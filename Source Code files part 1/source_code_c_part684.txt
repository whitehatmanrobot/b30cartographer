UAMChgPassDlg:
            DbgPrint_((DBGBUFF, "Change password dialog must be implemented"));
            theResult = kNotForUs;
            break;
                        
        default:
            //
            //If we get here then we were asked to handle a routine that
            //we don't support. Return the appropriate error code.
            //
                                    
            DbgPrint_((DBGBUFF, "Unsupported function selector in MSUAM main() (%d)", inUAMArgs->command));

            theResult = kNotForUs;
            break;
    }
    
    return(theResult);
}

#pragma export off

// ---------------------------------------------------------------------------
//		 MS_UAMOpen()
// ---------------------------------------------------------------------------
//	This is called by the device package. It is not a required function but
//	we use it to initialize our UAM code. Note that when we encounter an
//	error we don't make an effort to clean up. Instead we return userCanceledErr
//	in which case our UAMClose function will be called by AppleShare Client.

OSStatus MS_UAMOpen(UAMArgs *inUAMArgs)
{
	short theUAMConfig = 0;
    
    DbgPrint_((DBGBUFF, "MS_UAMOpen() enter..."));
		
	//
	//Get the name of the server we want to log into.
	//
	UAM_PStrCopy(inUAMArgs->Opt.open.objectName, gServerName, sizeof(gServerName));
	
	//
	//Copy the zone name for. If it's NULL, then we
	//don't have a zone name.
	//
	if (inUAMArgs->Opt.open.zoneName != NULL)
	{
		//
		//01.16.02: Pass maximum length to string copy routine.
		//
		UAM_PStrCopy(inUAMArgs->Opt.open.zoneName, gZoneName, sizeof(gZoneName));
	}
	else
    {
        DbgPrint_((DBGBUFF, "No AppleTalk zone name passed to UAM"));

		gZoneName[0] = 0;
    }
							
	gContextInited 		= false;		//Been through PwdDialog before?	
	gGuestLogon 		= false;	//Is guest our logon choice?
	gDialog				= NULL;		//So we can see if we really got it.
	gPwdDialogFilter	= NULL;
	gLineItem			= NULL;
	gAFPVersion[0]		= 0;
	gUserName[0]		= 0;
	gServerAddress		= inUAMArgs->Opt.open.srvrAddress;
	gEventCallbackUPP	= inUAMArgs->callbacks->EventCallbackUPP;		
	gTriedKeychain		= false;
	
	//
	//Get the MSUAM preferences from the prefs file.
	//
	ZeroMemory(&gUAMPreferences, sizeof(UAM_PREFERENCES));
	UAM_RetrieveUAMPreferenceData(&gUAMPreferences);

	UAM_KCInitialize(inUAMArgs);
    
    gPwdDialogFilter	= NewModalFilterUPP((ModalFilterUPP)MS_PwdDialogFilter);
    gLineItem			= NewUserItemUPP((UserItemUPP)UAM_FrameDialogItem);

	//
	//Get the AFP version and the default user name. This function finds
	//a match which is the highest AFP version supported by both the client
	//and server.
	//
	UAM_GetAFPVersionString(	
			inUAMArgs->Opt.open.srvrInfo,
			inUAMArgs->callbacks,
			gAFPVersion,
			gUserName 			);
	
	//
	//gUserName can be null, we just capture here during debugging to
	//ensure we're getting the name properly.
	//
	Assert_(PSTR_LENGTH(gUserName) != 0);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
	
	if (PSTR_LENGTH(gAFPVersion) == 0)
	{
		//
		//No AFPVersion, no logon...
		//
		
		UAM_ReportError(uamErr_NoAFPVersion);
		return(userCanceledErr);
	}
					
	gSupportsChngPwd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsChngPswd) != 0);
												
	//
	//Get the list of supported UAMs from a utility routine. This data
	//is necessary in the password dialog code.
	//							
	UAM_GetSupportedUAMS(
			inUAMArgs,
            gAFPVersion,
			&gSupportedUAMs
			);
	
	//
	//We should never get here if the following is false, but we
	//check just to be on the safe side.
	//
	if (	((gSupportedUAMs & kMSUAMSupported) 	== 0)	&&
			((gSupportedUAMs & kMSUAM_V2_Supported) == 0)	) 
	{
		Assert_(0);
		
		UAM_ReportError(afpBadUAM);
		return(userCanceledErr);
	}
	
	UAM_VersionString(gUAMVersionString);
    
    //
    //Set the maximum allowed password length. This may be changed and reset
    //later by the change password UI.
    //
    UAM_SetMaximumPasswordLength(false);
    
	//
	//This is how we tell AppleShare what our UAM supports. We have
	//our own password dialog, we support change password, and we
	//use our own change password dialog.
	//
	
	theUAMConfig |= BIT_0;	//Custom login dialog
	theUAMConfig |= BIT_2;	//We support change password
	theUAMConfig |= BIT_3;	//Custom change password dialog
	
	inUAMArgs->result = theUAMConfig;
		
	return(noErr);
}


// ---------------------------------------------------------------------------
//		 MS_UAMClose()
// ---------------------------------------------------------------------------
//	Like UAMOpen, UAMClose has no specific purpose as defined by the device
//	manager. We use it to clean up our allocated storage and globals.

void MS_UAMClose(void)
{
    DbgPrint_((DBGBUFF, "MS_UAMClose() enter..."));
    
    //
    //Release memory allocated for the password edit stuff.
    //
    UAM_CleanupPasswordFieldItems();
    
    if (gDialog != NULL)
    {
        //
        //If we put up our login dialog, get rid of it.
        //
        DisposeDialog(gDialog);        
    }
    
    if (gPwdDialogFilter)	DisposeRoutineDescriptor(gPwdDialogFilter);
    if (gLineItem)			DisposeRoutineDescriptor(gLineItem);
}


// ---------------------------------------------------------------------------
//		 MS_TestTextEntryLength()
// ---------------------------------------------------------------------------
//	We don't allow entries in the login dialog to be of any length. This
//	function tests the length of the entered text in an edit field. It will
//	modify the event record appropriately to inhibit processing of the
//	keystroke if it will take the field over the limit.

Boolean MS_TestTextEntryLength(
	DialogPtr 		inDialog,
	EventRecord*	inEvent,
	short 			inItem,
	short			inMaxLengthAllowed
)
{
	Str255	theString;
	Boolean	theResult 	= false;
        
	if (GetDialogKeyboardFocusItem(inDialog) == inItem)
	{
            UAM_GetDialogEditText(inDialog, inItem, theString);
            
            if (PSTR_LENGTH(theString) >= inMaxLengthAllowed)
            {
                SysBeep(1);
        
                inEvent->what 		= nullEvent;
                inEvent->message	= 0;
                theResult 	  		= true;
                
                //
                //If the string length is currently too long, then
                //we have to chop off the end of the string to the
                //proper length.
                //
                if (PSTR_LENGTH(theString) > inMaxLengthAllowed)
                {
                    //
                    //Easy way out, pascal style strings have length
                    //byte in front. Just adjust it.
                    //
                    theString[0] = inMaxLengthAllowed;
                    
                    //
                    //Now set the text in the edit field with the new string.
                    //
                    UAM_SetDialogEditText(inDialog, inItem, theString);
                }
            }
	}
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_PwdDialogFilter()
// ---------------------------------------------------------------------------
//	Filter function for the password dialog. We have this so we can capture
//	command keys and keep length requirements for the user name in the login 
//	dialog.

pascal Boolean MS_PwdDialogFilter(DialogRef inDialog, EventRecord *inEvent, short *inItem)
{
	short	theCode;
	Str255	theString;
	Boolean	theResult = false;
    SInt16	theMaxUserNameLength;
    
    //
    //For MS2.0 and 3.0 we allow 64 character passwords. 32 characters
    //for Microsoft V1.0.
    //
    theMaxUserNameLength = (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?
                                UAM_USERNAMELEN_V3 : UAM_USERNAMELEN;
		
	if ((inEvent->what == keyDown) || (inEvent->what == autoKey))
	{
		theCode = (inEvent->message & charCodeMask);
        
		//
		//04.30.01: Don't allow cmd selections when autoKey'ing.
		//
		if ((inEvent->modifiers & cmdKey) && (inEvent->what != autoKey))
		{
			switch(theCode)
			{
				case 'g':
				case 'G':
					*inItem   = DITEM_GuestRadio;
					theResult = true;
					break;
				
				case 'r':
				case 'R':
					*inItem   = DITEM_RegRadio;
					theResult = true;
					break;
					
				case 's':
				case 'S':
					*inItem	  = DITEM_ChangePwd;
					theResult = true;
					break;
									
				case 'a':
				case 'A':
					*inItem   = DITEM_Keychain;
					theResult = true;
					break;
				
				//
				//Handle edit commands from the user. We don't allow any
				//editing commands in the password field. This mimicks
				//Apple's own UAM's.
				//
				
				case 'c':
				case 'C':
				case 'v':
				case 'V':
				case 'x':
				case 'X':
                    theResult = true;
                    break;
					
				default:
					break;
			}
		}
		else
		{
			//
			//Don't allow more than UAM_USERNAMELEN maximum characters in edit field.
			//
			
			if (GetDialogKeyboardFocusItem(inDialog) == DITEM_UserName)
			{
				UAM_GetDialogEditText(inDialog, DITEM_UserName, theString);
				
				switch(theCode)
				{
					case UAMKey_BackDel:
					case UAMKey_Left:
					case UAMKey_Right:
					case UAMKey_Return:
					case UAMKey_Enter:
					case UAMKey_Escape:
					case UAMKey_Tab:
						break;
						
					default:
                        if (PSTR_LENGTH(theString) >= theMaxUserNameLength)
                        {
                            SysBeep(1);
                        
                            inEvent->what = nullEvent;
                            theResult 	  = true;
                        }
						break;
				}
			}
		}
	}
	else
	{
		if (gEventCallbackUPP)
		{
			//
			//If we're not handling the event ourselves, then call the
			//event callback which gives AS and the Chooser a chance
			//to update it's windows, etc.
			//
			
            #ifndef UAM_TARGET_CARBON
            CallUniversalProc(gEventCallbackUPP, kEventCallbackProcInfo, inEvent);
            #else
			gEventCallbackUPP(inEvent);
            #endif
		}
	}
    
    if (theResult == FALSE)
    {
        theResult = StdFilterProc(inDialog , inEvent, inItem);
    }
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_UAMPwdDialog()
// ---------------------------------------------------------------------------
//	This is where we put up our password dialog. The buffers pointed to by
//	'inUserName' and 'inPassword' end up getting passed directly to the
//	UAMLogin function.
//
//	The buffer passed for the user name and password is 64 bytes long. Don't
//	use more than that! 

OSStatus MS_UAMPwdDialog(UAMArgs *inUAMArgs)
{
	short			theItem, x;
	Str255			theStr;
	OSStatus		theError	= noErr;
	Boolean			theLoop 	= true;
    
    DbgPrint_((DBGBUFF, "MS_UAMPwdDialog() enter..."));
	
	Assert_(gPwdDialogFilter 	!= NULL);
	Assert_(gLineItem 			!= NULL);
		
	//
	//Determine which user name to use, the default or the
	//one supplied by the client (if any). gUserName is filled
	//in originally during the UAMOpen call.
	//
	if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) != 0)
	{
		//
		//01.16.02: Pass maximum length to string copy routine.
		//
		UAM_PStrCopy(inUAMArgs->Opt.pwDlg.userName, gUserName, sizeof(gUserName));
	}
	
	//
	//If we already tried the keychain and failed, we don't want
	//to try again or we'll loop forever. Give the user a chance
	//to enter the correct name and password.
	//
	//NOTE: We check to see if the cmd key is down, if it is, then
	//we bypass the keychain stuff alltogether. Maybe the user wants
	//to change his password!?!?!
	//
	if ((gTriedKeychain == false) && (UAM_KCAvailable()) && (!UAM_KeyDown(KEY_Command)))
	{
		gTriedKeychain = true;
		
		if ( (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) 	!= 0)	&&
			 (strlen((char*)inUAMArgs->Opt.pwDlg.password)	!= 0)	)
		{
			//
			//We were supplied a username and password by the AFP
			//client. This means the user clicked a keychain entry.
			//
			goto exit;
		}
		else 
		{
            DbgPrint_((DBGBUFF, "Checking keychain for stored credentials..."));

			theError = UAM_KCFindAppleSharePassword(
							gUserName,
							inUAMArgs->Opt.pwDlg.password,
							gServerName,
							NULL
			);
			
			if (theError == noErr)
			{
				DbgPrint_((DBGBUFF, "Credentials found in the keychain!"));
				
				//
				//Fill in the user name for the UAMArgs.
				//
				if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) == 0)
				{
					UAM_PStrCopy(gUserName, inUAMArgs->Opt.pwDlg.userName);
				}
				
				//
				//The password must always passed back in UAMArgs as a C string.
				//
				_p2cstr(inUAMArgs->Opt.pwDlg.password);

				//
				//A password was found so try to logon.
				//
				goto exit;
			}
			else if (	(theError != errKCItemNotFound)		&&
						(theError != userCanceledErr)		)
			{
				//
				//Only report "real" errors.
				//
				UAM_ReportError(theError);
			}
            else
            {
                DbgPrint_((DBGBUFF, "No credentials found in the keychain!"));
            }
		}
	}
	else if ((UAM_KCAvailable()) && (UAM_KeyDown(KEY_Command)))
	{
		//
		//If the user is holding the cmd key down, then we don't want to
		//try the keychain the next time through either.
		//
		gTriedKeychain = true;
	}
			
	//
	//Display the server name in the dialog title text
	//which is located at the top of the dialog. This must be
	//done even if we've been here before.
	//
	
	ParamText(gServerName, NULL, NULL, NULL);
	
	//
	//If we haven't been through here before, then we need to do
	//all the prep work.
	//
		
	if (!gContextInited)
	{
		gDialog = GetNewDialog(DLOG_Login, NULL, (WindowPtr)-1);
        
		if (gDialog == NULL)
		{
            DbgPrint_((DBGBUFF, "Failed to get logon dialog resource!"));
            
			//
			//If we couldn't get the dialog, then we're either out
			//of memory or the resource couldn't be found.
			//
			
			theError = MemError();
			if (theError == noErr)
				theError = ResError();
			if (theError == noErr)
				theError = resNotFound;
			
			UAM_ReportError(theError);
			return(userCanceledErr);
		}
		
		//
		//Setup our custom user item that displays the divider line at the
        //top of the dialog window.
        //	
		UAM_SetupDialogUserItem(gDialog, DITEM_Line, gLineItem, userItem);
        		
		//
		//Set up the default user name and password (if any). If a user name
		//exists, then make the password field the active field ready for input.
		//
        
		//
		//If we've not been here before, then we want to use the user name
		//entered in the Sharing Setup Control Panel (or Chooser).
		//
		
		if (PSTR_LENGTH(gUserName) != 0)
		{
			UAM_SetDialogEditText(gDialog, DITEM_UserName, gUserName);
            UAM_MakeEditItemFocus(gDialog, DITEM_UserName);
		}
		else
		{
			UAM_HiliteDialogControlItem(gDialog, 1, 255);
		}
		
        //
        //Initialize the password edit control so it behaves properly.
        //
        UAM_InitializeDialogPasswordItem(gDialog, DITEM_Password);

		//
		//Now we set up the guest and registered user radio buttons and the
		//change password button as determined by UAM_GetServerInfo().
		//
		
		if (!gSupportsChngPwd)
        {
            //
            //Change password is not supported by the server for this user. We
            //gray out the button to make it unselectable.
            //
			UAM_HiliteDialogControlItem(gDialog, DITEM_ChangePwd, 255);
		}
		
		if (!(gSupportedUAMs & kGuestSupported))
		{
			//
			//No guest support, we don't need the guest radio button.
			//
			UAM_HiliteDialogControlItem(gDialog, DITEM_GuestRadio, 255);
		}
		
		//
		//Set the initial radio for the default/current login method.
		//
		
		if (gGuestLogon)
		{
			UAM_SetDialogControlValue(gDialog, DITEM_GuestRadio, 1);
			UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 	 0);
			
			UAM_HiliteDialogControlItem(gDialog, DITEM_ChangePwd, 255);
			
			for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
				HideDialogItem(gDialog, x);
			}
			
			UAM_HiliteDialogControlItem(gDialog, 1, 0);
		}
		else {
			UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 1);
		}
        
		//
		//If the client is not allowed to save password for this server,
		//then we gray out the keychain checkbox.
		//
		if (UAM_KCAvailable() == false)
		{
			UAM_HiliteDialogControlItem(gDialog, DITEM_Keychain, 255);
		}
		else if (gTriedKeychain)
		{
            UAM_SetPasswordText(gDialog, DITEM_Password, "\p");
            UAM_MakePasswordItemFocusItem(gDialog, DITEM_Password);
		}
        
		//
		//Set the encryption type checkbox to the proper value.
		//
		if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)
		{
			UAM_SetDialogControlValue(gDialog, DITEM_StrongEncryption, 1);
		}

        SetDialogDefaultItem(gDialog, DITEM_OK);
        SetDialogCancelItem(gDialog, DITEM_Cancel);
		
		//
		//This flag lets up know that we've initialized our login dialog
		//and that we don't need to do it again when/if we come here again.
		//
		
		gContextInited	= true;
        
        SetPortDialogPort(gDialog);
        ShowWindow(GetDialogWindow(gDialog));
	}
	else
	{
		UAM_SetDialogEditText(gDialog, DITEM_UserName, gUserName);
        UAM_SetPasswordText(gDialog, DITEM_Password, "\p");
		
		//
		//Hilite the password selection.
		//
		UAM_MakePasswordItemFocusItem(gDialog, DITEM_Password);
	}
	
	do
	{
		ModalDialog(gPwdDialogFilter, &theItem);
		
		switch(theItem)
		{
			case DITEM_OK:				
				gGuestLogon 	= (UAM_GetDialogControlValue(gDialog, DITEM_GuestRadio) != 0);
				theError		= noErr;
				theLoop 		= false;
				
				if (gGuestLogon)
				{
					inUAMArgs->Opt.pwDlg.userName[0] = 0;
					inUAMArgs->Opt.pwDlg.password[0] = 0;
				}
				else
				{					
					UAM_GetPasswordText(	gDialog,
                                            DITEM_Password,
                                            inUAMArgs->Opt.pwDlg.password	);
					
					UAM_GetDialogEditText(	gDialog,
                                            DITEM_UserName,
                                            inUAMArgs->Opt.pwDlg.userName	);

                    //
                    //Don't allow blank passwords for 2 reasons:
                    //
                    //	1. It is not secure and user can use Apple UAM for this.
                    //	2. This covers a security hole that is generated after changing 
                    //	   passwords on these servers using Apple's clear text UAM.
                    //
                    if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0)
                    {
                        UAM_StandardAlert(
                                uamErr_PasswordMessage,
                                uamErr_NoBlankPasswordsAllowed,
                                NULL
                                );
                                
                        //
                        //Continue the login dialog loop so the user can make changes.
                        //
                        theLoop = true;
                    }
                    
                    //
                    //The password must always be in C style string form.
                    //
                    _p2cstr(inUAMArgs->Opt.pwDlg.password);
				}

				//
				//Only save the preferences if the user hits "Connect".
				//
				UAM_SaveUAMPreferenceData(&gUAMPreferences);
				break;
				
			case DITEM_Cancel:
				//
				//VERSION 5.0: To force cancellation, we pass userCanceledError(-128)
				//back to the Chooser. The old UAM would pass back dsForcedQuit which
				//is the wrong value. This would cause an error dialog when cancelling.
				//
				DbgPrint_((DBGBUFF, "Cancel selected in login dialog."));
                
				theError	= userCanceledError;
				theLoop 	= false;
				break;
			
			case DITEM_GuestRadio:
				//
				//Set up the controls in the dialog for guest login. We don't
				//need the user name and password items, so hide them from
				//the user. We must explicitly enable the 'OK' button since
				//it may have been disabled by the gate stuff.
				//
				
				if (UAM_IsDialogControlActive(gDialog, DITEM_GuestRadio))
				{
					UAM_SetDialogControlValue(gDialog, DITEM_GuestRadio, 1);
					UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 	 0);
										
					for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
						HideDialogItem(gDialog, x);
					}
				}
				break;
			
			case DITEM_RegRadio:
				//
				//Now we need all the items back that were hidden above, make
				//them visible.
				//
				if (UAM_GetDialogControlValue(gDialog, DITEM_RegRadio) <= 0)
				{
					UAM_SetDialogControlValue(gDialog, DITEM_GuestRadio, 0);
					UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 	 1);
					
					for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
						ShowDialogItem(gDialog, x);
					}
													
					UAM_GetDialogEditText(gDialog, DITEM_UserName, theStr);
                    UAM_MakeEditItemFocus(gDialog, DITEM_UserName);
					
					if ((gSupportsChngPwd) && (theStr[0] != 0)) {
						UAM_HiliteDialogControlItem(gDialog, DITEM_ChangePwd, 0);
					}
				}
				break;
				
			case DITEM_ChangePwd:
				UAM_GetPasswordText(	gDialog,
                                        DITEM_Password,
                                        inUAMArgs->Opt.pwDlg.password	);
				UAM_GetDialogEditText(	gDialog,
                                        DITEM_UserName,
                                        inUAMArgs->Opt.pwDlg.userName	);
				
				theError = UAM_ChangePwd(inUAMArgs);
                
				switch(theError)
				{
					case CHNGPSWD_USER_CANCELED:
						break;
					
					case CHNGPSWD_UPDATE_KEYCHAIN:
						//
						//We need to re-add the keychain item with the
						//correct password. Flag it by checking the box.
						//
						UAM_SetDialogControlValue(gDialog, DITEM_Keychain, 1);
						
						//
						//Just fall on through and handle the normal case.
						//
						
					case CHNGPSWD_NOERR:
						//
						//Set the password field and buffer with the new password in case
						//we end back here later.
						//
						
						UAM_SetPasswordText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
						
	                    //
	                    //The password must always be in C style string form.
	                    //
	                    _p2cstr(inUAMArgs->Opt.pwDlg.password);

						theError = noErr;
						theLoop  = false;
						break;
						
					default:
						UAM_ReportError(theError);
						
						//
						//Make sure in debug that the password field is cleared in
						//an error condition.
						//
						Assert_(PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0);
						
						//
						//We do this here so we clear the password field like we should
						//do whenever there is a failure.
						//
						UAM_SetPasswordText(gDialog, DITEM_Password, "\p");
						
						//
						//Because we use ParamText() we must manually force an update
						//of the dialog or things won't redraw properly.
						//
						#ifndef UAM_TARGET_CARBON
						InvalRect(&gDialog->portRect);
						#endif
						break;
				}
			
				//
				//Must reset our user's name since UAM_ChangePwd() uses ParamText()
				//to set some strings of it's own.
				//
				
				ParamText(gServerName, NULL, NULL, NULL);
				break;
							
			case DITEM_Keychain:
				UAM_ToggleDialogControl(gDialog, DITEM_Keychain);
				break;
			
			case DITEM_StrongEncryption:
				//
				//Update the required encryption dynamically.
				//
				UAM_ToggleDialogControl(gDialog, DITEM_StrongEncryption);
				
				if (UAM_GetDialogControlValue(gDialog, DITEM_StrongEncryption) > 0)
				{
					gUAMPreferences.flags |= UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;
				}
				else
				{
					gUAMPreferences.flags &= ~UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;
					
					UAM_StandardAlert(
						uamErr_WARNINGMessage,
						uamErr_UsingWeakAuthentication,
						NULL
						);
				}
				break;
			default:
				break;
		}
		
	}while(theLoop);

exit:
    DbgPrint_((DBGBUFF, "Exit MS_UAMPwdDialog() return code = %d", (int)theError));
	return(theError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uamrsa32.c ===
/*
 *  UAMRSA32.c
 *  MSUAM
 *
 *  Created by MConrad on Fri Jun 08 2001.
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */

#include <Carbon/Carbon.h>
#include "MWERKSCrypto.h"

void *RSA32Alloc(unsigned long cb)
{
	return malloc(cb);
}

	
void RSA32Free(void *pv)
{
	free(pv);
	return;
}

unsigned int
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    )
{
	#pragma unused(ppbRandSeed)
	#pragma unused(pcbRandSeed)
	#pragma unused(pbBuffer)
	#pragma unused(dwLength)
	
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uammain.h ===
// ===========================================================================
//	UAMMain.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include <CoreFoundation/CoreFoundation.h>
#include <Carbon/Carbon.h>
#include "ClientUAM.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//Our type and creator
//
#define UAM_CREATOR			FOUR_CHAR_CODE('NTAM')
#define UAM_TYPE			kUAMFileType
#define UAM_TYPE_CODE		139

#define UAMResourceSignatureSize 	8
#define AFP_IconSize  				128
#define	DLOG_Login					12128	//Login dialog

//
//This is needed to tell the Chooser that the user requests
//to cancel the login operation. This is not defined anywhere,
//this is what Leland Wallace (randall@apple.com) from Apple said to use.
//
#define userCanceledError		-128

//
//Our connection method names for the login dialog. Note that these
//items are not to be localized!
//
#define STR_TCPConnection			"TCP/IP"
#define STR_AppleTalkConnection		"AppleTalk"

//
//Password expiration notices occur when within this # of days
//
#define MINIMUM_DAYS_TILL_EXPIRATION	14

//
//The following are constants for the items in the login dialog.
//
#define DITEM_Connect			1
#define DITEM_Line				5
#define DITEM_GuestRadio		6
#define DITEM_RegRadio			7
#define DITEM_StaticName		8
#define	DITEM_UserName			10
#define DITEM_Password			11
#define DITEM_ChangePwd			13
#define DITEM_Keychain			14
#define DITEM_StrongEncryption	15

#define DITEM_FirstHideItem		DITEM_StaticName
#define DITEM_LastHideItem		DITEM_StrongEncryption

#define UAM_ReplaceKeyQuestion	1500

//
//NT specific error codes we use.
//
enum {
	afpNTNewPasswordMismatchErr		= -13000,
	afpNTChangePasswordFailed		= -13001,
	afpNTAccountDisabled			= -13002,
	afpNTInvalidWorkstation			= -13003,
	afpNTInvalidLogonHours			= -13004,
	afpNTPasswordExpired			= -13005,
	afpNTPasswordCantChange			= -13006,
	afpNTPasswordHistConflict		= -13007,
	afpNTPasswordTooShort			= -13008,
	afpNTPasswordTooRecent			= -13009,
	afpNTPasswordRestriction		= -13010,
	afpNTAccountRestriction			= -13011,
	afpNTPasswordProcessFailure		= -13012,	//Encryption or host mapping error
	
	uamPasswordExpiresInOneDay		= 1002
};

typedef unsigned char Str64[64];

//
//Prototypes for the main module live here.
//

EXTERN_API( OSStatus )
UAMMain(UAMArgs *inUAMArgs);

OSStatus
MS_UAMOpen(UAMArgs *inUAMArgs);

void	
MS_UAMClose(void);

Boolean
MS_TestTextEntryLength(
	DialogPtr 		inDialog,
	EventRecord*		inEvent,
	short 			inItem,
	short			inMaxLengthAllowed
);

pascal Boolean 
MS_PwdDialogFilter(DialogRef inDialog, EventRecord *inEvent, short *inItem);

OSStatus
MS_UAMPwdDialog(UAMArgs *inUAMArgs);

OSStatus
MS_UAMLogin(UAMArgs *inUAMArgs);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uamdlogtext.h ===
// ===========================================================================
//	UAMDLOGText.h 			 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once


void				UAM_AdjustText			( ControlHandle );
void				UAM_DoScrolling			( ControlHandle, short );
pascal void			UAM_ScrollText			( ControlHandle, short );
void				UAM_SetScrollBar		( ControlHandle );
void				UAM_UpdateText			( DialogPtr );
void				UAM_SetSText			( DialogPtr, short );
void				UAM_MakeText			( DialogPtr, short, short, short );
void 				UAM_FixText				(DialogPtr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uamdlogtext.cpp ===
// ===========================================================================
//	UAMDLOGText.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// Utilities for maintaining a scrolling text field in a dialog.
//
// ===========================================================================

#include <ControlDefinitions.h>

#include "UAMDLOGUtils.h"
#include "UAMDLOGText.h"

// ---------------------------------------------------------------------------
//		 UAM_AdjustText()
// ---------------------------------------------------------------------------

void UAM_AdjustText(ControlHandle theScrollBar)
{
	DialogPtr	dialog;
	TEHandle	dTE;
	short		scrollValue;
	char		saveState;
	
	dialog = (*theScrollBar)->contrlOwner;
	dTE = UAM_DLOG(dialog).dialogTE;

	saveState = HGetState((Handle)dTE);
	HLock((Handle)dTE);
	
	scrollValue = GetControlValue( theScrollBar);
	UAM_DLOG(dialog).deltaV = Abs(UAM_DLOG(dialog).vOffset) - scrollValue;
	UAM_DLOG(dialog).vOffset = scrollValue;
	
	if (UAM_DLOG(dialog).deltaV)
		TEScroll(0, UAM_DLOG(dialog).deltaV, dTE);
	
	UAM_DLOG(dialog).deltaV = 0;
	
	HSetState((Handle)dTE, saveState);
}


// ---------------------------------------------------------------------------
//		 UAM_ScrollText()
// ---------------------------------------------------------------------------

pascal void UAM_ScrollText(ControlHandle theControl, short thePart)
{
	short		delta, newValue;
	short		ctlMin, ctlMax;
	UInt32		tix;
	DialogPtr	dialog;
	Rect		r;
	
	dialog = (*theControl)->contrlOwner;
	r = (*(UAM_DLOG(dialog).dialogTE))->viewRect;
	
	switch(thePart)
	{
		case kControlUpButtonPart:
			delta = -16;
			break;
		case kControlDownButtonPart:
			delta = 16;
			break;
		case kControlPageUpPart:
			delta = Min(-(r.bottom - r.top) / 2, -1);
			Delay(10, &tix);
			break;
		case kControlPageDownPart:
			delta = Max((r.bottom - r.top) / 2, 1);
			Delay(10, &tix);
			break;
		default:
			return;
			break;
	}
	
	newValue = GetControlValue( theControl) + delta;
	
	ctlMax = GetControlMaximum( theControl);
	ctlMin = GetControlMinimum( theControl);
	
	if (newValue > ctlMax)
		newValue = ctlMax;
	else if (newValue < ctlMin)
		newValue = ctlMin;
	
	SetControlValue( theControl, newValue);
	UAM_AdjustText( theControl);
}


// ---------------------------------------------------------------------------
//		 UAM_SetScrollBar()
// ---------------------------------------------------------------------------

void UAM_SetScrollBar(ControlHandle theScrollBar)
{
	short		theHeight;
	DialogPtr	dialog;
	Rect		winRect;
	TEHandle	dTE;	
	
	dialog = (*theScrollBar)->contrlOwner;
	dTE = UAM_DLOG(dialog).dialogTE;
	winRect = UAM_DLOG(dialog).dialogTERect;
	
	theHeight = TEGetHeight( (*dTE)->nLines, 0, dTE);
	
	if (theHeight > (winRect.bottom - winRect.top))
		SetControlMaximum( theScrollBar, (theHeight - (winRect.bottom - winRect.top)));
	else {
		SetControlValue( theScrollBar, 0);
		SetControlMaximum( theScrollBar, 0);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_UpdateText()
// ---------------------------------------------------------------------------

void UAM_UpdateText(DialogPtr dialog)
{
	Rect 		r;
	
	r = UAM_DLOG(dialog).dialogTERect;
	InsetRect(&r, textMargin, textMargin);
	TEUpdate(&r, UAM_DLOG(dialog).dialogTE);
	FrameRect(&UAM_DLOG(dialog).dialogTERect);
}
			

// ---------------------------------------------------------------------------
//		 UAM_FixText()
// ---------------------------------------------------------------------------

void UAM_FixText(DialogPtr dialog)
{
	TEHandle	dTE;
	char		saveState;
	
	dTE = UAM_DLOG(dialog).dialogTE;
	
	saveState = HGetState((Handle)dTE);
	HLock((Handle)dTE);
	
	(*dTE)->viewRect = UAM_DLOG(dialog).dialogTERect;
	
	(*dTE)->viewRect.right = (*dTE)->viewRect.right;
	(*dTE)->viewRect.bottom = (*dTE)->viewRect.bottom;
	
	InsetRect( &((*dTE)->viewRect), textMargin, textMargin);
	(*dTE)->destRect = (*dTE)->viewRect;
	
	TECalText( dTE);

	HSetState((Handle)dTE, saveState);
}


// ---------------------------------------------------------------------------
//		 UAM_SetSText()
// ---------------------------------------------------------------------------

void UAM_SetSText(DialogPtr dialog, short textID)
{
	Handle			textHndl;
	Rect			r;
	StScrpHandle	hST;
	
	textHndl = Get1Resource('TEXT', textID);

	if (textHndl != NULL)
	{
		HLock((Handle)UAM_DLOG(dialog).dialogTE);
		HLock(textHndl);
				
		r = UAM_DLOG(dialog).dialogTERect;
		InsetRect(&r, textMargin, textMargin);
		EraseRect(&r);
		InvalRect(&r);
	
		TESetText(*textHndl, GetHandleSize(textHndl), UAM_DLOG(dialog).dialogTE);
		
		hST = (StScrpHandle)Get1Resource('styl', textID);
		if (hST != NULL) {
			HidePen();
			TEUseStyleScrap( 0, 32767, hST, TRUE, UAM_DLOG(dialog).dialogTE);
			ShowPen();
		}

		UAM_DLOG(dialog).vOffset = 0;
		UAM_DLOG(dialog).deltaV  = 0;
		
		SetControlValue(UAM_DLOG(dialog).scrollBar, 0);
		UAM_FixText(dialog);
		UAM_AdjustText(UAM_DLOG(dialog).scrollBar);
		
		UAM_SetScrollBar( UAM_DLOG(dialog).scrollBar);
		
		HUnlock((Handle)UAM_DLOG(dialog).dialogTE);
		HUnlock(textHndl);
		
		ReleaseResource(textHndl);
		ReleaseResource((Handle)hST);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_MakeText()
// ---------------------------------------------------------------------------

void UAM_MakeText(DialogPtr dialog, short textItem, short scrollItem, short textID)
{
	Rect	textRect, r;
		
	UAM_DLOG(dialog).dialogTERect = UAM_GetItemRect(dialog, textItem);
	textRect = UAM_DLOG(dialog).dialogTERect;
	
	UAM_DLOG(dialog).hasScrollBar = TRUE;
	
	InsetRect(&textRect, textMargin, textMargin);
	UAM_DLOG(dialog).dialogTE = TEStyleNew(&textRect, &textRect);
	
	r = UAM_GetItemRect(dialog, scrollItem);
	UAM_DLOG(dialog).scrollBar = NewControl(dialog, &r, "\p", TRUE, 0, 0, 0, 16, 0);
	UAM_SetupDialogUserItem(dialog, scrollItem, (UserItemUPP)UAM_DLOG(dialog).scrollBar, ctrlItem);
	
	UAM_SetSText(dialog, textID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uamdlogutils.cpp ===
// ===========================================================================
//	UAMDLOGUtils.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// General dialog utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#include <Dialogs.h>
#include <Events.h>
#include <Controls.h>
#include <Sound.h>
#include <ControlDefinitions.h>

#include <ctype.h>

#include "UAMUtils.h"
#include "UAMListBox.h"
#include "UAMDLOGText.h"
#include "UAMDLOGUtils.h"
#include "UAMDebug.h"
	

// ---------------------------------------------------------------------------
//		 UAM_GetScreenBounds()
// ---------------------------------------------------------------------------

Rect UAM_GetScreenBounds()
{
	GrafPtr		savePort,p;
	Rect		screenBounds;
	
	GetPort(&savePort);
	
	p = (GrafPtr)NewPtr(sizeof(GrafPort));
	OpenPort(p);
	
	screenBounds = p->portBits.bounds;
	
	ClosePort(p);
	DisposePtr((Ptr)p);
	
	return(screenBounds);
}


// ---------------------------------------------------------------------------
//		 UAM_GetCHandle()
// ---------------------------------------------------------------------------

ControlHandle UAM_GetCHandle(DialogPtr inDialog, short item)
{
	short	itype;
	Rect	irect;
	Handle	ihan;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	return((ControlHandle)ihan);
}


// ---------------------------------------------------------------------------
//		 UAM_GetItemRect()
// ---------------------------------------------------------------------------

Rect UAM_GetItemRect(DialogPtr inDialog, short item)
{
	short	itype;
	Rect	irect;
	Handle	ihan;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	return(irect);
}


// ---------------------------------------------------------------------------
//		 UAM_ToggleControl()
// ---------------------------------------------------------------------------

void UAM_ToggleControl(DialogPtr inDialog, short item)
{
	UAM_SetCValue(inDialog, item, UAM_GetCValue(inDialog, item) == 0);
}


// ---------------------------------------------------------------------------
//		 UAM_GetText()
// ---------------------------------------------------------------------------

void UAM_GetText(DialogPtr inDialog, short item, Str255 *theText)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
		
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	
	if ((itype == editText)||(itype == editText + itemDisable))
		GetDialogItemText(ihan, *theText);
}


// ---------------------------------------------------------------------------
//		 UAM_SetText()
// ---------------------------------------------------------------------------

void UAM_SetText(DialogPtr inDialog, short item, Str255 theText)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	if ((itype == editText)
		||(itype == editText+itemDisable)
		||(itype == statText)
		||(itype == statText+itemDisable))
		
		SetDialogItemText(ihan, theText);
}


// ---------------------------------------------------------------------------
//		 UAM_HiliteItem()
// ---------------------------------------------------------------------------

void UAM_HiliteItem(DialogPtr inDialog, short item, short value)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	HiliteControl((ControlHandle)ihan, value);
}


// ---------------------------------------------------------------------------
//		 UAM_IsActive()
// ---------------------------------------------------------------------------

Boolean UAM_IsActive(DialogPtr inDialog, short item)
{
	ControlHandle	theHandle;
	
	theHandle = UAM_GetCHandle(inDialog, item);
	if (theHandle)
	{
		return(((*theHandle)->contrlHilite != 255));
	}
	
	return(false);
}


// ---------------------------------------------------------------------------
//		 UAM_GetCValue()
// ---------------------------------------------------------------------------

short UAM_GetCValue(DialogPtr inDialog, short item)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	short	result;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	result = GetControlValue((ControlHandle)ihan);
			
	return(result);
}


// ---------------------------------------------------------------------------
//		 UAM_SetCValue()
// ---------------------------------------------------------------------------

void UAM_SetCValue(DialogPtr inDialog, short item, short value)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	SetControlValue((ControlHandle)ihan, value);
}


// ---------------------------------------------------------------------------
//		 UAM_PositionDialog()
// ---------------------------------------------------------------------------

void UAM_PositionDialog(ResType theType, short theID)
{
	Rect	*theRect;
	Rect	screenBounds;
	Handle	theTemplate;
	short	left,top;
	
	screenBounds = UAM_GetScreenBounds();
	
	theTemplate = GetResource(theType, theID);
	theRect = (Rect *)*theTemplate;
	
	left = (screenBounds.right - (theRect->right - theRect->left)) / 2;
	top = (screenBounds.bottom - (theRect->bottom - theRect->top)) / 3;
	
	if (top < LMGetMBarHeight())
		top = LMGetMBarHeight() + 7;
	
	theRect->right = theRect->right + left - theRect->left;
	theRect->left = left;
	theRect->bottom = theRect->bottom + top - theRect->top;
	theRect->top = top;
}


// ---------------------------------------------------------------------------
//		 UAM_GetItemType()
// ---------------------------------------------------------------------------

short UAM_GetItemType(DialogPtr inDialog, short item)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
			
	return(itype);
}


// ---------------------------------------------------------------------------
//		 UAM_NewDialog()
// ---------------------------------------------------------------------------

DialogPtr UAM_NewDialog(short id, Boolean show)
{
	Ptr			storage;
	DialogPtr	dialog;
	short		x;
		
	storage = NewPtrClear(sizeof(UAMDialogRec));
	if (storage == NULL) {
		return(NULL);
	}
			
	dialog = GetNewDialog(id, storage, (WindowPtr) -1);
	if (dialog == NULL) {
		return(NULL);
	}
	
	SetPort(dialog);
	
	if (UAM_GetItemType(dialog, kStdOkItemIndex) == kButtonDialogItem) {
		SetDialogDefaultItem(dialog, kStdOkItemIndex);
	}
	
	if (UAM_GetItemType(dialog, kStdCancelItemIndex) == kButtonDialogItem) {
		SetDialogCancelItem(dialog, kStdCancelItemIndex);
	}

	SetDialogTracksCursor(dialog, true);

	if (show) {
		ShowWindow(dialog);
	}
		
	UAM_DLOG(dialog).hasScrollBar 	= FALSE;
	UAM_DLOG(dialog).supportCmdKeys	= TRUE;
	UAM_DLOG(dialog).customFilter	= NULL;
	UAM_DLOG(dialog).hasList		= false;
	
	for (x = 0; x < kMaxGatedItems; x++)
	{
		UAM_DLOG(dialog).gateItems[x].controlID		= 0;
		UAM_DLOG(dialog).gateItems[x].textID		= 0;
	}
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		UAM_DLOG(dialog).bulletItems[x].editID		= 0;
		UAM_DLOG(dialog).bulletItems[x].maxLength	= 0;
		UAM_DLOG(dialog).bulletItems[x].hTE			= NULL;
	}
	
	UAM_DLOG(dialog).scrollActionProc = NewControlActionProc(&UAM_ScrollText);
		
	InitCursor();
	return(dialog);
}
		

// ---------------------------------------------------------------------------
//		 UAM_Update()
// ---------------------------------------------------------------------------

void UAM_Update(DialogPtr inDialog)
{
	GrafPtr	savePort;
	
	GetPort(&savePort);
	SetPort(inDialog);
	
	BeginUpdate(inDialog);
		
	if (UAM_DLOG(inDialog).hasScrollBar) {
		UAM_UpdateText(inDialog);
	}
		
	if (UAM_DLOG(inDialog).hasList) {
		UAM_ListUpdate(inDialog);
	}
		
	DrawDialog(inDialog);
	DrawControls(inDialog);

	EndUpdate(inDialog);
	
	SetPort(savePort);
}


// ---------------------------------------------------------------------------
//		 UAM_DialogFilter()
// ---------------------------------------------------------------------------

pascal Boolean UAM_DialogFilter(DialogPtr inDialog, EventRecord *e, short *itemHit)
{
	Boolean 		result;
	short			thePart, temp;
	Point			pt;
	ControlHandle	theControl;
	ModalFilterUPP	theStdProc;
			
	result = FALSE;
	
	if (GetStdFilterProc(&theStdProc) == noErr)
	{
		if (CallModalFilterProc(theStdProc, inDialog, e, itemHit))
		{
			//
			//The standard proc handled everything for us, so exit.
			//
			return(TRUE);
		}
	}
	
	if (UAM_DLOG(inDialog).customFilter != NULL)
	{
		if (CallModalFilterProc(UAM_DLOG(inDialog).customFilter, inDialog, e, itemHit))
		{
			return(TRUE);
		}
	}
	
	switch(e->what)
	{
		case updateEvt:
			if ((DialogPtr)e->message == inDialog)
				UAM_Update(inDialog);
			break;
			
		case mouseDown:
			pt = e->where;
			GlobalToLocal(&pt);
			
			if (UAM_DLOG(inDialog).hasScrollBar)
			{
				thePart = FindControl(pt, inDialog, &theControl);
				if (theControl == UAM_DLOG(inDialog).scrollBar)
				{
					if (thePart == kControlIndicatorPart)
					{
						temp = TrackControl(theControl, pt, 0L);
						UAM_AdjustText(theControl);
						result = TRUE;
					}
					else if (thePart >= kControlUpButtonPart)
					{
						temp = TrackControl(theControl, pt, UAM_DLOG(inDialog).scrollActionProc);
						result = TRUE;
					}
				}
			}
			
			if ((!result) && (UAM_DLOG(inDialog).hasList)) {
				result = UAM_ListDialogFilter(inDialog, e, itemHit);
			}
			break;
			
		case keyDown:
		case autoKey:
			result = UAM_ProcessKeydown(inDialog, e, itemHit);
			break;
			
		default:
			break;
	}
			
	return(result);
}


// ---------------------------------------------------------------------------
//		 UAM_CheckGatedControls()
// ---------------------------------------------------------------------------

void UAM_CheckGatedControls(DialogPtr inDialog)
{
	short			x,i;
	Str255			s2;
		
	//
	//Flip through each of the gated controls and check to see if their associated
	//text box has text of not.
	//
	for (x = 0; x < kMaxGatedItems; x++)
	{
		if (	(UAM_DLOG(inDialog).gateItems[x].controlID != 0)	&&
				(UAM_DLOG(inDialog).gateItems[x].textID != 0)		)
		{
			UAM_GetText(
					inDialog,
					UAM_DLOG(inDialog).gateItems[x].textID,
					(Str255 *)&s2
			);
			
			//
			//Do we have text in the associated text box? And, is the first character
			//a non-white space?
			//
			if ((s2[0] == 0) || (isspace(s2[1])))
			{
				if (UAM_DLOG(inDialog).gateItems[x].state != 255)
				{
					//
					//No, so set the state of the box to 255 which grays it out.
					//
					UAM_DLOG(inDialog).gateItems[x].state = 255;
					
					UAM_HiliteItem(
							inDialog,
							UAM_DLOG(inDialog).gateItems[x].controlID,
							UAM_DLOG(inDialog).gateItems[x].state
					);
					
					//
					//Now see if any other controls are gated to this text box. If so, then
					//set the state to grayed also at this point.
					//
					for (i = 0; i < kMaxGatedItems; i++)
					{
						if ((i != x) && (UAM_DLOG(inDialog).gateItems[i].controlID != 0))
						{
							if (UAM_DLOG(inDialog).gateItems[i].textID == UAM_DLOG(inDialog).gateItems[x].textID)
							{
								UAM_DLOG(inDialog).gateItems[i].state = 255;
								
								UAM_HiliteItem(
										inDialog,
										UAM_DLOG(inDialog).gateItems[i].controlID,
										UAM_DLOG(inDialog).gateItems[i].state
								);
							}
						}
					}
				}
			}
			else
			{
				UAM_DLOG(inDialog).gateItems[x].state = 0;
				
				UAM_HiliteItem(
						inDialog,
						UAM_DLOG(inDialog).gateItems[x].controlID,
						UAM_DLOG(inDialog).gateItems[x].state
				);
			}
		}
	}
}
	

// ---------------------------------------------------------------------------
//		 UAM_FrameItem()
// ---------------------------------------------------------------------------

pascal void UAM_FrameItem(DialogPtr inDialog, short i)
{
	GrafPtr	savePort;
	Rect	r;
	
	GetPort(&savePort);
	SetPort(inDialog);
	
	r = UAM_GetItemRect( inDialog, i);
	if ((r.bottom - r.top <= 1) || (r.right - r.left <= 1))
	{
		if (r.bottom - r.top <= 1) {
			MoveTo(r.left, r.top);
			LineTo(r.right, r.top);
		} else {
			MoveTo(r.left, r.top);
			LineTo(r.left, r.bottom);
		}
	}
	else
		FrameRect(&r);
	
	SetPort(savePort);
}


// ---------------------------------------------------------------------------
//		 UAM_GetDRect()
// ---------------------------------------------------------------------------

Rect UAM_GetDRect( short id )
{
	DialogTHndl	dTh;
	Rect		r;
	
	dTh = (DialogTHndl)Get1Resource('DLOG', id);
	r = (**dTh).boundsRect;
	
	ReleaseResource((Handle)dTh);
	
	return(r);
}
	

// ---------------------------------------------------------------------------
//		 UAM_SetUpUserItem()
// ---------------------------------------------------------------------------

void UAM_SetupDialogUserItem(DialogPtr inDialog, short i, UserItemUPP userProc, short type)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, i, &itype, &ihan, &irect);
	SetDialogItem(inDialog, i, type, (Handle)userProc, &irect);
}


// ---------------------------------------------------------------------------
//		 UAM_DisposeDialog()
// ---------------------------------------------------------------------------

void UAM_DisposeDialog(DialogPtr inDialog)
{
	SInt16	x;
	
	if (UAM_DLOG(inDialog).hasScrollBar)
	{
		if (UAM_DLOG(inDialog).dialogTE)
			TEDispose(UAM_DLOG(inDialog).dialogTE);
		if (UAM_DLOG(inDialog).scrollBar)
			DisposeControl(UAM_DLOG(inDialog).scrollBar);
	}
	
	DisposeRoutineDescriptor(UAM_DLOG(inDialog).scrollActionProc);
	
	if (UAM_DLOG(inDialog).hasList) {
		LDispose(UAM_DLOG(inDialog).dialogList);
	}
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].hTE != NULL)
		{
			TEDispose(UAM_DLOG(inDialog).bulletItems[x].hTE);
			UAM_DLOG(inDialog).bulletItems[x].hTE = NULL;
		}
	}	
	
	DisposeDialog(inDialog);
}


// ---------------------------------------------------------------------------
//		 UAM_GateControl()
// ---------------------------------------------------------------------------

void UAM_GateControl(DialogPtr inDialog, short controlID, short textID)
{
	short	x;
	Boolean	found = false;
	
	//
	//Find the next available gate slot.
	//
	
	for (x = 0; x < kMaxGatedItems; x++)
	{
		if (UAM_DLOG(inDialog).gateItems[x].controlID == 0)
		{
			found = true;
			break;
		}
	}
	
	if (found)
	{
		UAM_DLOG(inDialog).gateItems[x].controlID	= controlID;
		UAM_DLOG(inDialog).gateItems[x].textID		= textID;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_StopGate()
// ---------------------------------------------------------------------------

void UAM_StopGate(DialogPtr inDialog, short controlID)
{
	SInt16	x;
	
	for (x = 0; x < kMaxGatedItems; x++)
	{
		if (UAM_DLOG(inDialog).gateItems[x].controlID == controlID)
		{
			UAM_DLOG(inDialog).gateItems[x].controlID	= 0;
			UAM_DLOG(inDialog).gateItems[x].textID		= 0;
			UAM_DLOG(inDialog).gateItems[x].state		= 0;
			
			UAM_HiliteItem(inDialog, controlID, 0);
			
			break;
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SetBulletItem()
// ---------------------------------------------------------------------------

void UAM_SetBulletItem(DialogPtr inDialog, short item, short maxLen)
{
	short 		x;
	Boolean		found = false;
	Rect		rDest;
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == 0)
		{
			found = true;
			break;
		}
	}
	
	if (found)
	{
		UAM_DLOG(inDialog).bulletItems[x].editID	= item;
		UAM_DLOG(inDialog).bulletItems[x].maxLength	= maxLen;
		
		SetRect(&rDest, -1001, -1001, -1000, -1000);
		UAM_DLOG(inDialog).bulletItems[x].hTE = TENew(&rDest, &rDest);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SetBulletText()
// ---------------------------------------------------------------------------

void UAM_SetBulletText(DialogPtr inDialog, short item, Str255 text)
{
	short		x, i;
	Str255		s;
	TEHandle	hTE = NULL;
		
	//
	//Flip through all the bullet items till we find the one to set
	//
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)
		{
			SelectDialogItemText(inDialog, item, 0, 0);
			
			s[0] = 0;
				
			for (i = 1; i <= text[0]; i++) 
			{
				s[i] = kPasswordBulletText;
				s[0]++;
			}
			
			UAM_SetText(inDialog, item, s);			
			TESetText(&text[1], text[0], UAM_DLOG(inDialog).bulletItems[x].hTE);
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ClearBulletText()
// ---------------------------------------------------------------------------

void UAM_ClearBulletText(DialogPtr inDialog, short item)
{
	short	x;
	TEPtr	pTE;
		
	//
	//Flip through all the bullet items till we find the one to set
	//
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)
		{
			UAM_SetText(inDialog, item, "\p");
			
			HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
			
			pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);
			pTE->selStart	= 0;
			pTE->selEnd		= pTE->teLength;
			
			HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
			
			TEDelete(UAM_DLOG(inDialog).bulletItems[x].hTE);
			break;
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ProcessKeydown()
// ---------------------------------------------------------------------------

Boolean UAM_ProcessKeydown(DialogPtr inDialog, EventRecord *event, short *item)
{
	Boolean		result 		= false;
	short		chCode		= (event->message & charCodeMask);
	Cell		theCell		= {0,0};
	Cell		tempCell	= {0,0};
	short		x;
	TEHandle	hTE;
	TEPtr		pTE;
	
	//
	//See if we want to support the edit command keys. If not, then
	//kill the event and act like nothing happend. Also checkd for
	//the unsupported Forward Delete key.
	//
	
	if (	((!UAM_DLOG(inDialog).supportCmdKeys) && (event->modifiers & cmdKey)) ||
			(chCode == UAMKey_FwdDel)									)
	{
		event->what		= nullEvent;
		event->message	= 0;
		
		return(true);
	}
	
	//
	//If we have a list box, then we want to process the arrow keys for up
	//and down movement only. We can't process the keys directly here because
	//we can't call LGetSelect() from this callback routine.
	//
	
	if (UAM_DLOG(inDialog).hasList)
	{
		switch(chCode)
		{
			case UAMKey_Up:
			case UAMKey_Down:
			case UAMKey_PageUp:
			case UAMKey_PageDown:
			case UAMKey_Home:
			case UAMKey_End:
				*item = DITEM_ListNavigationKey;
				
				UAM_DLOG(inDialog).lastKeyCode	= chCode;
				UAM_DLOG(inDialog).modifiers	= event->modifiers;
				
				result = true;
				break;
				
			default:
				*item = DITEM_ListMoveToKey;

				UAM_DLOG(inDialog).lastKeyCode	= chCode;
				UAM_DLOG(inDialog).modifiers	= event->modifiers;
				
				GetDateTime(&UAM_DLOG(inDialog).lastKeyTime);
				
				result = true;
				break;
		}
	}
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if ((UAM_DLOG(inDialog).standardDialog.editField + 1) == UAM_DLOG(inDialog).bulletItems[x].editID)
		{
			switch(chCode)
			{
				case UAMKey_PageUp:
				case UAMKey_PageDown:
				case UAMKey_Home:
				case UAMKey_End:
				case UAMKey_Tab:
				case UAMKey_Left:
				case UAMKey_Right:
				case UAMKey_Up:
				case UAMKey_Down:
					//
					//We don't want to process these keys so just break here and continue.
					//
					break;
				
				case UAMKey_FwdDel:
					break;
				
				default:
					hTE = UAM_DLOG(inDialog).standardDialog.textH;
					if (hTE == NULL) {
						break;
					}
										
					if (chCode != UAMKey_BackDel)
					{
						event->message -= chCode;
						event->message += kPasswordBulletText;
					}
					
					HLock((Handle)hTE);
					HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
					
					pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);
					pTE->selStart	= (*hTE)->selStart;
					pTE->selEnd		= (*hTE)->selEnd;
					
					if ((pTE->selStart == pTE->selEnd) && (chCode != UAMKey_BackDel))
					{
						if (pTE->teLength >= UAM_DLOG(inDialog).bulletItems[x].maxLength)
						{
							SysBeep(1);

							HUnlock((Handle)hTE);
							HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
							
							event->what		= nullEvent;
							event->message	= 0;
							
							break;
						}
					}
					
					HUnlock((Handle)hTE);
					HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
					
					TEKey(chCode, UAM_DLOG(inDialog).bulletItems[x].hTE);
					break;
			}
			
			break;
		}
	}
	
	return(result);
}


// ---------------------------------------------------------------------------
//		 UAM_GetBulletBuffer()
// ---------------------------------------------------------------------------

void UAM_GetBulletBuffer(DialogPtr inDialog, short item, StringPtr outBuffer)
{
	short 		x;
	Boolean		found = false;
	TEPtr		pTE;
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)
		{
			found = true;
			break;
		}
	}
	
	if (found)
	{
		HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
				
		pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);
		outBuffer[0] 	= pTE->teLength;
		
		HLock(pTE->hText);
		
		BlockMove(*pTE->hText, &outBuffer[1], outBuffer[0]);
		
		HUnlock(pTE->hText);
		HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SupportCmdKeys()
// ---------------------------------------------------------------------------

void UAM_SupportCmdKeys(DialogPtr inDialog, Boolean support)
{
	UAM_DLOG(inDialog).supportCmdKeys = support;
}


// ---------------------------------------------------------------------------
//		 UAM_SetCustomFilterProc()
// ---------------------------------------------------------------------------

void UAM_SetCustomFilterProc(DialogPtr inDialog, ModalFilterUPP proc)
{
	if (UAM_DLOG(inDialog).customFilter == NULL)
	{
		UAM_DLOG(inDialog).customFilter = proc;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uamx_headers.h ===
// ===========================================================================
//	UAM_HeadersPPC.h		   1998-2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeadersMach-O.h>

#define UAM_TARGET_CARBON
#define UAM_TARGET_PPC

//
//These are needed because we include the MacSSP headers.
//
#include <SspHeadersMach.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uamdlogutils.h ===
// ===========================================================================
//	UAMDLOGUtils.h 			 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#define	textMargin			2

#define	Abs(x)				((x) < 0 ? -(x) : (x))

#define	HiShort(longNum)	(short)(((longNum) >> 16) & 0xFFFF)
#define	LoShort(longNum)	(short)((longNum) & 0xFFFF)

#define	Max(x, y)			((x) > (y) ? (x) : (y))
#define	Min(x, y)			((x) < (y) ? (x) : (y))

#define UAM_DLOG(d)			(*((UAMDialogRecP)d))

#define kMaxGatedItems		3
#define kMaxBulletItems		3

#define kPasswordBulletText	'*'

//
//These item defines are needed because we can't navigate a list
//box using arrow keys because we can't call LGetSelect from a
//completion or callback routine.
//

#define DITEM_ListNavigationKey	20000
#define DITEM_ListMoveToKey		20001


#define UAMKey_Home		0x01
#define UAMKey_Enter	0x03
#define UAMKey_End		0x04
#define UAMKey_PageUp	0x0B
#define UAMKey_PageDown	0x0C
#define UAMKey_BackDel	0x08
#define UAMKey_Tab		0x09
#define UAMKey_Escape	0x1b
#define UAMKey_Left		0x1c
#define UAMKey_Right	0x1d
#define UAMKey_Up		0x1e
#define UAMKey_Down		0x1f
#define UAMKey_Return	0x0d
#define UAMKey_Space	0x20
#define UAMKey_FwdDel	0x7f
#define UAMKey_Period	'.'

//
//Struct needed for maintaining gated dialog items.
//

typedef struct {
	short	controlID;
	short	textID;
	short	state;
}GatedItems;

//
//Struct needed to maintain bullet edit fields.
//

typedef struct {
	short		editID;
	short		maxLength;
	TEHandle	hTE;
}BulletEditRec;

//
//This is the main struct. It is made part of the actual dialog record and holds
//key private information for us to maintain a dialog which is capable of displaying
//several custom items such as lists, scrolling text, bullet edit fields, etc.
//

typedef struct {
	//
	//This is the standard dialog recrod, it must be first in our rec.
	//
	
	DialogRecord		standardDialog;
	
	//
	//The following is used for scrolling text fields within a dialog.
	//
	
	Boolean				hasScrollBar;
	TEHandle			dialogTE;
	Rect				dialogTERect;
	ControlHandle		scrollBar;
	short				deltaV;
	short				vOffset;
	ControlActionUPP	scrollActionProc;
	
	//
	//These are private items needed to maintain a list box in a dialog.
	//
	
	Boolean				hasList;
	short				listID;
	Boolean				doubleClick;
	ListHandle			dialogList;
	Rect				listRect;
	Rect				dataBounds;
	Point				cSize;
	Cell				lastCell;
	short				listFont;
	short				listSize;
	Boolean				listHasScrollBar;
	short				lastKeyCode;
	unsigned long		lastKeyTime;
	long				modifiers;
	
	//
	//Fields for various other tasks with our dialog.
	//
	
	Boolean				supportCmdKeys;					//Support edit command keys?
	ModalFilterUPP		customFilter;					//Custom filter provided by user
	GatedItems			gateItems[kMaxGatedItems];		//All gated controls
	BulletEditRec		bulletItems[kMaxBulletItems];	//All bullet fields
} UAMDialogRec, *UAMDialogRecP;


Rect				UAM_GetScreenBounds		( void );
void				UAM_DisposeDialog		( DialogPtr );
ControlHandle 		UAM_GetCHandle			( DialogPtr, short );
Rect				UAM_GetItemRect			( DialogPtr, short );
void				UAM_ToggleControl		( DialogPtr, short );
void 				UAM_GetText				( DialogPtr, short, Str255 * );
void 				UAM_SetText				( DialogPtr, short, Str255 );
void 				UAM_HiliteItem			( DialogPtr, short, short );
Boolean				UAM_IsActive			( DialogPtr, short );
short				UAM_GetCValue			( DialogPtr, short );
void				UAM_SetCValue			( DialogPtr, short, short );
void				UAM_PositionDialog		( ResType, short );
short 				UAM_GetItemType			( DialogPtr, short );
DialogPtr			UAM_NewDialog			( short, Boolean );
void				UAM_Update				( DialogPtr );
pascal Boolean 		UAM_DialogFilter		( DialogPtr, EventRecord *, short * );
void				UAM_CheckGatedControls	( DialogPtr );
pascal void			UAM_FrameItem			( DialogPtr, short );
Rect				UAM_GetDRect			( short );
void				UAM_SetupDialogUserItem	( DialogPtr, short, UserItemUPP, short );
void				UAM_GateControl			( DialogPtr, short, short );
void				UAM_StopGate			( DialogPtr, short );
void				UAM_SetBulletItem		( DialogPtr, short, short );
void				UAM_SetBulletText		( DialogPtr , short , Str255 );
void 				UAM_ClearBulletText		(DialogPtr inDialog, short item);
Boolean				UAM_ProcessKeydown		( DialogPtr, EventRecord *, short * );
void				UAM_GetBulletBuffer		( DialogPtr, short, StringPtr );
void				UAM_SupportCmdKeys		( DialogPtr, Boolean );
void				UAM_SetCustomFilterProc	( DialogPtr, ModalFilterUPP );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uamlistbox.cpp ===
// ===========================================================================
//	UAMListBox.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// List box routines for maintaining a list in a dialog. This unit is required
// for the custom volume list dialog.
//
// ===========================================================================

#include <Lists.h>
#include <stdlib.h>

#include "UAMUtils.h"
#include "UAMListBox.h"

ListHandle	gList;

// ---------------------------------------------------------------------------
//		 UAM_MakeList()
// ---------------------------------------------------------------------------
//	Create a new list in the dialog window.

void UAM_MakeList(DialogPtr inDialog, short inItem, short inFont, short inSize, short inProc, Boolean inHasScroll)
{
	Rect	theListRect;
			
	UAM_DLOG(inDialog).listID 			= inItem;
	UAM_DLOG(inDialog).listRect 		= UAM_GetItemRect(inDialog, inItem);
	UAM_DLOG(inDialog).listFont 		= inFont;
	UAM_DLOG(inDialog).listSize 		= inSize;
	UAM_DLOG(inDialog).listHasScrollBar = inHasScroll;
	
	UAM_DLOG(inDialog).hasList			= true;
	
	//
	//If the list has a scrollbar, leave room for it on the right.
	//
	
	theListRect = UAM_DLOG(inDialog).listRect;
	if (UAM_DLOG(inDialog).listHasScrollBar) {
		theListRect.right -= 15;
	}
	
	SetRect(&UAM_DLOG(inDialog).dataBounds, 0, 0, 1, 0);
	UAM_DLOG(inDialog).cSize.h = theListRect.right - theListRect.left;
	UAM_DLOG(inDialog).cSize.v = 0;
	
	TextFont(UAM_DLOG(inDialog).listFont);
	TextSize(UAM_DLOG(inDialog).listSize);
	
	UAM_DLOG(inDialog).dialogList = LNew(	&theListRect, 
											&UAM_DLOG(inDialog).dataBounds,
											UAM_DLOG(inDialog).cSize,
											inProc,
											inDialog,
											TRUE, FALSE, FALSE,
											UAM_DLOG(inDialog).listHasScrollBar		);
	
	UAM_DLOG(inDialog).cSize.v = -1;

	if (UAM_DLOG(inDialog).dialogList != NULL)
	{
		(**(UAM_DLOG(inDialog).dialogList)).selFlags = lUseSense + lNoExtend;
		
		LSetDrawingMode(TRUE, UAM_DLOG(inDialog).dialogList);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ListUpdate()
// ---------------------------------------------------------------------------
//	Update (redraw) the list box, probably due to an update event.

void UAM_ListUpdate(DialogPtr inDialog)
{
	Rect			theListRect;
		
	TextFont(UAM_DLOG(inDialog).listFont);
	TextSize(UAM_DLOG(inDialog).listSize);
	
	LUpdate(inDialog->visRgn, UAM_DLOG(inDialog).dialogList);
	
	theListRect = UAM_DLOG(inDialog).listRect;
	if (UAM_DLOG(inDialog).listHasScrollBar) {
		theListRect.right -= 15;
	}
			
	InsetRect(&theListRect, -1, -1);
	FrameRect(&theListRect);
}


// ---------------------------------------------------------------------------
//		 UAM_ListMoveToItem()
// ---------------------------------------------------------------------------
//	Move to the first item of this pressed letter/combo.

void UAM_ListMoveToItem(short inCode, unsigned long inLastTime, ListHandle inList)
{
	#pragma unused(inLastTime)

	Cell		theCell 	= {0,0};
	Str32		theKey;
	Str32		theName;
	UAMListData	theData;
	short		theDataLen;
	
	theKey[0]	= 1;
	theKey[1]	= (char)inCode;
	
	//
	//We use UpperString() in this routine for strong compatibility across
	//localized of versions of the UAM.
	//
	
	UpperString(theKey, false);
	
	while(theCell.v < (*inList)->dataBounds.bottom)
	{
		theDataLen = sizeof(UAMListData);
		
		LGetCell((Ptr)&theData, &theDataLen, theCell, inList);
		
		UAM_PStrCopy(theData.volumeName, theName);
		UpperString(theName, false);
		
		if ((theName[1] == theKey[1]) && (theData.isActive))
		{
			UAM_SelectOneCell(theCell, inList);
			LAutoScroll(inList);
			break;
		}
		
		theCell.v++;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ListKeyNavigation()
// ---------------------------------------------------------------------------
//	Navigate the list box using the keyboard.

void UAM_ListKeyNavigation(short inCode, long inModifiers, ListHandle inList)
{
	Cell		theCell	= {0,0};
	UAMListData	theData;
	short		theDataLen;
	short		theRows;
	
	switch(inCode)
	{
		case UAMKey_Up:
			if (LGetSelect(true, &theCell, inList))
			{
				if (theCell.v > 0) {
					theCell.v -= 1;
				}
														
				do
				{
					theDataLen = sizeof(UAMListData);
					
					LGetCell((Ptr)&theData, &theDataLen, theCell, inList);
					
					if (theData.isActive == true) 
					{
						if (inModifiers & shiftKey) {
							LSetSelect(true, theCell, inList);
						}
						else {
							UAM_SelectOneCell(theCell, inList);
						}
					}
					else if (theCell.v > 0) {
						theCell.v -= 1;
					}
					else {
						break;
					}
						
				}while(!theData.isActive);
				
				//
				//Scroll the list to the active cell.
				//
				LAutoScroll(inList);
			}
			break;
			
		case UAMKey_Down:
			if (UAM_GetLastSelectedCell(&theCell, inList))
			{
				if (theCell.v < ((*inList)->dataBounds.bottom - 1)) {
					theCell.v += 1;
				}
				
				do
				{
					theDataLen = sizeof(UAMListData);
					
					LGetCell((Ptr)&theData, &theDataLen, theCell, inList);
					
					if (theData.isActive == true) 
					{
						if (inModifiers & shiftKey) {
							LSetSelect(true, theCell, inList);
						}
						else {
							UAM_SelectOneCell(theCell, inList);
						}
					}
					else if (theCell.v < ((*inList)->dataBounds.bottom - 1)) {
						theCell.v += 1;
					}
					else {
						break;
					}
						
				}while(!theData.isActive);
				
				//
				//Scroll the list to the active cell.
				//
				LAutoScroll(inList);
			}
			break;
			
		case UAMKey_Home:
			LScroll(-16000, -16000, inList);
			break;
		
		case UAMKey_End:
			LScroll(16000, 16000, inList);
			break;
			
		case UAMKey_PageUp:
		case UAMKey_PageDown:
			theRows = (*inList)->visible.bottom - (*inList)->visible.top - 1;
			
			if (inCode == UAMKey_PageUp) {
				theRows = -theRows;
			}
			
			LScroll(0, theRows, inList);
			break;
			
		default:
			break;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SelectOneCell()
// ---------------------------------------------------------------------------
//	Select just one cell in the list.

void UAM_SelectOneCell(Cell inCell, ListHandle inList)
{
	Cell	theCurrCell = {0,0};
	
	while(LGetSelect(true, &theCurrCell, inList))
	{
		if (*(long *)&theCurrCell == *(long *)&inCell) {
			LNextCell(true, true, &theCurrCell, inList);
		}
		else {
			LSetSelect(false, theCurrCell, inList);
		}
	}
	
	LSetSelect(true, inCell, inList);
}


// ---------------------------------------------------------------------------
//		 UAM_GetLastSelectedCell()
// ---------------------------------------------------------------------------
//	Get the last selected cell in the list.

Boolean UAM_GetLastSelectedCell(Cell *outCell, ListHandle inList)
{
	Cell	tCurrCell 		= {0,0};
	Boolean	tHasSelection	= LGetSelect(true, &tCurrCell, inList);
	
	if (tHasSelection)
	{
		do
		{
			*outCell = tCurrCell;
		}while(LNextCell(true, true, &tCurrCell, inList) && LGetSelect(true, &tCurrCell, inList));
	}
	
	return(tHasSelection);
}


// ---------------------------------------------------------------------------
//		 UAM_SortSwapProc()
// ---------------------------------------------------------------------------
//	Sorting swap routine.

void UAM_SortSwapProc(size_t inOne, size_t inTwo)
{
	Cell		theCell1, theCell2;
	UAMListData	theData1, theData2;
	short		theDataLen1 = sizeof(UAMListData);
	short		theDataLen2 = sizeof(UAMListData);

	theCell1.h		= 0;
	theCell1.v		= inOne;
	theCell2.h		= 0;
	theCell2.v		= inTwo;
	
	LGetCell((Ptr)&theData1, &theDataLen1, theCell1, gList);
	LGetCell((Ptr)&theData2, &theDataLen2, theCell2, gList);

	if ((theDataLen1 != 0) && (theDataLen2 != 0))
	{
		LSetCell((Ptr)&theData2, theDataLen2, theCell1, gList);
		LSetCell((Ptr)&theData1, theDataLen1, theCell2, gList);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SortCompProc()
// ---------------------------------------------------------------------------
//	Sorting compare routine. We need a custom compare routine since we only
//	want to compare the volume names, not the other data in the struct.

int UAM_SortCompProc(size_t inOne, size_t inTwo)
{
	Cell		theCell1, theCell2;
	UAMListData	theData1, theData2;
	short		theDataLen = sizeof(UAMListData);
	
	theCell1.h		= 0;
	theCell1.v		= inOne;
	theCell2.h		= 0;
	theCell2.v		= inTwo;
	
	LGetCell((Ptr)&theData1, &theDataLen, theCell1, gList);
	LGetCell((Ptr)&theData2, &theDataLen, theCell2, gList);
		
	return(CompareString(theData1.volumeName,theData2.volumeName, NULL));
}


// ---------------------------------------------------------------------------
//		 UAM_SortList()
// ---------------------------------------------------------------------------
//	Sorts the volume list in alphabetical order.

void UAM_SortList(DialogPtr inDialog)
{
	gList = UAM_DLOG(inDialog).dialogList;
	
/*
	_qsort(	(*UAM_DLOG(inDialog).dialogList)->dataBounds.bottom,
			(__cmp1_func)UAM_SortCompProc,
			(__swap1_func)UAM_SortSwapProc							); */
}


// ---------------------------------------------------------------------------
//		 UAM_AddListData()
// ---------------------------------------------------------------------------
//	Add data to the list by adding a new row and inserting the data ptr into
//	the list's data field.

void UAM_AddListData(DialogPtr inDialog, Ptr inData, short inDataSize)
{
	UAM_DLOG(inDialog).cSize.h = 0;
	UAM_DLOG(inDialog).cSize.v = LAddRow(1, 32767, UAM_DLOG(inDialog).dialogList);
	
	LSetCell(inData, inDataSize, UAM_DLOG(inDialog).cSize, UAM_DLOG(inDialog).dialogList);
	LDraw(UAM_DLOG(inDialog).cSize, UAM_DLOG(inDialog).dialogList);
}


// ---------------------------------------------------------------------------
//		 UAM_GetListData()
// ---------------------------------------------------------------------------
//	Get the data associated with a cell in the list box.

Ptr	UAM_GetListData(DialogPtr inDialog, Cell inCell, short *inDataSize)
{
	Ptr theData = NULL;
		
	theData = NewPtrClear(*inDataSize);
	
	if (theData != NULL)
	{
		//
		//Get the data from the cell data handle.
		//
		
		LGetCell(theData, inDataSize, inCell, UAM_DLOG(inDialog).dialogList);
		
		//
		//Now set our new pointer size to the actual size of the data returned.
		//
		
		SetPtrSize(theData, *inDataSize);
	}
	
	return(theData);
}


// ---------------------------------------------------------------------------
//		 UAM_CalculateBoxRect()
// ---------------------------------------------------------------------------
//	Calculate the rectangle for the check box that lives in this cell. The
//	defines below much match those in the UAM LDEF.

#define kBoxWidth	11
#define kBoxHeight	11

void UAM_CalculateBoxRect(Rect *inRect)
{
	SetRect(	inRect,
				inRect->right - (kBoxWidth + 5),
				inRect->top + 3,
				inRect->right - 5,
				inRect->top + 3 + kBoxWidth			);
}


// ---------------------------------------------------------------------------
//		 UAM_GetCellCheckBox()
// ---------------------------------------------------------------------------
//	Return the rect of the checkbox for a given cell.

void UAM_GetCellCheckBox(DialogPtr inDialog, Cell inCell, Rect *outRect)
{	
	LRect(outRect, inCell, UAM_DLOG(inDialog).dialogList);
	UAM_CalculateBoxRect(outRect);
}


// ---------------------------------------------------------------------------
//		 UAM_CheckBoxClick()
// ---------------------------------------------------------------------------
//	Check for a user click inside a checkbox in our list box.

void UAM_CheckBoxClick(DialogPtr inDialog, Point inMouseLoc)
{
	Rect			theCellRect;
	Cell			theCell;
	short			theDataOffset;
	short			theDataLen;
	UAMListDataP	theData;
	ListHandle		theListH		= UAM_DLOG(inDialog).dialogList;
	Point			theClickLoc		= (*theListH)->clikLoc;
	Point			theRealLoc		= (*theListH)->mouseLoc;
	
	//
	//Obtain the rectangle of the cell that was just clicked in
	//and get the rect of the checkbox.
	//
	
	theCell = UAM_GetLastListClick(inDialog);
	UAM_GetCellCheckBox(inDialog, theCell, &theCellRect);
	
	//
	//Now determine if the click was actually in the checkbox or in another
	//part of the cell that we don't care about.
	//
	
	if (	(PtInRect(theClickLoc, &theCellRect)) 	&& 
			(PtInRect(inMouseLoc, &theCellRect)) 	&&
			(PtInRect(theRealLoc, &theCellRect))	)
	{
		//
		//The mouse click was in the checkbox of one of our cells, so
		//now we need to get the data associated with that cell.
		//
		
		LGetCellDataLocation(&theDataOffset, &theDataLen, theCell, theListH);
		
		//
		//If we get data, then determine what the current state of the checkbox
		//should be and then invalidate the checkbox rect to force a redraw.
		//
		
		if ((theDataOffset != -1) && (theDataLen != -1))
		{
			theData = (UAMListDataP)((*(*theListH)->cells) + theDataOffset);
		
			theData->isChecked = (theData->isChecked) ? FALSE : TRUE;
			InvalRect(&theCellRect);
		}
		
		//
		//We don't want double clicks in the checkbox to count
		//as a 'real' double click.
		//
		
		UAM_DLOG(inDialog).doubleClick = false;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ListDialogFilter()
// ---------------------------------------------------------------------------
//	This is called by UAM_DialogFilter(), it processes user action to our
//	dialog list box.

Boolean	UAM_ListDialogFilter(DialogPtr inDialog, EventRecord *event, short *itemHit)
{
	Point			theMouseLoc;
	Boolean			theResult	= false;
	Cell			theCell		= {0,0};
						
	theMouseLoc = event->where;
	GlobalToLocal(&theMouseLoc);

	if (PtInRect(theMouseLoc, &UAM_DLOG(inDialog).listRect))
	{
		//
		//You must always set the proper font and size!
		//
		
		TextFont(UAM_DLOG(inDialog).listFont);
		TextSize(UAM_DLOG(inDialog).listSize);
		
		//
		//Have the ListManager handle the nitty gritty of user action and
		//save the cell that the user actually clicked in.
		//
		
		UAM_DLOG(inDialog).doubleClick = LClick(theMouseLoc, event->modifiers, UAM_DLOG(inDialog).dialogList);
		theCell = LLastClick(UAM_DLOG(inDialog).dialogList);
		
		UAM_DLOG(inDialog).lastCell.h = theCell.h;
		UAM_DLOG(inDialog).lastCell.v = theCell.v;
		
		//
		//Call the click routine to handle clicks in the checkboxes.
		//
		
		UAM_CheckBoxClick(inDialog, theMouseLoc);
		
		//
		//Signal that the list box was indeed the item the user hit.
		//
		
		*itemHit 	= UAM_DLOG(inDialog).listID;
		theResult 	= true;
	}
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 UAM_ListGotDoubleClick()
// ---------------------------------------------------------------------------
//	Returns TRUE if the user doubled clicked in the list box.

Boolean	UAM_ListGotDoubleClick(DialogPtr inDialog)
{
	return(UAM_DLOG(inDialog).doubleClick);
}


// ---------------------------------------------------------------------------
//		 UAM_GetLastListClick()
// ---------------------------------------------------------------------------
//	Returns the cell that the user last clicked in.

Cell UAM_GetLastListClick(DialogPtr inDialog)
{
	return(UAM_DLOG(inDialog).lastCell);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uamlistbox.h ===
// ===========================================================================
//	UAMListBox.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include <stdlib.h>
#include "UAMDLOGUtils.h"

//
//Our custom UAM LDEF resource ID
//

#define UAM_LDEF_ID		1000


//
//Data structure for storage in the list data field. This structure
//should only be used for our UAM list.
//

typedef struct
{
	Str32		volumeName;
	Boolean		isChecked;
	Boolean		isActive;
}UAMListData, *UAMListDataP, **UAMListDataH;


void			UAM_MakeList			( DialogPtr, short, short, short, short, Boolean );
void			UAM_ListUpdate			( DialogPtr );
void 			UAM_ListKeyNavigation	( short , long , ListHandle );
void	 		UAM_ListMoveToItem		( short , unsigned long , ListHandle );
void 			UAM_SelectOneCell		( Cell , ListHandle );
Boolean 		UAM_GetLastSelectedCell	( Cell *, ListHandle );
void			UAM_SortSwapProc		( size_t, size_t );
int 			UAM_SortCompProc		( size_t, size_t );
void 			UAM_SortList			( DialogPtr );
void 			UAM_AddListData			( DialogPtr, Ptr, short );
Ptr				UAM_GetListData			( DialogPtr, Cell, short * );
void			UAM_CalculateBoxRect	( Rect * );
void 			UAM_GetCellCheckBox		( DialogPtr, Cell, Rect * );
void 			UAM_CheckBoxClick		( DialogPtr, Point );
Boolean			UAM_ListDialogFilter	( DialogPtr, EventRecord *, short * );
Boolean			UAM_ListGotDoubleClick	( DialogPtr );
Cell			UAM_GetLastListClick	( DialogPtr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uam_debugheadersppc.h ===
// ===========================================================================
//	UAM_DebugHeaders.h		   1998 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <SspDebugHeadersPPC.h>	

#define UAM_TARGET_CLASSIC	1
#define UAM_TARGET_PPC		1
#define UAMDebug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uam_headersppc.h ===
// ===========================================================================
//	UAM_HeadersPPC.h		   1998-2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <SspHeadersPPC.h>		// Precompiled header of Toolbox routines

#define UAM_TARGET_CLASSIC	1
#define UAM_TARGET_PPC	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uammain.h ===
// ===========================================================================
//	UAMMain.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "ClientUAM.h"

//
//Our type and creator
//
#define UAM_CREATOR		FOUR_CHAR_CODE('NTAM')
#define UAM_TYPE		kUAMFileType
#define UAM_TYPE_CODE	139

#define UAMResourceSignatureSize 	8
#define AFP_IconSize  				128		//Currently no defined icon bigger which AFP client model can handle.

#define	DLOG_Login					12128	//Loging dialog

//
//This is needed to tell the Chooser that the user requests
//to cancel the login operation. This is not defined anywhere,
//this is what Leland Wallace (randall@apple.com) from Apple said to use.
//
#define userCanceledError			-128

//
//Our connection method names for the login dialog. Note that these
//items are not to be localized!
//
#define STR_TCPConnection			"TCP/IP"
#define STR_AppleTalkConnection		"AppleTalk"

//
//Password expiration notices occur when within this # of days
//
#define MINIMUM_DAYS_TILL_EXPIRATION	14

//
//The following are constants for the items in the login dialog.
//
#define DITEM_FirstHideItem		9
#define DITEM_LastHideItem		14

#define DITEM_Connect			1
#define DITEM_Line				6
#define DITEM_GuestRadio		7
#define DITEM_RegRadio			8
#define	DITEM_UserName			11
#define DITEM_Password			12
#define DITEM_ChangePwd			14
#define DITEM_Method			16
#define DITEM_Version			17
#define DITEM_Keychain			18
#define DITEM_StrongEncryption	19
#define DITEM_About				20

#define UAM_ReplaceKeyQuestion		1500

//
//NT specific error codes we use.
//
enum {
	afpNTNewPasswordMismatchErr		= -13000,
	afpNTChangePasswordFailed		= -13001,
	afpNTAccountDisabled			= -13002,
	afpNTInvalidWorkstation			= -13003,
	afpNTInvalidLogonHours			= -13004,
	afpNTPasswordExpired			= -13005,
	afpNTPasswordCantChange			= -13006,
	afpNTPasswordHistConflict		= -13007,
	afpNTPasswordTooShort			= -13008,
	afpNTPasswordTooRecent			= -13009,
	afpNTPasswordRestriction		= -13010,
	afpNTAccountRestriction			= -13011,
	afpNTPasswordProcessFailure		= -13012,	//Encryption or host mapping error
	
	uamPasswordExpiresInOneDay		= 1002
};

typedef unsigned char Str64[64];

//
//Prototypes for the main module live here.
//

pascal OSStatus
main(UAMArgs *inUAMArgs);
OSStatus
MS_UAMOpen(UAMArgs *inUAMArgs);
void	
MS_UAMClose(void);
pascal void	
MS_VersionUserItem(DialogPtr inDialog, DialogItemIndex inItem);

Boolean
MS_TestTextEntryLength(
	DialogPtr 		inDialog,
	EventRecord*	inEvent,
	short 			inItem,
	short			inMaxLengthAllowed
);

pascal Boolean 
MS_PwdDialogFilter(DialogPtr inDialog, EventRecord *inEvent, short *inItem);
OSStatus
MS_UAMPwdDialog(UAMArgs *inUAMArgs);
OSStatus
MS_UAMLogin(UAMArgs *inUAMArgs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_classic\uam 5.0 src\uammain.cpp ===
// ===========================================================================
//	UAMMain.cp 				 1997-2001 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Main unit for Microsoft User Authentication Method.
//
//	Notes:
//	--------------------------------------------------------------------------
//
//
// 	Version History:
// 	===========================================================================
//	04.22.97	MJC - Begin coding version 5.0.
//	05.22.97	MJC - Completed version 5.0d5, getting close.
//	02.21.98	MJC	- Begin updating for AppleShare 3.8 and AFP/TCP.
//	03.02.98	MJC - First working version (5.0d12) with AS Client v3.8a1lawJ
//	03.26.98	MJC - Implemented change password. It works, but not when the
//					  password has expired on the server. I suspect a bug in
//					  in AppleShare Client 3.8a1LawL which doesn't open a session
//					  when the error code returned is not noErr. 
//	03.31.98	MJC	- First checkin into VSS database.
//
//	Version 5.0d15:
//	04.13.98	MJC	- Changed the way supported UAM's are recorded (bitmap vice
//					  a struct of booleans).
//					- Change some error code determination code in UAM_OpenSession()
//					  and UAM_MSUAMContLogin().
//					- Added version string at bottom of dialog window.
//
//	Version 5.0d16:
//	04.30.98	MJC	- Fixed bug in UAMDSNetwork.c where the AFP login command block
//					  would not always end on an even boundary.
//					- Added some additional asserts to UAM_DSLoginMSUAM().
//					- Changed instances of astring[0] to PSTR_LENGTH(astring).
//
//	Version 5.0d17:
//	05.19.98	MJC	- Updated for new ClientUAM.h from Apple. Now the main
//					  entry returns OSStatus vice OSErr.
//
//	Version 5.0b2:
//	06.08.98	MJC	- Added new event callback routine for AS and the Chooser
//					  in the login dialog filter.
//	Version 5.0b3:
//	09.01.98	MJC	- Fixed bug where null passwords weren't allowed.
//	10.23.98	MJC	- Fixed bug where you could use cmd-g to select Guest
//					  radio even though it was disabled.
//					- Can now use cut, copy and paste in User Name field.
//					- Changed 'OK' button to 'Connect' to match Apple's UAM
//					- Clicking on 'Registered User' when it is already
//					  doesn't cause a flash anymore or select the user name.
//	11.13.98	MJC - Added support for passing the actual encrypted password
//					  over the wire for cleartxt storage updating when
//					  changing password.
//				MJC - Added support for notifying the user that their password
//					  is about to expire.
//	12.01.98	MJC	- Fixed bug were I wasn't reversing the byte order of the
//					  returned password expiration time.
//	01.22.99	MJC - CheckGatedControls() would step 1 too far in the array.
//					- Could not use escape key if username len maxed out.
//	Version 5.0.1:
//	07.12.99	MJC - More problems with UAM_CheckGatedControls(), hopefully all
//					  fixed this time.
//					  Made small change in MS_VersionUserItem() so we compile
//					  under CW Pro 5.
//	Version 5.0.2:
//	10.21.99	MJC - Fixed bug on double byte character OS's (CHX, JPN, etc)
//					  where first char in password was getting dropped.
//					- Now select all the password text after a login failure.
//	Version 5.0.3:
//	10.29.99	MJC - Fixed bug on international systems where hitting
//					  backspace would yield incorrect results (got rid of one
//					  char instead of the double byte char).
//					- Related to fix above, change password field entry diaplay
//					  character to '*' instead of ''.
//	Version 5.0.4:
//	11.17.99	MJC - Fixed bug in encrypt.c, wasn't locking resource handle,
//					  so password OWF was incorrectly generated.
//					- SetupUAMEncrypt() was not returning a fail code
//					  if loading the data table failed.
//	Version 5.0.5:
//	11.22.99	MJC - Put 2 0x00 bytes at the end of the initial login call for
//					  NT4 SP6.
//	12.01.99	MJC - Finished keychain support.
//					- NOTE: You must now compile the MS UAM with Universal
//					  headers v3.3 or later.
//					- Can finally build PPC! The MS UAM is now a safe FAT
//					  binary. So, it'll run natively on 68K and PPC.
//					- Complete rewrite of password edit field handling. Now kicks
//					  butt! You can type just like any other text and should work
//					  better with foreign languages.
//					- Made some changes to the dialog code in preparation
//					  for Carbon.
//	01.10.00	MJC - Now check for cmd key down when opening UAM so user can
//					  bypass keychain.
//	03.13.00	MJC - Removed about dialog.
//	03.15.00	MJC - Now check for MacOS 9 or > to see if keychain is available.
//					- Now week load the Keychain.lib for compatibility with
//					  older systems.
//	03.20.00	MJC - Fixed bug: When changing password, wasn't checking for existance
//					  of keychain manager (caused -2802 error).
//	Version 5.0.6:
//	06.11.00	MJC	- Now give the option to replace keychains items that
//					  already exist. This caused problems when the user changed
//					  their password on another machine, there was no way to
//					  update the keychain item without doing it manually from the
//					  KeychainAccess control panel.
//	Version 5.0.7:
//	09.06.00	MJC - Bug fix: keychain item shouldn't appear when guest selected
//					- Bug fix: Don't allow white space as first char in user name, this
//					  involved redoing the gating logic in UAMDlogUtils.c.
//	09.28.00		- Bug fix: Allow null user name and password entries when
//					  guest login is enabled on server.
//	01.29.01		- Set PPC struct alignment to 68K for fix change password
//					  bug.
//	Version 5.0.8:
//	04.26.01	MJC	- Code cleanup. Combined UAMNetwork and UAMDSNetwork into
//					  one file (UAMNetwork.c & UAMNetwork.h)
//					- UAM_ChangePasswordV2(): Now check for zero length old
//					  and new passwords before upper casing.
//					- Now use common NTLM des code for login and changepassword v2.
//					- Zero password buffers when done with them (security fix).
//					- Now clear password field when login error occurs.
//	05.01.01		- Fixed bug where over-long user names could be pasted
//					  into username field.
//					- Can now tab out of user name field when name is max length.
//					- Now clear password when failure occurs in UAM_LoginMSUAM().
//	07.02.01		- Fixed bug where password was getting cleared before I was
//					  adding it to the keychain.
//
//	Version 5.0.9:
//	10.23.01		- Added support for NTLMv2 authentication
//					- Don't support blank passwords for MS2.0 auth
//					- Added new MS3.0 encryption protocol (support NTLMv2)
//
//	Version 5.0.10	- Now properly close session after bad password error case.
//	Version 5.0.11	- Security review
//						- Added max length parameter to string copy routine
//						- Found bug where couldn't save passwords more than
//						  8 bytes long in keychain. Could lead to AV.
//						- Now use strsafe routines.
// ===========================================================================

#if !GENERATINGCFM
#include <A4Stuff.h>
#include <SetupA4.h>
#else
#define EnterCodeResource()
#define PrepareCallback()
#define ExitCodeResource()
#define EnterCallback()
#define ExitCallback()
#endif

#include "UAMMain.h"
#include "UAMDebug.h"
#include "UAMUtils.h"
#include "UAMDialogs.h"
#include "UAMNetwork.h"
#include "UAMDLOGUtils.h"
#include "UAMKeychain.h"
#include "UAMPswdField.h"
#include "UAMPrefs.h"

//
//Global variables are declared here
//
Str32				gServerName;
Str32				gUserName;
Boolean				gContextInited;
Boolean				gGuestLogon;
Boolean				gSupportsChngPwd;
Boolean				gDoingIPConnection;
DialogPtr			gDialog;
Str32				gAFPVersion;
long				gSupportedUAMs;
ModalFilterUPP		gDialogFilter;
ModalFilterUPP		gPwdDialogFilter;
UserItemUPP			gLineItem;
UserItemUPP			gVersionItem;
Str32				gUAMVersionString;
Str32				gZoneName;
UInt32				gExpirationTime		= 0;
OTAddress*			gServerAddress 		= NULL;
EventCallbackPtr	gEventCallbackUPP 	= NULL;
Boolean				gTriedKeychain		= false;

extern UAM_PREFERENCES	gUAMPreferences;

#if GENERATINGCFM
//We need to define __procinfo for Metrowerks' linker. This basically
//defines main. Without it, we'll get a link error.
ProcInfoType __procinfo = kPascalStackBased | RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))
											| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UAMArgs*)));
#endif


// ---------------------------------------------------------------------------
//		 main()
// ---------------------------------------------------------------------------
//	This is the main entry point for our UAM. This function is passed a
//	pointer to a UAMArgs struct. This struct contains the function selector,
//	call-backs, and many other things we need to do our stuff.

pascal OSStatus main(UAMArgs *inUAMArgs)
{
	OSStatus theResult = noErr;
	
	EnterCodeResource();
	PrepareCallback();
			
	switch(inUAMArgs->command)
	{
		case kUAMOpen:
			theResult = MS_UAMOpen(inUAMArgs);
			break;
			
		case kUAMClose:
			MS_UAMClose();
			break;
			
		case kUAMPWDlog:
			theResult = MS_UAMPwdDialog(inUAMArgs);
			break;
			
		case kUAMLogin:
			theResult = UAM_UAMLogin(inUAMArgs);
			break;
			
		case kUAMVSDlog:
			break;
		
		case kUAMChgPass:
		case kUAMChgPassDlg:
			DbgPrint_((DBGBUFF, "Change password dialog must be implemented"));
			theResult = kNotForUs;
			break;
				
		default:
			//
			//If we get here then we were asked to handle a routine that
			//we don't support. Return the appropriate error code.
			//
						
			DbgPrint_((DBGBUFF, "Unsupported function selector in MSUAM main() (%d)", inUAMArgs->command));

			theResult = kNotForUs;
			break;
	}
	
	ExitCodeResource();
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_UAMOpen()
// ---------------------------------------------------------------------------
//	This is called by the device package. It is not a required function but
//	we use it to initialize our UAM code. Note that when we encounter an
//	error we don't make an effort to clean up. Instead we return userCanceledErr
//	in which case our UAMClose function will be called by AppleShare Client.

OSStatus MS_UAMOpen(UAMArgs *inUAMArgs)
{
	short 	theUAMConfig = 0;
	SInt32	theResponse;
		
	//
	//Get the name of the server we want to log into.
	//
	UAM_PStrCopy(inUAMArgs->Opt.open.objectName, gServerName, sizeof(gServerName));
	
	//
	//Copy the zone name for. If it's NULL, then we
	//don't have a zone name.
	//
	if (inUAMArgs->Opt.open.zoneName != NULL)
	{
		//
		//01.16.02: Pass maximum length to string copy routine.
		//
		UAM_PStrCopy(inUAMArgs->Opt.open.zoneName, gZoneName, sizeof(gZoneName));
	}
	else
		gZoneName[0] = 0;
							
	gContextInited 		= false;		//Been through PwdDialog before?	
	gGuestLogon 		= false;		//Is guest our logon choice?
	gDoingIPConnection	= false;		//Default to AppleTalk support.
	gDialog				= NULL;			//So we can see if we really got it.
	gDialogFilter		= NULL;	
	gPwdDialogFilter	= NULL;
	gLineItem			= NULL;
	gVersionItem		= NULL;
	gAFPVersion[0]		= 0;
	gUserName[0]		= 0;
	gServerAddress		= inUAMArgs->Opt.open.srvrAddress;
	gEventCallbackUPP	= inUAMArgs->callbacks->EventCallbackUPP;		
	gTriedKeychain		= false;
	
	ZeroMemory(&gUAMPreferences, sizeof(UAM_PREFERENCES));
	UAM_RetrieveUAMPreferenceData(&gUAMPreferences);
		
	UAM_KCInitialize(inUAMArgs);
					
	//
	//Under PowerPC this is a pointer allocated. Under 68K, it just
	//points to the function.
	//
	gDialogFilter = NewModalFilterProc(&UAM_DialogFilter);
	if (gDialogFilter == NULL)
	{
		//
		//We check for ptr validity. Note that we don't bother to 
		//clean up since we'll get a kUAMClose message next.
		//
		
		DbgPrint_((DBGBUFF, "Failed to allocate gDialogFilter"));
		return(userCanceledErr);
	}
	
	gPwdDialogFilter = NewModalFilterProc(&MS_PwdDialogFilter);
	if (gPwdDialogFilter == NULL)
	{
		DbgPrint_((DBGBUFF, "Failed to allocate gPwdDialogFilter"));
		return(userCanceledErr);
	}
	
	gLineItem = NewUserItemProc(&UAM_FrameItem);
	if (gLineItem == NULL)
	{
		DbgPrint_((DBGBUFF, "Failed to allocate gLineItem"));
		return(userCanceledErr);
	}
	
	gVersionItem = NewUserItemProc(&MS_VersionUserItem);
	if (gVersionItem == NULL)
	{
		DbgPrint_((DBGBUFF, "Failed to allocate gVersionItem"));
		return(userCanceledErr);
	}

	//
	//Get the AFP version and the default user name. This function finds
	//a match which is the highest AFP version supported by both the client
	//and server.
	//
	UAM_GetAFPVersionString(	
			inUAMArgs->Opt.open.srvrInfo,
			inUAMArgs->callbacks,
			gAFPVersion,
			gUserName 			);
	
	//
	//gUserName can be null, we just capture here during debugging to
	//ensure we're getting the name properly.
	//
	Assert_(PSTR_LENGTH(gUserName) != 0);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
	
	if (PSTR_LENGTH(gAFPVersion) == 0)
	{
		//
		//No AFPVersion, no logon...
		//
		
		UAM_ReportError(uamErr_NoAFPVersion);
		return(userCanceledErr);
	}
					
	gSupportsChngPwd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsChngPswd) != 0);
	
	//
	//Determine what connection method we are using, IP or AppleTalk. Basically,
	//if the client supports IP and the address type is IP, then we have
	//a TCP connection.
	//
	if (inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsTCPIP)
	{
		if (inUAMArgs->Opt.open.srvrAddress->fAddressType == AF_INET)
		{
			gDoingIPConnection = TRUE;
		}
	}
												
	//
	//Get the list of supported UAMs from a utility routine. This data
	//is necessary in the password dialog code.
	//							
	UAM_GetSupportedUAMS(
			inUAMArgs,
			(StringPtr)gAFPVersion,
			&gSupportedUAMs		);
		
	//
	//We should never get here if the following is false, but we
	//check just to be on the safe side.
	//
	if (	((gSupportedUAMs & kMSUAMSupported) 	== 0)	&&
			((gSupportedUAMs & kMSUAM_V2_Supported) == 0)	) 
	{
		Assert_((gSupportedUAMs & kMSUAMSupported) != 0);
		
		UAM_ReportError(afpBadUAM);
		return(userCanceledErr);
	}
	
	UAM_VersionString(gUAMVersionString);
	UAM_SetMaximumPasswordLength(false);

	//
	//This is how we tell AppleShare what our UAM supports. We have
	//our own password dialog, we support change password, and we
	//use our own change password dialog.
	//
	
	theUAMConfig |= BIT_0;	//Custom login dialog
	theUAMConfig |= BIT_2;	//We support change password
	theUAMConfig |= BIT_3;	//Custom change password dialog
	
	inUAMArgs->result = theUAMConfig;
		
	return(noErr);
}


// ---------------------------------------------------------------------------
//		 MS_UAMClose()
// ---------------------------------------------------------------------------
//	Like UAMOpen, UAMClose has no specific purpose as defined by the device
//	manager. We use it to clean up our allocated storage and globals.

void MS_UAMClose(void)
{	
	if (gDialog != NULL)
	{
		//
		//If we put up our login dialog, get rid of it.
		//
		UAM_DisposeDialog(gDialog);
	}
	
	if (gDialogFilter != NULL)		DisposeRoutineDescriptor(gDialogFilter);
	if (gLineItem != NULL)			DisposeRoutineDescriptor(gLineItem);
	if (gPwdDialogFilter != NULL)	DisposeRoutineDescriptor(gPwdDialogFilter);
	if (gVersionItem != NULL)		DisposeRoutineDescriptor(gVersionItem);
}


// ---------------------------------------------------------------------------
//		 MS_VersionUserItem()
// ---------------------------------------------------------------------------
//	Custom user item routine to display UAM version number and connection
//	type (ATalk or TCP/IP).

pascal void MS_VersionUserItem(DialogPtr inDialog, DialogItemIndex inItem)
{
	short	theFont, theSize;
	Rect	theItemRect;
	
	EnterCallback();
			
	theFont = inDialog->txFont;
	theSize	= inDialog->txSize;
	
	TextFont(kFontIDGeneva);
	TextSize(9);
	
	theItemRect = UAM_GetItemRect(inDialog, inItem);
	
	switch(inItem)
	{
		case DITEM_Version:
			//
			//Display the version of the MS UAM in the lower right corner.
			//
			TETextBox(	
					&gUAMVersionString[1],
					PSTR_LENGTH(gUAMVersionString),
					&theItemRect,
					teJustRight	);
			break;
		
		case DITEM_Method:
			//
			//Let the client know what connection method is being used to
			//connect to the server.
			//
			if (gDoingIPConnection)
			{
				TETextBox(
					&STR_TCPConnection,
					strlen(STR_TCPConnection),
					&theItemRect,
					teJustLeft);
			}
			else
			{
				TETextBox(
					STR_AppleTalkConnection,
					strlen(STR_AppleTalkConnection),
					&theItemRect,
					teJustLeft);
			}
			break;
			
		default:
			Assert_(0);
			break;
	}
			
	TextFont(theFont);
	TextSize(theSize);
	
	ExitCallback();
}

// ---------------------------------------------------------------------------
//		 MS_TestTextEntryLength()
// ---------------------------------------------------------------------------
//	We don't allow entries in the login dialog to be of any length. This
//	function tests the length of the entered text in an edit field. It will
//	modify the event record appropriately to inhibit processing of the
//	keystroke if it will take the field over the limit.

Boolean MS_TestTextEntryLength(
	DialogPtr 		inDialog,
	EventRecord*	inEvent,
	short 			inItem,
	short			inMaxLengthAllowed
)
{
	Str255	theString;
	Boolean	theResult 	= false;
		
	if ((((DialogPeek)inDialog)->editField + 1) == inItem)
	{
		UAM_GetText(inDialog, inItem, (Str255 *)&theString);
		
		if (PSTR_LENGTH(theString) >= inMaxLengthAllowed)
		{
			SysBeep(1);
		
			inEvent->what 		= nullEvent;
			inEvent->message	= 0;
			theResult 	  		= true;
			
			//
			//If the string length is currently too long, then
			//we have to chop off the end of the string to the
			//proper length.
			//
			if (PSTR_LENGTH(theString) > inMaxLengthAllowed)
			{
				//
				//Easy way out, pascal style strings have length
				//byte in front. Just adjust it.
				//
				theString[0] = inMaxLengthAllowed;
				
				//
				//Now set the text in the edit field with the new string.
				//
				UAM_SetText(inDialog, inItem, theString);
			}
		}
	}
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_PwdDialogFilter()
// ---------------------------------------------------------------------------
//	Filter function for the password dialog. We have this so we can capture
//	command keys and keep length requirements for the user name in the login 
//	dialog.

pascal Boolean MS_PwdDialogFilter(DialogPtr inDialog, EventRecord *inEvent, short *inItem)
{
	short	theCode;
	Str255	theString;
	Boolean	theResult = false;
	SInt16	theMaxUsernameLen;
	
	EnterCallback();
			
	if ((inEvent->what == keyDown) || (inEvent->what == autoKey))
	{
		theMaxUsernameLen = (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?
								UAM_USERNAMELEN_V3 : UAM_USERNAMELEN;
				
		theCode = (inEvent->message & charCodeMask);
		
		//
		//04.30.01: Don't allow cmd selections when autoKey'ing.
		//
		if ((inEvent->modifiers & cmdKey) && (inEvent->what != autoKey))
		{
			switch(theCode)
			{
				case 'g':
				case 'G':
					*inItem   = DITEM_GuestRadio;
					theResult = true;
					break;
				
				case 'r':
				case 'R':
					*inItem   = DITEM_RegRadio;
					theResult = true;
					break;
					
				case 's':
				case 'S':
					*inItem	  = DITEM_ChangePwd;
					theResult = true;
					break;
									
				case 'a':
				case 'A':
					*inItem   = DITEM_Keychain;
					theResult = true;
					break;
				
				//
				//Handle edit commands from the user. We don't allow any
				//editing commands in the password field. This mimicks
				//Apple's own UAM's.
				//
					
				case 'c':
				case 'C':
					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {
						DialogCopy(inDialog);
					}
					break;
					
				case 'v':
				case 'V':
					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password)
					{
						DialogPaste(inDialog);
						
						//
						//For pastes, we have to do a lot more work to ensure the
						//user name field doesn't get too big.
						//
						theResult = MS_TestTextEntryLength(
											inDialog,
											inEvent,
											DITEM_UserName,
											theMaxUsernameLen);
					}
					break;
				case 'x':
				case 'X':
					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {
						DialogCut(inDialog);
					}
					break;
					
				default:
					break;
			}
		}
		else
		{
			//
			//Don't allow more than UAM_USERNAMELEN maximum characters in edit field.
			//
			
			if ((((DialogPeek)inDialog)->editField + 1) == DITEM_UserName)
			{
				UAM_GetText(inDialog, DITEM_UserName, (Str255 *)&theString);
				
				switch(theCode)
				{
					case UAMKey_BackDel:
					case UAMKey_Left:
					case UAMKey_Right:
					case UAMKey_Return:
					case UAMKey_Enter:
					case UAMKey_Escape:
					case UAMKey_Tab:
						break;
						
					default:
						if (PSTR_LENGTH(theString) >= theMaxUsernameLen)
						{
							SysBeep(1);
						
							inEvent->what = nullEvent;
							theResult 	  = true;
						}
						break;
				}
			}
		}
	}
	else
	{
		if (gEventCallbackUPP)
		{
			//
			//If we're not handling the event ourselves, then call the
			//event callback which gives AS and the Chooser a chance
			//to update it's windows, etc.
			//
			
			#if GENERATING68K
			
			gEventCallbackUPP(inEvent);
			
			#else
			
			CallUniversalProc(gEventCallbackUPP, kEventCallbackProcInfo, inEvent);
			
			#endif	
		}
	}
	
	ExitCallback();
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_UAMPwdDialog()
// ---------------------------------------------------------------------------
//	This is where we put up our password dialog. The buffers pointed to by
//	'inUserName' and 'inPassword' end up getting passed directly to the
//	UAMLogin function.
//
//	The buffer passed for the user name and password is 64 bytes long. Don't
//	use more than that! 

OSStatus MS_UAMPwdDialog(UAMArgs *inUAMArgs)
{
	short			theItem, x;
	Str255			theStr;
	OSStatus		theError	= noErr;
	Boolean			theLoop 	= true;
	
	Assert_(gDialogFilter 		!= NULL);
	Assert_(gPwdDialogFilter 	!= NULL);
	Assert_(gLineItem 			!= NULL);
		
	//
	//Determine which user name to use, the default or the
	//one supplied by the client (if any). gUserName is filled
	//in originally during the UAMOpen call.
	//
	if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) != 0)
	{
		//
		//01.16.02: Pass maximum length to string copy routine.
		//
		UAM_PStrCopy(inUAMArgs->Opt.pwDlg.userName, gUserName, sizeof(gUserName));
	}
	
	//
	//If we already tried the keychain and failed, we don't want
	//to try again or we'll loop forever. Give the user a chance
	//to enter the correct name and password.
	//
	//NOTE: We check to see if the cmd key is down, if it is, then
	//we bypass the keychain stuff alltogether. Maybe the user wants
	//to change his password!?!?!
	//
	if ((gTriedKeychain == false) && (UAM_KCAvailable()) && (!UAM_KeyDown(KEY_Command)))
	{
		gTriedKeychain = true;
		
		if ( (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName))	&&
			 (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password))	)
		{
			//
			//We were supplied a username and password by the AFP
			//client. This means the user clicked a keychain entry.
			//
			goto exit;
		}
		else 
		{
			theError = UAM_KCFindAppleSharePassword(
							gUserName,
							inUAMArgs->Opt.pwDlg.password,
							gServerName,
							NULL
			);
			
			if (theError == noErr)
			{
				DbgPrint_((DBGBUFF, "Pswd found via MSUAM keychain calls;g"));
				
				//
				//Fill in the user name for the UAMArgs.
				//
				if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) == 0)
				{
					UAM_PStrCopy(gUserName, inUAMArgs->Opt.pwDlg.userName);
				}

				//
				//A password was found so try to logon.
				//
				goto exit;
			}
			else if (	(theError != errKCItemNotFound)		&&
						(theError != userCanceledErr)		)
			{
				//
				//Only report "real" errors.
				//
				UAM_ReportError(theError);
			}
		}
	}
	else if ((UAM_KCAvailable()) && (UAM_KeyDown(KEY_Command)))
	{
		//
		//If the user is holding the cmd key down, then we don't want to
		//try the keychain the next time through either.
		//
		gTriedKeychain = true;
	}
			
	//
	//Display the server name in the dialog title text
	//which is located at the top of the dialog. This must be
	//done even if we've been here before.
	//
	
	ParamText(gServerName, NULL, NULL, NULL);
	
	//
	//If we haven't been through here before, then we need to do
	//all the prep work.
	//
		
	if (!gContextInited)
	{
		gDialog = UAM_NewDialog(DLOG_Login, true);
		if (gDialog == NULL)
		{
			//
			//If we couldn't get the dialog, then we're either out
			//of memory or the resource couldn't be found.
			//
			
			theError = MemError();
			if (theError == noErr)
				theError = ResError();
			if (theError == noErr)
				theError = resNotFound;
			
			UAM_ReportError(theError);
			return(userCanceledErr);
		}
		
		//
		//Setup our custom user items that display things like the UAM
		//version number and the connection method.
		//	
		UAM_SetupDialogUserItem(gDialog, DITEM_Line, gLineItem, userItem);
		UAM_SetupDialogUserItem(gDialog, DITEM_Version, gVersionItem, userItem);
		UAM_SetupDialogUserItem(gDialog, DITEM_Method, gVersionItem, userItem);
		
		//
		//Set up the default user name and password (if any). If a user name
		//exists, then make the password field the active field ready for input.
		//
						
		//
		//If we've not been here before, then we want to use the user name
		//entered in the Sharing Setup Control Panel (or Chooser).
		//
		
		if (PSTR_LENGTH(gUserName) != 0)
		{
			UAM_SetText(gDialog, DITEM_UserName, gUserName);
			SelectDialogItemText(gDialog, DITEM_Password, 0, 64);
		}
		else
		{
			UAM_HiliteItem(gDialog, 1, 255);
		}
		
		//
		//Now we set up the guest and registered user radio buttons and the
		//change password button as determined by UAM_GetServerInfo().
		//
		
		if (!gSupportsChngPwd) {
			UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);
		}
		else {
			UAM_GateControl(gDialog, DITEM_ChangePwd, DITEM_UserName);
		}
		
		if (!(gSupportedUAMs & kGuestSupported))
		{
			//
			//No guest support, we don't need the guest radio button.
			//
			UAM_HiliteItem(gDialog, DITEM_GuestRadio, 255);
			
			//
			//If guest is not supported, then we gate the connect
			//button to the username text field.
			//
			UAM_GateControl(gDialog, DITEM_Connect, DITEM_UserName);
		}
		
		//
		//Set the initial radio for the default/current login method.
		//
		
		if (gGuestLogon)
		{
			UAM_SetCValue(gDialog, DITEM_GuestRadio, 1);
			UAM_SetCValue(gDialog, DITEM_RegRadio, 	 0);
			
			UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);
			
			for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
				HideDialogItem(gDialog, x);
			}
			
			UAM_HiliteItem(gDialog, 1, 0);
		}
		else {
			UAM_SetCValue(gDialog, DITEM_RegRadio, 1);
		}
				
		UAM_SetBulletItem(
				gDialog,
				DITEM_Password,
				(gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?
					UAM_MAX_LMv2_PASSWORD : UAM_CLRTXTPWDLEN
				);
		
		UAM_SupportCmdKeys(gDialog, false);
				
		//
		//Set our custom filter function so we can handle command keys and
		//manage user name maximum string length.
		//
		UAM_SetCustomFilterProc(gDialog, gPwdDialogFilter);
		
		//
		//If the client is not allowed to save password for this server,
		//then we gray out the keychain checkbox.
		//
		if (UAM_KCAvailable() == false)
		{
			UAM_HiliteItem(gDialog, DITEM_Keychain, 255);
		}
		else if (gTriedKeychain)
		{
			UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
			SelectDialogItemText(gDialog, DITEM_Password, 0, 64);
		}
		
		//
		//Set the encryption type checkbox to the proper value.
		//
		if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)
		{
			UAM_SetCValue(gDialog, DITEM_StrongEncryption, 1);
		}
		
		//
		//This flag lets up know that we've initialized our login dialog
		//and that we don't need to do it again when/if we come here again.
		//
		
		gContextInited	= true;
	}
	else {
		UAM_SetText(gDialog, DITEM_UserName, inUAMArgs->Opt.pwDlg.userName);
		UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
		
		//
		//Hilite the password selection.
		//
		SelectDialogItemText(gDialog, DITEM_Password, 0, 64);
		
		InvalRect(&gDialog->portRect);
	}
	
	do
	{
		ModalDialog(gDialogFilter, &theItem);
		
		//
		//Check gated controls, disable them if their text item
		//counterpart has no text.
		//
			
		UAM_CheckGatedControls(gDialog);

		switch(theItem)
		{
			case DITEM_OK:				
				gGuestLogon 	= (UAM_GetCValue(gDialog, DITEM_GuestRadio) != 0);
				theError		= noErr;
				theLoop 		= false;
				
				if (gGuestLogon)
				{
					inUAMArgs->Opt.pwDlg.userName[0] = 0;
					inUAMArgs->Opt.pwDlg.password[0] = 0;
				}
				else
				{					
					UAM_GetBulletBuffer(	gDialog,
											DITEM_Password,
											inUAMArgs->Opt.pwDlg.password	);
					
					UAM_GetText(			gDialog,
											DITEM_UserName,
											(Str255 *)inUAMArgs->Opt.pwDlg.userName	);

                    //
                    //Don't allow blank passwords for 2 reasons:
                    //
                    //	1. It is not secure and user can use Apple UAM for this.
                    //	2. This covers a security hole that is generated after changing 
                    //	   passwords on these servers using Apple's clear text UAM.
                    //
                    if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0)
                    {
                        UAM_StandardAlert(
                                uamErr_PasswordMessage,
                                uamErr_NoBlankPasswordsAllowed,
                                NULL
                                );
                                
                        //
                        //Continue the login dialog loop so the user can make changes.
                        //
                        theLoop = true;
                    }
				}
				
				//
				//Only save the preferences if the user hits "Connect".
				//
				UAM_SaveUAMPreferenceData(&gUAMPreferences);
				break;
				
			case DITEM_Cancel:
				//
				//VERSION 5.0: To force cancellation, we pass userCanceledError(-128)
				//back to the Chooser. The old UAM would pass back dsForcedQuit which
				//is the wrong value. This would cause an error dialog when cancelling.
				//
				
				theError	= userCanceledError;
				theLoop 	= false;
				break;
			
			case DITEM_GuestRadio:
				//
				//Set up the controls in the dialog for guest login. We don't
				//need the user name and password items, so hide them from
				//the user. We must explicitly enable the 'OK' button since
				//it may have been disabled by the gate stuff.
				//
				
				if (UAM_IsActive(gDialog, DITEM_GuestRadio))
				{
					UAM_SetCValue(gDialog, DITEM_GuestRadio, 1);
					UAM_SetCValue(gDialog, DITEM_RegRadio, 	 0);
					
					//UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);
					
					for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
						HideDialogItem(gDialog, x);
					}
					
					//
					//Now hide the keychain checkbox
					//
					UAM_SetCValue(gDialog, DITEM_Keychain, 0);
					HideDialogItem(gDialog, DITEM_Keychain);
					
					HideDialogItem(gDialog, DITEM_StrongEncryption);
					
					UAM_StopGate(gDialog, DITEM_Connect);
				}
				break;
			
			case DITEM_RegRadio:
				//
				//Now we need all the items back that were hidden above, make
				//them visible.
				//
				if (UAM_GetCValue(gDialog, DITEM_RegRadio) <= 0)
				{
					UAM_SetCValue(gDialog, DITEM_GuestRadio, 0);
					UAM_SetCValue(gDialog, DITEM_RegRadio, 	 1);
					
					for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
						ShowDialogItem(gDialog, x);
					}
					
					//
					//Make the keychain and encryption items reaappear.
					//
					ShowDialogItem(gDialog, DITEM_Keychain);
					ShowDialogItem(gDialog, DITEM_StrongEncryption);
								
					UAM_GetText(gDialog, DITEM_UserName, &theStr);
					SelectDialogItemText(gDialog, DITEM_UserName, 0, 32767);
					
					if ((gSupportsChngPwd) && (theStr[0] != 0)) {
						UAM_HiliteItem(gDialog, DITEM_ChangePwd, 0);
					}
					
					//
					//Check to see if guest is supported or not so we know if
					//we need to gate the connect button.
					//
					if (!(gSupportedUAMs & kGuestSupported))
					{
						UAM_GateControl(gDialog, DITEM_Connect, DITEM_UserName);
						UAM_CheckGatedControls(gDialog);
					}
				}
				break;
				
			case DITEM_ChangePwd:
				UAM_GetBulletBuffer(	gDialog,
										DITEM_Password,
										inUAMArgs->Opt.pwDlg.password	);
				UAM_GetText(			gDialog,
										DITEM_UserName,
										(Str255 *)inUAMArgs->Opt.pwDlg.userName	);
				
				theError = UAM_ChangePwd(inUAMArgs);
				switch(theError)
				{
					case CHNGPSWD_USER_CANCELED:
						break;
					
					case CHNGPSWD_UPDATE_KEYCHAIN:
						//
						//We need to re-add the keychain item with the
						//correct password. Flag it by checking the box.
						//
						UAM_SetCValue(gDialog, DITEM_Keychain, 1);
						
						//
						//Just fall on through and handle the normal case.
						//
						
					case CHNGPSWD_NOERR:
						//
						//Set the password field and buffer with the new password in case
						//we end back here later.
						//
						
						UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
						
						theError = noErr;
						theLoop  = false;
						break;
						
					default:
						UAM_ReportError(theError);
						
						//
						//Make sure in debug that the password field is cleared in
						//an error condition.
						//
						Assert_(PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0);
						
						//
						//We do this here so we clear the password field like we should
						//do whenever there is a failure.
						//
						UAM_SetBulletText(gDialog, DITEM_Password, "\p");
						
						//
						//Because we use ParamText() we must manually force an update
						//of the dialog or things won't redraw properly.
						//
						InvalRect(&gDialog->portRect);
						break;
				}
			
				//
				//Must reset our user's name since UAM_ChangePwd() uses ParamText()
				//to set some strings of it's own.
				//
				
				ParamText(gServerName, NULL, NULL, NULL);
				break;
							
			case DITEM_Keychain:
				UAM_ToggleControl(gDialog, DITEM_Keychain);
				break;
				
			case DITEM_StrongEncryption:
				//
				//Update the required encryption dynamically.
				//
				UAM_ToggleControl(gDialog, DITEM_StrongEncryption);
				
				if (UAM_GetCValue(gDialog, DITEM_StrongEncryption) > 0)
				{
					gUAMPreferences.flags |= UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;
				}
				else
				{
					gUAMPreferences.flags &= ~UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;
					
					UAM_StandardAlert(
						uamErr_WARNINGMessage,
						uamErr_UsingWeakAuthentication,
						NULL
						);
				}
				break;
			
			default:
				break;
		}
		
	}while(theLoop);

exit:
	return(theError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\afpdatastream.h ===
/*
 	File:		afpDataStream.h
 
 	Contains:	Public Header file for the low level AppleShare Client API (AFP Protocol)
 
 	Version:	3.8.5
 
*/
#ifndef __AFPDATASTREAM__
#define __AFPDATASTREAM__

#ifndef __CONDITIONALMACROS__
#include <ConditionalMacros.h>
#endif

#ifndef __MIXEDMODE__
#include <MixedMode.h>
#endif

#ifndef __DEVICES__
#include <Devices.h>
#endif

#ifndef __APPLETALK__
//#include <AppleTalk.h>
#endif

#ifndef __OPENTRANSPORT__
#include <OpenTransport.h>
#endif

#ifndef __OPENTPTINTERNET__
//#include <OpenTptInternet.h>
#endif

#ifndef __OPENTPTAPPLETALK__
//#include <OpenTptAppleTalk.h>
#endif




#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_IMPORT
#pragma import on
#endif

#if PRAGMA_STRUCT_ALIGN
	#pragma options align=mac68k
#elif PRAGMA_STRUCT_PACKPUSH
	#pragma pack(push, 2)
#elif PRAGMA_STRUCT_PACK
	#pragma pack(2)
#endif



/*	-------------------------------------------------------------------------
	csCodes
	------------------------------------------------------------------------- */
/* for PBControl calls*/
enum {
	afpGetAttnRoutine			= 252,							/*	Get the default AFP Attention routine*/
	dsOpenSession				= 244,							/*	Open an AFP session to the server*/
	dsGetStatus					= 243,							/*	Send a GetSrvrInfo request to the server*/
	dsSendRequest				= 240,							/*	Send an AFP command to the server*/
	dsCloseSession				= 237,							/*	Close the specified session*/
	dsCloseAll					= 232,							/*	Close all sessions*/
	dsIOCTL						= 231,							/*	Make an IOCTL call to the session endpoint iff it is TCP/IP*/
																/* these will be retired soon	*/
	AFPInsSessMemBlk			= 246,							/* insert the SMB into the drviers Queue	*/
	AFPRemSessMemBlk			= 245							/* remove the SMB from the drviers Queue	*/
};

/* for PBStatus calls*/
enum {
	afpGetFSID					= 127,							/*	returns the File System ID	*/
	afpSVolInfo					= 124,							/* 	returns basic info about the server volume (address, servername, username...)*/
	afpXGetVolInfo				= 121,							/*	returns extended info about the volume (server time offset, volume grade...)*/
	afpGetSMBSize				= 118,							/*  returns the size of the session memory block required for a new session*/
	dsGetXPortInfo				= 236							/*	returns information about the transport used for the given session*/
};

/*	-------------------------------------------------------------------------
	Data Stream Parameter Block
	------------------------------------------------------------------------- */
typedef CALLBACK_API( void , DSIOCompletionProcPtr )(void *pb);
/*
	WARNING: DSIOCompletionProcPtr uses register based parameters under classic 68k
			 and cannot be written in a high-level language without 
			 the help of mixed mode or assembly glue.
*/
typedef REGISTER_UPP_TYPE(DSIOCompletionProcPtr) 				DSIOCompletionUPP;


/* csCode = dsSendRequest*/

struct DSWritePB {
	UInt32 							dsWriteDataOffset;			/* <- specifies the write offset in the data*/
	UInt32 							dsWriteBufferSize;			/* <- size of the data to be written*/
	Byte *							dsWriteBuffer;				/* <- ptr to data to be written*/
};
typedef struct DSWritePB				DSWritePB;
/* csCode = dsGetStatus*/

struct DSGetStatusPB {
	OTAddress *						dsGSSrvrAddress;			/* <- OT Address of server to GetStatus() from (you also need to fill in the reply buffer & size)*/
	const char *					dsGSEpString;				/* <- endpoint string for the connection (nil == default)		*/
};
typedef struct DSGetStatusPB			DSGetStatusPB;
/* NOTE: 
	Make sure the reply buffer for the dsGetStatus call is at least 2048 bytes, 
	it may be advisable to make it larger in the future.	
*/
/* csCode = dsOpenSession*/

struct DSOpenPB {
	AttnRoutineUPP 					dsOSAttnRoutine;			/* <- Custom attention routine (nil == default)*/
	OTAddress *						dsOSSrvrAddress;			/* <- OT Address of server to open a session to*/
	Ptr 							dsOSSessionBlock;			/* <- ptr to the SMB; memory reserved for the session.*/
	const char *					dsOSEpString;				/* <- endpoint string for the connection (nil == default)		*/
};
typedef struct DSOpenPB					DSOpenPB;

enum {
	SMBSize						= 3072							/* size of the session memory block (must be allocated in the System Heap)*/
};

/*	NOTE:
	you should use the afpGetSMBSize call instead of this constant.
*/


struct DSParamBlock {
	QElem *							qLink;						/* - standard header stuff*/
	short 							qType;						/* - standard header stuff*/
	short 							ioTrap;						/* - standard header stuff*/
	Ptr 							ioCmdAddr;					/* - standard header stuff*/
	DSIOCompletionUPP 				ioCompletion;				/* <- completion rtn point*/
	OSErr 							ioResult;					/* -> result from Async call*/
	long 							cmdResult;					/* -> result from the Server for the AFP Cmd*/
	short 							ioVRefNum;					/* - standard header stuff */
	short 							ioCRefNum;					/* <- RefNum of the ".AFPTranslator"*/
	short 							csCode;						/* <- DS Command code*/
	short 							dsTimeout;					/* <- ASP - How long to wait before retrying request, TCP - resv for internal use*/
	short 							dsReserved1;				/* -  resv for internal use*/
	long 							dsRetry;					/* <- ASP - How many times to retry the request, TCP - unused*/
	UInt16 							dsReserved2;				/* -  resv for internal use*/
	short 							dsSessRefNum;				/* <- AFP Session number*/
	short 							dsReserved3;				/* -  resv for internal use*/
	short 							dsCmdBufferSize;			/* <- size of the command buffer*/
	UInt8 *							dsCmdBuffer;				/* <- ptr to the command buffer*/
	UInt32 							dsReplyBufferSize;			/* <- size of the reply buffer*/
	UInt8 *							dsReplyBuffer;				/* <- ptr to the reply buffer*/

	union {
		DSOpenPB 						open;
		DSWritePB 						write;
		DSGetStatusPB 					status;
	} 								csParam;
};
typedef struct DSParamBlock				DSParamBlock;
typedef DSParamBlock *					DSParamBlockPtr;

/* NOTE:
	The dsCmdBuffer for the csCode = dsOpenSession case Must contain an AFP Login command.
	The dsCmdBuffer for the csCode = dsCloseSession case Must contain an AFP Logout command.
	Consult Inside AppleTalk for the packet formats.
*/


struct DSXPortInfo {
	long 							dsXPortType;				/* Transport Type (kASPXport, kTCPXport)*/
	short 							dsXPortSessRefNum;			/* Session ref number for ASP or TCP*/
	union {
		InetAddress 					ipAddr;
		DDPAddress 						ddpAddr;
	} 								addr;
};
typedef struct DSXPortInfo				DSXPortInfo;
typedef DSXPortInfo *					DSXPortInfoPtr;
/* definitions for 	dsXPortType */
enum {
	kASPXport					= 0x00,
	kTCPXport					= 0x01
};

/* argument structure for the dsIOCTL call, put a pointer to the DSIOCTLArgs 
   struct into the dsCmdBuffer field & fill out the dsCmdBufferSize with
   sizeof(DSIOCTLArgs). put the session refnum of the session
   you are interested in, into dsSessRefNum. The result of the IOCTL
   call will be in the cmdResult field. if the session is not a TCP/IP
   session you will recieve an error (ENOTSOCK)
*/

struct DSIOCTLArgs {
	UInt32 							ioctlCmd;
	void *							ioctlData;
};
typedef struct DSIOCTLArgs				DSIOCTLArgs;
typedef DSIOCTLArgs *					DSIOCTLArgsPtr;




struct GetVolSessInfoRec {
	short 							sessAFPVersion;				/*	AFP version number: */
	short 							sessReferenceNumber;		/*	AFP session reference number*/
	short 							sessAFPVolID;				/*	AFP volume identifier*/
	OTAddress *						sessServerAddress;			/*	server internet address*/
	short 							sessUAMType;				/*	user authentication method*/
	StringPtr 						sessUserNamePtr;			/*	ptr to user name string*/
	Ptr 							sessVolIconPtr;				/*	ptr to server volume icon/mask*/
	StringPtr 						sessWhereStringPtr;			/*	ptr to "where" information string, shown in the Get Info window*/
};
typedef struct GetVolSessInfoRec		GetVolSessInfoRec;
typedef GetVolSessInfoRec *				GetVolSessInfoRecPtr;
enum {
	kAFPVersion11				= 1,
	kAFPVersion20				= 2,
	kAFPVersion21				= 3,
	kAFPVersion22				= 4,
	kAFPVersion23				= 5
};

enum {
	kNoUserAuth					= 1,							/*	'No User Authent' UAM (Guest)*/
	kCleartextAuth				= 2,							/*	'Cleartxt Passwrd' UAM 	(types 2 & 3 will be automatically upgraded to 6 if avail.)*/
	kRandnumAuth				= 3,							/*	'Randnum Exchange' UAM */
	k2WayRandnumAuth			= 6,							/*	'2-Way Randnum exchange'*/
	kEncryptPassXport			= 7,							/*  'DHXCAST128' UAM (Diffie Hellman password transport)*/
	kMinCustomUAM				= 128							/*	Minimum type value for a Custom UAM*/
};


struct GetVolSessInfoPB {
	QElemPtr 						qLink;						/*  -  standard header stuff*/
	short 							qType;						/*  -  standard header stuff*/
	short 							ioTrap;						/*  -  standard header stuff*/
	Ptr 							ioCmdAddr;					/*  -  standard header stuff*/
	IOCompletionUPP 				ioCompletion;				/* <-  completion rtn pointer*/
	OSErr 							ioResult;					/*  -> result from Async call*/
	StringPtr 						ioNamePtr;					/*  -  standard header stuff*/
	short 							ioVRefNum;					/*  -  standard header stuff*/
	short 							ioRefNum;					/* <-  RefNum of the ".AFPTranslator"*/
	short 							csCode;						/* <-  allways afpSVolInfo*/
	Ptr 							vcbPtr;						/* <-  pointer to the VCB that you want info about*/
	GetVolSessInfoRecPtr 			sessInfoBuffer;				/* <-  pointer to the GetVolSessInfoRec to be filled*/
	long 							sessInfoSize;				/* <-  size of the GetVolSessInfoRec*/
	long 							actSessInfoSize;			/*  -> actual size of the data returned*/
};
typedef struct GetVolSessInfoPB			GetVolSessInfoPB;
typedef GetVolSessInfoPB *				GetVolSessInfoPBPtr;

/* the AFPInsSessMemBlk & AFPRemSessMemBlk  calls are currently  required
   when opening or closing a session. Make the AFPInsSessMemBlk call after the dsOpenSession
   call succeeds (or returns afpAuthContinue), with the same dsOSSessionBlock that you
   sent into dsOpenSession. You need to call AFPRemSessMemBlk with that same pointer after
   calling dsCloseSession or dsCloseAll. 
*/

struct AFPInsRemSMBParam {
	QElemPtr 						qLink;						/*  -  standard header stuff	*/
	short 							qType;						/*  -  standard header stuff	*/
	short 							ioTrap;						/*  -  standard header stuff	*/
	Ptr 							ioCmdAddr;					/*  -  standard header stuff	*/
	IOCompletionUPP 				ioCompletion;				/* <-  completion rtn pointer	*/
	OSErr 							ioResult;					/*  -> result from Async call	*/
	StringPtr 						ioNamePtr;					/*  -  standard header stuff	*/
	short 							ioVRefNum;					/*  -  standard header stuff	*/
	short 							ioRefNum;					/* <-  RefNum of the ".AFPTranslator"			*/
	short 							csCode;						/* <-  AFPInsSessMemBlk or AFPRemSessMemBlk 	*/
	Ptr 							smbPtr;						/* <-> pointer to the SMB to insert or remove	*/
};
typedef struct AFPInsRemSMBParam		AFPInsRemSMBParam;

typedef AFPInsRemSMBParam *				AFPInsRemSMBPBPtr;
/* Server Info Buffer returned from the dsGetStatus call 	*/
/* you should make your buffer at least 1024 bytes in size.	*/
/* a partial definition of the AFPSrvrInfo data structure (the fixed portion) */

struct AFPSrvrInfo {
	short 							fMachineOffset;
	short 							fVerCountOffset;
	short 							fUAMCountOffset;
	short 							fIconOffset;
	short 							fFlags;
	unsigned char 					fSrvrName[2];
};
typedef struct AFPSrvrInfo				AFPSrvrInfo;

/* definitions for the fFlags word	*/
enum {
	srvSCopyFile				= 0,							/* Server supports FPCopyFile call*/
	srvSChangePswd				= 1,							/* Server supports FPChangePassword call*/
	srvNoPswdSave				= 2,							/* Workstation should not save password*/
	srvSServerMsgs				= 3,							/* Server supports server messages*/
	srvSSrvrSig					= 4,							/* Server supports Server Signatures  (AFP 2.2)*/
	srvSupportsTCP				= 5,							/* Server may be connected to via TCP/IP (AFP 2.2)*/
	srvSNotification			= 6								/* Server will send notifications (AFP 2.2)*/
};




#if TARGET_CPU_68K
																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM
																							#pragma parameter __D0 NAFPCommandSync(__A0)
																							#endif
EXTERN_API( OSErr ) NAFPCommandSync(DSParamBlockPtr paramBlock)								ONEWORDINLINE(0xA004);

																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM
																							#pragma parameter __D0 NAFPCommandAsync(__A0)
																							#endif
EXTERN_API( OSErr ) NAFPCommandAsync(DSParamBlockPtr paramBlock)							ONEWORDINLINE(0xA404);


/* use only for dsCloseAll	*/
																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM
																							#pragma parameter __D0 NAFPCommandImmediate(__A0)
																							#endif
EXTERN_API( OSErr ) NAFPCommandImmediate(DSParamBlockPtr paramBlock)						ONEWORDINLINE(0xA204);

#else
#define	NAFPCommandSync(dspb)	PBControlSync((ParmBlkPtr)(dspb)
#define	NAFPCommandAsync(dspb)	PBControlAsync((ParmBlkPtr)(dspb)
#define	NAFPCommandImmediate(dspb)	PBControlImmed((ParmBlkPtr)(dspb)
#endif  /* TARGET_CPU_68K */




#if PRAGMA_STRUCT_ALIGN
	#pragma options align=reset
#elif PRAGMA_STRUCT_PACKPUSH
	#pragma pack(pop)
#elif PRAGMA_STRUCT_PACK
	#pragma pack()
#endif

#ifdef PRAGMA_IMPORT_OFF
#pragma import off
#elif PRAGMA_IMPORT
#pragma import reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __AFPDATASTREAM__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\crypto.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypto.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifdef __MACUAM__
#include "MWERKSCrypto.h"
#endif
#ifdef __MACSSP__
#include "bootdefs.h"
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    char    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;


#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    char    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;


#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    char    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    DWORD   Length;         // Number of valid bytes in buffer
    DWORD   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef char *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef DWORD                       CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////




#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////



#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\afppackets.h ===
/*
	File:		afppackets.h

	Contains: Bitmaps and structures pertaining to the packets received in the session.
						These relate to functions used in afpsession.cp.
						
	Version:	xxx put version here xxx

	Copyright:	Copyright Apple Computer, Inc. 1992-1994

	File Ownership:

		DRI:			Leland Wallace

		Other Contact:		Brad Suinn

		Technology:		AppleShare X
				All rights reserved

	Writers:

		(bms)	Brad Suinn

	Change History (most recent first):

	<RASC14>	10/18/00	bms		Add SymLinks, Finder Attribute bits, now using kAFPNameMax, DHX,
                                                        LoginExt, limited chmod, checks for illegal filenames, and
                                                        Deleting open files.
	<RASC13>	 7/11/00	bms		mmap support, atten support, and change some print levels.
	<RASC12>	 6/19/00	bms		Add deny modes and read/write bits.
	<RASC11>	 5/24/00	bms		Update again.
	<RASC10>	 4/21/00	bms		Add in the rest of the attribute definitions.
	 <RASC9>	 4/21/00	bms		Add write inhibit bit
	 <RASC8>	 4/21/00	bms		Add definitions for the attributes field
	 <RASC7>	 4/18/00	bms		Add AFP2.3 string constant
	 <RASC6>	  4/7/00	bms		Add FPZzzz and the getting/using of the reconnect token
	 <RASC5>	 3/31/00	bms		Add some new definitions
	 <RASC4>	  2/2/00	bms		Add AFP version string constants for the logins.  Also add
									constants for the AFP version.
		 <3>	12/17/99	GBV		synced with server side 3.0 header
	 <RASC2>	 10/5/99	bms		Make the 68K align macros work again.
	 <RASC2>	 8/25/99	bms		Remove silly special characters.
		 <4>	 2/25/98	law		added kFPwdPolicyErr
		 <3>	 8/11/97	law		added kFPPwdNeedsChangeErr
		 <2>	10/31/96	bms		Add the align 68K flags for the PPC compiles.
			7/18/94 MDV		login cleanup
			5/16/94	RMB		vol consts and code standards
			1/1/93	MB		created
			
	To Do:			
*/


#ifndef __AFPPACKETS__
#define __AFPPACKETS__


#define kAFP30VersionString "AFPX03"
#define kAFP23VersionString "AFP2.3"
#define kAFP22VersionString "AFP2.2"
#define kAFP21VersionString "AFPVersion 2.1"


#if PRAGMA_STRUCT_ALIGN
        #pragma options align=mac68k
#elif PRAGMA_STRUCT_PACKPUSH
        #pragma pack(push, 2)
#elif PRAGMA_STRUCT_PACK
        #pragma pack(2)
#endif

// Defines used by client
enum {
    kAFPVersion11	= 1,
    kAFPVersion20	= 2,
    kAFPVersion21	= 3,
    kAFPVersion22	= 4,
    kAFPVersion23	= 5,
    kAFPVersion30	= 6
};

enum {
	kFPAccessDenied = -5000,
	kFPAuthContinue = -5001,
	kFPBadUAM = -5002,
	kFPBadVersNum = -5003,
	kFPBitmapErr = -5004,
	kFPCantMove = -5005,
	kFPDenyConflict = -5006,
	kFPDirNotEmpty = -5007,
	kFPDiskFull = -5008,
	kFPEOFErr = -5009,
	kFPFileBusy = -5010,
	kFPFlatVol = -5011,
	kFPItemNotFound = -5012,
	kFPLockErr = -5013,
	kFPMiscErr = -5014,
	kFPNoMoreLocks = -5015,
	kFPNoServer = -5016,
	kFPObjectExists = -5017,
	kFPObjectNotFound = -5018,
	kFPParamErr = -5019,
	kFPRangeNotLocked = -5020,
	kFPRangeOverlap = -5021,
	kFPSessClosed = -5022,
	kFPUserNotAuth = -5023,
	kFPCallNotSupported = -5024,
	kFPObjectTypeErr = -5025,
	kFPTooManyFilesOpen = -5026,
	kFPServerGoingDown = -5027,
	kFPCantRename = -5028,
	kFPDirNotFound = -5029,
	kFPIconTypeError = -5030,
	kFPVolLocked = -5031,
	kFPObjectLocked = -5032,
	kFPContainsSharedErr = -5033,
	kFPIDNotFound = -5034,
	kFPIDExists = -5035,
	kFPDiffVolErr = -5036,
	kFPCatalogChanged = -5037,
	kFPSameObjectErr = -5038,
	kFPBadIDErr = -5039,                     
	kFPPwdSameErr = -5040,
	kFPPwdTooShortErr = -5041,                      
	kFPPwdExpiredErr = -5042,                       
	kFPInsideSharedErr = -5043,                     
	kFPInsideTrashErr = -5044,
	kFPPwdNeedsChangeErr = -5045,
	kFPwdPolicyErr = -5046
};

enum {
	kFPAddAPPL = 53, 
	kFPAddComment = 56, 
	kFPAddIcon = 192, 
	kFPByteRangeLock = 1,
	kFPByteRangeLockExt = 59,
	kFPCatSearch = 43, 
	kFPCatSearchExt = 67, 
	kFPChangePassword = 36, 
	kFPCloseDir = 3, 
	kFPCloseDT = 49, 
	kFPCloseFork = 4, 
	kFPCloseVol = 2, 
	kFPCopyFile = 5, 
	kFPCreateID = 39,
	kFPCreateDir = 6, 
	kFPCreateFile = 7,
	kFPDelete = 8, 
	kFPDeleteID = 40,
	kFPEnumerate = 9, 
	kFPEnumerateExt = 66, 
	kFPExchangeFiles = 42,
	kFPFlush = 10, 
	kFPFlushFork = 11, 
	kFPGetAPPL = 55, 
	kFPGetAuthMethods = 62, 
	kFPGetComment = 58, 
	kFPGetFileDirParms = 34, 
	kFPGetForkParms = 14, 
	kFPGetIcon = 51, 
	kFPGetIconInfo = 52, 
	kFPGetSrvrInfo = 15, 
	kFPGetSrvrMsg = 38,
	kFPGetSrvrParms = 16, 
	kFPGetUserInfo = 37, 
	kFPGetVolParms = 17, 
	kFPLogin = 18, 
	kFPLoginCont = 19, 
	kFPLoginDirectory = 63, 
	kFPLogout = 20, 
	kFPMapID = 21, 
	kFPMapName = 22, 
	kFPMoveAndRename = 23, 
	kFPOpenDir = 25, 
	kFPOpenDT = 48, 
	kFPOpenFork = 26, 
	kFPOpenVol = 24, 
	kFPRead = 27, 
	kFPReadExt = 60, 
	kFPRemoveAPPL = 54, 
	kFPRemoveComment = 57, 
	kFPRename = 28, 
	kFPResolveID = 41,
	kFPSetDirParms = 29, 
	kFPSetFileDirParms = 35, 
	kFPSetFileParms = 30, 
	kFPSetForkParms = 31, 
	kFPSetVolParms = 32, 
	kFPWrite = 33,
	kFPWriteExt = 61,
	kFPZzzzz =122,
	kFPGetSessionToken = 64,
	kFPDisconnectOldSession = 65
};

enum { kFPNoUserID = -1, kFPGuestUserID = 0 };

enum { kFPSoftCreate = 0, kFPHardCreate = 0x80 };

enum { kFPShortName = 1, kFPLongName = 2, kFPUTF8Name = 3 };

// Define Server Flags
enum {
    kSupportsCopyfile = 0x01,
    kSupportsChgPwd = 0x02,
    kDontAllowSavePwd = 0x04,
    kSupportsSrvrMsg = 0x08,
    kSrvrSig = 0x10,
    kSupportsTCP = 0x20,
    kSupportsSrvrNotify = 0x40,
    kSupportsReconnect = 0x80,
    kSupportsDirServices = 0x100,
    kSupportsSuperClient = 0x8000
};

// Define Volume Attributes
enum {
    kReadOnly = 			0x01,
    kHasVolumePassword = 		0x02,
    kSupportsFileIDs =			0x04,
    kSupportsCatSearch =		0x08,
    kSupportsBlankAccessPrivs = 	0x10,
    kSupportsUnixPrivs = 		0x20,
    kSupportsUTF8Names = 		0x40
};

// Volume bitmap
enum {
	kFPBadVolPre22Bitmap 		= 0xFE00,
	kFPBadVolBitmap 		= 0xF000,
	kFPVolAttributeBit 		= 0x1,
	kFPVolSignatureBit 		= 0x2,
	kFPVolCreateDateBit 		= 0x4,
	kFPVolModDateBit 		= 0x8,
	kFPVolBackupDateBit 		= 0x10,
	kFPVolIDBit 			= 0x20,
	kFPVolBytesFreeBit 		= 0x40,
	kFPVolBytesTotalBit 		= 0x80,
	kFPVolNameBit 			= 0x100,
	kFPVolExtBytesFreeBit		= 0x200,
	kFPVolExtBytesTotalBit		= 0x400,
	kFPVolBlockSizeBit		= 0x800
};

// FileDir bitmap
enum {
	kFPAttributeBit 		= 0x1,
	kFPParentDirIDBit 		= 0x2,
	kFPCreateDateBit 		= 0x4,
	kFPModDateBit 			= 0x8,
	kFPBackupDateBit 		= 0x10,
	kFPFinderInfoBit 		= 0x20,
	kFPLongNameBit 			= 0x40,
	kFPShortNameBit 		= 0x80,
	kFPNodeIDBit 			= 0x100,
	kFPProDOSInfoBit 		= 0x2000,	// for AFP version 2.2 and prior
	kFPUTF8NameBit 			= 0x2000,	// for AFP version 3.0 and greater
	kFPUnixPrivsBit			= 0x8000	// for AFP version 3.0 and greater
};

// struct returned when the kFPUnixPrivsBit is used
struct FPUnixPrivs {
	unsigned long uid;
	unsigned long gid;
        unsigned long permissions;
        unsigned long ua_permissions;
};

// attribute bits
enum {
    kFPInvisibleBit 		= 0x01,
    kFPMultiUserBit 		= 0x02,
    kFPSystemBit 		= 0x04,
    kFPDAlreadyOpenBit 		= 0x08,
    kFPRAlreadyOpenBit 		= 0x10,
    kFPWriteInhibitBit 		= 0x20,
    kFPBackUpNeededBit 		= 0x40,
    kFPRenameInhibitBit 	= 0x80,
    kFPDeleteInhibitBit 	= 0x100,
    kFPCopyProtectBit 		= 0x400,
    kFPSetClearBit 		= 0x8000
};

// unique to Fork and File bitmap
enum {
	kFPDataForkLenBit 		= 0x0200,
	kFPRsrcForkLenBit 		= 0x0400,
	kFPExtDataForkLenBit 		= 0x0800,	// for AFP version 3.0 and greater
	kFPLaunchLimitBit		= 0x1000,
	kFPExtRsrcForkLenBit 		= 0x4000,	// for AFP version 3.0 and greater

	kFPGet22FileParmsMask		= 0x77ff,
	kFPSet22FileParmsMask		= 0x303d,
	kFPGet22DataForkParmsMask 	= 0x23ff,
	kFPGet22ResForkParmsMask 	= 0x25ff,

	kFPGetExtFileParmsMask	= 0xf7ff,
	kFPSetExtFileParmsMask	= 0x103d,
	kFPGetFileParmsMask 	= 0x27ff,
	kFPSetFileParmsMask 	= 0x203d,
	kFPGetDataForkParmsMask = 0x63ff,
	kFPGetResForkParmsMask 	= 0xa5ff
};

// unique to Dir bitmap
enum {
	kFPOffspringCountBit 		= 0x0200,
	kFPOwnerIDBit 			= 0x0400,
	kFPGroupIDBit 			= 0x0800,
	kFPAccessRightsBit 		= 0x1000,

	kFPGetDirParmsMask 		= 0x3fff,
	kFPSetDirParmsMask 		= 0x3c3d
};

enum {
	kFPBadFileBitmap = 0xd800,
	kFPBadDirBitmap =  0xc000
};

// specific to openfork
enum {
	kBadDataBitmap = 0xdc00,
	kBadResBitmap  = 0xda00,
	kBadAccessMode = 0xffcc
};

enum {
	kFPBadFileAttribute = 0x7a00,
	kFPBadDirAttribute =  0x7e1a		// WriteInhibit bit - Whats the story with this?
};

// Related to CatSearch
enum {
	kPartialName	= 0x80000000,	
	kBadRespBits	= 0xffbd,		// legal response info
	kBadDir		= 0x7ffffd80,		// legal request bitmaps 
	kBadFile	= 0x7ffff980,		
	kBadDirFile	= 0x7fffff81
};

enum { kSP = 1, kRP = 2, kWP = 4, kSA = 8, kWA = 16, kOwner = 128 };
enum { kSearchPrivBit = 0, kReadPrivBit = 1, kWritePrivBit = 2 };

// Read/Write and Deny bits for OpenFork
enum {
        kAccessRead = 	0x01,
        kAccessWrite = 	0x02,
        kDenyRead = 	0x10,
        kDenyWrite = 	0x20,
        kAccessMask =	0x33
};

// Attention packet bits
enum {
    kAttnDiscUser	= 0x8000,
    kAttnServerCrash	= 0x4000,
    kAttnServerMsg	= 0x2000,
    kAttnDontReconnect	= 0x1000
};

typedef unsigned char FPFunc;
typedef unsigned short DTRef;
typedef unsigned long DirID;
typedef unsigned char PathType;
typedef unsigned char IconType;
typedef unsigned long IconTag;
typedef unsigned short ForkRef;
typedef unsigned short VolID;
typedef unsigned short Bitmap;
typedef unsigned long Date;
typedef unsigned char FPFinfo[32];
typedef unsigned char ProDOSInfo[6];
typedef unsigned short Attributes;
typedef unsigned short FSAttributes; // *** merge types
typedef unsigned short VolAttributes; // *** merge types
typedef unsigned long UserID;
typedef unsigned long GroupID;
typedef unsigned long AccessRights;
typedef unsigned short AccessMode;
typedef unsigned char FileDirTag;
typedef unsigned char Flag;
typedef unsigned long FileID;
typedef unsigned long ApplTag;
typedef unsigned char *Password;
typedef unsigned short FPRights;
typedef unsigned char CatPosition[16];

struct FPUserAuthInfo {
	unsigned long keyHi;			
	unsigned long keyLo;			
};

struct FPCreateID {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};

struct FPDeleteID {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	FileID fileID;
};
struct FPResolveID {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	FileID fileID;
	Bitmap bitmap;
};
struct FPExchangeFiles {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID srcDirID;
	DirID destDirID;
	PathType srcPathType;
	unsigned char srcPathName;
//	PathType destPathType;
//	StringPtr destPathName;
};


struct FPAddAPPL {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	DirID dirID;
	OSType creator;
	OSType applTag;
	PathType pathType;
	unsigned char pathName;
};
struct FPAddComment {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
//	StringPtr comment;
};
struct FPAddIcon {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	OSType fileCreator;
	OSType fileType;
	IconType iconType;
	unsigned char pad2;
	IconTag iconTag;
	short bitmapSize;
};
struct FPByteRangeLock {
	FPFunc funcCode;
	Flag flags;
	ForkRef forkRef;
	long offset;
	long length;
};
struct FPByteRangeLockExt {
	FPFunc funcCode;
	Flag flags;
	ForkRef forkRef;
	long long offset;
	long long length;
};
struct FPCatSearch {
	FPFunc		funcCode;
	unsigned char		pad;
	short		volumeID;
	long		reqMatches;
	long		reserved;
	CatPosition	catPos;
	short		fileRsltBitmap;
	short		dirRsltBitmap;
	long		reqBitmap;
	unsigned char		length;
};
struct FPCatSearchExt {
	FPFunc		funcCode;
	unsigned char		pad;
	short		volumeID;
	long		reqMatches;
	long		reserved;
	CatPosition	catPos;
	short		fileRsltBitmap;
	short		dirRsltBitmap;
	long		reqBitmap;
	unsigned char		length;
};
struct FPChangePassword {
	FPFunc funcCode;
	unsigned char pad;
	unsigned char uam;
};

struct FPCloseDir {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
};
struct FPCloseDT {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
};
struct FPCloseFork {
	FPFunc funcCode;
	unsigned char pad;
	ForkRef forkRef;
};
struct FPCloseVol {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
};
struct FPCopyFile {
	FPFunc funcCode;
	unsigned char pad;
	VolID srcVolID;
	DirID srcDirID;
	VolID destVolID;
	DirID destDirID;
	PathType srcPathType;
	unsigned char srcPathName;
//	PathType destPathType;
//	StringPtr destPathName;
//	PathType newType;
//	StringPtr newName;
};
struct FPCreateDir {
	FPFunc funcCode;
	Flag flags;
	VolID volID;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};
struct FPCreateFile {
	FPFunc funcCode;
	Flag createFlag;
	VolID volID;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};
struct FPDelete {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};
struct FPEnumerate {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	Bitmap fileBitmap;
	Bitmap dirBitmap;
	short reqCount;
	short startIndex;
	short maxReplySize;
	PathType pathType;
	unsigned char pathName;
};
struct FPEnumerateExt {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	Bitmap fileBitmap;
	Bitmap dirBitmap;
	short reqCount;
	short startIndex;
	short maxReplySize;
	PathType pathType;
	unsigned char pathName;
};
struct FPFlush {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
};
struct FPFlushFork {
	FPFunc funcCode;
	unsigned char pad;
	ForkRef forkRefNum;
};
struct FPGetAPPL {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	OSType creator;
	short index;
	Bitmap bitmap;
};
struct FPGetAuthMethods {
	FPFunc funcCode;
	unsigned char pad;
	unsigned short flags;   /* none defined yet */
	PathType pathType;
	unsigned char pathName;
};
struct FPGetComment {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};
struct FPGetFileDirParms {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	Bitmap fileBitmap;
	Bitmap dirBitmap;
	PathType pathType;
	unsigned char pathName;
};
struct FPGetForkParms {
	FPFunc funcCode;
	unsigned char pad;
	ForkRef forkRef;
	Bitmap bitmap;
};
struct FPGetIcon {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	OSType creator;
	OSType type;
	IconType iconType;
	unsigned char pad2;
	short length;
};
struct FPGetIconInfo {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	OSType fileCreator;
	short iconIndex;
};
struct FPGetSrvrInfo {
	FPFunc funcCode;
	unsigned char pad;
};
struct FPGetSrvrMsg {
	FPFunc funcCode;
	unsigned char pad;
	unsigned short msgType;
	Bitmap msgBitmap;
};
struct FPGetSrvrParms {
	FPFunc funcCode;
	unsigned char pad;
};
struct FPGetUserInfo {
	FPFunc funcCode;
	Flag flag;
	UserID theUserID;
	Bitmap bitmap;
};
struct FPGetVolParms {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	Bitmap bitmap;
};
struct FPLogin {
	FPFunc funcCode;
	unsigned char pad;
};
struct FPLoginCont {
	FPFunc funcCode;
	unsigned char pad;
	short idNumber;
	struct FPUserAuthInfo userAuthInfo;
	struct FPUserAuthInfo userRandNum;
};
struct FPLoginExt {
	FPFunc funcCode;
	unsigned char pad;
	unsigned short flags;    	/* none defined yet */
	unsigned char afpVersion;
// 	unsigned char UAMString;
//	PathType userNamePathType;
//	StringPtr userName;
//	PathType dirNamePathType;
//	StringPtr dirName;
//	uchar pad;					/* if needed to pad to even boundary */
//	uchar authInfo;
};
struct FPLogout {
	FPFunc funcCode;
	unsigned char pad;
};
struct FPMapID {
	FPFunc funcCode;
	Flag subFunction;
	union {
		GroupID groupID;
		UserID userID;
		} u;
};
struct FPMapName {
	FPFunc funcCode;
	Flag subFunction;
	unsigned char name;
};
struct FPMoveAndRename {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID srcDirID;
	DirID destDirID;
	PathType srcPathType;
	unsigned char srcPathName;
//	PathType destPathType;
//	StringPtr destPathName;
//	PathType newType;
//	StringPtr newName;
};
struct FPOpenDir {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};
struct FPOpenDT {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
};
struct FPOpenFork {
	FPFunc funcCode;
	Flag forkFlag;
	VolID volID;
	DirID dirID;
	Bitmap bitmap;
	AccessMode accessMode;
	PathType pathType;
	unsigned char pathName;
};
struct FPOpenVol {
	FPFunc funcCode;
	unsigned char pad;
	Bitmap bitmap;
	unsigned char name;
	Password password;
};
struct FPRead {
	FPFunc funcCode;
	unsigned char pad;
	ForkRef forkRef;
	long offset;
	long reqCount;
	unsigned char newlineMask;
	unsigned char newlineChar;
};

struct FPReadExt {
	FPFunc funcCode;
	unsigned char pad;
	ForkRef forkRef;
	long long offset;
	long long reqCount;
};

struct FPRemoveAPPL {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	DirID dirID;
	OSType creator;
	PathType pathType;
	unsigned char pathName;
};
struct FPRemoveComment {
	FPFunc funcCode;
	unsigned char pad;
	DTRef dtRefNum;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
};
struct FPRename {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	PathType pathType;
	unsigned char pathName;
//	PathType newType;
//	StringPtr newName;
};

struct FPSetDirParms {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	Bitmap bitmap;
	PathType pathType;
	unsigned char pathName;
//	struct FPDirParam dp;
};

struct FPSetFileDirParms {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	Bitmap bitmap;
	PathType pathType;
	unsigned char pathName;
//	union {
//		struct FPDirParam dp;
//		struct FPFileParam fp;
//		} u;
};
struct FPSetFileParms {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	DirID dirID;
	Bitmap bitmap;
	PathType pathType;
	unsigned char pathName;
//	struct FPFileParam fp;
};

struct FPSetForkParms {
	FPFunc funcCode;
	unsigned char pad;
	ForkRef forkRef;
	Bitmap bitmap;
	unsigned long forkLen;
};

struct FPSetVolParms {
	FPFunc funcCode;
	unsigned char pad;
	VolID volID;
	Bitmap bitmap;
	Date backupDate;
};

struct FPWrite {
	FPFunc funcCode;
	Flag startEndFlag;
	ForkRef forkRef;
	long offset;
	long reqCount;
};

struct FPWriteExt {
	FPFunc funcCode;
	Flag startEndFlag;
	ForkRef forkRef;
	long long offset;
	long long reqCount;
};

struct FPZzzzz {
	FPFunc funcCode;
	unsigned char pad;
	unsigned long flag;
};

struct FPGetSessionToken {
	FPFunc funcCode;
	unsigned char   pad;
	short	type;
};

struct FPDisconnectOldSession {
	FPFunc funcCode;
	unsigned char   pad;
	short   type;
	unsigned long	length;
	unsigned char	data;
};

typedef union FPRequestParam FPRequestParam;
union FPRequestParam {
	struct FPAddAPPL fpAddAPPLRequest; 
	struct FPAddComment fpAddCommentRequest;
	struct FPAddIcon fpAddIconRequest;
	struct FPByteRangeLock fpByteRangeLockRequest;
	struct FPByteRangeLockExt fpByteRangeLockExtRequest;
	struct FPCatSearch fpCatSearchRequest;
	struct FPCatSearchExt fpCatSearchExtRequest;
	struct FPChangePassword fpChangePasswordRequest;
	struct FPCloseDir fpCloseDirRequest;
	struct FPCloseDT fpCloseDTRequest;
	struct FPCloseFork fpCloseForkRequest;
	struct FPCloseVol fpCloseVolRequest;
	struct FPCopyFile fpCopyFileRequest;
	struct FPCreateDir fpCreateDirRequest;
	struct FPCreateFile fpCreateFileRequest;
	struct FPCreateID fpCreateIDRequest;
	struct FPDelete fpDeleteRequest;
	struct FPDeleteID fpDeleteIDRequest;
	struct FPEnumerate fpEnumerateRequest;
	struct FPEnumerateExt fpEnumerateExtRequest;
	struct FPExchangeFiles fpExchangeFilesRequest;
	struct FPFlush fpFlushRequest;
	struct FPFlushFork fpFlushForkRequest;
	struct FPGetAPPL fpGetAPPLRequest;
	struct FPGetComment fpGetCommentRequest;
	struct FPGetFileDirParms fpGetFileDirParmsRequest;
	struct FPGetForkParms fpGetForkParmsRequest;
	struct FPGetIcon fpGetIconRequest;
	struct FPGetIconInfo fpGetIconInfoRequest;
	struct FPGetSrvrInfo fpGetSrvrInfoRequest;
	struct FPGetSrvrMsg fpGetSrvrMsgRequest;
	struct FPGetSrvrParms fpGetSrvrParmsRequest;
	struct FPGetUserInfo fpGetUserInfoRequest;
	struct FPGetVolParms fpGetVolParmsRequest;
	struct FPLogin fpLoginRequest;
	struct FPLoginCont fpLoginContRequest;
	struct FPLoginExt fpLoginExtRequest;
	struct FPLogout fpLogoutRequest;
	struct FPMapID fpMapIDRequest;
	struct FPMapName fpMapNameRequest;
	struct FPMoveAndRename fpMoveAndRenameRequest;
	struct FPOpenDir fpOpenDirRequest;
	struct FPOpenDT fpOpenDTRequest;
	struct FPOpenFork fpOpenForkRequest;
	struct FPOpenVol fpOpenVolRequest;
	struct FPRead fpReadRequest;
	struct FPReadExt fpReadExtRequest;
	struct FPRemoveAPPL fpRemoveAPPLRequest;
	struct FPRemoveComment fpRemoveCommentRequest;
	struct FPRename fpRenameRequest;
	struct FPResolveID fpResolveIDRequest;
	struct FPSetDirParms fpSetDirParmsRequest;
	struct FPSetFileDirParms fpSetFileDirParmsRequest;
	struct FPSetFileParms fpSetFileParmsRequest;
	struct FPSetForkParms fpSetForkParmsRequest;
	struct FPSetVolParms fpSetVolParmsRequest;
	struct FPWrite fpWriteRequest;
	struct FPWriteExt fpWriteExtRequest;
	struct FPZzzzz	fpFPZzzzz;
	struct FPGetSessionToken fpGetSessionToken;
	struct FPDisconnectOldSession fpDisconnectOldSession;
};

#if PRAGMA_STRUCT_ALIGN
        #pragma options align=reset
#elif PRAGMA_STRUCT_PACKPUSH
        #pragma pack(pop)
#elif PRAGMA_STRUCT_PACK
        #pragma pack()
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamencrypt.h ===
// ===========================================================================
//	UAMEncrypt.h 			 1998-2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "macssp.h"

#define kOneWayEncryptedArgSize					16
#define kServerChallengeMaxLen					8
#define kServerChallengeExtCharMapTableSize		128
#define kStartingExtendedCharValue				0x80
#define kIllegalMappedExtChar					0xFF
#define UAM_USERNAMELEN							32
#define UAM_USERNAMELEN_V3						64
#define UAM_CLRTXTPWDLEN						14
#define UAM_ENCRYPTEDPWLEN						32

//
//Added for MS2.0/MS3.0 authentication.
//
#define UAM_MAX_LMv2_PASSWORD					kMaxPwdLength


Boolean
UAM_GetEncryptedLmOwfPassword(
	char*		inClearTextPassword,
	char*		inServerChallenge,
	char*		outEncryptedOwfPassword
);

Boolean
UAM_GetDoubleEncryptedLmOwfPasswords(
	char*		inClearTextPassword,
	char*		inKey,
	char*		outEncryptedOwfPasswords
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamdebug.h ===
// ===========================================================================
//	UAMDebug.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Debugging routines for MS UAM.
// 	===========================================================================

#pragma once

#include "UAMUtils.h"

#include <stdio.h>
#include <String.h>
#include <macstrsafe.h>

#ifdef UAMDebug

#define DBGBUFF				_buff,sizeof(_buff)

#ifdef UAM_TARGET_CARBON
#define DbgPrint_(x)		do {																	\
								char	_buff[256];													\
								StringCbPrintf x;															\
 								printf("%s%s", _buff, "\n");										\
							}while(false)
						
#else
#define DbgPrint_(x)		do {																	\
								char	_buff[256];													\
								StringCbPrintf x;															\
								StringCbCat(_buff, sizeof(_buff), ";"); 												\
								StringCbCat(_buff, sizeof(_buff), "g");													\
 								DebugStr(_c2pstr(_buff));											\
							}while(false)
#endif //UAM_TARGET_CARBON

#define Assert_(test) 		do {																	\
								if (!(test)) {														\
									DbgPrint_((DBGBUFF, "Assertion failed: (%s) file: %s line: %d", \
														#test, __FILE__, __LINE__)); 				\
								}																	\
							}while(false)
							
#define DBGPrintIfOSErr_(err)	if (err != noErr) { 												\
									DbgPrint_((DBGBUFF, "OSErr: %d, line: %d  file: %s", 			\
														err, __LINE__, __FILE__)); 					\
								}

#else
#define DbgPrint_(x)
#define Assert_(test)
#define DBGPrintIfOSErr_(err)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamdialogs.h ===
// ===========================================================================
//	UAMDialogs.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "ClientUAM.h"
#include "UAMMain.h"
#include "UAMUtils.h"

#define DLOG_ChangePwd	12129
#define ALRT_Error		135
#define ALRT_Error2		136

#define MAX_PASSWORD_ENTRY_ERRORS	2

//
//Standard dialog items throughout all our dialogs.
//

#define DITEM_OK		1
#define DITEM_Cancel	2

//
//Codes that UAM_ChangePswd return
//
#define CHNGPSWD_UPDATE_KEYCHAIN	1000
#define CHNGPSWD_USER_CANCELED		1001
#define CHNGPSWD_NOERR				noErr

//
//These are our UAM specific error codes.
//
enum
{
	uamErr_InternalErr				= 1000,
	uamErr_NoAFPVersion,
	uamErr_WrongClientErr,
    
    uamErr_ErrorMessageString,
    uamErr_DefaultExplanation,
    
    uamErr_PasswordExpirationMessage,
    uamErr_PasswordExpirationExplanation,
    
    uamErr_KeychainEntryExistsMessage,
    uamErr_KeychainEntryExistsExplanation,
    
    uamErr_PasswordMessage,
    uamErr_PasswordTooLongExplanation,
    uamErr_NoBlankPasswordsAllowed,			//This is against Win2K Gold only
    uamErr_ExtendedCharsNotAllowed,			//This is against Win2K Gold only
    
    uamErr_WARNINGMessage,					//Displays "WARNING!" at the top
    uamErr_UsingWeakAuthentication,			//For weak auth message
    
    uamErr_AuthenticationMessage,
    uamErr_AuthTooWeak
};

//
//Prototypes for dialog routines live here.
//

void 			UAM_ReportError(OSStatus inError);
void 			UAM_StandardAlert(SInt16 inMessageID, SInt32 inExplanation, SInt16* outSelectedItem);
pascal Boolean  UAM_ChangePwdDialogFilter(DialogRef inDialog, EventRecord *inEvent, SInt16 *inItem);
OSStatus		UAM_ChangePwd(UAMArgs *inUAMArgs);
void 			UAM_ChangePasswordNotificationDlg(Int16 inDaysTillExpiration);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamkeychain.cpp ===
// ===========================================================================
//	UAMKeychain.c 			 1999-2000 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Keychain support routines for the MS UAM.
//
// ===========================================================================

#include "UAMDebug.h"
#include "UAMUtils.h"
#include "UAMMain.h"
#include "UAMDialogs.h"
#include "UAMNetwork.h"
#include "UAMKeychain.h"

Boolean				gKeychainAvailable	= false;
Boolean				gAllowedToSavePswd	= false;

extern Str32 		gServerName;
extern Str32		gUserName;
extern Str32		gZoneName;
extern OTAddress*	gServerAddress;
extern long			gSupportedUAMs;


// ---------------------------------------------------------------------------
//		 UAM_KCInitialize()
// ---------------------------------------------------------------------------
// See if the keychain is supported on this machine as well as perform some
// initialization for our keychain support.

void UAM_KCInitialize(UAMArgs* inUAMArgs)
{
	UInt32	theVersion;
	SInt32	theResponse;
	OSErr	theError;
	
	gKeychainAvailable	= false;
	gAllowedToSavePswd	= false;
	
	//
	//Do a check here to make sure that we're running on a
	//system version that we support.
	//
	
	theError = Gestalt(gestaltSystemVersion, &theResponse);
	if (theError != noErr)
	{
		//
		//If there's an error calling Gestalt(), we're in real trouble.
		//
		return;
	}
	
	if (LoWord(theResponse) < 0x0900)
	{
		//
		//We don't support any OS older than MacOS 9.0. This is
		//because the old Keychain (v1.01) on older systems is
		//not stable enough and crashes often.
		//
		return;
	}
		
	//
	//Let's see if the Apple KeyChain manager is available and
	//remember it.
	//
	gKeychainAvailable = KeychainManagerAvailable();
	
	if (gKeychainAvailable)
	{
		//
		//Get the version of the keychain manager. OS9 uses
		//v2.0 and is the first shipping version. However, v1.0
		//was available to pre-OS9 macs.
		//
		KCGetKeychainManagerVersion(&theVersion);
		
		//
		//The version is kept in the hi-word of the return.
		//
		if (HiWord(theVersion) >= 0x0200)
		{
			//
			//Just in case someone else turned it off, we make sure
			//interaction is enabled. This call is only supported in
			//Keychain 2.0 or later.
			//
			KCSetInteractionAllowed(true);
		}
	}

	//
	//For debug, print out the availability.
	//
	DbgPrint_((DBGBUFF, "Keychain Manager available = %d", gKeychainAvailable));

	//
	//BIT_2 of the srvr flags tells us if the user is allowed
	//to save their passwords in the keychain.
	//
	gAllowedToSavePswd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & BIT_2) == 0);
}


// ---------------------------------------------------------------------------
//		 UAM_KCAvailable()
// ---------------------------------------------------------------------------
// Returns TRUE if the keychain is available on this machine as well as if
// the AFP server allows clients to save passwords on the workstation.

Boolean UAM_KCAvailable(void)
{
	return(((gKeychainAvailable) && (gAllowedToSavePswd)) ? true : false);
}


// ---------------------------------------------------------------------------
//		 UAM_KCDeleteItem()
// ---------------------------------------------------------------------------
// Deletes a keychain item that pertains to this username & server.

OSStatus UAM_KCDeleteItem(
			StringPtr 	inUserName,
			Str255 		inServerName
)
{
	OSStatus	theStatus;
	KCItemRef	theItem		= NULL;
	
	theStatus = UAM_KCFindAppleSharePassword(
					inUserName,
					NULL,
					inServerName,
					&theItem
	);
	
	if (theStatus != noErr)
	{
		//
		//We couldn't find an existing keychain item matching
		//the criteria. Bail.
		//
		return(theStatus);
	}
	
	Assert_(theItem != NULL);
	
	if (theItem != NULL)
	{
		//
		//We found the item, remove it from the keychain.
		//
		theStatus = KCDeleteItem(theItem);
		
		//
		//The keychain manager allocated this memory, we need to
		//free it. For free builds, we don't do anything if this
		//fails since there's nothing we or the user can do about it.
		//		
		if (KCReleaseItem(&theItem) != noErr)
		{
			DbgPrint_((DBGBUFF, "KCReleaseItem() failed"));
		}
	}
	
	return(theStatus);
}


// ---------------------------------------------------------------------------
//		 UAM_KCSavePassword()
// ---------------------------------------------------------------------------

OSStatus UAM_KCSavePassword(
			StringPtr 	inUserName,
			StringPtr 	inPassword,
			Str255 		inServerName
)
{
	OSStatus 				theStatus;
	OSType					theTypeData;
	KCAttribute				theAttribute;
	KCItemRef				theItem		= NULL;
	Boolean					theIconFlag = true;
	PUAM_AFPXVolMountInfo	theUAMInfo	= NULL;
	
	Assert_(UAM_KCAvailable() == true);
	
	//
	//Search for an item in the keychain that already matches
	//what we are about to add. Note we have to do this because
	//of a bug in the keychain manager that prevents it from
	//doing it for us.
	//
	theStatus = UAM_KCFindAppleSharePassword(
					inUserName,
					NULL,
					inServerName,
					NULL
	);
	
	if (theStatus == noErr)
	{
		//
		//If we get here, then that means there is already
		//an item in the keychain for this server and account.
		//
		return(errKCDuplicateItem);
	}
	
	//
	//Call our function that builds the AFPXVolMountInfo
	//structure that we pass to the keychain routine.
	//
	theStatus = UAM_BuildAFPXVolMountInfo(
					inUserName,
					inPassword,
					inServerName,
					(gSupportedUAMs & kMSUAM_V2_Supported) ? 
					PSTR_EncryptedLogin2_0 : PSTR_EncryptedLogin1_0,
					&theUAMInfo
	);
	
	if (theStatus != noErr)
	{
		//
		//If we failed here, it's bad news. This means we
		//don't have enough memory to allocate a small
		//buffer.
		//
		return(theStatus);
	}
		
	//
	//Have the keychain store our key information for this
	//server.
	//
	theStatus = KCAddAppleSharePassword(
					NULL,
					(PSTR_LENGTH(gZoneName)) ? gZoneName : NULL,
					inServerName,
					NULL,
					inUserName,
					sizeof(UAM_AFPXVolMountInfo),
					theUAMInfo,
					&theItem
	);
	
	if (theStatus != noErr)
	{
		//
		//Check for cancel action by the user and report error.
		//
		if (theStatus != userCanceledErr)
		{
			DbgPrint_((DBGBUFF, "KCAddAppleSharePassword() failed (%d)", (int)theStatus));
		}
	}
	else
	{
		do
		{
			//
			//Set the title of this keychain item so folks know
			//what it's for.
			//
			theAttribute.tag	= kDescriptionKCItemAttr;
			theAttribute.length	= PSTR_LENGTH(UAM_KC_DESCRIPTION);
			theAttribute.data	= (void*)&UAM_KC_DESCRIPTION[1];
			
			theStatus = KCSetAttribute(theItem, &theAttribute);	
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kLabelKCItemAttr) failed (%d)", (int)theStatus));
				break;
			}

			//
			//Tell the keychain to use our MS UAM icon when displaying
			//the keys to the user.
			//
			
			//
			//Set the creator of the MS UAM.
			//
			theTypeData			= UAM_CREATOR;
			
			theAttribute.tag	= kCreatorKCItemAttr;
			theAttribute.length	= sizeof(OSType);
			theAttribute.data	= &theTypeData;
			
			theStatus = KCSetAttribute(theItem, &theAttribute);	
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kCreatorKCItemAttr) failed (%d)", (int)theStatus));
				break;
			}
			
			//
			//Set the type to our code type (uams)
			//
			theTypeData			= UAM_TYPE;
			
			theAttribute.tag	= kTypeKCItemAttr;
			theAttribute.length	= sizeof(OSType);
			theAttribute.data	= &theTypeData;
			
			theStatus = KCSetAttribute(theItem, &theAttribute);
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kTypeKCItemAttr) failed (%d)", (int)theStatus));
				break;
			}
			
			//
			//Lastly, tell the keychain manager we have a custom icon.
			//
			theAttribute.tag	= kCustomIconKCItemAttr;
			theAttribute.length	= sizeof(Boolean);
			theAttribute.data	= &theIconFlag;
			
			theStatus = KCSetAttribute(theItem, &theAttribute);
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kCustomIconKCItemAttr) failed (%d)", (int)theStatus));
				break;
			}
		}while(false);
		
		//
		//Only do the update if everthing above passed. Otherwise
		//we'll loose the error code. What to do, what to do...
		//
		if (theStatus == noErr)
		{
			//
			//After setting the attributes on the item, we need to tell
			//the keychain to save our changes.
			//
			theStatus = KCUpdateItem(theItem);
			
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCUpdateItem() failed (%d);g", (int)theStatus));
			}
		}
		
		//
		//The keychain manager allocated this memory, we need to
		//free it. For free builds, we don't do anything if this
		//fails since there's nothing we or the user can do about it.
		//		
		if (KCReleaseItem(&theItem) != noErr)
		{
			DbgPrint_((DBGBUFF, "KCReleaseItem() failed"));
		}
	}
	
	//
	//Free up our mount volume info structure.
	//
	if (theUAMInfo != NULL)
	{
		DisposePtr((Ptr)theUAMInfo);
	}
	
	return(theStatus);
}


// ---------------------------------------------------------------------------
//		 UAM_KCFindAppleSharePassword()
// ---------------------------------------------------------------------------
// Look for a password associated with this server and account in the
// keychain.

OSStatus UAM_KCFindAppleSharePassword(
			StringPtr	inUserName,
			StringPtr	inPassword,
			StringPtr	inServerName,
			KCItemRef*	outItemRef
)
{
	OSStatus				theStatus		= noErr;
	UInt32					theActualLen 	= 0;
	UInt32					theBuffSize		= sizeof(UAM_AFPXVolMountInfo);
	PUAM_AFPXVolMountInfo	theUamInfo		= NULL;
	
	Assert_(UAM_KCAvailable() == true);
	
	do
	{
		theUamInfo = (PUAM_AFPXVolMountInfo)NewPtrClear(theBuffSize);
		
		if (theUamInfo == NULL)
		{
			theStatus = memFullErr;
			break;
		}
		
		theStatus = KCFindAppleSharePassword(
						NULL,
						NULL,
						inServerName,
						NULL,
						inUserName,
						theBuffSize,
						theUamInfo,
						&theActualLen,
						outItemRef
		);
		
		//
		//If the buffer we supplied is too small, then reallocate the
		//buffer according to what is actually needed. NOTE: We will
		//only need to reallocate when looking at keychains that we
		//did not create ourselves.
		//
		
		if (theStatus == errKCBufferTooSmall)
		{
			DisposePtr((Ptr)theUamInfo);
			
			theUamInfo 	= NULL;
			theBuffSize = theActualLen;
			
			DbgPrint_((DBGBUFF, "Reallocating for %d bytes", (int)theActualLen));
			continue;
		}
		
		break;
				
	}while(TRUE);
		
	if (theStatus == noErr)
	{
		//
		//Initialize expecting failure. For lack of anything
		//better we return param error.
		//
		theStatus = paramErr;
		
		//
		//First make sure we have a proper mount structure.
		//
		if ( (theUamInfo->media == AppleShareMediaType)	&&
			 (theUamInfo->userPasswordOffset != 0)		)
		{
			//
			//Copy the password into a temp buffer and make sure it's
			//not zero length. But, only if inPassword is not null.
			//
			if (inPassword != NULL)
			{
				//
				//01.16.02: Pass maximum length to string copy routine.
				//
				StringPtr	thePassword = (StringPtr)(((UInt32)theUamInfo) + 
													theUamInfo->userPasswordOffset);
				
				UAM_PStrCopy(thePassword, inPassword, UAM_MAX_LMv2_PASSWORD);
			}
			
			theStatus = noErr;
		}
	}
	else if (theStatus != errKCItemNotFound)
	{
		//
		//For debugging only, we print out the error code.
		//
		DbgPrint_((DBGBUFF, "KCFindAppleSharePassword() failed (%d)", (int)theStatus));
	}
	
	//
	//We don't need this buffer anymore, free it up.
	//
	if (theUamInfo != NULL)
	{
		DisposePtr((Ptr)theUamInfo);
	}
	
	return(theStatus);
}


// ---------------------------------------------------------------------------
//		 UAM_BuildAFPXVolMountInfo()
// ---------------------------------------------------------------------------
// Builds the AFPXVolMountInfo structure that we need to send to the keychain.

OSStatus UAM_BuildAFPXVolMountInfo(
			StringPtr 				inUserName,
			StringPtr 				inPassword,
			Str255 					inServerName,
			const Str32				inUAMString,
			PUAM_AFPXVolMountInfo*	outVolInfo
)
{
	PUAM_AFPXVolMountInfo	uamInfo		= NULL;
	Size					uamInfoSize	= 0;
	
	*outVolInfo = NULL;
	uamInfoSize = sizeof(UAM_AFPXVolMountInfo);
	
	uamInfo = (PUAM_AFPXVolMountInfo)NewPtrClear(uamInfoSize);
	
	if (uamInfo != NULL)
	{
		uamInfo->length			= uamInfoSize;
		uamInfo->media			= AppleShareMediaType;
		uamInfo->flags			= 0;
		
		//
		//We're not going to pass any alternate address info. We'll
		//let the AS Client do that for us.
		//
		uamInfo->extendedFlags 			= 0;
		uamInfo->alternateAddressOffset	= 0;
		
		//
		//NBP and UAM Type stuff. Note we use our unique UAM indetifier
		//for the uam type.
		//
		uamInfo->nbpInterval	= 10;
		uamInfo->nbpCount		= 10;
		uamInfo->uamType		= UAM_TYPE_CODE;
		
		//
		//Now setup all the offsets for the parameters. Yuck!
		//
		
		//
		//We don't always get a zone name from the client, we get
		//nil if we're using IP.
		//
		if (PSTR_LENGTH(gZoneName) > 0)
		{
			uamInfo->zoneNameOffset	= uamx_member_offset(zoneName);
			UAM_PStrCopy(gZoneName, uamInfo->zoneName, sizeof(uamInfo->zoneName));
		}
		else
		{
			uamInfo->zoneNameOffset	= 0;
		}
		
		uamInfo->volNameOffset		= 0;
		uamInfo->serverNameOffset	= uamx_member_offset(serverName);
		uamInfo->userNameOffset		= uamx_member_offset(userName);
		uamInfo->userPasswordOffset	= uamx_member_offset(userPassword);
		uamInfo->uamNameOffset		= uamx_member_offset(uamNameOffset);
		
		//
		//Now actually copy the data.
		//
		//01.16.02: Now pass maximum length to string copy routine.
		//
		UAM_PStrCopy(
			inServerName,
			uamInfo->serverName,
			sizeof(uamInfo->serverName)
			);
		UAM_PStrCopy(
			inUserName,
			uamInfo->userName,
			sizeof(uamInfo->userName)
			);
		UAM_PStrCopy(
			inPassword,
			uamInfo->userPassword,
			sizeof(uamInfo->userPassword)
			);
		UAM_PStrCopy(
			(StringPtr)inUAMString,
			uamInfo->uamName,
			sizeof(uamInfo->uamName)
			);
	}
	else
	{
		DbgPrint_((DBGBUFF, "Failed to allocated AFPX buffer! (%d)", MemError()));
		
		//
		//Couldn't allocate memory for structure.
		//
		return(memFullErr);
	}
	
	*outVolInfo = uamInfo;
	
	return(noErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamdialogs.cpp ===
// ===========================================================================
//	UAMDialogs.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// General dialog utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#include <macstrsafe.h>

#include "UAMDebug.h"
#include "UAMDialogs.h"
#include "UAMUtils.h"
#include "UAMNetwork.h"
#include "UAMDLOGUtils.h"
#include "UAMKeychain.h"
#include "UAMPswdField.h"
#include "UAMPrefs.h"

#ifndef UAM_TARGET_CARBON
extern ModalFilterUPP	gDialogFilter;
#endif

extern Str32 			gServerName;
extern UserItemUPP		gLineItem;
extern long				gSupportedUAMs;
extern UAM_PREFERENCES	gUAMPreferences;

SInt16	gNumPasswordEntryErrors = 0; 


// ---------------------------------------------------------------------------
//		 UAM_ReportError()
// ---------------------------------------------------------------------------
//	Reports an error to the user by displaying an alert box. 
//

void UAM_ReportError(OSStatus inError)
{
    UAM_StandardAlert(uamErr_ErrorMessageString, inError, NULL);
}

// ---------------------------------------------------------------------------
//		 UAM_StandardAlert()
// ---------------------------------------------------------------------------
//	Puts up a standard alert box for reporting errors and other items to the
//	user.
//
//	The routine looks for resources of type 'STR ' to get the strings
//	associated with the message and explanations.
//

void UAM_StandardAlert(SInt16 inMessageID, SInt32 inExplanation, SInt16* outSelectedItem)
{
    StringHandle			theMessage		= NULL;
    StringHandle			theExplanation	= NULL;
    SInt16					theSelectedItem;
        
    #ifdef UAM_TARGET_CARBON
    AlertStdAlertParamRec	theAlertRec;
    
    SysBeep(1);
    
    theAlertRec.movable			= TRUE;
    theAlertRec.helpButton		= FALSE;
    theAlertRec.filterProc		= NULL;
    theAlertRec.defaultText		= (UInt8*)kAlertDefaultOKText;
    theAlertRec.cancelText		= NULL;
    theAlertRec.otherText		= NULL;
    theAlertRec.defaultButton	= kAlertStdAlertOKButton;
    theAlertRec.position		= kWindowAlertPositionMainScreen;
    
    //
    //If the caller is looking for the button the user selected, then we
    //assume that the user wants a cancel button.
    //
    if (outSelectedItem != NULL)
    {
        theAlertRec.cancelButton	= kAlertStdAlertCancelButton;
    }
    else
    {
        theAlertRec.cancelButton	= 0;
    }
    #endif //UAM_TARGET_CARBON
    
    InitCursor();

    if (outSelectedItem != NULL)
    {
        *outSelectedItem = 0;        
    }
    
    theMessage = GetString(inMessageID);
    
    if (theMessage != NULL)
    {
        HLock((Handle)theMessage);
        
        theExplanation = GetString(inExplanation);
        
        if (theExplanation == NULL)
        {
            //
            //We didn't find an error string corresponding to this error, so
            //put up a general error message.
            //
            theExplanation = GetString(uamErr_DefaultExplanation);
        }
        
        if (theExplanation != NULL)
        {
            HLock((Handle)theExplanation);
            
            #ifdef UAM_TARGET_CARBON
            
            StandardAlert(
            	kAlertStopAlert, 
            	*theMessage, 
            	*theExplanation, 
            	&theAlertRec, 
            	&theSelectedItem
            	);
            
            #else
            
            ParamText(NULL, NULL, *theMessage, *theExplanation);
            theSelectedItem = StopAlert((outSelectedItem == NULL) ? ALRT_Error : ALRT_Error2, NULL);
            	
            #endif
            
            if (outSelectedItem != NULL)
            {
                *outSelectedItem = theSelectedItem;
            }
            
            HUnlock((Handle)theExplanation);
            ReleaseResource((Handle)theExplanation);
        }
        
        HUnlock((Handle)theMessage);
        ReleaseResource((Handle)theMessage);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePwdDialogFilter()
// ---------------------------------------------------------------------------
// Dialog filter for the change password dialog.
//

pascal Boolean UAM_ChangePwdDialogFilter(DialogRef inDialog, EventRecord *inEvent, SInt16 *inItem)
{
    Boolean		theResult	= FALSE;
    SInt16		theCode;
    
	if ((inEvent->what == keyDown) || (inEvent->what == autoKey))
	{
		theCode = (inEvent->message & charCodeMask);
        
		if ((inEvent->modifiers & cmdKey) && (inEvent->what != autoKey))
		{
			switch(theCode)
			{
				//
				//Don't allow users to cut/copy or paste their passwords.
				//
				case 'c':
				case 'C':
				case 'v':
				case 'V':
				case 'x':
				case 'X':
					theResult = TRUE;
					break;
					
				default:
					break;
			}
		}
		else if ((inEvent->modifiers & optionKey) || (inEvent->modifiers & controlKey))
		{
			//
			//We do not allow the use of extended or control characters. This is because
			//there is no way to map them over to the windows code page.
			//
			
			//
			//If the user tried to use extended chars more than once, we
			//put up a dialog telling them they are not allowed.
			//
			gNumPasswordEntryErrors++;
			
			if (gNumPasswordEntryErrors >= MAX_PASSWORD_ENTRY_ERRORS)
			{
				UAM_StandardAlert(
					uamErr_PasswordMessage,
					uamErr_ExtendedCharsNotAllowed,
					NULL
					);
					
				gNumPasswordEntryErrors = 0;
			}
			else {
			
				SysBeep(1);
			}
			
			theResult = TRUE;
		}
		else
		{
			switch(theCode)
			{
				case UAMKey_Escape:
					*inItem		= DITEM_Cancel;
					theResult 	= TRUE;
					break;
					
				case UAMKey_Enter:
				case UAMKey_Return:
					*inItem		= DITEM_OK;
					theResult	= TRUE;
					break;
					
				default:
					break;
			}
		}
    }

	#ifdef UAM_TARGET_CARBON
	
    if (theResult == FALSE)
    {
        theResult = StdFilterProc(inDialog , inEvent, inItem);
    }
    
    #endif
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePwd()
// ---------------------------------------------------------------------------
//	Puts up and handles the change password dialog and calls the appropriate
//	routines to change the password.
//
//	Unless there is an error, we'll usually return one of:
//
//	#define CHNGPSWD_UPDATE_KEYCHAIN	1000
//	#define CHNGPSWD_USER_CANCELED		1001
//	#define CHNGPSWD_NOERR				noErr

#define DITEM_Icon			3
#define DITEM_OldPassword	6
#define DITEM_NewPassword	8
#define DITEM_VerifyPwd		10
#define DITEM_LineItem		11

OSStatus UAM_ChangePwd(UAMArgs *inUAMArgs)
{
	GrafPtr			theSavePort;
	short			theItem;
	Str255			theNewPwd, theVerPwd;
	CursHandle		theCursor;
	OSStatus		theError		= noErr;
	DialogRef		theDialog 		= NULL;
	Boolean			theDoLoop 		= true;
	KCItemRef		theKCItemRef	= NULL;
    ModalFilterUPP	theFilter		= NULL;
	
	Assert_(gLineItem != NULL);
    
    theFilter = NewModalFilterUPP(&UAM_ChangePwdDialogFilter);
    
    if (theFilter == NULL)
    {
        //
        //Bad problems if we couldn't allocate a little ol upp!
        //
        return(-108);
    }
	
	GetPort(&theSavePort);
	
	ParamText(inUAMArgs->Opt.pwDlg.userName, gServerName, NULL, NULL);
	
	#ifdef UAM_TARGET_CARBON
	theDialog = GetNewDialog(DLOG_ChangePwd, NULL, (WindowPtr)-1);
	#else
	theDialog = UAM_NewDialog(DLOG_ChangePwd, true);
	#endif
	
	if (theDialog == NULL)
	{
		UAM_ReportError(resNotFound);
		return(resNotFound);
	}
		
	//
	//Set up the line at the top of the dialog.
	//
	
	UAM_SetupDialogUserItem(theDialog, DITEM_LineItem, gLineItem, userItem);
	
	//
	//Initialize the 3 password edit fields.
   	//
	UAM_InitializeDialogPasswordItem(theDialog, DITEM_OldPassword);
    UAM_InitializeDialogPasswordItem(theDialog, DITEM_NewPassword);
    UAM_InitializeDialogPasswordItem(theDialog, DITEM_VerifyPwd);
		
	if (inUAMArgs->Opt.pwDlg.password[0] != 0)
	{
		UAM_SetPasswordText(
					theDialog,
					DITEM_OldPassword,
					inUAMArgs->Opt.pwDlg.password	);
        
        UAM_MakePasswordItemFocusItem(theDialog, DITEM_NewPassword);
	}
	else {
        UAM_MakePasswordItemFocusItem(theDialog, DITEM_OldPassword);
	}
    
    #ifdef UAM_TARGET_CARBON
    
    SetPortDialogPort(theDialog);
    ShowWindow(GetDialogWindow(theDialog));
    
    BringToFront(GetDialogWindow(theDialog));
    	
    #else
    
   	UAM_SetCustomFilterProc(theDialog, theFilter);

    #endif
    
	//
	//Tell the password key filter the maximum password length to allow.
	//
	UAM_SetMaximumPasswordLength(true);

	do
	{
		ModalDialog(
			#ifdef UAM_TARGET_CARBON
			theFilter, 
			#else
			gDialogFilter,
			#endif
			&theItem);
		
		switch(theItem)
		{
			case 1:
				UAM_GetPasswordText(theDialog, DITEM_NewPassword, theNewPwd);
				UAM_GetPasswordText(theDialog, DITEM_VerifyPwd,   theVerPwd);
				UAM_GetPasswordText(theDialog, DITEM_OldPassword, inUAMArgs->Opt.pwDlg.password);
				
				//
				//Ensure the new and verified password are equal. If not, present an
				//error to the user and give 'em a chance to correct the problem.
				//
				
				if (!EqualString(theNewPwd, theVerPwd, true, true))
				{
					UAM_ReportError(afpNTNewPasswordMismatchErr);
					
					UAM_SetPasswordText(theDialog, DITEM_NewPassword, "\p");
					UAM_SetPasswordText(theDialog, DITEM_VerifyPwd, "\p");
                    
                    UAM_MakePasswordItemFocusItem(theDialog, DITEM_NewPassword);
					break;
				}
				
                //
                //Let the user know they may wait a while for the operation to
                //complete.
                //
				theCursor = GetCursor(watchCursor);
				if (theCursor) {
					SetCursor(*theCursor);
				}
				
                //
                //Make sure the user is not trying to enter in a blank or null 
                //password for the old or new password.
                //
                if ((PSTR_LENGTH(inUAMArgs->Opt.auth.password) == 0) || (PSTR_LENGTH(theNewPwd) == 0))
                {
                    UAM_StandardAlert(
                        uamErr_PasswordMessage,
                        uamErr_NoBlankPasswordsAllowed,
                        NULL
                    );

                    break;
                }
 
                //
                //Determine which change password method we're using. We use v1 for
                //NT4.0 and older servers and v2 for Windows2000 and v3 for .NET.
                //
                if (gSupportedUAMs & kMSUAM_V3_Supported)
                {
                    DbgPrint_((DBGBUFF, "CHANGE PSWD: using  UAM_ChangePasswordV3()"));
                    
                    theError = UAM_ChangePasswordForMS30(inUAMArgs, theNewPwd);
                }
				else if (gSupportedUAMs & kMSUAM_V2_Supported)
				{
					DbgPrint_((DBGBUFF, "CHANGE PSWD: using  UAM_ChangePasswordV2()"));
                    
					theError = UAM_ChangePasswordForMS20(inUAMArgs, theNewPwd);
				}
				else
                {
					//
					//Check and see if the user wants to allow this weak authentication
					//to take place.
					//
					if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)
					{
						//
						//Nope, the auth strength is too weak for the user to
						//stomach. Exit gracefully.
						//
						UAM_StandardAlert(
								uamErr_AuthenticationMessage,
								uamErr_AuthTooWeak,
								NULL
								);
								
						return(userCanceledErr);
					}
					
		        	DbgPrint_((DBGBUFF, "CHANGE PSWD: using  UAM_ChangePasswordV1()"));

					theError = UAM_ChangePasswordForMS10(inUAMArgs, theNewPwd);
				}
				
				if (theError == noErr)
				{
					if (UAM_KCAvailable())
					{
						//
						//See if a keychain existed for the user name.
						//If so, delete it.
						//
						if (UAM_KCFindAppleSharePassword(
									inUAMArgs->Opt.pwDlg.userName,
									inUAMArgs->Opt.pwDlg.password,
									gServerName,
									&theKCItemRef) == noErr)
						{
							theError = KCDeleteItem(theKCItemRef);
							
							if ((theError != noErr) && (theError != userCanceledErr))
							{
								DbgPrint_((DBGBUFF, "KCDeleteItem() failed (%d)", (int)theError));
								UAM_ReportError(theError);
							}
							else if (theError == noErr)
							{
								//
								//This is how we tell the main login routine to
								//re-enter the password into the keychain.
								//
								theError = CHNGPSWD_UPDATE_KEYCHAIN;
							}
							
							KCReleaseItem(&theKCItemRef);
						}
					}
					
					//
					//If we changed the password successfully, then store the
					//new password in the arguments struct.
					//
					UAM_PStrCopy(theNewPwd, inUAMArgs->Opt.pwDlg.password);
				}
								
				theDoLoop = false;
				break;
			
			case 2:
				theError  = CHNGPSWD_USER_CANCELED;
				theDoLoop = false;
				break;
			
			default:
				break;
		}
		
	}while(theDoLoop);
	
	DisposeDialog(theDialog);
	SetPort(theSavePort);
    
    DisposeRoutineDescriptor(theFilter);
		
	//
	//Reset the maximum password length for non-password changing ops.
	//
	UAM_SetMaximumPasswordLength(false);
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePasswordNotificationDlg()
// ---------------------------------------------------------------------------
//	Put up an about dialog.

void UAM_ChangePasswordNotificationDlg(Int16 inDaysTillExpiration)
{
	Str255			theDaysStr;
    
	NumToString(inDaysTillExpiration, theDaysStr);
	ParamText(theDaysStr, NULL, NULL, NULL);

    UAM_StandardAlert(uamErr_PasswordExpirationMessage, uamErr_PasswordExpirationExplanation, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamencrypt.cpp ===
// ===========================================================================
//	UAMEncrypt.c 			 1998-2001 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Ecryption functions for use by Microsoft User Authentication Method.
//
// ===========================================================================

#ifdef UAM_TARGET_CARBON
#include <CoreFoundation/CoreFoundation.h>
#endif

#include <string.h>
#include <ctype.h>

#include "UAMEncrypt.h"
#include "UAMDebug.h"


// ---------------------------------------------------------------------------
//		 UAM_GetEncryptedLmOwfPassword()
// ---------------------------------------------------------------------------
//	Using a combination of the above to functions, build an encrypted owf
//	password that we can send back to the server.
//
//	Returns: TRUE if the encryption attempt succeeded.
//

Boolean
UAM_GetEncryptedLmOwfPassword(
	char*		inClearTextPassword,
	char*		inServerChallenge,
	char*		outEncryptedOwfPassword
)
{
	LM_OWF_PASSWORD	theLmOwfPassword;
	
	memset(&theLmOwfPassword, '\0', sizeof(theLmOwfPassword));
	
	if (!MacSspCalculateLmOwfPassword(
				(PLM_PASSWORD)inClearTextPassword, 
				(PLM_OWF_PASSWORD)&theLmOwfPassword))
	{
		return(false);
	}
	
	if (!MacSspCalculateLmResponse(
				(PLM_CHALLENGE)inServerChallenge,
				(PLM_OWF_PASSWORD)&theLmOwfPassword,
				(PLM_RESPONSE)outEncryptedOwfPassword))
	{
		return(false);
	}
	
	return(true);
}


// ---------------------------------------------------------------------------
//		 UAM_GetDoubleEncryptedLmOwfPasswords()
// ---------------------------------------------------------------------------
//	Taken from the NT RtlXXX sources, this algorithm is designed to deal with the encryption
//	of two passwords, when the OneWayFunction of one is known on the target.  Specifically,
//	
//		for passwords x, y 
//	-- do a one way encryption of x  to Owf(x) -> result(0..15)
//	-- do a one way encryption of  y to Owf(x) -> result(16..31)
//

Boolean
UAM_GetDoubleEncryptedLmOwfPasswords(
	char*		inClearTextPassword,
	char*		inKey,
	char*		outEncryptedOwfPasswords
)
{
	if (!MacSspCalculateLmOwfPassword(
			(char*)inClearTextPassword,
			(PLM_OWF_PASSWORD)outEncryptedOwfPasswords))
	{
		return(false);
	}
		
	if (!MacSspCalculateLmOwfPassword(
			(char*)inKey,
			(PLM_OWF_PASSWORD)(outEncryptedOwfPasswords + kOneWayEncryptedArgSize)))
	{
		return(false);
	}
			
	return(true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamnetwork.cpp ===
// ===========================================================================
//	UAMNetwork.c 			 1998-2001 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Networking functions for use by Microsoft User Authentication Method.
//
//	There are several versions of authentication used by the UAM to an SFM
//	server. Here is the matrix which shows which Microsoft AFP encryption
//	version will be used depending on the server version.
//
//	Server Version		Auth	Chng Pswd		Notes
//	--------------		----	---------		---------------
//	NT 4.0				1.0		1.0				Weakest, LM Hash only
//	Win2K				2.0		2.0				NTLMv2 auth, LM Hash for chgn pswd
//	.NET				2.0		3.0				Strongest, using NTLMv2 for both
//
// ===========================================================================

#ifdef UAM_TARGET_CARBON
#include <CoreFoundation/CoreFoundation.h>
#include <Carbon/Carbon.h>
#endif

#include <macssp.h>

#include <String.h>
#include <macstrsafe.h>

#include "UAMMain.h"
#include "UAMEncrypt.h"
#include "UAMDebug.h"
#include "UAMNetwork.h"
#include "UAMUtils.h"
#include "UAMDLOGUtils.h"
#include "UAMDialogs.h"
#include "UAMKeychain.h"
#include "UAMPrefs.h"

unsigned char				gCmdBuffer[kMaxAFPCommand];
unsigned char				gReplyBuffer[kMaxAFPCommand];
MSUAMLoginReplyBlock		gMSUAMReply;

extern Str32 				gAFPVersion;
extern OTAddress			*gServerAddress;
extern long					gSupportedUAMs;
extern UInt32				gExpirationTime;
extern Str32				gServerName;
extern Boolean				gGuestLogon;
extern DialogPtr			gDialog;
extern UAM_PREFERENCES		gUAMPreferences;

// ---------------------------------------------------------------------------
//		 UAM_MapCharactersIntoHostSet()
// ---------------------------------------------------------------------------
//	Given a counted string, and a "host mapping table", do an in-place conversion
//	of that string into the host character set.  The table is construed to be
//	of length 255 - StartingExtendedCharValue chars long, and a character for
//	character conversion will be indicated for any chars in targetStr which 
//	are equal to or in excess of StartingExtendedCharValue.

Boolean UAM_MapCharactersIntoHostSet(char *szTarg, char *mappingTbl)
{
	unsigned char c;
		
	while (*szTarg)	
	{
		if ((unsigned char)*szTarg >= (unsigned char)kStartingExtendedCharValue)
		{
			c = *(mappingTbl+ (unsigned char)*szTarg - kStartingExtendedCharValue);
			if (c == kIllegalMappedExtChar) {
				DbgPrint_((DBGBUFF, "Illegal mapping character"));
				return(false);
			}
			else {
				*szTarg = c;
			}
		}
		
		szTarg++;
	}
			
	return(true);
}


#pragma mark-
// ---------------------------------------------------------------------------
//		 UAM_UAMLogin()
// ---------------------------------------------------------------------------
//	This routine does the actual logging onto the server.

OSStatus UAM_UAMLogin(UAMArgs *inUAMArgs)
{
	OSStatus	theError 	= noErr;
	Boolean		theLoop		= true;
	CursHandle	theCursor;
	
	Assert_(inUAMArgs != NULL);
							
	do
	{
		theCursor = GetCursor(watchCursor);
		SetCursor(*theCursor);
				
		if (gGuestLogon) {
			theError = UAM_LoginGuest(inUAMArgs);
		}
		else {
        	SspDebugPrintHex(
        			(char*)inUAMArgs->Opt.pwDlg.userName,
        			PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName)+1
        			);
        	SspDebugPrintHex(
        			(char*)inUAMArgs->Opt.pwDlg.password,
        			strlen((char*)inUAMArgs->Opt.pwDlg.password)
        			);

        	//
        	//The password buffer in UAMArgs is always in C style form. The encryption
        	//routines expect it to be in pascal style, so we convert it before we
        	//send it on.
        	//
        	if (strlen((char*)inUAMArgs->Opt.pwDlg.password) != 0)
        	{
        		_c2pstr((char*)inUAMArgs->Opt.pwDlg.password);
        	}

			theError = UAM_LoginMSUAM(inUAMArgs);
		}
		
		if (theError != noErr)
		{
			//
			//For whatever reason, we couldn't log into the server, handle the most
			//basic errors and try to logon again by presenting the login dialog
			//again. Otherwise, exit...
			//
			
			//
			//Make sure in debug that the password field is cleared in
			//an error condition.
			//
			Assert_(PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0);
			
			//
			//03.11.02 MJC: Only put up the error dialog for real errors.
			//
			if (theError != userCanceledErr) {
			
				UAM_ReportError(theError);
			}
				
			UAM_CloseSession(inUAMArgs);
			
			switch(theError)
			{
				//
				//Standard uam error codes that may occur during logon when
				//we will want to allow the user to try again.
				//
				//
				case afpNTPasswordExpired:
				case afpPwdExpiredErr:
				case afpUserNotAuth:
				case afpParmErr:
				case afpNTAccountDisabled:
				case afpNTInvalidWorkstation:
				case afpNTInvalidLogonHours:
				
				//
				//We use this error to signal to the uam that a non-critical error
				//has occured during login, most likely due to the users uam
				//configuration.
				//
				case userCanceledErr:
				
					if (MS_UAMPwdDialog(inUAMArgs) != noErr)
						return(userCanceledErr);
					break;
												
				default:
					theLoop 	= false;
					theError	= userCanceledErr;
					break;
			}
		}
		else
		{
			if ((gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) && (!gGuestLogon))
			{
				//
				//Check for password expiration at this point.
				//
				UInt32	theDaysTillExpiration = (((gExpirationTime / 60) / 60) / 24);
								
				if (theDaysTillExpiration <= MINIMUM_DAYS_TILL_EXPIRATION)
				{
					//
					//The password is going to expire within MINIMUM_DAYS_TILL_EXPIRATION,
					//post the nofication dialog.
					//
					
					UAM_ChangePasswordNotificationDlg(theDaysTillExpiration);
				}
			}
			
			if (UAM_KCAvailable())
			{
				//
				//If the user is allowed to save their password and
				//the keychain check box is checked, save the current
				//credentials to the keychain.
				//
				#ifdef UAM_TARGET_CARBON
				if (UAM_GetDialogControlValue(gDialog, DITEM_Keychain) > 0)
				#else
				if (UAM_GetCValue(gDialog, DITEM_Keychain) > 0)
				#endif
				{
					theError = UAM_KCSavePassword(
									inUAMArgs->Opt.auth.userName, 
									inUAMArgs->Opt.auth.password,
									gServerName
					);
					
					if ((theError != noErr) && (theError != userCanceledErr))
					{
						if (theError == errKCDuplicateItem)
						{
							Int16 theResponse;
							
							//
							//A duplicate item exists, see if the user wants
							//to replace it.
							//
							
                            UAM_StandardAlert(
                                        uamErr_KeychainEntryExistsMessage,
                                        uamErr_KeychainEntryExistsExplanation,
                                        &theResponse);
							
							if (theResponse == kAlertStdAlertOKButton)
							{
								//
								//The user asked us to replace the item. Try one
								//more time to add the keychain item.
								//
								theError = UAM_KCDeleteItem(
												inUAMArgs->Opt.auth.userName,
												gServerName
								);
								
								if (theError == noErr)
								{
									theError = UAM_KCSavePassword(
													inUAMArgs->Opt.auth.userName, 
													inUAMArgs->Opt.auth.password,
													gServerName
									);
									
									if (theError != noErr)
									{
										//
										//We errored out, nothing to do but report it.
										//
										UAM_ReportError(theError);
									}
								}
							}
						}
						else
						{
							UAM_ReportError(theError);
						}
						
						//
						//We do not want to pass back any keychain error codes to
						//the AFP client!
						//
						theError = noErr;
					}				
				}
			}
			
			//
			//04.27.01: We don't need this buffer that contained the password
			//in cleartext form anymore. Clear them for better security.
			//03.02.02 MJC - Convert to use RtlSecureZeroMemory().
			//
			RtlSecureZeroMemory(
				inUAMArgs->Opt.auth.password,
				PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password)+1
				);
			
			theLoop = false;
		}
		
	}while(theLoop);
	
	return(theError);
}


#pragma mark-
// ---------------------------------------------------------------------------
//		 UAM_CloseSession()
// ---------------------------------------------------------------------------
//	Close a session on the AFP server.

OSStatus UAM_CloseSession(UAMArgs *inUAMArgs)
{
	OSStatus theError;
		
    theError = UAM_CALLBACK_ONEPARAM(
                    inUAMArgs->callbacks->CloseSessionUPP,
                    kCloseSessionProcInfo,
                    inUAMArgs->sessionRefNum);
                    
    inUAMArgs->sessionRefNum = 0;
	
	return(theError);
}

// ---------------------------------------------------------------------------
//		 UAM_OpenSession()
// ---------------------------------------------------------------------------
//	Open a session on the AFP server.

OSStatus UAM_OpenSession(	UAMArgs 		*inUAMArgs,
							UAMMessage		*inMessage,
							unsigned char	*inCmdBuffer,
							UInt32			inCmdBufferSize,
							unsigned char	*inReplyBuffer,
							UInt32			inReplyBufferSize	)
{
	OSStatus theError;
	
	Assert_(inUAMArgs		!= NULL);
	Assert_(inMessage		!= NULL);
	Assert_(inCmdBuffer		!= NULL);
	Assert_(gServerAddress	!= NULL);
	
	//
	//Note that inReplyBuffer can be null.
	//
	
	inMessage->commandCode		= kOpenSession;
	inMessage->cmdBuffer		= inCmdBuffer;
	inMessage->cmdBufferSize	= inCmdBufferSize;
	inMessage->replyBuffer		= inReplyBuffer;
	inMessage->replyBufferSize	= inReplyBufferSize;
	inMessage->completion		= NULL;
	inMessage->contextPtr		= NULL;
	
    theError = UAM_CALLBACK_THREEPARAM(
                    inUAMArgs->callbacks->OpenSessionUPP,
                    kOpenSessionProcInfo,
                    gServerAddress,
                    NULL,
                    inMessage);
    
	//
	//Even if theError == noErr, the parameter block's result
	//param still might hold an error code!
	//

	return((theError == noErr) ? inMessage->result : theError);
}


// ---------------------------------------------------------------------------
//		 UAM_LoginGuest()
// ---------------------------------------------------------------------------
//	Log into an AFP server as a guest.

OSStatus UAM_LoginGuest(UAMArgs *inUAMArgs)
{
	Ptr				theCmdPtr;
	UInt32			theCmdSize;
	OSStatus		theError;
	UAMMessage		theMessage;
	
	Assert_(inUAMArgs != NULL);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
	
	theCmdPtr = (Ptr)&gCmdBuffer[0];
	
	*theCmdPtr	= kFPLogin;
	theCmdPtr	+= sizeof(Byte);
	
	StringPush_(gAFPVersion, (StringPtr)theCmdPtr);
	StringPush_(PSTR_GuestLogin, (StringPtr)theCmdPtr);
		
	theCmdSize = theCmdPtr - ((Ptr)&gCmdBuffer);
	
	theError = UAM_OpenSession(	inUAMArgs,
								&theMessage,
								gCmdBuffer,
								theCmdSize,
								NULL,
								0				);
	
	DbgPrint_((DBGBUFF, "OpenSession() returned %d in UAM_LoginGuest()", (int)theError));	
						
	if (theError == noErr) {
		inUAMArgs->sessionRefNum = theMessage.sessionRefNum;
	}
	
	return(theMessage.result);
}


// ---------------------------------------------------------------------------
//		 UAM_LoginMSUAM()
// ---------------------------------------------------------------------------
//	Log into an AFP server using the .AFPTranslator (through the UAM).

OSStatus UAM_LoginMSUAM(UAMArgs *inUAMArgs)
{
	OSStatus			theError = noErr;
	Ptr					theCmdPtr;
	UInt32				theCmdSize;
	Str32				theWSName;
	Str64				theUserName;
	char				theDomainName[DNLEN+1];
	UAMMessage			theMessage;
		
	Assert_(inUAMArgs != NULL);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
		
	//
	//11.10.99: Clear out the command buffer just to be safe.
	//
	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));

	theCmdPtr = (Ptr)gCmdBuffer;
	UAM_PStrCopy(inUAMArgs->Opt.auth.userName, theUserName);
			
	//
	//09.28.00: If the user name is blank, then we create a random user name
	//so as to attempt a login as "guest".
	//
	if (PSTR_LENGTH(theUserName) == 0)
	{
		UAM_PStrCopy("\pGst&^^", theUserName);
	}
		
	if (inUAMArgs->callbacks != NULL)
	{
		UAM_GetWorkStationName(theWSName);
		
		//
		//This can be 0, but shouldn't be, catch only for debugging.
		//
		Assert_(PSTR_LENGTH(theWSName) != 0);
		
		//
		//Build the AFP command structure for a login.
		//
		
		*theCmdPtr   = kFPLogin;
		theCmdPtr	+= sizeof(Byte);
		
		//
		//Stuff the AFP command block with our info.
		//
		StringPush_(gAFPVersion, (StringPtr)theCmdPtr);
				
		//
		//Check UAM version that the server supports, use the latest...
		//
		if (gSupportedUAMs & kMSUAM_V3_Supported)
		{
			DbgPrint_((DBGBUFF, "Using MS3.0 Encryption"));
			StringPush_(PSTR_EncryptedLogin3_0, (StringPtr)theCmdPtr);
		}
		else if (gSupportedUAMs & kMSUAM_V2_Supported)
		{
			DbgPrint_((DBGBUFF, "Using MS2.0 Encryption"));
			StringPush_(PSTR_EncryptedLogin2_0, (StringPtr)theCmdPtr);
		}
		else
		{
			//
			//Check and see if the user wants to allow this weak authentication
			//to take place.
			//
			if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)
			{
				//
				//Nope, the auth strength is too weak for the user to
				//stomach. Exit gracefully.
				//
				UAM_StandardAlert(
						uamErr_AuthenticationMessage,
						uamErr_AuthTooWeak,
						NULL
						);
				
				//
				//Since we're returned right from here, we need to
				//zero out the password the user entered.
				//	
				RtlSecureZeroMemory(
						inUAMArgs->Opt.pwDlg.password,
						PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password)+1
						);
						
				return(userCanceledErr);
			}
			
			DbgPrint_((DBGBUFF, "Using MS1.0 Encryption"));
			StringPush_(PSTR_EncryptedLogin1_0, (StringPtr)theCmdPtr);
		}
		
		StringPush_(theUserName, (StringPtr)theCmdPtr);
				
		//
		//11.23.99 MJC - Only copy the workstation name if 
		//there is one. If there is no workstation name for the Mac, then
		//we pad the end of the buffer with 2 bytes of 0's for NT4 SP6.
		//
		if (theWSName[0] > 0)
		{
			StringPush_(theWSName, (StringPtr)theCmdPtr);
		}
		else if (	((gSupportedUAMs & kMSUAM_V2_Supported) == 0) &&
					((gSupportedUAMs & kMSUAM_V3_Supported) == 0)	)
		{
			//
			//If the encryption version is 1.0, then we're talking to an NT 4.0
			//or 3.51 file server.
			//
			
			//10.17.01
			//NOTE: We'll never get here now since UAM_GetWorkStationName()
			//always returns a name.
			//
			
			*theCmdPtr++ = 0x00;
			*theCmdPtr++ = 0x00;
		}
		
		//
		//For MS3.0 authentication, we need to do a little extra work by
		//supplying the server name, domain name, user name and workstation
		//name in C-style strings to the continue function.
		//
		if (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported))
		{
			Str32	theServerName;

			//
			//Copy the pascal-style server name so we can convert it to a
			//C-style string (null terminated).
			//
			UAM_PStrCopy(gServerName, theServerName);
			
			//
			//Convert all p-strings to c-strings.
			//
			_p2cstr(theServerName);
			_p2cstr(theUserName);
			_p2cstr(theWSName);
			
			//
			//See if the user name contains a domain name. If not, then pass
			//0 as the domain name.
			//
			memset(theDomainName, 0, sizeof(theDomainName));
			
			if (UAM_ExtractDomainName((char*)theUserName, theDomainName, sizeof(theDomainName)) == TRUE)
			{
				//
				//Since a domain name was included, we need to weed out the
				//user name.
				//
				UAM_ExtractUserName((char*)theUserName, (char*)theUserName, sizeof(theUserName));
			}
		}
	
		//
		//The command block must end on an even boundary!
		//
		if ((theCmdPtr - (Ptr)gCmdBuffer) % 2)
			*theCmdPtr++ = 0x00;
								
		//
		//We need to get the command buffer size so we can pass it along.
		//
		theCmdSize = theCmdPtr - ((Ptr)gCmdBuffer);
		
		//
		//We can't be bigger than the max AFP command allowed.
		//
		Assert_(theCmdSize <= kMaxAFPCommand);
		
		//
		//Zero out the parameter block.
		//
		RtlSecureZeroMemory(&theMessage, sizeof(UAMMessage));
				
		theError = UAM_OpenSession(	inUAMArgs,
									&theMessage,
									gCmdBuffer,
									theCmdSize,
									gReplyBuffer,
									sizeof(gReplyBuffer)	);
		
		//
		//The error returned should always be afpAuthContinue unless the
		//server is rejecting the username.
		//
		if (	(theError == noErr) 				||
				(theError == afpAuthContinue) 		)
		{
			//
			//Save the session reference number to the open AFP
			//session we have with the server.
			//
			inUAMArgs->sessionRefNum = theMessage.sessionRefNum;
			
			BlockMove(gReplyBuffer, &gMSUAMReply, sizeof(MSUAMLoginReplyBlock));
			
			//
			//We need to handle the authentication differently for v3.0 versus
			//v2.0. The previous 2 versions use LM Hash for security, v3 uses
			//NTLMv2.
			//
			if (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported))
			{
				theError = UAM_LoginContinueMS20(
								inUAMArgs,
								(char*)theUserName,
								(char*)theDomainName,
								(char*)theWSName
								);
			}
			else
			{			
				theError = UAM_LoginContinueMS10(inUAMArgs);
			}
		}
		else
		{
			//
			//The server refused the connection based on the UAM used or
			//just the user name.
			//
			DbgPrint_((DBGBUFF, "OpenSession() returned %d in UAM_LoginMSUAM(), we're bailing...", (int)theError));
			
			//
			//The username was rejected most likely. We need to zero out
			//the password field for security.
			//
			RtlSecureZeroMemory(
				inUAMArgs->Opt.pwDlg.password,
				PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password)+1
				);
		}
	}
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_PascalStringToCString()
// ---------------------------------------------------------------------------
//	Convert a pascal password into a c-style string for LMv2 authentication.
//

void UAM_PascalStringToCString(
	const Str255	inPascal,
	BOOL			inUpcase,
	char*			outCStyle,
	Size			inCBufferSize
	)
{
	Str255		thePascal; //Temporary storage
	
	//
	//Make a copy so we don't disrupt the original.
	//
	UAM_PStrCopy(inPascal, thePascal, sizeof(thePascal));

	if (inUpcase) {
	
		UpperString(thePascal, true);
	}

	//
	//02.15.02 MJC: Replace strcpy() with strsafe routine.
	//
	StringCbCopy(outCStyle, inCBufferSize, _p2cstr(thePascal));
}


// ---------------------------------------------------------------------------
//		 UAM_LoginContinueMS20()
// ---------------------------------------------------------------------------
//	Continue the login when authenticating using MS2.0 or MS3.0.
//

OSStatus UAM_LoginContinueMS20(
	UAMArgs*	inUAMArgs,
	char*		inUserName,
	char*		inDomainName,
	char*		inWorkstationName		
	)
{
	char		thePassword[UAM_MAX_LMv2_PASSWORD+1];
	PUAMLogin2	theCmdPtr;
	OSStatus	theError = memFullErr;
	UInt32		theTimeTillExpiration;
	
	DbgPrint_((DBGBUFF, "Enter UAM_LoginContinueMS20()"));
	
	//
	//Make sure the UI is doing it's job and limiting the password to
	//only UAM_MAX_LMv2_PASSWORD characters long.
	//
	if (PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_MAX_LMv2_PASSWORD)
	{
		Assert_(0);
		return(afpParmErr);
	}
		
	//
	//Convert the pascal password into a c-style string we can use.
	//
	//01.16.02: Pass maximum string buffer size to conversion routine.
	//
	UAM_PascalStringToCString(
			inUAMArgs->Opt.auth.password,
			false,
			thePassword,
			sizeof(thePassword)
			);
				
	//
	//Clear out the command buffer just to be safe.
	//
	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));
	
	//
	//Build the AFP command block that we'll send to the server.
	//
	theCmdPtr			= (PUAMLogin2)gCmdBuffer;
	theCmdPtr->command	= kFPLoginCont;
	theCmdPtr->pad		= '\0';
	
	HRESULT					hResult;
	ULONG					theNegotiateFlags;
	ULONG					theChallengeMessageLength		= 0;
	CHALLENGE_MESSAGE*		theChallengeMessage				= NULL;
	ULONG					theAuthenticateMessageLength	= 0;
	AUTHENTICATE_MESSAGE*	theAuthenticateMessage			= NULL;
	USER_SESSION_KEY		theUserSessionKey;
	
	//
	//Build a "fake" challenge message that we can pass to the NTLMv2 routines.
	//We do this since the server does not send us a real NTLM challenge message.
	//
	hResult = MacSspGenerateChallengeMessage(
					gMSUAMReply.serverChallenge,
					&theChallengeMessageLength,
					&theChallengeMessage
					);
	
	if (SUCCEEDED(hResult))
	{
		theNegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE		|
							NTLMSSP_NEGOTIATE_ALWAYS_SIGN	|
							NTLMSSP_NEGOTIATE_NTLM2			|
							NTLMSSP_NEGOTIATE_128			|
							NTLMSSP_TARGET_TYPE_SERVER;
				
		hResult = MacSspHandleNtlmv2ChallengeMessage(
						inUserName,
						inDomainName,
						inWorkstationName,
						thePassword,
						theChallengeMessageLength,
						theChallengeMessage,
						&theNegotiateFlags,
						&theAuthenticateMessageLength,
						&theAuthenticateMessage,
						&theUserSessionKey
						);
		
		if (SUCCEEDED(hResult))
		{
			Assert_(theAuthenticateMessage != NULL);
			
			//
			//We have to swap the authentication bytes here as
			//MacSspHandleNtlmv2ChallengeMessage() puts the message in
			//Windows byte order (littl endian).
			//
			SspSwapAuthenticateMessageBytes(theAuthenticateMessage);
			
			memcpy(
				theCmdPtr->UAMInfo,
				((char*)theAuthenticateMessage) + theAuthenticateMessage->LmChallengeResponse.Buffer,
				theAuthenticateMessage->LmChallengeResponse.Length
				);
					
			theError = UAM_SendAFPRequestToServer(
							inUAMArgs,
							gCmdBuffer,
							sizeof(UAMLogin2),
							(UInt8*)&theTimeTillExpiration,
							sizeof(UInt32)
							);
	
			//
			//The reply buffer contains the password expiration time.
			//
			if (theError == noErr)
			{
				theTimeTillExpiration = swaplong(theTimeTillExpiration);
				gExpirationTime = theTimeTillExpiration;
			}
		}
	}
	
	//
	//The challenge message and authenticate message pointers are allocated
	//in MacSspHandleNtlmv2ChallengeMessage() and we need to dispose of them.
	//
	
	if (theChallengeMessage)
	{
		delete theChallengeMessage;
	}
	
	if (theAuthenticateMessage)
	{
		delete theAuthenticateMessage;
	}
	
    return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_SendAFPRequestToServer()
// ---------------------------------------------------------------------------
//	Send the challenge response back to the server.
//

OSStatus UAM_SendAFPRequestToServer(
	UAMArgs*			inUAMArgs,
	unsigned char*		inChallengeResponseBuffer,
	SInt16				inChallengeResponseBufferSize,
	UInt8*				ioReplyBuffer,
	SInt16				inReplyBufferSize
	)
{
	UAMMessage		theMessage;
	OSStatus		theError;
	
	//
	//We need to zero out the parameter block.
	//
	ZeroMemory(&theMessage, sizeof(UAMMessage));
	
	theMessage.sessionRefNum	= inUAMArgs->sessionRefNum;
	theMessage.commandCode		= kSendRequest;
	theMessage.cmdBuffer		= inChallengeResponseBuffer;
	theMessage.cmdBufferSize	= inChallengeResponseBufferSize;
	theMessage.replyBuffer		= ioReplyBuffer;
	theMessage.replyBufferSize	= inReplyBufferSize;
	theMessage.completion		= NULL;
	theMessage.contextPtr		= NULL;
	
    theError = UAM_CALLBACK_ONEPARAM(
                    inUAMArgs->callbacks->SendRequestUPP,
                    kSendRequestProcInfo,
                    &theMessage);
    
	//
	//The actual error code may lerk in either place
	//
	theError = (theError == noErr) ? theMessage.result : theError;
		
	//
	//For debugging we do this so we know where the error came from.
	//
    DbgPrint_((DBGBUFF, "SendRequest() returned %d in UAM_SendAFPRequestToServer()", (int)theError));
			
	return(theError);	
}


// ---------------------------------------------------------------------------
//		 UAM_LoginContinueMS10()
// ---------------------------------------------------------------------------
//	Continue the login for v1 authentication. 
//
//	The following command block is built.
//
//	|---------------------|
//	|     AFP Command     | <- One Byte
//	|---------------------|
//	|	    Filler        |
//	|---------------------|
//	| Encrypted Password  |
//	/                     /
//	|---------------------|

OSStatus UAM_LoginContinueMS10(UAMArgs *inUAMArgs)
{
 	char			thePassT[UAM_CLRTXTPWDLEN+1];
	OSStatus		theError;
	UInt32			theTimeTillExpiration;
    PUAMLogin		theCmdPtr;
    
    DbgPrint_((DBGBUFF, "Enter UAM_LoginContinueMS10()"));
	
	//
	//04.27.01: This should never happen as the UI should not allow any password
	//to be over our limit. But, we check to make sure.
	//
	if (PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_CLRTXTPWDLEN)
	{
		//
		//If we were to proceed from here, we would crash as our
		//password buffers are not big enough.
		//
		Assert_(0);
		return(afpParmErr);
	}
	
	//
	//Copy the password as we're going to munge it up and we don't want
	//to munge the original, case sensitive, copy.
	//
	UAM_PascalStringToCString(
			inUAMArgs->Opt.auth.password,
			true,
			thePassT,
			sizeof(thePassT)
			);
		
	//
	//Map extended characters to the correct values for NT.
	//
	if (!UAM_MapCharactersIntoHostSet(thePassT, gMSUAMReply.serverExtCharMapTable))
	{
		DbgPrint_((DBGBUFF, "UAM_MapCharactersIntoHostSet() failed"));
		return(afpUserNotAuth);
	}
	
	//
	//11.10.99: Clear out the command buffer just to be safe.
	//
	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));
				
	theCmdPtr			= (PUAMLogin)gCmdBuffer;
	theCmdPtr->command	= kFPLoginCont;
	theCmdPtr->pad		= '\0';
			
	//
	//Get the encrypted LmOwf password using the encrypting routines.
	//	
	if (!UAM_GetEncryptedLmOwfPassword(
				thePassT,
				gMSUAMReply.serverChallenge,
				theCmdPtr->UAMInfo))
	{
		Assert_(0);
		return(afpMiscErr);
	}
	
	//
	//Be a good security citizen and zero out the password buffer
	//that we don't need anymore.
	//
	RtlSecureZeroMemory(thePassT, sizeof(thePassT));
	
	//
	//The encrypted OWF should never be null.
	//
	Assert_(strlen(theCmdPtr->UAMInfo) > 0);
	
	theError = UAM_SendAFPRequestToServer(
					inUAMArgs,
					gCmdBuffer,
					sizeof(UAMLogin),
					(UInt8*)&theTimeTillExpiration,
					sizeof(UInt32)
					);
	//
	//The reply buffer contains the password expiration time.
	//
	if (theError == noErr)
	{
		theTimeTillExpiration = swaplong(theTimeTillExpiration);
		gExpirationTime = theTimeTillExpiration;
	}
				
	return(theError);
}

// ---------------------------------------------------------------------------
//		 UAM_ChangePasswordForMS10()
// ---------------------------------------------------------------------------
//	Change the user's password on the server.
//
//	->	inUAMArgs		The UAM arguments.
//	->	inNewPwd		The new password requested by the user.
//
//	Returns: An error code or noErr.
//
//	|---------------------|
//	|     AFP Command     | <- One Byte
//	|---------------------|
//	|	  New pwd len     |
//	|---------------------|
//	|     UAM String      |
//	/                     /
//	|---------------------|
//	|      User Name      |
//	/					  /
//	|---------------------|
//  | Old Pwd (Encrypted) |
//	/					  /
//	|---------------------|
//  | New Pwd (Encrypted) |
//	/					  /
//	|---------------------|


OSStatus UAM_ChangePasswordForMS10(UAMArgs *inUAMArgs, StringPtr inNewPwd)
{	
	OSStatus	theError;
	Ptr			theCmdPtr;
	short		theCmdSize;
	char		oldPassword[UAM_CLRTXTPWDLEN+1];
	char		newPassword[UAM_CLRTXTPWDLEN+1];

	Assert_(inNewPwd != NULL);
	Assert_(inUAMArgs != NULL);
	
	//
	//Check to make sure we don't go over our maximum
	//buffer size. The UI should prevent this, but...
	//
	if ((PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_CLRTXTPWDLEN)	||
		(PSTR_LENGTH(inNewPwd) > UAM_CLRTXTPWDLEN)						)
	{
		//
		//Our buffers aren't big enough, a password that is too big was passed.
		//
		Assert_(0);
		return(afpParmErr);
	}
	
	//
	//Convert everything to C strings and uppercase them as well.
	//
	UAM_PascalStringToCString(
			inUAMArgs->Opt.auth.password,
			true,
			oldPassword,
			sizeof(oldPassword)
			);
			
	UAM_PascalStringToCString(
			inNewPwd,
			true,
			newPassword,
			sizeof(newPassword)
			);
		
	//
	//Log into the server. Note that if the password is expired, the server
	//will let us make one AFP call, that being FPChangePassword over
	//the opened session.
	//
	theError = UAM_LoginMSUAM(inUAMArgs);
		
	if ((theError != noErr) 				&&
		(theError != afpNTPasswordExpired)	&&
		(theError != afpPwdExpiredErr)		)
	{
		//
		//If we couldn't login or the password wasn't expired, we
		//cannot continue.
		//
		return(theError);
	}
	
	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));
	theCmdPtr = (Ptr)gCmdBuffer;
	
	*theCmdPtr++ = afpChangePwd;
	*theCmdPtr++ = strlen(newPassword);
	 
	StringPush_(PSTR_EncryptedLogin1_0, theCmdPtr);

	if ((theCmdPtr - ((Ptr)gCmdBuffer)) % 2)
	{
		*theCmdPtr++ = 0x00;
	}

	StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);
	
	//
	//Make sure the buffer ends on an even boundary before the next block.
	//
	if ((theCmdPtr - ((Ptr)gCmdBuffer)) % 2)
	{
		*theCmdPtr++ = 0x00;
	}
		
	theCmdSize 	= theCmdPtr - ((Ptr)gCmdBuffer);
	theError 	= afpNTPasswordProcessFailure;

	if ( (UAM_MapCharactersIntoHostSet(oldPassword, gMSUAMReply.serverExtCharMapTable)) &&
		 (UAM_MapCharactersIntoHostSet(newPassword, gMSUAMReply.serverExtCharMapTable)) 
	   )
	{
		//
		//Call the magic NTLM routine to encrypt the passwords into one
		//single buffer.
		//
		if (UAM_GetDoubleEncryptedLmOwfPasswords(oldPassword, newPassword, theCmdPtr))
		{		
			//
			//Make a couple last calculations so we can determine the size of the CB.
			//
			
			theCmdSize += (kOneWayEncryptedArgSize * 2);
            
			theError = UAM_SendAFPRequestToServer(
							inUAMArgs,
							gCmdBuffer,
							theCmdSize,
							gReplyBuffer,
							kMaxAFPCommand
							);
		}
	}
	
	DBGPrintIfOSErr_((int)theError);
	
	//
	//We're done with the session, so close it out and return any error codes.
	//
	UAM_CloseSession(inUAMArgs);
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePasswordForMS20()
// ---------------------------------------------------------------------------
//	Change the user's password on the server using Microsoft V2.0. This new
//	function was required so we can pass the actual password encrypted
//	over the wire to the server. The server needs the password so it can
//	update the stored clear text password on the DS (Domain Controller).
//
//	->	inUAMArgs		The UAM arguments.
//	->	inNewPwd		The new password requested by the user.
//
//	Returns: An error code or noErr.
//
//	|--------------------------------|
//	|           AFP Command          | <- One Byte
//	|--------------------------------|
//	|	        New pwd len          |
//	|--------------------------------|
//	|           UAM String           | <- Always PSTR_EncryptedLogin2_0
//	/                     			 /
//	|--------------------------------|
//	|           User Name      		 | <- Variable length
//	/					  			 /
//	|--------------------------------|
//  | PENCRYPTED_NT_OWF_PASSWORD 	 | <- Variable length
//	/					             /
//	|--------------------------------|
//  | PSAMPR_ENCRYPTED_USER_PASSWORD | <- Variable length
//	/					             /
//	|--------------------------------|
//

OSStatus UAM_ChangePasswordForMS20(UAMArgs *inUAMArgs, const StringPtr inNewPwd)
{	
	OSStatus	theError;
	Ptr			theCmdPtr;
	short		theCmdSize;
	char		oldPassword[UAM_CLRTXTPWDLEN+1];
	char		newPassword[UAM_CLRTXTPWDLEN+1];
	char		newStdPassword[UAM_CLRTXTPWDLEN+1];
	
	SAMPR_ENCRYPTED_USER_PASSWORD	theNewEncryptedWithLm;
	ENCRYPTED_NT_OWF_PASSWORD		theOldLmOwfEncryptedWithNewLm;
	
	Assert_(inNewPwd != NULL);
	Assert_(inUAMArgs != NULL);
		
	//
	//Check to make sure we don't go over our maximum
	//buffer size. The UI should prevent this, but...
	//
	if ((PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_CLRTXTPWDLEN)	||
		(PSTR_LENGTH(inNewPwd) > UAM_CLRTXTPWDLEN)						)
	{
		//
		//Our buffers aren't big enough, a password that is too big was passed.
		//
		Assert_(0);
		return(afpParmErr);
	}
	
	//
	//Convert everything to C strings and uppercase them as well. DO NOT
	//uppercase newStdPassword as this is passed as is over the wire.
	//
	UAM_PascalStringToCString(
			inUAMArgs->Opt.auth.password,
			true,
			oldPassword,
			sizeof(oldPassword)
			);
			
	UAM_PascalStringToCString(
			inNewPwd,
			true,
			newPassword,
			sizeof(newPassword)
			);
			
	UAM_PascalStringToCString(
			inNewPwd,
			false,
			newStdPassword,
			sizeof(newStdPassword)
			);
	
	//
	//Log into the server. Note that if the password is expired, the server
	//will let us make one AFP call, that being FPChangePassword over
	//the opened session.
	//
	theError = UAM_LoginMSUAM(inUAMArgs);
		
	if ((theError != noErr) 				&&
		(theError != afpNTPasswordExpired)	&&
		(theError != afpPwdExpiredErr)		)
	{
		//
		//If we couldn't login or the password wasn't expired, we
		//cannot continue.
		//
		return(theError);
	}
	
	//
	//Start with a clean slate in our command buffer.
	//
	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));
	
	theCmdPtr = (Ptr)gCmdBuffer;
	
	*theCmdPtr++	= afpChangePwd;
	*theCmdPtr++	= strlen(newPassword);
	
	StringPush_(PSTR_EncryptedLogin2_0, theCmdPtr);
	StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);
	
	//
	//Make sure the ptr is aligned on an even boundary at this point
	//
	if ((theCmdPtr - (Ptr)gCmdBuffer) % 2)
	{
		DbgPrint_((DBGBUFF, "Aligning for even boundary (size = %d)", (theCmdPtr - (Ptr)gCmdBuffer)));
		*theCmdPtr++ = 0x00;
	}
	
	//
	//We doctor up the error code here since the only error that
	//SampEncryptLmPasswords() returns is INVALID_FUCTION. We assume
	//failure here.
	//
	theError = afpNTPasswordProcessFailure;
	
	//
	//Map the extended characters from Mac to Windows. NOTE that we do it for all
	//3 buffers because newPassword and newStdPassword are really different!
	//
	if ( (UAM_MapCharactersIntoHostSet(oldPassword, gMSUAMReply.serverExtCharMapTable)) &&
		 (UAM_MapCharactersIntoHostSet(newPassword, gMSUAMReply.serverExtCharMapTable))	&&
		 (UAM_MapCharactersIntoHostSet(newStdPassword, gMSUAMReply.serverExtCharMapTable)) 
		 
	   )
	{
		RtlSecureZeroMemory(&theNewEncryptedWithLm, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD));
		RtlSecureZeroMemory(&theOldLmOwfEncryptedWithNewLm, sizeof(ENCRYPTED_NT_OWF_PASSWORD));
		
		DbgPrint_((DBGBUFF, "Old password = %s", oldPassword));
		DbgPrint_((DBGBUFF, "New password = %s", newPassword));
		DbgPrint_((DBGBUFF, "New case sensitive = %s", newStdPassword));
				
		//
		//Call the magic function with will encrypt the password(s) for us.
		//
		theError = MacSspSampEncryptLmPasswords(
						oldPassword,
						newPassword,
						newStdPassword,
						&theNewEncryptedWithLm,
						&theOldLmOwfEncryptedWithNewLm
						);
		
		if (SUCCEEDED(theError))
		{
			//
			// Copy the ENCRYPTED_NT_OWF_PASSWORD into the command buffer.
			//
			DataPush_(&theOldLmOwfEncryptedWithNewLm, sizeof(ENCRYPTED_NT_OWF_PASSWORD), theCmdPtr);
								
			//
			//Copy the SAMPR_ENCRYPTED_USER_PASSWORD into the command buffer.
			//
			DataPush_(&theNewEncryptedWithLm, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD), theCmdPtr);
							
			//
			//Make a last minute calculation so we can determine the size of the CB.
			//
			theCmdSize = theCmdPtr - (Ptr)(&gCmdBuffer);
			
			Assert_(theCmdSize <= kMaxAFPCommand);
			DbgPrint_((DBGBUFF, "Change password v2 cmd size = %d", theCmdSize));
			
			theError = UAM_SendAFPRequestToServer(
							inUAMArgs,
							gCmdBuffer,
							theCmdSize,
							gReplyBuffer,
							kMaxAFPCommand
							);
		}
	}
	
	DBGPrintIfOSErr_((int)theError);
	
	//
	//We're done with the session, so close it out and return any error codes.
	//
	UAM_CloseSession(inUAMArgs);
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePasswordForMS30()
// ---------------------------------------------------------------------------
//	Change the user's password on the server using Microsoft V3.0. 
//

OSStatus UAM_ChangePasswordForMS30(
	UAMArgs* 		inUAMArgs,
	const StringPtr inNewPwd
)
{
	char		theNewPassword[UAM_MAX_LMv2_PASSWORD+1];
	char		theOldPassword[UAM_MAX_LMv2_PASSWORD+1];
	Ptr			theCmdPtr;
	SInt16		theCmdSize;
	OSStatus	theError = memFullErr;
		
	SFM_PASSWORD_CHANGE_MESSAGE	theChangeMessage;
	
	//
	//Log into the server. Note that if the password is expired, the server
	//will let us make one AFP call, that being FPChangePassword over
	//the opened session.
	//
	theError = UAM_LoginMSUAM(inUAMArgs);
		
	if ((theError != noErr) 				&&
		(theError != afpNTPasswordExpired)	&&
		(theError != afpPwdExpiredErr)		)
	{
		//
		//If we couldn't login or the password wasn't expired, we
		//cannot continue.
		//
		return(theError);
	}
	
	//
	//Convert the pascal passwords into c-style strings we can use and
	//map extended characters to the correct values for NT.
	//
	UAM_PascalStringToCString(
			inUAMArgs->Opt.auth.password,
			false,
			theOldPassword,
			sizeof(theOldPassword)
			);
	
	UAM_PascalStringToCString(
			inNewPwd,
			false,
			theNewPassword,
			sizeof(theNewPassword)
			);
	
	//
	//Start with a clean slate in our command buffer.
	//
	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));
	
	theCmdPtr = (Ptr)gCmdBuffer;
	
	*theCmdPtr++	= afpChangePwd;
	*theCmdPtr++	= strlen(theNewPassword);
	
	StringPush_(PSTR_EncryptedLogin3_0, theCmdPtr);
	StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);
	
	//
	//Make sure the ptr is aligned on an even boundary at this point
	//
	if ((theCmdPtr - (Ptr)gCmdBuffer) % 2) {
	
		*theCmdPtr++ = 0x00;
	}
	
	StringCbCopy(
		(char*)theChangeMessage.Signature,
		sizeof(theChangeMessage.Signature),
		SFM_CHANGE_PASSWORD_SIGNATURE
		);
	
	theChangeMessage.cbMessage	= sizeof(theChangeMessage);
	theChangeMessage.cbMessage	= swaplong(theChangeMessage.cbMessage);
	theChangeMessage.Version	= SFM_CHANGE_PASSWORD_VERSION;
	theChangeMessage.Version	= swaplong(theChangeMessage.Version);
	
	theError = MacSspSamiEncryptCStringPasswords(
					theOldPassword,
					theNewPassword,
					&theChangeMessage.NewPasswordEncryptedWithOldNt,
					&theChangeMessage.OldNtOwfPasswordEncryptedWithNewNt
					);
					
	if (SUCCEEDED(theError))
	{
		//
		//For Macintosh, since we can only have a maximum password length of
		//64 bytes, we only send the second half of the encrypted NT password.
		//This allows us to leave extra room in our request packet to handle
		//a 64 byte long domain\user name.
		//
		
		SFM_PASSWORD_CHANGE_MESSAGE_SHORT	theShortMsg;
		
		StringCbCopy(
			(char*)theShortMsg.Signature,
			sizeof(theShortMsg.Signature),
			(char*)theChangeMessage.Signature
			);
		
		theShortMsg.cbMessage 	= sizeof(SFM_PASSWORD_CHANGE_MESSAGE_SHORT);
		theShortMsg.cbMessage	= swaplong(theShortMsg.cbMessage);
		theShortMsg.Version		= theChangeMessage.Version;
		
		memcpy(
			&theShortMsg.NewPasswordEncryptedWithOldNt,
			(((unsigned char*)&theChangeMessage.NewPasswordEncryptedWithOldNt))+
			(sizeof(theChangeMessage.NewPasswordEncryptedWithOldNt)/2),
			sizeof(theShortMsg.NewPasswordEncryptedWithOldNt)
			);
			
		memcpy(
			&theShortMsg.OldNtOwfPasswordEncryptedWithNewNt,
			&theChangeMessage.OldNtOwfPasswordEncryptedWithNewNt,
			sizeof(theShortMsg.OldNtOwfPasswordEncryptedWithNewNt)
			);
		
		DataPush_(&theShortMsg, sizeof(theShortMsg), theCmdPtr);
						
		//
		//Make a last minute calculation so we can determine the size of the CB.
		//
		theCmdSize = theCmdPtr - (Ptr)(&gCmdBuffer);
		
		Assert_(theCmdSize <= kMaxAFPCommand);
		DbgPrint_((DBGBUFF, "Change password v3 cmd size = %d", theCmdSize));
		
		theError = UAM_SendAFPRequestToServer(
						inUAMArgs,
						gCmdBuffer,
						theCmdSize,
						gReplyBuffer,
						kMaxAFPCommand
						);
	}
	
	DBGPrintIfOSErr_((int)theError);
	
	//
	//We're done with the session, so close it out and return any error codes.
	//
	UAM_CloseSession(inUAMArgs);

	return(theError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamkeychain.h ===
// ===========================================================================
//	UAMKeychain.h 				 1999 Microsoft Corp. All rights reserved.
// ===========================================================================

#ifdef UAM_TARGET_CARBON
#include <Carbon/Carbon.h>
#else
#include "Keychain.h"
#endif

#define UAM_KC_DESCRIPTION		"\pMicrosoft Windows Server"

typedef unsigned char Str8[9];

//
//The volume mount info structure must be aligned for 68K
//as the Mac AFP Client as of MacOS 9.0 is still 68K code!
//
#pragma options align=mac68k

typedef struct
{
	SInt16 		length;					/* length of this record */
	VolumeType 	media;					/* type of media, always AppleShareMediaType */
	SInt16 		flags;					/* bits for no messages, no reconnect, etc */
	char 		nbpInterval;			/* NBP interval parameter; 7 is a good choice */
	char 		nbpCount;				/* NBP count parameter; 5 is a good choice */
	SInt16 		uamType;				/* User Authentication Method */
	SInt16 		zoneNameOffset;			/* offset from start of record to zoneName */
	SInt16 		serverNameOffset;		/* offset from start of record to serverName */
	SInt16 		volNameOffset;			/* offset from start of record to volName */
	SInt16 		userNameOffset;			/* offset from start of record to userName */
	SInt16 		userPasswordOffset;		/* offset from start of record to userPassword */
	SInt16 		volPasswordOffset;		/* offset from start of record to volPassword */
	SInt16 		extendedFlags;			/* extended flags word */
	SInt16 		uamNameOffset;			/* offset to a pascal UAM name string */
	SInt16 		alternateAddressOffset; /* offset to Alternate Addresses in tagged format */
	Str32 		zoneName;				/* server's AppleTalk zone name */					
	char 		filler1;				/* to word align volPassword */
	Str32 		serverName;				/* server name */					
	char 		filler2;				/* to word align volPassword */
	Str27 		volName;				/* volume name */					
	Str31 		userName;				/* user name (zero length Pascal string for guest) */
	Str64 		userPassword;			/* user password (zero length Pascal string if no user password) */					
	char 		filler3;				/* to word align volPassword */
	Str8 		volPassword;			/* volume password (zero length Pascal string if no volume password) */					
	char 		filler4;				/* to word align uamNameOffset */
	Str32 		uamName;				/* UAM name */
	char 		filler5;				/* to word align alternateAddress */
	char 		alternateAddress[kVariableLengthArray];	/* AFPAlternateAddress */
}UAM_AFPXVolMountInfo, *PUAM_AFPXVolMountInfo;

#pragma options align=reset

//
//This macro helps us get offsets into the struct above.
//
#define uamx_member_offset(member)	((size_t) &((UAM_AFPXVolMountInfo *) 0)->member)

OSStatus 	UAM_KCDeleteItem(
				StringPtr 	inUserName,
				Str255 		inServerName
);
void 		UAM_KCInitialize(UAMArgs* inUAMArgs);
Boolean 	UAM_KCAvailable(void);
OSStatus	UAM_KCSavePassword(
				StringPtr 	inUserName,
				StringPtr 	inPassword,
				Str255 		inServerName
);
OSStatus 	UAM_KCFindAppleSharePassword(
				StringPtr	inUserName,
				StringPtr	inPassword,
				StringPtr	inServerName,
				KCItemRef	*outItemRef
);
OSStatus 	UAM_BuildAFPXVolMountInfo(
				StringPtr 				inUserName,
				StringPtr 				inPassword,
				Str255 					inServerName,
				const Str32				inUAMString,
				PUAM_AFPXVolMountInfo*	outVolInfo
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamnetwork.h ===
// ===========================================================================
//	UAMNetwork.h 			 1998-2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#ifdef UAM_TARGET_CARBON
#include "ClientUAM.h"
#endif

#include "UAMEncrypt.h"

#define afpChangePwd		36

#define kDDPPacketLength	576		//The size of one packet
#define kAFPIconSize		128		//Black & white icons are 128 bytes

//
//Pascal style strings used to determine supported UAMs.
//
#define PSTR_NT_MACHINE_TYPE	"\pWindows NT"
#define PSTR_AFPVersion30		"\pAFP3.0"
#define PSTR_AFPVersion22		"\pAFP2.2"
#define PSTR_AFPVersion20		"\pAFPVersion 2.0"
#define PSTR_AFPVersion21		"\pAFPVersion 2.1"
#define PSTR_AFPVersionOfChoice	"\pAFPVersion 2.1"
#define PSTR_ClearTextLogin		"\pCleartxt Passwrd"
#define PSTR_GuestLogin			"\pNo User Authent"
#define PSTR_EncryptedLogin1_0	"\pMicrosoft V1.0"
#define PSTR_EncryptedLogin2_0	"\pMS2.0"
#define PSTR_EncryptedLogin3_0	"\pMS3.0"

//
//NOTE: We say we support AFP version than we do so we
//can leave a little room for AFP 3.0 in the future.
//
#define MAXNUM_AFP_VERSIONS_SUPPORTED	4

//
//NT4 supported AFPVersion 2.0 and 2.1
//
#define MINNUM_AFP_VERSIONS_SUPPORTED	2

//
//Mac's time is based from January 1, 1904 while a server's is based on the
//year 2000. Below is the difference between the two for conversion and a
//macro to make life easier.
//
#define NUM_SECS_FROM_1904_TO_2000 	3029529600
#define LOCAL_TIME(serverTime)		(NUM_SECS_FROM_1904_TO_2000 + serverTime)


typedef unsigned char PassWord[8];


//FPGetSrvrInfo() server flags bit values
typedef enum {
	kSupportsCopyFile			= 0x1,
	kSupportsChngPswd			= 0x2,
	//kDontAllowSavePwd			= 0x4,
	kSupportsSrvrMsgs			= 0x8,
	kSupportsSrvrSig			= 0x10,
	kSupportsTCPIP				= 0x20,
	kSupportsSrvrNotification	= 0x40
}ServerStatusReplyFlags;

enum
{
	kFPLogin = 18, 
	kFPLoginCont = 19
};

//
//The reply block returned when using MSUAM.
//
typedef struct _MSUAMLoginReplyBlock
{
	char	serverChallenge[kServerChallengeMaxLen];
	char 	serverExtCharMapTable[kServerChallengeExtCharMapTableSize];
}MSUAMLoginReplyBlock;

//
//This is the structure the MS UAM uses for the FPLogin command.
//
typedef struct
{
    Byte	command;
    char	pad;
    char	UAMInfo[sizeof(LM_RESPONSE)];
}UAMLogin, *PUAMLogin;

typedef struct
{
    Byte	command;
    char	pad;
    char	UAMInfo[sizeof(MSV1_0_LMV2_RESPONSE)];
}UAMLogin2, *PUAMLogin2;

//
//The following defines and types are used for change password when doing
//Microsoft AFP Authentication v3.0.
//
#define SFM_CHANGE_PASSWORD_SIGNATURE 	"ChP"
#define SFM_CHANGE_PASSWORD_VERSION		1

typedef struct
{
    unsigned char					Signature[sizeof(SFM_CHANGE_PASSWORD_SIGNATURE)];
    UInt32							cbMessage;
    UInt32							Version;
    SAMPR_ENCRYPTED_USER_PASSWORD	NewPasswordEncryptedWithOldNt;
    ENCRYPTED_NT_OWF_PASSWORD		OldNtOwfPasswordEncryptedWithNewNt;
}SFM_PASSWORD_CHANGE_MESSAGE, *PSFM_PASSWORD_CHANGE_MESSAGE;

typedef struct
{
    unsigned char				Signature[sizeof(SFM_CHANGE_PASSWORD_SIGNATURE)];
    UInt32						cbMessage;
    UInt32						Version;
    unsigned char				NewPasswordEncryptedWithOldNt[sizeof(SAMPR_ENCRYPTED_USER_PASSWORD)/2];
    ENCRYPTED_NT_OWF_PASSWORD	OldNtOwfPasswordEncryptedWithNewNt;
}SFM_PASSWORD_CHANGE_MESSAGE_SHORT, *PSFM_PASSWORD_CHANGE_MESSAGE_SHORT;

//
//Prototypes for UAMNetwork live here.
//
Boolean 	UAM_MapCharactersIntoHostSet(char *szTarg, char *mappingTbl);

#define StringPush_(s, p)	do {										\
								UAM_PStrCopy(s, (StringPtr)p);			\
								p += s[0] + 1;							\
							}while(false)
							
#define DataPush_(d, s, p)	do {										\
								memcpy(p, d, s);						\
								p += s;									\
							}while(false)

OSStatus UAM_UAMLogin(UAMArgs *inUAMArgs);

OSStatus UAM_CloseSession(UAMArgs *inUAMArgs);
OSStatus UAM_OpenSession(	
	UAMArgs 		*inUAMArgs,
	UAMMessage		*inMessage,
	unsigned char	*inCmdBuffer,
	UInt32			inCmdBufferSize,
	unsigned char	*inReplyBuffer,
	UInt32			inReplyBufferSize
);

OSStatus UAM_LoginGuest(UAMArgs *inUAMArgs);
OSStatus UAM_LoginMSUAM(UAMArgs *inUAMArgs);

void UAM_PascalStringToCString(
	const Str255	inPascal,
	BOOL			inUpcase,
	char*			outCStyle,
	Size			inCBufferSize
);
	
OSStatus UAM_LoginContinueMS20(
	UAMArgs*	inUAMArgs,
	char*		inUserName,
	char*		inDomainName,
	char*		inWorkstationName		
);

OSStatus UAM_SendAFPRequestToServer(
	UAMArgs*			inUAMArgs,
	unsigned char*		inChallengeResponseBuffer,
	SInt16				inChallengeResponseBufferSize,
	UInt8*				ioReplyBuffer,
	SInt16				inReplyBufferSize
);

OSStatus UAM_LoginContinueMS10(
	UAMArgs*		inUAMArgs
);
	
OSStatus UAM_ChangePasswordForMS10(
	UAMArgs*		inUAMArgs,
	const StringPtr inNewPwd
);

OSStatus UAM_ChangePasswordForMS20(
	UAMArgs*		inUAMArgs,
	const StringPtr inNewPwd
);

OSStatus UAM_ChangePasswordForMS30(
	UAMArgs*		inUAMArgs,
	const StringPtr inNewPwd
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamprefs.cpp ===
// ===========================================================================
//	UAMPrefs.cpp 			 1998-2002 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Preference file manipulation routines for the Microsoft UAM.
//

#ifdef UAM_TARGET_CARBON
#include <CoreFoundation/CoreFoundation.h>
#include <Carbon/Carbon.h>
#endif

#include <String.h>
#include <macstrsafe.h>

#include "UAMDebug.h"
#include "UAMPrefs.h"


UAM_PREFERENCES	gUAMPreferences;


// ---------------------------------------------------------------------------
//		 UAM_OpenOrCreateFile()
// ---------------------------------------------------------------------------
//	Open or create and open the resource fork of a file.
//

SInt16 UAM_OpenOrCreateFile(
		FSSpec*		inSpec,
		OSType		inCreator,
		OSType		inFileType
)
{
	SInt16	theRefNum	= -1;
	OSErr	theError;
	
	theError = FSpOpenDF(inSpec, fsRdWrPerm, &theRefNum);
	
	if (theError == fnfErr)
	{
		//
		//The file does not exist, create a new file.
		//
		theError = FSpCreate(inSpec, inCreator, inFileType, 0);
			
		if (theError == noErr)
		{
			theError = FSpOpenDF(inSpec, fsRdWrPerm, &theRefNum);
		}
	}
	
	if ((theRefNum == -1) || (theError != noErr))
	{
		DbgPrint_((DBGBUFF, "Failed to open preference file (%d)!", theError));
	}
	
	return(theRefNum);
}


// ---------------------------------------------------------------------------
//		 UAM_OpenPreferenceFile()
// ---------------------------------------------------------------------------
//	Opens the preference file by name.
//

SInt16 UAM_OpenPreferenceFile()
{
	FSSpec		theSpec;
	SInt16		theRefNum	= -1;	//assume failure
	SInt16		theVRefNum	= 0;
	SInt32		theDirID	= 0;
	OSErr		theError	= noErr;
	
	theError = FindFolder(
					kOnSystemDisk,
					kPreferencesFolderType,
					kCreateFolder,
					&theVRefNum,
					&theDirID
					);
	
	if (theError == noErr)
	{
		//
		//Create the file spec that will point to the file.
		//
		theError = FSMakeFSSpec(
						theVRefNum,
						theDirID,
						UAM_PREFERENCE_FILE_NAME,
						&theSpec
						);
		
		if ((theError == noErr) || (theError == fnfErr))
		{
			theRefNum = UAM_OpenOrCreateFile(
								&theSpec,
								'MACS',
								'pref'
								);
		}
		else
		{
			//
			//There was a failure creating the spec that we cannot handle. Nothing
			//to do unless we're in debug.
			//
			DbgPrint_((DBGBUFF, "Failed to create pref file spec (%d)", ResError()));
		}
	}
	
	return(theRefNum);
}


// ---------------------------------------------------------------------------
//		 UAM_RetrieveUAMPreferenceData()
// ---------------------------------------------------------------------------
//	Retrieves the preferences data saved in the file.
//

OSErr UAM_RetrieveUAMPreferenceData(
		PUAM_PREFERENCES	ioUAMPrefs
)
{
	OSErr			theError			= noErr;
	SInt16			theRefNum			= -1;
	SInt32			theSize;
	UAM_PREFERENCES	thePrefs;
	
	//
	//Open the resource fork of the preferences file.
	//
	theRefNum = UAM_OpenPreferenceFile();
	
	if (theRefNum >= 0)
	{
		theError = SetFPos(theRefNum, fsFromStart, 0);
		
		if (theError != noErr)
		{
			DbgPrint_((DBGBUFF, "FSSetForkPosition() failed! (%d)", theError));
		}

		//
		//Read in the preference file data.
		//
		theSize		= sizeof(UAM_PREFERENCES);
		theError 	= FSRead(theRefNum, &theSize, &thePrefs);
		
		//
		//If there is an error or there is a discrepancy in the number
		//of bytes we read in, bail.
		//
		if (theError != noErr)
		{
			DbgPrint_((DBGBUFF, "Reading from prefs file failed! (%d)", theError));
			
			if (theError != eofErr)
			{
				FSClose(theRefNum);
				return(theError);
			}
		}
	}
		
	if ((theError == eofErr) || (theSize == 0) || (theRefNum == -1))
	{
		DbgPrint_((DBGBUFF, "Setting default preferences..."));
		
		//
		//The preference file did not exist or we can't open the file, 
		//return the defaults.
		//
		ioUAMPrefs->flags |= UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;
		
		//
		//Not really necessary, but we do it anyway.
		//
		ioUAMPrefs->reserved1	= 0;
		ioUAMPrefs->reserved2	= 0;
		
		theError = noErr;
	}
	else
	{
		BlockMove(&thePrefs, ioUAMPrefs, sizeof(UAM_PREFERENCES));
		
		DbgPrint_((DBGBUFF, "Pref flags = 0x%x", ioUAMPrefs->flags));
	}
	
	FSClose(theRefNum);
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_SaveUAMPreferenceData()
// ---------------------------------------------------------------------------
//	Saves the preferences data to file.
//

OSErr UAM_SaveUAMPreferenceData(
		PUAM_PREFERENCES	inUAMPrefs
)
{
	SInt16	theRefNum			= -1;
	OSErr	theError			= noErr;
	SInt32	theSize;
	
	//
	//Open the resource fork of the preferences file.
	//
	theRefNum = UAM_OpenPreferenceFile();
	
	if (theRefNum >= 0)
	{
		theError = SetFPos(theRefNum, fsFromStart, 0);
		
		if (theError != noErr)
		{
			DbgPrint_((DBGBUFF, "FSSetForkPosition() failed! (%d)", theError));
		}
		else
		{
			theSize		= sizeof(UAM_PREFERENCES);
			theError 	= FSWrite(theRefNum, &theSize, inUAMPrefs);
			
			if (theError != noErr)
			{
				DbgPrint_((DBGBUFF, "Writing to prefs file failed! (%d)", theError));
			}
			else if (theSize == sizeof(UAM_PREFERENCES))
			{
				DbgPrint_((DBGBUFF, "Preferences successfully written to disk"));
			}
		}
		
		FSClose(theRefNum);
	}
	
	return(theError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamprefs.h ===
// ===========================================================================
//	UAMPrefs.h 			 1998-2002 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

//
//The name of the preferences file.
//
#define UAM_PREFERENCE_FILE_NAME	"\pMSUAM Preferences"

//
//These flags are currently defined for preferences.
//
enum
{
	UAM_PREFS_REQUIRE_STRONG_ENCRYPTION	= 0x02
};

//
//This is the data structure of the UAM preferences file.
//
typedef struct
{
	SInt32	flags;
	SInt32	reserved1;
	SInt32	reserved2;
}UAM_PREFERENCES, *PUAM_PREFERENCES;

SInt16 UAM_OpenOrCreateFile(
		FSSpec*		inSpec,
		OSType		inCreator,
		OSType		inFileType
);

SInt16 UAM_OpenPreferenceFile();

OSErr UAM_RetrieveUAMPreferenceData(
		PUAM_PREFERENCES	ioUAMPrefs
);

OSErr UAM_SaveUAMPreferenceData(
		PUAM_PREFERENCES	inUAMPrefs
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uampswdfield.cpp ===
// ===========================================================================
//	UAMPswdField.c 				 2001 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Routines for managing a password field in Carbon. Carbon provides an edit
//	control that acts as a great password entry box.
//
//	Created by: Michael J. Conrad (mconrad@microsoft.com)
//
// ===========================================================================
//

#include "UAMPswdField.h"
#include "UAMUtils.h"
#include "UAMEncrypt.h"
#include "UAMDialogs.h"
#include "UAMDLOGUtils.h"
#include "UAMDebug.h"

extern long				gSupportedUAMs;

ControlKeyFilterUPP		gKeyFilterUPP		= NULL;
SInt16					gMaxPasswordLength	= UAM_CLRTXTPWDLEN;


// ---------------------------------------------------------------------------
//		 UAM_SetMaximumPasswordLength()
// ---------------------------------------------------------------------------
//	Sets the maximum password length that the password key filter will
//	allow. This function is only really necessary under carbon.
//
//	Note that the allowed length is different for chaning password depending
//	on the support the server offers.
//

void UAM_SetMaximumPasswordLength(
		Boolean		inChangingPassword
		)
{
	//
	//If we're changing password, then the maximum password length changes
	//depending on what level of support the server provides. MS2.0 auth
	//is the only special case we need to check for.
	//
	if ((inChangingPassword) && (SUPPORTS_MS20_ONLY(gSupportedUAMs)))
	{
		gMaxPasswordLength = UAM_CLRTXTPWDLEN;
	}
	else
	{
		//
		//This is the default password length for all cases. Unless we're changing
		//password, this will always return the correct value to use.
		//
		gMaxPasswordLength = (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?
								UAM_MAX_LMv2_PASSWORD : UAM_CLRTXTPWDLEN;
	}
}

// ---------------------------------------------------------------------------
//		 UAM_InitializeDialogPasswordItem()
// ---------------------------------------------------------------------------
//	Initialize the dialog password edit control by setting its validation
//	and key filter procs.
//
//	Returns: TRUE if initialization was successful.
//

Boolean UAM_InitializeDialogPasswordItem(
		DialogRef 		inDialog,
		SInt16 			inItem
		)
{
    OSErr		theError = noErr;
    
	#ifdef UAM_TARGET_CARBON
    ControlRef	theControl	= NULL;
    
    theError = GetDialogItemAsControl(inDialog, inItem, &theControl);
    
    if ((theError != noErr) || (!IsValidControlHandle(theControl)))
    {
        //
        //For some reason we couldn't get a handle to the control. Exit
        //gracefully if possible.
        //
        Assert_(0);
        return(FALSE);
    }
    
    //
    //Create the universal proc ptr that will get called when validation
    //is necessary. We only do this on the initial call to this func.
    //
    if (gKeyFilterUPP == NULL)
    {
        gKeyFilterUPP = NewControlKeyFilterUPP(
                                    (ControlKeyFilterUPP)&UAM_PasswordKeyFilterProc);
        
        if (gKeyFilterUPP == NULL)
        {
            DbgPrint_((DBGBUFF, "Initializing password key filter proc failed!"));
            
            //
            //Not enough memory?? Bail and tell the caller we're done.
            //
            return(FALSE);
        }
    }
    
    //
    //Now set the proc in the control by using the Set API.
    //
    theError = SetControlData(
                        theControl,
                        kControlNoPart,
                        kControlEditTextKeyFilterTag,
                        sizeof(ControlKeyFilterUPP),
                        &gKeyFilterUPP);    
    #else
    
    UAM_SetBulletItem(inDialog, inItem, gMaxPasswordLength);
    
    #endif
    
    return(theError == noErr);
}


// ---------------------------------------------------------------------------
//		 UAM_CleanupPasswordFieldItems()
// ---------------------------------------------------------------------------
//	Clean up allocated memory that we used dealing with the edit control
//	passwords.
//

void UAM_CleanupPasswordFieldItems(void)
{
    if (gKeyFilterUPP == NULL)
    {
        DisposeControlKeyFilterUPP(gKeyFilterUPP);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_PasswordKeyFilterProc()
// ---------------------------------------------------------------------------
//	Validate the password field whenever a key is pressed.
//

ControlKeyFilterResult 
UAM_PasswordKeyFilterProc(
        ControlRef 		inControl,
        SInt16*			inKeyCode,
        SInt16*			inCharCode,
        EventModifiers*	inModifiers)
{
	#pragma unused(inKeyCode)
	#pragma unused(inModifiers)
	
    Size						theActualLength = 0;
    char						theText[64];
    OSErr						theError;
    ControlEditTextSelectionRec	theSelection;
    
    //
    //Get the actual password text from the control. We don't care what the
    //text is at this point, we only want it's size.
    //
    theError = GetControlData(
                    inControl,
                    kControlNoPart,
                    kControlEditTextPasswordTag,
                    sizeof(theText),
                    theText,
                    &theActualLength);
                    
    //
    //If we got an error getting the string, then we're in big trouble.
    //
    if (theError != noErr)
    {
        Assert_(0);
        return(kControlKeyFilterBlockKey);
    }
    
    //
    //Here are the keystrokes that we just plain don't want to allow in
    //the password edit field.
    //
    switch(*inCharCode)
    {
        case UAMKey_Escape:
        case UAMKey_PageUp:
        case UAMKey_PageDown:
        case UAMKey_End:
        case UAMKey_Home:
            return(kControlKeyFilterBlockKey);
            
        default:
            //
            //The key pressed is okay to pass onto the password edit field.
            //
            break;
    }
       
    //
    //Check and make sure the length of the password+1 is within the limits.
    //
    if ((theActualLength + 1) > gMaxPasswordLength)
    {
        //
        //The additional character will make the password too long. Before we
        //put up the warning, check to make sure that no text is selected that
        //would be deleted upon accepting the key press.
        //
        
        theError = GetControlData(
                            inControl,
                            kControlNoPart,
                            kControlEditTextSelectionTag,
                            sizeof(theSelection),
                            (void*)&theSelection,
                            &theActualLength);
                            
        if (theError == noErr)
        {
            //
            //If selStart != selEnd, then there is a selection and we should
            //allow the key press.
            //
            if (theSelection.selStart != theSelection.selEnd)
            {
                return(kControlKeyFilterPassKey);
            }
        }
        
        switch(*inCharCode)
        {
            case UAMKey_BackDel:
            case UAMKey_FwdDel:
            case UAMKey_Left:
            case UAMKey_Right:
            case UAMKey_Return:
            case UAMKey_Enter:
                 break;
                
            default:
                Str32 theLengthStr;
                
                NumToString(gMaxPasswordLength, theLengthStr);
                ParamText(NULL, NULL, NULL, theLengthStr);
                                
                //
                //The password is too long, so we warn the user.
                //
                UAM_StandardAlert(uamErr_PasswordMessage, uamErr_PasswordTooLongExplanation, NULL);
                
                //
                //Block the key from being accepted into the password buffer.
                //
                return(kControlKeyFilterBlockKey);
        }
    }
    
    return(kControlKeyFilterPassKey);
}


// ---------------------------------------------------------------------------
//		 UAM_GetPasswordText()
// ---------------------------------------------------------------------------
//	Get the text from the password edit control.
//

void UAM_GetPasswordText(DialogRef inDialog, short item, Str255 theText)
{
	#ifdef UAM_TARGET_CARBON
	
    OSErr		theError;
    Size		theActualLength;
    ControlRef	theControl	= NULL;
    
    theError = GetDialogItemAsControl(inDialog, item, &theControl);
    
    if (theError == noErr)
    {
        GetControlData(
                theControl,
                kControlNoPart,
                kControlEditTextPasswordTag,
                sizeof(Str255),
                (char*)&theText[1],
                &theActualLength);
                
        theText[0] = (UInt8)theActualLength;
    }
    #else
    
    UAM_GetBulletBuffer(inDialog, item, theText);
    
    #endif
}


// ---------------------------------------------------------------------------
//		 UAM_SetPasswordText()
// ---------------------------------------------------------------------------
//	Set the text in a password edit control.
//

void UAM_SetPasswordText(DialogRef inDialog, short item, const Str255 theText)
{
	#ifdef UAM_TARGET_CARBON
	
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, item, &theControl);
    
    if (theError == noErr)
    {
        SetControlData(
                theControl,
                kControlEditTextPart,
                kControlEditTextPasswordTag,
                theText[0],
                (void*)&theText[1]);
    }
    #else
    
    UAM_SetBulletText(inDialog, item, (unsigned char*)theText);
    
    #endif
}


// ---------------------------------------------------------------------------
//		 UAM_MakePasswordItemFocusItem()
// ---------------------------------------------------------------------------
//	Makes a password item the keyboard focus item and select the text in it.
//

void UAM_MakePasswordItemFocusItem(DialogRef inDialog, SInt16 inPasswordItemID)
{
	#ifdef UAM_TARGET_CARBON
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, inPasswordItemID, &theControl);
    
    if (theError == noErr)
    {
        SetKeyboardFocus(GetDialogWindow(inDialog), theControl, kControlEditTextPart);
    }
    #else
    
    SelectDialogItemText(inDialog, inPasswordItemID, 0, 0);
    
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamutils.cpp ===
// ===========================================================================
//	UAMUtils.cp 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// General utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#ifdef UAM_TARGET_CARBON
#include <Carbon/Carbon.h>
#include <CoreServices/CoreServices.h>
#else
#include <OpenTransport.h>
#include <OpenTptLinks.h>
#include <OpenTptConfig.h>
#endif

#include <String.h>
#include <stdio.h>
#include <ctype.h>
#include <macstrsafe.h>

#include "UAMUtils.h"
#include "UAMNetwork.h"
#include "UAMDialogs.h"
#include "UAMDebug.h"


// ---------------------------------------------------------------------------
//		 UAM_CToPStr()
// ---------------------------------------------------------------------------
//	In carbon, c2pstr is not supported. Roll our own.
//
//	This should usually be called using the _c2pstr macro.

StringPtr UAM_CToPStr(char* ioStr)
{
	if (ioStr != nil)
	{
		UInt8	theLen = strlen(ioStr);
		
		BlockMoveData(ioStr, ioStr+1, theLen);
		
		ioStr[0] = (char)theLen;
	}
	
	return((StringPtr)ioStr);
}


// ---------------------------------------------------------------------------
//		 UAM_PToCStr()
// ---------------------------------------------------------------------------
//	In carbon, p2cstr is not supported. Roll our own.
//
//	This should usually be called using the _p2cstr macro.

char* UAM_PToCStr(StringPtr ioStr)
{
	if (ioStr != nil)
	{
		UInt8	theLen = PSTR_LENGTH(ioStr);
		
		BlockMoveData(ioStr+1, ioStr, theLen);
		
		ioStr[theLen] = 0;
	}
	
	return((char*)ioStr);
}


// ---------------------------------------------------------------------------
//		 UAM_PStrCopy()
// ---------------------------------------------------------------------------
//	Custom routine for copying pascal style strings. Copies inSrcString into
//	inDestString.
//

void UAM_PStrCopy(const Str255 inSrcString, StringPtr inDestString, SInt16 inMaxLength)
{
	//
	//01.16.02: Add check for string length. Default to 256 bytes max length.
	//
	
	Size	theAmountToCopy = PSTR_LENGTH(inSrcString) + 1;
	
	theAmountToCopy = (theAmountToCopy > inMaxLength) ? inMaxLength : theAmountToCopy;
	
	BlockMove(inSrcString, inDestString, theAmountToCopy);
	inDestString[0] = inSrcString[0];
}


// ---------------------------------------------------------------------------
//		 UAM_AppendPStr()
// ---------------------------------------------------------------------------
//	Custom routine for appending one pascal style string to another.
//	inAppendStr in pasted to the end of inBase. inDestSize if the maximum size
//	the new string can be.

void UAM_AppendPStr(Str255 inBase, const Str255 inAppendStr, short inDestSize)
{
	short	charsToCopy	= inAppendStr[0];
	
	if ((inBase[0] + charsToCopy) > (inDestSize - 1)) {
		charsToCopy = inDestSize - 1 - inBase[0];
	}
	
	BlockMove(inAppendStr + 1, inBase + inBase[0] + 1, charsToCopy);
	
	inBase[0] += charsToCopy;
}

#pragma mark-
// ---------------------------------------------------------------------------
//		 UAM_GetUserName()
// ---------------------------------------------------------------------------
//	Returns the default user name as set in the Sharing Setup/File Sharing
//	dialogs. This would also be considered the old 'Chooser' name.

void UAM_GetUserName(StringPtr outUserName)
{
	StringHandle	theString = NULL;
	
	outUserName[0] = 0;
		
	theString = GetString(STR_ChooserUserName);
	if (theString != NULL)
	{
		UAM_PStrCopy(*theString, outUserName);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_GetWorkStationName()
// ---------------------------------------------------------------------------
//	Returns the workstation name as set in the Sharing Setup/File Sharing
//	dialogs.

void UAM_GetWorkStationName(Str255 outWSName)
{
	StringHandle	theString = NULL;
	Str255			theAddress;
	
	//
	//We assume failure here, if it fails, the user hasn't entered
	//a workstation name. Most likely a missconfiguration.
	//
	outWSName[0] = 0;
	
	theString = GetString(STR_Sys7WorkStationName);
	if ((theString != NULL) && (PSTR_LENGTH(*theString) > 0))
	{
		HLock((Handle)theString);
		UAM_PStrCopy(*theString, outWSName);
		HUnlock((Handle)theString);
	}
    else
    {
        //
        //No name exists in the resource or the resource does not
        //exist.
        //
        
        UAM_PStrCopy(PSTR_DEFAULT_WORKSTATION_NAME, outWSName);
    }
    
    #ifndef UAM_TARGET_68K
    OSStatus	theStatus;
    
    //
    //For PPC and Carbon, we want to append the MAC address to the
    //workstation name. This gives us better identification on the
    //net for Mac clients.
    //
    theStatus = UAM_GetEthernetAddress(theAddress);
    
	if (OT_SUCCESS(theStatus))
    {
    	UAM_AppendPStr(outWSName, "\p(", sizeof(Str255));
    	UAM_AppendPStr(outWSName, theAddress, sizeof(Str255));
    	UAM_AppendPStr(outWSName, "\p)", sizeof(Str255));
    }
    else
    {
        DbgPrint_((DBGBUFF, "UAM_GetEthernetAddress() failed, error = %d", (int)theStatus));
    }
    #endif //UAM_TARGET_68K
}


// ---------------------------------------------------------------------------
//		 UAM_AFPClientSupportsOurUAM
// ---------------------------------------------------------------------------
//	Returns TRUE if the client we're on is running AppleShare Client 3.8
//	or later.

Boolean UAM_AFPClientSupportsOurUAM(void)
{
	short 	theCfgWord;
	short	theVersion = UAM_AppleShareVersion(&theCfgWord);
	
	if (theVersion <= gestaltAFPClient3_7_2)
	{
        //
        //This will never happen under MacOS X.
        //
		return(false);
	}
	
	return(true);
}


// ---------------------------------------------------------------------------
//		 UAM_VerifyServerInfo()
// ---------------------------------------------------------------------------
//	Verify that the server info reply block the server returned to us is
//	valid.
//
//	NOTE: 	This function assumes that the string buffer is packed with the
//			strings in the order they appear in the AFPSrvrInfo structure.
//			Any change in order on the server must result in a change here
//			as well.
//
//	->	inServerInfo		Server info reply block sent to us by the server.
//
//	Returns: TRUE if we think the reply block is valid.
//
//	The format of the ServerInfo block is as follows:
//
//	struct AFPSrvrInfo {
//		short 							fMachineOffset;
//		short 							fVerCountOffset;
//		short 							fUAMCountOffset;
//		short 							fIconOffset;
//		short 							fFlags;
//		unsigned char 					fSrvrName[2];
//		char							variablelengthdata[0];
//	};
//
#if 0
Boolean UAM_VerifyServerInfo(
	IN	AFPSrvrInfo* 	inReplyInfo
)
{
	UInt32		theEndOfBuffer;
	StringPtr	theString;
	
	//
	//First, make sure none of the offset fields are not negative numbers. In the
	//context of this UAM, we MUST have version UAM and machines strings as well.
	//
	if (	(inReplyInfo->fMachineOffset > 0)			||
			(inReplyInfo->fVerCountOffset > 0)			||
			(inReplyInfo->fUAMCountOffset > 0)			||
			(inReplyInfo->fIconOffset > 0)				)
	{
		//
		//The server info block is corrupt or has been tampered with.
		//
		DbgPrint_((DBGBUFF, "Invalid (negative or zero) offsets in server info buffer"));
		return(FALSE);
	}
	
	//
	//We have to assume the SFM server will always send the buffer in the same
	//order and that it will always fill in all the blocks for information.
	//
	
	//========================================================================
	//MACHINE TYPE
	//========================================================================
	
	//
	//The machine offset should always be the space just after the server name.
	//
	SInt16 theMachineOffset	= ((UInt32)inReplyInfo) + inReplyInfo->fSrvrName[0] + 1;
	
	if (theMachineOffset != inReplyInfo->fMachineOffset)
	{
		//
		//Problem: the calculated offset doesn't match the one passed.
		//
		DbgPrint_((DBGBUFF, "Bad machine offset in server info buffer! (%d vs.%d)",
							inReplyInfo->fMachineOffset,
							theMachineOffset
							));
		return(FALSE);
	}
	
	//
	//Now see if the correct machine type is returned.
	//
	theString = ((StringPtr)(((UInt32)inReplyInfo) + theMachineOffset));
	
	if (!EqualString(theString, PSTR_NT_MACHINE_TYPE, true, true))
	{
		//
		//This is not a Windows NT server so the buffer is corrupt.
		//
		DbgPrint_((DBGBUFF, "Bad machine type in server info buffer! (%s)", _p2cstr(theString)));		
		return(FALSE);
	}
	
	//========================================================================
	//AFP VERSION
	//========================================================================

	//
	//The AFP version offset will always follow the machine type offset string.
	//
	SInt16 theVersionOffset	= PSTR_LENGTH(theString) + 1;
	SInt16 theVersionCount	= *(SInt16*)(((UInt32)inReplyInfo) + theVersionOffset);
	
	//
	//Make sure our calculated offset matches the one passed to us.
	//
	if (theVersionOffset != inReplyInfo->fVerCountOffset)
	{
		//
		//Offset is incorrect so the buffer is corrupt.
		//
		DbgPrint_((DBGBUFF, "Bad afp version offset in server info buffer! (%d vs.%d)",
							inReplyInfo->fVerCountOffset,
							theVersionOffset
							));
		return(FALSE);
	}
	
	//
	//We don't expect any more than 3 AFP versions from the server.
	//
	if ((theVersionCount < MINNUM_AFP_VERSIONS_SUPPORTED) 	||
		(theVersionCount > MAXNUM_AFP_VERSIONS_SUPPORTED)	)
	{
		//
		//Bad number of versions supported.
		//
		DbgPrint_((DBGBUFF, "Bad afp version count in server info buffer! (%d)",
							theVersionCount
							));
		return(FALSE);
	}
		
	return(TRUE);
}
#endif


// ---------------------------------------------------------------------------
//		 UAM_GetSupportedUAMS()
// ---------------------------------------------------------------------------
//	Returns a bitmap containing the UAMs supported on the server.
//
//	->	inReplyInfo			Pointer to reply info supplied by ASPGetStatus() call.
//	<-	outSupportedUAMS	Bitmap containing supported UAMs:
//								- Clear Text Password (Apple)
//								- Guest (Apple and MS)
//								- Microsoft V1.0
//								- Microsoft V2.0
//								- Microsoft V3.0
//
//	As per Inside AppleTalk p.13-96, the supported UAM string variable list structure:
//
//		|-------------------|
//		|   Count of UAMs   |
//		|-------------------|
//		|					|
//							
//			 UAM Strings	
//							
//		|					|
//		|-------------------|

void UAM_GetSupportedUAMS(
	IN	UAMArgs*		inUAMArgs,
	IN	StringPtr		inAFPVersion,
	OUT	SInt32*			ioSupported)
{
	AFPSrvrInfo*	theServerInfo = inUAMArgs->Opt.open.srvrInfo;
	char*			theString;
	SInt16			theIndex;
	SInt16			theUAMCount;
	
	if ((ioSupported == NULL) || (inAFPVersion == NULL))
	{
		if (ioSupported != NULL)
		{
			*ioSupported = 0;
		}
		return;
	}
	
	theString 	= ((char *)theServerInfo) + theServerInfo->fUAMCountOffset;
	theUAMCount	= *theString;
	
	//
	//The first byte is the UAM count, so we must increment past it.
	// 
	++theString;
	
	//
	//Initialize the return struct to all false.
	//
	*ioSupported = 0L;

	for (theIndex = theUAMCount; theIndex > 0; theIndex--, theString += theString[0] + 1)
	{
		if (EqualString(PSTR_ClearTextLogin, (StringPtr)theString, false, false))
		{
			*ioSupported |= kClearTxtSupported;
			continue;
		}
		
		if (EqualString(PSTR_GuestLogin, (StringPtr)theString, false, false))
		{
			*ioSupported |= kGuestSupported;
			continue;
		}
		
		if (EqualString(PSTR_EncryptedLogin1_0, (StringPtr)theString, false, false))
		{
			*ioSupported |= kMSUAMSupported;
			continue;
		}
		
		if (EqualString(PSTR_EncryptedLogin2_0, (StringPtr)theString, false, false))
		{
			*ioSupported |= kMSUAM_V2_Supported;
			continue;
		}
		
		if (EqualString(PSTR_EncryptedLogin3_0, (StringPtr)theString, false, false))
		{
			*ioSupported |= kMSUAM_V3_Supported;
			continue;
		}
	}
		
	//
	//02.08.02: We check to make sure the server is not lying to us regarding
	//what auth method it supports. This will make a "downgrade" attack
	//a little harder, but doesn't stop it completely.
	//
	if ((*ioSupported & kMSUAM_V2_Supported) == 0)
	{
		//
		//The server is telling us that it is not a Win2K server and as a result
		//does not support the new stronger NTLMv2 auth. method. Make some checks
		//to see if it is lying to us.
		//
		#ifndef UAM_TARGET_CARBON
		if (	(theServerInfo->fFlags & kSupportsTCPIP)					||
				(inUAMArgs->Opt.open.srvrAddress->fAddressType == AF_INET)	)
		#else
		if (	(theServerInfo->fFlags & kSupportsTCPIP)					)
		#endif
		{
			DbgPrint_((DBGBUFF, "SPOOF! TCP connection - forcing NTLMv2 auth!"));
			
			//
			//Gotcha! If the server supports TCP/IP connections then it
			//is at least a Windows2000 server that supports NTLMv2.
			//
			*ioSupported |= kMSUAM_V2_Supported;
		}
		
		//
		//Check the AFP version and see if we were spoofed somehow there.
		//
		
		//
		//If the 4th character in the string is a digit (0-9) then we know
		//we have AFP2.2 or higher as this is when Apple went from the
		//AFPVersion X.X format to the AFPX.X format.
		//
		if (isdigit(inAFPVersion[4]))
		{
			DbgPrint_((DBGBUFF, "SPOOF! AFP2.2 or higher is supported - forcing NTLMv2 auth!"));
				
			//
			//Gotcha! Force NTLMv2 authorization since the server supports AFP2.2
			//or higher.
			//
			*ioSupported |= kMSUAM_V2_Supported;
		}
	}
}


#pragma mark-
// ---------------------------------------------------------------------------
//		 UAM_VersionString
// ---------------------------------------------------------------------------
//	Returns a string containing the version of this build.

void UAM_VersionString(Str32 outVersionString)
{
	Handle			theVersHandle;
	long			theVersion;
	unsigned char	theVer1, theVer2, theVer3, theRelStatus, thePrereleaseNum;
	Str32			theTempStr;
	
	outVersionString[0] = 0;
	UAM_PStrCopy("\pv", outVersionString);
	
	theVersHandle = Get1Resource('vers', 1);
	if (theVersHandle)
	{
		theVersion = *((long *)(*theVersHandle));
	
		ReleaseResource(theVersHandle);
	
		theVer1		= ((char *)&theVersion)[0];
		theVer1		= (((theVer1 & 0xF0) >> 4) * 10) + (theVer1 & 0x0F);
		theVer2		= (((char *)&theVersion)[1] & 0xF0) >> 4;
		theVer3		= (((char *)&theVersion)[1] & 0x0F);
		
		theRelStatus		= ((char *)&theVersion)[2];
		thePrereleaseNum	= ((char *)&theVersion)[3];
		
		NumToString((long)theVer1, theTempStr);
		UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
		UAM_AppendPStr(outVersionString, "\p.", sizeof(Str32));
		
		NumToString((long)theVer2, theTempStr);
		UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
	
		if (theVer3 != 0)
		{
			UAM_AppendPStr(outVersionString, "\p.", sizeof(Str32));
			
			NumToString((long)theVer3, theTempStr);
			UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
		}
		
		switch(theRelStatus)
		{
			case 0x20:
				UAM_AppendPStr(outVersionString, "\pd", sizeof(Str32));
				break;
			
			case 0x40:
				UAM_AppendPStr(outVersionString, "\pa", sizeof(Str32));
				break;
	
			case 0x60:
				UAM_AppendPStr(outVersionString, "\pb", sizeof(Str32));
				break;
				
			default:
				break;
		}
		
		if (theRelStatus != 0x80)
		{
			NumToString((long)thePrereleaseNum, theTempStr);
			UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_GetAFPVersionString
// ---------------------------------------------------------------------------
//	Return the AFP version string and the default user name.

void UAM_GetAFPVersionString(	AFPSrvrInfo 			*inInfo,
								ClientUAMCallbackRec 	*inCallbacks,
								Str32					ioAFPVersion,
								Str32					ioDefaultUserName	)
{
	struct 		AFPClientInfo *theClientInfo = NULL;
	short		theIndex;
	StringPtr	theVersionBuf;
	UInt32		theVersionBufSize;
	Boolean		theResult;
	OSStatus 	theError;
	
	ioAFPVersion[0]	  	 = 0;
	ioDefaultUserName[0] = 0;
	
	if ((inCallbacks) && (inInfo))
	{
		//
		//Use the UAM callback GetClientInfo() to get the client info.
		//
		theError = UAM_CALLBACK_TWOPARAM(
							inCallbacks->GetClientInfoUPP,
							kGetClientInfoProcInfo,
							kAFPClientInfo,
							(ClientInfo **)&theClientInfo);
		
		if (theError != noErr)
		{
			UAM_ReportError(theError);
			return;
		}
				
		if (theClientInfo)
		{
			//
			//Stuff the default user name in the return parameter.
			//
			UAM_PStrCopy(theClientInfo->fDefaultUserName, ioDefaultUserName);
			
			//
			//Go through the list of AFP versions supported on this client
			//and try to find them in the SrvrInfoBuffer, first match
			//succeeds.
			//
			
			theVersionBuf		= (StringPtr)((UInt32)inInfo + inInfo->fVerCountOffset + 1);
			theVersionBufSize	= (inInfo->fUAMCountOffset - inInfo->fVerCountOffset) - 1;
			
			for (theIndex = 0; theIndex < theClientInfo->fNumAFPVersions; theIndex++)
			{
				theResult = UAM_FindStringInBuffer(
										theClientInfo->fAFPVersionStrs[theIndex],
										theVersionBuf,
										theVersionBufSize  );
				
				if (theResult)
				{
					UAM_PStrCopy(theClientInfo->fAFPVersionStrs[theIndex], ioAFPVersion);
					return;
				}
			}
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_FindStringInBuffer
// ---------------------------------------------------------------------------
//	Finds a pascal string within a buffer.

Boolean UAM_FindStringInBuffer(StringPtr inString, StringPtr inBuffer, short inBufferSize)
{
	short	i = 0;
	short	theLen;
	
	theLen = inBuffer[i];
	
	while(TRUE)
	{
		if (memcmp(&inBuffer[i], inString, theLen + 1) != 0)
		{
			i += theLen + 1;
			theLen = inBuffer[i];
			
			if (i >= inBufferSize)
				break;
		}
		else {
			return(TRUE);
		}
	}
	
	return(FALSE);
}


// ---------------------------------------------------------------------------
//		 UAM_AppleShareVersion()
// ---------------------------------------------------------------------------
//	Returns the version of AppleShare running on the host computer.

short UAM_AppleShareVersion(short *upperWord)
{
	long	theResult;
	OSErr	theError;
	
	theError = Gestalt(gestaltAFPClient, &theResult);
	if (!theError)
	{
		if (upperWord != NULL) {
			*upperWord = (theResult & gestaltAFPClientAttributeMask);
		}
		
		return(theResult & gestaltAFPClientVersionMask);
	}
	
	return(0);
}


// ---------------------------------------------------------------------------
//		 UAM_KeyDown()
// ---------------------------------------------------------------------------
//	Returns TRUE if the passed keycode is currently held down.

Boolean UAM_KeyDown(Int16 inKeycode)
{
	KeyMapByteArray	theKeyMap;
	
	#ifdef UAM_TARGET_CARBON
	GetKeys((SInt32*)theKeyMap);
	#else
	GetKeys((UInt32*)theKeyMap);
	#endif
	
	return((theKeyMap[inKeycode>>3] >> (inKeycode & 7)) & 1);
}


// ---------------------------------------------------------------------------
//		 UAM_ExtractDomainName()
// ---------------------------------------------------------------------------
//	Extracts a domain name from a user name entry of: domain\username
//
//	outDomainName must be a buffer big enough to hold the found domain
//	name or MAX_DOMAIN_NAME_LEN+1 in length.
//
//	Returns: TRUE if a domain name was found.
//

Boolean UAM_ExtractDomainName(char* inUserName, char* outDomainName, SInt16 cbDomainName)
{
	char*	theTemp;
	
	theTemp = strchr(inUserName, '\\');
	
	if (theTemp)
	{
		strncpy(
			outDomainName,
			inUserName,
			_min(cbDomainName, (theTemp-inUserName))
			);
		
		return(TRUE);
	}
	
	return(FALSE);
}


// ---------------------------------------------------------------------------
//		 UAM_ExtractUserName()
// ---------------------------------------------------------------------------
//	Extracts a user name from a user name entry of: domain\username
//
//	outUserName must be a buffer big enough to hold the found user
//	name or MAX_USER_NAME_LEN+1 in length.
//
//	Returns: TRUE if a user name was found.
//

Boolean UAM_ExtractUserName(char* inUserName, char* outUserName, SInt16 cbOutUserName)
{
	char*	theTemp;
	char	theTempUserName[64];
	
	//
	//We make a copy of the original user name so the caller can
	//use the same buffer to receive the new actual user name.
	//
	StringCbCopy(theTempUserName, sizeof(theTempUserName), inUserName);
	
	theTemp = strchr(theTempUserName, '\\');
	
	if (theTemp)
	{
		StringCbCopy(outUserName, cbOutUserName, theTemp+1);
		return(strlen(outUserName) > 0);
	}
	
	return(FALSE);
}


// ---------------------------------------------------------------------------
//		 UAM_GetEthernetAddress()
// ---------------------------------------------------------------------------
//	Returns the hardware ethernet address by using OpenTransport.
//
//	****This function will crash if run on 68K machines!****
//

OSStatus UAM_GetEthernetAddress(Str255 outAddress)
{
	OSStatus		theStatus		= kOTNoError;
	UInt32			theIndex		= 0;
	EndpointRef		theEndPoint;
	OTPortRecord	theDevicePortRec;
	TBind			theReturnInfo;
	TBind			theRequestInfo;
	Address8022		theReturnAddr	= {AF_8022, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0x0000,
									  {0x00,0x00,0x00,0x00,0x00}};
	Address8022		theAddress		= {AF_8022, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0x8888,
									  {0x00,0x00,0x00,0x00,0x00}};
	Boolean			fFoundAPort		= TRUE;
	
	theStatus = UAMInitOpenTransport(kInitOTForApplicationMask, NULL);
	
	if (OT_SUCCESS(theStatus))
	{
		//
		//Iterate through each OT port record for ethernet devices.
		//
		while(TRUE)
		{
			fFoundAPort = OTGetIndexedPort(&theDevicePortRec, theIndex);
			
			if (!fFoundAPort)
			{
				break;
			}
			
			if ((theDevicePortRec.fCapabilities & kOTPortIsDLPI)	&&
				(theDevicePortRec.fCapabilities & kOTPortIsTPI)		&&
				(kOTEthernetDevice == OTGetDeviceTypeFromPortRef(theDevicePortRec.fRef)))
			{
				theEndPoint = UAMOTOpenEndpoint(
									OTCreateConfiguration(theDevicePortRec.fPortName),
									(OTOpenFlags)NULL,
									NULL,
									&theStatus
									);
				
				if (OT_SUCCESS(theStatus))
				{
					//
					//Bind the endpoint so we can get the address info.
					//
					theRequestInfo.addr.buf		= (UInt8*)&theAddress;
					theRequestInfo.addr.len		= 10;
					theRequestInfo.addr.maxlen	= 0;
					theRequestInfo.qlen			= 0;
					
					theStatus = OTBind(theEndPoint, &theRequestInfo, NULL);
					
					if (OT_SUCCESS(theStatus))
					{
						theReturnInfo.addr.buf		= (UInt8*)&theReturnAddr;
						theReturnInfo.addr.maxlen	= 10;
						theReturnInfo.qlen			= 0;
						
						theStatus = OTGetProtAddress(
										theEndPoint,
										&theReturnInfo,
										NULL
										);
						
						if (OT_SUCCESS(theStatus))
						{
							char	c1,c2;
							Str15	theHex;
							
							theHex[0] = 12;
							
							for (Int16 i = 0; i < 6; i++)
							{
								c1 = ((theReturnAddr.fHWAddr[i] >> 4) & 0xF) + '0';
								c2 = (theReturnAddr.fHWAddr[i] & 0x0F) + '0';
								
								if (c1 > '9')	c1 = c1 + ('A' - '9' - 1);
								if (c2 > '9')	c2 = c2 + ('A' - '9' - 1);
								
								theHex[2*i+1] = c1;
								theHex[2*i+2] = c2;
							}
							
							UAM_PStrCopy(theHex, outAddress);
							break;
						}
						
						OTUnbind(theEndPoint);
					}
					
					OTCloseProvider(theEndPoint);
				}
			}
			
			theIndex++;
		}
	}
	
	UAMCloseOpenTransport(NULL);
	
	return theStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uampswdfield.h ===
// ===========================================================================
//	UAMPswdField.c 				 2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#ifdef UAM_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

void UAM_SetMaximumPasswordLength(
		Boolean			inChangingPassword
		);

Boolean UAM_InitializeDialogPasswordItem(
		DialogRef 		inDialog,
		SInt16 			inItem
		);
		
void UAM_CleanupPasswordFieldItems(void);

ControlKeyFilterResult UAM_PasswordKeyFilterProc(
        ControlRef 		inControl,
        SInt16*			inKeyCode,
        SInt16*			inCharCode,
        EventModifiers*	inModifiers
		);

void UAM_GetPasswordText(DialogRef inDialog, short item, Str255 theText);
void UAM_SetPasswordText(DialogRef inDialog, short item, const Str255 theText);
void UAM_MakePasswordItemFocusItem(DialogRef inDialog, SInt16 inPasswordItemID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\uamutils.h ===
// ===========================================================================
//	UAMUtils.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "ClientUAM.h"

#define PSTR_DEFAULT_WORKSTATION_NAME	"\pMacintosh"

#define STR_ChooserUserName		-16096		//User name set in sharing setup
#define STR_Sys7WorkStationName	-16413		//Workstation (computer) name set in sharing setup

#define PSTR_LENGTH(s)			s[0]

//
//This macro "does the right thing" when calling any callback functions. The method
//for calling these fuctions is different depending on what platform we're building
//for.
//
#if defined(UAM_TARGET_PPC) && !defined(UAM_TARGET_CARBON)
#define UAM_CALLBACK_ONEPARAM(procPtr, procInfo, param)	\
                                    CallUniversalProc(procPtr, procInfo, param)
#define UAM_CALLBACK_TWOPARAM(procPtr, procInfo, param1, param2) \
									CallUniversalProc(procPtr, procInfo, param1, param2)
#define UAM_CALLBACK_THREEPARAM(procPtr, procInfo, param1, param2, param3) \
                                    CallUniversalProc(procPtr, procInfo, param1, param2, param3)
#else //Must be Carbon PPC or 68K
#define UAM_CALLBACK_ONEPARAM(procPtr, procInfo, param)	\
                                    procPtr(param)
#define UAM_CALLBACK_TWOPARAM(procPtr, procInfo, param1, param2) \
									procPtr(param1, param2)
#define UAM_CALLBACK_THREEPARAM(procPtr, procInfo, param1, param2, param3) \
                                    procPtr(param1, param2, param3)
#endif

//
//In carbon, c2pstr and p2cstr are not defined. So these macros help
//us go between carbon and Mac68K.
//
#ifdef UAM_TARGET_CARBON
#define _c2pstr(c)		UAM_CToPStr(c)
#define _p2cstr(p)		UAM_PToCStr(p)
#else
#define _c2pstr(c)		c2pstr(c)
#define _p2cstr(p)		p2cstr(p)
#endif

//
//Some help with the differences in OT from Classic to Carbon
//
#ifdef UAM_TARGET_CARBON
#define UAMInitOpenTransport(flags,cntx)			InitOpenTransportInContext(flags, cntx);
#define UAMCloseOpenTransport(cntx)					CloseOpenTransportInContext(cntx);
#define UAMOTOpenEndpoint(config,oflag,info,err)	OTOpenEndpointInContext(config,oflag,info,err,NULL);
#else
#define UAMInitOpenTransport(flags,cntx)			InitOpenTransport();
#define UAMCloseOpenTransport(cntx)					CloseOpenTransport();
#define UAMOTOpenEndpoint(config,oflag,info,err)	OTOpenEndpoint(config,oflag,info,err);
#endif

#define _min(a,b)		(((a) < (b)) ? (a) : (b))
#define _max(a,b)		(((a) > (b)) ? (a) : (b))

//
//Help with bitmaps...
//
#define BIT_0	0x1
#define BIT_1	0x2
#define BIT_2	0x4
#define BIT_3	0x8
#define BIT_4	0x10
#define BIT_5	0x20
#define BIT_6	0x40
#define BIT_7	0x80
#define BIT_8	0x100

//
//Some keycodes in keymap form
//
#define KEY_Shift		0x38
#define KEY_Command		0x37
#define KEY_Option		0x3A
#define KEY_Control		0x3B

//
//Event key code types.
//
#define UAMKey_Home				0x01
#define UAMKey_Enter			0x03
#define UAMKey_End				0x04
#define UAMKey_PageUp			0x0B
#define UAMKey_PageDown			0x0C
#define UAMKey_BackDel			0x08
#define UAMKey_Tab				0x09
#define UAMKey_Escape			0x1b
#define UAMKey_Left				0x1c
#define UAMKey_Right			0x1d
#define UAMKey_Up				0x1e
#define UAMKey_Down				0x1f
#define UAMKey_Return			0x0d
#define UAMKey_Space			0x20
#define UAMKey_FirstExtended	0x80
#define UAMKey_FwdDel			0x7f
#define UAMKey_Period			'.'

//
//Struct for accessing server info after a ASPGetStatus call. This is the
//header information provided from the call. See Inside Appletalk p. 13-95/97
//
typedef struct
{
	short		machineTypeOffset;
	short		afpVersionOffset;
	short		supportedUAMOffset;
	short		volumeIconOffset;
	short		serverFlags;
}ServerInfoReplyBlock, *ServerInfoReplyBlockP;

#ifdef UAM_TARGET_CARBON
struct AFPSrvrInfo {
	short 				fMachineOffset;
	short 				fVerCountOffset;
	short 				fUAMCountOffset;
	short 				fIconOffset;
	short 				fFlags;
	unsigned char 		fSrvrName[2];
};
typedef struct AFPSrvrInfo		AFPSrvrInfo;
#endif

//
//Enums for supported UAMs on the server.
//
enum {
	kGuestSupported				= 0x1,
	kClearTxtSupported			= 0x2,
	kMSUAMSupported				= 0x4,
	kMSUAM_V2_Supported			= 0x8,
	kMSUAM_V3_Supported			= 0x10
};

//
//Returns TRUE if the server we're authenticating with only
//supports v2.
//
#define SUPPORTS_MS20_ONLY(bits)	(((bits & kMSUAM_V2_Supported)!=0) && ((bits & kMSUAM_V3_Supported)==0))

//
//Help with types...
//
typedef long Int32;
typedef short Int16;

struct Address8022
{
	OTAddressType	fAddrFamily;
	UInt8			fHWAddr[k48BitAddrLength];
	UInt16			fSAP;
	UInt8			fSNAP[k8022SNAPLength];
};

#define OT_SUCCESS(c)	(((c) >= 0) ? true : false)

//
//Prototypes for utility functions live here.
//
StringPtr	UAM_CToPStr(char* ioStr);
char*		UAM_PToCStr(StringPtr ioStr);
void 		UAM_PStrCopy(const Str255 inSrcString, StringPtr inDestString, SInt16 inMaxLength = sizeof(Str255));
void		UAM_AppendPStr(Str255 inBase, const Str255 inAppendStr, short inDestSize);
void 		UAM_GetUserName(StringPtr outUserName);
void 		UAM_GetWorkStationName(Str255 outWSName);
Boolean 	UAM_AFPClientSupportsOurUAM(void);
void		UAM_VersionString(Str32 outVersionString);
void 		UAM_GetAFPVersionString(AFPSrvrInfo 		*inInfo,
                                        ClientUAMCallbackRec 	*inCallbacks,
                                        Str32			ioAFPVersion,
                                        Str32			ioDefaultUserName	);
Boolean UAM_VerifyServerInfo(
	AFPSrvrInfo* 	inReplyInfo
);
           
void 		UAM_GetSupportedUAMS(UAMArgs* inUAMArgs, StringPtr inAFPVersion, long *ioSupported);
Boolean 	UAM_FindStringInBuffer(StringPtr inString, StringPtr inBuffer, short inBufferSize);
short 		UAM_AppleShareVersion(short *upperWord);
Boolean 	UAM_KeyDown(Int16 inKeycode);
Boolean 	UAM_ExtractDomainName(char* inUserName, char* outDomainName, SInt16 cbDomainName);
Boolean 	UAM_ExtractUserName(char* inUserName, char* outUserName, SInt16 cbOutUserName);
OSStatus	UAM_GetEthernetAddress(Str255 outAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\usrpwst3.h ===
/*****************************************************************/
/**                       Microsoft Windows                     **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

#pragma once

#ifdef UAM_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

#include "crypto.h"
#include "descrypt.h"
#include "rc4.h"

#define __RPC_FAR

//
// From ntsam.h
//
#define SAM_MAX_PASSWORD_LENGTH 256

#define ERROR_SUCCESS			0
#define ERROR_INVALID_FUNCTION	-1070

#define ntoh(a)	((((a) << 24) & 0xFF000000) | (((a) << 8) & 0x00FF0000) | (((a) >> 8) & 0x0000FF00) | (((a) >> 24) & 0x000000FF))

//
// From sampass.h
//
typedef struct //_SAMPR_USER_PASSWORD
{
	UInt16 	Buffer[256];
	DWORD 	Length;
}SAMPR_USER_PASSWORD, *PSAMPR_USER_PASSWORD;

//typedef struct _SAMPR_USER_PASSWORD __RPC_FAR *PSAMPR_USER_PASSWORD;
typedef struct  _SAMPR_ENCRYPTED_USER_PASSWORD
{
	UCHAR Buffer[516];
}SAMPR_ENCRYPTED_USER_PASSWORD;

typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD __RPC_FAR *PSAMPR_ENCRYPTED_USER_PASSWORD;


Boolean EncryptStdBlock(
    	IN 	PBLOCK_KEY 		BlockKey,
    	OUT PCYPHER_BLOCK 	CypherBlock	
);
Boolean CalculateLmOwfPassword(
    	IN 	PLM_PASSWORD 		LmPassword,
    	OUT PLM_OWF_PASSWORD 	LmOwfPassword
);
Boolean EncryptBlock(
    	IN 	PCLEAR_BLOCK 	ClearBlock,
    	IN 	PBLOCK_KEY 		BlockKey,
    	OUT PCYPHER_BLOCK 	CypherBlock
);
Boolean EncryptLmOwfPwdWithLmOwfPwd(
    	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,
    	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,
   		OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword
);

OSStatus SampEncryptLmPasswords(
	    LPSTR OldUpcasePassword,
	    LPSTR NewUpcasePassword,
	    LPSTR NewPassword,
	    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
	    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uam_common\usrpwst3.cpp ===
/*****************************************************************/
/**                  Microsoft Windows 2000                     **/
/**           Copyright (C) Microsoft Corp., 1991-1998          **/
/*****************************************************************/

/*****************************************************************/
/**                       Microsoft Windows                     **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1991          **/
/********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef __MACUAM__
#include "MWERKSCrypto.h"
#endif

#include "rc4.h"
#include "USRPWST3.h"

// ---------------------------------------------------------------------------
//		 EncryptStdBlock()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes a block key encrypts the standard text block with it.
//    The resulting encrypted block is returned.
//    This is a One-Way-Function - the key cannot be recovered from the
//    encrypted data block.
//
//	Arguments:
//
//    BlockKey - The key to use to encrypt the standard text block.
//
//    CypherBlock - The encrypted data is returned here
//
//	Return Values:
//
//    TRUE - The encryption was successful.
//           The result is in CypherBlock
//
//    FALSE - Something failed. The CypherBlock is undefined.

Boolean EncryptStdBlock(
    		IN 	PBLOCK_KEY 		BlockKey,
    		OUT PCYPHER_BLOCK 	CypherBlock	 )
{
    unsigned 	Result;
    char 		StdEncrPwd[] = "KGS!@#$%";

    Result = DES_ECB_LM((DWORD)ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)StdEncrPwd,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


// ---------------------------------------------------------------------------
//		 CalculateLmOwfPassword()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes the passed LmPassword and performs a one-way-function on it.
//    The current implementation does this by using the password as a key
//    to encrypt a known block of text.
//
//	Arguments:
//
//    LmPassword - The password to perform the one-way-function on.
//
//    LmOwfPassword - The hashed password is returned here
//
//	Return Values:
//
//    Boolean - The function was completed successfully. The hashed
//                     password is in LmOwfPassword.
//
//    FALSE - Something failed. The LmOwfPassword is undefined.

Boolean CalculateLmOwfPassword(
    		IN 		PLM_PASSWORD 		LmPassword,
    		OUT 	PLM_OWF_PASSWORD 	LmOwfPassword )
{
    Boolean     Status;
    BLOCK_KEY   Key[2];
    PCHAR       pKey;
    PBLOCK_KEY	pK;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    // Use the keys to encrypt the standard text

    Status = EncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));

    if (!Status) {
        return(Status);
    }

	pK = (PBLOCK_KEY)(((PUCHAR)&Key[1])-1);

    Status = EncryptStdBlock(pK /*&Key[1]*/, &(LmOwfPassword->data[1]));

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(Status);
}


// ---------------------------------------------------------------------------
//		 EncryptBlock()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes a block of data and encrypts it with a key producing
//    an encrypted block of data.
//
//	Arguments:
//
//    ClearBlock - The block of data that is to be encrypted.
//
//    BlockKey - The key to use to encrypt data
//
//    CypherBlock - Encrypted data is returned here
//
//	Return Values:
//
//    TRUE - The data was encrypted successfully. The encrypted
//                     data block is in CypherBlock
//
//    FALSE - Something failed. The CypherBlock is undefined.

Boolean EncryptBlock(
    	IN 	PCLEAR_BLOCK 	ClearBlock,
    	IN 	PBLOCK_KEY 		BlockKey,
    	OUT PCYPHER_BLOCK 	CypherBlock )
{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


// ---------------------------------------------------------------------------
//		 EncryptLmOwfPwdWithLmOwfPwd()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Encrypts one OwfPassword with another
//
//	Arguments:
//
//    DataLmOwfPassword - OwfPassword to be encrypted
//
//    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption
//
//    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.
//
//	Return Values:
//
//    TRUE - The function completed successfully. The encrypted
//                     OwfPassword is in EncryptedLmOwfPassword
//
//    FALSE - Something failed. The EncryptedLmOwfPassword is undefined.

Boolean EncryptLmOwfPwdWithLmOwfPwd(
    	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,
    	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,
   		OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword )
{
    Boolean    Status;
    PBLOCK_KEY	pK;

    Status = EncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]),
                            &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                            &(EncryptedLmOwfPassword->data[0]));
    if (!Status) {
        return(Status);
    }
    
    pK = (PBLOCK_KEY)&(KeyLmOwfPassword->data[1]);
    
    //
    //Notice the "-1" in the second parameter, this is necessary because the
    //compiler aligns on an 8 byte boundary!
    //

    Status = EncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]),
                            (PBLOCK_KEY)(((PUCHAR)pK)-1),
                            &(EncryptedLmOwfPassword->data[1]));  
     
    //
    //*****************************************
    //
    
    return(Status);
}


// ---------------------------------------------------------------------------
//		 SampEncryptLmPasswords()
// ---------------------------------------------------------------------------
//Routine Description:
//
//    Encrypts the cleartext passwords into the form that is sent over
//    the network.  Before computing the OWF passwords, the cleartext forms
//    are upper cased, then OEMed (the order is significant).  The cleartext
//    password to be sent is OEMed only.
//
//Arguments:
//
//Return Value:

OSStatus SampEncryptLmPasswords(
	    LPSTR OldUpcasePassword,
	    LPSTR NewUpcasePassword,
	    LPSTR NewPassword,
	    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
	    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm )
{
    LM_OWF_PASSWORD OldLmOwfPassword;
    LM_OWF_PASSWORD NewLmOwfPassword;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    Boolean Status;
    
    memset(&Rc4Key, 0, sizeof(RC4_KEYSTRUCT));

    //
    // Calculate the LM OWF passwords
    //
    Status = CalculateLmOwfPassword(
                OldUpcasePassword,
                &OldLmOwfPassword
                );
    
    if (Status)
    {
        Status = CalculateLmOwfPassword(
                    NewUpcasePassword,
                    &NewLmOwfPassword
                    );
    }

    //
    // Calculate the encrypted old passwords
    //
    if (Status)
    {
        Status = EncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    &NewLmOwfPassword,
                    OldLmOwfEncryptedWithNewLm
                    );
    }
    
    //
    // Calculate the encrypted new passwords
    //
    if (Status)
    {
        //
        // Compute the encrypted new password with LM key.
        //
        rc4_key(
            &Rc4Key,
            (DWORD)LM_OWF_PASSWORD_LENGTH,
            (PUCHAR)&OldLmOwfPassword
            );
            
        memcpy(
            ((PUCHAR) NewLm->Buffer) + (SAM_MAX_PASSWORD_LENGTH * sizeof(UInt16)) - strlen(NewPassword),
            NewPassword,
            strlen(NewPassword)
            );
    
    	//****************************************************
    	//BUGBUG: We must swap the significant bytes on Mac68K
    	//****************************************************
        NewLm->Length = strlen(NewPassword);
		NewLm->Length = ntoh(NewLm->Length);
	
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewLm->Buffer
            );
    }

    if (Status)
    {
        return(ERROR_SUCCESS);
    }
    else return(ERROR_INVALID_FUNCTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\any.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    any.c

Abstract:

    Contains routines to manipulate AsnAny structures.

        SnmpUtilAsnAnyCpy
        SnmpUtilAsnAnyFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilAsnAnyCpy(
    AsnAny * pAnyDst,
    AsnAny * pAnySrc
    )

/*++

Routine Description:

    Copy a variable value.

Arguments:

    pAnyDst - pointer to structure to receive value.

    pAnySrc - pointer to value to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_NOERROR;

    // determine asn type
    switch (pAnySrc->asnType) {

    case ASN_OBJECTIDENTIFIER:

        // copy object identifier
        nResult = SnmpUtilOidCpy(
                    &pAnyDst->asnValue.object, 
                    &pAnySrc->asnValue.object
                    );
        break;

    case ASN_OPAQUE:
    case ASN_IPADDRESS:
    case ASN_OCTETSTRING:
    case ASN_BITS:

        // copy octet string
        nResult = SnmpUtilOctetsCpy(
                    &pAnyDst->asnValue.string,
                    &pAnySrc->asnValue.string
                    );
        break;
        
    default:

        // simply transfer entire structure
        pAnyDst->asnValue = pAnySrc->asnValue;
        break;
    }

    // transfer type to destination
    pAnyDst->asnType = pAnySrc->asnType;

    return nResult;
}


VOID
SNMP_FUNC_TYPE
SnmpUtilAsnAnyFree(
    AsnAny * pAny
    )

/*++

Routine Description:

    Release memory associated with variable value.

Arguments:

    pAny - pointer to variable value to free.

Return Values:

    None. 

--*/

{
    // determine asn type
    switch (pAny->asnType) {

    case ASN_OBJECTIDENTIFIER:

        // free object identifier
        SnmpUtilOidFree(&pAny->asnValue.object);
        break;

    case ASN_OPAQUE:
    case ASN_IPADDRESS:
    case ASN_OCTETSTRING:
    case ASN_BITS:

        // free octet string
        if (pAny->asnValue.string.dynamic)
        {
            SnmpUtilOctetsFree(&pAny->asnValue.string);
            pAny->asnValue.string.dynamic = FALSE;
            pAny->asnValue.string.stream = NULL;
        }
        break;
        
    default:

        break;
    }

    // re-initialize
    pAny->asnType = ASN_NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\dbg.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Contains common SNMP debugging routines.

        SnmpSvcSetLogLevel
        SnmpSvcSetLogType
        SnmpUtilDbgPrint

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <stdio.h>
#include <time.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MAX_LOG_ENTRY_LEN   512


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT g_nLogType  = SNMP_OUTPUT_TO_DEBUGGER;  
INT g_nLogLevel = SNMP_LOG_SILENT;    


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID 
OutputLogEntry(
    LPSTR pLogEntry
    )

/*++

Routine Description:

    Writes log entry to log types specified.

Arguments:

    pLogEntry - zero-terminated string containing log entry text.

Return Values:

    None. 

--*/

{
    // initialize descriptor
    static FILE * fd = NULL;

    // check if console output specified
    if (g_nLogType & SNMP_OUTPUT_TO_CONSOLE) {

        // output entry to stream
        fprintf(stdout, "%s", pLogEntry);

        // flush stream
        fflush(stdout);
    }

    // check if logfile output specified
    if (g_nLogType & SNMP_OUTPUT_TO_LOGFILE) {

        // validate    
        if (fd == NULL) {

            // attempt to open log file 
            fd = fopen("snmpdbg.log", "w");
        }

        // validate    
        if (fd != NULL) {

            // output entry to stream
            fprintf(fd, "%s", pLogEntry);

            // flush stream
            fflush(fd);
        }
    }

    // check if debugger output specified
    if (g_nLogType & SNMP_OUTPUT_TO_DEBUGGER) {

        // output entry to debugger
        OutputDebugStringA(pLogEntry);
    }

} 


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogLevel(
    INT nLogLevel
    )

/*++

Routine Description:

    Modifies the logging level of the SNMP process.

Arguments:

    nLogLevel - new logging level.

Return Values:

    None. 

--*/

{
    // update log level
    g_nLogLevel = nLogLevel; 
}


VOID 
SNMP_FUNC_TYPE
SnmpSvcSetLogType(
    INT nLogType
    )

/*++

Routine Description:

    Modifies the type of log used by the SNMP process.

Arguments:

    nLogType - type of log.

Return Values:

    None. 

--*/

{
    // update log type
    g_nLogType = nLogType;
}


VOID 
SNMP_FUNC_TYPE 
SnmpUtilDbgPrint(
    INT   nLogLevel, 
    LPSTR szFormat, 
    ...
    )

/*++

Routine Description:

    Prints debug message to current log types.

Arguments:

    nLogLevel - log level of message.

    szFormat - formatting string (see printf).

Return Values:

    None. 

--*/

{
    va_list arglist;

	// 640 octets should be enough to encode oid's of 128 sub-ids.
	// (one subid can be encoded on at most 5 octets; there can be at
	// 128 sub-ids per oid. MAX_LOG_ENTRY_LEN = 512
    char szLogEntry[4*MAX_LOG_ENTRY_LEN];

    // validate entry's level
    if (nLogLevel <= g_nLogLevel) {

        time_t now;

        // initialize variable args
        va_start(arglist, szFormat);

        time(&now);
        strftime(szLogEntry, MAX_LOG_ENTRY_LEN, "%H:%M:%S :", localtime(&now));

        // transfer variable args to buffer
        vsprintf(szLogEntry + strlen(szLogEntry), szFormat, arglist);

        // actually output entry
        OutputLogEntry(szLogEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\ipx.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ipx.c

Abstract:

    Contains routines to manipulate ipx addresses.

        SnmpSvcAddrToSocket

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <winsock.h>
#include <wsipx.h>


BOOL isHex(LPSTR str, int strLen)
    {
    int ii;

    for (ii=0; ii < strLen; ii++)
        if (isxdigit(*str))
            str++;
        else
            return FALSE;

    return TRUE;
    }

unsigned int toHex(unsigned char x)
    {
    if (x >= '0' && x <= '9')
        return x - '0';
    else if (x >= 'A' && x <= 'F')
        return x - 'A' + 10;
    else if (x >= 'a' && x <= 'f')
        return x - 'a' + 10;
    else
        return 0;
    }

// convert str to hex number of NumDigits (must be even) into pNum
void atohex(IN LPSTR str, IN int NumDigits, OUT unsigned char *pNum)
    {
    int i, j;

    j=0;
    for (i=0; i < (NumDigits>>1) ; i++)
        {
        pNum[i] = (toHex(str[j]) << 4) + toHex(str[j+1]);
        j+=2;
        }
    }

// return true if addrText is of the form 123456789ABC or
// 000001.123456789abc
// if pNetNum is not null, upon successful return, pNetNum = network number
// if pNodeNum is not null, upon successful return, pNodeNum = node number

BOOL 
SNMP_FUNC_TYPE 
SnmpSvcAddrIsIpx(
    IN  LPSTR addrText,
    OUT char pNetNum[4],
    OUT char pNodeNum[6])
    {
    int addrTextLen;

    addrTextLen = strlen(addrText);
    if (addrTextLen == 12 && isHex(addrText, 12))
        {
            if (pNetNum)
                *((UNALIGNED unsigned long *) pNetNum) = 0L;
            if (pNodeNum)
                atohex(addrText, 12, pNodeNum);
            return TRUE;
        }
    else if (addrTextLen == 21 && addrText[8] == '.' && isHex(addrText, 8) &&
            isHex(addrText+9, 12))
        {
            if (pNetNum)
                atohex(addrText, 8, pNetNum);
            if (pNodeNum)
                atohex(addrText+9, 12, pNodeNum);
            return TRUE;
        }
    else
        return FALSE;
    }

BOOL 
SNMP_FUNC_TYPE
SnmpSvcAddrToSocket(
    LPSTR addrText,
    struct sockaddr *addrEncoding
    )
{
    struct hostent * hp;
    struct sockaddr_in * pAddr_in = (struct sockaddr_in *)addrEncoding;
    struct sockaddr_ipx * pAddr_ipx = (struct sockaddr_ipx *)addrEncoding;
    unsigned long addr;

    // check for ipx addr
    if (SnmpSvcAddrIsIpx(
           addrText,
           pAddr_ipx->sa_netnum,
           pAddr_ipx->sa_nodenum
           )) {

        // see if ip host name which looks like ipx
        if ((hp = gethostbyname(addrText)) == NULL) {

            // host really is ipx machine
            pAddr_ipx->sa_family = AF_IPX;
            pAddr_ipx->sa_socket = htons(DEFAULT_SNMPTRAP_PORT_IPX);

            // address transferred above...

        } else {

            // host is really ip machine
            struct servent * pServEnt = NULL;

            // save value returned by gethostbyname before calling getservbyname
            pAddr_in->sin_family = AF_INET;
            pAddr_in->sin_addr.s_addr = *(unsigned long *)hp->h_addr;
            
            // attempt to get server information
            pServEnt = getservbyname("snmptrap","udp");
            
            pAddr_in->sin_port = (pServEnt != NULL)
                ? (SHORT)pServEnt->s_port
                : htons(DEFAULT_SNMPTRAP_PORT_UDP)
                ;
        }

    } else if (strncmp(addrText, "255.255.255.255", 15) == 0) {

        // host is a broadcast address
        struct servent * pServEnt = NULL;
        
        // attempt to get server information
        pServEnt = getservbyname("snmptrap","udp");

        pAddr_in->sin_family = AF_INET;
        pAddr_in->sin_port = (pServEnt != NULL)
            ? (SHORT)pServEnt->s_port
            : htons(DEFAULT_SNMPTRAP_PORT_UDP)
            ;
        pAddr_in->sin_addr.s_addr = 0xffffffff;

    } else if ((long)(addr = inet_addr(addrText)) != -1) {

        // host is ip machine
        struct servent * pServEnt = NULL;

        // attempt to get server information
        pServEnt = getservbyname("snmptrap","udp");
        
        pAddr_in->sin_family = AF_INET;
        pAddr_in->sin_port = (pServEnt != NULL)
                                ? (SHORT)pServEnt->s_port
                                : htons(DEFAULT_SNMPTRAP_PORT_UDP)
                                ;
        pAddr_in->sin_addr.s_addr = addr;

    } else if ((hp = gethostbyname(addrText)) != NULL) {

        // host is really ip machine
        struct servent * pServEnt = NULL;

        // BUG 507426
        // save value returned by gethostbyname before calling getservbyname
        pAddr_in->sin_family = AF_INET;
        pAddr_in->sin_addr.s_addr = *(unsigned long *)hp->h_addr;

        // attempt to get server information
        pServEnt = getservbyname("snmptrap","udp");
        
        pAddr_in->sin_port = (pServEnt != NULL)
                                ? (SHORT)pServEnt->s_port
                                : htons(DEFAULT_SNMPTRAP_PORT_UDP)
                                ;

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: could not convert %s to socket.\n",
            addrText
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\octets.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    octets.c

Abstract:

    Contains routines to manipulate octet strings.

        SnmpUtilOctetsCpy
        SnmpUtilOctetsFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCpy(
    AsnOctetString * pOctetsDst,
    AsnOctetString * pOctetsSrc
    )

/*++

Routine Description:

    Copy an octet string.

Arguments:

    pOctetsDst - pointer to structure to receive octets.

    pOctetsSrc - pointer to octets to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointers
    if (pOctetsDst != NULL) {
        
        // initialize
        pOctetsDst->stream  = NULL;
        pOctetsDst->length  = 0;
        pOctetsDst->dynamic = FALSE;

        // make sure there are bytes
        if ((pOctetsSrc != NULL) &&
            (pOctetsSrc->stream != NULL) &&
            (pOctetsSrc->length != 0)) {

            // attempt to allocate octet string
            pOctetsDst->stream = SnmpUtilMemAlloc(pOctetsSrc->length);
            
            // validate pointer
            if (pOctetsDst->stream != NULL) {

                // denote allocated type
                pOctetsDst->dynamic = TRUE;

                // transfer octet string length
                pOctetsDst->length = pOctetsSrc->length;

                // copy
                memcpy(pOctetsDst->stream,
                       pOctetsSrc->stream,
                       pOctetsSrc->length
                       );

                nResult = SNMPAPI_NOERROR; // success...

            } else {
            
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: could not allocate octet string.\n"
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
            }

        } else {

            // copying null string
            nResult = SNMPAPI_NOERROR;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null octet string pointer.\n"
            ));

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nResult;
}


VOID
SNMP_FUNC_TYPE
SnmpUtilOctetsFree(
    AsnOctetString * pOctets
    )

/*++

Routine Description:

    Releases memory for an octet string.

Arguments:

    pOctets - pointer to octets to release.

Return Values:

    None. 

--*/

{
    // validate pointers
    if ((pOctets != NULL) &&
        (pOctets->stream != NULL) && 
        (pOctets->dynamic == TRUE)) {

        // release memory for octets
        SnmpUtilMemFree(pOctets->stream);

        // re-initialize
        pOctets->dynamic = FALSE;
        pOctets->stream  = NULL;
        pOctets->length  = 0;
    }
}


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOctetsNCmp(
    AsnOctetString * pOctets1, 
    AsnOctetString * pOctets2,
    UINT             nChars
    )

/*++

Routine Description:

    Compares two octet strings up to a certain number of characters.

Arguments:

    pOctets1 - pointer to first octet string.

    pOctets2 - pointer to second octet string.

    nChars - maximum characters to compare.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    UINT i = 0;
    INT nResult = 0;

    // validate pointers
    if ((pOctets1 != NULL) &&
        (pOctets2 != NULL)) {

        // calculate maximum number of subidentifiers to compare
        UINT nMaxChars = min(nChars, min(pOctets1->length, pOctets2->length));

        // loop through the subidentifiers
        while((nResult == 0) && (i < nMaxChars)) {

            // compare each subidentifier
            nResult = pOctets1->stream[i] - pOctets2->stream[i];
            ++i;
        }

        // check for second being subset
        if ((nResult == 0) && (i < nChars)) {

            // determine order by length of oid
            nResult = pOctets1->length - pOctets2->length;
        }
    }
    
    return nResult;
} 


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOctetsCmp(
    AsnOctetString * pOctets1, 
    AsnOctetString * pOctets2
    )

/*++

Routine Description:

    Compares two octet strings.

Arguments:

    pOctets1 - pointer to first octet string.

    pOctets2 - pointer to second octet string.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    // forward request above
    return SnmpUtilOctetsNCmp(
                pOctets1,
                pOctets2,
                max(pOctets1->length,pOctets2->length)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\mem.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    Contains memory allocation routines.

        SnmpUtilMemAlloc
        SnmpUtilMemReAlloc
        SnmpUtilMemFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT g_nBytesTotal = 0;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
SnmpUtilMemFree(
    LPVOID pMem
    )

/*++

Routine Description:

    Releases memory used by SNMP entities.

Arguments:

    pMem - pointer to memory to release.

Return Values:

    None.

--*/

{
    // validate
    if (pMem != NULL) {

#if defined(DBG) && defined(_SNMPDLL_)

        // substract memory from global count
        g_nBytesTotal -= (UINT)GlobalSize((HGLOBAL)pMem);

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: MEM: releasing 0x%08lx (%d bytes, %d total).\n",
            pMem, GlobalSize((HGLOBAL)pMem), g_nBytesTotal
            ));

#endif

        // release memory
        GlobalFree((HGLOBAL)pMem);
    }
}


LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemAlloc(
    UINT nBytes
    )

/*++

Routine Description:

    Allocates memory used by SNMP entities.

Arguments:

    nBytes - number of bytes to allocate.

Return Values:

    Returns pointer to memory.

--*/

{
    LPVOID pMem;

    // attempt to allocate memory from process heap
    pMem = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, (DWORD)nBytes);

#if defined(DBG) && defined(_SNMPDLL_)

    // add allocated memory to global count if successful
    g_nBytesTotal += (UINT)((pMem != NULL) ? GlobalSize((HGLOBAL)pMem) : 0);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: MEM: allocated 0x%08lx (%d bytes, %d total).\n",
        pMem, (pMem != NULL) ? GlobalSize((HGLOBAL)pMem) : 0, g_nBytesTotal
        ));

#endif

    return pMem;
}


LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemReAlloc(
    LPVOID pMem,
    UINT   nBytes
    )

/*++

Routine Description:

    Reallocates memory used by SNMP entities.

Arguments:

    pMem - pointer to memory to reallocate.

    nBytes - number of bytes to allocate.

Return Values:

    Returns pointer to memory.

--*/

{
    LPVOID pNew;

    // validate
    if (pMem == NULL) {

        // forward to alloc routine
        pNew = SnmpUtilMemAlloc(nBytes);

    } else {

#if defined(DBG) && defined(_SNMPDLL_)

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: MEM: expanding 0x%08lx (%d bytes) to %d bytes.\n",
            pMem, GlobalSize((HGLOBAL)pMem), nBytes
            ));

        // substract current memory from total
        g_nBytesTotal -= (UINT)GlobalSize((HGLOBAL)pMem);

#endif

        // reallocate memory
        pNew = GlobalReAlloc(
                    (HGLOBAL)pMem,
                    (DWORD)nBytes,
                    GMEM_MOVEABLE |
                    GMEM_ZEROINIT
                    );

#if defined(DBG) && defined(_SNMPDLL_)

        // add new memory to total count
        g_nBytesTotal += (UINT)((pNew != NULL) ? GlobalSize((HGLOBAL)pNew) : 0);

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: MEM: allocated 0x%08lx (%d bytes, %d total).\n",
            pNew, (pNew != NULL) ? GlobalSize((HGLOBAL)pNew) : 0, g_nBytesTotal
            ));

#endif

    }

    return pNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\print.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Contains printing support.

        SnmpUtilPrintOid
        SnmpUtilPrintAsnAny

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include <stdio.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID 
SNMP_FUNC_TYPE 
SnmpUtilPrintOid(
    AsnObjectIdentifier * pOid 
    )

/*++

Routine Description:

    Outputs object identifier to the console.

Arguments:

    pOid - pointer to OID to display.

Return Values:

    None. 

--*/

{
    UINT i;

    // validate oid
    if ((pOid != NULL) &&
        (pOid->ids != NULL) &&
        (pOid->idLength != 0)) {

        // output first subidentifier
        fprintf(stdout, "%lu", pOid->ids[0]);

        // loop through subidentifiers
        for (i = 1; i < pOid->idLength; i++) {

            // output next subidentifier
            fprintf(stdout, ".%lu", pOid->ids[i]);
        }
    }
} 


VOID
SNMP_FUNC_TYPE 
SnmpUtilPrintAsnAny(
    AsnAny * pAsnAny
    )

/*++

Routine Description:

    Outputs variable value to the console.

Arguments:

    pAsnAny - pointer to value structure from variable binding.

Return Values:

    None. 

--*/


{
    // validate
    if (pAsnAny != NULL) {

        // determine type    
        switch (pAsnAny->asnType) {

        case ASN_INTEGER32:
        fprintf(stdout, "Integer32 %ld\n", pAsnAny->asnValue.number);
        break;

        case ASN_UNSIGNED32:
        fprintf(stdout, "Unsigned32 %lu\n", pAsnAny->asnValue.unsigned32);
        break;

        case ASN_COUNTER32:
        fprintf(stdout, "Counter32 %lu\n", pAsnAny->asnValue.counter);
        break;

        case ASN_GAUGE32:
        fprintf(stdout, "Gauge32 %lu\n", pAsnAny->asnValue.gauge);
        break;

        case ASN_TIMETICKS:
        fprintf(stdout, "TimeTicks %lu\n", pAsnAny->asnValue.ticks);
        break;

        case ASN_COUNTER64:
        fprintf(stdout, "Counter64 %I64u\n", pAsnAny->asnValue.counter64.QuadPart);
        break;

        case ASN_OBJECTIDENTIFIER:
        {
            UINT i;

            fprintf(stdout, "ObjectID ");

            // simply forward to helper function
            SnmpUtilPrintOid(&pAsnAny->asnValue.object);

            putchar('\n');
        }
        break;

        case ASN_OCTETSTRING:
        {
            UINT i;
            BOOL bDisplayString = TRUE;
            LPSTR StringFormat;

            // loop through string looking for non-printable characters
            for (i = 0; i < pAsnAny->asnValue.string.length && bDisplayString; i++ ) {
                bDisplayString = isprint(pAsnAny->asnValue.string.stream[i]);
            }
    
            // determine string format based on results
            StringFormat = bDisplayString ? "%c" : "<0x%02x>" ;

            fprintf(stdout, "String ");

            for (i = 0; i < pAsnAny->asnValue.string.length; i++) {
                fprintf(stdout, StringFormat, pAsnAny->asnValue.string.stream[i]);
            }

            putchar('\n');
        }
        break;

        case ASN_IPADDRESS:
        {
            UINT i;

            fprintf(stdout, "IpAddress " );
            if (pAsnAny->asnValue.string.stream && (pAsnAny->asnValue.string.length == 4))
            {
            
                fprintf(stdout, "%d.%d.%d.%d ",
                    pAsnAny->asnValue.string.stream[0] ,
                    pAsnAny->asnValue.string.stream[1] ,
                    pAsnAny->asnValue.string.stream[2] ,
                    pAsnAny->asnValue.string.stream[3] 
                );
            }
            else
            {
                fprintf(stdout, "Invalid" );
            }
            putchar('\n');
        }
        break;

        case ASN_OPAQUE:
        {
            UINT i;

            fprintf(stdout, "Opaque ");

            for (i = 0; i < pAsnAny->asnValue.string.length; i++) {
                fprintf(stdout, "0x%x ", pAsnAny->asnValue.string.stream[i]);
            }

            putchar('\n');
        }
        break;

        case ASN_BITS:
        {
            UINT i;

            fprintf(stdout, "Bits ");

            for (i = 0; i < pAsnAny->asnValue.string.length; i++) {
                fprintf(stdout, "0x%x ", pAsnAny->asnValue.string.stream[i]);
            }

            putchar('\n');
        }
        break;

        case ASN_NULL:
            fprintf(stdout, "Null value\n");
            break;

        case SNMP_EXCEPTION_NOSUCHOBJECT:
            fprintf(stdout, "NOSUCHOBJECT\n");
            break;

        case SNMP_EXCEPTION_NOSUCHINSTANCE:
            fprintf(stdout, "NOSUCHINSTANCE\n");
            break;

        case SNMP_EXCEPTION_ENDOFMIBVIEW:
            fprintf(stdout, "ENDOFMIBVIEW\n");
            break;

        default:
            fprintf(stdout, "Invalid type %d\n", pAsnAny->asnType);
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\snmpapi.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpapi.c

Abstract:

    Contains entry point for SNMPAPI.DLL.

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include "ntfuncs.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD g_dwPlatformId = 0;
AsnObjectIdentifier * g_pEnterpriseOid = NULL;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Variables                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT idsWindowsNTWorkstation[] = {1,3,6,1,4,1,311,1,1,3,1,1};
static UINT idsWindowsNTServer[]      = {1,3,6,1,4,1,311,1,1,3,1,2};
static UINT idsWindowsNTDC[]          = {1,3,6,1,4,1,311,1,1,3,1,3};
static UINT idsWindows[]              = {1,3,6,1,4,1,311,1,1,3,2};

static AsnObjectIdentifier oidWindowsNTWorkstation = { 
    sizeof(idsWindowsNTWorkstation)/sizeof(UINT), 
    idsWindowsNTWorkstation 
    };

static AsnObjectIdentifier oidWindowsNTServer = { 
    sizeof(idsWindowsNTServer)/sizeof(UINT), 
    idsWindowsNTServer 
    };

static AsnObjectIdentifier oidWindowsNTDC = { 
    sizeof(idsWindowsNTDC)/sizeof(UINT), 
    idsWindowsNTDC 
    };

static AsnObjectIdentifier oidWindows = { 
    sizeof(idsWindows)/sizeof(UINT), 
    idsWindows 
    };


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
InitializeEnterpriseOID(
    )

/*++

Routine Description:

    Determines the default enterprise object identifier.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

{
    NT_PRODUCT_TYPE NtProductType;

    // default to generic oid
    g_pEnterpriseOid = &oidWindows;

    // check to see if the platform is winnt
    if (g_dwPlatformId == VER_PLATFORM_WIN32_NT) {

        // assume this is just a workstation        
        g_pEnterpriseOid = &oidWindowsNTWorkstation;

      
            
        // let the system determine product type
        RtlGetNtProductType(&NtProductType);

        // point to the correct enterprise oid
        if (NtProductType == NtProductServer) {

            // this is a stand-alone server
            g_pEnterpriseOid = &oidWindowsNTServer;

        } else if (NtProductType == NtProductLanManNt) {

            // this is a PDC or a BDC
            g_pEnterpriseOid = &oidWindowsNTDC;
        }
        
    }

    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: INIT: enterprise is %s.\n", 
        SnmpUtilOidToA(g_pEnterpriseOid)
        ));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
InitializeDLL(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

    Same as DllMain.

Return Values:

    Returns true if successful. 

--*/

{
    // check if new process attaching
    if (Reason == DLL_PROCESS_ATTACH) { 

        OSVERSIONINFO osInfo;    

        // initialize os info structure
        osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        // gather os info
        GetVersionEx(&osInfo);

        // save platform id for later use
        g_dwPlatformId = osInfo.dwPlatformId;

        // initialize enterprise
        InitializeEnterpriseOID();

        // turn off thread attach messages
        DisableThreadLibraryCalls(DllHandle);

    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\ntfuncs.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ntfuncs.h

Abstract:

    Contains definitions for dynamically loaded NTDLL functions.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_NTFUNCS
#define _INC_NTFUNCS

typedef NTSYSAPI NTSTATUS 
(NTAPI * PFNNTQUERYSYSTEMINFORMATION)(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSYSAPI LARGE_INTEGER 
(NTAPI * PFNRTLEXTENDEDLARGEINTEGERDIVIDE)(
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

typedef NTSYSAPI BOOLEAN
(NTAPI * PFNRTLGETNTPRODUCTTYPE)(
    PNT_PRODUCT_TYPE    NtProductType
    );

#endif // _INC_NTFUNCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\snmptfx.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    snmptfx.c

Abstract:

    Provides common varbind resolution functionality for subagents.

Environment:

    User Mode - Win32

Revision History:

    02-Oct-1996 DonRyan
        Moved from extensible agent in anticipation of SNMPv2 SPI.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>     
#include <ntrtl.h>
#include <nturtl.h>   // using ntrtl's ASSERT
#include <snmp.h>
#include <snmputil.h>
#include <snmpexts.h>
#include <winsock.h>

#define HASH_TABLE_SIZE     101
#define HASH_TABLE_RADIX    18

#define INVALID_INDEX       ((DWORD)(-1))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private type definitions                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SnmpVarBindXlat {

    UINT                   vlIndex;  // index into view list
    UINT                   vblIndex; // index into varbind list
    SnmpMibEntry *         mibEntry; // pointer to mib information
    struct _SnmpExtQuery * extQuery; // pointer to followup query
    

} SnmpVarBindXlat;

typedef struct _SnmpGenericList {

    VOID * data; // context-specific pointer
    UINT   len;  // context-specific length

} SnmpGenericList;

typedef struct _SnmpTableXlat {

    AsnObjectIdentifier txOid;   // table index oid
    SnmpMibTable *      txInfo;  // table description
    UINT                txIndex; // index into table list

} SnmpTableXlat;

typedef struct _SnmpExtQuery {

    UINT              mibAction; // type of query
    UINT              viewType;  // type of view
    UINT              vblNum;    // number of varbinds
    SnmpVarBindXlat * vblXlat;   // info to reorder varbinds
    SnmpTableXlat *   tblXlat;   // info to parse table oids
    SnmpGenericList   extData;   // context-specific buffer
    FARPROC           extFunc;   // instrumentation callback

} SnmpExtQuery;

#define INVALID_QUERY ((SnmpExtQuery*)(-1))

typedef struct _SnmpExtQueryList {

    SnmpExtQuery * query;  // list of subagent queries
    UINT           len;    // number of queries in list
    UINT           action; // original query request

} SnmpExtQueryList;

typedef struct _SnmpHashNode {

    SnmpMibEntry *         mibEntry;
    struct _SnmpHashNode * nextEntry;

} SnmpHashNode;

typedef struct _SnmpTfxView {

    SnmpMibView  *  mibView;
    SnmpHashNode ** hashTable;

} SnmpTfxView;

typedef struct _SnmpTfxInfo {

    UINT          numViews;
    SnmpTfxView * tfxViews;

} SnmpTfxInfo;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
ValidateQueryList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    UINT                 q,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
OidToHashTableIndex(
    AsnObjectIdentifier * hashOid
    )

/*++

Routine Description:

    Hash function for mib entry access.

Arguments:

    hashOid - object identifer to hash into table position.

Return Values:

    Returns hash table position.

--*/

{
    UINT i;
    UINT j;

    // process each element of the oid
    for (i=0, j=0; i < hashOid->idLength; i++) {

        // determine table position by summing oid
        j = (j * HASH_TABLE_RADIX) + hashOid->ids[i];
    }

    // adjust to within table
    return (j % HASH_TABLE_SIZE);
}


VOID
FreeHashTable(
    SnmpHashNode ** hashTable
    )

/*++

Routine Description:

    Destroys hash table used for accessing views.

Arguments:

    hashTable - table of hash nodes.

Return Values:

    None.

--*/

{
    UINT i;

    SnmpHashNode * nextNode;
    SnmpHashNode * hashNode;

    if (hashTable == NULL) {
        return;
    }

    // free hash table and nodes
    for (i=0; i < HASH_TABLE_SIZE; i++) {

        // point to first item
        hashNode = hashTable[i];

        // find end of node list
        while (hashNode) {

            // save pointer to next node
            nextNode = hashNode->nextEntry;

            // free current node
            SnmpUtilMemFree(hashNode);

            // retrieve next
            hashNode = nextNode;
        }
    }

    // release table itself
    SnmpUtilMemFree(hashTable);
}


SnmpHashNode **
AllocHashTable(
    SnmpMibView * mibView
    )

/*++

Routine Description:

    Initializes view hash table.

Arguments:

    mibView - mib view information.

Return Values:

    Returns pointer to first entry if successful.

--*/

{
    UINT i;
    UINT j;

    UINT numItems;
    BOOL fInitedOk;

    SnmpMibEntry *  mibEntry;
    SnmpHashNode *  hashNode;
    SnmpHashNode ** hashTable = NULL;

    // validate parameter
    if (mibView == NULL) {
        return NULL;
    }

    // determine how many items in view
    numItems = mibView->viewScalars.len;

    // load the first entry in the view
    mibEntry = mibView->viewScalars.list;

    // allocate hash table using predefined size
    hashTable = (SnmpHashNode **)SnmpUtilMemAlloc(
                                    HASH_TABLE_SIZE * sizeof(SnmpHashNode *)
                                    );

    // make sure table is allocated
    fInitedOk = (hashTable != NULL);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: initializing hash table 0x%08lx (%d items).\n",
        hashTable,
        numItems
        ));

    // process each item in the subagent's supported view
    for (i = 0; (i < numItems) && fInitedOk; i++, mibEntry++) {

        // hash into table index
        j = OidToHashTableIndex(&mibEntry->mibOid);

        // check if table entry taken
        if (hashTable[j] == NULL) {

            // allocate new node
            hashNode = (SnmpHashNode *)SnmpUtilMemAlloc(
                            sizeof(SnmpHashNode)
                            );

            // save hash node
            hashTable[j] = hashNode;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: adding hash node 0x%08lx to empty slot %d (0x%08lx).\n",
                hashNode, j, mibEntry
                ));

        } else {

            // point to first item
            hashNode = hashTable[j];

            // find end of node list
            while (hashNode->nextEntry) {
                hashNode = hashNode->nextEntry;
            }

            // allocate new node entry
            hashNode->nextEntry = (SnmpHashNode *)SnmpUtilMemAlloc(
                                        sizeof(SnmpHashNode)
                                        );

            // re-init node to edit below
            hashNode = hashNode->nextEntry;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: adding hash node 0x%08lx to full slot %d (0x%08lx).\n",
                hashNode, j, mibEntry
                ));
        }

        // make sure allocation succeeded
        fInitedOk = (hashNode != NULL);

        if (fInitedOk) {

            // fill in node values
            hashNode->mibEntry = mibEntry;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: %s initialized hash table 0x%08lx.\n",
        fInitedOk ? "successfully" : "unsuccessfully",
        hashTable
        ));

    if (!fInitedOk) {

        // free view hash table
        FreeHashTable(hashTable);

        // reinitialize
        hashTable = NULL;
    }

    return hashTable;
}


VOID
OidToMibEntry(
    AsnObjectIdentifier * hashOid,
    SnmpHashNode **       hashTable,
    SnmpMibEntry **       mibEntry
    )

/*++

Routine Description:

    Returns mib entry associated with given object identifier.

Arguments:

    hashOid   - oid to convert to table index.
    hashTable - table to look up entry.
    mibEntry  - pointer to mib entry information.

Return Values:

    None.

--*/

{
    UINT i;
    SnmpHashNode * hashNode;
    AsnObjectIdentifier newOid;

    // create index
    i = OidToHashTableIndex(hashOid);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: searching hash table 0x%08lx slot %d for %s.\n",
        hashTable, i, SnmpUtilOidToA(hashOid)
        ));

    // retrieve node
    hashNode = hashTable[i];

    // initialize
    *mibEntry = NULL;

    // search list
    while (hashNode) {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: searching hash node 0x%08lx (mibe=0x%08lx) - %s.\n",
            hashNode, hashNode->mibEntry,
            SnmpUtilOidToA(&hashNode->mibEntry->mibOid)
            ));

        // retrieve mib identifier
        newOid = hashNode->mibEntry->mibOid;

        // make sure that the oid matches
        if (!SnmpUtilOidCmp(&newOid, hashOid)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: returning mib entry 0x%08lx.\n",
                hashNode->mibEntry
                ));

            // return node data
            *mibEntry = hashNode->mibEntry;
            return;

        }

        // check next node
        hashNode = hashNode->nextEntry;
    }
}


int
ValidateInstanceIdentifier(
    AsnObjectIdentifier * indexOid,
    SnmpMibTable *        tableInfo
    )

/*++

Routine Description:

    Validates that oid can be successfully parsed into index entries.

Arguments:

    indexOid  - object indentifier of potential index.
    tableInfo - information describing conceptual table.

Return Values:

    Returns the comparision between the length of the indexOid
    and the cumulated lengths of all the indices of the table tableInfo.
    {-1, 0, 1}

--*/

{
    UINT i = 0;
    UINT j = 0;

    int nComp;

    BOOL fFixed;
    BOOL fLimit;
    BOOL fIndex;

    SnmpMibEntry * mibEntry;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: validating index %s via table 0x%08lx.\n",
        SnmpUtilOidToA(indexOid), tableInfo
        ));

    // see if the table indices are specified
    fIndex = (tableInfo->tableIndices != NULL);

    // scan mib entries of table indices ensuring match of given oid
    for (i = 0; (i < tableInfo->numIndices) && (j < indexOid->idLength); i++) {

        // get mib entry from table or directly
        mibEntry = fIndex ?  tableInfo->tableIndices[i]
                          : &tableInfo->tableEntry[i+1]
                          ;

        // determine type
        switch (mibEntry->mibType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:
        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // increment fixed length
                j += mibEntry->mibMaximum;

            } else if (fLimit) {

                // check whether the length of the variable is valid
                if (((INT)indexOid->ids[j] >= mibEntry->mibMinimum) &&
                    ((INT)indexOid->ids[j] <= mibEntry->mibMaximum)) {

                    // increment given length
                    j += (indexOid->ids[j] + 1);

                } else {

                    // invalidate
                    j = INVALID_INDEX;
                }

            } else {

                // increment given length
                j += (indexOid->ids[j] + 1);
            }

            break;

        // implicit fixed size
        case ASN_RFC1155_IPADDRESS:
            // increment
            j += 4;
            break;

        case ASN_RFC1155_COUNTER:
        case ASN_RFC1155_GAUGE:
        case ASN_RFC1155_TIMETICKS:
        case ASN_INTEGER:
            // increment
            j++;
            break;

        default:
            // invalidate
            j = INVALID_INDEX;
            break;
        }
    }

    if (i<tableInfo->numIndices)
        nComp = -1;
    else if (j < indexOid->idLength)
        nComp = 1;
    else if (j > indexOid->idLength)
        nComp = -1;
    else
        nComp = 0;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: ValidateInstanceIdentifier; OID %s %s table indices.\n",
        SnmpUtilOidToA(indexOid),
        nComp > 0 ? "over-covers" : nComp < 0 ? "shorter than" : "matches"
        ));

    return nComp;
}


VOID
ValidateAsnAny(
    AsnAny *       asnAny,
    SnmpMibEntry * mibEntry,
    UINT           mibAction,
    UINT *         errorStatus
    )

/*++

Routine Description:

    Validates asn value with given mib entry.

Arguments:

    asnAny      - value to set.
    mibEntry    - mib information.
    mibAction   - mib action to be taken.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    BOOL fLimit;
    BOOL fFixed;

    INT asnLen;

    BOOL fOk = TRUE;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: validating value for %s request using entry 0x%08lx.\n",
        (mibAction == MIB_ACTION_SET) ? "write" : "read", mibEntry
        ));

    // validating gets is trivial
    if (mibAction != MIB_ACTION_SET) {

        // validate instrumentation info
        if ((mibEntry->mibGetBufLen == 0) ||
            (mibEntry->mibGetFunc == NULL) ||
           !(mibEntry->mibAccess & MIB_ACCESS_READ)) {

            // variable is not available for reading
            *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: entry 0x%08lx not read-enabled.\n",
                mibEntry
                ));

            return; // bail...
        }

    } else {

        // validate instrumentation info
        if ((mibEntry->mibSetBufLen == 0) ||
            (mibEntry->mibSetFunc == NULL) ||
           !(mibEntry->mibAccess & MIB_ACCESS_WRITE)) {

            // variable is not avaiLable for writing
            *errorStatus = SNMP_ERRORSTATUS_NOTWRITABLE;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: entry 0x%08lx not write-enabled.\n",
                mibEntry
                ));

            return; // bail...
        }

        if (mibEntry->mibType != asnAny->asnType)
        {
            *errorStatus = SNMP_ERRORSTATUS_BADVALUE;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: entry 0x%08lx doesn't match the asnType",
                mibEntry));

            return; // bail...
        }

        // check whether this is a fixed length variable or not
        fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
        fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

        // determine value type
        switch (asnAny->asnType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:

            // retrieve the objects id length
            asnLen = asnAny->asnValue.object.idLength;

            // fixed?
            if (fFixed) {

                // make sure the length is correct
                fOk = (asnLen == mibEntry->mibMaximum);

            } else if (fLimit) {

                // make sure the length is correct
                fOk = ((asnLen >= mibEntry->mibMinimum) &&
                       (asnLen <= mibEntry->mibMaximum));
            }

            break;

        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // retrieve the arbitrary length
            asnLen = asnAny->asnValue.string.length;

            // fixed?
            if (fFixed) {

                // make sure the length is correct
                fOk = (asnLen == mibEntry->mibMaximum);

            } else if (fLimit) {

                // make sure the length is correct
                fOk = ((asnLen >= mibEntry->mibMinimum) &&
                       (asnLen <= mibEntry->mibMaximum));
            }

            break;

        case ASN_RFC1155_IPADDRESS:

            // make sure the length is correct
            fOk = (asnAny->asnValue.address.length == 4);
            break;

        case ASN_INTEGER:

            // limited?
            if (fLimit) {

                // make sure the value in range
                fOk = ((asnAny->asnValue.number >= mibEntry->mibMinimum) &&
                       (asnAny->asnValue.number <= mibEntry->mibMaximum));
            }

            break;

        default:
            // error...
            fOk = FALSE;
            break;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: value is %s using entry 0x%08lx.\n",
        fOk ? "valid" : "invalid", mibEntry
        ));

    // report results
    *errorStatus = fOk
                    ? SNMP_ERRORSTATUS_NOERROR
                    : SNMP_ERRORSTATUS_BADVALUE
                    ;
}


VOID
FindMibEntry(
    SnmpTfxInfo *    tfxInfo,
    RFC1157VarBind * vb,
    SnmpMibEntry **  mibEntry,
    UINT *           mibAction,
    SnmpTableXlat ** tblXlat,
    UINT             vlIndex,
    UINT *           errorStatus
    )

/*++

Routine Description:

    Locates mib entry associated with given varbind.

Arguments:

    tfxInfo     - context info.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;

    UINT newIndex;
    UINT numItems;
    UINT numTables;

    BOOL fFoundOk;
    int  indexComp;

    AsnObjectIdentifier hashOid;
    AsnObjectIdentifier indexOid;
    AsnObjectIdentifier * viewOid;

    SnmpMibTable  * viewTables;
    SnmpTfxView   * tfxView;

    SnmpMibEntry  * newEntry = NULL;
    SnmpTableXlat * newXlat  = NULL;

    // initialize
    *mibEntry = NULL;
    *tblXlat  = NULL;

    // retrieve view information
    tfxView = &tfxInfo->tfxViews[vlIndex];

    // retrieve view object identifier
    viewOid = &tfxView->mibView->viewOid;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: FindMibEntry; comp(%s, ",
        SnmpUtilOidToA(&vb->name)
        ));

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "%s).\n",
        SnmpUtilOidToA(viewOid)
        ));

    // if the prefix exactly matchs it is root oid
    if (!SnmpUtilOidCmp(&vb->name, viewOid)) {
        SNMPDBG((SNMP_LOG_VERBOSE, "SNMP: TFX: requested oid is root.\n"));
        *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
        return;
    }

    // if the prefix does not match it is not in hash table
    if (SnmpUtilOidNCmp(&vb->name, viewOid, viewOid->idLength)) {
        SNMPDBG((SNMP_LOG_TRACE, "SNMP: TFX: requested oid not in view.\n"));
        *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
        return;
    }

    // construct new oid sans root prefix
    hashOid.ids = &vb->name.ids[viewOid->idLength];
    hashOid.idLength = vb->name.idLength - viewOid->idLength;

    // retrieve mib entry and index via hash table
    OidToMibEntry(&hashOid, tfxView->hashTable, &newEntry);

    // check if mib entry found
    fFoundOk = (newEntry != NULL);

    // try mib tables
    if (!fFoundOk) {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: searching mib tables for %s.\n",
            SnmpUtilOidToA(&hashOid)
            ));

        // retrieve mib table information
        numTables  = tfxView->mibView->viewTables.len;
        viewTables = tfxView->mibView->viewTables.list;

        // scan mib tables for a match to the given oid
        for (i=0; (i < numTables) && !fFoundOk; i++, viewTables++) {

            // retrieve entry for table entry
            numItems = viewTables->numColumns;
            newEntry = viewTables->tableEntry;

            if (!SnmpUtilOidNCmp(
                    &hashOid,
                    &newEntry->mibOid,
                    newEntry->mibOid.idLength)) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: TFX: searching table 0x%08lx (%s).\n",
                    newEntry, SnmpUtilOidToA(&newEntry->mibOid)
                    ));

                // next
                ++newEntry;

                // scan mib table entries for a match
                for (j=0; j < numItems; j++, newEntry++) {

                    // compare with oid of table entry
                    if (!SnmpUtilOidNCmp(
                            &hashOid,
                            &newEntry->mibOid,
                            newEntry->mibOid.idLength)) {

                        SNMPDBG((
                            SNMP_LOG_VERBOSE,
                            "SNMP: TFX: validating mib entry 0x%08lx (%s).\n",
                            newEntry, SnmpUtilOidToA(&newEntry->mibOid)
                            ));

                        // construct new oid sans table entry prefix
                        indexOid.ids =
                            &hashOid.ids[newEntry->mibOid.idLength];
                        indexOid.idLength =
                            hashOid.idLength - newEntry->mibOid.idLength;

                        // verify rest of oid is valid index
                        indexComp = ValidateInstanceIdentifier(
                                        &indexOid,
                                        viewTables
                                        );
                        fFoundOk = (indexComp < 0 && *mibAction == MIB_ACTION_GETNEXT) ||
                                   (indexComp == 0);

                        // is index?
                        if (fFoundOk) {

                            SNMPDBG((
                                SNMP_LOG_VERBOSE,
                                "SNMP: TFX: saving index oid %s.\n",
                                SnmpUtilOidToA(&indexOid)
                                ));

                            // alloc a table traslation entry only if the object is accessible
                            if (newEntry->mibAccess != MIB_ACCESS_NONE)
                            {
                                // allocate table translation structure
                                newXlat = (SnmpTableXlat *)SnmpUtilMemAlloc(
                                                sizeof(SnmpTableXlat)
                                                );
                                // Prefix bug # 445169
                                if (newXlat != NULL)
                                {
                                    // copy index object identifier
                                    if (! SnmpUtilOidCpy(&newXlat->txOid, &indexOid))
                                    {
                                        // report memory allocation problem
                                        SNMPDBG((
                                            SNMP_LOG_ERROR,
                                            "SNMP: TFX: SnmpUtilOidCpy at line %d failed.\n",
                                            __LINE__));

                                        // free previous allocated memory
                                        SnmpUtilMemFree(newXlat);
                                        *errorStatus = SNMP_ERRORSTATUS_GENERR;
                                        return; // bail...
                                    }

                                    // save table information
                                    newXlat->txInfo  = viewTables;
                                    newXlat->txIndex = i;
                                }       
                                else
                                {
                                    // report memory allocation problem
                                    SNMPDBG((
                                        SNMP_LOG_ERROR,
                                        "SNMP: TFX: unable to allocate memory.\n"
                                        ));
                                    *errorStatus = SNMP_ERRORSTATUS_GENERR;
                                    return; // bail...
                                }
                            }

                            break; // finished...
                        }
                    }
                }
            }
        }

    } else {

        UINT newOff;

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: searching mib tables for %s.\n",
            SnmpUtilOidToA(&hashOid)
            ));

        // retrieve mib table information
        numTables  = tfxView->mibView->viewTables.len;
        viewTables = tfxView->mibView->viewTables.list;

        // scan mib tables for an entry in table
        for (i=0; i < numTables; i++, viewTables++) {

            // columns are positioned after entry
            if (newEntry > viewTables->tableEntry) {

                // calculate the difference between pointers
                newOff = (UINT)((ULONG_PTR)newEntry - (ULONG_PTR)viewTables->tableEntry);

                // calculate table offset
                newOff /= sizeof(SnmpMibEntry);

                // determine if entry within region
                if (newOff <= viewTables->numColumns &&
                    newEntry->mibAccess != MIB_ACCESS_NONE) {

                    // allocate table translation structure
                    newXlat = (SnmpTableXlat *)SnmpUtilMemAlloc(
                                    sizeof(SnmpTableXlat)
                                    );
                    // Prefix bug # 445169
                    if (newXlat != NULL)
                    {
                        // save table information
                        newXlat->txInfo  = viewTables;
                        newXlat->txIndex = i;

                        // initialize index oid
                        newXlat->txOid.ids = NULL;
                        newXlat->txOid.idLength = 0;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: TFX: mib entry is in table 0x%08lx (%s).\n",
                            viewTables->tableEntry,
                            SnmpUtilOidToA(&viewTables->tableEntry->mibOid)
                            ));

                        break; // finished...
                    }
                    else
                    {
                        // report memory allocation problem
                        SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: TFX: unable to allocate memory.\n"
                                ));
                        *errorStatus = SNMP_ERRORSTATUS_GENERR;
                        return; // bail...
                    }
                }
            }
        }
    }

    // found entry?
    if (fFoundOk) {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: FindMibEntry; found %s\n",
            SnmpUtilOidToA(&newEntry->mibOid)
            ));
        // pass back results
        *mibEntry = newEntry;
        *tblXlat  = newXlat;

    } else {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: unable to exactly match varbind.\n"
            ));

        // unable to locate varbind in mib table
        *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
    }
}


VOID
FindNextMibEntry(
    SnmpTfxInfo *     tfxInfo,
    RFC1157VarBind *  vb,
    SnmpMibEntry **   mibEntry,
    UINT *            mibAction,
    SnmpTableXlat **  tblXlat,
    UINT              vlIndex,
    UINT *            errorStatus
    )

/*++

Routine Description:

    Locates next mib entry associated with given varbind.

Arguments:

    tfxInfo     - context info.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    UINT mibStatus;

    SnmpMibEntry  * newEntry = NULL;
    SnmpTableXlat * newXlat  = NULL;

    SnmpTfxView * tfxView;

    // table?
    if (*tblXlat) {
        SNMPDBG((SNMP_LOG_VERBOSE, "SNMP: TFX: querying table.\n"));
        return; // simply query table...
    }

    // retrieve view information
    tfxView = &tfxInfo->tfxViews[vlIndex];

    // retrieve entry
    newEntry = *mibEntry;

    // initialize
    *mibEntry = NULL;
    *tblXlat  = NULL;

    // continuing?
    if (newEntry) {
        // next
        ++newEntry;
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: searching mib at next entry 0x%08lx (%s).\n",
            newEntry,
            SnmpUtilOidToA(&newEntry->mibOid)
            ));
    } else {
        // retrieve first mib entry in supported view
        newEntry = tfxView->mibView->viewScalars.list;
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: searching mib at first entry 0x%08lx.\n",
            newEntry
            ));
    }

    // initialize status to start search
    mibStatus = SNMP_ERRORSTATUS_NOSUCHNAME;

    // scan
   for (;; newEntry++) {

       SNMPDBG((
           SNMP_LOG_VERBOSE,
           "SNMP: TFX: FindNextMibEntry; scanning view %s ",
           SnmpUtilOidToA(&tfxView->mibView->viewOid)
           ));

       SNMPDBG((
           SNMP_LOG_VERBOSE,
           " scalar %s.\n",
           SnmpUtilOidToA(&newEntry->mibOid)
           ));

        // if last entry then we stop looking
        if (newEntry->mibType == ASN_PRIVATE_EOM) {

            SNMPDBG((SNMP_LOG_TRACE, "SNMP: TFX: encountered end of mib.\n"));

            *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
            return; // bail...
        }

        // skip over place holder mib entries
        if (newEntry->mibType != ASN_PRIVATE_NODE) {

            // validate asn value against info in mib entry
            ValidateAsnAny(&vb->value, newEntry, *mibAction, &mibStatus);

            // bail if we found a valid entry...
            if (mibStatus == SNMP_ERRORSTATUS_NOERROR) {
                break;
            }
        }
    }

    // retrieved an entry but is it in a table?
    if (mibStatus == SNMP_ERRORSTATUS_NOERROR) {

        UINT i;
        UINT newOff;
        UINT numTables;

        SnmpMibTable * viewTables;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: mib entry 0x%08lx found (%s).\n",
            newEntry, SnmpUtilOidToA(&newEntry->mibOid)
            ));

        // retrieve table information from view
        numTables  = tfxView->mibView->viewTables.len;
        viewTables = tfxView->mibView->viewTables.list;

        // scan mib tables for an entry in table
        for (i=0; i < numTables; i++, viewTables++) {

            // columns are positioned after entry
            if (newEntry > viewTables->tableEntry) {

                // calculate the difference between pointers
                newOff = (UINT)((ULONG_PTR)newEntry - (ULONG_PTR)viewTables->tableEntry);

                // calculate table offset
                newOff /= sizeof(SnmpMibEntry);

                // determine if entry within region
                if (newOff <= viewTables->numColumns) {

                    // allocate table translation structure
                    newXlat = (SnmpTableXlat *)SnmpUtilMemAlloc(
                                    sizeof(SnmpTableXlat)
                                    );
                    
                    // Prefix bug # 445169
                    if (newXlat != NULL)
                    {
                        // save table information
                        newXlat->txInfo  = viewTables;
                        newXlat->txIndex = i;

                        // initialize index oid
                        newXlat->txOid.ids = NULL;
                        newXlat->txOid.idLength = 0;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: TFX: mib entry is in table 0x%08lx (%s).\n",
                            viewTables->tableEntry,
                            SnmpUtilOidToA(&viewTables->tableEntry->mibOid)
                            ));

                        break; // finished...
                    }
                    else
                    {
                        // report memory allocation problem
                        SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: TFX: unable to allocate memory.\n"
                                ));
                        
                        *errorStatus = SNMP_ERRORSTATUS_GENERR;
                        return; // bail...
                    }
                }
            }
        }

        // pass back results
        *mibEntry  = newEntry;
        *tblXlat   = newXlat;

        // update mib action of scalar getnext
        if (!newXlat && (*mibAction == MIB_ACTION_GETNEXT)) {

            *mibAction = MIB_ACTION_GET;

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: altered mib action to MIB_ACTION_GET.\n"
                ));
        }
    }

    // pass back status
    *errorStatus = mibStatus;
}


VOID
FindAnyMibEntry(
    SnmpTfxInfo *     tfxInfo,
    RFC1157VarBind *  vb,
    SnmpMibEntry **   mibEntry,
    UINT *            mibAction,
    SnmpTableXlat **  tblXlat,
    UINT              vlIndex,
    UINT *            errorStatus
    )

/*++

Routine Description:

    Locates any mib entry associated with given varbind.

Arguments:

    tfxInfo     - context info.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    BOOL fExact;
    BOOL fBefore;

    SnmpTfxView * tfxView;

    // retrieve view information
    tfxView = &tfxInfo->tfxViews[vlIndex];

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: FindAnyMibEntry; comp(%s, ",
        SnmpUtilOidToA(&vb->name)
        ));
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "%s[, %d]).\n",
        SnmpUtilOidToA(&tfxView->mibView->viewOid),
        tfxView->mibView->viewOid.idLength
        ));

    // look for oid before view
    fBefore = (0 > SnmpUtilOidNCmp(
                         &vb->name,
                         &tfxView->mibView->viewOid,
                         tfxView->mibView->viewOid.idLength
                         ));

    // look for exact match
    fExact = !fBefore && !SnmpUtilOidCmp(
                            &vb->name,
                            &tfxView->mibView->viewOid
                            );

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: fBefore=%d fExact=%d\n",
        fBefore,
        fExact
        ));
    // check for random oid...
    if (!fBefore && !fExact) {

        AsnObjectIdentifier relOid;
        AsnObjectIdentifier * viewOid;
        SnmpMibEntry * newEntry = NULL;

        // point to the first item in the list
        newEntry = tfxView->mibView->viewScalars.list;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: linear search from first entry 0x%08lx.\n",
            newEntry
            ));

        // retrieve the view object identifier
        viewOid = &tfxView->mibView->viewOid;

        // construct new oid sans root prefix
        relOid.ids = &vb->name.ids[viewOid->idLength];
        relOid.idLength = vb->name.idLength - viewOid->idLength;

        // scan mib entries
        while ((newEntry->mibType != ASN_PRIVATE_EOM) &&
               (SnmpUtilOidCmp(&relOid, &newEntry->mibOid) > 0)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: skipping %s.\n",
                SnmpUtilOidToA(&newEntry->mibOid)
                ));

            // next
            newEntry++;
        }

        // if last entry then we stop looking
        if (newEntry->mibType == ASN_PRIVATE_EOM) {

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: encountered end of mib.\n"
                ));

            *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
            return; // bail...
        }

        // backup to find next
        *mibEntry = --newEntry;
        *tblXlat  = NULL;

        // find next
        FindNextMibEntry(
               tfxInfo,
               vb,
               mibEntry,
               mibAction,
               tblXlat,
               vlIndex,
               errorStatus
               );

    } else {

        // initialize
        *mibEntry = NULL;
        *tblXlat  = NULL;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: searching for first entry.\n"
            ));

        // find next
        FindNextMibEntry(
               tfxInfo,
               vb,
               mibEntry,
               mibAction,
               tblXlat,
               vlIndex,
               errorStatus
               );
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: FindAnyMibEntry; error %d on %s(.",
            *errorStatus,
            SnmpUtilOidToA(&tfxInfo->tfxViews[vlIndex].mibView->viewOid)
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "%s).\n",
            SnmpUtilOidToA(&(*mibEntry)->mibOid)
            ));
    }
}


VOID
VarBindToMibEntry(
    SnmpTfxInfo *    tfxInfo,
    RFC1157VarBind * vb,
    SnmpMibEntry **  mibEntry,
    UINT *           mibAction,
    SnmpTableXlat ** tblXlat,
    UINT             vlIndex,
    UINT *           errorStatus
    )

/*++

Routine Description:

    Locates mib entry associated with given varbind.

Arguments:

    tfxInfo     - context information.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    BOOL fAnyOk;
    BOOL fFoundOk;
    BOOL fErrorOk;

    // determine whether we need exact match
    fAnyOk = (*mibAction == MIB_ACTION_GETNEXT);

    // find match
    FindMibEntry(
        tfxInfo,
        vb,
        mibEntry,
        mibAction,
        tblXlat,
        vlIndex,
        errorStatus
        );
    
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: VarBindToMibEntry; errorStatus=%d.\n",
        *errorStatus
        ));

    // get next?
    if (fAnyOk) {

        // search again
        if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

            // find next entry
            FindNextMibEntry(
                tfxInfo,
                vb,
                mibEntry,
                mibAction,
                tblXlat,
                vlIndex,
                errorStatus
                );

        } else if (*errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME) {

            // find any entry
            FindAnyMibEntry(
                tfxInfo,
                vb,
                mibEntry,
                mibAction,
                tblXlat,
                vlIndex,
                errorStatus
                );
        }

    } else if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

        // validate asn value against mib entry information
        ValidateAsnAny(&vb->value, *mibEntry, *mibAction, errorStatus);

        // make sure valid before passing back entry
        if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {

            // table entry?
            if (*tblXlat) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: TFX: freeing index info (%s).\n",
                    SnmpUtilOidToA(&(*tblXlat)->txOid)
                    ));

                // free index oid
                SnmpUtilOidFree(&(*tblXlat)->txOid);

                // free table info
                SnmpUtilMemFree(*tblXlat);

            }

            // nullify results
            *mibEntry = NULL;
            *tblXlat  = NULL;
        }
    }
}

BOOL
CheckUpdateIndex(
    AsnObjectIdentifier *indexOid,
    UINT                nStartFrom,
    UINT                nExpecting
    )
/*++
Routine Description:

    Checks if an index OID contains all the components expected.
    If not, the index is updated to point before the very first
    OID requested.

Arguments:
    
    indexOid  - pointer to the index to be checked.
    nStartFrom - the point from where the index is checked.
    nExpecting  - the index should have at least expectTo components from startFrom.

Return value:
    TRUE if index was valid or has been updated successfully.
    FALSE otherwise (index was shorter then expected and all filled with 0s).

--*/
{
    int i;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: CheckUpdateIndex; checking %s.\n",
        SnmpUtilOidToA(indexOid)
        ));

    if (indexOid->idLength >= nStartFrom + nExpecting)
    {
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: CheckUpdateIndex; valid, unchanged.\n"
            ));

        return TRUE;
    }

    for (i = indexOid->idLength-1; i >= (int)nStartFrom; i--)
    {
        if (indexOid->ids[i] > 0)
        {
            indexOid->ids[i]--;
            indexOid->idLength = i+1;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: CheckUpdateIndex; valid, changed to %s.\n",
                SnmpUtilOidToA(indexOid)
                ));

            return TRUE;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: CheckUpdateIndex; invalid, to be removed.\n"
        ));

    return FALSE;
}

VOID
ParseInstanceIdentifier(
    SnmpTableXlat * tblXlat,
    AsnAny *        objArray,
    UINT            mibAction,
    UINT *          errorStatus
    )

/*++

Routine Description:

    Converts table index oid into object array.

Arguments:

    tblXlat   - table translation information.
    objArray  - instrumentation object array.
    mibAction - action requested of subagent.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;
    UINT k;
    UINT l;
    UINT m;

    BOOL fFixed;
    BOOL fLimit;
    BOOL fIndex;
    BOOL fEmpty;
    BOOL fExceed;

    UINT numItems;

    SnmpMibEntry * mibEntry;
    AsnObjectIdentifier * indexOid;

    LPDWORD lpIpAddress;

    *errorStatus = SNMP_ERRORSTATUS_NOERROR; // init return status

    // retrieve index oid
    indexOid = &tblXlat->txOid;

    // is this valid oid
    fEmpty = (indexOid->idLength == 0);

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: converting index %s to obj array via table 0x%08lx.\n",
        fEmpty ? "<tbd>" : SnmpUtilOidToA(indexOid), tblXlat->txInfo
        ));

    // retrieve root entry and entry count
    numItems = tblXlat->txInfo->numIndices;

    // see if the table indices are specified
    fIndex = (tblXlat->txInfo->tableIndices != NULL);
    fExceed = FALSE;
    // scan mib entries of table indices
    for (i=0, j=0; (i < numItems) && (j < indexOid->idLength); i++) {

        // get mib entry from table or directly
        mibEntry = fIndex ?  tblXlat->txInfo->tableIndices[i]
                          : &tblXlat->txInfo->tableEntry[i+1]
                          ;

        // retrieve array index
        k = (mibAction == MIB_ACTION_SET)
                ? (UINT)(CHAR)mibEntry->mibSetBufOff
                : (UINT)(CHAR)mibEntry->mibGetBufOff
                ;

        // determine type
        switch (mibEntry->mibType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length; indexOid should have at least l components more
                l = mibEntry->mibMaximum;

                if (!CheckUpdateIndex(indexOid, j, l))
                {
                    // out from switch and for
                    j+=l;
                    break;
                }

            } else {
                // variable length
                l = indexOid->ids[j];

                if (!CheckUpdateIndex(indexOid, j, l+1))
                {
                    // out from switch and for
                    j+=l+1;
                    break;
                }

                // BUG# 457746
                // the length of OID might have been changed by 
                // CheckUpdateIndex
                l = indexOid->ids[j]; // update the length if necessary
                
                j++;
            }

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // allocate object using length above
            objArray[k].asnValue.object.idLength = l;
            objArray[k].asnValue.object.ids = SnmpUtilMemAlloc(
                objArray[k].asnValue.object.idLength * sizeof(UINT)
                );

            if (objArray[k].asnValue.object.ids == NULL)
            {
                // report memory allocation problem
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: unable to allocate memory.\n"
                    ));
                objArray[k].asnValue.object.idLength = 0;
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                return; // bail...
            }
            // transfer data
            for (m=0; m < l; m++, j++) {

                // transfer oid element to buffer
                if (!fExceed && j < indexOid->idLength)
                {
                    objArray[k].asnValue.object.ids[m] = indexOid->ids[j];
                }
                else
                {
                    if (!fExceed)
                        fExceed = TRUE;
                    // this certainly is the last index from the request
                }

                if (fExceed)
                {
                    objArray[k].asnValue.object.ids[m] = (UINT)(-1);
                }
            }

            break;

        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length
                l = mibEntry->mibMaximum;

                if (!CheckUpdateIndex(indexOid, j, l))
                {
                    // out from switch and for
                    j+=l;
                    break;
                }

            } else {

                // variable length
                l = indexOid->ids[j];

                if (!CheckUpdateIndex(indexOid, j, l+1))
                {
                    j+=l+1;
                    break;
                }

                // BUG# 457746
                // the length of octet string might have been changed by 
                // CheckUpdateIndex
                l = indexOid->ids[j]; // update the length if necessary
                
                j++;
            }

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // allocate object
            objArray[k].asnValue.string.length = l;
            objArray[k].asnValue.string.dynamic = TRUE;
            objArray[k].asnValue.string.stream = SnmpUtilMemAlloc(
                objArray[k].asnValue.string.length * sizeof(CHAR)
                );

            if (objArray[k].asnValue.string.stream == NULL)
            {
                // report memory allocation problem
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: unable to allocate memory.\n"
                    ));
                objArray[k].asnValue.string.length = 0;
                objArray[k].asnValue.string.dynamic = FALSE;
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                return; // bail...
            }
            // transfer data
            for (m=0; m < l; m++, j++) {

                // convert oid element to character
                if (j < indexOid->idLength)
                {
                    if (!fExceed && indexOid->ids[j] <= (UCHAR)(-1))
                        objArray[k].asnValue.string.stream[m] = (BYTE)(indexOid->ids[j]);
                    else
                        fExceed=TRUE;
                }
                else
                {
                    if (!fExceed)
                        fExceed = TRUE;
                    // this certainly is the last index from the request
                }

                if (fExceed)
                {
                    objArray[k].asnValue.string.stream[m] = (UCHAR)(-1);
                }
            }

            break;

        // implicit fixed size
        case ASN_RFC1155_IPADDRESS:

            if (!CheckUpdateIndex(indexOid, j, 4))
            {
                // out from switch and for
                j+=4;
                break;
            }

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // allocate object
            objArray[k].asnValue.string.length = 4;
            objArray[k].asnValue.string.dynamic = TRUE;
            objArray[k].asnValue.string.stream = SnmpUtilMemAlloc(
                objArray[k].asnValue.string.length * sizeof(CHAR)
                );


            if (objArray[k].asnValue.string.stream == NULL)
            {
                // report memory allocation problem
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: unable to allocate memory.\n"
                    ));
                objArray[k].asnValue.string.length = 0;
                objArray[k].asnValue.string.dynamic = FALSE;
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                return; // bail...
            }

            // cast to dword in order to manipulate ip address
            lpIpAddress = (LPDWORD)objArray[k].asnValue.string.stream;


            // transfer data into buffer
            for (m=0; m<4; m++, j++)
            {
                *lpIpAddress <<= 8;

                if (!fExceed && j < indexOid->idLength)
                {
                    if (indexOid->ids[j] <= (UCHAR)(-1))
                        *lpIpAddress += indexOid->ids[j];
                    else
                        fExceed = TRUE;
                }
                else
                {
                    if (!fExceed)
                        fExceed = TRUE;
                    // this certainly is the last index from the request
                }
                if (fExceed)
                {
                    *lpIpAddress += (UCHAR)(-1);
                }
            }

            // ensure network byte order
            *lpIpAddress = htonl(*lpIpAddress);

            break;

        case ASN_RFC1155_COUNTER:
        case ASN_RFC1155_GAUGE:
        case ASN_RFC1155_TIMETICKS:
        case ASN_INTEGER:

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // transfer value as integer
            objArray[k].asnValue.number = fExceed ? (UINT)(-1) : indexOid->ids[j];
            j++;
            break;

        default:
            // invalidate
            j = INVALID_INDEX;
            break;
        }
    }
}



BOOL
IsTableIndex(
    SnmpMibEntry *  mibEntry,
    SnmpTableXlat * tblXlat
    )
{
    UINT newOff;
    BOOL fFoundOk = FALSE;
    BOOL fIndex;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: comparing mibEntry 0x%08lx to table 0x%08lx.\n",
        mibEntry,
        tblXlat->txInfo
        ));

    // see if the table indices are specified
    fIndex = (tblXlat->txInfo->tableIndices != NULL);

#if DBG
    newOff = 0;
#endif

    if (fIndex) {

        // rummage through index list looking for match
        for (newOff = 0; (newOff < tblXlat->txInfo->numIndices) && !fFoundOk; newOff++ ) {

            // compare mib entry with the next specified index
            fFoundOk = (mibEntry == tblXlat->txInfo->tableIndices[newOff]);
        }

    } else {

        // make sure pointer greater than table entry
        if (mibEntry > tblXlat->txInfo->tableEntry) {

            // calculate the difference between pointers
            newOff = (UINT)((ULONG_PTR)mibEntry - (ULONG_PTR)tblXlat->txInfo->tableEntry);

            // calculate table offset
            newOff /= sizeof(SnmpMibEntry);

            // determine whether entry within region
            fFoundOk = (newOff <= tblXlat->txInfo->numIndices);
        }
    }


    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: mibEntry %s a component of the table's index (off=%d, len=%d).\n",
        fFoundOk ? "is" : "is not",
        newOff,
        tblXlat->txInfo->numIndices
        ));

    return fFoundOk;
}


VOID
MibEntryToQueryList(
    SnmpMibEntry *       mibEntry,
    UINT                 mibAction,
    SnmpExtQueryList *   ql,
    SnmpTableXlat *      tblXlat,
    UINT                 vlIndex,
    RFC1157VarBindList * vbl,
    UINT                 vb,
    UINT *               errorStatus
    )

/*++

Routine Description:

    Converts mib entry information into subagent query.

Arguments:

    mibEntry    - mib information.
    mibAction   - action to perform.
    ql          - list of subagent queries.
    tableXlat   - table translation info.
    vlIndex     - index into view list.
    vbl         - original varbind list.
    vb          - original varbind.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;
    UINT viewType;

    FARPROC extFunc;

    AsnAny * objArray;
    SnmpExtQuery * extQuery;

    SnmpExtQuery    * tmpExtQuery = NULL; // prefix Bug 445172
    SnmpVarBindXlat * tmpVblXlat  = NULL; // prefix Bug 445172
   

    BOOL fFoundOk = FALSE;

    // determine instrumentation callback
    extFunc = (mibAction == MIB_ACTION_SET)
                ? (FARPROC)mibEntry->mibSetFunc
                : (FARPROC)mibEntry->mibGetFunc
                ;

    // process existing queries
    for (i=0; (i < ql->len) && !fFoundOk; i++) {

        // retrieve query ptr
        extQuery = &ql->query[i];

        // determine if a similar query exists
        fFoundOk = ((extQuery->extFunc == extFunc) &&
                    (extQuery->mibAction == mibAction));

        // compare table indices (if any)
        if (fFoundOk && extQuery->tblXlat) {

            // make sure
            if (tblXlat) {

                // compare index oids...
                fFoundOk = !SnmpUtilOidCmp(
                                &extQuery->tblXlat->txOid,
                                &tblXlat->txOid
                                );

            } else {

                // hmmm...
                fFoundOk = FALSE;
            }

        }
    }

    // append entry
    if (!fFoundOk) {

        ql->len++; // add new query to end of list
        tmpExtQuery = (SnmpExtQuery *)SnmpUtilMemReAlloc(
                                            ql->query,
                                            ql->len * sizeof(SnmpExtQuery)
                                            );
        // Prefix bug 445172
        // check memory re-allocation
        if (tmpExtQuery == NULL)
        {
            if (tblXlat)
            {
                // free table oid
                SnmpUtilOidFree(&tblXlat->txOid);

                // free table info
                SnmpUtilMemFree(tblXlat);
            }
            ql->len--; // rollback
            // report memory allocation problem
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return; // bail...
        }
        ql->query = tmpExtQuery;

        // retrieve new query pointer
        extQuery = &ql->query[ql->len-1];

        // save common information
        extQuery->mibAction = mibAction;
        extQuery->viewType  = MIB_VIEW_NORMAL;
        extQuery->extFunc   = extFunc;

        // initialize list
        extQuery->vblNum  = 0;
        extQuery->vblXlat = NULL;
        extQuery->tblXlat = NULL;

        // size the instrumentation buffer
        extQuery->extData.len = (mibAction == MIB_ACTION_SET)
                                    ? mibEntry->mibSetBufLen
                                    : mibEntry->mibGetBufLen
                                    ;
        
        // allocate the instrumentation buffer
        extQuery->extData.data = SnmpUtilMemAlloc(
                                    extQuery->extData.len
                                    );

        // check memory allocation
        if (extQuery->extData.data) {

            // table?
            if (tblXlat) {

                // retrieve object array pointer
                objArray = (AsnAny *)(extQuery->extData.data);

                // Prefix 118006
                // initialize asn array
                ParseInstanceIdentifier(tblXlat, objArray, mibAction, errorStatus);
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
                {
                    // logging...
                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: TFX: unable to ParseInstanceIdentifier with table info 0x%08lx.\n",
                        tblXlat
                        ));
                    SnmpUtilMemFree(extQuery->extData.data);
                    extQuery->extData.data = NULL; // null pointer to avoid double free or deref.
                    extQuery->extData.len = 0;
                    
                    // free table oid
                    SnmpUtilOidFree(&tblXlat->txOid);
                    // free table info
                    SnmpUtilMemFree(tblXlat);


                    ql->len--; // rollback
                    
                    return; // bail
                }

                // save table info
                extQuery->tblXlat = tblXlat;
            }

        } else {

            // rollback
            extQuery->extData.len = 0; 
            ql->len--;

            if (tblXlat) 
            {
                // free table oid
                SnmpUtilOidFree(&tblXlat->txOid);

                // free table info
                SnmpUtilMemFree(tblXlat);
            }

            // report memory allocation problem
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return; // bail...
        }

    } else if (tblXlat != NULL) {

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: releasing duplicate table info 0x%08lx.\n",
            tblXlat
            ));

        // free table oid
        SnmpUtilOidFree(&tblXlat->txOid);

        // free table info
        SnmpUtilMemFree(tblXlat);
    }

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: %s query 0x%08lx.\n",
        fFoundOk ? "editing" : "adding",
        extQuery
        ));

    // copy to index
    i = extQuery->vblNum;

    // allocate entry
    extQuery->vblNum++;

    tmpVblXlat = (SnmpVarBindXlat *)SnmpUtilMemReAlloc(
                            extQuery->vblXlat,
                            extQuery->vblNum * sizeof(SnmpVarBindXlat)
                            );
    if (tmpVblXlat == NULL)
    {
        // report memory allocation problem
        *errorStatus = SNMP_ERRORSTATUS_GENERR;
        extQuery->vblNum--; // rollback
        return; // bail...
    }
    extQuery->vblXlat  = tmpVblXlat;


    // copy common xlate information
    extQuery->vblXlat[i].vblIndex = vb;
    extQuery->vblXlat[i].vlIndex  = vlIndex;
    extQuery->vblXlat[i].extQuery = NULL;

    // save translation info
    extQuery->vblXlat[i].mibEntry = mibEntry;

    // determine offset used
    i = (mibAction == MIB_ACTION_SET)
          ? (UINT)(CHAR)mibEntry->mibSetBufOff
          : (UINT)(CHAR)mibEntry->mibGetBufOff
          ;

    // retrieve object array pointer
    objArray = (AsnAny *)(extQuery->extData.data);

    // fill in only asn type if get
    if (mibAction != MIB_ACTION_SET) {

        // ignore table indices
        if (extQuery->tblXlat &&
            IsTableIndex(mibEntry,extQuery->tblXlat)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: requesting index value.\n"
                ));

        } else {

            // initialize asn type to match entry
            objArray[i].asnType = mibEntry->mibType;
        }

    } else {

        // copy user-supplied value into buffer
        if (! SnmpUtilAsnAnyCpy(&objArray[i], &vbl->list[vb].value) )
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: TFX: MibEntryToQueryList; SnmpUtilAsnAnyCpy failed.\n"
                ));

            // report memory allocation problem
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            extQuery->vblNum--; // invalidate this SnmpVarBindXlat
            return; // bail...
        }
    }
}


VOID
VarBindToQueryList(
    SnmpTfxInfo *        tfxInfo,
    RFC1157VarBindList * vbl,
    SnmpExtQueryList *   ql,
    UINT                 vb,
    UINT *               errorStatus,
    UINT *               errorIndex,
    UINT                 queryView
    )

/*++

Routine Description:

    Adds varbind to query list.

Arguments:

    tfxInfo     - context info.
    vbl         - list of varbinds.
    ql          - list of subagent queries.
    vb          - index of varbind to add to query.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.
    queryView   - view of query requested.

Return Values:

    None.

--*/

{
    INT i;
    INT nDiff;
    INT lastViewIndex;

    BOOL fAnyOk;
    BOOL fFoundOk = FALSE;

    UINT mibAction;

    SnmpMibView   * mibView;
    SnmpMibEntry  * mibEntry = NULL;
    SnmpTableXlat * tblXlat  = NULL;

    // copy request type
    mibAction = ql->action;

    // determine whether we need exact match
    fAnyOk = (mibAction == MIB_ACTION_GETNEXT);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: searching subagents to resolve %s (%s).\n",
        SnmpUtilOidToA(&vbl->list[vb].name),
        fAnyOk ? "AnyOk" : "AnyNOk"
        ));

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: VarBindToQueryList; scanning views from %d to %d.\n",
        queryView,
        (INT)tfxInfo->numViews
    ));

    // init to NonView
    lastViewIndex = -1;

    // locate appropriate view (starting at queryView)
    for (i = queryView; (i < (INT)tfxInfo->numViews) && !fFoundOk; i++) {

        // retrieve the mib view information
        mibView = tfxInfo->tfxViews[i].mibView;

        // compare root oids
        nDiff = SnmpUtilOidNCmp(
                    &vbl->list[vb].name,
                    &mibView->viewOid,
                    mibView->viewOid.idLength
                    );

        // analyze results based on request type
        fFoundOk = (!nDiff || (fAnyOk && (nDiff < 0)));

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: View %d: comp(%s, ",
            i,
            SnmpUtilOidToA(&vbl->list[vb].name)
        ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "%s, %d) = %d '%s'\n",
            SnmpUtilOidToA(&mibView->viewOid),
            mibView->viewOid.idLength,
            nDiff,
            fFoundOk?"Found":"NotFound"
        ));


        // make sure we can obtain mib entry (if available)
        if (fFoundOk && (mibView->viewType == MIB_VIEW_NORMAL)) {

            // initialize local copy of error status
            UINT mibStatus = SNMP_ERRORSTATUS_NOERROR;

            // store index
            lastViewIndex = i;

            // load mib entry
            VarBindToMibEntry(
                   tfxInfo,
                   &vbl->list[vb],
                   &mibEntry,
                   &mibAction,
                   &tblXlat,
                   i,
                   &mibStatus
                   );

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: VarBindToMibEntry returned %d.\n",
                mibStatus
            ));

            // successfully loaded mib entry information
            fFoundOk = (mibStatus == SNMP_ERRORSTATUS_NOERROR);

            // bail if not searching...
            if (!fFoundOk && !fAnyOk) {
                // pass up error status
                *errorStatus = mibStatus;
                *errorIndex  = vb+1;
                return; // bail...
            }
        }
    }

    // reset error status and index...
    *errorStatus = SNMP_ERRORSTATUS_NOERROR;
    *errorIndex  = 0;

    // found AND had a valid mibEntry
    if (fFoundOk && mibEntry) { 
        // save query
        MibEntryToQueryList(
               mibEntry,
               mibAction,
               ql,
               tblXlat,
               i-1,
               vbl,
               vb,
               errorStatus
               );

    } else if (fAnyOk){

        if (lastViewIndex == -1)
            lastViewIndex = tfxInfo->numViews - 1;

        // not supported in any view...
        SnmpUtilOidFree(&vbl->list[vb].name);

        // copy varbind
        if (SnmpUtilOidCpy(
            &vbl->list[vb].name,
            &tfxInfo->tfxViews[lastViewIndex].mibView->viewOid) == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: TFX: SnmpUtilOidCpy at line %d failed.\n",
                __LINE__));

            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return; // bail...
        }
    
        // increment last element of view oid
        vbl->list[vb].name.ids[(vbl->list[vb].name.idLength-1)]++;

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: changing varbind to %s.\n",
            SnmpUtilOidToA(&vbl->list[vb].name)
            ));
    }
}


VOID
VarBindListToQueryList(
    SnmpTfxInfo *        tfxInfo,
    RFC1157VarBindList * vbl,
    SnmpExtQueryList *   ql,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Convert list of varbinds from incoming pdu into a list of
    individual subagent queries.

Arguments:

    tfxInfo     - context handle.
    vbl         - list of varbinds in pdu.
    ql          - list of subagent queries.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT i; // index into varbind list

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: processing %s request containing %d variable(s).\n",
        (ql->action == MIB_ACTION_GET)
            ? "get"
            : (ql->action == MIB_ACTION_SET)
                ? "set"
                : (ql->action == MIB_ACTION_GETNEXT)
                    ? "getnext"
                    : "unknown", vbl->len));

    // initialize status return values
    *errorStatus = SNMP_ERRORSTATUS_NOERROR;
    *errorIndex  = 0;

    // process incoming variable bindings
    for (i=0; i < vbl->len; i++) 
    {
        // find varbind
        VarBindToQueryList(
            tfxInfo,
            vbl,
            ql,
            i,
            errorStatus,
            errorIndex,
            0
            );
        if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
        {
            *errorIndex = i+1; // have problem during the processing of (i+1)th varbind
            break;
        }
    }
}


UINT
MibStatusToSnmpStatus(
    UINT mibStatus
    )

/*++

Routine Description:

    Translate mib status into snmp error status.

Arguments:

    mibStatus - mib error code.

Return Values:

    Returns snmp error status.

--*/

{
    UINT errorStatus;

    switch (mibStatus) {

    case MIB_S_SUCCESS:
        errorStatus = SNMP_ERRORSTATUS_NOERROR;
        break;

    case MIB_S_INVALID_PARAMETER:
        errorStatus = SNMP_ERRORSTATUS_BADVALUE;
        break;

    case MIB_S_NOT_SUPPORTED:
    case MIB_S_NO_MORE_ENTRIES:
    case MIB_S_ENTRY_NOT_FOUND:
        errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
        break;

    default:
        errorStatus = SNMP_ERRORSTATUS_GENERR;
        break;
    }

    return errorStatus;
}


VOID
AdjustErrorIndex(
    SnmpExtQuery * q,
    UINT *         errorIndex
    )

/*++

Routine Description:

    Ensure that indices match the original pdu.

Arguments:

    q          - subagent query.
    errorIndex - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT errorIndexOld = *errorIndex;

    // make sure within bounds
    if (errorIndexOld && (errorIndexOld <= q->vblNum)) {

        // determine proper index from xlat info
        *errorIndex = q->vblXlat[errorIndexOld-1].vblIndex+1;

    } else {

        // default to first variable
        *errorIndex = q->vblXlat[0].vblIndex+1;
    }
}


BOOL
ProcessQuery(
    SnmpExtQuery * q,
    UINT *         errorStatus,
    UINT *         errorIndex
    )

/*++

Routine Description:

    Query the subagent for requested items.

Arguments:

    q           - subagent query.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    BOOL fOk = TRUE;
    UINT extStatus = 0;

    AsnAny * objArray;

    // validate...
    if (q == NULL) {
        return TRUE;
    }

    // retrieve asn object array
    objArray = (AsnAny *)(q->extData.data);
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: ProcessQuery - objArray=%lx\n",
        objArray
        ));

    __try {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: entering subagent code ....\n"
            ));
        // query subagent
        extStatus = (UINT)(*q->extFunc)(
                            q->mibAction,
                            objArray,
                            errorIndex
                            );
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: ... subagent code completed.\n"
            ));

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: subagent returned %s (e=0x%08lx,i=%d).\n",
            (extStatus == MIB_S_SUCCESS)
                ? "MIB_S_SUCCESS"
                : (extStatus == MIB_S_NO_MORE_ENTRIES)
                    ? "MIB_S_NO_MORE_ENTRIES"
                    : (extStatus == MIB_S_ENTRY_NOT_FOUND)
                        ? "MIB_S_ENTRY_NOT_FOUND"
                        : (extStatus == MIB_S_INVALID_PARAMETER)
                            ? "MIB_S_INVALID_PARAMETER"
                            : (extStatus == MIB_S_NOT_SUPPORTED)
                                ? "MIB_S_NOT_SUPPORTED"
                                : "error", extStatus, *errorIndex
                                ));

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        // report exception code
        extStatus = GetExceptionCode();

        // disable
        fOk = FALSE;
    }

    // save error info
    SetLastError(extStatus);

    // pass back translated version
    *errorStatus = MibStatusToSnmpStatus(extStatus);

    return fOk;
}


VOID
ProcessQueryList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Process the query list based on request type.

Arguments:

    tfxInfo     - context information.
    ql          - list of subagent queries.
    vbl         - list of incoming variable bindings.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    INT i=0; // index into query list
    INT j=0; // index into query list

    INT qlLen = ql->len; // save...

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: processing %d subagent queries.\n",
        qlLen
        ));

    // sets are processed below...
    if (ql->action != MIB_ACTION_SET) {

        // process list of individual queries
        for (i=0; (i < qlLen) && !(*errorStatus); i++ ) {

            // send query to subagent
            if (ProcessQuery(&ql->query[i], errorStatus, errorIndex)) {

                // need to validate getnext results
                if (ql->action == MIB_ACTION_GETNEXT) {
                    // exhaust all possibilities...
                    ValidateQueryList(
                        tfxInfo,
                        ql,
                        i,
                        vbl,
                        errorStatus,
                        errorIndex
                        );
                }

                // check the subagent status code returned
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {
                    // adjust index to match request pdu
                    AdjustErrorIndex(&ql->query[i], errorIndex);
                }

            } else {

                // subagent unable to process query
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                *errorIndex  = 1;
                // adjust index to match request pdu
                AdjustErrorIndex(&ql->query[i], errorIndex);
            }
        }

    } else {

        // process all of the validate queries
        for (i=0; (i < qlLen) && !(*errorStatus); i++) {

            // alter query type to validate entries
            ql->query[i].mibAction = MIB_ACTION_VALIDATE;

            // send query to subagent
            if (ProcessQuery(&ql->query[i], errorStatus, errorIndex)) {

                // check the subagent status code returned
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {
                    // adjust index to match request pdu
                    AdjustErrorIndex(&ql->query[i], errorIndex);
                }

            } else {

                // subagent unable to process query
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                *errorIndex  = 1;
                // adjust index to match request pdu
                AdjustErrorIndex(&ql->query[i], errorIndex);
            }
        }

        // process all of the set queries
        for (j=0; (j < qlLen) && !(*errorStatus); j++) {

            // alter query type to set entries
            ql->query[j].mibAction = MIB_ACTION_SET;

            // send query to subagent
            if (ProcessQuery(&ql->query[j], errorStatus, errorIndex)) {

                // check the subagent status code returned
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {
                    // adjust index to match request pdu
                    AdjustErrorIndex(&ql->query[j], errorIndex);
                }

            } else {

                // subagent unable to process query
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                *errorIndex  = 1;
                // adjust index to match request pdu
                AdjustErrorIndex(&ql->query[j], errorIndex);
            }
        }

        // cleanup...
        while (i-- > 0) {

            UINT ignoreStatus = 0; // dummy values
            UINT ignoreIndex  = 0; // dummy values

            // alter query type to set entries
            ql->query[i].mibAction = MIB_ACTION_CLEANUP;

            // send the cleanup request success or not
            ProcessQuery(&ql->query[i], &ignoreStatus, &ignoreIndex);
        }
    }
}


BOOL
ConstructInstanceIdentifier(
    SnmpTableXlat *       tblXlat,
    AsnAny *              objArray,
    AsnObjectIdentifier * newOid,
    UINT                  mibAction
    )
/*++

Routine Description:

    Convert asn value into index oid.

Arguments:

    tblXlat   - table translation info.
    objArray  - asn object array.
    newOid    - relative oid to return.
    mibAction - action requested of subagent.

Return Values: TRUE if successful

    None.

--*/

{
    UINT i;
    UINT j;
    UINT k;
    UINT l;
    UINT m;

    BOOL fFixed;
    BOOL fLimit;
    BOOL fIndex;

    UINT numItems;

    SnmpMibEntry * mibEntry;

    UINT * tmpIds = NULL; // prefix bug 445170

    // initialize
    newOid->ids = NULL;
    newOid->idLength = 0;


    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: converting obj array to index via table 0x%08lx.\n",
        tblXlat->txInfo
        ));

    // retrieve root entry and entry count
    numItems = tblXlat->txInfo->numIndices;

    // see if the table indices are specified
    fIndex = (tblXlat->txInfo->tableIndices != NULL);

    // scan entries of table indices
    for (i=0, j=0; i < numItems; i++) {

        // get mib entry from table or directly
        mibEntry = fIndex ?  tblXlat->txInfo->tableIndices[i]
                          : &tblXlat->txInfo->tableEntry[i+1]
                          ;

        // retrieve array index
        k = (mibAction == MIB_ACTION_SET)
                ? (UINT)(CHAR)mibEntry->mibSetBufOff
                : (UINT)(CHAR)mibEntry->mibGetBufOff
                ;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: ConstructIndexIdentifier - k=%d\n",
            k
            ));
        // determine type
        switch (mibEntry->mibType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length
                l = mibEntry->mibMaximum;

                // allocate space
                newOid->idLength += l;

                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

            } else {

                // determine variable length of object
                l = objArray[k].asnValue.object.idLength;

                // allocate space
                newOid->idLength += (l+1);
                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

                // save length
                newOid->ids[j++] = l;
            }

            // transfer data
            for (m=0; m < l; m++) {

                // transfer oid element from buffer
                newOid->ids[j++] = objArray[k].asnValue.object.ids[m];
            }

            break;

        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length
                l = mibEntry->mibMaximum;

                // allocate space
                newOid->idLength += l;
                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

            } else {

                // determine variable length of object
                l = objArray[k].asnValue.string.length;

                // allocate space
                newOid->idLength += (l+1);
                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

                // save length
                newOid->ids[j++] = l;
            }

            // transfer data
            for (m=0; m < l; m++) {

                // convert character
                newOid->ids[j++] =
                    (UINT)(UCHAR)objArray[k].asnValue.string.stream[m];
            }

            break;

        // implicit fixed size
        case ASN_RFC1155_IPADDRESS:

            // allocate space
            newOid->idLength += 4;
            tmpIds = (UINT *)SnmpUtilMemReAlloc(
                newOid->ids,
                newOid->idLength * sizeof(UINT)
                );
            if (tmpIds == NULL)
            {
                newOid->idLength = 0;
                SnmpUtilMemFree(newOid->ids);
                newOid->ids = NULL;
                return FALSE;
            }
            newOid->ids = tmpIds;

            // transfer data into buffer
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[0];
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[1];
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[2];
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[3];

            break;

        case ASN_RFC1155_COUNTER:
        case ASN_RFC1155_GAUGE:
        case ASN_RFC1155_TIMETICKS:
        case ASN_INTEGER:

            // allocate space
            newOid->idLength += 1;
            tmpIds = (UINT *)SnmpUtilMemReAlloc(
                newOid->ids,
                newOid->idLength * sizeof(UINT)
                );
            if (tmpIds == NULL)
            {
                newOid->idLength = 0;
                SnmpUtilMemFree(newOid->ids);
                newOid->ids = NULL;
                return FALSE;
            }
            newOid->ids = tmpIds;

            // transfer value as integer
            newOid->ids[j++] = objArray[k].asnValue.number;
            break;

        default:
            // invalidate
            j = INVALID_INDEX;
            break;
        }
    }
    return TRUE;
}


VOID
DeleteQuery(
    SnmpExtQuery * q
    )

/*++

Routine Description:

    Deletes individual query.

Arguments:

    q - subagent query.

Return Values:

    None.

--*/

{
    UINT i; // index into xlat array
    UINT j; // index into object array

    BOOL fSet;

    AsnAny * objArray;
    SnmpMibEntry * mibEntry;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: deleting query 0x%08lx.\n", q
        ));

    // determine whether a set was requested
    fSet = (q->mibAction == MIB_ACTION_SET);

    // retrieve asn object array
    objArray = (AsnAny *)(q->extData.data);

    // free requested entries
    for (i = 0; i < q->vblNum; i++ ) 
    {
        // retrieve mib entry
        mibEntry = q->vblXlat[i].mibEntry;

        ASSERT(mibEntry);

        j = fSet ? (UINT)(CHAR)mibEntry->mibSetBufOff
                 : (UINT)(CHAR)mibEntry->mibGetBufOff
                 ;
        
        if (objArray)
            SnmpUtilAsnAnyFree(&objArray[j]);

        // free any followup queries
        if ((q->vblXlat[i].extQuery != NULL) &&
            (q->vblXlat[i].extQuery != INVALID_QUERY)) 
        {
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: deleting followup query 0x%08lx.\n",
                q->vblXlat[i].extQuery
                ));

            // free followup query
            DeleteQuery(q->vblXlat[i].extQuery);

            // free query structure itself
            SnmpUtilMemFree(q->vblXlat[i].extQuery);
        }
    }

    q->vblNum = 0;

    
    // free indices
    if (q->tblXlat && objArray) 
    {

        BOOL fIndex;

        // see if the table indices are specified
        fIndex = (q->tblXlat->txInfo->tableIndices != NULL);

        // free the individual indices
        for (i = 0; i < q->tblXlat->txInfo->numIndices; i++) 
        {

            // get mib entry from table or directly from entry
            mibEntry = fIndex ?  q->tblXlat->txInfo->tableIndices[i]
                              : &q->tblXlat->txInfo->tableEntry[i+1]
                              ;

            ASSERT(mibEntry);

            // determine the buffer offset used
            j = fSet ? (UINT)(CHAR)mibEntry->mibSetBufOff
                     : (UINT)(CHAR)mibEntry->mibGetBufOff
                     ;
            
            // free individual index
            SnmpUtilAsnAnyFree(&objArray[j]);
        }
    }
    
        
    // free buffer
    SnmpUtilMemFree(objArray);
    
    // avoid double freeing
    q->extData.data = NULL;

    // free table info
    if (q->tblXlat) {

        // free object identifier
        SnmpUtilOidFree(&q->tblXlat->txOid);

        // free the xlat structure
        SnmpUtilMemFree(q->tblXlat);

        // avoid double freeing
        q->tblXlat = NULL;
    }

    // free translation info
    SnmpUtilMemFree(q->vblXlat);

    // avoid double freeing
    q->vblXlat = NULL;
}


VOID
DeleteQueryList(
    SnmpExtQueryList * ql
    )

/*++

Routine Description:

    Deletes query list.

Arguments:

    ql - list of subagent queries.

Return Values:

    None.

--*/

{
    UINT q; // index into query list

    // process queries
    for (q=0; q < ql->len; q++) {

        // delete query
        DeleteQuery(&ql->query[q]);
    }

    // free query list
    SnmpUtilMemFree(ql->query);
}


VOID
QueryToVarBindList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQuery *       q,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )
/*++

Routine Description:

    Convert query back into varbind.

Arguments:

    tfxInfo - context info
    q       - subagent query.
    vbl     - list of varbinds in outgoing pdu.

Return Values:

    None.

--*/

{
    UINT i=0;
    UINT j=0;
    UINT k=0;
    UINT l=0;

    BOOL fSet;

    AsnAny * objArray;
    SnmpMibEntry * mibEntry;

    AsnObjectIdentifier idxOid;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: converting query 0x%08lx to varbinds.\n", q
        ));

    // determine whether a set was requested
    fSet = (q->mibAction == MIB_ACTION_SET);

    // retrieve asn object array
    objArray = (AsnAny *)(q->extData.data);

    // copy requested entries
    for (j = 0; j < q->vblNum; j++) {
        // process followup query
        if (q->vblXlat[j].extQuery != NULL) {

            if (q->vblXlat[j].extQuery != INVALID_QUERY) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: TFX: processing followup query 0x%08lx.\n",
                    q->vblXlat[j].extQuery
                    ));


                QueryToVarBindList(
                    tfxInfo,
                    q->vblXlat[j].extQuery,
                    vbl, 
                    errorStatus, 
                    errorIndex
                    );

                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
                    return; // bail...
                else 
                    continue; // skip...
                
            } else {
            
                i = q->vblXlat[j].vblIndex;
            
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: TFX: returning oid %s without reassembly.\n",
                    SnmpUtilOidToA(&vbl->list[i].name)
                    ));        
                
                continue; // skip...
            }
        }

        // retrieve index
        i = q->vblXlat[j].vblIndex;

        // retrieve mib entry for requested item
        mibEntry = q->vblXlat[j].mibEntry;

        k = fSet ? (UINT)(CHAR)mibEntry->mibSetBufOff
                 : (UINT)(CHAR)mibEntry->mibGetBufOff
                 ;

        // free original variable
        SnmpUtilVarBindFree(&vbl->list[i]);

        // copy the asn value first
        if (SnmpUtilAsnAnyCpy(&vbl->list[i].value, &objArray[k]) == 0)
        {
            // report memory allocation problem
            *errorIndex = i+1; // failed in (i+1)th varbind
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: TFX: SnmpUtilAsnAnyCpy at line %d failed on the %d th varbind.\n",
                __LINE__, i+1
                ));
            return; // bail...
        }

        // copy root oid of view
        if (SnmpUtilOidCpy(
                &vbl->list[i].name,
                &tfxInfo->tfxViews[(q->vblXlat[j].vlIndex)].mibView->viewOid) == 0)
        {
            // report memory allocation problem
            *errorIndex = i+1; // failed in (i+1)th varbind
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: TFX: SnmpUtilOidCpy at line %d failed on the %d th varbind.\n",
                __LINE__, i+1
                ));
            return; // bail...
        }

        // copy oid of variable
        if (SnmpUtilOidAppend(
                &vbl->list[i].name,
                &mibEntry->mibOid) == 0)
        {
            // report memory allocation problem
            *errorIndex = i+1; // failed in (i+1)th varbind
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: TFX: SnmpUtilOidAppend at line %d failed on the %d th varbind.\n",
                __LINE__, i+1
                ));
            return; // bail...
        }

        // copy table index
        if (q->tblXlat) {

            // convert value to oid
            if (ConstructInstanceIdentifier(q->tblXlat, objArray, &idxOid, q->mibAction) == FALSE)
            {
                // report memory allocation problem
                *errorIndex = i+1; // failed in (i+1)th varbind
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: ConstructInstanceIdentifier failed with %d th varbind.\n",
                    i+1
                    ));
                return; // bail...
            }

            // append oid to object name
            if (SnmpUtilOidAppend(&vbl->list[i].name, &idxOid) == 0)
            {
                // free temp oid
                SnmpUtilOidFree(&idxOid);
                
                // report memory allocation problem
                *errorIndex = i+1; // failed in (i+1)th varbind
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: SnmpUtilOidAppend at line %d failed on the %d th varbind.\n",
                    __LINE__, i+1
                    ));
                return; // bail...
            }

            // free temp oid
            SnmpUtilOidFree(&idxOid);
        }

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: returning oid %s.\n",
            SnmpUtilOidToA(&vbl->list[i].name)
            ));         
    }
}


VOID
QueryListToVarBindList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Convert query list back into outgoing varbinds.

Arguments:

    tfxInfo     - context information.
    ql          - list of subagent queries.
    vbl         - list of varbinds in outgoing pdu.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT q;   // index into queue list
    UINT vb;  // index into queue varbind list
    UINT i;   // index into original varbind list

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: request %s, errorStatus=%s, errorIndex=%d.\n",
        (*errorStatus == SNMP_ERRORSTATUS_NOERROR)
            ? "succeeded"
            : "failed",
        (*errorStatus == SNMP_ERRORSTATUS_NOERROR)
            ? "NOERROR"
            : (*errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME)
                  ? "NOSUCHNAME"
                  : (*errorStatus == SNMP_ERRORSTATUS_BADVALUE)
                      ? "BADVALUE"
                      : (*errorStatus == SNMP_ERRORSTATUS_READONLY)
                          ? "READONLY"
                          : (*errorStatus == SNMP_ERRORSTATUS_TOOBIG)
                              ? "TOOBIG"
                              : "GENERR", *errorIndex
                              ));

    // only convert back if error not reported
    if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

        // process queries
        for (q=0; q < ql->len; q++) {

            // translate query data
            QueryToVarBindList(tfxInfo, &ql->query[q], vbl, errorStatus, errorIndex);
            if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
                break;
        }
    }

    // free
    DeleteQueryList(ql);
}

VOID
ValidateQueryList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    UINT                 q,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Validate getnext results and re-query if necessary.

Arguments:

    tfxInfo      - context information.
    ql           - list of subagent queries.
    q            - subagent query of interest.
    vbl          - list of bindings in incoming pdu.
    errorStatus  - used to indicate success or failure.
    errorIndex   - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;

    SnmpExtQueryList tmpQl;

    UINT vlIndex;
    UINT vblIndex;
    UINT mibAction;
    UINT mibStatus;
    SnmpMibEntry * mibEntry;
    SnmpTableXlat * tblXlat;
    RFC1157VarBindList tmpVbl;
    BOOL fFoundOk = FALSE;

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: verifying results of query 0x%08lx.\n", &ql->query[q]
        ));

    // bail on any error other than no such name
    if (*errorStatus != SNMP_ERRORSTATUS_NOSUCHNAME) {

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: *errorStatus != SNMP_ERRORSTATUS_NOSUCHNAME, *errorStatus = %d.\n",
            *errorStatus
            ));

        return; // bail...
    }

    // scan query list updating variables
    for (i=0; i < ql->query[q].vblNum; i++) {

        // initialize
        mibEntry  = ql->query[q].vblXlat[i].mibEntry;
        vlIndex   = ql->query[q].vblXlat[i].vlIndex;
        j         = ql->query[q].vblXlat[i].vlIndex;

        tblXlat   = NULL;
        mibAction = MIB_ACTION_GETNEXT;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: ValidateQueryList; next of %s.\n",
            SnmpUtilOidToA(&mibEntry->mibOid)
            ));

        // next...
        FindNextMibEntry(
               tfxInfo,
               NULL,
               &mibEntry,
               &mibAction,
               &tblXlat,
               vlIndex,
               errorStatus
               );

        while (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: constructing followup to query 0x%08lx:\n"
                "SNMP: TFX: \tmibEntry=0x%08lx\n"
                "SNMP: TFX: \ttblXlat =0x%08lx\n",
                &ql->query[q],
                mibEntry,
                tblXlat
                ));

            // initialize
            tmpQl.len    = 0;
            tmpQl.query  = NULL;
            tmpQl.action = MIB_ACTION_GETNEXT;

            // create query
            MibEntryToQueryList(
                   mibEntry,
                   mibAction,
                   &tmpQl,
                   tblXlat,
                   vlIndex,
                   NULL,
                   ql->query[q].vblXlat[i].vblIndex,
                   errorStatus
                   );

            if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: ValidateQueryList; MibEntryToQueryList returned %d.\n",
                    *errorStatus
                    ));

                // delete if necessary
                DeleteQueryList(&tmpQl);
                
                return; // bail...
            }

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: processing followup query 0x%08lx.\n",
                tmpQl.query
                ));

            // perform query with new oid
            ProcessQuery(tmpQl.query, errorStatus, errorIndex);

            // calculate results of query
            if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: TFX: saving followup 0x%08lx in query 0x%08lx.\n",
                    tmpQl.query, &ql->query[q]
                    ));

                // copy query for reassembly purposes
                ql->query[q].vblXlat[i].extQuery = tmpQl.query;

                break; // process next varbind...

            } else if (*errorStatus != SNMP_ERRORSTATUS_NOSUCHNAME) {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: TFX: could not process followup.\n"
                    ));

                // delete...
                DeleteQueryList(&tmpQl);

                return; // bail...
            }

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: re-processing followup to query 0x%08lx.\n",
                &ql->query[q]
                ));

            // delete...
            DeleteQueryList(&tmpQl);

            // re-initialize and continue...
            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
            tblXlat = NULL;
            mibAction = MIB_ACTION_GETNEXT;

            // next...
            FindNextMibEntry(
                   tfxInfo,
                   NULL,
                   &mibEntry,
                   &mibAction,
                   &tblXlat,
                   vlIndex,
                   errorStatus
                   );
        }

        // NOTE: if we break from the above while loop,
        //       *errorStatus will be SNMP_ERRORSTATUS_NOERROR

        // attempt to query next supported subagent view
        if (*errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME) {

            // retrieve variable binding list index
            vblIndex = ql->query[q].vblXlat[i].vblIndex;

            // release old variable binding
            SnmpUtilVarBindFree(&vbl->list[vblIndex]);

            // copy varbind
            if (! SnmpUtilOidCpy(&vbl->list[vblIndex].name,
                                 &tfxInfo->tfxViews[j].mibView->viewOid) )
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: ValidateQueryList; SnmpUtilOidCpy failed.\n"
                    ));

                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                
                return; // bail...
            }

            // increment last sub-identifier of view oid
            vbl->list[vblIndex].name.ids[vbl->list[vblIndex].name.idLength-1]++;

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: query out of view. Pass up %s to service.\n",
                SnmpUtilOidToA(&vbl->list[vblIndex].name)
                ));

            // this query goes outside the MIB view.
            // varbind is set (above) to the first OID outside this view, so let the master agent
            // handle the switch between views.
            
            // let QueryToVarBindList() knows that this SnmpVarBindXlat is
            // not valid for reassembly purpose.
            ql->query[q].vblXlat[i].extQuery = INVALID_QUERY;
            
            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
             
            continue; // process next varbind...

        } else if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {

            SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: ValidateQueryList; FindNextMibEntry returned %d.\n",
                    *errorStatus
                    ));

            return; // bail...
        }
    }
}


SnmpTfxInfo *
AllocTfxInfo(
    )
{
    // simply return results from generic memory allocation
    return (SnmpTfxInfo *)SnmpUtilMemAlloc(sizeof(SnmpTfxInfo));
}


VOID
FreeTfxInfo(
    SnmpTfxInfo * tfxInfo
    )
{
    UINT i;
    // prefix bug 445171    
    if (tfxInfo == NULL) {
        return;
    }
    if (tfxInfo->tfxViews == NULL)
    {
        SnmpUtilMemFree(tfxInfo);
        return;
    }

    // walk through list of views
    for (i=0; (i < tfxInfo->numViews); i++) {

        // release memory for view hash tables
        FreeHashTable(tfxInfo->tfxViews[i].hashTable);
    }
    SnmpUtilMemFree(tfxInfo->tfxViews);
    SnmpUtilMemFree(tfxInfo);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpTfxHandle
SNMP_FUNC_TYPE
SnmpTfxOpen(
    DWORD         numViews,
    SnmpMibView * supportedViews
    )
{
    UINT i,j;
    BOOL fOk;
    SnmpTfxInfo * tfxInfo = NULL;

    // validate parameters
    if ((numViews == 0) ||
        (supportedViews == NULL)) {
        return NULL;
    }

    // allocate structure
    tfxInfo = AllocTfxInfo();

    // validate pointer
    if (tfxInfo == NULL) {
        return NULL;
    }

    // copy number of views
    tfxInfo->numViews = numViews;

    // allocate individual view structures
    tfxInfo->tfxViews = SnmpUtilMemAlloc(
        tfxInfo->numViews * sizeof(SnmpTfxView)
        );

    // initialize status
    fOk = (tfxInfo->tfxViews != NULL);

    // initialize each view structure
    for (i=0; (i < tfxInfo->numViews) && fOk; i++) {

        SnmpHashNode ** tmpHashTable;

        // initialize individual view list entry
        tmpHashTable = AllocHashTable(&supportedViews[i]);

        // initialize status
        fOk = (tmpHashTable != NULL);

        // validate
        if (fOk) {

            // save a pointer into the subagent view list
            tfxInfo->tfxViews[i].mibView = &supportedViews[i];

            // save newly allocated view hash table
            tfxInfo->tfxViews[i].hashTable = tmpHashTable;
        }
    }

    // validate
    if (fOk) {

        SnmpTfxView tmpTfxView;

        // make sure views are sorted
        for (i=0; (i < tfxInfo->numViews); i++) {

            for(j=i+1; (j < tfxInfo->numViews); j++) {

                // in lexographic order?
                if (0 < SnmpUtilOidCmp(
                        &(tfxInfo->tfxViews[i].mibView->viewOid),
                        &(tfxInfo->tfxViews[j].mibView->viewOid))) {
                    // no, swap...
                    tmpTfxView = tfxInfo->tfxViews[i];
                    tfxInfo->tfxViews[i] = tfxInfo->tfxViews[j];
                    tfxInfo->tfxViews[i] = tmpTfxView;
                }
            }
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: Adding view [%d] %s.\n",
                tfxInfo->tfxViews[i].mibView->viewOid.idLength,
                SnmpUtilOidToA(&(tfxInfo->tfxViews[i].mibView->viewOid))
                ));

        }

    } else {

        // free structure
        FreeTfxInfo(tfxInfo);

        // reinitialize
        tfxInfo = NULL;
    }

    return (LPVOID)tfxInfo;
}

SNMPAPI
SNMP_FUNC_TYPE
SnmpTfxQuery(
    SnmpTfxHandle        tfxHandle,
    BYTE                 requestType,
    RFC1157VarBindList * vbl,
    AsnInteger *         errorStatus,
    AsnInteger *         errorIndex
    )
{
    SnmpExtQueryList ql;
    SnmpTfxInfo *tfxInfo = tfxHandle;
    int i;

    // initialize
    ql.query  = NULL;
    ql.len    = 0;
    ql.action = requestType;

    // disassemble varbinds
    VarBindListToQueryList(
        (SnmpTfxInfo*)tfxHandle,
        vbl,
        &ql,
        errorStatus,
        errorIndex
        );

    // process queries
    ProcessQueryList(
        (SnmpTfxInfo*)tfxHandle,
        &ql,
        vbl,
        errorStatus,
        errorIndex
        );

    // reassemble varbinds
    QueryListToVarBindList(
        (SnmpTfxInfo*)tfxHandle,
        &ql,
        vbl,
        errorStatus,
        errorIndex
        );

    return TRUE;
}


VOID
SNMP_FUNC_TYPE
SnmpTfxClose(
    SnmpTfxHandle tfxHandle
    )
{
    // simply treat as info and release
    FreeTfxInfo((SnmpTfxInfo *)tfxHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\oid.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    oid.c

Abstract:

    Contains routines to manipulatee object identifiers.

        SnmpUtilOidCpy
        SnmpUtilOidAppend
        SnmpUtilOidNCmp
        SnmpUtilOidCmp
        SnmpUtilOidFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <limits.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidCpy(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc  
    )

/*++

Routine Description:

    Copy an object identifier.

Arguments:

    pOidDst - pointer to structure to receive OID.

    pOidSrc - pointer to OID to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointers
    if (pOidDst != NULL) {

        // initialize
        pOidDst->ids = NULL;
        pOidDst->idLength = 0;    

        // check for subids
        if ((pOidSrc != NULL) &&
            (pOidSrc->ids != NULL) &&
            (pOidSrc->idLength != 0)) {

            // check for arithmetic overflow
            if (pOidSrc->idLength > UINT_MAX/sizeof(UINT)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: pOidSrc->idLength 0x%x will overflow.\n",
                    pOidSrc->idLength
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
                
                return nResult;
            }

            // attempt to allocate the subids
            pOidDst->ids = (UINT *)SnmpUtilMemAlloc(
                                    pOidSrc->idLength * sizeof(UINT)
                                    );    

            // validate pointer
            if (pOidDst->ids != NULL) {

                // transfer the oid length
                pOidDst->idLength = pOidSrc->idLength;
                
                // transfer subids
                memcpy(pOidDst->ids, 
                       pOidSrc->ids, 
                       pOidSrc->idLength * sizeof(UINT) 
                       );         

                nResult = SNMPAPI_NOERROR; // success...    

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: could not allocate oid.\n"
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
            }

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: copying a null oid.\n"
                ));
            
            nResult = SNMPAPI_NOERROR; // success...
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null oid pointer during copy.\n"
            ));

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nResult;
} 


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidAppend(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc 
    )

/*++

Routine Description:

    Append source OID to destination OID

Arguments:

    pOidDst - pointer to structure to receive combined OID.

    pOidSrc - pointer to OID to append.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointers
    if (pOidDst != NULL) {

        // check if there are subids
        if ((pOidSrc != NULL) &&
            (pOidSrc->ids != NULL) &&
            (pOidSrc->idLength != 0)) {

            // calculate the total number of subidentifiers
            UINT nIds;

            // check for arithmetic overflow
            if (pOidDst->idLength > (UINT_MAX - pOidSrc->idLength)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: combined oid too large. Dst oid len 0x%x, Src oid len 0x%x.\n",
                    pOidDst->idLength, pOidSrc->idLength
                    ));

                SetLastError(SNMP_BERAPI_OVERFLOW);
                
                return nResult;
            }

            nIds = pOidDst->idLength + pOidSrc->idLength;
            
            // validate number of subids    
            if (nIds <= SNMP_MAX_OID_LEN) {

                // attempt to allocate the subidentifiers
                UINT * pIds = (UINT *)SnmpUtilMemReAlloc(
                                            pOidDst->ids, 
                                            nIds * sizeof(UINT)
                                            );

                // validate pointer
                if (pIds != NULL) {

                    // transfer pointer
                    pOidDst->ids = pIds;

                    // transfer subids
                    memcpy(&pOidDst->ids[pOidDst->idLength], 
                           pOidSrc->ids, 
                           pOidSrc->idLength * sizeof(UINT) 
                           );

                    // transfer oid length
                    pOidDst->idLength = nIds;

                    nResult = SNMPAPI_NOERROR; // success...

                } else {

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: API: could not allocate oid.\n"
                        ));

                    SetLastError(SNMP_MEM_ALLOC_ERROR);
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: combined oid too large.\n"
                    ));

                SetLastError(SNMP_BERAPI_OVERFLOW);
            }

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: appending a null oid.\n"
                ));
            
            nResult = SNMPAPI_NOERROR; // success...
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null oid pointer during copy.\n"
            ));

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nResult;
}


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidNCmp(
    AsnObjectIdentifier * pOid1, 
    AsnObjectIdentifier * pOid2,
    UINT                  nSubIds               
    )

/*++

Routine Description:

    Compares two OIDs up to a certain subidentifier.

Arguments:

    pOid1 - pointer to first OID.

    pOid2 - pointer to second OID.

    nSubIds - maximum subidentifiers to compare.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    UINT i = 0;
//    INT nResult = 0;

    // validate pointers
    if ((pOid1 != NULL) &&
        (pOid2 != NULL)) {

        // calculate maximum number of subidentifiers to compare
        UINT nMaxIds = min(nSubIds, min(pOid1->idLength, pOid2->idLength));

        while(i < nMaxIds)
        {
            if (pOid1->ids[i] != pOid2->ids[i])
                break;
            i++;
        }

        // comparision length less than either OID lengths; components equals
        if (i == nSubIds)
            return 0;

        // difference encountered before either OID endings and before the
        // requested comparision length
        if (i < nMaxIds)
            return (pOid1->ids[i] < pOid2->ids[i])? -1 : 1;

        // one OID is shorter than the requested comparision length
        return pOid1->idLength - pOid2->idLength;
    }

    return 0;
} 


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidCmp(
    AsnObjectIdentifier * pOid1, 
    AsnObjectIdentifier * pOid2
    )

/*++

Routine Description:

    Compares two OIDs.

Arguments:

    pOid1 - pointer to first OID.

    pOid2 - pointer to second OID.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    // forward request to the function above
    return SnmpUtilOidNCmp(pOid1,pOid2,max(pOid1->idLength,pOid2->idLength));
}


VOID
SNMP_FUNC_TYPE 
SnmpUtilOidFree(
    AsnObjectIdentifier * pOid
    )

/*++

Routine Description:

    Releases memory associated with OID.

Arguments:

    pOid - pointer to OID to free.

Return Values:

    None.

--*/

{
    // validate 
    if (pOid != NULL) {

        // release subids memory
        SnmpUtilMemFree(pOid->ids);

        // re-initialize
        pOid->idLength = 0;
        pOid->ids      = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\vbl.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    vbl.c

Abstract:

    Contains routines to manipulate variable binding lists.

        SnmpUtilVarBindListCpy
        SnmpUtilVarBindListFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <limits.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilVarBindListCpy(
    SnmpVarBindList * pVblDst, 
    SnmpVarBindList * pVblSrc  
    )

/*++

Routine Description:

    Copies a variable binding list.

Arguments:

    pVblDst - pointer to structure to receive VarBindList.

    pVblSrc - pointer to VarBindList to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    UINT i;
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointer 
    if (pVblDst != NULL) {

        // initialize
        pVblDst->list = NULL;
        pVblDst->len  = 0;

        // check for varbinds    
        if ((pVblSrc != NULL) &&
            (pVblSrc->list != NULL) &&
            (pVblSrc->len != 0)) {

            // check for arithmetic overflow
            if (pVblSrc->len > UINT_MAX/sizeof(SnmpVarBind)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: pVblSrc->len 0x%x will overflow\n",
                    pVblSrc->len
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
                
                return nResult;
            }

            // attempt to allocate varbinds
            pVblDst->list = SnmpUtilMemAlloc(
                                pVblSrc->len * sizeof(SnmpVarBind)
                                );

            // validate pointer
            if (pVblDst->list != NULL) {

                // loop through the varbinds
                for (i = 0; i < pVblSrc->len; i++) {

                    // copy individual varbind
                    nResult = SnmpUtilVarBindCpy(   
                                    &pVblDst->list[i], 
                                    &pVblSrc->list[i]
                                    );

                    // validate return code
                    if (nResult == SNMPAPI_NOERROR) {            

                        // increment
                        pVblDst->len++; // success...
                        
                    } else {
            
                        break; // failure...    
                    }
                }
            
            } else {
            
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: could not allocate varbinds.\n"
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
            }

        } else {

            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: copying null varbindlist.\n"
                ));
        
            nResult = SNMPAPI_NOERROR; // success..,
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null varbindlist pointer.\n"
            ));
    
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    // make sure we cleanup    
    if (nResult == SNMPAPI_ERROR) {

        // release new varbinds
        SnmpUtilVarBindListFree(pVblDst);
    }

    return nResult;
}


VOID
SNMP_FUNC_TYPE 
SnmpUtilVarBindListFree(
    SnmpVarBindList * pVbl
    )

/*++

Routine Description:

    Frees memory associated with variable binding list.

Arguments:

    pVbl - pointer to VarBindList to free.

Return Values:

    None. 

--*/

{
    UINT i;

    // loop throught varbinds
    for (i = 0; i < pVbl->len; i++) {

        // release individual varbind
        SnmpUtilVarBindFree(&pVbl->list[i]);
    }

    // release actual list
    SnmpUtilMemFree(pVbl->list);

    // re-initialize
    pVbl->list = NULL;
    pVbl->len  = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\string.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    string.c

Abstract:

    Contains string conversion routines.

        SnmpUtilIdsToA
        SnmpUtilOidToA

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <stdio.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MAX_STRING_LEN  512 
#define MAX_SUBIDS_LEN  16  


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSTR
SNMP_FUNC_TYPE
SnmpUtilIdsToA(
    UINT * pIds, 
    UINT   nIds
    )

/*++

Routine Description:

    Converts OID subidentifiers into string.

Arguments:

    pIds - pointer to subidentifiers.

    nIds - number of subidentifiers.

Return Values:

    Returns pointer to string representation. 

--*/

{
    UINT i;
    UINT j;

    static char szBuf[MAX_STRING_LEN+MAX_SUBIDS_LEN];
	static char szId[MAX_SUBIDS_LEN];

    if ((pIds != NULL) && (nIds != 0)) {
                                     
        j = sprintf(szBuf, "%d", pIds[0]);

        for (i = 1; (i < nIds) && (j < MAX_STRING_LEN); i++) {
			j += sprintf(szId, ".%d", pIds[i]);
			if (j >= (MAX_STRING_LEN + MAX_SUBIDS_LEN)-3)
			{
				strcat(szBuf, "...");
				break;
			}
            else
				strcat(szBuf, szId);
        }

    } else {
                        
        sprintf(szBuf, "<null oid>");
    }

    return szBuf;
} 


LPSTR
SNMP_FUNC_TYPE
SnmpUtilOidToA(
    AsnObjectIdentifier * pOid
    )

/*++

Routine Description:

    Converts OID into string.

Arguments:

    pOid - pointer to object identifier.

Return Values:

    Returns pointer to string representation. 

--*/

{
    UINT * pIds = NULL;
    UINT   nIds = 0;

    if (pOid != NULL) {

        pIds = pOid->ids;
        nIds = pOid->idLength;
    }

    return SnmpUtilIdsToA(pIds, nIds); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\uniconv.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uniconv.c

Abstract:

    Routine to convert UNICODE to ASCII.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include <ntrtl.h>
#include <string.h>
#include <stdlib.h>


//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilUnicodeToAnsi(
    LPSTR   *ppSzString,
    LPWSTR  pWcsString,
    BOOLEAN bAllocBuffer)

{
    int   retCode;
    int   nAnsiStringLen;
    int   nUniStringLen;

    // make sure the parameters are valid
    if (pWcsString == NULL ||       // the unicode string should be valid
        ppSzString == NULL ||       // the output parameter should be a valid pointer
        (!bAllocBuffer && *((UNALIGNED LPSTR *) ppSzString) == NULL)) // if we are not requested to allocate the buffer,
                                                // then the supplied one should be valid
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Invalid input to SnmpUtilUnicodeToAnsi.\n"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return (-1);
    }

    nUniStringLen = wcslen(pWcsString);
    nAnsiStringLen = nUniStringLen + 1; // greatest value possible
    
    // if we are requested to alloc the output buffer..
    if (bAllocBuffer)
    {
        // ...pick up first the buffer length needed for translation.
        retCode = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pWcsString,
                    nUniStringLen + 1,  // include the null terminator in the string
                    NULL,
                    0,  // the function returns the number of bytes required for the buffer
                    NULL,
                    NULL);
        // at least we expect here the null terminator
        // if retCode is zero, something else went wrong.
        if (retCode == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: First call to WideCharToMultiByte failed [%d].\n",
                GetLastError()));

            return -1;
        }

        // adjust the length of the ANSI string to the correct value
        // !!! it includes the null terminator !!!
        nAnsiStringLen = retCode;

        // alloc here as many bytes as we need for the translation
        *((UNALIGNED LPSTR *) ppSzString) = SnmpUtilMemAlloc(nAnsiStringLen);

        // at this point we should have a valid output buffer
        if (*((UNALIGNED LPSTR *) ppSzString) == NULL)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: Memory allocation failed in SnmpUtilUnicodeToAnsi [%d].\n",
                GetLastError()));

            SetLastError(SNMP_MEM_ALLOC_ERROR);
            return -1;
        }
    }

    // if bAllocBuffer is false, we assume the buffer given
    // by the caller is sufficiently large to hold all the ANSI string
    retCode = WideCharToMultiByte(
                CP_ACP,
                0,
                pWcsString,
                nUniStringLen + 1,
                *((UNALIGNED LPSTR *) ppSzString),
                nAnsiStringLen,
                NULL,
                NULL);

    // nothing should go wrong here. However, if something went wrong...
    if (retCode == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Second call to WideCharToMultiByte failed [%d].\n",
            GetLastError()));

        // ..we made it, we kill it
        if (bAllocBuffer)
        {
            SnmpUtilMemFree(*((UNALIGNED LPSTR *) ppSzString));
            *((UNALIGNED LPSTR *) ppSzString) = NULL;
        }
        // bail with error
        return -1;
    }

    // at this point, the call succeeded.
    return 0;
 
}

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilUnicodeToUTF8(
    LPSTR   *pUtfString,
    LPWSTR  wcsString,
    BOOLEAN bAllocBuffer)
{
    int retCode;
    int nWcsStringLen;
    int nUtfStringLen;

    // Bug# 268748, lmmib2.dll uses this API and causes exception here on IA64 platform.
    // it is possible that pUtfString points to a pointer which is not aligned because the
    // pointer is embedded in a buffer allocated in lmmib2.dll.
    // Other functions in this file are fixed with this potential problem too.

    // make sure the parameters are valid
    if (wcsString == NULL ||                    // the unicode string should be valid
        pUtfString == NULL ||                   // the output parameter should be a valid pointer
        (!bAllocBuffer && *((UNALIGNED LPSTR *) pUtfString) == NULL)) // if we are not requested to allocate the buffer,
                                                // then the supplied one should be valid
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Invalid input to SnmpUtilUnicodeToUTF8.\n"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return (-1);
    }

    nWcsStringLen = wcslen(wcsString);
    nUtfStringLen = 3 * (nWcsStringLen + 1);    // initialize the lenght of the output buffer with the
                                                // greatest value possible

    // if we are requested to alloc the output buffer..
    if (bAllocBuffer)
    {
        // ...pick up first the buffer length needed for translation.
        retCode = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    wcsString,
                    nWcsStringLen + 1,  // include the null terminator in the string
                    NULL,
                    0,
                    NULL,
                    NULL);
        // at least we expect here the null terminator
        // if retCode is zero, something else went wrong.
        if (retCode == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: First call to WideCharToMultiByte failed [%d].\n",
                GetLastError()));

            return -1;
        }

        // adjust the length of the utf8 string to the correct value
        // !!! it includes the null terminator !!!
        nUtfStringLen = retCode;

        // alloc here as many bytes as we need for the translation
        *((UNALIGNED LPSTR *) pUtfString) = SnmpUtilMemAlloc(nUtfStringLen);

        // at this point we should have a valid output buffer
        if (*((UNALIGNED LPSTR *) pUtfString) == NULL)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: Memory allocation failed in SnmpUtilUnicodeToUTF8 [%d].\n",
                GetLastError()));

            SetLastError(SNMP_MEM_ALLOC_ERROR);
            return -1;
        }
    }
    // if bAllocBuffer is false, we assume the buffer given
    // by the caller is sufficiently large to hold all the UTF8 string

    retCode = WideCharToMultiByte(
                CP_UTF8,
                0,
                wcsString,
                nWcsStringLen + 1,
                *((UNALIGNED LPSTR *) pUtfString),
                nUtfStringLen,
                NULL,
                NULL);

    // nothing should go wrong here. However, if smth went wrong...
    if (retCode == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Second call to WideCharToMultiByte failed [%d].\n",
            GetLastError()));

        // ..we made it, we kill it
        if (bAllocBuffer)
        {
            SnmpUtilMemFree(*((UNALIGNED LPSTR *) pUtfString));
            *((UNALIGNED LPSTR *) pUtfString) = NULL;
        }
        // bail with error
        return -1;
    }

    // at this point, the call succeeded.
    return 0;
}

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilAnsiToUnicode(
    LPWSTR  *ppWcsString,
    LPSTR   pSzString,
    BOOLEAN bAllocBuffer)

{
    int retCode;
    int nAnsiStringLen;
    int nWcsStringLen;

    // check the consistency of the parameters first
    if (pSzString == NULL ||        // the input parameter must be valid
        ppWcsString == NULL ||      // the pointer to the output parameter must be valid
        (!bAllocBuffer && *((UNALIGNED LPWSTR *) ppWcsString) == NULL)) // if we are not required to allocate the output parameter
                                                // then the output buffer must be valid
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Invalid input to SnmpUtilAnsiToUnicode.\n"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    nAnsiStringLen = strlen(pSzString);  // the length of the input ANSI string
    nWcsStringLen = nAnsiStringLen + 1;  // greatest value possible

    if (bAllocBuffer)
    {
        retCode = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    pSzString,
                    nAnsiStringLen + 1, // including the null terminator
                    NULL,
                    0); // the function returns the required buffer size, in wide characters

        // at least we expect here the null terminator
        // if retCode is zero, something else went wrong.
        if (retCode == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: First call to MultiByteToWideChar failed [%d].\n",
                GetLastError()));

            return -1;
        }

        // adjust the length of the Uincode string to the correct value
        nWcsStringLen = retCode;

        // alloc here as many bytes as we need for the translation
        // !!! it includes the null terminator !!!
        *((UNALIGNED LPWSTR *) ppWcsString) = SnmpUtilMemAlloc(nWcsStringLen * sizeof(WCHAR));

        // at this point we should have a valid output buffer
        if (*((UNALIGNED LPWSTR *) ppWcsString) == NULL)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: Memory allocation failed in SnmpUtilAnsiToUnicode [%d].\n",
                GetLastError()));

            SetLastError(SNMP_MEM_ALLOC_ERROR);
            return -1;
        }
    }

    // if bAllocBuffer is false, we assume the buffer given
    // by the caller is sufficiently large to hold all the Unicode string

    retCode = MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                pSzString,
                nAnsiStringLen + 1,
                *((UNALIGNED LPWSTR *) ppWcsString),
                nWcsStringLen);

    // nothing should go wrong here. However, if something went wrong...
    if (retCode == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Second call to MultiByteToWideChar failed [%d].\n",
            GetLastError()));

        // ..we made it, we kill it
        if (bAllocBuffer)
        {
            SnmpUtilMemFree(*((UNALIGNED LPWSTR *) ppWcsString)); 
            *((UNALIGNED LPWSTR *) ppWcsString) = NULL; 
        }
        // bail with error
        return -1;
    }

    // at this point, the call succeeded.
    return 0;
}

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilUTF8ToUnicode(
    LPWSTR  *pWcsString,
    LPSTR   utfString,
    BOOLEAN bAllocBuffer)

{
    int retCode;
    int nUtfStringLen;
    int nWcsStringLen;

    // check the consistency of the parameters first
    if (utfString == NULL ||                    // the input parameter must be valid
        pWcsString == NULL ||                   // the pointer to the output parameter must be valid
        (!bAllocBuffer && *((UNALIGNED LPWSTR *) pWcsString) == NULL)) // if we are not required to allocate the output parameter
                                                // then the output buffer must be valid
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Invalid input to SnmpUtilUTF8ToUnicode.\n"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    nUtfStringLen = strlen(utfString);  // the length of the input utf8 string
    nWcsStringLen = nUtfStringLen + 1;  // greatest value possible

    if (bAllocBuffer)
    {
        retCode = MultiByteToWideChar(
                    CP_UTF8,
                    0,
                    utfString,
                    nUtfStringLen + 1,
                    NULL,
                    0);

        // at least we expect here the null terminator
        // if retCode is zero, something else went wrong.
        if (retCode == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: First call to MultiByteToWideChar failed [%d].\n",
                GetLastError()));

            return -1;
        }

        // adjust the length of the utf8 string to the correct value
        nWcsStringLen = retCode;

        // alloc here as many bytes as we need for the translation
        // !!! it includes the null terminator !!!
        *((UNALIGNED LPWSTR *) pWcsString) = SnmpUtilMemAlloc(nWcsStringLen * sizeof(WCHAR));

        // at this point we should have a valid output buffer
        if (*((UNALIGNED LPWSTR *) pWcsString) == NULL)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SNMPAPI: Memory allocation failed in SnmpUtilUTF8ToUnicode [%d].\n",
                GetLastError()));

            SetLastError(SNMP_MEM_ALLOC_ERROR);
            return -1;
        }
    }

    // if bAllocBuffer is false, we assume the buffer given
    // by the caller is sufficiently large to hold all the UTF8 string

    retCode = MultiByteToWideChar(
                CP_UTF8,
                0,
                utfString,
                nUtfStringLen + 1,
                *((UNALIGNED LPWSTR *) pWcsString),
                nWcsStringLen);

    // nothing should go wrong here. However, if smth went wrong...
    if (retCode == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SNMPAPI: Second call to MultiByteToWideChar failed [%d].\n",
            GetLastError()));

        // ..we made it, we kill it
        if (bAllocBuffer)
        {
            SnmpUtilMemFree(*((UNALIGNED LPWSTR *) pWcsString)); 
            *((UNALIGNED LPWSTR *) pWcsString) = NULL; 
        }
        // bail with error
        return -1;
    }

    // at this point, the call succeeded.
    return 0;
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\sysoid.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    sysoid.c

Abstract:

    Contains enterprise oid routine.

        SnmpSvcGetEnterpriseOid

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern AsnObjectIdentifier * g_pEnterpriseOid;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

AsnObjectIdentifier *
SNMP_FUNC_TYPE
SnmpSvcGetEnterpriseOID(
    )

/*++

Routine Description:

    Retrieves enterprise oid for SNMP process.

Arguments:

    None.

Return Values:

    Returns pointer to enterprise oid.

--*/

{
    // return system oid
    return g_pEnterpriseOid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\vb.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    vb.c

Abstract:

    Contains routines to manipulate variable bindings.

        SnmpUtilVarBindCpy
        SnmpUtilVarBindFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilVarBindCpy(
    SnmpVarBind * pVbDst,
    SnmpVarBind * pVbSrc
    )

/*++

Routine Description:

    Copies a variable binding.

Arguments:

    pVbDst - pointer to structure to receive VarBind.

    pVbSrc - pointer to VarBind to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointer
    if (pVbDst != NULL) {
        
        // initialize destination
        pVbDst->value.asnType = ASN_NULL;

        // validate pointer
        if (pVbSrc != NULL) {

            // copy the variable's name from source to destination
            nResult = SnmpUtilOidCpy(&pVbDst->name, &pVbSrc->name);

            // validate return code
            if (nResult == SNMPAPI_NOERROR) {
        
                // copy the variable's value from source to destination            
                nResult = SnmpUtilAsnAnyCpy(&pVbDst->value, &pVbSrc->value);
            }
        
        } else {

            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: copying null varbind.\n"
                ));
        
            nResult = SNMPAPI_NOERROR; // success..,
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null varbind pointer.\n"
            ));
    
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    // validate return code
    if (nResult == SNMPAPI_ERROR) {
        
        // release new variable 
        SnmpUtilVarBindFree(pVbDst);
    }

    return nResult;
} 


VOID
SNMP_FUNC_TYPE 
SnmpUtilVarBindFree(
    SnmpVarBind * pVb 
    )

/*++

Routine Description:

    Releases memory associated with variable binding.

Arguments:

    pVb - pointer to VarBind to release.

Return Values:

    None. 

--*/

{
    // validate
    if (pVb != NULL) {
        
        // release variable name    
        SnmpUtilOidFree(&pVb->name);

        // release variable value
        SnmpUtilAsnAnyFree(&pVb->value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\configs.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <iostream.h>
#include <fstream.h>
#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include "Configs.hpp"
#include "Debug.hpp"

Configs theConfigs;

Configs::Configs()
{
	m_pszOutputFilename = NULL;
	m_nMaxErrors = CFG_DEF_MAXERRORS;
	m_dwFlags = CFG_PRINT_LOGO;

}

Configs::~Configs()
{
	if (m_pszOutputFilename != NULL)
		delete m_pszOutputFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\dll\uptime.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    uptime.c

Abstract:

    Contains routines to calculate sysUpTime.

        SnmpSvcInitUptime
        SnmpSvcGetUptime
        SnmpSvcGetUptimeFromTime

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include <ntfuncs.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD g_dwUpTimeReference = 0;
LONGLONG g_llUpTimeReference = 0;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define INVALID_UPTIME  0xFFFFFFFF


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
SNMP_FUNC_TYPE 
SnmpSvcInitUptime(
    )

/*++

Routine Description:

    Initializes sysUpTime reference for SNMP process.

Arguments:

    None.

Return Values:

    Returns sysUpTime reference to pass to subagents. 

--*/

{
    NTSTATUS NtStatus;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    // obtain reference the outdated way
    g_dwUpTimeReference = GetCurrentTime();


    // query time in spiffy new precise manner        
    NtStatus = NtQuerySystemInformation(
                        SystemTimeOfDayInformation,
                        &TimeOfDay,
                        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                        NULL
                        );
        
    // validate return code
    if (NT_SUCCESS(NtStatus)) {

        // initialize higher precision startup time         
        g_llUpTimeReference = TimeOfDay.CurrentTime.QuadPart;
    }
    

    //
    // The algorithm for subagents to calculate sysUpTime
    // is based on GetCurrentTime() which returns the time 
    // in milliseconds and therefore wraps every 49.71 days.
    // RFC1213 specifies that sysUpTime is to be returned in
    // centaseconds but we cannot break existing subagents.
    // The old value is returned to the master agent here 
    // but newer subagents should use SnmpUtilGetUpTime.
    //

    return g_dwUpTimeReference;
} 


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptime(
    )

/*++

Routine Description:

    Retrieves sysUpTime for SNMP process.

Arguments:

    None.

Return Values:

    Returns sysUpTime value for use by subagents. 

--*/

{
    DWORD dwUpTime = INVALID_UPTIME;
        
    NTSTATUS NtStatus;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    // query time in spiffy new precise manner        
    NtStatus = NtQuerySystemInformation(
                        SystemTimeOfDayInformation,
                        &TimeOfDay,
                        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                        NULL
                        );
        
    // validate return code
    if (NT_SUCCESS(NtStatus)) {
        LARGE_INTEGER liUpTime;
        LARGE_INTEGER liUpTimeInCentaseconds;

        // calculate difference from reference
        liUpTime.QuadPart = TimeOfDay.CurrentTime.QuadPart - 
                                                    g_llUpTimeReference;
                                    
        // convert 100ns units (10^-7) into centasecond units (10^-2)
        liUpTimeInCentaseconds = RtlExtendedLargeIntegerDivide(
                                            liUpTime,
                                            100000,
                                            NULL
                                            );

        // convert large integer to dword value
        dwUpTime = (DWORD)(LONGLONG)liUpTimeInCentaseconds.QuadPart;
    
    } else if (g_dwUpTimeReference != 0) {

        // calculate difference from reference
        dwUpTime = (GetCurrentTime() - g_dwUpTimeReference) / 10;
    }

    return dwUpTime;
}

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptimeFromTime(
    DWORD dwUpTime
    )

/*++

Routine Description:

    Retrieves sysUpTime value for a given tick count.

Arguments:

    dwUpTime - stack uptime (in centaseconds) to convert to sysUpTime

Return Values:

    Returns sysUpTime value for use by subagents.

--*/

{
    DWORD dwUpTimeReferenceInCentaseconds;

    // convert 100ns units (10^-7) into centasecond units (10^-2)
    dwUpTimeReferenceInCentaseconds = (DWORD)(g_llUpTimeReference / 100000);

    if (dwUpTime < dwUpTimeReferenceInCentaseconds) {
        return 0;
    }

    // calculate difference from reference
    return dwUpTime - dwUpTimeReferenceInCentaseconds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\common\lib\dummy.c ===
//
// The TCP/IP performance counter DLL loads INETMIB1.DLL
// directly and impersonates the SNMP master agent.  In
// order to accomplish this the DLL needs some of the
// utilities included in SNMPAPI.DLL but the Perf dudes
// do not want to load another DLL into their process.
//
// This static library hopefully will be only temporary
// until we can get the performance DLL rewritten to use
// the new MIB2UTIL.DLL.
//

#include "..\dll\any.c"
#include "..\dll\dbg.c"
#include "..\dll\mem.c"
#include "..\dll\oid.c"
#include "..\dll\octets.c"
#include "..\dll\vb.c"
#include "..\dll\vbl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\configs.hpp ===
#ifndef _CONFIGS_HPP
#define _CONFIGS_HPP

#define CFG_PRINT_LOGO		0x01
#define	CFG_PRINT_TREE		0x02
#define CFG_PRINT_NODE		0x04
#define CFG_VERB_ERROR		0x08
#define CFG_VERB_WARNING	0x10

#define CFG_DEF_MAXERRORS	10

class Configs
{
public:
	LPSTR	m_pszOutputFilename;
	int		m_nMaxErrors;
	DWORD	m_dwFlags;

	Configs();
	~Configs();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\debug.hpp ===
#ifndef _DEBUG_H
#define _DEBUG_H

void _coreASSERT(const char *filename, int line, const char *errMst, void (*cleanup)());

void dumpOnBuild();

#ifdef _ASSERT
#undef _ASSERT
#endif

// DESCRIPTION:
//		macro useful for run-time debugging
//		it tels exactly which source and which line an error occured.
//		it also calls a user-supplied clean-up function, if available
//		and exits the program.
// PARAMETERS:
//		(in)b - boolean condition that has to be checked
//		(in)s - error message string to be displayed if assertion fails
//		(in)f - user-defined function to be called for cleanup before exiting
#define _ASSERT(b,s,f)											\
	{															\
		if (!(b))												\
		{														\
			_coreASSERT(__FILE__, __LINE__, (s), (f));			\
			exit(-1);											\
		}														\
	}

// DESCRIPTION
//		macro useful for parameter checking.
// PARAMETERS
//		(in)b - boolean condition that has to be checked
//		(in)v - value to be returned if condition fails
#define _VERIFY(b,v)													\
	{																	\
		if (!(b))														\
		{																\
			_coreASSERT(__FILE__, __LINE__, " _VERIFY failure ", NULL);	\
			return v;													\
		}																\
	}
															
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\mibcc.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mibcc.cpp

Abstract:

    SMI compiler backend for MIB database.

Author:

    Florin Teodorescu (florint)   26-Jan-1998

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <io.h>
#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "Debug.hpp"
#include "OidToF.hpp"
#include "Configs.hpp"

// error container defined in debug.cpp
extern SIMCErrorContainer errorContainer;
extern Configs	theConfigs;

int InitTree(SIMCParseTree &theTree, int argc, char *argv[])
{
	UINT uFileCount;
	UINT uFileNameLen;
	UINT uErrLevel;
	UINT uSMIVersion;

	/* process command line options */
	--argc;
	++argv;
	while ((argc > 0) && ((argv[0][0] == '-') || (argv[0][0] == '/')))
	{
		switch (argv[0][1])
		{
		case '?':
        case 'h':
        case 'H':
			cout << "usage: mibcc [-?] [-e] [-l] [-n] [-o] [-t] -[w] [files...]\n";
			cout << "   MibCC compiles the specified SNMP MIB files.\n";
			cout << "      -?        usage.\n";
			cout << "      -eX       stop after X Errors. (default = 10)\n";
			cout << "      -l        do not print Logo.\n";
			cout << "      -n        print each Node as it is added.\n";
			cout << "      -o[file]  output file name. (no file by default)\n";
			cout << "      -t        print the mib Tree when finished.\n";
			cout << "      -wX       set Warning level.\n";
			cout << "                0=silent; 1=errors only; 2=warnings only; 3=both\n";
			cout << "                (default = 0)\n";
			exit (0);
			break;
		case 'e':
		case 'E':
			theConfigs.m_nMaxErrors = atoi(argv[0]+2);
			break;
		case 'l':
		case 'L':
			theConfigs.m_dwFlags &= ~CFG_PRINT_LOGO;
			break;
        case 'n':
		case 'N':
			theConfigs.m_dwFlags |= CFG_PRINT_NODE;
			break;
		case 'o':
		case 'O':
			uFileNameLen = strlen(argv[0]+2);
			 
			if (uFileNameLen == 0)
			{
				if (theConfigs.m_pszOutputFilename != NULL)
					delete theConfigs.m_pszOutputFilename;
				theConfigs.m_pszOutputFilename = NULL;
			}
			else
			{
				if (theConfigs.m_pszOutputFilename != NULL)
					delete (theConfigs.m_pszOutputFilename);
				theConfigs.m_pszOutputFilename = new char[uFileNameLen+1];
				_ASSERT(theConfigs.m_pszOutputFilename != NULL, "Memory Allocation error!", NULL);
				strcpy(theConfigs.m_pszOutputFilename, argv[0]+2);
			}
			break;
        case 't':
        case 'T':
            theConfigs.m_dwFlags |= CFG_PRINT_TREE;
            break;
        case 'w':
        case 'W':
			uErrLevel = atoi(argv[0]+2);
			theConfigs.m_dwFlags |= (uErrLevel == 1 || uErrLevel == 3 ? CFG_VERB_ERROR : 0) | 
									(uErrLevel == 2 || uErrLevel == 3 ? CFG_VERB_WARNING : 0);
            break;
		case 'v':
		case 'V':
			uSMIVersion = atoi(argv[0]+2);

			if (uSMIVersion > 2)
				cout << "mibcc: wrong value for -v option; ignored\n";
			else
				theTree.SetSnmpVersion(uSMIVersion);
			break;
        default:
            cout << "mibcc: unrecognized option '" << argv[0] << "'\n";
            cout << "mibcc -? for usage\n";
            exit (-1);
            break;
		}
		--argc;
		++argv;
	}

	if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
	{
		cout << "Microsoft (R) SNMP MIB Compiler Version 2.00\n";
		cout << "Copyright (c) Microsoft Corporation 1998.  All rights reserved.\n";
	}

	for(uFileCount = 0; argc>0; argc--, argv++)
	{
		struct _finddata_t findData;
                intptr_t handle;

		// check snmp syntax
		handle = _findfirst(argv[0], &findData);
		if (handle != -1)
		{
			do
			{
				if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
				{
					cout << "mibcc: parsing " << findData.name << "\n";
					cout.flush();
				}
				uFileCount++;
				_ASSERT(theTree.CheckSyntax(findData.name), "CheckSyntax() failed!", dumpOnBuild);
			}while(_findnext(handle, &findData) != -1);
		}
	}

	if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
	{
		// do not print anything further if no files processed
		if (uFileCount == 0)
			theConfigs.m_dwFlags &= ~CFG_PRINT_LOGO;

		cout << "mibcc: total files processed: " << uFileCount << "\n";
	}

    cout.flush();
	return 0;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Entry point                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT 
__cdecl 
main(
    IN INT   argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    Program entry point. 

Arguments:

    argc - number of command line arguments.
    argv - pointer to array of command line arguments.

Return Values:

    Returns 0 if successful.

--*/

{
    SIMCParseTree		theTree(&errorContainer);
	SIMCOidTree			*pTheOidTree;
	OidToFile			oidDumpTree;

	_ASSERT(InitTree(theTree, argc, argv)==0, "InitTree() failed!", dumpOnBuild);

    // resolve symbols
    _ASSERT(theTree.Resolve(FALSE), "Resolve() failed!", dumpOnBuild);

    // check semantics
    _ASSERT(theTree.CheckSemantics(), "CheckSemantics() failed!", dumpOnBuild);

	// retrieve the Oid Tree

	pTheOidTree = (SIMCOidTree *)theTree.GetOidTree();
	_ASSERT(pTheOidTree != NULL, "Oid Tree is NULL", NULL);
	oidDumpTree.SetOidTree(pTheOidTree);

	_ASSERT(oidDumpTree.SetMibFilename(theConfigs.m_pszOutputFilename)==0, "SetMibFilename failed!", NULL);
	_ASSERT(oidDumpTree.MergeBuiltIn()==0, "MergeBuiltIn failed!", NULL);
	_ASSERT(oidDumpTree.Scan()==0, "Oid Scan() failed", NULL);

	if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
	{
		if (theConfigs.m_dwFlags & CFG_PRINT_NODE)
			cout << '\n';
		if (theConfigs.m_pszOutputFilename != NULL)
			cout << "mibcc: writing compiled file '" << theConfigs.m_pszOutputFilename << "'\n";
		else
			cout << "mibcc: no output file generated" << "\n";
	}
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\oid.cpp ===
#include <iostream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include "debug.hpp"
#include "Oid.hpp"

// DESCRIPTION;
//     constructor, implicitly construct m_nOIDs and m_szOIDs
Oid::Oid()
{
}

// DESCRIPTION:
//     Adds a new Oid component to the END of the internal arrays!
// PARAMETERS:
//     (in) integer component of the Oid
//     (out) symbolic name of the component
// RETURN VALUE:
//      0 on success, -1 on failure
int Oid::AddComponent(int nOidComp, const char * szOidComp)
{
	char *szOidCopy = NULL;

	_VERIFY(m_nOidComp.Add((WORD)nOidComp)!=-1, -1);
	if (szOidComp != NULL)
	{
		szOidCopy = new char [strlen(szOidComp)+1];
		_VERIFY(szOidCopy != NULL, -1);
		strcpy(szOidCopy, szOidComp);
	}
	m_szOidComp.Add((CObject *)szOidCopy);
	return 0;
}

// DESCRIPTION:
//      Reverses the components of the OID from both
//		m_nOidComp and m_szOidComp
// RETURN VALUE:
//      0 on success, -1 on failure
int Oid::ReverseComponents()
{
	INT_PTR fwd, rev;

	for (fwd = 0, rev=m_nOidComp.GetSize()-1;
		 fwd < rev;
		 fwd ++, rev--)
	{
		int nOidComp;
		const char *szOidComp;

		nOidComp = m_nOidComp.GetAt(fwd);
		m_nOidComp.SetAt(fwd, m_nOidComp.GetAt(rev));
		m_nOidComp.SetAt(rev, (WORD)nOidComp);

		szOidComp = (const char *)m_szOidComp.GetAt(fwd);
		m_szOidComp.SetAt(fwd, m_szOidComp.GetAt(rev));
		m_szOidComp.SetAt(rev, (CObject *)szOidComp);
	}
	return 0;
}

// DESCRIPTION:
//      Output operator, displays the whole Oid
ostream& operator<< (ostream& outStream, const Oid& oid)
{
	INT_PTR sz = oid.m_nOidComp.GetSize();

	_ASSERT(sz == oid.m_szOidComp.GetSize(), "Size mismatch in Oid arrays", NULL);

	for (INT_PTR i=0; i<sz; i++)
	{
		unsigned int nId;
		const char *szId;

		// skip over the first component zero(0)
		if (i == 0)
			continue;

		nId = oid.m_nOidComp.GetAt(i);
		szId = (const char *)oid.m_szOidComp.GetAt(i);
		if (szId != NULL)
		{
			outStream << szId << "(";
			outStream << nId << ")";
		}
		else
			outStream << nId;
		if (i != sz-1)
			outStream << ".";
	}
	return outStream;
}

// DESCRIPTION:
//     destructor
Oid::~Oid()
{
	/*
	m_nOidComp.RemoveAll();
	for (int i=m_szOidComp.GetSize()-1; i>=0; i--)
	{
		char *szName = (char *)m_szOidComp.GetAt(i);
		if (szName != NULL)
		{
			// allocated with new in the AddComponent() member function
			delete szName;
		}
	}
	m_szOidComp.RemoveAll();
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\debug.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>

#include <afxwin.h>
#include <afxole.h>

#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>

#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "Debug.hpp"
#include "Configs.hpp"

SIMCErrorContainer errorContainer;
extern Configs theConfigs;

void _coreASSERT(const char *filename, int line, const char *errMsg, void (*cleanup)())
{
	const char *name;
	name = strrchr(filename, '\\');
	if (name != NULL)
		filename = name+1;
	cout << "Err [" << filename << ":" << line << "] - " << errMsg << "\n";
	if (cleanup != NULL)
		(*cleanup)();
}

void dumpOnBuild()
{
	SIMCErrorMessage errorMessage;

	if ( (theConfigs.m_dwFlags & (CFG_VERB_ERROR | CFG_VERB_WARNING)) == 0 )
		return;
	for (errorContainer.MoveToFirstMessage();
	     errorContainer.GetNextMessage(errorMessage) && theConfigs.m_nMaxErrors > 0;
		)
	{
		switch (errorMessage.GetSeverityLevel())
		{
		case 0:
			if (theConfigs.m_dwFlags & CFG_VERB_ERROR)
			{
				cout << errorMessage;
				theConfigs.m_nMaxErrors--;
			}
			break;
		case 1:
			if (theConfigs.m_dwFlags & CFG_VERB_WARNING)
			{
				cout << errorMessage;
				theConfigs.m_nMaxErrors--;
			}
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\oidtof.hpp ===
#include "OTScan.hpp"

#ifndef _OIDTOFILE_HPP
#define _OIDTOFILE_HPP

class SIMCOidTreeNode;

class OidToFile : public OidTreeScanner
{
	typedef struct _FileNode
	{
		long	lNextOffset;
		UINT	uNumChildren;
		UINT	uStrLen;
		LPSTR	lpszTextSubID;
		UINT	uNumSubID;
	} T_FILE_NODE;

    // mib.bin file actually needs the following platform independent format 
    // on 32bit(x86) and 64bit(ia64) environment. The uReserved field is used
    // for backward compatibility to T_FILE_NODE on 32bit platform because
    // mib.bin file format has been around since NT 3.51 time frame.
    typedef struct _FileNodeEx 
    {
        long                 lNextOffset;  // This field must remain first
        UINT                 uNumChildren;
        UINT                 uStrLen;
        UINT                 uReserved;
        UINT                 uNumSubID;
    } T_FILE_NODE_EX;

	HFILE		m_hMibFile;
	const char	*m_pszMibFilename;
public:
	OidToFile();

	// DESCRIPTION:
	//		wrapper for the base class Scan();
	//		it find first the sizes of subtrees;
	// RETURN VALUE:
	//		0 on success
	//		-1 on failure;
	virtual int Scan();

	// DESCRIPTION:
	//		Creates the output file, containing the OID encoding
	// PARAMETERS:
	//		(in) pointer to the output file name
	// RETURN VALUE:
	//		0 on success, -1 on failure
	int SetMibFilename(const char * pszMibFilename);

	// DESCRIPTION:
	//		"callback" function, called each time a
	//		tree node passes through the scan. The user
	//		should redefine this function in the derived
	//		object to perform the action desired.
	// PARAMETERS:
	//		(in) Pointer to the current node in the tree.
	//			 Nodes are supplied in lexicographic order.
	// RETURN VALUE:
	//		0  - the scanner should continue
	//		-1 - the scanner should abort.
	int OnScanNode(const SIMCOidTreeNode *pOidNode);

	~OidToFile();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\oidtof.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "Debug.hpp"
#include "Oid.hpp"
#include "OidToF.hpp"
#include "Configs.hpp"

extern Configs theConfigs;

OidToFile::OidToFile()
{
	m_hMibFile = NULL;
	m_pszMibFilename = NULL;
}

// DESCRIPTION:
//		wrapper for the base class Scan();
//		it find first the sizes of subtrees (subtree's root node included)
// RETURN VALUE:
//		0 on success
//		-1 on failure;
int OidToFile::Scan()
{
	SIMCOidTreeNode *pOidNode;
	SIMCNodeList recursionTrace;

	// get the root node from the oid tree,
	// return "error" if no tree or no root
	_VERIFY(m_pOidTree != NULL, -1);
	pOidNode = (SIMCOidTreeNode *)m_pOidTree->GetRoot();
	_VERIFY(pOidNode != NULL, -1);

	// node hasn't been scanned; _lParam=number of dependencies
	pOidNode->_lParam = (DWORD)pOidNode->GetListOfChildNodes()->GetCount();
	// initialize the recursionTree with the root node
	_VERIFY(recursionTrace.AddHead(pOidNode)!=NULL, -1);

	// start to scan the tree
	while (!recursionTrace.IsEmpty())
	{
		const SIMCNodeList *pLstChildren;

		// allways pick up the node in the head of the list
		pOidNode = recursionTrace.GetHead();

		// get the dependencies list
		pLstChildren = pOidNode->GetListOfChildNodes();

		// if there are no more dependencies to process
		// sum the children values and add to its own
		if (pOidNode->_lParam == 0)
		{
			SIMCOidTreeNode *pParent;
			const char * cszSymbol = NULL;

			_VERIFY(GetNodeSymbol(pOidNode, cszSymbol)==0, -1);

			pOidNode->_lParam = sizeof(T_FILE_NODE_EX) + (cszSymbol != NULL ? strlen(cszSymbol) : 0);

			// compute the cumulated size of the subtree
			for (POSITION p = pLstChildren->GetHeadPosition(); p != NULL;)
			{
				const SIMCOidTreeNode *pChild;

				pChild = pLstChildren->GetNext(p);
				_VERIFY(pChild!=NULL, -1);

				// Modify here!!!!
				pOidNode->_lParam += pChild->_lParam;
			}

			// decrease the number of dependencies from the parent node
			pParent = m_pOidTree->GetParentOf(pOidNode);
			if ( pParent != NULL)
			{
				pParent->_lParam--;
			}

			// delete the node from the list
			recursionTrace.RemoveHead();
		}
		else
		{
			// add the children list to the front of the recursionTrace
			for (POSITION p = pLstChildren->GetHeadPosition(); p != NULL;)
			{
				SIMCOidTreeNode *pChild;

				pChild = pLstChildren->GetNext(p);
				_VERIFY(pChild!=NULL, -1);

				pChild->_lParam = (DWORD)pChild->GetListOfChildNodes()->GetCount();
				_VERIFY(recursionTrace.AddHead(pChild)!=NULL, -1);
			}
		}
	}
	return OidTreeScanner::Scan();
}

// DESCRIPTION:
//		Creates the output file, containing the OID encoding
// PARAMETERS:
//		(in) pointer to the output file name
// RETURN VALUE:
//		0 on success, -1 on failure
int OidToFile::SetMibFilename(const char * pszMibFilename)
{
	if (m_pszMibFilename != NULL)
	{
		delete (void *)m_pszMibFilename;
		m_pszMibFilename = NULL;
	}

	if (pszMibFilename != NULL)
	{
		_VERIFY(strlen(pszMibFilename) != 0, -1);
		m_pszMibFilename = new char [strlen(pszMibFilename) + 1];
		_VERIFY(m_pszMibFilename != NULL, -1);
		strcpy((char *)m_pszMibFilename, pszMibFilename);
	}
	return 0;
}

// DESCRIPTION:
//		"callback" function, called each time a
//		tree node passes through the scan.
//		in pOidNode->_lParam there is the cumulated size
//		of the hole subtree, root included.
//		size = sizeof(T_FILE_NODE_EX) + strlen(node symbol)
// PARAMETERS:
//		(in) Pointer to the current node in the tree.
//			 Nodes are supplied in lexicographic order.
// RETURN VALUE:
//		0  - the scanner should continue
//		-1 - the scanner should abort.
int OidToFile::OnScanNode(const SIMCOidTreeNode *pOidNode)
{
	T_FILE_NODE_EX fileNode;
	char *nodeSymbol = NULL;

	// skip the '0' root of the OID tree
	if (m_pOidTree->GetParentOf(pOidNode) == NULL)
		return 0;

	if (theConfigs.m_dwFlags & CFG_PRINT_TREE)
	{
		Oid oid;

		_VERIFY(GetNodeOid(pOidNode, oid)==0, -1);
		cout << oid << "\n";
	}
	if (theConfigs.m_dwFlags & CFG_PRINT_NODE)
	{
		cout << "."; cout.flush();
	}

	// if no need to write output file, return success
	if (m_pszMibFilename == NULL)
		return 0;

	_VERIFY(GetNodeSymbol(pOidNode, nodeSymbol) == 0, -1);

	// build the T_FILE_NODE_EX structure
	fileNode.uNumChildren = (UINT)pOidNode->GetListOfChildNodes()->GetCount();
	fileNode.uReserved = 0;
	fileNode.uNumSubID = pOidNode->GetValue();

	if (nodeSymbol == NULL)
	{
		fileNode.lNextOffset = pOidNode->_lParam - sizeof(T_FILE_NODE_EX);
		fileNode.uStrLen = 0;
	}
	else
	{
		fileNode.uStrLen = strlen(nodeSymbol);
		fileNode.lNextOffset = pOidNode->_lParam - fileNode.uStrLen - sizeof(T_FILE_NODE_EX);
	}

	// create / write_open file if not already created
	if (m_hMibFile == NULL)
	{
		OFSTRUCT of;

		_VERIFY(m_pszMibFilename != NULL, -1);
		m_hMibFile = OpenFile(m_pszMibFilename, &of, OF_CREATE|OF_WRITE|OF_SHARE_EXCLUSIVE);
		_VERIFY(m_hMibFile != -1, -1);
	}

	// write fileNode to file
	_VERIFY(_lwrite(m_hMibFile, (LPSTR)&fileNode, sizeof(T_FILE_NODE_EX)) == sizeof(T_FILE_NODE_EX), -1);

	// write node's symbol if exists
	if (fileNode.uStrLen != 0)
	{
		_VERIFY(_lwrite(m_hMibFile, nodeSymbol, fileNode.uStrLen) == fileNode.uStrLen, -1);
	}

	return 0;
}

OidToFile::~OidToFile()
{
	if (m_pszMibFilename != NULL)
		delete (void *)m_pszMibFilename;
	if (m_hMibFile != NULL)
		_lclose(m_hMibFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\oid.hpp ===
#ifndef _OID_HPP
#define _OID_HPP

class Oid
{
	// DESCRIPTION:
	//     array containing the numeric components of the OID
	CWordArray m_nOidComp;

	// DESCRIPTION:
	//     array of pointers to strings, containing symbolic names
	//     for OID's components.
	CObArray  m_szOidComp;

public:
	// DESCRIPTION:
	//     constructor
	Oid();

	// DESCRIPTION:
	//     Adds a new Oid component to the END of the internal arrays!
	// PARAMETERS:
	//     (in) integer component of the Oid
	//     (out) symbolic name of the component
	// RETURN VALUE:
	//      0 on success, -1 on failure
	int AddComponent(int nOidComp, const char * szOidComp);

	// DESCRIPTION:
	//      Reverses the components of the OID from both
	//		m_nOidComp and m_szOidComp
	// RETURN VALUE:
	//      0 on success, -1 on failure
	int ReverseComponents();

	// DESCRIPTION:
	//      Output operator, displays the whole Oid
	friend ostream& operator<< (ostream& outStream, const Oid& oid);

	// DESCRIPTION:
	//     destructor
	~Oid();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\otscan.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "debug.hpp"
#include "Oid.hpp"
#include "OTScan.hpp"

typedef struct _oidBuiltIn
{
	const char * m_szSymbol;
	UINT m_nSubID;
	UINT m_nNextSibling;
} T_OID_BUILTIN;

#define BUILTIN_OID_COUNT	29
static T_OID_BUILTIN g_BuiltinOIDs[] = {
/*0 */	{"zero",           0, 29},	{"ccitt",           0,  2},	{"iso",           1, 28},
/*3 */	{"org",            3, 29},	{"dod",             6, 29},	{"internet",      1, 29},
/*6	*/	{"directory",      1,  7},	{"mgmt",            2, 12},	{"mib-2",         1, 29},
/*9	*/	{"interfaces",     2, 10},	{"ip",              4, 11},	{"transmission", 10, 29},
/*12*/	{"experimental",   3, 13},	{"private",         4, 15},	{"enterprises",   1, 29},
/*15*/	{"security",       5, 16},	{"snmpV2",          6, 29},	{"snmpDomains",   1, 24},
/*18*/	{"snmpUDPDomain",  1, 19},	{"snmpCLNSDomain",  2, 20}, {"snmpCONSDomain",3, 21},
/*21*/	{"snmpDDPDomain",  4, 22},  {"snmpIPXDomain",   5, 23}, {"rfc1157Domain", 6, 29},
/*24*/	{"snmpProxys",     2, 27},	{"rfc1157Proxy",    1, 29},	{"rfc1157Domain", 1, 29},
/*27*/	{"snmpModules",    3, 28},	{"joint-iso-ccitt", 2, 28}
};


// DESCRIPTION:
//		Adds list of nodes from lstChildren	to the tail of m_recursionTrace,
//		constructing at the same time the OID lexicographically order.
//		the list received as parameter should not be modified;
// PARAMETERS:
//		(in) list of nodes to add
void OidTreeScanner::UpdateRecursionTrace(SIMCNodeList *pLstChildren, SIMCNodeList *pLstTrace)
{
	int nChld;
	POSITION posChld;

	_ASSERT((pLstChildren != NULL) && (pLstTrace != NULL), "NULL parameter error!", NULL);

	// for each node from the children list
	for (posChld = pLstChildren->GetHeadPosition(), nChld=0;
	     posChld != NULL;
		 nChld++)
	{
		int nList;
		POSITION posList;
		SIMCOidTreeNode *nodeChld, *nodeList;
		
		nodeChld = pLstChildren->GetNext(posChld);
		nodeList = NULL;

		// if it's the first child to add, it goes at the head of the list
		if (nChld == 0)
		{
			_ASSERT(pLstTrace->AddHead(nodeChld)!=NULL,
				    "Memory Allocation error",
					NULL);
		}
		// otherwise, the head of the list should be an ordered list of
		// maximum nChld nodes. The new node is inserted in this list
		// with respect to it's value.
		else
		{
			// there are at least nChld nodes in m_recursionTrace
			for (nList=0, posList = pLstTrace->GetHeadPosition();
				 nList < nChld;
				 nList++)
			{
				POSITION posBackup = posList;

				nodeList = (SIMCOidTreeNode *)pLstTrace->GetNext(posBackup);
				_ASSERT(nodeList != NULL, "Internal OidNode List error!", NULL);

				// if the node to add has the value less then the current node, it
				// should be inserted in the list right before it.
				if (nodeChld->GetValue() < nodeList->GetValue())
					break;
				posList = posBackup;
			}
			if (posList != NULL)
			{
				_ASSERT(pLstTrace->InsertBefore(posList, nodeChld)!=NULL,
					    "Memory allocation error",
						NULL);
			}
			else
			{
				_ASSERT(pLstTrace->AddTail(nodeChld)!=NULL,
						"Memory allocation error",
						NULL);
			}
		}
	}
}

// DESCRIPTION:
//		Gets the first symbol from the symbol list of the node pOidNode
// PARAMETERS:
//		(in) pOidNode whose symbol is to be returned
//		(out) cszSymbol - pointer to the symbol (do not alter or free)
// RETURN VALUE:
//		0 on success, -1 on failure
int OidTreeScanner::GetNodeSymbol(const SIMCOidTreeNode *pOidNode, const char * & cszSymbol)
{
	const SIMCSymbolList *pSymbolList;

	_VERIFY(pOidNode != NULL, -1);
	pSymbolList = pOidNode->GetSymbolList();
	_VERIFY(pSymbolList != NULL, -1);

	if (pSymbolList->IsEmpty())
	{
		cszSymbol = (pOidNode->_pParam != NULL) ? (const char *)pOidNode->_pParam : NULL;
	}
	else
	{
		const SIMCSymbol **ppSymbol;

		ppSymbol = pSymbolList->GetHead();
		_VERIFY(ppSymbol != NULL && *ppSymbol != NULL, -1);

		cszSymbol = (*ppSymbol)->GetSymbolName();
	}
	return 0;
}

// DESCRIPTION:
//		Gets the complete OID information for the given pOidNode.
//		It supplies both the numeric value and symbolic name for each
//		component of the OID.
// PARAMETERS:
//      (in) pOidNode - the node whose OID is to be found
//      (out) oid - the Oid object who stores the data
// RETURN VALUE:
//      0 on success 
//		-1 on failure
int OidTreeScanner::GetNodeOid(const SIMCOidTreeNode *pOidNode, Oid &oid)
{
	_VERIFY(pOidNode != NULL, -1);
	_VERIFY(m_pOidTree != NULL, -1);
	do
	{
		const char * cszSymbol = NULL;

		_VERIFY(GetNodeSymbol(pOidNode, cszSymbol)==0, -1);

		_VERIFY(oid.AddComponent(pOidNode->GetValue(), cszSymbol)==0, -1);

		pOidNode = m_pOidTree->GetParentOf(pOidNode);
	} while (pOidNode != NULL);
	oid.ReverseComponents();

	return 0;
}


// initializes the OidTreeScanner
OidTreeScanner::OidTreeScanner()
{
	m_pOidTree = NULL;
}

// DESCRIPTION:
//		scans lexicographically the oid tree;
// RETURN VALUE:
//		0 on success
//		-1 on failure;
int OidTreeScanner::Scan()
{
	SIMCOidTreeNode *pOidNode;
	SIMCNodeList recursionTrace;

	// get the root node from the oid tree,
	// return "error" if no tree or no root
	_VERIFY(m_pOidTree != NULL, -1);
	pOidNode = (SIMCOidTreeNode *)m_pOidTree->GetRoot();
	_VERIFY(pOidNode != NULL, -1);

	// initialize the recursion trace list with the root node
	_VERIFY(recursionTrace.AddHead(pOidNode)!=NULL, -1);

	// start to scan the tree
	while (!recursionTrace.IsEmpty())
	{
		// list of current node's children
		SIMCNodeList *lstChildren;

		// allways pick up the node in the head of the list
		pOidNode = recursionTrace.GetHead();

		// then erase it from the list
		recursionTrace.RemoveAt(recursionTrace.GetHeadPosition());

		// check to see if the scanner should stop (with error code)
		_VERIFY(OnScanNode(pOidNode)==0, -1);

		// get the list of children
		lstChildren = (SIMCNodeList *)pOidNode->GetListOfChildNodes();

		// if there are children
		if (lstChildren != NULL)
			// add children to the head of the trace list
			UpdateRecursionTrace(lstChildren, &recursionTrace);
	}
	return 0;
}

// DESCRIPTION:
//		Fills the symbols of the built-in objects from the static table
// RETURN VALUE:
//		0 - on success, -1 on failure
int OidTreeScanner::MergeBuiltIn()
{
	SIMCNodeList lstOidStack;
	SIMCOidTreeNode	*pOid;
	CList <unsigned int, unsigned int> wlstBuiltinStack;
	unsigned int nBuiltin;
	
	// initialize the two stacks with the root nodes from 
	// the oid tree and from the builtin symbols
	pOid = (SIMCOidTreeNode *)m_pOidTree->GetRoot();
	_VERIFY(pOid != NULL, -1);
	_VERIFY(lstOidStack.AddHead(pOid)!=NULL, -1);
	_VERIFY(wlstBuiltinStack.AddHead((unsigned int)0)!=NULL, -1);

	// as long as there are items on the stack, process each item
	// item is processed only if it doesn't have a symbol associated
	while(!lstOidStack.IsEmpty())
	{
		const SIMCSymbolList *pSymbolList;

		pOid = lstOidStack.RemoveHead();
		nBuiltin = wlstBuiltinStack.RemoveHead();
		pSymbolList = pOid->GetSymbolList();
		_VERIFY(pSymbolList != NULL, -1);

		// if node already has a symbol attached, no need to dive deeper
		if (!pSymbolList->IsEmpty())
			continue;
		else
		{
			const SIMCNodeList *pChildList;

			pOid->_pParam = (void *)g_BuiltinOIDs[nBuiltin].m_szSymbol;

			// now push new nodes on the stacks
			pChildList = pOid->GetListOfChildNodes();
			_VERIFY(pChildList != NULL, -1);
			for (POSITION p = pChildList->GetHeadPosition(); p != NULL;)
			{
				unsigned int i;

				pOid = pChildList->GetNext(p);
				_VERIFY(pOid != NULL, -1);

				// the child nodes always begin at index nBuiltin+1 (if they exist)
				// and end before the parent's first sibling node.
				for (i = nBuiltin+1;
					 i < g_BuiltinOIDs[nBuiltin].m_nNextSibling;
					 i = g_BuiltinOIDs[i].m_nNextSibling)
				{
					// when the match is found, push both nodes on their stacks (in sync)
					// and go to another child
					if (g_BuiltinOIDs[i].m_nSubID == (UINT)pOid->GetValue())
					{
						_VERIFY(lstOidStack.AddHead(pOid)!=NULL, -1);
						_VERIFY(wlstBuiltinStack.AddHead(i)!=NULL, -1);
						break;
					}
				}
			}
		}
	}
	return 0;
}

// DESCRIPTION:
//		initializes the m_pOidTree.
// PARAMETERS:
//		(in) pointer to the SIMCOidTree to scan.
void OidTreeScanner::SetOidTree(SIMCOidTree *pOidTree)
{
	m_pOidTree = pOidTree;
}

OidTreeScanner::~OidTreeScanner()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\compiler\mibccv2\otscan.hpp ===
#ifndef _OIDTREESCANNER_HPP
#define _OIDTREESCANNER_HPP

class Oid;

class OidTreeScanner
{
protected:
	SIMCOidTree		*m_pOidTree;

	// DESCRIPTION:
	//		Adds list of nodes from lstChildren	to the tail of m_recursionTrace,
	//		constructing at the same time the OID lexicographically order.
	//		the list received as parameter should not be modified;
	// PARAMETERS:
	//		(in) list of nodes to add
	void UpdateRecursionTrace(SIMCNodeList *pLstChildren, SIMCNodeList *pLstTrace);

	// DESCRIPTION:
	//		Gets the first symbol from the symbol list of the node pOidNode
	// PARAMETERS:
	//		(in) pOidNode whose symbol is to be returned
	//		(out) cszSymbol - pointer to the symbol (do not alter or free)
	// RETURN VALUE:
	//		0 on success, -1 on failure
	int GetNodeSymbol(const SIMCOidTreeNode *pOidNode, const char * & cszSymbol);

	// DESCRIPTION:
	//		Gets the complete OID information for the given pOidNode.
	//		It supplies both the numeric value and symbolic name for each
	//		component of the OID.
	// PARAMETERS:
	//      (in) pOidNode - the node whose OID is to be found
	//      (out) oid - the Oid object who stores the data
	// RETURN VALUE:
	//      0 on success, -1 on failure
	int GetNodeOid(const SIMCOidTreeNode *pOidNode, Oid &oid);

public:
	// initializes the OidTreeScanner
	OidTreeScanner();

	// DESCRIPTION:
	//		scans lexicographically the oid tree;
	// RETURN VALUE:
	//		0 on success
	//		-1 on failure;
	virtual int Scan();

	// DESCRIPTION:
	//		"callback" function, called each time a
	//		tree node passes through the scan. The user
	//		should redefine this function in the derived
	//		object to perform the action desired.
	// PARAMETERS:
	//		(in) Pointer to the current node in the tree.
	// RETURN VALUE:
	//		0 - the scanner should continue
	//		1 - the scanner should abort.
	virtual int OnScanNode(const SIMCOidTreeNode *pOidNode) = 0;

	// DESCRIPTION:
	//		Fills the symbols of the built-in objects from the static table
	// RETURN VALUE:
	//		0 - on success, -1 on failure
	int MergeBuiltIn();

	// DESCRIPTION:
	//		initializes the m_pOidTree.
	// PARAMETERS:
	//		(in) pointer to the SIMCOidTree to scan.
	void SetOidTree(SIMCOidTree *pOidTree);

	~OidTreeScanner();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\mgmtapi\dll\mgmtapi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mgmtapi.c

Abstract:

    SNMP Management API (wrapped around WinSNMP API).

Environment:

    User Mode - Win32

Revision History:

    05-Feb-1997 DonRyan
        Rewrote functions to be wrappers around WinSNMP.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include Files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wsipx.h>
#include <winsnmp.h>
#include <mgmtapi.h>
#include <oidconv.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SNMP_MGR_SESSION {

    SOCKET            UnusedSocket;     // WARNING: Previous versions of the
    struct sockaddr   UnusedDestAddr;   // MGMTAPI.H header file exposed the
    LPSTR             UnusedCommunity;  // SNMP_MGR_SESSION structure which
    INT               UnusedTimeout;    // unfortunately encouraged people to
    INT               UnusedNumRetries; // muck with it.  Since this structure
    AsnInteger        UnusedRequestId;  // has now changed we must protect it.

    CRITICAL_SECTION  SessionLock;      // multiple threads may share session

    HSNMP_SESSION     hSnmpSession;     // handle to winsnmp session
    HSNMP_ENTITY      hAgentEntity;     // handle to agent entity
    HSNMP_ENTITY      hManagerEntity;   // handle to manager entity
    HSNMP_CONTEXT     hViewContext;     // handle to view context
    HSNMP_PDU         hPdu;             // handle to snmp pdu
    HSNMP_VBL         hVbl;             // handle to snmp pdu
    HWND              hWnd;             // handle to window

    smiINT32          nPduType;         // current pdu type
    smiINT32          nRequestId;       // current request id
    smiINT32          nErrorIndex;      // error index from pdu
    smiINT32          nErrorStatus;     // error status from pdu
    smiINT32          nLastError;       // last system error
    SnmpVarBindList * pVarBindList;     // pointer to varbind list

} SNMP_MGR_SESSION, *PSNMP_MGR_SESSION;

typedef struct _TRAP_LIST_ENTRY {

    LIST_ENTRY          Link;           // linked-list link
    AsnObjectIdentifier EnterpriseOID;  // generating enterprise
    AsnNetworkAddress   AgentAddress;   // generating agent addr
    AsnNetworkAddress   SourceAddress;  // generating network addr
    AsnInteger          nGenericTrap;   // generic trap type
    AsnInteger          nSpecificTrap;  // enterprise specific type
    AsnOctetString      Community;      // generating community
    AsnTimeticks        TimeStamp;      // time stamp
    SnmpVarBindList     VarBindList;    // variable bindings

} TRAP_LIST_ENTRY, * PTRAP_LIST_ENTRY;

#define IPADDRLEN           4
#define IPXADDRLEN          10

#define MAXENTITYSTRLEN     128

#define MINVARBINDLEN       2
#define SYSUPTIMEINDEX      0
#define SNMPTRAPOIDINDEX    1

#define DEFAULT_ADDRESS_IP  "127.0.0.1"
#define DEFAULT_ADDRESS_IPX "00000000.000000000000"

#define NOTIFICATION_CLASS  "MGMTAPI Notification Class"
#define WM_WSNMP_INCOMING   (WM_USER + 1)
#define WM_WSNMP_DONE       (WM_USER + 2)

#define WSNMP_FAILED(s)     ((s) == SNMPAPI_FAILURE)
#define WSNMP_SUCCEEDED(s)  ((s) != SNMPAPI_FAILURE)

#define WSNMP_ASSERT(s)     ASSERT((s))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HINSTANCE         g_hDll;                       // module handle
HANDLE            g_hTrapEvent = NULL;          // trap event handle
HANDLE            g_hTrapThread = NULL;         // trap thread handle
HANDLE            g_hTrapRegisterdEvent = NULL; // event to sync. SnmpMgrTrapListen
BOOL              g_fIsSnmpStarted = FALSE;     // indicates winsnmp inited
BOOL              g_fIsSnmpListening = FALSE;   // indicates trap thread on
BOOL              g_fIsTrapRegistered = FALSE;  // indicates trap registered
DWORD             g_dwRequestId = 1;            // unique pdu request id
LIST_ENTRY        g_IncomingTraps;              // incoming trap queue
CRITICAL_SECTION  g_GlobalLock;                 // process resource lock
SNMP_MGR_SESSION  g_TrapSMS;                    // process trap session
DWORD             g_cSnmpMgmtRef = 0;           // ref. count on using mgmtapi


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
GetRequestId(
    )

/*++

Routine Description:

    Retrieve next global request id.

Arguments:

    None.

Return Values:

    Returns request id.

--*/

{
    DWORD dwRequestId;

    // obtain exclusive access to request id
    EnterCriticalSection(&g_GlobalLock);

    // obtain copy of request id
    dwRequestId = g_dwRequestId++;

    // obtain exclusive access to request id
    LeaveCriticalSection(&g_GlobalLock);

    return dwRequestId;
}


BOOL
TransferVb(
    PSNMP_MGR_SESSION pSMS,
    SnmpVarBind *     pVarBind
    )

/*++

Routine Description:

    Transfer VarBind structure to WinSNMP structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

    pVarBind - pointer to varbind to transfer.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    smiVALUE tmpValue;
    smiOID tmpOID;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate pointers
    if ((pVarBind != NULL) &&
        (pVarBind->name.ids != NULL) &&
        (pVarBind->name.idLength != 0)) {

        // re-init
        fOk = TRUE;

        // transfer oid information
        tmpOID.len = pVarBind->name.idLength;
        tmpOID.ptr = pVarBind->name.ids;

        // only initialize value if set
        if (pSMS->nPduType == SNMP_PDU_SET) {

            // syntax values are equivalent
            tmpValue.syntax = (smiINT32)(BYTE)pVarBind->value.asnType;

            // determine type
            switch (pVarBind->value.asnType) {

            case ASN_INTEGER32:

                // transfer signed int
                tmpValue.value.sNumber = pVarBind->value.asnValue.number;
                break;

            case ASN_UNSIGNED32:
            case ASN_COUNTER32:
            case ASN_GAUGE32:
            case ASN_TIMETICKS:

                // transfer unsigned int
                tmpValue.value.uNumber = pVarBind->value.asnValue.unsigned32;
                break;

            case ASN_COUNTER64:

                // transfer 64-bit counter
                tmpValue.value.hNumber.lopart =
                    pVarBind->value.asnValue.counter64.LowPart;
                tmpValue.value.hNumber.hipart =
                    pVarBind->value.asnValue.counter64.HighPart;
                break;

            case ASN_OPAQUE:
            case ASN_IPADDRESS:
            case ASN_OCTETSTRING:
            case ASN_BITS:

                // transfer octet string
                tmpValue.value.string.len =
                    pVarBind->value.asnValue.string.length;
                tmpValue.value.string.ptr =
                    pVarBind->value.asnValue.string.stream;
                break;

            case ASN_OBJECTIDENTIFIER:

                // transfer object id
                tmpValue.value.oid.len =
                    pVarBind->value.asnValue.object.idLength;
                tmpValue.value.oid.ptr =
                    pVarBind->value.asnValue.object.ids;
                break;

            case ASN_NULL:
            case SNMP_EXCEPTION_NOSUCHOBJECT:
            case SNMP_EXCEPTION_NOSUCHINSTANCE:
            case SNMP_EXCEPTION_ENDOFMIBVIEW:

                // initialize empty byte
                tmpValue.value.empty = 0;
                break;

            default:

                // failure
                fOk = FALSE;
                break;
            }
        }

        if (fOk) {

            // register varbind
            status = SnmpSetVb(
                        pSMS->hVbl,
                        0, // index
                        &tmpOID,
                        (pSMS->nPduType == SNMP_PDU_SET)
                            ? &tmpValue
                            : NULL
                        );

            // validate return code
            if (WSNMP_FAILED(status)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpSetVb returned %d.\n",
                    SnmpGetLastError(pSMS->hSnmpSession)
                    ));

                // failure
                fOk = FALSE;
            }
        }
    }

    return fOk;
}


BOOL
AllocateVbl(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Transfer VarBindList structure to WinSNMP structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    SnmpVarBind * pVarBind;
    DWORD cVarBind;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate parameters
    WSNMP_ASSERT(pSMS->pVarBindList != NULL);
    WSNMP_ASSERT(pSMS->pVarBindList->len != 0);
    WSNMP_ASSERT(pSMS->pVarBindList->list != NULL);

    // allocate resources for variable bindings list
    pSMS->hVbl = SnmpCreateVbl(pSMS->hSnmpSession, NULL, NULL);

    // validate varbind handle
    if (WSNMP_SUCCEEDED(pSMS->hVbl)) {

        // re-init
        fOk = TRUE;

        // initialize varbind pointer
        pVarBind = pSMS->pVarBindList->list;

        // initialize varbind count
        cVarBind = pSMS->pVarBindList->len;

        // process each varbind
        while (fOk && cVarBind--) {

            // transfer variable binding
            fOk = TransferVb(pSMS, pVarBind++);
        }

        if (!fOk) {

            // release varbind list handle
            status = SnmpFreeVbl(pSMS->hVbl);

            // validate return code
            if (WSNMP_FAILED(status)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpFreeVbl returned %d.\n",
                    SnmpGetLastError(pSMS->hSnmpSession)
                    ));
            }

            // re-initialize
            pSMS->hVbl = (HSNMP_VBL)NULL;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpCreateVbl returned %d.\n",
            SnmpGetLastError(pSMS->hSnmpSession)
            ));
    }

    return fOk;
}


BOOL
FreeVbl(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Cleanup VarBind resources from WinSNMP structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate handle
    if (pSMS->hVbl != (HSNMP_VBL)NULL) {

        // actually release vbl handle
        status = SnmpFreeVbl(pSMS->hVbl);

        // validate return code
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreeVbl returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize handle
        pSMS->hVbl = (HSNMP_VBL)NULL;
    }

    return fOk;
}


BOOL
AllocatePdu(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Initialize session structure for sending request.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // transfer varbinds
    if (AllocateVbl(pSMS)) {

        // grab next shared request id
        pSMS->nRequestId = GetRequestId();

        // create request pdu
        pSMS->hPdu = SnmpCreatePdu(
                        pSMS->hSnmpSession,
                        pSMS->nPduType,
                        pSMS->nRequestId,
                        0, // errorStatus
                        0, // errorIndex
                        pSMS->hVbl
                        );

        // validate return status
        if (WSNMP_SUCCEEDED(pSMS->hPdu)) {

            // success
            fOk = TRUE;

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpCreatePdu returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // free resources
            FreeVbl(pSMS);
        }
    }

    return fOk;
}


BOOL
FreePdu(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Cleanup session structure after processing response.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate handle
    if (pSMS->hPdu != (HSNMP_PDU)NULL) {

        // free vbl
        FreeVbl(pSMS);

        // actually release pdu handle
        status = SnmpFreePdu(pSMS->hPdu);

        // validate return code
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreePdu returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize handle
        pSMS->hPdu = (HSNMP_PDU)NULL;
    }

    return fOk;
}


BOOL
CopyOid(
    AsnObjectIdentifier * pDstOID,
    smiLPOID              pSrcOID
    )

/*++

Routine Description:

    Copies object identifier from WinSNMP format to MGMTAPI format.

Arguments:

    pDstOID - points to MGMTAPI structure to receive OID.

    pSrcOID - points to WinSNMP structure to copy.

Return Values:

    Returns true if successful.

Note: if pSrcOID is valid, its contents will be freed regardless of
      return value

--*/

{
    BOOL fOk = FALSE;

    // validate pointers
    WSNMP_ASSERT(pDstOID != NULL);
    WSNMP_ASSERT(pSrcOID != NULL);
    WSNMP_ASSERT(pSrcOID->len != 0);
    WSNMP_ASSERT(pSrcOID->ptr != NULL);

    // store the number of subids
    pDstOID->idLength = pSrcOID->len;

    // allocate memory for subidentifiers
    pDstOID->ids = SnmpUtilMemAlloc(pDstOID->idLength * sizeof(DWORD));

    // validate pointer
    if (pDstOID->ids != NULL) {

        // transfer memory
        memcpy(pDstOID->ids,
               pSrcOID->ptr,
               pDstOID->idLength * sizeof(DWORD)
               );

        // success
        fOk = TRUE;
    }

    // now release memory for original oid
    SnmpFreeDescriptor(SNMP_SYNTAX_OID, (smiLPOPAQUE)pSrcOID);

    return fOk;
}


BOOL
CopyOctets(
    AsnOctetString * pDstOctets,
    smiLPOCTETS      pSrcOctets
    )

/*++

Routine Description:

    Copies octet string from WinSNMP format to MGMTAPI format.

Arguments:

    pDstOctets - points to MGMTAPI structure to receive octets.

    pSrcOctets - points to WinSNMP structure to copy.

Return Values:

    Returns true if successful.

Note: if pSrcOctets is valid, its contents will be freed regardless of
      return value

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;

    // validate pointers
    WSNMP_ASSERT(pDstOctets != NULL);
    WSNMP_ASSERT(pSrcOctets != NULL);

    // it is legitimate that 
    // 1. pSrcOctets->len == 0
    // 2. pSrcOctets->ptr == NULL

    if (pSrcOctets->len == 0 || pSrcOctets->ptr == NULL)
    {
        pDstOctets->dynamic = FALSE;
        pDstOctets->length = 0;
        pDstOctets->stream = NULL;
        fOk = TRUE;
    }
    else
    {
        // allocate memory for octet string
        pDstOctets->stream = SnmpUtilMemAlloc(pSrcOctets->len);

        // validate pointer
        if (pDstOctets->stream != NULL) {

            // octet string allocated
            pDstOctets->dynamic = TRUE;

            // store the number of bytes
            pDstOctets->length = pSrcOctets->len;
       
            // transfer memory
            memcpy(pDstOctets->stream,
                   pSrcOctets->ptr,
                   pDstOctets->length
                   );

            // success
            fOk = TRUE;
        }
    }

    // now release memory for original string
    SnmpFreeDescriptor(SNMP_SYNTAX_OCTETS, (smiLPOPAQUE)pSrcOctets);

    return fOk;
}


CopyVb(
    PSNMP_MGR_SESSION pSMS,
    DWORD             iVarBind,
    SnmpVarBind *     pVarBind
    )

/*++

Routine Description:

    Copy variable binding from WinSNMP structure to MGMTAPI structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

    iVarBind - index of varbind structure to copy.

    pVarBind - pointer to varbind structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    smiOID tmpOID;
    smiVALUE tmpValue;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(pVarBind != NULL);

    // attempt to retrieve varbind data from winsnmp structure
    status = SnmpGetVb(pSMS->hVbl, iVarBind, &tmpOID, &tmpValue);

    // validate return code
    if (WSNMP_SUCCEEDED(status)) {

        // transfer object identifier value
        fOk = CopyOid(&pVarBind->name, &tmpOID);

        // syntax values are equivalent
        pVarBind->value.asnType = (BYTE)(smiINT32)tmpValue.syntax;

        // determine syntax
        switch (tmpValue.syntax) {

        case SNMP_SYNTAX_INT32:

            // transfer signed int
            pVarBind->value.asnValue.number = tmpValue.value.sNumber;
            break;

        case SNMP_SYNTAX_UINT32:
        case SNMP_SYNTAX_CNTR32:
        case SNMP_SYNTAX_GAUGE32:
        case SNMP_SYNTAX_TIMETICKS:

            // transfer unsigned int
            pVarBind->value.asnValue.unsigned32 = tmpValue.value.uNumber;
            break;

        case SNMP_SYNTAX_CNTR64:

            // transfer 64-bit counter
            pVarBind->value.asnValue.counter64.LowPart =
                tmpValue.value.hNumber.lopart;
            pVarBind->value.asnValue.counter64.HighPart =
                tmpValue.value.hNumber.hipart;
            break;

        case SNMP_SYNTAX_OPAQUE:
        case SNMP_SYNTAX_IPADDR:
        case SNMP_SYNTAX_OCTETS:
        case SNMP_SYNTAX_BITS:

            // transfer octet string
            if (!CopyOctets(&pVarBind->value.asnValue.string,
                            &tmpValue.value.string)) {
              
                // re-initialize
                pVarBind->value.asnType = ASN_NULL;

                // failure
                fOk = FALSE;
            }

            break;

        case SNMP_SYNTAX_OID:

            // transfer object identifier
            if (!CopyOid(&pVarBind->value.asnValue.object,
                         &tmpValue.value.oid)) {

                // re-initialize
                pVarBind->value.asnType = ASN_NULL;

                // failure
                fOk = FALSE;
            }

            break;

        case SNMP_SYNTAX_NULL:
        case SNMP_SYNTAX_NOSUCHOBJECT:
        case SNMP_SYNTAX_NOSUCHINSTANCE:
        case SNMP_SYNTAX_ENDOFMIBVIEW:

            break; // do nothing...

        default:

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpGetVb returned invalid type.\n"
                ));

            // re-initialize
            pVarBind->value.asnType = ASN_NULL;

           // failure
            fOk = FALSE;

            break;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpGetVb returned %d.\n",
            SnmpGetLastError(pSMS->hSnmpSession)
            ));
    }

    return fOk;
}


BOOL
CopyVbl(
    PSNMP_MGR_SESSION pSMS,
    SnmpVarBindList * pVarBindList
    )

/*++

Routine Description:

    Copy variable bindings from WinSNMP structure to MGMTAPI structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

    pVarBindList - pointer to varbind list structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(pVarBindList != NULL);

    // initialize
    pVarBindList->len  = 0;
    pVarBindList->list = NULL;

    // validate varbind list handle
    if (pSMS->hVbl != (HSNMP_VBL)NULL) {

        // determine number of varbinds
        pVarBindList->len = SnmpCountVbl(pSMS->hVbl);

        // validate number of varbinds
        if (WSNMP_SUCCEEDED(pVarBindList->len)) {

            // allocate memory for varbinds
            pVarBindList->list = SnmpUtilMemAlloc(
                                    pVarBindList->len *
                                    sizeof(SnmpVarBind)
                                    );

            // validate pointer
            if (pVarBindList->list != NULL) {

                DWORD cVarBind = 1;
                SnmpVarBind * pVarBind;

                // save pointer to varbinds
                pVarBind = pVarBindList->list;

                // process varbinds in the list
                while (fOk && (cVarBind <= pVarBindList->len)) {

                    // copy varbind from winsnmp to mgmtapi
                    fOk = CopyVb(pSMS, cVarBind++, pVarBind++);
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Could not allocate VBL.\n"
                    ));

                // re-initialize
                pVarBindList->len = 0;

                // failure
                fOk = FALSE;
            }

        } else if (SnmpGetLastError(pSMS->hSnmpSession) != SNMPAPI_NOOP) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpCountVbl returned %s.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pVarBindList->len = 0;

            // failure
            fOk = FALSE;
        }
    }

    if (!fOk) {

        // cleanup any varbinds allocated
        SnmpUtilVarBindListFree(pVarBindList);
    }

    return fOk;
}


BOOL
ParseVbl(
    PSNMP_MGR_SESSION pSMS,
    PTRAP_LIST_ENTRY  pTLE
    )

/*++

Routine Description:

    Parse varbind list for trap-related varbinds.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

    pTLE - pointer to trap list entry.

Return Values:

    Returns true if successful.

--*/

{
    SnmpVarBind * pVarBind;
    AsnObjectIdentifier * pOID;
    AsnNetworkAddress   * pAgentAddress = NULL;
    AsnObjectIdentifier * pEnterpriseOID = NULL;

    // object identifiers to convert snmpv2 trap format
    static UINT _sysUpTime[]             = { 1, 3, 6, 1, 2, 1, 1, 3       };
    static UINT _snmpTrapOID[]           = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1 };
    static UINT _snmpAddress[]           = { 1, 3, 6, 1, 3, 1057, 1       };
    static UINT _snmpTrapEnterprise[]    = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 3 };
    static UINT _snmpTraps[]             = { 1, 3, 6, 1, 6, 3, 1, 1, 5    };

    static AsnObjectIdentifier sysUpTime          = DEFINE_OID(_sysUpTime);
    static AsnObjectIdentifier snmpTrapOID        = DEFINE_OID(_snmpTrapOID);
    static AsnObjectIdentifier snmpAddress        = DEFINE_OID(_snmpAddress);
    static AsnObjectIdentifier snmpTrapEnterprise = DEFINE_OID(_snmpTrapEnterprise);
    static AsnObjectIdentifier snmpTraps          = DEFINE_OID(_snmpTraps);

    // validate pointers
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(pTLE != NULL);

    // validate vbl have minimum entries
    if (pTLE->VarBindList.len >= MINVARBINDLEN) {

        // point to sysUpTime varbind structure
        pVarBind = &pTLE->VarBindList.list[SYSUPTIMEINDEX];

        // verify variable is sysUpTime
        if ((pVarBind->value.asnType == ASN_TIMETICKS) &&
            !SnmpUtilOidNCmp(&pVarBind->name,
                             &sysUpTime,
                             sysUpTime.idLength)) {

            // transfer sysUpTime value to trap entry
            pTLE->TimeStamp = pVarBind->value.asnValue.ticks;

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Could not find sysUpTime.\n"
                ));

            goto cleanup; // bail...
        }

        // see if any additional varbinds present
        if (pTLE->VarBindList.len > MINVARBINDLEN) {

            // point to snmpTrapEnterprise varbind structure (maybe)
            pVarBind = &pTLE->VarBindList.list[pTLE->VarBindList.len - 1];

            // verify variable is snmpTrapEnterprise
            if ((pVarBind->value.asnType == ASN_OBJECTIDENTIFIER) &&
                !SnmpUtilOidNCmp(&pVarBind->name,
                                 &snmpTrapEnterprise,
                                 snmpTrapEnterprise.idLength))  {

                // transfer enterprise oid to list entry
                pTLE->EnterpriseOID = pVarBind->value.asnValue.object;

                // store enterprise oid for later
                pEnterpriseOID = &pTLE->EnterpriseOID;

                // modify type to avoid deallocation
                pVarBind->value.asnType = ASN_NULL;

            } else {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "MGMTAPI: Could not find snmpTrapEnterprise.\n"
                    ));
            }
        }

        // see if the agent address is present
        if (pTLE->VarBindList.len > MINVARBINDLEN+1) {
            
            // point to snmpAddress varbind structure (maybe)
            pVarBind = &pTLE->VarBindList.list[pTLE->VarBindList.len - 2];

            // verify variable is snmpAddress
            if ((pVarBind->value.asnType == SNMP_SYNTAX_IPADDR) &&
                !SnmpUtilOidNCmp(&pVarBind->name,
                                 &snmpAddress,
                                 snmpAddress.idLength))  {

                // transfer agent address oid to list entry
                pTLE->AgentAddress = pVarBind->value.asnValue.address;

                // store agent address for later
                pAgentAddress = &pTLE->AgentAddress;

                // modify type to avoid deallocation
                pVarBind->value.asnType = ASN_NULL;

            } else {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "MGMTAPI: Could not find snmpAddress.\n"
                    ));
            }
        }

        // point to snmpTrapOID varbind structure
        pVarBind = &pTLE->VarBindList.list[SNMPTRAPOIDINDEX];

        // verify variable is snmpTrapOID
        if ((pVarBind->value.asnType == ASN_OBJECTIDENTIFIER) &&
            !SnmpUtilOidNCmp(&pVarBind->name,
                             &snmpTrapOID,
                             snmpTrapOID.idLength))  {

            // retrieve pointer to oid
            pOID = &pVarBind->value.asnValue.object;

            // check for generic trap
            if (!SnmpUtilOidNCmp(pOID,
                                 &snmpTraps,
                                 snmpTraps.idLength)) {

                // validate size is one greater than root
                if (pOID->idLength == (snmpTraps.idLength + 1)) {

                    // retrieve trap id
                    // --ft:10/01/98 (bug #231344): WINSNMP gives up the V2 syntax => pOID->ids[snmpTraps.idLength] = [1..6]
                    // --ft:10/01/98 (bug #231344): as MGMTAPI turns back to V1, we need to decrement this value.
                    pTLE->nGenericTrap = (pOID->ids[snmpTraps.idLength])-1;

                    // re-initialize
                    pTLE->nSpecificTrap = 0;

                } else {

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "MGMTAPI: Invalid snmpTrapOID.\n"
                        ));

                    goto cleanup; // bail...
                }

            // check for specific trap
            } else if ((pEnterpriseOID != NULL) &&
                       !SnmpUtilOidNCmp(pOID,
                                        pEnterpriseOID,
                                        pEnterpriseOID->idLength)) {

                // validate size is two greater than root
                if (pOID->idLength == (pEnterpriseOID->idLength + 2)) {

                    // validate separator sub-identifier
                    WSNMP_ASSERT(pOID->ids[pEnterpriseOID->idLength] == 0);

                    // retrieve trap id
                    pTLE->nSpecificTrap = pOID->ids[pEnterpriseOID->idLength + 1];

                    // re-initialize
                    pTLE->nGenericTrap = SNMP_GENERICTRAP_ENTERSPECIFIC;

                } else {

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "MGMTAPI: Invalid snmpTrapOID.\n"
                        ));

                    goto cleanup; // bail...
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Could not identify snmpTrapOID.\n"
                    ));

               goto cleanup; // bail...
            }

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Could not find snmpTrapOID.\n"
                ));

            goto cleanup; // bail...
        }

        // check for enterprise oid
        if (pEnterpriseOID != NULL) {

            // release snmpTrapEnterprise varbind structure
            SnmpUtilVarBindFree(&pTLE->VarBindList.list[pTLE->VarBindList.len - 1]);

            // decrement the list length as the last varbind was freed
            pTLE->VarBindList.len--;
        }

        // check for agent address
        if (pAgentAddress != NULL) {

            // release snmpAgentAddress varbind structure
            SnmpUtilVarBindFree(&pTLE->VarBindList.list[pTLE->VarBindList.len - 1]);

            // decrement the list length as the last varbind was again freed
            pTLE->VarBindList.len--;
        }

        // release sysUpTime varbind structure
        SnmpUtilVarBindFree(&pTLE->VarBindList.list[SYSUPTIMEINDEX]);

        // release snmpTrapOID varbind structure
        SnmpUtilVarBindFree(&pTLE->VarBindList.list[SNMPTRAPOIDINDEX]);

        // subtract released varbinds
        pTLE->VarBindList.len -= MINVARBINDLEN;

        // check if all varbinds freed
        if (pTLE->VarBindList.len == 0) {

            // release memory for list
            SnmpUtilMemFree(pTLE->VarBindList.list);

            // re-initialize
            pTLE->VarBindList.list = NULL;

        } else {

            // shift varbind list up two spaces
            memmove((LPBYTE)(pTLE->VarBindList.list),
                    (LPBYTE)(pTLE->VarBindList.list + MINVARBINDLEN),
                    (pTLE->VarBindList.len * sizeof(SnmpVarBind))
                    );
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: Too few subidentifiers.\n"
            ));
    }

    // success
    return TRUE;

cleanup:

    // failure
    return FALSE;
}


BOOL
FreeTle(
    PTRAP_LIST_ENTRY pTLE
    )

/*++

Routine Description:

    Release memory used for trap entry.

Arguments:

    pTLE - pointer to trap list entry.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    WSNMP_ASSERT(pTLE != NULL);
    
    // release memory for enterprise oid if necessary
    SnmpUtilOidFree(&pTLE->EnterpriseOID);
    
    // release memory for AgentAddress if necessary
    SnmpUtilOctetsFree(&pTLE->AgentAddress);  // AgentAddress is a AsnOctetString type
    
    // release memory for SourceAddress if necessary
    SnmpUtilOctetsFree(&pTLE->SourceAddress); // SourceAddress is a AsnOctetString type
    
    // release memory for community string if necessary
    SnmpUtilMemFree(pTLE->Community.stream);
    
    // release memory used in varbind list if necessary
    SnmpUtilVarBindListFree(&pTLE->VarBindList);
    
    // release list entry
    SnmpUtilMemFree(pTLE);
    
    return TRUE;
}


BOOL
AllocateTle(
    PSNMP_MGR_SESSION  pSMS,
    PTRAP_LIST_ENTRY * ppTLE,
    HSNMP_ENTITY       hAgentEntity,
    HSNMP_CONTEXT      hViewContext
    )

/*++

Routine Description:

    Allocate memory for trap entry.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

    ppTLE - pointer to pointer to trap list entry.

    hAgentEntity - handle to agent sending trap.

    hViewContext - handle to view context of trap.

Return Values:

    Returns true if successful.

--*/

{
    PTRAP_LIST_ENTRY pTLE;
    SNMPAPI_STATUS status;
    smiOCTETS CommunityStr;
    CHAR SourceStrAddr[MAXENTITYSTRLEN+1];
    struct sockaddr SourceSockAddr;

    // validate pointers
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(ppTLE != NULL);

    // allocate memory from list entry
    pTLE = SnmpUtilMemAlloc(sizeof(TRAP_LIST_ENTRY));

    // validate pointer
    if (pTLE == NULL) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: Could not allocate trap entry.\n"
            ));

        return FALSE; // bail...
    }

    // initialize
    *ppTLE = NULL;

    // copy varbinds to trap list entry
    if (!CopyVbl(pSMS, &pTLE->VarBindList)) {
        goto cleanup; // bail...
    }

    // parse trap-related varbinds
    if (!ParseVbl(pSMS, pTLE)) {
        goto cleanup; // bail...
    }

    // check if source address is specified
    if (hAgentEntity != (HSNMP_ENTITY)NULL) {

        // convert addr to string
        status = SnmpEntityToStr(
                    hAgentEntity,
                    sizeof(SourceStrAddr),
                    SourceStrAddr
                    );

        // validate error code
        if (WSNMP_SUCCEEDED(status)) {

            DWORD  AddrLen = 0;
            LPBYTE AddrPtr = NULL;

            // convert string to socket address structure
            if (! SnmpSvcAddrToSocket(SourceStrAddr, &SourceSockAddr))
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Ignoring invalid address.\n"
                    ));

                goto cleanup; // bail...
            }

            // validate address family
            if (SourceSockAddr.sa_family == AF_INET) {

                // assign ip values
                AddrLen = IPADDRLEN;
                AddrPtr = (LPBYTE)&(((struct sockaddr_in *)
                            (&SourceSockAddr))->sin_addr);

            } else if (SourceSockAddr.sa_family == AF_IPX) {

                // assign ipx values
                AddrLen = IPXADDRLEN;
                AddrPtr = (LPBYTE)&(((struct sockaddr_ipx *)
                            (&SourceSockAddr))->sa_netnum);

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Ignoring invalid address.\n"
                    ));

                goto cleanup; // bail...
            }

            // allocate address to return (if specified)
            pTLE->SourceAddress.stream = SnmpUtilMemAlloc(AddrLen);

            // validate pointer
            if (pTLE->SourceAddress.stream != NULL) {

                // initialize length values
                pTLE->SourceAddress.length  = AddrLen;
                pTLE->SourceAddress.dynamic = TRUE;

                // transfer agent address information
                memcpy(pTLE->SourceAddress.stream, AddrPtr, AddrLen);
            }

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpEntityToStr returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }
    }

    // check if community specified
    if (hViewContext != (HSNMP_CONTEXT)NULL) {

        // convert agent entity to string
        status = SnmpContextToStr(hViewContext, &CommunityStr);

        // validate error code
        if (WSNMP_SUCCEEDED(status)) {

            // copy octet string, memory allocated in CommunityStr is also freed
            CopyOctets(&pTLE->Community, &CommunityStr);

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpContextToStr returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }
    }

    // transfer
    *ppTLE = pTLE;

    // success
    return TRUE;

cleanup:

    // release
    FreeTle(pTLE);

    // failure
    return FALSE;
}


BOOL
NotificationCallback(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Callback for processing notification messages.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if processing finished.

--*/

{
    BOOL fDone = TRUE;
    SNMPAPI_STATUS status;
    HSNMP_ENTITY   hAgentEntity   = (HSNMP_ENTITY)NULL;
    HSNMP_ENTITY   hManagerEntity = (HSNMP_ENTITY)NULL;
    HSNMP_CONTEXT  hViewContext   = (HSNMP_CONTEXT)NULL;
    smiINT32       nPduType;
    smiINT32       nRequestId;

    // validate pointer
    WSNMP_ASSERT(pSMS != NULL);

    // retrieve message
    status = SnmpRecvMsg(
                pSMS->hSnmpSession,
                &hAgentEntity,
                &hManagerEntity,
                &hViewContext,
                &pSMS->hPdu
                );

    // validate return code
    if (WSNMP_SUCCEEDED(status)) {

        // retrieve pdu data
        status = SnmpGetPduData(
                    pSMS->hPdu,
                    &nPduType,
                    &nRequestId,
                    &pSMS->nErrorStatus,
                    &pSMS->nErrorIndex,
                    &pSMS->hVbl
                    );

        // validate return code
        if (WSNMP_SUCCEEDED(status)) {

            // process reponse to request
            if (nPduType == SNMP_PDU_RESPONSE) {

                // validate context information
                if ((pSMS->nRequestId == nRequestId) &&
                    (pSMS->hViewContext == hViewContext) &&
                    (pSMS->hAgentEntity == hAgentEntity) &&
                    (pSMS->hManagerEntity == hManagerEntity)) {

                    // validate returned error status
                    if (pSMS->nErrorStatus == SNMP_ERROR_NOERROR) {

                        SnmpVarBindList VarBindList;

                        // copy variable binding list
                        if (CopyVbl(pSMS, &VarBindList)) {

                            // release existing varbind list
                            SnmpUtilVarBindListFree(pSMS->pVarBindList);

                            // manually copy new varbind list
                            *pSMS->pVarBindList = VarBindList;

                        } else {

                            // modify last error status
                            pSMS->nLastError = SNMPAPI_ALLOC_ERROR;
                        }
                    }

                } else {

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "MGMTAPI: Ignoring invalid context.\n"
                        ));

                    // continue
                    fDone = FALSE;
                }

            } else if (nPduType == SNMP_PDU_TRAP) {

                PTRAP_LIST_ENTRY pTLE;

                // allocate trap list entry (transfers varbinds etc.)
                if (AllocateTle(pSMS, &pTLE, hAgentEntity, hViewContext)) {

                    // obtain exclusive access
                    EnterCriticalSection(&g_GlobalLock);

                    // insert new trap into the incoming queue
                    InsertTailList(&g_IncomingTraps, &pTLE->Link);

                    // alert user
                    SetEvent(g_hTrapEvent);

                    // release exclusive access
                    LeaveCriticalSection(&g_GlobalLock);
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Ignoring invalid pdu type %d.\n",
                    nPduType
                    ));

                // continue
                fDone = FALSE;
            }

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpGetPduData returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // retrieve last error status from winsnmp
            pSMS->nLastError = SnmpGetLastError(pSMS->hSnmpSession);
        }

        // release temporary entity
        SnmpFreeEntity(hAgentEntity);

        // release temporary entity
        SnmpFreeEntity(hManagerEntity);

        // release temporary context
        SnmpFreeContext(hViewContext);

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpRecvMsg returned %d.\n",
            SnmpGetLastError(pSMS->hSnmpSession)
            ));

        // retrieve last error status from winsnmp
        pSMS->nLastError = SnmpGetLastError(pSMS->hSnmpSession);

    }

    // release pdu
    FreePdu(pSMS);

    return fDone;
}


LRESULT
CALLBACK
NotificationWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Callback that processes WinSNMP notifications.

Arguments:

    hWnd - window handle.

    uMsg - message identifier.

    wParam - first message parameter.

    lParam - second message parameter.

Return Values:

    The return value is the result of the message processing and
    depends on the message sent.

--*/

{
    // check for winsnmp notification and transport timeout
    if (uMsg == WM_WSNMP_INCOMING && wParam == SNMPAPI_TL_TIMEOUT) {
        
        PSNMP_MGR_SESSION pSMS;

        // retrieve mgmtapi session pointer from window
        pSMS = (PSNMP_MGR_SESSION)GetWindowLongPtr(hWnd, 0);

        // validate session ptr
        WSNMP_ASSERT(pSMS != NULL);

        // translate winsnmp error to mgmtapi error
        pSMS->nLastError = SNMP_MGMTAPI_TIMEOUT;

        // post message to break out of message pump
        PostMessage(pSMS->hWnd, WM_WSNMP_DONE, (WPARAM)0, (LPARAM)0);
        
        return (LRESULT)0;
    }
    // check for winsnmp notification
    else if (uMsg == WM_WSNMP_INCOMING) {

        PSNMP_MGR_SESSION pSMS;

        // retrieve mgmtapi session pointer from window
        pSMS = (PSNMP_MGR_SESSION)GetWindowLongPtr(hWnd, 0);

        // validate session ptr
        WSNMP_ASSERT(pSMS != NULL);

        // process notification message
        if (NotificationCallback(pSMS)) {

            // post message to break out of message pump
            PostMessage(pSMS->hWnd, WM_WSNMP_DONE, (WPARAM)0, (LPARAM)0);
        }

        return (LRESULT)0;

    } else {

        // forward all other messages to windows
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
}


BOOL
RegisterNotificationClass(
    )

/*++

Routine Description:

    Register notification class for sessions.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    WNDCLASS wc;

    // initialize notification window class
    wc.lpfnWndProc   = NotificationWndProc;
    wc.lpszClassName = NOTIFICATION_CLASS;
    wc.lpszMenuName  = NULL;
    wc.hInstance     = g_hDll;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.cbWndExtra    = sizeof(PSNMP_MGR_SESSION);
    wc.cbClsExtra    = 0;
    wc.style         = 0;

    // register class
    fOk = RegisterClass(&wc);

    if (!fOk) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: RegisterClass returned %d.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
UnregisterNotificationClass(
    )

/*++

Routine Description:

    Unregister notification class.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // unergister notification window class
    fOk = UnregisterClass(NOTIFICATION_CLASS, g_hDll);

    if (!fOk) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: UnregisterClass returned %d.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
StartSnmpIfNecessary(
    )

/*++

Routine Description:

    Initialize WinSNMP DLL if necessary.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // serialize access to startup code
    EnterCriticalSection(&g_GlobalLock);

    // see if already started
    if (g_fIsSnmpStarted != TRUE) {

        SNMPAPI_STATUS status;

        // initialize start params
        smiUINT32 nMajorVersion   = 0;
        smiUINT32 nMinorVersion   = 0;
        smiUINT32 nLevel          = 0;
        smiUINT32 nTranslateMode  = 0;
        smiUINT32 nRetransmitMode = 0;

        // start winsnmp
        status = SnmpStartup(
                    &nMajorVersion,
                    &nMinorVersion,
                    &nLevel,
                    &nTranslateMode,
                    &nRetransmitMode
                    );

        // validate return code
        if (WSNMP_SUCCEEDED(status)) {

            SNMPDBG((
                SNMP_LOG_TRACE,
                "MGMTAPI: SnmpStartup succeeded:\n"
                "MGMTAPI:\tnMajorVersion   = %d\n"
                "MGMTAPI:\tnMinorVersion   = %d\n"
                "MGMTAPI:\tnLevel          = %d\n"
                "MGMTAPI:\tnTranslateMode  = %d\n"
                "MGMTAPI:\tnRetransmitMode = %d\n",
                nMajorVersion,
                nMinorVersion,
                nLevel,
                nTranslateMode,
                nRetransmitMode
                ));

            // allocate global trap available event
            if ((g_hTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: CreateEvent returned %d.\n",
                    GetLastError()
                    ));

                // failure
                goto cleanup;
            }

            // allocate global event to sync. SnmpMgrTrapListen
            if ((g_hTrapRegisterdEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) ==NULL)
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: CreateEvent returned %d.\n",
                    GetLastError()
                    ));

                // failure
                goto cleanup;
            }

            // make sure translate mode is snmp v1
            status = SnmpSetTranslateMode(SNMPAPI_UNTRANSLATED_V1);
            if (WSNMP_FAILED(status)) 
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpSetTranslateMode returned %d.\n",
                    SnmpGetLastError((HSNMP_SESSION)NULL)
                    ));

                // failure
                goto cleanup;
            }

            // make sure retransmit mode is on
            status = SnmpSetRetransmitMode(SNMPAPI_ON);
            if (WSNMP_FAILED(status)) 
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpSetRetransmitMode returned %d.\n",
                    SnmpGetLastError((HSNMP_SESSION)NULL)
                    ));

                // failure
                goto cleanup;
            }

            // register notification class
            if (!RegisterNotificationClass())
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: RegisterNotificationClass returned %d.\n",
                    GetLastError()
                    ));

                // failure
                goto cleanup;
            }

            // save new status
            g_fIsSnmpStarted = TRUE;

            // success
            fOk = TRUE;

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStartup returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure, but no need to cleanup
            fOk = FALSE;
        }

    } else {

        fOk = TRUE;

    }

    // serialize access to startup code
    LeaveCriticalSection(&g_GlobalLock);

    return fOk;

cleanup:

    // cleanup if necessary
    
    SnmpCleanup(); // ignore any return status at this stage
    
    if (g_hTrapEvent)
    {
        CloseHandle(g_hTrapEvent);
        g_hTrapEvent = NULL;
    }
    
    if (g_hTrapRegisterdEvent)
    {
        CloseHandle(g_hTrapRegisterdEvent);
        g_hTrapRegisterdEvent = NULL;
    }

    LeaveCriticalSection(&g_GlobalLock);
    
    return FALSE;
}


BOOL
CleanupIfNecessary(
    )

/*++

Routine Description:

    Cleanup WinSNMP DLL if necessary.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // serialize access to startup code
    EnterCriticalSection(&g_GlobalLock);

    // see if already started
    if (g_fIsSnmpStarted == TRUE) {

        SNMPAPI_STATUS status;

        // shutdown winsnmp
        status = SnmpCleanup();

        // validate return code
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpCleanup returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // unregister notification class
        UnregisterNotificationClass();

        // save new status
        g_fIsSnmpStarted = FALSE;
    }

    // check trap handle
    if (g_hTrapEvent != NULL) {

        // close trap handle
        CloseHandle(g_hTrapEvent);

        // re-initialize
        g_hTrapEvent = NULL;
    }
    
    // check event that syncs SnmpMgrTrapListen
    if (g_hTrapRegisterdEvent != NULL)
    {
        // close trap handle
        CloseHandle(g_hTrapRegisterdEvent);

        // re-initialize
        g_hTrapRegisterdEvent = NULL;
    }

    // serialize access to startup code
    LeaveCriticalSection(&g_GlobalLock);

    return fOk;
}

DWORD AddMgmtRef()
/*++

Routine Description:

    Increment the reference count on using the mgmtapi.dll module.

Arguments:

    none

Return Values:

    Returns the reference count value after the increment is done.

--*/
{
    EnterCriticalSection(&g_GlobalLock);

    ++g_cSnmpMgmtRef;
    
    LeaveCriticalSection(&g_GlobalLock);
    
    return g_cSnmpMgmtRef;
}

DWORD ReleaseMgmtRef()
/*++

Routine Description:

    Decrement the reference count if it is greater than zero. 
    Call CleanupIfNecessary if the reference count on using mgmtapi.dll becomes
    zero after the decrement.

Arguments:

    none

Return Values:

    Returns the final reference count value.

--*/
{
    EnterCriticalSection(&g_GlobalLock);

    if (g_cSnmpMgmtRef)
    {
        --g_cSnmpMgmtRef;
        if (g_cSnmpMgmtRef == 0)
        {
            CleanupIfNecessary();
        }
    }
    
    LeaveCriticalSection(&g_GlobalLock);
    
    return g_cSnmpMgmtRef;
}


BOOL
CreateNotificationWindow(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Create notification window for session.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // create notification window
    pSMS->hWnd = CreateWindow(
                    NOTIFICATION_CLASS,
                    NULL,       // pointer to window name
                    0,          // window style
                    0,          // horizontal position of window
                    0,          // vertical position of window
                    0,          // window width
                    0,          // window height
                    NULL,       // handle to parent or owner window
                    NULL,       // handle to menu or child-window identifier
                    g_hDll,     // handle to application instance
                    NULL        // pointer to window-creation data
                    );

    // validate window handle
    if (pSMS->hWnd != NULL) {

        // store pointer to session in window
        SetWindowLongPtr(pSMS->hWnd, 0, (LONG_PTR)pSMS);

        // success
        fOk = TRUE;

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: CreateWindow returned %d.\n",
            GetLastError()
            ));

        // failure
        fOk = FALSE;
    }

    return fOk;
}


BOOL
DestroyNotificationWindow(
    HWND hWnd
    )

/*++

Routine Description:

    Destroy notification window for session.

Arguments:

    hWnd - window handle for session.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // destroy notification window
    fOk = DestroyWindow(hWnd);

    if (!fOk) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: DestroyWindow returned %d.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
CloseSession(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Close WinSNMP session associated with MGMTAPI session.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // check if window opened
    if (pSMS->hWnd != (HWND)NULL) {

        // destroy notification window
        fOk = DestroyNotificationWindow(pSMS->hWnd);
    }

    // check if agent entity allocated
    if (pSMS->hAgentEntity != (HSNMP_ENTITY)NULL) {

        // close the entity handle
        status = SnmpFreeEntity(pSMS->hAgentEntity);

        // validate status
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreeEntity returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize
        pSMS->hAgentEntity = (HSNMP_ENTITY)NULL;
    }

    // check if manager entity allocated
    if (pSMS->hManagerEntity != (HSNMP_ENTITY)NULL) {

        // close the entity handle
        status = SnmpFreeEntity(pSMS->hManagerEntity);

        // validate status
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreeEntity returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize
        pSMS->hManagerEntity = (HSNMP_ENTITY)NULL;
    }

    // check if session allocated
    if (pSMS->hSnmpSession != (HSNMP_SESSION)NULL) {

        // close the winsnmp session
        status = SnmpClose(pSMS->hSnmpSession);

        // validate status
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpClose returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize
        pSMS->hSnmpSession = (HSNMP_SESSION)NULL;
    }

    return fOk;
}

//SNMPAPI_STATUS SNMPAPI_CALL
//   SnmpConveyAgentAddress (SNMPAPI_STATUS mode);


BOOL
OpenSession(
    PSNMP_MGR_SESSION pSMS,
    LPSTR             pAgentAddress,
    LPSTR             pAgentCommunity,
    INT               nTimeOut,
    INT               nRetries
    )

/*++

Routine Description:

    Open WinSNMP session and associate with MGMTAPI session.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

    pAgentAddress - points to a null-terminated string specifying either a
        dotted-decimal IP address or a host name that can be resolved to an
        IP address, an IPX address (in 8.12 notation), or an ethernet address.

    pAgentCommunity - points to a null-terminated string specifying the
        SNMP community name used when communicating with the agent specified
        in the lpAgentAddress parameter

    nTimeOut - specifies the communications time-out in milliseconds.

    nRetries - specifies the communications retry count.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    struct sockaddr AgentSockAddr;
    CHAR AgentStrAddr[MAXENTITYSTRLEN+1];
    smiOCTETS smiCommunity;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // initialize notification window
    if (!CreateNotificationWindow(pSMS)) {
        return FALSE; // bail...
    }

    // open a winsnmp session which corresponds to mgmtapi session
    pSMS->hSnmpSession = SnmpOpen(pSMS->hWnd, WM_WSNMP_INCOMING);

    // --ft
    // we need to turn this on in order to have WINSNMP to pass back not
    // only the entity standing for the source Ip address but also the
    // agent address as it was sent into the V1 Trap Pdu. Without it,
    // SnmpMgrGetTrapEx() will return a NULL address for the pSourceAddress
    // paramter. However, SnmpMgrGetTrapEx() is not documented!!!
    //SnmpConveyAgentAddress(SNMPAPI_ON); // Move this into wsnmp_cf.c:SnmpStartup
    // to avoid missing entry point problem when wsnmp32.dll is from other vendors

    // validate session handle returned
    if (WSNMP_FAILED(pSMS->hSnmpSession)) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpOpen returned %d.\n",
            SnmpGetLastError((HSNMP_SESSION)NULL)
            ));

        // re-initialize
        pSMS->hSnmpSession = (HSNMP_SESSION)NULL;

        goto cleanup; // bail...
    }

    // validate pointer
    if (pAgentAddress != NULL) {

        AgentStrAddr[MAXENTITYSTRLEN] = '\0';

        // use snmpapi.dll to do convert to sockets structure
        if (!SnmpSvcAddrToSocket(pAgentAddress, &AgentSockAddr)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Ignoring invalid address.\n"
                ));

            goto cleanup; // bail...
        }

        // check address family of agent
        if (AgentSockAddr.sa_family == AF_INET) {

            LPSTR pAgentStrAddr;
            struct sockaddr_in * pAgentSockAddr;

            // cast generic socket address structure to inet
            pAgentSockAddr = (struct sockaddr_in *)&AgentSockAddr;

            // obtain exclusive access to api
            EnterCriticalSection(&g_GlobalLock);

            // attempt to convert address into string
            pAgentStrAddr = inet_ntoa(pAgentSockAddr->sin_addr);

            // copy to stack variable
            strncpy(AgentStrAddr, pAgentStrAddr, MAXENTITYSTRLEN);

            // release exclusive access to api
            LeaveCriticalSection(&g_GlobalLock);

        } else if (AgentSockAddr.sa_family == AF_IPX) {

            // simply copy original string
            strncpy(AgentStrAddr, pAgentAddress, MAXENTITYSTRLEN);

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Incorrect address family.\n"
                ));

            goto cleanup; // bail...
        }

        // create remote agent entity
        pSMS->hAgentEntity = SnmpStrToEntity(
                                    pSMS->hSnmpSession,
                                    AgentStrAddr
                                    );

        // validate agent entity returned
        if (WSNMP_FAILED(pSMS->hAgentEntity)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStrToEntity returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pSMS->hAgentEntity = (HSNMP_ENTITY)NULL;

            goto cleanup; // bail...
        }

        // attach timeout specified with agent
        status = SnmpSetTimeout(pSMS->hAgentEntity, nTimeOut / 10);
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpSetTimeout returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }

        // attach retries specified with agent
        status = SnmpSetRetry(pSMS->hAgentEntity, nRetries);
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpSetRetry returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }

        // create local manager entity
        pSMS->hManagerEntity = SnmpStrToEntity(
                                        pSMS->hSnmpSession,
                                        (AgentSockAddr.sa_family == AF_INET)
                                            ? DEFAULT_ADDRESS_IP
                                            : DEFAULT_ADDRESS_IPX
                                        );

        // validate manager entity returned
        if (WSNMP_FAILED(pSMS->hManagerEntity)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStrToEntity returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pSMS->hManagerEntity = (HSNMP_ENTITY)NULL;

            goto cleanup; // bail...
        }

        // attach timeout specified with manager
        status = SnmpSetTimeout(pSMS->hManagerEntity, nTimeOut / 10);
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpSetTimeout returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }

        // attach retries specified with manager
        status = SnmpSetRetry(pSMS->hManagerEntity, nRetries);
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpSetRetry returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }
    }

    // validate pointer
    if (pAgentCommunity != NULL) {

        // transfer community string
        smiCommunity.ptr = (smiLPBYTE)pAgentCommunity;
        smiCommunity.len = pAgentCommunity ? lstrlen(pAgentCommunity) : 0;

        // obtain context from community string
        pSMS->hViewContext = SnmpStrToContext(
                                pSMS->hSnmpSession,
                                &smiCommunity
                                );

        // validate context handle
        if (WSNMP_FAILED(pSMS->hViewContext)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStrToContext returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pSMS->hViewContext = (HSNMP_CONTEXT)NULL;

            goto cleanup; // bail...
        }
    }

    // success
    return TRUE;

cleanup:

    // cleanup resources
    CloseSession(pSMS);

    // failure
    return FALSE;
}


BOOL
AllocateSession(
    PSNMP_MGR_SESSION * ppSMS
    )

/*++

Routine Description:

    Allocate mgmtapi session structure.

Arguments:

    ppSMS - pointer to session pointer to return.

Return Values:

    Returns true if successful.

--*/

{
    PSNMP_MGR_SESSION pSMS = NULL;

    __try
    {
        // allocate new session table entry
        pSMS = SnmpUtilMemAlloc(sizeof(SNMP_MGR_SESSION));

        // validate pointer
        if (pSMS != NULL) {

            // initialize session level lock
            InitializeCriticalSection(&pSMS->SessionLock);

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Could not allocate session.\n"
                ));

            // notify application of error
            SetLastError(SNMP_MEM_ALLOC_ERROR);
        }

        // transfer
        *ppSMS = pSMS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        if (pSMS != NULL)
        {
            SnmpUtilMemFree(pSMS);
            pSMS = NULL;
        }
    }

    // return status
    return (pSMS != NULL);
}


VOID
FreeSession(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Frees mgmtapi session structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    None.

--*/

{
    // is session valid?
    if (pSMS != NULL) {

        // destroy the session level lock
        DeleteCriticalSection(&pSMS->SessionLock);

        // free session object
        SnmpUtilMemFree(pSMS);
    }
}


BOOL
ProcessAgentResponse(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Message pump for notification window.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

Return Values:

    Returns true if agent responded.

--*/

{
    MSG msg;
    BOOL fOk = FALSE;
    BOOL fRet; 

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // get the next message for this session
    while ((fRet = GetMessage(&msg, pSMS->hWnd, 0, 0))) {
        
        if (fRet == -1) {
            // If there is an error, GetMessage returns -1 
           
            pSMS->nLastError = SNMPAPI_OTHER_ERROR;

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: ProcessAgentResponse: GetMessage returns -1.\n"
                ));
            
            break;
        }

        // check for private message
        if (msg.message != WM_WSNMP_DONE) {

            // translate message
            TranslateMessage(&msg);

            // dispatch message
            DispatchMessage(&msg);

        } else {

            // success
            fOk = TRUE;

            break;
        }
    }

    return fOk;
}


DWORD
WINAPI
TrapThreadProc(
    LPVOID lpParam
    )

/*++

Routine Description:

    Trap processing procedure.

Arguments:

    lpParam - unused thread parameter.

Return Values:

    Returns NOERROR if successful.

--*/

{
    SNMPAPI_STATUS status;
    PSNMP_MGR_SESSION pSMS;

    SNMPDBG((
        SNMP_LOG_TRACE,
        "MGMTAPI: Trap thread starting...\n"
        ));

    // obtain pointer
    pSMS = &g_TrapSMS;

    
    // re-initialize
    ZeroMemory(&g_TrapSMS, sizeof(g_TrapSMS));

    g_fIsTrapRegistered = FALSE; // init to failure. Note that there will
                                 // be only 1 instance of this thread


    // initialize winsnmp trap session
    if (OpenSession(pSMS, NULL, NULL, 0, 0)) 
    {

        // register
        status = SnmpRegister(
                    pSMS->hSnmpSession,
                    (HSNMP_ENTITY)NULL,     // hAgentEntity
                    (HSNMP_ENTITY)NULL,     // hManagerEntity
                    (HSNMP_CONTEXT)NULL,    // hViewContext
                    (smiLPCOID)NULL,        // notification
                    SNMPAPI_ON
                    );

        // validate return code
        if (WSNMP_SUCCEEDED(status)) 
        {
            // signal main thread that Trap has been registered with WinSNMP
            g_fIsTrapRegistered = TRUE;
            SetEvent(g_hTrapRegisterdEvent);

            // loop processing responses
            while (ProcessAgentResponse(pSMS)) 
            {

                //
                // processing done in window procedure...
                //
            }

        } 
        else 
        {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpRegister returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // transfer last error to global structure
            pSMS->nLastError = SnmpGetLastError(pSMS->hSnmpSession);

            // signal main thread that there is an error 
            // in registering Trap with WinSNMP
            
            SetEvent(g_hTrapRegisterdEvent);
        }

    } 
    else 
    {

        // transfer last error to global structure
        pSMS->nLastError = SnmpGetLastError((HSNMP_SESSION)NULL);
        
        // signal main thread that there is an error 
        // in registering Trap with WinSNMP
      
        SetEvent(g_hTrapRegisterdEvent);

        goto ERROR_OUT;
    }

    if (g_fIsTrapRegistered)
    {
        // unregister WinSNMP notification reception
        status = SnmpRegister(
                    pSMS->hSnmpSession,
                    (HSNMP_ENTITY)NULL,     // hAgentEntity
                    (HSNMP_ENTITY)NULL,     // hManagerEntity
                    (HSNMP_CONTEXT)NULL,    // hViewContext
                    (smiLPCOID)NULL,        // notification
                    SNMPAPI_OFF
                    );

        // validate return code
        if (WSNMP_FAILED(status)) 
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpRegister SNMPAPI_OFF returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));
        }
    }

    // free session
    CloseSession(pSMS);

ERROR_OUT:

    // obtain exclusive access
    EnterCriticalSection(&g_GlobalLock);

    // signal this thread has gone
    g_fIsSnmpListening = FALSE;

    // release exclusive access
    LeaveCriticalSection(&g_GlobalLock);

    SNMPDBG((
        SNMP_LOG_TRACE,
        "MGMTAPI: Trap thread exiting...\n"
        ));

    // success
    return NOERROR;
}


BOOL
StartTrapsIfNecessary(
    HANDLE * phTrapAvailable
    )

/*++

Routine Description:

    Initializes global structures for trap listening.

Arguments:

    phTrapAvailable - pointer to event for signalling traps.

Return Values:

    Returns true if successful (must be called only once).

--*/

{
    BOOL fOk = FALSE;
    DWORD dwTrapThreadId;
    DWORD dwWaitTrapRegisterd;

    // validate pointer
    if (phTrapAvailable != NULL) 
    {

        // obtain exclusive access
        EnterCriticalSection(&g_GlobalLock);

        // transfer trap event to app
        *phTrapAvailable = g_hTrapEvent;

        // only start listening once
        if (g_fIsSnmpListening == FALSE) 
        {

            // spawn client trap thread
            g_hTrapThread = CreateThread(
                                NULL,   // lpThreadAttributes
                                0,      // dwStackSize
                                TrapThreadProc,
                                NULL,   // lpParameter
                                0,      // dwCreationFlags
                                &dwTrapThreadId
                                );

            if (g_hTrapThread != NULL)
            {
            
                // signal successful start
                g_fIsSnmpListening = TRUE;

                // release exclusive access
                LeaveCriticalSection(&g_GlobalLock);

                // WinSE bug 6182
                // wait for TrapThreadProc to signal sucessful or failure
                dwWaitTrapRegisterd = WaitForSingleObject(g_hTrapRegisterdEvent, INFINITE);
                if (dwWaitTrapRegisterd == WAIT_OBJECT_0)
                {
                    if (g_fIsTrapRegistered == TRUE)
                        fOk = TRUE;  // success
                    else
                    {
                        CloseHandle(g_hTrapThread);
                        g_hTrapThread = NULL;
                        SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);


                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "MGMTAPI: Traps are not accessible.\n"
                            ));

                    }
                }
                else
                {
                    CloseHandle(g_hTrapThread);
                    g_hTrapThread = NULL;
                    SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "MGMTAPI: Traps are not accessible.\n"
                        ));
                }
                // In case where fOk == TRUE, g_hTrapThread will be closed when 
                // - new app calls SnmpMgrClose(NULL) 
                // OR 
                // - DLL_PROCESS_DETACH in DllMain is called for legacy app.
            }
            else
            {
                
                // release exclusive access
                LeaveCriticalSection(&g_GlobalLock);

                SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: CreateThread TrapThreadProc failed %d.\n",
                    GetLastError()
                    ));
            }
        } 
        else 
        {

            // whine about having called this before
            SetLastError(SNMP_MGMTAPI_TRAP_DUPINIT);

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Duplicate registration detected.\n"
                ));
            // release exclusive access
            LeaveCriticalSection(&g_GlobalLock);
        }

    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Dll Entry Point                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

    hDll - module handle.

    dwReason - reason DllMain is being called.

    lpReserved - unused.

Return Values:

    None.

--*/

{
    BOOL bOk = TRUE;

    __try
    {
        // determine reason for being called
        if (dwReason == DLL_PROCESS_ATTACH)
        {

            // initialize startup critical section
            InitializeCriticalSection(&g_GlobalLock);

            // initialize list of incoming traps
            InitializeListHead(&g_IncomingTraps);

            // optimize thread startup
            DisableThreadLibraryCalls(hDll);

            // save handle
            g_hDll = hDll;
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {
            if (g_hTrapThread)
            {
                CloseHandle(g_hTrapThread);
            }
            // cleanup winsnmp
            CleanupIfNecessary();

            // nuke startup critical section
            DeleteCriticalSection(&g_GlobalLock);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bOk = FALSE;
    }

    return bOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
LPSNMP_MGR_SESSION
SNMP_FUNC_TYPE
SnmpMgrOpen(
    LPSTR pAgentAddress,
    LPSTR pAgentCommunity,
    INT   nTimeOut,
    INT   nRetries
    )

/*++

Routine Description:

    Initializes resources necessary for communication with specified agent.

Arguments:

    pAgentAddress - points to a null-terminated string specifying either a
        dotted-decimal IP address or a host name that can be resolved to an
        IP address, an IPX address (in 8.12 notation), or an ethernet address.

    pAgentCommunity - points to a null-terminated string specifying the
        SNMP community name used when communicating with the agent specified
        in the lpAgentAddress parameter

    nTimeOut - specifies the communications time-out in milliseconds.

    nRetries - specifies the communications retry count.

Return Values:

    Returns session handle if successful.

--*/

{
    PSNMP_MGR_SESSION pSMS = NULL;

    // initialize winsnmp
    if (StartSnmpIfNecessary()) {

        // allocate mgmtapi session
        if (AllocateSession(&pSMS)) {

            // open session
            if (!OpenSession(
                    pSMS,
                    pAgentAddress,
                    pAgentCommunity,
                    nTimeOut,
                    nRetries)) {

                // free session
                FreeSession(pSMS);

                // reset
                pSMS = NULL;
            }
            else
            {
                // add ref
                AddMgmtRef();
            }
        }
    }

    // return opaque pointer
    return (LPSNMP_MGR_SESSION)pSMS;
}

BOOL
SNMP_FUNC_TYPE
SnmpMgrCtl(
    LPSNMP_MGR_SESSION session,             // pointer to the MGMTAPI session
    DWORD              dwCtlCode,           // control code for the command requested
    LPVOID             lpvInBuffer,         // buffer with the input parameters for the operation
    DWORD              cbInBuffer,          // size of lpvInBuffer in bytes
    LPVOID             lpvOUTBuffer,        // buffer for all the output parameters of the command
    DWORD              cbOUTBuffer,         // size of lpvOUTBuffer
    LPDWORD            lpcbBytesReturned    // space used from lpvOutBuffer
    )
/*++

Routine Description:

    Operates several control operations over the MGMTAPI session

Arguments:

    pSession - pointer to the session to 


Return Values:


--*/
{
    BOOL bOk = FALSE;
    PSNMP_MGR_SESSION pSMS = (PSNMP_MGR_SESSION)session;

    switch(dwCtlCode)
    {
    case MGMCTL_SETAGENTPORT:
        if (pSMS == NULL)
            SetLastError(SNMP_MGMTAPI_INVALID_SESSION);
        else if (lpvInBuffer == NULL || cbInBuffer < sizeof(UINT))
            SetLastError(SNMP_MGMTAPI_INVALID_BUFFER);
        else if (WSNMP_FAILED(SnmpSetPort(pSMS->hAgentEntity, *(UINT*)lpvInBuffer)))
            SetLastError(SnmpGetLastError(pSMS->hSnmpSession));
        else
            bOk = TRUE;
        break;

    default:
        SetLastError(SNMP_MGMTAPI_INVALID_CTL);
        break;
    }

    return bOk;
}

BOOL
SNMP_FUNC_TYPE
SnmpMgrClose(
    LPSNMP_MGR_SESSION session
    )

/*++

Routine Description:

    Cleanups resources needed for communication with specified agent.

Arguments:

    session - points to an internal structure that specifies
        which session to close.

Return Values:

    Returns true if successful.

Notes: 
 BUG: 585652
 -Cleanup WinSNMP resources if reference count on using mgmtapi.dll reaches 0
 -SnmpMgrClose(NULL) is used to cleanup resources created by SnmpMgrTrapListen

--*/

{
    BOOL fOk = TRUE;
    DWORD dwWaitResult;
    PSNMP_MGR_SESSION pSMS = (PSNMP_MGR_SESSION)session;

    // validate pointer
    if (pSMS != NULL) {

        // close session
        CloseSession(pSMS);

        // free session
        FreeSession(pSMS);

        // release ref
        ReleaseMgmtRef();
    }
    else if (g_fIsSnmpListening && g_TrapSMS.hWnd && g_hTrapThread)
    {
        
        if (PostMessage(g_TrapSMS.hWnd, WM_QUIT, (WPARAM)0, (LPARAM)0))
        {
            // block until TrapThreadProc has gone
            dwWaitResult = WaitForSingleObject(g_hTrapThread, INFINITE);
            switch (dwWaitResult)
            {
            case WAIT_OBJECT_0 :
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "MGMTAPI: SnmpMgrClose: TrapThreadProc exited.\n"
                    )); 
                break;

            case WAIT_FAILED:
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpMgrClose: WaitForSingleObject returned WAIT_FAILED %u.\n",
                    GetLastError()
                    )); 
                break;
            
            default :
               SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpMgrClose: WaitForSingleObject returned %u.\n",
                    dwWaitResult
                    )); 
                break;
            }
        }
        else
        {
            fOk = FALSE;

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpMgrClose: PostMessage returned %u.\n",
                GetLastError()
                )); 
        }

        if (! CloseHandle(g_hTrapThread))
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpMgrClose: CloseHandle on %u returned %u.\n",
                g_hTrapThread, GetLastError()
                )); 
        }
        g_hTrapThread = NULL;

        // release ref
        ReleaseMgmtRef();
        
    }

    return fOk;
}


SNMPAPI
SNMP_FUNC_TYPE
SnmpMgrRequest(
    LPSNMP_MGR_SESSION session,
    BYTE               requestType,
    SnmpVarBindList  * pVarBindList,
    AsnInteger       * pErrorStatus,
    AsnInteger       * pErrorIndex
    )

/*++

Routine Description:

    Requests the specified operation be performed with the specified agent.

Arguments:

    session - points to an internal structure that specifies the session
        that will perform the request.

    requestType - specifies the SNMP request type.

    pVarBindList - points to the variable bindings list

    pErrorStatus - points to a variable in which the error status result
        will be returned.

    pErrorIndex - points to a variable in which the error index result
        will be returned.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    PSNMP_MGR_SESSION pSMS = (PSNMP_MGR_SESSION)session;

    // validate pointers
    if ((pSMS != NULL) &&
        (pErrorIndex != NULL) &&
        (pErrorStatus != NULL) &&
        (pVarBindList != NULL) &&
        (pVarBindList->len != 0) &&
        (pVarBindList->list != NULL)) {

        // obtain exclusive access to session
        EnterCriticalSection(&pSMS->SessionLock);

        // initialize session structure
        pSMS->pVarBindList = pVarBindList;
        pSMS->nPduType = (smiINT32)(BYTE)requestType;
        pSMS->hVbl = (HSNMP_VBL)NULL;
        pSMS->hPdu = (HSNMP_PDU)NULL;
        pSMS->nErrorStatus = 0;
        pSMS->nErrorIndex = 0;
        pSMS->nLastError = 0;

        // allocate resources
        if (AllocatePdu(pSMS)) {

            // actually send
            status = SnmpSendMsg(
                        pSMS->hSnmpSession,
                        pSMS->hManagerEntity,
                        pSMS->hAgentEntity,
                        pSMS->hViewContext,
                        pSMS->hPdu
                        );

            // release now
            FreePdu(pSMS);

            // validate return code
            if (WSNMP_SUCCEEDED(status)) {

                // process agent response
                if (ProcessAgentResponse(pSMS) &&
                   (pSMS->nLastError == SNMP_ERROR_NOERROR)) {

                    // update error status and index
                    *pErrorStatus = pSMS->nErrorStatus;
                    *pErrorIndex  = pSMS->nErrorIndex;

                    // success
                    fOk = TRUE;

                } else {

                    // set error to winsnmp error
                    SetLastError(pSMS->nLastError);

                    // failure
                    fOk = FALSE;
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpSendMsg returned %d.\n",
                    SnmpGetLastError(pSMS->hSnmpSession)
                    ));
            }
        }

        // release exclusive access to session
        LeaveCriticalSection(&pSMS->SessionLock);
    }

    return fOk;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrStrToOid(
    LPSTR                 pString,
    AsnObjectIdentifier * pOID
    )

/*++

Routine Description:

    Converts a string object identifier or object descriptor representation
    to an internal object identifier.

Arguments:

    pString - points to a null-terminated string to be converted.

    pOID - points to an object identifier variable that will receive the
        converted value.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer to oid and string
    if ((pOID != NULL) && (pString != NULL)) {

        // forward to mibcc code for now
        return SnmpMgrText2Oid(pString, pOID);
    }

    return FALSE;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrOidToStr(
    AsnObjectIdentifier * pOID,
    LPSTR               * ppString
    )

/*++

Routine Description:

    Converts an internal object identifier to a string object identifier or
    object descriptor representation.

Arguments:

    pOID - pointers to object identifier to be converted.

    ppString - points to string pointer to receive converted value.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer to oid and string
    if ((pOID != NULL) && (ppString != NULL)) {

        // forward to mibcc code for now
        return SnmpMgrOid2Text(pOID, ppString);
    }

    return FALSE;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrTrapListen(
    HANDLE * phTrapAvailable
    )

/*++

Routine Description:

    Registers the ability of a manager application to receive SNMP traps.

Arguments:

    phTrapAvailable - points to an event handle that will be used to indicate
        that there are traps available

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // startup winsnmp
    if (StartSnmpIfNecessary()) {

        // spawn only one trap client thread
        if (StartTrapsIfNecessary(phTrapAvailable)) {

            // success
            fOk = TRUE;

            // add ref
            AddMgmtRef();
        }
    }

    return fOk;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrGetTrap(
    AsnObjectIdentifier * pEnterpriseOID,
    AsnNetworkAddress   * pAgentAddress,
    AsnInteger          * pGenericTrap,
    AsnInteger          * pSpecificTrap,
    AsnTimeticks        * pTimeStamp,
    SnmpVarBindList     * pVarBindList
    )

/*++

Routine Description:

    Returns outstanding trap data that the caller has not received if
    trap reception is enabled.

Arguments:

    pEnterpriseOID - points to an object identifier that specifies the
        enterprise that generated the SNMP trap

    pAgentAddress - points to the address of the agent that generated the
        SNMP trap (retrieved from PDU).

    pGenericTrap - points to an indicator of the generic trap id.

    pSpecificTrap - points to an indicator of the specific trap id.

    pTimeStamp - points to a variable to receive the time stamp.

    pVarBindList - points to the associated variable bindings.

Return Values:

    Returns true if successful.

--*/

{
    // forward to new api
    return SnmpMgrGetTrapEx(
                pEnterpriseOID,
                pAgentAddress,
                NULL,
                pGenericTrap,
                pSpecificTrap,
                NULL,
                pTimeStamp,
                pVarBindList
                );
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrGetTrapEx(
    AsnObjectIdentifier * pEnterpriseOID,
    AsnNetworkAddress   * pAgentAddress,
    AsnNetworkAddress   * pSourceAddress,
    AsnInteger          * pGenericTrap,
    AsnInteger          * pSpecificTrap,
    AsnOctetString      * pCommunity,
    AsnTimeticks        * pTimeStamp,
    SnmpVarBindList     * pVarBindList
    )

/*++

Routine Description:

    Returns outstanding trap data that the caller has not received if
    trap reception is enabled.

Arguments:

    pEnterpriseOID - points to an object identifier that specifies the
        enterprise that generated the SNMP trap

    pAgentAddress - points to the address of the agent that generated the
        SNMP trap (retrieved from PDU).

    pSourceAddress - points to the address of the agent that generated the
        SNMP trap (retrieved from network transport).

    pGenericTrap - points to an indicator of the generic trap id.

    pSpecificTrap - points to an indicator of the specific trap id.

    pCommunity - points to structure to receive community string.

    pTimeStamp - points to a variable to receive the time stamp.

    pVarBindList - points to the associated variable bindings.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PLIST_ENTRY pLE = NULL;
    PTRAP_LIST_ENTRY pTLE = NULL;
    smiINT32 nLastError;

    // obtain exclusive access
    EnterCriticalSection(&g_GlobalLock);

    // make sure list has entries
    if (!IsListEmpty(&g_IncomingTraps)) {

        // remove first item from list
        pLE = RemoveHeadList(&g_IncomingTraps);

    } else {

        // check for trap thread failure
        nLastError = g_TrapSMS.nLastError;
    }

    // release exclusive access
    LeaveCriticalSection(&g_GlobalLock);

    // validate pointer
    if (pLE != NULL) {

        // retrieve pointer to trap list entry
        pTLE = CONTAINING_RECORD(pLE, TRAP_LIST_ENTRY, Link);

        // validate pointer
        if (pEnterpriseOID != NULL) {

            // manually copy enterprise oid
            *pEnterpriseOID = pTLE->EnterpriseOID;

            // re-initialize list entry
            pTLE->EnterpriseOID.ids = NULL;
            pTLE->EnterpriseOID.idLength = 0;
        }

        // validate pointer
        if (pCommunity != NULL) {

            // transfer string info
            *pCommunity = pTLE->Community;

            // re-initialize list entry
            pTLE->Community.length  = 0;
            pTLE->Community.stream  = NULL;
            pTLE->Community.dynamic = FALSE;
        }

        // validate pointer
        if (pVarBindList != NULL) {

            // transfer varbindlist
            *pVarBindList = pTLE->VarBindList;

            // re-initialize list entry
            pTLE->VarBindList.len  = 0;
            pTLE->VarBindList.list = NULL;
        }

        // validate pointer
        if (pAgentAddress != NULL) {

            // copy structure
            *pAgentAddress = pTLE->AgentAddress;
            
            // remove our reference
            pTLE->AgentAddress.length = 0;
            pTLE->AgentAddress.stream = NULL;
            pTLE->AgentAddress.dynamic = FALSE;
        }

        // validate pointer
        if (pSourceAddress != NULL) {

            // copy structure
            *pSourceAddress = pTLE->SourceAddress;
            
            // remove our reference
            pTLE->SourceAddress.length = 0;
            pTLE->SourceAddress.stream = NULL;
            pTLE->SourceAddress.dynamic = FALSE;
        }

        // validate pointer
        if (pGenericTrap != NULL) {

            // transfer generic trap info
            *pGenericTrap = pTLE->nGenericTrap;
        }

        // validate pointer
        if (pSpecificTrap != NULL) {

            // transfer generic trap info
            *pSpecificTrap = pTLE->nSpecificTrap;
        }

        // validate pointer
        if (pTimeStamp != NULL) {

            // transfer time info
            *pTimeStamp = pTLE->TimeStamp;
        }

        // release
        FreeTle(pTLE);

        // success
        fOk = TRUE;

    } else if (nLastError != NOERROR) {

        // indicate there was an thread error
        SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);

    } else {

        // indicate there are no traps
        SetLastError(SNMP_MGMTAPI_NOTRAPS);
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\mgmtapi\dll\oidconv.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    oidconv.c

Abstract:

    Routines to manage conversions between OID descriptions and numerical OIDs.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <snmp.h>
#include <snmputil.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "oidconv.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

/* name to used when converting OID <--> TEXT */
LPSTR lpInputFileName = "mib.bin";

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define FILENODE_SIZE     sizeof(T_FILE_NODE)
#define OID_PREFIX_LEN    (sizeof MIB_Prefix / sizeof(UINT))
#define STR_PREFIX_LEN    (strlen(MIB_StrPrefix))

#define SEEK_SET  0
#define SEEK_CUR  1

//--------------------------- PRIVATE STRUCTS -------------------------------

   //****************************************************************
   //
   //                     Record structure in file
   //
   //    These are the necessary fields to process a conversion request.
   //    When a request is made, the MIB file is searched sequentially
   //    matching subid's.  The field, lNextOffset, is an offset from the
   //    current file position to the current nodes next sibling.
   //
   //    The text subid for each node is stored directly after the
   //    T_FILE_NODE structure in the file.  Its length is stored in the
   //    field, uStrLen.
   //
   //    This is done because there are no limits placed on the size
   //    of a text subid.  Hence, when the T_FILE_NODE structure is
   //    read from the MIB file, the field, lpszTextSubID is not valid.
   //    The field will eventually point to the storage allocated to
   //    hold the text subid.
   //
   //    The order of the nodes in the file is the same as if the MIB
   //    tree was traversed in a "pre-order" manner.
   //
   //****************************************************************

typedef struct _FileNode {
   long                 lNextOffset;      // This field must remain first
   UINT                 uNumChildren;
   UINT                 uStrLen;
   LPSTR                lpszTextSubID;
   UINT                 uNumSubID;
} T_FILE_NODE;

// mib.bin file actually has the following platform independent format 
// on 32bit(x86) and 64bit(ia64) environment. See Bug# 125494 for detail.
typedef struct _FileNodeEx {
   long                 lNextOffset;      // This field must remain first
   UINT                 uNumChildren;
   UINT                 uStrLen;
   UINT                 uReserved;
   UINT                 uNumSubID;
} T_FILE_NODE_EX;
#define FILENODE_SIZE_EX     sizeof(T_FILE_NODE_EX)

//--------------------------- PRIVATE VARIABLES -----------------------------

LPSTR MIB_StrPrefix = "iso.org.dod.internet.mgmt.mib-2";

UINT MIB_Prefix[] = { 1, 3, 6, 1, 2, 1 };
AsnObjectIdentifier MIB_OidPrefix = { OID_PREFIX_LEN, MIB_Prefix };

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//
// GetNextNode
//    Reads the next record from MIB file into a FILENODE structure.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI GetNextNode(
    IN  HFILE fh,
    OUT T_FILE_NODE * Node
    )

{
    SNMPAPI nResult;
    T_FILE_NODE_EX NodeEx;
    ZeroMemory(&NodeEx, FILENODE_SIZE_EX);
    Node->lpszTextSubID = NULL;

    // Read in node
    if ( FILENODE_SIZE_EX != _lread(fh, (LPSTR)(&NodeEx), FILENODE_SIZE_EX) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }
    
    // Convert node format from mib.bin to format in memory
    // The format in the file is independent of 32bit(x86)/64bit(ia64) 
    // architecture.
    Node->lNextOffset = NodeEx.lNextOffset;
    Node->uNumChildren = NodeEx.uNumChildren;
    Node->uNumSubID = NodeEx.uNumSubID;
    Node->uStrLen = NodeEx.uStrLen;

    // Alloc space for string
    if ( NULL ==
        (Node->lpszTextSubID = SnmpUtilMemAlloc((1+Node->uStrLen) * sizeof(char))) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Read in subid string
    if ( Node->uStrLen != _lread(fh, Node->lpszTextSubID, Node->uStrLen) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // NULL terminate the text sub id
    Node->lpszTextSubID[Node->uStrLen] = '\0';

    nResult = SNMPAPI_NOERROR;

Exit:
    if ( SNMPAPI_ERROR == nResult )
    {
        SnmpUtilMemFree( Node->lpszTextSubID );
        Node->lpszTextSubID = NULL; // prevent memory being double freed
    }

    return nResult;
} // GetNextNode


//
// SkipSubTree
//    Frees a FILENODE and all information contained in it.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
SNMPAPI SkipSubTree(
           IN HFILE fh,
           IN T_FILE_NODE *Node
       )

{
    SNMPAPI     nResult;


    // Skip entire subtree
    if ( HFILE_ERROR == _llseek(fh, Node->lNextOffset, SEEK_CUR) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    nResult = SNMPAPI_NOERROR;

Exit:
    return nResult;
} // SkipSubTree

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// SnmpMgrOid2Text
//    Converts an OID to its textual description.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI SnmpMgrOid2Text(
       IN AsnObjectIdentifier *Oid, // Pointer to OID to convert
       OUT LPSTR *lpszTextOid       // Resulting text OID
       )

{
T_FILE_NODE  Node;
OFSTRUCT     of;
HFILE        fh;
UINT         Siblings;
UINT         OidSubId;
UINT         uTxtOidLen;
BOOL         bFound;
BOOL         bPartial;
BOOL         bDot;
SNMPAPI      nResult;
LPSTR        pszTmpTextOid;

    // OPENISSUE - this code does not generate errors if subid 0 is embeded
    // OPENISSUE - opening file every time could be a performance issue
    // OPENISSUE - optimization of file access could improve performance

    *lpszTextOid = NULL;

    // Open file and check for errors
    if ( HFILE_ERROR == (fh = OpenFile(lpInputFileName, &of, OF_READ|OF_SHARE_DENY_WRITE)) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Test for MIB prefix
    bDot = !( bPartial = OID_PREFIX_LEN < Oid->idLength &&
                        !SnmpUtilOidNCmp(Oid, &MIB_OidPrefix, OID_PREFIX_LEN) );

    // Loop until conversion is finished
    OidSubId           = 0;
    uTxtOidLen         = 0;
    Node.uNumChildren  = 1;
    Node.lpszTextSubID = NULL;
    while ( OidSubId < Oid->idLength )
    {
        // Init to not found on this level
        bFound   = FALSE;
        Siblings = Node.uNumChildren;

        // While there are siblings and the sub id is not found keep looking
        while ( Siblings && !bFound )
        {
            Node.lpszTextSubID = NULL;

            // Get next node from mib.bin file
            if ( SNMPAPI_ERROR == GetNextNode(fh, &Node) )
            {
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }

            Siblings --;

            // Compare the numeric subid's
            if ( Oid->ids[OidSubId] == Node.uNumSubID )
            {
                bFound = TRUE;

                // If OID is a partial, then skip prefix subid's
                if ( OidSubId >= OID_PREFIX_LEN || !bPartial )
                {
                    // Realloc space for text id - add 2 for '.' and NULL terminator
                    if ( NULL == (pszTmpTextOid = 
                            (LPSTR) SnmpUtilMemReAlloc(*lpszTextOid,
                                (uTxtOidLen+Node.uStrLen+2) * sizeof(char))) )
                    {
                        SnmpUtilMemFree( Node.lpszTextSubID );
                        nResult = SNMPAPI_ERROR;
                        goto Exit;
                    }

                    *lpszTextOid = pszTmpTextOid;

                    // Add DOT separator
                    if ( bDot )
                    {
                        (*lpszTextOid)[uTxtOidLen] = '.';

                        // Save text subid
                        memcpy( &(*lpszTextOid)[uTxtOidLen+1],
                                    Node.lpszTextSubID, Node.uStrLen+1 );

                        // Update length of text oid - add one for separator
                        uTxtOidLen += Node.uStrLen + 1;
                    }
                    else
                    {
                        bDot = TRUE;

                        // Save text subid
                        memcpy( &(*lpszTextOid)[uTxtOidLen],
                                    Node.lpszTextSubID, Node.uStrLen+1 );

                        // Update length of text oid
                        uTxtOidLen += Node.uStrLen;
                    }
                }

                // try to convert the next OID subid
                OidSubId ++;
            }
            else
            {
                // Skip over subtree since not a match
                if ( SNMPAPI_ERROR == SkipSubTree(fh, &Node) )
                {
                    SnmpUtilMemFree( Node.lpszTextSubID );
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
               }
            }

            // Free the text sub id read
            SnmpUtilMemFree( Node.lpszTextSubID );
            Node.lpszTextSubID = NULL;
        } // while

        // If no sub id matches
        if ( !bFound )
        {
            break;
        }
    } // while

    // Make sure that the entire OID was converted
    while ( OidSubId < Oid->idLength )
    {
        char NumChar[100];

        // in case _itoa fails, we won't get garbage
        ZeroMemory(NumChar, sizeof(NumChar));

        _itoa( Oid->ids[OidSubId], NumChar, 10 );
        // Realloc space for text id - add 2 for '.' and NULL terminator
        if ( NULL ==
                    (pszTmpTextOid = (LPSTR) SnmpUtilMemReAlloc(*lpszTextOid,
                            (uTxtOidLen+strlen(NumChar)+4) * sizeof(char))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        *lpszTextOid = pszTmpTextOid;

        // Add DOT separator
        (*lpszTextOid)[uTxtOidLen] = '.';

        // Save text subid
        memcpy( &(*lpszTextOid)[uTxtOidLen+1], NumChar, strlen(NumChar)+1 );

        // Skip to next OID subid
        OidSubId ++;

        // Update length of text oid - add one for separator
        uTxtOidLen += strlen(NumChar) + 1;
    } // while

    nResult = SNMPAPI_NOERROR;

Exit:
    if ( HFILE_ERROR != fh )
    {
        _lclose( fh );
    }

    if ( SNMPAPI_ERROR == nResult )
    {
        SnmpUtilMemFree( *lpszTextOid );
        *lpszTextOid = NULL;
    }

    return nResult;
} // SnmpMgrOid2Text



//
// SnmpMgrText2Oid
//    Converts an OID text description to its numerical equivalent.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI SnmpMgrText2Oid(
     IN LPSTR lpszTextOid,           // Pointer to text OID to convert
     IN OUT AsnObjectIdentifier *Oid // Resulting numeric OID
     )

{
#define DELIMETERS         ".\0"


T_FILE_NODE  Node;
OFSTRUCT     of;
HFILE        fh;
UINT         Siblings;
LPSTR        lpszSubId;
LPSTR        lpszWrkOid = NULL;
BOOL         bFound;
UINT         uSubId;
SNMPAPI      nResult;
UINT *       idsTmp;

    // OPENISSUE - this code does not generate errors if subid 0 is embeded
    // OPENISSUE - opening file every time could be a performance issue
    // OPENISSUE - optimization of file access could improve performance

    // Init. OID structure
    Oid->idLength = 0;
    Oid->ids      = NULL;

    // check for null string and empty string
    if ( NULL == lpszTextOid || '\0' == lpszTextOid[0] )
    {
        fh = HFILE_ERROR;
        nResult = SNMPAPI_NOERROR;
        goto Exit;
    }

    // Open file and check for errors
    if ( HFILE_ERROR == (fh = OpenFile(lpInputFileName, &of, OF_READ|OF_SHARE_DENY_WRITE)) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Make working copy of string
    if ( ('.' == lpszTextOid[0]) )
    {
        if ( NULL == (lpszWrkOid = SnmpUtilMemAlloc((strlen(lpszTextOid)+1) * sizeof(char))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        strcpy( lpszWrkOid, lpszTextOid+1 );
    }
    else
    {
        if ( NULL ==
                (lpszWrkOid =
            SnmpUtilMemAlloc((strlen(lpszTextOid)+STR_PREFIX_LEN+1+1) * sizeof(char))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        strcpy( lpszWrkOid, MIB_StrPrefix );
        lpszWrkOid[STR_PREFIX_LEN] = '.';
        strcpy( &lpszWrkOid[STR_PREFIX_LEN+1], lpszTextOid );
    }

    Node.uNumChildren = 1;
    Node.lpszTextSubID = NULL;
    lpszSubId = strtok( lpszWrkOid, DELIMETERS );

    // Loop until conversion is finished
    while ( NULL != lpszSubId )
    {

        // Init to not found on this level
        bFound   = FALSE;
        Siblings = Node.uNumChildren;

        // Check for imbedded numbers
        if ( isdigit(*lpszSubId) )
        {
            UINT I;


            // Make sure this is a NUMBER without alpha's
            for ( I=0;I < strlen(lpszSubId);I++ )
            {
                if ( !isdigit(lpszSubId[I]) )
                {
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
            }

            uSubId = atoi( lpszSubId );
        }
        else
        {
            uSubId = 0;
        }

        // While there are siblings and the sub id is not found keep looking
        while ( Siblings && !bFound )
        {
            
            // Get next sibling
            if ( SNMPAPI_ERROR == GetNextNode(fh, &Node) )
            {
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }

            Siblings --;

            if ( uSubId )
            {
                // Compare the numeric subid's
                if ( Node.uNumSubID == uSubId )
                {
                    bFound = TRUE;

                    // Add space for new sub id
                    if ( NULL ==
                                (idsTmp =
                                (UINT*) SnmpUtilMemReAlloc(Oid->ids, (Oid->idLength+1) * sizeof(UINT))) )
                    {
                        SnmpUtilMemFree( Node.lpszTextSubID );
                        nResult = SNMPAPI_ERROR;
                        goto Exit;
                    }
                    Oid->ids = idsTmp;

                    // Append this sub id to end of numeric OID
                    Oid->ids[Oid->idLength++] = Node.uNumSubID;
                }
            }
            else
            {
                // Compare the text subid's
                if ( !strcmp(lpszSubId, Node.lpszTextSubID) )
                {
                    bFound = TRUE;

                    // Add space for new sub id
                    if ( NULL ==
                                (idsTmp =
                                (UINT*) SnmpUtilMemReAlloc(Oid->ids, (Oid->idLength+1) * sizeof(UINT))) )
                    {
                        SnmpUtilMemFree( Node.lpszTextSubID );
                        nResult = SNMPAPI_ERROR;
                        goto Exit;
                    }
                    Oid->ids = idsTmp;

                    // Append this sub id to end of numeric OID
                    Oid->ids[Oid->idLength++] = Node.uNumSubID;
                }
            }

            // Skip over subtree since not a match
            if ( !bFound && SNMPAPI_ERROR == SkipSubTree(fh, &Node) )
            {
                SnmpUtilMemFree( Node.lpszTextSubID );
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }

            // Free the text sub id read
            SnmpUtilMemFree( Node.lpszTextSubID );
            Node.lpszTextSubID = NULL;
        } // while

        // If no sub id matches
        if ( !bFound )
        {
            break;
        }

        // Advance to next sub id
        lpszSubId = strtok( NULL, DELIMETERS );
    } // while

    // Make sure that the entire OID was converted
    while ( NULL != lpszSubId )
    {
        UINT I;


        // Make sure this is a NUMBER without alpha's
        for ( I=0;I < strlen(lpszSubId);I++ )
        {
            if ( !isdigit(lpszSubId[I]) )
            {
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }
        }

        // Add space for new sub id
        if ( NULL ==
                    (idsTmp = (UINT*) SnmpUtilMemReAlloc(Oid->ids, 
                                        (Oid->idLength+1) * sizeof(UINT))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }
        Oid->ids = idsTmp;

        // Append this sub id to end of numeric OID
        Oid->ids[Oid->idLength++] = atoi( lpszSubId );

        // Advance to next sub id
        lpszSubId = strtok( NULL, DELIMETERS );
    } // while


    // it is illegal for an oid to be less than two subidentifiers
    if (Oid->idLength < 2)
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }


    nResult = SNMPAPI_NOERROR;

Exit:
    if ( HFILE_ERROR != fh )
    {
        _lclose( fh );
    }

    if ( SNMPAPI_ERROR == nResult )
    {
        SnmpUtilOidFree( Oid );
    }

    if ( NULL != lpszWrkOid ) 
    {
        SnmpUtilMemFree ( lpszWrkOid );
    }

    return nResult;
} // SnmpMgrText2Oid

//------------------------------- END ---------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\mgmtapi\dll\oidconv.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    oidconv.h

Abstract:

    Routines to manage conversions between OID descriptions and numerical OIDs.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef oidconv_h
#define oidconv_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>


//--------------------------- PUBLIC STRUCTS --------------------------------

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern LPSTR lpInputFileName; /* name to used when converting OID <--> TEXT */

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI SnmpMgrOid2Text(
           IN AsnObjectIdentifier *Oid, // Pointer to OID to convert
	   OUT LPSTR *String            // Resulting text OID
	   );

SNMPAPI SnmpMgrText2Oid(
         IN LPSTR lpszTextOid,           // Pointer to text OID to convert
	 IN OUT AsnObjectIdentifier *Oid // Resulting numeric OID
	 );

//------------------------------- END ---------------------------------------

#endif /* oidconv_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\mgmtapi\dll\mibcc.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibcc.h

Abstract:

    mibcc.h contains the definitions common to the MIB compiler.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- VERSION INFO ----------------------------------

//--------------------------- PUBLIC CONSTANTS ------------------------------

//--------------------------- PUBLIC STRUCTS --------------------------------

#define UINT unsigned int
#define LPSTR char *

#define BOOL int
#define FALSE 0
#define TRUE 1

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern int lineno;

/* command line switches */
extern BOOL fTreePrint;		/* -p : Print the tree when it is all parsed */
extern BOOL fNodePrint;		/* -n : Print each node as it is added */
extern unsigned int nWarningLevel;
extern unsigned int nStopAfterErrors;

extern LPSTR lpOutputFileName;	/* Global pointer to output file name */

extern FILE *yyin, *yyout;	/* where lex will read its input from */

//--------------------------- PUBLIC PROTOTYPES -----------------------------

extern int yyparse ();
extern void mark_flex_to_init (void);

#define error_out	stdout

//--------------------------- END -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\mgmtapi\dll\mibtree.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibtree.h

Abstract:

    mibtree.h contains the definitions used by the MIB tree routines.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef mibtree_h
#define mibtree_h
 
//--------------------------- PUBLIC CONSTANTS ------------------------------
//--------------------------- PUBLIC STRUCTS --------------------------------

typedef struct _TreeNode {
   struct _TreeNode *   lpParent;           /* pointer to parent */
   struct _TreeNode * * lpChildArray;       /* array is alloced */
   UINT                 uNumChildren;
   LPSTR                lpszTextSubID;
   UINT                 uNumSubID;
} TreeNode, *lpTreeNode;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern lpTreeNode lpMIBRoot;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

void TreeInit (lpTreeNode *lplpRoot);
void TreeDeInit (lpTreeNode *lplpRoot);
void NodeInit (lpTreeNode lpNode);
lpTreeNode FindNodeByName (lpTreeNode lpParent, LPSTR lpszName);
lpTreeNode FindNodeByNumber (lpTreeNode lpParent, UINT uNum);
lpTreeNode FindNodeAddToTree (lpTreeNode lpParent, LPSTR lpszName, UINT uNum);
lpTreeNode FindNodeInSubTree (lpTreeNode lpRoot, LPSTR lpszName);
lpTreeNode NewChildNode (LPSTR lpszName, UINT uNum);
void InsertChildNode (lpTreeNode lpParent, lpTreeNode lpNode);
void PrintTree (lpTreeNode lpRoot, unsigned int nIndent);

//--------------------------- END -------------------------------------------

#endif /* mibtree_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\mgmtapi\samples\snmputil\snmputil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    snmputil.c

Abstract:

    Sample SNMP Management API usage for Windows NT.

    This file is an example of how to code management applications using
    the SNMP Management API for Windows NT.  It is similar in operation to
    the other commonly available SNMP command line utilities.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows NT SNMP Programmer's Reference".

--*/


// General notes:
//   Microsoft's SNMP Management API for Windows NT is implemented as a DLL
// that is linked with the developer's code.  These APIs (examples follow in
// this file) allow the developer's code to generate SNMP queries and receive
// SNMP traps.  A simple MIB compiler and related APIs are also available to
// allow conversions between OBJECT IDENTIFIERS and OBJECT DESCRIPTORS.


// Necessary includes.

#include <windows.h>

#include <stdio.h>
#include <string.h>

#include <snmp.h>
#include <mgmtapi.h>


// Constants used in this example.

#define GET     1
#define GETNEXT 2
#define WALK    3
#define TRAP    4

#define TIMEOUT 6000 /* milliseconds */
#define RETRIES 0

void
SNMP_FUNC_TYPE AsnValueFree(
    IN AsnAny *asnValue
    )
    {
    // Free any data in the varbind value
    switch ( asnValue->asnType )
        {
        case ASN_OBJECTIDENTIFIER:
            SnmpUtilOidFree( &asnValue->asnValue.object );
            break;

        case ASN_RFC1155_IPADDRESS:
        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:
            if ( asnValue->asnValue.string.dynamic == TRUE )
                {
                SnmpUtilMemFree( asnValue->asnValue.string.stream );
                }
            break;

        default:
            break;
            // Purposefully do nothing, because no storage alloc'ed for others
        }

    // Set type to NULL
    asnValue->asnType = ASN_NULL;
    }

// Main program.

INT __cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
    {
    INT                operation;
    LPSTR              agent;
    LPSTR              community;
    RFC1157VarBindList variableBindings;
    LPSNMP_MGR_SESSION session;

    INT        timeout = TIMEOUT;
    INT        retries = RETRIES;

    BYTE       requestType;
    AsnInteger errorStatus;
    AsnInteger errorIndex;


    // Parse command line arguments to determine requested operation.

    // Verify number of arguments...
    if      (argumentCount < 5 && argumentCount != 2)
        {
        printf("Error:  Incorrect number of arguments specified.\n");
        printf(
"\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\n");
        printf(
  "        snmputil trap\n");

        return 1;
        }

    // Get/verify operation...
    argumentVector++;
    argumentCount--;
    if      (!strcmp(*argumentVector, "get"))
        operation = GET;
    else if (!strcmp(*argumentVector, "getnext"))
        operation = GETNEXT;
    else if (!strcmp(*argumentVector, "walk"))
        operation = WALK;
    else if (!strcmp(*argumentVector, "trap"))
        operation = TRAP;
    else
        {
        printf("Error:  Invalid operation, '%s', specified.\n",
               *argumentVector);

        return 1;
        }

    if (operation != TRAP)
        {
        if (argumentCount < 4)
            {
            printf("Error:  Incorrect number of arguments specified.\n");
            printf(
"\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\n");
            printf(
  "        snmputil trap\n");

            return 1;
            }

        // Get agent address...
        argumentVector++;
        argumentCount--;
        agent = (LPSTR)SnmpUtilMemAlloc(strlen(*argumentVector) + 1);
        if (agent != NULL)
            strcpy(agent, *argumentVector);
        else
        {
            printf("Error: SnmpUtilMemAlloc failed to allocate memory.\n");
            return 1;
        }

        // Get agent community...
        argumentVector++;
        argumentCount--;
        community = (LPSTR)SnmpUtilMemAlloc(strlen(*argumentVector) + 1);
        if (community != NULL)
            strcpy(community, *argumentVector);
        else
        {
            printf("Error: SnmpUtilMemAlloc failed to allocate memory.\n");
            SnmpUtilMemFree(agent);
            return 1;
        }

        // Get oid's...
        variableBindings.list = NULL;
        variableBindings.len = 0;

        while(--argumentCount)
            {
            AsnObjectIdentifier reqObject;
            RFC1157VarBind * tmpVb;

            argumentVector++;

            // Convert the string representation to an internal representation.
            if (!SnmpMgrStrToOid(*argumentVector, &reqObject))
                {
                printf("Error: Invalid oid, %s, specified.\n", *argumentVector);
                SnmpUtilMemFree(agent);
                SnmpUtilMemFree(community);
                SnmpUtilVarBindListFree(&variableBindings);
                return 1;
                }
            else
                {
                // Since sucessfull, add to the variable bindings list.
                variableBindings.len++;
                if ((tmpVb = (RFC1157VarBind *)SnmpUtilMemReAlloc(
                    variableBindings.list, sizeof(RFC1157VarBind) *
                    variableBindings.len)) == NULL)
                    {
                    printf("Error: Error allocating oid, %s.\n",
                           *argumentVector);
                    SnmpUtilMemFree(agent);
                    SnmpUtilMemFree(community);
                    SnmpUtilOidFree(&reqObject);
                    variableBindings.len--;
                    SnmpUtilVarBindListFree(&variableBindings);

                    return 1;
                    }
                variableBindings.list = tmpVb;

                variableBindings.list[variableBindings.len - 1].name =
                    reqObject; // NOTE!  structure copy
                variableBindings.list[variableBindings.len - 1].value.asnType =
                    ASN_NULL;
                }
            } // end while()

        // Establish a SNMP session to communicate with the remote agent.  The
        // community, communications timeout, and communications retry count
        // for the session are also required.

        if ((session = SnmpMgrOpen(agent, community, timeout, retries)) == NULL)
            {
            printf("error on SnmpMgrOpen %d\n", GetLastError());
            SnmpUtilMemFree(agent);
            SnmpUtilMemFree(community);
            SnmpUtilVarBindListFree(&variableBindings);

            return 1;
            }

        } // end if(TRAP)


    // Determine and perform the requested operation.

    if      (operation == GET || operation == GETNEXT)
        {
        // Get and GetNext are relatively simple operations to perform.
        // Simply initiate the request and process the result and/or
        // possible error conditions.


        if (operation == GET)
            requestType = ASN_RFC1157_GETREQUEST;
        else
            requestType = ASN_RFC1157_GETNEXTREQUEST;


        // Request that the API carry out the desired operation.

        if (!SnmpMgrRequest(session, requestType, &variableBindings,
                            &errorStatus, &errorIndex))
            {
            // The API is indicating an error.

            printf("error on SnmpMgrRequest %d\n", GetLastError());
            }
        else
            {
            // The API succeeded, errors may be indicated from the remote
            // agent.

            if (errorStatus > 0)
                {
                printf("Error: errorStatus=%d, errorIndex=%d\n",
                       errorStatus, errorIndex);
                }
            else
                {
                // Display the resulting variable bindings.

                UINT i;
                char *string = NULL;

                for(i=0; i < variableBindings.len; i++)
                    {
                    SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
                    printf("Variable = %s\n", string);
                    if (string) SnmpUtilMemFree(string);

                    printf("Value    = ");
                    SnmpUtilPrintAsnAny(&variableBindings.list[i].value);

                    printf("\n");
                    } // end for()
                }
            }


        // Free allocated memory.
        SnmpUtilMemFree(agent);
        SnmpUtilMemFree(community);
        SnmpUtilVarBindListFree(&variableBindings);


        }
    else if (operation == WALK)
        {
        // Walk is a common term used to indicate that all MIB variables
        // under a given OID are to be traversed and displayed.  This is
        // a more complex operation requiring tests and looping in addition
        // to the steps for get/getnext above.

        UINT i;
        UINT j;

        AsnObjectIdentifier *rootOidList = NULL;
        UINT                 rootOidLen  = 0;
        UINT                *rootOidXlat = NULL;

        rootOidLen = variableBindings.len;

        rootOidList = (AsnObjectIdentifier*)SnmpUtilMemAlloc(rootOidLen *
                      sizeof(AsnObjectIdentifier));

        rootOidXlat = (UINT *)SnmpUtilMemAlloc(rootOidLen * sizeof(UINT));

        for (i=0; i < rootOidLen; i++)
            {
            SnmpUtilOidCpy(&rootOidList[i], &variableBindings.list[i].name);
            rootOidXlat[i] = i;
            }

        requestType = ASN_RFC1157_GETNEXTREQUEST;

        while(1)
            {
            if (!SnmpMgrRequest(session, requestType, &variableBindings,
                                &errorStatus, &errorIndex))
                {
                // The API is indicating an error.

                printf("error on SnmpMgrRequest %d\n", GetLastError());

                break;
                }
            else
                {
                // The API succeeded, errors may be indicated from the remote
                // agent.

                char *string = NULL;
                UINT nBindingsLeft = variableBindings.len;
                UINT nSubTreesDone = 0;
                RFC1157VarBind *tempVarBindList;
                BOOL fGotoExit = FALSE;

                if (errorStatus == SNMP_ERRORSTATUS_NOERROR)
                    {
                    // Test for end of subtree or end of MIB.

                    for(i=0; i < nBindingsLeft; i++)
                        {
                        // obtain root
                        j = rootOidXlat[i];

                        if (SnmpUtilOidNCmp(&variableBindings.list[i].name,
                                &rootOidList[j], rootOidList[j].idLength))
                            {
                            nSubTreesDone++;
                            rootOidXlat[i] = 0xffffffff;
                            }
                        else
                            {
                            SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
                            printf("Variable = %s\n", string);
                            if (string) SnmpUtilMemFree(string);

                            printf("Value    = ");
                            SnmpUtilPrintAsnAny(&variableBindings.list[i].value);

                            printf("\n");
                            }

                        AsnValueFree(&variableBindings.list[i].value);
                        }

                        if (nBindingsLeft > 1)
                            {
                            printf("\n"); // separate table entries
                            }
                    }
                else if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME)
                    {
                    if (!(errorIndex && (errorIndex <= (INT)nBindingsLeft)))
                        {
                        errorIndex = 1; // invalidate first variable
                        }

                    nSubTreesDone++;
                    rootOidXlat[errorIndex-1] = 0xffffffff;

                    errorStatus = 0;
                    errorIndex  = 0;
                    }
                else
                    {
                    printf("Error: errorStatus=%d, errorIndex=%d \n",
                           errorStatus, errorIndex);

                    break;
                    }

                // Test to see if any or all subtrees walked

                if (nSubTreesDone == 0)
                    {
                    continue;
                    }
                else if (nSubTreesDone >= nBindingsLeft)
                    {
                    printf("End of MIB subtree.\n\n");
                    break;
                    }

                // Fixup variable list

                tempVarBindList = variableBindings.list;

                variableBindings.len = nBindingsLeft - nSubTreesDone;

                variableBindings.list = (RFC1157VarBind *)SnmpUtilMemAlloc(
                    variableBindings.len * sizeof(RFC1157VarBind));
                if (variableBindings.list == NULL)
                    {
                    printf("Error: failed to allocate a new varbind list.\n");
                    // undo the changes
                    variableBindings.list = tempVarBindList;
                    variableBindings.len = nBindingsLeft;
                    break;
                    }

                for(i=0, j=0; i < nBindingsLeft; i++)
                    {
                    if ((rootOidXlat[i] != 0xffffffff) &&
                        (j < variableBindings.len))
                        {
                        if (!SnmpUtilVarBindCpy(
                            &variableBindings.list[j],
                            &tempVarBindList[i]
                            ))
                            {
                            printf("Error: SnmpUtilVarBindCpy failed.\n");
                            // erase itermediate results and undo the changes
                            SnmpUtilVarBindListFree(&variableBindings);
                            variableBindings.list = tempVarBindList;
                            variableBindings.len = nBindingsLeft;
                            tempVarBindList = NULL; // ownership transferred
                            fGotoExit = TRUE;
                            break;
                            }
                        rootOidXlat[j++] = rootOidXlat[i];
                        }

                    SnmpUtilVarBindFree(
                        &tempVarBindList[i]
                        );
                    }
                if (fGotoExit)
                {
                    // break out the while loop
                    break;
                }

                SnmpUtilMemFree(tempVarBindList);

                } // end if()

            } // end while()

        // Free allocated memory.
        SnmpUtilMemFree(agent);
        SnmpUtilMemFree(community);
        SnmpUtilMemFree(rootOidXlat);

        SnmpUtilVarBindListFree(&variableBindings);

        for (i=0; i < rootOidLen; i++)
            {
            SnmpUtilOidFree(&rootOidList[i]);
            }

        SnmpUtilMemFree(rootOidList);

        }
    else if (operation == TRAP)
        {
        // Trap handling can be done two different ways: event driven or
        // polled.  The following code illustrates the steps to use event
        // driven trap reception in a management application.


        HANDLE hNewTraps = NULL;


        if (!SnmpMgrTrapListen(&hNewTraps))
            {
            printf("error on SnmpMgrTrapListen %d\n", GetLastError());
            return 1;
            }
        else
            {
            printf("snmputil: listening for traps...\n");
            }


        while(1)
            {
            DWORD dwResult;

            if ((dwResult = WaitForSingleObject(hNewTraps, 0xffffffff))
                == 0xffffffff)
                {
                printf("error on WaitForSingleObject %d\n",
                       GetLastError());
                }
            else if (!ResetEvent(hNewTraps))
                {
                printf("error on ResetEvent %d\n", GetLastError());
                }
            else
                {
                AsnObjectIdentifier enterprise;
                AsnNetworkAddress   agentAddress;
                AsnNetworkAddress   sourceAddress;
                AsnInteger          genericTrap;
                AsnInteger          specificTrap;
                AsnOctetString      community;
                AsnTimeticks        timeStamp;
                RFC1157VarBindList  variableBindings;

                UINT i;
                char *string = NULL;

                while(SnmpMgrGetTrapEx(
                        &enterprise,
                        &agentAddress,
                        &sourceAddress,
                        &genericTrap,
                        &specificTrap,
                        &community,
                        &timeStamp,
                        &variableBindings))
                    {

                    printf("Incoming Trap:\n"
                           "  generic    = %d\n"
                           "  specific   = %d\n"
                           "  timeStamp  = %u\n",
                           genericTrap,
                           specificTrap,
                           timeStamp);

                    SnmpMgrOidToStr(&enterprise, &string);
                    printf ("  enterprise = %s\n", string);
                    if (string) 
                        SnmpUtilMemFree(string);
                    SnmpUtilOidFree(&enterprise);

                    if (agentAddress.length == 4) {
                        printf ("  agent      = %d.%d.%d.%d\n",
                             (int)agentAddress.stream[0],
                             (int)agentAddress.stream[1],
                             (int)agentAddress.stream[2],
                             (int)agentAddress.stream[3]);
                    }
                    if (agentAddress.dynamic) {
                        SnmpUtilMemFree(agentAddress.stream);
                    }

                    if (sourceAddress.length == 4) {
                        printf ("  source IP  = %d.%d.%d.%d\n",
                             (int)sourceAddress.stream[0],
                             (int)sourceAddress.stream[1],
                             (int)sourceAddress.stream[2],
                             (int)sourceAddress.stream[3]);
                    }
                    else if (sourceAddress.length == 10) {
                        printf ("  source IPX = %.2x%.2x%.2x%.2x."
                                "%.2x%.2x%.2x%.2x%.2x%.2x\n",
                             (int)sourceAddress.stream[0],
                             (int)sourceAddress.stream[1],
                             (int)sourceAddress.stream[2],
                             (int)sourceAddress.stream[3],
                             (int)sourceAddress.stream[4],
                             (int)sourceAddress.stream[5],
                             (int)sourceAddress.stream[6],
                             (int)sourceAddress.stream[7],
                             (int)sourceAddress.stream[8],
                             (int)sourceAddress.stream[9]);
                    }
                    if (sourceAddress.dynamic) {
                        SnmpUtilMemFree(sourceAddress.stream);
                    }

                    if (community.length)
                    {
                        string = SnmpUtilMemAlloc (community.length + 1);
                        memcpy (string, community.stream, community.length);
                        string[community.length] = '\0';
                        printf ("  community  = %s\n", string);
                        SnmpUtilMemFree(string);
                    }
                    if (community.dynamic) {
                        SnmpUtilMemFree(community.stream);
                    }

                    for(i=0; i < variableBindings.len; i++)
                        {
                        SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
                        printf("  variable   = %s\n", string);
                        if (string) SnmpUtilMemFree(string);

                        printf("  value      = ");
                        SnmpUtilPrintAsnAny(&variableBindings.list[i].value);
                        } // end for()
                    printf("\n");


                    SnmpUtilVarBindListFree(&variableBindings);
                    }

                dwResult = GetLastError(); // check for errors...

                if ((dwResult != NOERROR) && (dwResult != SNMP_MGMTAPI_NOTRAPS))
                    {
                    printf("error on SnmpMgrGetTrap %d\n", dwResult);
                    }
                }

            } // end while()


        } // end if(operation)

    if (operation != TRAP)
        {
        // Close SNMP session with the remote agent.

        if (!SnmpMgrClose(session))
            {
            printf("error on SnmpMgrClose %d\n", GetLastError());

            return 1;
            }
        }


    // Let the command interpreter know things went ok.

    return 0;

    } // end main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\winsnmp.inc ===
#pragma warning (disable : 4001)
//
// winsnmp.inc
// Utility include for NetPlus WinSNMP
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
#include <stdlib.h> // for _ltoa(), strtol(), etc.
#include <string.h>
#include <memory.h>
#include <process.h> // for _beginthreadex()
#include <errno.h> // for ERANGE
#include "winsnmp.h"
#include "winsnmpn.h"
#include "wsnmpext.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_bn.c ===
// wsnmp_bn.c
//
// WinSNMP Low-Level SNMP/ASN.1/BER Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980424 - Received msgLen may be larger than pduLen
//        - ParsePduHdr() and ParseMessage() now accommodate this.
// 980420 - Mods related to ParseCntr64() inspired by
//          MS bug ID 127357 (removal of temp64 variable)
//        - Mod to ParseOID() for MS bug ID 127353
//          (reset os_ptr->ptr to NULL on error)
//
// 970310 - Typographical changes
//
#include "winsnmp.inc"

long FindLenVarBind      (LPVARBIND vb_ptr);
long FindLenVALUE        (smiLPVALUE);
long FindLenOctetString  (smiLPOCTETS os_ptr);
long FindLenOID          (smiLPCOID oid_ptr);
long FindLenUInt         (smiUINT32 value);
long FindLenInt          (smiINT32 value);
long FindLenCntr64       (smiLPCNTR64 value);
long DoLenLen            (smiINT32 len);
void AddLen (smiLPBYTE *tmpPtr, smiINT32 lenlen, smiINT32 data_len);
long AddVarBind (smiLPBYTE *tmpPtr, LPVARBIND vb_ptr);
long AddOctetString (smiLPBYTE *tmpPtr, int type, smiLPOCTETS os_ptr);
long AddOID (smiLPBYTE *tmpPtr, smiLPOID oid_ptr);
long AddUInt (smiLPBYTE *tmpPtr, int type, smiUINT32 value);
long AddInt (smiLPBYTE *tmpPtr, smiINT32 value);
long AddCntr64 (smiLPBYTE *tmpPtr, smiLPCNTR64 value);
void AddNull (smiLPBYTE *tmpPtr, int type);
LPVARBIND ParseVarBind (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
BOOL ParseOctetString (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOCTETS os_ptr);
BOOL ParseOID (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOID oid_ptr);
BOOL ParseCntr64 (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPCNTR64 cntr64_ptr);
BOOL ParseUInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPUINT32 value);
BOOL ParseInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPINT value);
BOOL ParseNull (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
BOOL ParseSequence (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
smiINT32 ParseType (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
smiINT32 ParseLength (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);

void FreeOctetString (smiLPOCTETS os_ptr)
{
if (os_ptr)
   {
   if (os_ptr->ptr)
      GlobalFree (os_ptr->ptr);
   GlobalFree (os_ptr);
   }
return;
}

void FreeVarBindList (LPVARBIND vb_ptr)
{
if (vb_ptr)
   { // NULLs are handled by downstream call
   FreeVarBindList (vb_ptr->next_var);
   FreeVarBind (vb_ptr);
   }
return;
}

void FreeVarBind (LPVARBIND vb_ptr)
{
if (vb_ptr)
   {
   if (vb_ptr->name.ptr)
      GlobalFree (vb_ptr->name.ptr);
   switch (vb_ptr->value.syntax)
      {
      case SNMP_SYNTAX_OID:
      if (vb_ptr->value.value.oid.ptr)
         GlobalFree (vb_ptr->value.value.oid.ptr);
      break;

      case SNMP_SYNTAX_OCTETS:
      case SNMP_SYNTAX_IPADDR:
      case SNMP_SYNTAX_OPAQUE:
      if (vb_ptr->value.value.string.ptr)
         GlobalFree (vb_ptr->value.value.string.ptr);
      break;

      default: // Remaining types do not have 'ptr' members
      break;
      } // end_switch
   GlobalFree (vb_ptr);
   } // end_if (vb_ptr)
return;
} // end_FreeVarBind

void FreeV1Trap (LPV1TRAP v1Trap_ptr)
{
if (v1Trap_ptr)
   {
   if (v1Trap_ptr->enterprise.ptr)
      GlobalFree (v1Trap_ptr->enterprise.ptr);
   if (v1Trap_ptr->agent_addr.ptr)
      GlobalFree (v1Trap_ptr->agent_addr.ptr);
   GlobalFree (v1Trap_ptr);
   }
} // end_FreeV1Trap

void AddLen (smiLPBYTE *tmpPtr, long lenlen, long data_len)
{
long i;
if (lenlen == 1)
   *(*tmpPtr)++ = (smiBYTE)data_len;
else
   {
   *(*tmpPtr)++ = (smiBYTE)(0x80 + lenlen - 1);
   for (i = 1; i < lenlen; i++)
      {
      *(*tmpPtr)++ = (smiBYTE)((data_len >>
         (8 * (lenlen - i - 1))) & 0xFF);
      } // end_for
   } // end_else
return;
} // end_AddLen

long AddVarBind (smiLPBYTE *tmpPtr, LPVARBIND vb_ptr)
{
long lenlen;
if (vb_ptr == NULL)
   return (0);
if ((lenlen = DoLenLen(vb_ptr->data_length)) == -1)
   return (-1);
*(*tmpPtr)++ = SNMP_SYNTAX_SEQUENCE;
AddLen (tmpPtr, lenlen, vb_ptr->data_length);
if (AddOID (tmpPtr, &vb_ptr->name) == -1)
   return (-1);

switch (vb_ptr->value.syntax)
   {
   case SNMP_SYNTAX_CNTR32:
   case SNMP_SYNTAX_GAUGE32:
   case SNMP_SYNTAX_TIMETICKS:
   case SNMP_SYNTAX_UINT32:
   AddUInt (tmpPtr, (int)vb_ptr->value.syntax, vb_ptr->value.value.uNumber);
   break;

   case SNMP_SYNTAX_INT:
   AddInt (tmpPtr, vb_ptr->value.value.sNumber);
   break;

   case SNMP_SYNTAX_OID:
   if (AddOID (tmpPtr, (smiLPOID)&(vb_ptr->value.value.oid)) == -1)
      return (-1);
   break;

   case SNMP_SYNTAX_CNTR64:
   AddCntr64 (tmpPtr, (smiLPCNTR64)&(vb_ptr->value.value.hNumber));
   break;

   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_OPAQUE:
   if (AddOctetString (tmpPtr, (int)vb_ptr->value.syntax,
         (smiLPOCTETS)&(vb_ptr->value.value.string)) == -1)
      return -1;
   break;

   case SNMP_SYNTAX_NULL:
   case SNMP_SYNTAX_NOSUCHOBJECT:
   case SNMP_SYNTAX_NOSUCHINSTANCE:
   case SNMP_SYNTAX_ENDOFMIBVIEW:
   AddNull (tmpPtr, (int)vb_ptr->value.syntax);
   break;

   default:
   return (-1);
   } // end_switch
return (AddVarBind (tmpPtr, vb_ptr->next_var));
}

long AddOctetString (smiLPBYTE *tmpPtr, int type, smiLPOCTETS os_ptr)
{
UINT i;
long lenlen;
if ((lenlen = DoLenLen ((long)os_ptr->len)) == -1)
   return (-1);
*(*tmpPtr)++ = (smiBYTE)(0xFF & type);
AddLen (tmpPtr, lenlen, os_ptr->len);
for (i = 0; i < os_ptr->len; i++)
   *(*tmpPtr)++ = os_ptr->ptr[i];
return (0);
}

long AddOID (smiLPBYTE *tmpPtr, smiLPOID oid_ptr)
{
UINT i;
long lenlen = 0;
long encoded_len;
encoded_len = 1; // for first two SID's
for (i = 2; i < oid_ptr->len; i++)
   {
   if (oid_ptr->ptr[i] < 0x80)            // 0 - 0x7F
      encoded_len += 1;
   else if (oid_ptr->ptr[i] < 0x4000)     // 0x80 - 0x3FFF
      encoded_len += 2;
   else if (oid_ptr->ptr[i] < 0x200000)   // 0x4000 - 0x1FFFFF
      encoded_len += 3;
   else if (oid_ptr->ptr[i] < 0x10000000) // 0x200000 - 0xFFFFFFF
      encoded_len += 4;
   else
      encoded_len += 5;
   }
if ((lenlen = DoLenLen (encoded_len)) == -1)
   return (-1);
*(*tmpPtr)++ = (smiBYTE)(0xFF & SNMP_SYNTAX_OID);
AddLen (tmpPtr, lenlen, encoded_len);
if (oid_ptr->len < 2)
   *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[0] * 40);
else
   *(*tmpPtr)++ = (smiBYTE)((oid_ptr->ptr[0] * 40) + oid_ptr->ptr[1]);
for (i = 2; i < oid_ptr->len; i++)
   {
   if (oid_ptr->ptr[i] < 0x80)
      { // 0 - 0x7F
      *(*tmpPtr)++ = (smiBYTE)oid_ptr->ptr[i];
      }
   else if (oid_ptr->ptr[i] < 0x4000)
      { // 0x80 - 0x3FFF
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   else if (oid_ptr->ptr[i] < 0x200000)
      { // 0x4000 - 0x1FFFFF
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 14) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80);  // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   else if (oid_ptr->ptr[i] < 0x10000000)
      { // 0x200000 - 0xFFFFFFF
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 21) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 14) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80);  // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   else
      {
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 28) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 21) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 14) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80);  // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   } // end_for
return (0);
} // end_AddOID

long AddUInt (smiLPBYTE *tmpPtr, int type, smiUINT32 value)
{
long i;
long datalen;
long lenlen;
// if high bit one, must use 5 octets (first with 00)
if (((value >> 24) & 0xFF) != 0)
   datalen = 4;
else if (((value >> 16) & 0xFF) != 0)
   datalen = 3;
else if (((value >> 8) & 0xFF) != 0)
   datalen = 2;
else
   datalen = 1;
if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
   datalen++;
lenlen = 1; // < 127 octets
*(*tmpPtr)++ = (smiBYTE)(0xFF & type);
AddLen(tmpPtr, lenlen, datalen);
if (datalen == 5)
   { // gotta put a 00 in first octet
   *(*tmpPtr)++ = (smiBYTE)0;
   for (i = 1; i < datalen; i++)
      {
      *(*tmpPtr)++ = (smiBYTE)(value >>
         (8 * ((datalen - 1) - i) & 0xFF));
      }
   } // end_if
else
   {
   for (i = 0; i < datalen; i++)
      {
      *(*tmpPtr)++ = (smiBYTE)(value >>
         (8 * ((datalen - 1) - i) & 0xFF));
      }
   } // end_else
return (0);
} // end_AddUInt

long AddInt (smiLPBYTE *tmpPtr, smiINT32 value)
{
long i;
long datalen;
long lenlen;
switch ((smiBYTE) ((value >> 24) & 0xFF))
   {
   case 0x00:
   if (((value >> 16) & 0xFF) != 0)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
      datalen++;
   break;

   case 0xFF:
   if (((value >> 16) & 0xFF) != 0xFF)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0xFF)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) == 0)
      datalen++;
   break;

   default:
   datalen = 4;
   } // end_switch
lenlen = 1; // < 127 octets
*(*tmpPtr)++ = (smiBYTE)(0xFF & SNMP_SYNTAX_INT);
AddLen(tmpPtr, lenlen, datalen);
for (i = 0; i < datalen; i++)
   {
   *(*tmpPtr)++  = (smiBYTE) (value >>
      (8 * ((datalen - 1) - i) & 0xFF));
   }
return (0);
} // end_AddInt()

long AddCntr64 (smiLPBYTE *tmpPtr, smiLPCNTR64 value)
{
long i;
long datalen;
long lenlen;
datalen = FindLenCntr64(value) - 2;
lenlen = 1; // < 127 octets
*(*tmpPtr)++ = (smiBYTE)(0xFF & SNMP_SYNTAX_CNTR64);
AddLen(tmpPtr, lenlen, datalen);
if (datalen == 9)
   { // gotta put a 00 in first octet
   *(*tmpPtr)++ = (smiBYTE)0;
   datalen--;
   }
for (i = datalen; i > 4; i--)
   {
   *(*tmpPtr)++ = (smiBYTE)(value->hipart >>
      (8 * (i - 5) & 0xFF));
   }
for (; i > 0; i--)
   {
   *(*tmpPtr)++ = (smiBYTE)(value->lopart >>
      (8 * (i - 1) & 0xFF));
   }
return (0);
}

long FindLenVarBind (LPVARBIND vb_ptr)
{
long lenlen;
long tot_so_far;
long lOidLen;
long lValueLen;
if (!vb_ptr) return (0);
tot_so_far = FindLenVarBind (vb_ptr->next_var);
if (tot_so_far == -1)
   return (-1);
if ((lOidLen = FindLenOID (&vb_ptr->name)) == -1)
    return (-1);
if ((lValueLen = FindLenVALUE (&vb_ptr->value)) == -1)
    return (-1);
vb_ptr->data_length = lOidLen +
                      lValueLen;
if ((lenlen = DoLenLen (vb_ptr->data_length)) == -1)
   return (-1);
return (1 + lenlen + vb_ptr->data_length + tot_so_far);
} // end_FindLenVarBind

long FindLenVALUE (smiLPVALUE value_ptr)
{
if (value_ptr)
   {
   switch (value_ptr->syntax)
      {
      case SNMP_SYNTAX_OCTETS:
      case SNMP_SYNTAX_IPADDR:
      case SNMP_SYNTAX_OPAQUE:
      return (FindLenOctetString (&value_ptr->value.string));

      case SNMP_SYNTAX_OID:
      return (FindLenOID (&value_ptr->value.oid));

      case SNMP_SYNTAX_NULL:
      case SNMP_SYNTAX_NOSUCHOBJECT:
      case SNMP_SYNTAX_NOSUCHINSTANCE:
      case SNMP_SYNTAX_ENDOFMIBVIEW:
      return (2);

      case SNMP_SYNTAX_INT:
      return (FindLenInt (value_ptr->value.sNumber));

      case SNMP_SYNTAX_CNTR32:
      case SNMP_SYNTAX_GAUGE32:
      case SNMP_SYNTAX_TIMETICKS:
      case SNMP_SYNTAX_UINT32:
      return (FindLenUInt (value_ptr->value.uNumber));

      case SNMP_SYNTAX_CNTR64:
      return (FindLenCntr64 (&value_ptr->value.hNumber));
      } // end_switch
   } // end_if
return (-1);
} // end_FindLenVALUE

long FindLenOctetString (smiLPOCTETS os_ptr)
{
long lenlen;
if (!os_ptr) return (-1);
if ((lenlen = DoLenLen (os_ptr->len)) == -1)
   return (-1);
 return (1 + lenlen + os_ptr->len);
}

long FindLenOID (smiLPCOID oid_ptr)
{
long lenlen;
UINT i;
UINT encoded_len;
encoded_len = 1; // for first two Sub-IDs
// beware of i = 2
for (i = 2; i < oid_ptr->len; i++)
   {
   if (oid_ptr->ptr[i] < 0x80)            // 0 - 0x7F
      encoded_len += 1;
   else if (oid_ptr->ptr[i] < 0x4000)     // 0x80 - 0x3FFF
      encoded_len += 2;
   else if (oid_ptr->ptr[i] < 0x200000)   // 0x4000 - 0x1FFFFF
      encoded_len += 3;
   else if (oid_ptr->ptr[i] < 0x10000000) // 0x200000 - 0xFFFFFFF
      encoded_len += 4;
   else
      encoded_len += 5;
   } // end_for
if ((lenlen = DoLenLen (encoded_len)) == -1)
   return (-1);
return (1 + lenlen + encoded_len);
} // end_FindLenOID

long FindLenUInt (smiUINT32 value)
{
long datalen;
// if high bit one, must use 5 octets (first with 00)
if (((value >> 24) & 0xFF) != 0)
   datalen = 4;
else if (((value >> 16) & 0xFF) != 0)
   datalen = 3;
else if (((value >> 8) & 0xFF) != 0)
   datalen = 2;
else
   datalen = 1;
if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
   datalen++;
// length of length  < 127 octets
return (1 + 1 + datalen);
}

long FindLenInt (smiINT32 value)
{
long datalen;
switch ((smiBYTE) ((value >> 24) & 0xFF))
   {
   case 0x00:
   if (((value >> 16) & 0xFF) != 0)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
      datalen++;
   break;

   case 0xFF:
   if (((value >> 16) & 0xFF) != 0xFF)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0xFF)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) == 0)
      datalen++;
   break;

   default:
   datalen = 4;
   } // end_switch
return (1 + 1 + datalen);
}

long FindLenCntr64 (smiLPCNTR64 value)
{
long datalen;

// if high bit one, must use 5 octets (first with 00)
if (((value->hipart >> 24) & 0xFF) != 0)
   {
   datalen = 8;
   if (((value->hipart >> 24) & 0x80) != 0) datalen++;
   }
else if (((value->hipart >> 16) & 0xFF) != 0)
   {
   datalen = 7;
   if (((value->hipart >> 16) & 0x80) != 0) datalen++;
   }
else if (((value->hipart >> 8) & 0xFF) != 0)
   {
   datalen = 6;
   if (((value->hipart >> 8) & 0x80) != 0) datalen++;
   }
else if (((value->hipart) & 0xFF) != 0)
   {
   datalen = 5;
   if (((value->hipart) & 0x80) != 0) datalen++;
   }
else if (((value->lopart>> 24) & 0xFF) != 0)
   {
   datalen = 4;
   if (((value->lopart >> 24) & 0x80) != 0) datalen++;
   }
else if (((value->lopart >> 16) & 0xFF) != 0)
   {
   datalen = 3;
   if (((value->lopart >> 16) & 0x80) != 0) datalen++;
   }
else if (((value->lopart >> 8) & 0xFF) != 0)
   {
   datalen = 2;
   if (((value->lopart >> 8) & 0x80) != 0) datalen++;
   }
else
   {
   datalen = 1;
   if (((value->lopart) & 0x80) != 0) datalen++;
   }
// length of length  < 127 octets
return (1 + 1 + datalen);
}

long DoLenLen (long len)
{
// short form?
if (len < 128) return (1);
if (len < 0x100) return (2);
if (len < 0x10000) return (3);
if (len < 0x1000000) return (4);
return (-1);
}

void AddNull (smiLPBYTE *tmpPtr, int type)
{
*(*tmpPtr)++ = (smiBYTE)(0xFF & type);
*(*tmpPtr)++ = 0x00;
return;
}

BOOL BuildMessage (smiUINT32 version, smiLPOCTETS community,
                   LPPDUS pdu, smiINT32 requestId,
                   smiLPBYTE *msgAddr, smiLPUINT32 msgSize)
{
LPVARBIND vbList = NULL;
long nVbDataLen, nVbLenLen, nVbTotalLen;
long nPduDataLen, nPduLenLen, nPduTotalLen;
long nMsgDataLen, nMsgLenLen, nMsgTotalLen;
long nTmpDataLen;
smiLPBYTE tmpPtr = NULL;
*msgAddr = NULL;
*msgSize = 0;
if (pdu == NULL || community == NULL)
   return (FALSE);
// Determine length of VarBind list part
vbList = pdu->VBL_addr;
if (vbList == NULL && pdu->VBL != 0)
   vbList = ((LPVBLS)snmpGetTableEntry(&VBLsDescr, HandleToUlong(pdu->VBL)-1))->vbList;
// vbList == NULL is ok
if ((nVbDataLen = FindLenVarBind (vbList)) == -1)
   return (FALSE);
if ((nVbLenLen = DoLenLen (nVbDataLen)) == -1)
   return (FALSE);
nVbTotalLen = 1 + nVbLenLen + nVbDataLen;
// Determine length of PDU overhead part
switch (pdu->type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_GETBULK:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   nPduDataLen = FindLenInt (requestId)
               + FindLenInt (pdu->errStatus)
               + FindLenInt (pdu->errIndex)
               + nVbTotalLen;
   break;

   case SNMP_PDU_V1TRAP:
   if (!pdu->v1Trap)
      return (FALSE);
   nPduDataLen = FindLenInt (pdu->v1Trap->generic_trap)
               + FindLenInt (pdu->v1Trap->specific_trap)
               + FindLenUInt (pdu->v1Trap->time_ticks)
               + nVbTotalLen;
   if ((nTmpDataLen = FindLenOID (&pdu->v1Trap->enterprise)) == -1)
      return (FALSE);
   nPduDataLen += nTmpDataLen;
   if ((nTmpDataLen = FindLenOctetString (&pdu->v1Trap->agent_addr)) == -1)
      return (FALSE);
   nPduDataLen += nTmpDataLen;
   break;

   default:
   return (FALSE);
   } // end_switch
if ((nPduLenLen = DoLenLen(nPduDataLen)) == -1)
   return (FALSE);
nPduTotalLen = 1 + nPduLenLen + nPduDataLen;
if ((nTmpDataLen = FindLenOctetString (community)) == -1)
    return (FALSE);
nMsgDataLen = FindLenUInt (version)
            + nTmpDataLen
            + nPduTotalLen;
if ((nMsgLenLen = DoLenLen (nMsgDataLen)) == -1)
    return (FALSE);
nMsgTotalLen = 1 + nMsgLenLen + nMsgDataLen;
// Allocate the necessary memory for the message
tmpPtr = GlobalAlloc (GPTR, nMsgTotalLen);
if (tmpPtr == NULL)
   return (FALSE);
*msgAddr = tmpPtr;
*msgSize = nMsgTotalLen;
// Now plug in the values in the message bytes
*tmpPtr++ = SNMP_SYNTAX_SEQUENCE;
// Wrapper portion
AddLen (&tmpPtr, nMsgLenLen, nMsgDataLen);
AddInt (&tmpPtr, version);
if (AddOctetString (&tmpPtr, SNMP_SYNTAX_OCTETS, community) == -1)
    goto error_out;
// PDU header portion
// "Downgrade" GetBulk to GetNext if target is SNMPv1
if (pdu->type == SNMP_PDU_GETBULK && version == 0)
   *tmpPtr++ = SNMP_PDU_GETNEXT;
else
   *tmpPtr++ = (BYTE) pdu->type;
AddLen (&tmpPtr, nPduLenLen, nPduDataLen);
switch (pdu->type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   case SNMP_PDU_GETBULK:
   AddInt (&tmpPtr, requestId);
   AddInt (&tmpPtr, pdu->errStatus);
   AddInt (&tmpPtr, pdu->errIndex);
   break;

   case SNMP_PDU_V1TRAP:
   if (AddOID (&tmpPtr, &pdu->v1Trap->enterprise)== -1)
      goto error_out;
   if (AddOctetString (&tmpPtr, SNMP_SYNTAX_IPADDR, &pdu->v1Trap->agent_addr) == -1)
      goto error_out;
   AddInt (&tmpPtr, pdu->v1Trap->generic_trap);
   AddInt (&tmpPtr, pdu->v1Trap->specific_trap);
   AddUInt (&tmpPtr, SNMP_SYNTAX_TIMETICKS, pdu->v1Trap->time_ticks);
   break;

   default:
   goto error_out;
   } // end_switch
// VarBindList portion
*tmpPtr++ = SNMP_SYNTAX_SEQUENCE;
AddLen (&tmpPtr, nVbLenLen, nVbDataLen);
if (AddVarBind (&tmpPtr, vbList) == -1)
   {
error_out:
   if (*msgAddr)
      GlobalFree (*msgAddr);
   *msgAddr = NULL;
   *msgSize = 0;
   return (FALSE);
   }
// Success
return (TRUE);
} // end_BuildMessage()


BOOL SetPduType (smiLPBYTE msgPtr, smiUINT32 msgLen, int pduType)
{
smiLPBYTE tmpPtr;
smiINT32 tmp;
if (!(tmpPtr = msgPtr))                    // Deliberate assignment
   return (FALSE);
if (!(ParseSequence (&tmpPtr, &msgLen)))   // sequence
   return (FALSE);
if (!(ParseUInt (&tmpPtr, &msgLen, &tmp))) // version
   return (FALSE);
// Jump over communityString...not needed here
if (ParseType (&tmpPtr, &msgLen) == -1)
   return (FALSE);
// -1 is error, we also reject 0 and -ve length commuityString
if ((tmp = ParseLength (&tmpPtr, &msgLen)) <= 0)
   return (FALSE);
if ((smiUINT32)tmp > msgLen)
   return (FALSE);
tmpPtr += (smiUINT32)tmp; // Jump!
// Set the PDU type byte
*tmpPtr = (smiBYTE)pduType;
return (TRUE);
} // End_SetPduType()


smiUINT32 ParsePduHdr (smiLPBYTE msgPtr, smiUINT32 msgLen,
                       smiLPUINT32 version, smiLPINT32 type, smiLPUINT32 reqID)
{
// This is a private function (not exported via WinSNMP)
// It is called only once by msgNotify() (another private function)
// to "peek ahead" at certain PDU attributes to determine the next
// procesing steps.
smiINT32 pduLen;
smiINT32 length;
long errcode = 1;
if (msgPtr == NULL)
   goto DONE;
errcode++; // 2
// Parse initial Sequence field...
if (ParseType (&msgPtr, &msgLen) != SNMP_SYNTAX_SEQUENCE)
   goto DONE;
errcode++; // 3
// ...to get the remaining pduLen out of it
pduLen = ParseLength (&msgPtr, &msgLen);
if (pduLen <= 0)
   goto DONE;
errcode++; // 4
if ((smiUINT32)pduLen > msgLen)
   goto DONE;
errcode++; // 5
msgLen = (smiUINT32)pduLen; // Only pduLen counts now
if (!(ParseUInt (&msgPtr, &msgLen, version)))
   goto DONE;
errcode++; // 6
// Jump over communityString...not needed here
if (ParseType (&msgPtr, &msgLen) == -1)
   goto DONE;
errcode++; // 7
// -1 is error, we also reject 0 and -ve length commuityString
if ((length = ParseLength (&msgPtr, &msgLen)) <= 0)
   goto DONE;
errcode++; // 8
if ((smiUINT32)length > msgLen)
   goto DONE;
errcode++; // 9
msgPtr += (smiUINT32)length; // Jump!
msgLen -= (smiUINT32)length;
// Get PDU type
if ((*type = ParseType (&msgPtr, &msgLen)) == -1)
   goto DONE;
errcode++; // 10
// Check PDU type for requestID semantics
if (*type == SNMP_PDU_V1TRAP)
   *reqID = 0; // No requestID on v1 trapPDU
else // Not a v1 trapPDU, therefore
   { // must get requestID
   // -1 is error, reject 0 and any -ve values too.
   if ((ParseLength (&msgPtr, &msgLen)) <= 0)
      goto DONE;
   errcode++; // 11
   if (!(ParseInt (&msgPtr, &msgLen, reqID)))
      goto DONE;
   }
errcode = 0;
DONE:
return (errcode);
} // end_ParsePduHdr

smiUINT32 ParseMessage (smiLPBYTE msgPtr, smiUINT32 msgLen,
                        smiLPUINT32 version, smiLPOCTETS *community, LPPDUS pdu)
{
smiINT32 pduLen;
smiLPOCTETS os_ptr;
LPVARBIND vb_ptr;
LPVARBIND vb_end_ptr;
long errcode = 1;
if (msgPtr == NULL)
   goto DONE;
errcode++; // 2
// Parse initial Sequence field...
if (ParseType (&msgPtr, &msgLen) != SNMP_SYNTAX_SEQUENCE)
   goto DONE;
errcode++; // 3
// ...to get the remaining pduLen out of it
pduLen = ParseLength (&msgPtr, &msgLen);
if (pduLen <= 0)
   goto DONE;
errcode++; // 4
if ((smiUINT32)pduLen > msgLen)
   goto DONE;
errcode++; // 5
msgLen = (smiUINT32)pduLen; // Only pduLen counts now
if (!(ParseUInt (&msgPtr, &msgLen, version)))
   goto DONE;
errcode++; // 5
if (*version != 0 && *version != 1) // SNMPv1 or SNMPv2c
   goto DONE;
errcode++; // 6
if (!(os_ptr = GlobalAlloc (GPTR, sizeof(smiOCTETS))))
   goto DONE;
errcode++; // 7
if (!(ParseOctetString (&msgPtr, &msgLen, os_ptr)))
   goto DONE_OS;
// reject 0 length community string
if (os_ptr->len == 0)
    goto DONE_OS;
errcode++; // 8
if (pdu == NULL)
   goto DONE_OS;
ZeroMemory (pdu, sizeof(PDUS));
if ((pdu->type = ParseType (&msgPtr, &msgLen)) == -1)
   goto DONE_PDU;
errcode++; // 9
pduLen = ParseLength (&msgPtr, &msgLen);
if ((pduLen <= 0) || (smiUINT32)pduLen > msgLen)
   goto DONE_PDU;
errcode++; // 10
switch (pdu->type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_GETBULK:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->appReqId)))
      goto DONE_PDU;
errcode++; // 11
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->errStatus)))
      goto DONE_PDU;
errcode++; // 12
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->errIndex)))
      goto DONE_PDU;
errcode++; // 13
   break;

   case SNMP_PDU_V1TRAP:
   pdu->v1Trap = GlobalAlloc (GPTR, sizeof(V1TRAP));
   if (pdu->v1Trap == NULL)
      goto DONE_PDU;
errcode++; // 11
   if (!(ParseOID (&msgPtr, &msgLen, &pdu->v1Trap->enterprise)))
      goto DONE_PDU;
errcode++; // 12
   if (!(ParseOctetString (&msgPtr, &msgLen, &pdu->v1Trap->agent_addr)))
      goto DONE_PDU;
errcode++; // 13
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->v1Trap->generic_trap)))
      goto DONE_PDU;
errcode++; // 14
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->v1Trap->specific_trap)))
      goto DONE_PDU;
errcode++; // 15
   if (!(ParseUInt (&msgPtr, &msgLen, &pdu->v1Trap->time_ticks)))
      goto DONE_PDU;
errcode++; // 16
   break;

   default:
   goto DONE_PDU;
   } // end_switch
errcode = 20; // re-normalize
// Waste the SEQUENCE tag
if (!(ParseSequence (&msgPtr, &msgLen)))
      goto DONE_PDU;
errcode++; // 21
// Parse the varbind list
pdu->VBL = 0;
pdu->VBL_addr = NULL;
while (msgLen)
   {
   if (!(vb_ptr = ParseVarBind (&msgPtr, &msgLen)))
      goto DONE_PDU;
errcode++; // 22+
   if (!pdu->VBL_addr)                     // Is this the first one?
      vb_end_ptr = pdu->VBL_addr = vb_ptr; // If so, start a list
   else
      { // tack onto end of list
      vb_end_ptr->next_var = vb_ptr;
      vb_end_ptr = vb_ptr;
      }
   } // end_while
errcode = 0;
*community = os_ptr;
goto DONE;
DONE_PDU:
FreeVarBindList (pdu->VBL_addr); // Checks for NULL
FreeV1Trap (pdu->v1Trap);        // Checks for NULL
ZeroMemory (pdu, sizeof(PDUS));
DONE_OS:
FreeOctetString (os_ptr);
DONE:
return (errcode);
} // end_ParseMessage

LPVARBIND ParseVarBind (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
LPVARBIND vb_ptr;
if (!(ParseSequence (tmpPtr, tmpLen)))
   return (NULL);
if ((vb_ptr = (LPVARBIND)GlobalAlloc(GPTR, sizeof(VARBIND))) == NULL)
   return (NULL);
if (!(ParseOID(tmpPtr, tmpLen, &vb_ptr->name)))
   goto ERROROUT;
//we're going to derefrence (*tmpPtr), check length left first
if (*tmpLen == 0)
   goto ERROROUT;
vb_ptr->value.syntax = (smiUINT32)*(*tmpPtr);
switch (vb_ptr->value.syntax)
   {
   case SNMP_SYNTAX_CNTR32:
   case SNMP_SYNTAX_GAUGE32:
   case SNMP_SYNTAX_TIMETICKS:
   case SNMP_SYNTAX_UINT32:
   if (!(ParseUInt (tmpPtr, tmpLen, &vb_ptr->value.value.uNumber)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_INT:
   if (!(ParseInt (tmpPtr, tmpLen, &vb_ptr->value.value.sNumber)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_OID:
   if (!(ParseOID (tmpPtr, tmpLen, &vb_ptr->value.value.oid)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_CNTR64:
   if (!(ParseCntr64 (tmpPtr, tmpLen, &vb_ptr->value.value.hNumber)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_OPAQUE:
   if (!(ParseOctetString (tmpPtr, tmpLen, &vb_ptr->value.value.string)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_NULL:
   case SNMP_SYNTAX_NOSUCHOBJECT:
   case SNMP_SYNTAX_NOSUCHINSTANCE:
   case SNMP_SYNTAX_ENDOFMIBVIEW:
   if (!(ParseNull (tmpPtr, tmpLen)))
      goto ERROROUT;
   break;

   default:
   goto ERROROUT;
   } // end_switch
return (vb_ptr); // Success
//
ERROROUT:
FreeVarBind(vb_ptr);
return (NULL);   // Failure
} // end_ParseVarBind

BOOL ParseOctetString
      (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOCTETS os_ptr)
{
smiINT32 length;

if (!os_ptr)
   return (FALSE);
os_ptr->ptr = NULL;
os_ptr->len = 0;
if (ParseType (tmpPtr, tmpLen) == -1)
   return (FALSE);
// make sure no conversion to UINT is done before testing
// because os_ptr->len is of UINT type
length = ParseLength (tmpPtr, tmpLen);
// note: we don't reject zero length Octet String 
if (length < 0 || (smiUINT32)length > *tmpLen)
   return (FALSE);
os_ptr->len = (smiUINT32)length;
if (os_ptr->len)
   { // Does not allocate "string" space on "length = 0"
   if (!(os_ptr->ptr = (smiLPBYTE)GlobalAlloc (GPTR, os_ptr->len)))
      return (FALSE);
   CopyMemory (os_ptr->ptr, *tmpPtr, os_ptr->len);
   }
*tmpPtr += os_ptr->len;
*tmpLen -= os_ptr->len;
return (TRUE);
} // end_ParseOctetString

BOOL ParseOID (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOID oid_ptr)
{
    smiINT32 length;

    if (!oid_ptr)
        return (FALSE);
    oid_ptr->ptr = NULL;
    oid_ptr->len = 0;
    if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_OID)
        return (FALSE);
    length = ParseLength (tmpPtr, tmpLen);
    // -1 is error return from ParseLength()

    // BUG# 347175 this is just the length in bytes for the BER encoded OID in the stream, 
    // this code should be the same as in %sdxroot%\net\snmp\newagent\exe\snmppdus.c!ParseOid.
    // removed the (|| length > MAXOBJIDSIZE) condition from the following test. It should be
    // moved to the while loop to test the number of sub-ids instead of bytes in stream.
    if (length <= 0)  
        return (FALSE);
    if ((smiUINT32)length > *tmpLen)
        return (FALSE);
    // the sub-id array will by 1 longer than the ASN.1/BER array
    oid_ptr->ptr = (smiLPUINT32)GlobalAlloc (GPTR, sizeof(smiUINT32) * (length+1));
    if (oid_ptr->ptr == NULL)
        return (FALSE);

    // oid_ptr structure space is pre-zero'd via GlobalAlloc()
    while (length && (oid_ptr->len < MAXOBJIDSIZE))
    {
        if (oid_ptr->ptr[oid_ptr->len] & 0xFE000000)
        {
            // overflow in the next left shift
            GlobalFree(oid_ptr->ptr);
            oid_ptr->ptr = NULL;
            oid_ptr->len = 0;
            return (FALSE);
        }
        oid_ptr->ptr[oid_ptr->len] =
            (oid_ptr->ptr[oid_ptr->len] << 7) + (*(*tmpPtr) & 0x7F);
        if ((*(*tmpPtr)++ & 0x80) == 0)
        {   // on the last octet of this sub-id
            if (oid_ptr->len == 0)  // check for first sub-id
            {                       // ASN.1/BER packs two into it
                oid_ptr->ptr[1] = oid_ptr->ptr[0];
                oid_ptr->ptr[0] /= 40;
                if (oid_ptr->ptr[0] > 2)
                    oid_ptr->ptr[0] = 2;
                oid_ptr->ptr[1] -= (oid_ptr->ptr[0] * 40);
                oid_ptr->len++; // extra bump
            }
            oid_ptr->len++; // increment the count on sub-id
        }
        length--;
        (*tmpLen)--;
    } // end_while (length)

    // BUG 506192
    // Invalid OID BER of the form like "06 07 FF FF FF FF FF FF FF"
    // causes oid_ptr->len becomes 0. Each subidentifier should be
    // encoded as a non-negative integer using as few 7-bit blocks as possible.
    // The blocks are packed in octets with the first bit of each octet equal
    // to 1 except for the last octet of each subidentifier. The example above
    // does not have the last octet. Added the (0 == oid_ptr->len) test below.
    if (length || (0 == oid_ptr->len)) 
    {
        // the above while loop is terminated without finishing the parsing of the stream
        GlobalFree(oid_ptr->ptr);
        oid_ptr->ptr = NULL;
        oid_ptr->len = 0;
        return (FALSE);
    }

    return (TRUE);
} // end_ParseOID

BOOL ParseCntr64 (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPCNTR64 Cntr64_ptr)
{
smiINT32 i;
smiINT32 length;
if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_CNTR64)
   return (FALSE);
length = ParseLength(tmpPtr, tmpLen);
if (length <= 0)
    return (FALSE);
if ((smiUINT32)length > *tmpLen || length > 9 ||
   (length == 9 && *(*tmpPtr) != 0x00))
   return (FALSE);
while (length && *(*tmpPtr) == 0x00)
   {            // leading null octet?
   (*tmpPtr)++; // if so, skip it
   length--;    // and don't count it
   (*tmpLen)--;   // Adjust remaining msg length
   }
Cntr64_ptr->hipart = Cntr64_ptr->lopart = 0;
for (i = 0; i < length; i++)
   {
   Cntr64_ptr->hipart = (Cntr64_ptr->hipart << 8) +
                        (Cntr64_ptr->lopart >> 24);
   Cntr64_ptr->lopart = (Cntr64_ptr->lopart << 8) +
                        (smiUINT32) *(*tmpPtr)++;
   }
*tmpLen -= length;
return (TRUE);
} // end_ParseCntr64

BOOL ParseUInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPUINT32 value)
{
smiINT32 length;
smiINT32 i;
if (ParseType (tmpPtr, tmpLen) == -1)
   return (FALSE);
length = ParseLength(tmpPtr, tmpLen);
if (length <= 0)
    return (FALSE);
if ((smiUINT32)length > *tmpLen)
   return (FALSE);
if ((length > 5) || ((length > 4) && (*(*tmpPtr) != 0x00)))
   return (FALSE);
while (length && *(*tmpPtr) == 0x00)
   {            // leading null octet?
   (*tmpPtr)++; // if so, skip it
   length--;    // and don't count it
   (*tmpLen)--;   // Adjust remaining msg length
   }
*value = 0;
for (i = 0; i < length; i++)
   *value = (*value << 8) + (smiUINT32)*(*tmpPtr)++;
*tmpLen -= length;
return (TRUE);
} // end_ParseUInt()

BOOL ParseInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPINT value)
{
smiINT32 length;
smiINT32 i;
smiINT32 sign;
if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_INT)
   return (FALSE);
length = ParseLength (tmpPtr, tmpLen);
if (length <= 0)
    return (FALSE);
if ((smiUINT32)length > *tmpLen || length > 4)
   return (FALSE);
sign = ((*(*tmpPtr) & 0x80) == 0x00) ? 0x00 : 0xFF;
*value = 0;
for (i = 0; i < length; i++)
   *value = (*value << 8) + (smiUINT32) *(*tmpPtr)++;
// sign-extend upper bits
for (i = length; i < 4; i++)
   *value = *value + (sign << i * 8);
*tmpLen -= length;
return (TRUE);
} // end_ParseInt()

BOOL ParseNull (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
smiINT32 length;
if (ParseType (tmpPtr, tmpLen) == -1)
   return (FALSE);
length = ParseLength (tmpPtr, tmpLen);
if (length != 0) // NULLs have no length
   return (FALSE);
return (TRUE);
} // end_ParseNull

BOOL ParseSequence (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_SEQUENCE)
   return (FALSE);
if (ParseLength (tmpPtr, tmpLen) == -1)
   return (FALSE);
return (TRUE);
} // end_ParseSequence

smiINT32 ParseType (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
// 980421 - BobN
//        - replaced tmpLen logic with working_len logic
//        - working_len is always checked on entry into a
//        - Parse<xxx> function
smiINT32 type;
if (*tmpLen == 0)
   return (-1);
type = *(*tmpPtr)++;
(*tmpLen)--; // Adjust remaining msg length
switch (type)
   {
   case SNMP_SYNTAX_INT:
   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_OID:
   case SNMP_SYNTAX_SEQUENCE:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_CNTR32:
   case SNMP_SYNTAX_GAUGE32:
   case SNMP_SYNTAX_TIMETICKS:
   case SNMP_SYNTAX_OPAQUE:
   case SNMP_SYNTAX_UINT32:
   case SNMP_SYNTAX_CNTR64:
   case SNMP_SYNTAX_NULL:
   case SNMP_SYNTAX_NOSUCHOBJECT:
   case SNMP_SYNTAX_NOSUCHINSTANCE:
   case SNMP_SYNTAX_ENDOFMIBVIEW:
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_V1TRAP:
   case SNMP_PDU_GETBULK:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   break;

   default:
   type = -1;
   break;
   }
return (type);
} // end_ParseType

smiINT32 ParseLength (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
// 980421 - BobN
//        - replaced end_ptr logic with tmpLen logic
//        - tmpLen is always checked on entry into a Parse<xxx>
//        - function and is decremented as used therein.
smiINT32 length;
smiINT32 lenlen;
if (*tmpLen == 0)
   return (-1);
length = (smiINT32) *(*tmpPtr)++;
(*tmpLen)--; // Adjust remaining msg length
// Check for short-form value
if (length < 0x80)
   return (length);
// Long form
lenlen = length & 0x7F;
if ((smiUINT32)lenlen > *tmpLen || lenlen > 4 || lenlen < 1)
   return (-1); // Out of bounds
*tmpLen -= lenlen; // Adjust remaining msg length
length = 0;
while (lenlen)
   {
   length = (length << 8) + *(*tmpPtr)++;
   lenlen--;
   }
return (length);
} // end_ParseLength
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_ec.c ===
// wsnmp_ec.c
//
// WinSNMP Entity/Context Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980424 - BobN
//        - Mods to SnmpStrToEntity() to support corresponding
//        - mods to SnmpStrToIpxAddress() to permit '.' char as
//        - netnum/nodenum separator
// 970310 - Typographical changes
//
#include "winsnmp.inc"
SNMPAPI_STATUS SNMPAPI_CALL SnmpStrToIpxAddress (LPCSTR, LPBYTE, LPBYTE);

// SnmpStrToEntity
HSNMP_ENTITY SNMPAPI_CALL
   SnmpStrToEntity (IN HSNMP_SESSION hSession,
                    IN LPCSTR entityString)
{
DWORD strLen;
LPCSTR tstStr;
LPSTR profilePtr;
LPSTR comma = ",";
DWORD nEntity;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
char profileBuf[MAX_PATH];
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
if (!entityString || (strLen = lstrlen(entityString)) == 0)
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Must go through ERROR_PRECHECK label after next statement...
EnterCriticalSection (&cs_ENTITY);
// Search for Entity table entry to use
lError = snmpAllocTableEntry(&EntsDescr, &nEntity);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);

pEntity->version = 0;
pEntity->nPolicyTimeout = DEFTIMEOUT;
pEntity->nPolicyRetry = DEFRETRY;
if (strLen > MAX_FRIEND_NAME_LEN)
   strLen = MAX_FRIEND_NAME_LEN;
switch (TaskData.nTranslateMode)
   {
   case SNMPAPI_TRANSLATED:
   // the entity is picked up from NP_WSNMP.INI, from [Entities] section:
   // [Entities]
   // EntityFriendlyName = ver#, ipaddr, timeout#, retries#, port#[,]
   // ------
   // Get the whole buffer
   if (!GetPrivateProfileString ("Entities", entityString, "",
                     profileBuf, sizeof(profileBuf)/sizeof(profileBuf[0]), "NP_WSNMP.INI"))
      {
      snmpFreeTableEntry(&EntsDescr, nEntity);
      lError = SNMPAPI_ENTITY_UNKNOWN;
      goto ERROR_PRECHECK;
      }
   // pick up the ver# first (mandatory)
   profilePtr = strtok (profileBuf, comma);
   // if no token, is like we have a key with no value
   // bail out with SNMPAPI_NOOP
   if (profilePtr == NULL)
   {
       snmpFreeTableEntry(&EntsDescr, nEntity);
       lError = SNMPAPI_NOOP;
       goto ERROR_PRECHECK;
   }
   pEntity->version = atoi (profilePtr);

   // pick up the dotted ip address (mandatory)
   tstStr = strtok (NULL, comma); // Save real address string
   // if no address is specified, we don't have the vital info, so there's nothing to do
   // bail with SNMPAPI_NOOP
   if (tstStr == NULL)
   {
       snmpFreeTableEntry(&EntsDescr, nEntity);
       lError = SNMPAPI_NOOP;
       goto ERROR_PRECHECK;
   }

   // pick up the timeout# (optional)
   if (profilePtr = strtok (NULL, comma))
   {
        // The local database entry uses milliseconds for the timeout interval
        pEntity->nPolicyTimeout = atol (profilePtr);
        // Adjust for centiseconds, as used by the WinSNMP API
        pEntity->nPolicyTimeout /= 10;

        // pick up the retry# (optional)
        if (profilePtr = strtok (NULL, comma))
        {
            pEntity->nPolicyRetry = atol (profilePtr);

            // pick up the port# (optional)
            if (profilePtr = strtok (NULL, comma))
                pEntity->addr.inet.sin_port = htons ((short)atoi (profilePtr));
         }
      }
   break;

   // "version" was set to 0 above
   // if _V2, it will be incremented twice
   // if _V1, it will be incremented only once
   case SNMPAPI_UNTRANSLATED_V2:
   pEntity->version++;
   case SNMPAPI_UNTRANSLATED_V1:
   pEntity->version++;
   tstStr = entityString;           // Save real address string
   break;

   default:
   snmpFreeTableEntry(&EntsDescr, nEntity);
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_PRECHECK;
   } // end_switch
CopyMemory (pEntity->name, entityString, strLen); 
pEntity->name[strLen] = '\0'; // null terminated, name has size of MAX_FRIEND_NAME_LEN+1
if (strncmp(tstStr, "255.255.255.255", 15) && inet_addr (tstStr) == INADDR_NONE)
   { // Not AF_INET, try AF_IPX
   if (SnmpStrToIpxAddress (tstStr,
                            pEntity->addr.ipx.sa_netnum,
                            pEntity->addr.ipx.sa_nodenum) == SNMPAPI_FAILURE)
      {
      snmpFreeTableEntry(&EntsDescr, nEntity);
      LeaveCriticalSection (&cs_ENTITY);
      return ((HSNMP_ENTITY) ULongToPtr(SaveError (hSession, SNMPAPI_ENTITY_UNKNOWN)));
      }
   pEntity->addr.ipx.sa_family = AF_IPX;
   if (pEntity->addr.ipx.sa_socket == 0)
      pEntity->addr.ipx.sa_socket = htons (IPX_SNMP_PORT);
   }
else
   { // AF_INET
   pEntity->addr.inet.sin_family = AF_INET;
   if (pEntity->addr.inet.sin_port == 0)
      pEntity->addr.inet.sin_port = htons (IP_SNMP_PORT);
   pEntity->addr.inet.sin_addr.s_addr = inet_addr (tstStr);
   }
// Record the creating session
pEntity->Session = hSession;
// Initialize refCount for SnmpFreeEntity garbage collection
pEntity->refCount = 1;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_ENTITY);
ERROR_OUT:
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_ENTITY) ULongToPtr(nEntity+1));
else // Failure cases
   return ((HSNMP_ENTITY) ULongToPtr(SaveError (lSession, lError)));
} //end_SnmpStrToEntity

// SnmpEntityToStr
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpEntityToStr (IN HSNMP_ENTITY hEntity,
                    IN smiUINT32 size,
                    OUT LPSTR string)
{
DWORD nEntity = HandleToUlong(hEntity) - 1;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPSTR str;
smiUINT32 len;
char tmpStr[24];
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_UNKNOWN;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
lSession = pEntity->Session;
if (size == 0)
   {
   lError = SNMPAPI_SIZE_INVALID;
   goto ERROR_OUT;
   }
if (IsBadWritePtr(string, size))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
len = 0;
if (TaskData.nTranslateMode == SNMPAPI_TRANSLATED)
   {
   str = pEntity->name;
   len = lstrlen (str);
   }
else
   {
   if (pEntity->addr.inet.sin_family == AF_INET)
      {
      // prefix bug 445174 
      if ((str = inet_ntoa (pEntity->addr.inet.sin_addr)) != NULL)
         len = lstrlen (str);
      else
         {
         lError = SNMPAPI_OTHER_ERROR; // error in inet_ntoa call
         goto ERROR_OUT;
         }
      }
   else if (pEntity->addr.ipx.sa_family == AF_IPX)
      {
      SnmpIpxAddressToStr (pEntity->addr.ipx.sa_netnum,
                           pEntity->addr.ipx.sa_nodenum,
                           tmpStr);
      str = tmpStr;
      len = lstrlen (str);
      }
   else
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   }
if (len >= size)
   {
   CopyMemory (string, str, size);
   string[size-1] = '\0';
   lError = SNMPAPI_OUTPUT_TRUNCATED;
   goto ERROR_OUT;
   }
else
   {
   lstrcpy (string, str);
   return (len+1);
   }
// Failure cases
ERROR_OUT:
return (SaveError (lSession, lError));
} // End_SnmpEntityToStr

// SnmpFreeEntity
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeEntity (IN HSNMP_ENTITY hEntity)
{
DWORD nEntity;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
EnterCriticalSection (&cs_ENTITY);
// Decrement refCount (unless already 0 [error])
if (pEntity->refCount)
   pEntity->refCount--;
// Now actually free it...
if (pEntity->Agent == 0 &&     // but not if it's an Agent
    pEntity->refCount == 0)   // nor if other references exist
    snmpFreeTableEntry(&EntsDescr, nEntity);

LeaveCriticalSection (&cs_ENTITY);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}

// SnmpStrToContext
// Allow for zero-length/NULL context...BN 3/12/96
HSNMP_CONTEXT  SNMPAPI_CALL
   SnmpStrToContext (IN HSNMP_SESSION hSession,
                     IN smiLPCOCTETS contextString)
{
DWORD strLen;
DWORD nContext;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
char profileBuf[MAX_PATH];
LPSTR profilePtr;
LPSTR comma = ",";
LPCTXT pCtxt;
smiOCTETS tmpContextString;

tmpContextString.len = 0;
tmpContextString.ptr = NULL;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // Save for possible error return
if (IsBadReadPtr (contextString, sizeof(smiOCTETS)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

if (IsBadReadPtr (contextString->ptr, contextString->len))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
// Remember to allow for 0-len contexts (as above does)
EnterCriticalSection (&cs_CONTEXT);
// Search for Entity table entry to use
lError = snmpAllocTableEntry(&CntxDescr, &nContext);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pCtxt = snmpGetTableEntry(&CntxDescr, nContext);

pCtxt->version = 0; // just to be sure
pCtxt->name[0] = pCtxt->commStr[0] = '\0';
// Following "if" test allows for zero-length/NULL community string
// (deliberate assignment in conditional...)
if (pCtxt->commLen = contextString->len)
   {
   switch (TaskData.nTranslateMode)
      {
      case SNMPAPI_TRANSLATED:
      // make a copy of input parameter to make sure the raw data is null terminated
      tmpContextString.ptr = (smiLPBYTE) GlobalAlloc(GPTR, contextString->len + 2);
      if (tmpContextString.ptr == NULL)
      {
         snmpFreeTableEntry(&CntxDescr, nContext);
         lError = SNMPAPI_ALLOC_ERROR;
         goto ERROR_PRECHECK;   
      }
      tmpContextString.len = contextString->len;
      CopyMemory(tmpContextString.ptr, contextString->ptr, contextString->len);
      if (!GetPrivateProfileString ("Contexts", tmpContextString.ptr, "",
                                    profileBuf, sizeof(profileBuf)/sizeof(profileBuf[0]), "NP_WSNMP.INI"))
         {
         snmpFreeTableEntry(&CntxDescr, nContext);
         lError = SNMPAPI_CONTEXT_UNKNOWN;
         goto ERROR_PRECHECK;
         }
      strLen = min(contextString->len, MAX_FRIEND_NAME_LEN);
      CopyMemory (pCtxt->name, contextString->ptr, strLen);
      pCtxt->name[strLen] = '\0'; // name is size of MAX_FRIEND_NAME_LEN+1

      // pick up the version# for this context (mandatory)
      profilePtr = strtok (profileBuf, comma);
      // if there is no such version# is like we have a INI key without its value,
      // so bail out with SNMPAPI_NOOP
      if (profilePtr == NULL)
      {
          snmpFreeTableEntry(&CntxDescr, nContext);
          lError = SNMPAPI_NOOP;
          goto ERROR_PRECHECK;
      }
      pCtxt->version = (DWORD) atoi (profilePtr);

      // pick up the actual context value (mandatory)
      profilePtr = strtok (NULL, comma);
      // if there is no such value, is like we have the friendly name but this is malformed
      // and doesn't point to any actual context.
      // bail out with SNMPAPI_NOOP
      if (profilePtr == NULL)
      {
          snmpFreeTableEntry(&CntxDescr, nContext);
          lError = SNMPAPI_NOOP;
          goto ERROR_PRECHECK;
      }
      strLen = min(lstrlen (profilePtr), MAX_CONTEXT_LEN);
      pCtxt->commLen = strLen;
      CopyMemory (pCtxt->commStr, profilePtr, strLen);
      break;

      // "version" was set to 0 above
      // if _V2, it will be incremented twice
      // if _V1, it will be incremented only once
      case SNMPAPI_UNTRANSLATED_V2:
      pCtxt->version++;
      case SNMPAPI_UNTRANSLATED_V1:
      pCtxt->version++;
      strLen = min(contextString->len, MAX_CONTEXT_LEN);
      pCtxt->commLen = strLen; // updates the len of the commStr
      CopyMemory (pCtxt->commStr, contextString->ptr, strLen);
      break;

      default:
      snmpFreeTableEntry(&CntxDescr, nContext);
      lError = SNMPAPI_MODE_INVALID;
      goto ERROR_PRECHECK;
      } // end_switch
   // Remember that NULL community strings are allowed!
   } // end_if (on len)
// Record the creating session value
pCtxt->Session = hSession;
// Initialize refCount for SnmpFreeContext garbage collection
pCtxt->refCount = 1;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_CONTEXT);
if (tmpContextString.ptr)
   GlobalFree(tmpContextString.ptr);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_CONTEXT) ULongToPtr(nContext+1));
ERROR_OUT:
return ((HSNMP_CONTEXT) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpStrToContext

// SnmpContextToStr
// Revised to allow for zero-length/NULL context...BN 3/12/96
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpContextToStr (IN HSNMP_CONTEXT hContext,
                     OUT smiLPOCTETS string)
{
smiUINT32 len;
smiLPBYTE str;
DWORD nCtx;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPCTXT pCtxt;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nCtx = HandleToUlong(hContext) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

// save session for possible error return
lSession = pCtxt->Session;
if (IsBadWritePtr(string, sizeof(smiLPOCTETS)))
   {
   lError = string == NULL ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
switch (TaskData.nTranslateMode)
   {
   case SNMPAPI_TRANSLATED:
   str = pCtxt->name;
   len = lstrlen (str);
// If calling mode is TRANSLATED, and friendly value was stored,
   if (len)
// then we are done here.
      break;
// If calling mode is TRANSLATED, but no value stored,
// then fall through to UNTRANSLATED default...
   case SNMPAPI_UNTRANSLATED_V1:
   case SNMPAPI_UNTRANSLATED_V2:
   str = pCtxt->commStr;
   len = pCtxt->commLen;
   break;

   default:
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
// Setup for possible zero-length/NULL context return
string->ptr = NULL;
// (deliberate assignment in conditional...)
if (string->len = len)
   {
   // App must free following alloc via SnmpFreeDescriptor()
   if (!(string->ptr = (smiLPBYTE)GlobalAlloc (GPTR, len)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   CopyMemory (string->ptr, str, len);
   }
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpContextToStr()

// SnmpFreeContext
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeContext (IN HSNMP_CONTEXT hContext)
{
DWORD nCtx;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPCTXT pCtxt;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nCtx = HandleToUlong(hContext) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

EnterCriticalSection (&cs_CONTEXT);
// Decrement refCount (unless already 0 [error])
if (pCtxt->refCount)
   pCtxt->refCount--;
// Now test refCount again
if (pCtxt->refCount == 0)
   snmpFreeTableEntry(&CntxDescr, nCtx);

LeaveCriticalSection (&cs_CONTEXT);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}

// SnmpSetPort
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetPort (IN HSNMP_ENTITY hEntity,
                IN UINT port)
{
DWORD nEntity;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
EnterCriticalSection (&cs_ENTITY);
if (pEntity->Agent)
   { // Entity running as agent, cannot change port now
   lError = SNMPAPI_OPERATION_INVALID;
   goto ERROR_PRECHECK;
   }
pEntity->addr.inet.sin_port = htons ((WORD)port);
ERROR_PRECHECK:
LeaveCriticalSection (&cs_ENTITY);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetPort()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_pd.c ===
// wsnmp_pd.c
//
// WinSNMP PDU Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// Removed extraneous functions
//
#include "winsnmp.inc"
LPVARBIND SnmpCopyVbl (LPVARBIND);
// PDU Functions
// SnmpCreatePdu
HSNMP_PDU SNMPAPI_CALL
   SnmpCreatePdu  (IN HSNMP_SESSION hSession,
                   IN smiINT PDU_type,
                   IN smiINT32 request_id,
                   IN smiINT error_status,
                   IN smiINT error_index,
                   IN HSNMP_VBL hVbl)
{
DWORD nPdu;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
if (hVbl)
	{
	if (!snmpValidTableEntry(&VBLsDescr, HandleToUlong(hVbl)-1))
		{
		lError = SNMPAPI_VBL_INVALID;
		goto ERROR_OUT;
		}
	}

if (!PDU_type)  // NULL is allowed and defaults to SNMP_PDU_GETNEXT
   PDU_type = SNMP_PDU_GETNEXT;
switch (PDU_type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   case SNMP_PDU_GETBULK:
   break;

   case SNMP_PDU_V1TRAP:
   default:
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }

EnterCriticalSection (&cs_PDU);
lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

// Initialize new PDU components
pPdu->Session  = hSession;
pPdu->type = PDU_type;
pPdu->errStatus = error_status;
pPdu->errIndex  = error_index;
// If RequestID=0 at this point, assign one (which may be 0)
pPdu->appReqId = (request_id) ? request_id : ++(TaskData.nLastReqId);
pPdu->VBL_addr = NULL;
pPdu->VBL = (hVbl) ? hVbl : 0;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);

if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_PDU) ULongToPtr(nPdu+1));
else
ERROR_OUT:
   return ((HSNMP_PDU) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpCreatePdu

// SnmpGetPduData
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetPduData (IN HSNMP_PDU hPdu,
                   OUT smiLPINT PDU_type,
                   OUT smiLPINT32 request_id,
                   OUT smiLPINT error_status,
                   OUT smiLPINT error_index,
                   OUT LPHSNMP_VBL hVbl)
{
DWORD nPdu = HandleToUlong(hPdu) - 1;
DWORD done = 0;
HSNMP_SESSION hSession;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

// Use PDU's session for (possibly) creating hVbl later
hSession = pPdu->Session;
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // Save for possible error return
if (PDU_type)
   {
   *PDU_type = pPdu->type;
   done++;
   }
if (request_id)
   {
   *request_id = pPdu->appReqId;
   done++;
   }
if (error_status)
   {
   *error_status = pPdu->errStatus;
   done++;
   }
if (error_index)
   {
   *error_index = pPdu->errIndex;
   done++;
   }
if (hVbl)
   {
   DWORD nVbl; // Important control variable
   *hVbl = 0;
   EnterCriticalSection (&cs_VBL);
   // First case is on a created (not received) PDU
   // which has not yet been assigned a VBL
   if ((!pPdu->VBL) && (!pPdu->VBL_addr))
      goto DONE_VBL;
   // If there is a VBL already assinged to the PDU,
   // then duplicate it
   if (pPdu->VBL)
      { // Per policy, create a new hVbl resource for the calling app
      if (!(*hVbl = SnmpDuplicateVbl (hSession, pPdu->VBL)))
         {
         lError = SNMPAPI_VBL_INVALID;
         goto ERROR_PRECHECK;
         }
      goto DONE_VBL;
      }
   // This must be a received PDU and
   // the first call to extract the VBL
   lError = snmpAllocTableEntry(&VBLsDescr, &nVbl);
   if (lError != SNMPAPI_SUCCESS)
	   goto ERROR_PRECHECK;
   pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

   pVbl->Session = hSession;
   pVbl->vbList = pPdu->VBL_addr;
   // Clear received vbList address...IMPORTANT!
   pPdu->VBL_addr = NULL;
   *hVbl = pPdu->VBL = (HSNMP_VBL) ULongToPtr(nVbl+1);
DONE_VBL:
   done++;
ERROR_PRECHECK:
   LeaveCriticalSection (&cs_VBL);
   } // end_if vbl
if (done == 0)
   lError = SNMPAPI_NOOP;
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpGetPduData

// SnmpSetPduData
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetPduData (IN HSNMP_PDU hPdu,
                   IN const smiINT FAR *PDU_type,
                   IN const smiINT32 FAR *request_id,
                   IN const smiINT FAR *non_repeaters,
                   IN const smiINT FAR *max_repetitions,
                   IN const HSNMP_VBL FAR *hVbl)
{
DWORD nPdu = HandleToUlong(hPdu) - 1;
DWORD done = 0;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }

if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

lSession = pPdu->Session; // Save for possible error return
EnterCriticalSection (&cs_PDU);
if (!IsBadReadPtr((LPVOID)PDU_type, sizeof(smiINT)))
   {
   if (*PDU_type == SNMP_PDU_V1TRAP)
       {
           lError = SNMPAPI_PDU_INVALID;
           goto ERROR_OUT;
       }
   pPdu->type = *PDU_type;
   done++;
   }
if (!IsBadReadPtr((LPVOID)request_id, sizeof(smiINT32)))
   {
   pPdu->appReqId = *request_id;
   done++;
   }
if (!IsBadReadPtr((LPVOID)non_repeaters, sizeof(smiINT)))
   {
   pPdu->errStatus = *non_repeaters;
   done++;
   }
if (!IsBadReadPtr((LPVOID)max_repetitions, sizeof(smiINT)))
   {
   pPdu->errIndex = *max_repetitions;
   done++;
   }
if (!IsBadReadPtr((LPVOID)hVbl, sizeof(HSNMP_VBL)))
   { // Assign new vbl
   HSNMP_VBL tVbl = *hVbl;
   // Check for validity
   if (!snmpValidTableEntry(&VBLsDescr, HandleToUlong(tVbl)-1))
      { // If not, disallow operation
      lError = SNMPAPI_VBL_INVALID;
      goto ERROR_PRECHECK;
      }
   pPdu->VBL = tVbl;
   // Following case can happen if a a vbl is assigned to a
   // response pdu which never had its vbl dereferenced...
   if (pPdu->VBL_addr) //...then is must be freed
      FreeVarBindList (pPdu->VBL_addr);
   pPdu->VBL_addr = NULL;
   done++;
   } // end_if vbl
ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);
if (done == 0)
   lError = ((PDU_type == NULL) && 
            (request_id == NULL) &&
            (non_repeaters == NULL) &&
            (max_repetitions == NULL) &&
            (hVbl == NULL)) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpSetPduData

// SnmpDuplicatePdu
HSNMP_PDU SNMPAPI_CALL
   SnmpDuplicatePdu  (IN HSNMP_SESSION hSession,
                      IN HSNMP_PDU hPdu)
{
DWORD lPdu = HandleToUlong(hPdu) - 1;
DWORD nPdu;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pOldPdu, pNewPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // save for possible error return
if (!snmpValidTableEntry(&PDUsDescr, lPdu) ||
    (pOldPdu = snmpGetTableEntry(&PDUsDescr, lPdu))->type == SNMP_PDU_V1TRAP)
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }

EnterCriticalSection (&cs_PDU);

lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pNewPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

CopyMemory (pNewPdu, pOldPdu, sizeof(PDUS));
pNewPdu->Session = hSession; // Can be different
// Setting the VBL value in the duplicated PDU is "tricky"...
// If there is a VBL value, just replicate it and that's that.
// If VBL = 0 and there is no VBL_addr attached to the pdu_ptr,
// then the VBL value is 0 and is already set from the original PDU.
// Otherwise, this is a received PDU from which the varbindlist has
// not yet been extracted and must, therefore, be re-produced.
// This third case is covered in the next *2* lines.
if ((!pOldPdu->VBL) && pOldPdu->VBL_addr)
   {
   if (!(pNewPdu->VBL_addr = SnmpCopyVbl (pOldPdu->VBL_addr)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      }
   }
ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_PDU) ULongToPtr(nPdu+1));
ERROR_OUT:
return ((HSNMP_PDU) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpDuplicatePdu

// SnmpFreePdu
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreePdu (IN HSNMP_PDU hPdu)
{
DWORD nPdu = HandleToUlong(hPdu) - 1;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

EnterCriticalSection (&cs_PDU);
if (pPdu->VBL_addr)
   FreeVarBindList (pPdu->VBL_addr);
if (pPdu->v1Trap)
   FreeV1Trap (pPdu->v1Trap);
snmpFreeTableEntry(&PDUsDescr, nPdu);
LeaveCriticalSection (&cs_PDU);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpfreePdu
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_db.c ===
// wsnmp_db.c
//
// WinSNMP Local Database Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
#include "winsnmp.inc"

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetVendorInfo (OUT smiLPVENDORINFO vendorInfo)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (vendorInfo == NULL)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
if (IsBadWritePtr(vendorInfo, sizeof(smiVENDORINFO)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Max len = 64
lstrcpy (&vendorInfo->vendorName[0], "Microsoft Corporation");
lstrcpy (&vendorInfo->vendorContact[0], "snmpinfo@microsoft.com");
// Max len = 32
lstrcpy (&vendorInfo->vendorVersionId[0], "v2.32.19980808");
lstrcpy (&vendorInfo->vendorVersionDate[0], "August 8, 1998");
vendorInfo->vendorEnterprise = 311;
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetVendorInfo()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetTranslateMode (OUT smiLPUINT32 nTranslateMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// Must have some place to write answer to...
if (IsBadWritePtr (nTranslateMode, sizeof(smiUINT32)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Ok to write value
*nTranslateMode = TaskData.nTranslateMode;
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetTranslateMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetTranslateMode (IN smiUINT32 nTranslateMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
switch (nTranslateMode)
   {
   case SNMPAPI_TRANSLATED:
   case SNMPAPI_UNTRANSLATED_V1:
   case SNMPAPI_UNTRANSLATED_V2:
   EnterCriticalSection (&cs_TASK);
   TaskData.nTranslateMode = nTranslateMode;
   LeaveCriticalSection (&cs_TASK);
   break;

   default:
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetTranslateMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetRetransmitMode (OUT smiLPUINT32 nRetransmitMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// Must have some place to write answer to...
if (IsBadWritePtr (nRetransmitMode, sizeof(smiUINT32)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Ok to write value
*nRetransmitMode = TaskData.nRetransmitMode;
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetRetransmitMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetRetransmitMode (IN smiUINT32 nRetransmitMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (nRetransmitMode != SNMPAPI_OFF && nRetransmitMode != SNMPAPI_ON)
   {
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_TASK);
TaskData.nRetransmitMode = nRetransmitMode;
LeaveCriticalSection (&cs_TASK);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetRetransmitMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetTimeout (IN  HSNMP_ENTITY hEntity,
                   OUT smiLPTIMETICKS nPolicyTimeout,
                   OUT smiLPTIMETICKS nActualTimeout)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);

if (!nPolicyTimeout && !nActualTimeout)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
// Intervals are specified and stored as centiseconds
if (nPolicyTimeout)
   {
   if (IsBadWritePtr (nPolicyTimeout, sizeof(smiTIMETICKS)))
      {
      lError  = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nPolicyTimeout = pEntity->nPolicyTimeout;
   }
if (nActualTimeout)
   {
   if (IsBadWritePtr (nActualTimeout, sizeof(smiTIMETICKS)))
      {
      lError  = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nActualTimeout = pEntity->nActualTimeout;
   }
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetTimeout()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetTimeout (IN HSNMP_ENTITY hEntity,
                   IN smiTIMETICKS nPolicyTimeout)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
EnterCriticalSection (&cs_ENTITY);
// Timeout interval is specified and stored in centiseconds
pEntity->nPolicyTimeout = nPolicyTimeout;
LeaveCriticalSection (&cs_ENTITY);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetTimeout()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetRetry (IN HSNMP_ENTITY hEntity,
                 OUT smiLPUINT32 nPolicyRetry,
                 OUT smiLPUINT32 nActualRetry)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
if (!nPolicyRetry && !nActualRetry)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
if (nPolicyRetry)
   {
   if (IsBadWritePtr (nPolicyRetry, sizeof(smiUINT32)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nPolicyRetry = pEntity->nPolicyRetry;
   }
if (nActualRetry)
   {
   if (IsBadWritePtr (nActualRetry, sizeof(smiUINT32)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nActualRetry = pEntity->nActualRetry;
   }
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetRetry()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetRetry (IN HSNMP_ENTITY hEntity,
                 IN smiUINT32 nPolicyRetry)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);

EnterCriticalSection (&cs_ENTITY);
pEntity->nPolicyRetry = nPolicyRetry;
LeaveCriticalSection (&cs_ENTITY);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetRetry()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_cf.c ===
// wsnmp_cf.c
//
// WinSNMP Communications Functions and helpers
// Copyright 1995-1998 ACE*COMM Corp
// Rleased to Microsoft under Contract
//
// Bob Natale (bnatale@acecomm.com)
//
// 19980625 - Modified SnmpStartup() to allow for NULL
//            output args and to check for IsBadWritePtr()
//            when non-NULL
//
#include "winsnmp.inc"

#define SNMP_MAJOR_VERSION 2
#define SNMP_MINOR_VERSION 0
#define SNMP_SUPPORT_LEVEL SNMPAPI_V2_SUPPORT


LPPDUS MapV2TrapV1 (HSNMP_PDU hPdu);
THR_TYPE WINAPI thrManager (LPVOID);
THR_TYPE WINAPI thrTrap (LPVOID);
THR_TYPE WINAPI thrTimer (LPVOID);
THR_TYPE WINAPI thrAgent (LPVOID);
THR_TYPE WINAPI thrNotify (LPVOID);

void FreeRegister (DWORD nTrap)
{
LPTRAPNOTICE pTrap;
EnterCriticalSection (&cs_TRAP);
pTrap = snmpGetTableEntry(&TrapDescr, nTrap);
if (pTrap->ourEntity)
   SnmpFreeEntity (pTrap->ourEntity);
if (pTrap->agentEntity)
   SnmpFreeEntity (pTrap->agentEntity);
if (pTrap->Context)
   SnmpFreeContext (pTrap->Context);
snmpFreeTableEntry(&TrapDescr, nTrap);
LeaveCriticalSection (&cs_TRAP);
return;
} // end_FreeRegister

// Exported Functions
// SnmpStartup
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpStartup (OUT smiLPUINT32 nMajorVersion,
                OUT smiLPUINT32 nMinorVersion,
                OUT smiLPUINT32 nLevel,
                OUT smiLPUINT32 nTranslateMode,
                OUT smiLPUINT32 nRetransmitMode)
{
WSADATA wsaData;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION hTask = (HSNMP_SESSION) ULongToPtr(GetCurrentProcessId());
//

//
if (nMajorVersion)
   {
   if (IsBadWritePtr (nMajorVersion, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nMajorVersion = SNMP_MAJOR_VERSION;
   }
if (nMinorVersion)
   {
   if (IsBadWritePtr (nMinorVersion, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nMinorVersion = SNMP_MINOR_VERSION;
   }
if (nLevel)
   {
   if (IsBadWritePtr (nLevel, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nLevel = SNMP_SUPPORT_LEVEL;
   }
if (nTranslateMode)
   {
   if (IsBadWritePtr (nTranslateMode, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nTranslateMode  = SNMPAPI_UNTRANSLATED_V1;
   }
if (nRetransmitMode)
   {
   if (IsBadWritePtr (nRetransmitMode, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nRetransmitMode = SNMPAPI_ON;
   }
goto ARGS_OK;
ARG_ERROR:
lError = SNMPAPI_ALLOC_ERROR;
goto ERROR_OUT;
ARGS_OK:
EnterCriticalSection (&cs_TASK);
TaskData.nRetransmitMode = SNMPAPI_ON;
TaskData.nTranslateMode  = SNMPAPI_UNTRANSLATED_V1;
// we need to turn this on in order to have WINSNMP to pass back not
// only the entity standing for the source Ip address but also the
// agent address as it was sent into the V1 Trap Pdu.
TaskData.conveyAddress = SNMPAPI_ON;
// SnmpStartup is idempotent...
if (TaskData.hTask == hTask)
   goto DONE;  // ...already called
// New task starting up...get OS info
TaskData.sEnv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
if (!GetVersionEx (&TaskData.sEnv))
   {
   lError = SNMPAPI_OTHER_ERROR;
   goto ERROR_PRECHECK;
   }
// Start WinSock connection...should return 0
if (WSAStartup ((WORD)0x0101, &wsaData))
   {
   lError = SNMPAPI_TL_NOT_INITIALIZED;
   goto ERROR_PRECHECK;
   }
// Set trapPipe (used in NT case only)
TaskData.trapPipe = INVALID_HANDLE_VALUE;
// bug# 270672
// create non-signaled event to synchronize shutdown of thrTrap
TaskData.trapEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
if (NULL == TaskData.trapEvent)
   {
   lError = SNMPAPI_ALLOC_ERROR;
   WSACleanup();
   goto ERROR_PRECHECK;
   }
// init the trapOl overlapped struct with manual reset non-signaled event   
ZeroMemory(&TaskData.trapOl, sizeof(TaskData.trapOl));
TaskData.trapOl.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
if (NULL == TaskData.trapOl.hEvent)    
   {
   lError = SNMPAPI_ALLOC_ERROR;
   CloseHandle(TaskData.trapEvent);
   TaskData.trapEvent = NULL;
   WSACleanup();
   goto ERROR_PRECHECK;
   }
// init TaskData.hExitEvent with manual reset non-signaled event to
// synchronize shutdown of thrManager
TaskData.hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
if (NULL == TaskData.hExitEvent)    
   {
   lError = SNMPAPI_ALLOC_ERROR;
   CloseHandle(TaskData.trapEvent);
   TaskData.trapEvent = NULL;
   CloseHandle(TaskData.trapOl.hEvent);
   TaskData.trapOl.hEvent = NULL;
   WSACleanup();
   goto ERROR_PRECHECK;
   }
// Set trapSock (used in Win95 case only)
TaskData.trapSock = INVALID_SOCKET;
// Set "manager" sockets (used at SnmpSendMsg() time)
TaskData.ipSock = TaskData.ipxSock = INVALID_SOCKET;
// Start timer thread

{
DWORD thrId;
TaskData.timerThread = (HANDLE)_beginthreadex (NULL, 0, thrTimer, NULL, 0, &thrId);
if (NULL == TaskData.timerThread)
   {
   lError = SNMPAPI_TL_RESOURCE_ERROR;
   CloseHandle(TaskData.trapEvent);
   TaskData.trapEvent = NULL;
   CloseHandle(TaskData.trapOl.hEvent);
   TaskData.trapOl.hEvent = NULL;
   WSACleanup();
   goto ERROR_PRECHECK;
   }
}

//
DONE:
TaskData.hTask = hTask;
TaskData.nLastError = SNMPAPI_SUCCESS;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_TASK);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpStartup

// SnmpCleanup
SNMPAPI_STATUS SNMPAPI_CALL SnmpCleanup (void)
{
DWORD nSession;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
// Variables for threads not associated with a specific session
DWORD nHandles = 0;
HANDLE hTemp[4] = {NULL, NULL, NULL, NULL};
CONST HANDLE *hObjects = &hTemp[0];
//--------------------------------------------------------------
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_SESSION);
// Do all Forgotten Closes
if (SessDescr.Used)
   {
   for (nSession = 0; nSession < SessDescr.Allocated; nSession++)
      if (((LPSESSION)snmpGetTableEntry(&SessDescr, nSession))->nTask)
         SnmpClose ((HSNMP_SESSION) ULongToPtr(nSession + 1));
   }
LeaveCriticalSection (&cs_SESSION);
EnterCriticalSection (&cs_TASK);
SetEvent(TaskData.hExitEvent); // askes thrManager to exit
// Terminate thrTimer
if (TaskData.timerThread)
   {
   hTemp[nHandles++] = TaskData.timerThread;
   // NULL signals the timer thread to terminate itself
   TaskData.timerThread = NULL;
   }
// Close "Mgr" sockets and threads
if (TaskData.ipSock != INVALID_SOCKET)
   {// UDP channel
   // check thrManager code to understand the lines below:
   SOCKET ipSock = TaskData.ipSock;
   WaitForSingleObject (TaskData.ipThread, INFINITE);
   TaskData.ipSock = INVALID_SOCKET;
   closesocket (ipSock);
   if (TaskData.ipThread)
      hTemp[nHandles++] = TaskData.ipThread;
   }
if (TaskData.ipxSock != INVALID_SOCKET)
   {// IPX channel
   // check thrManager code to understand the lines below:
   SOCKET ipxSock = TaskData.ipxSock;
   WaitForSingleObject (TaskData.ipxThread, INFINITE);
   TaskData.ipxSock = INVALID_SOCKET;
   closesocket (ipxSock);
   if (TaskData.ipxThread)
      hTemp[nHandles++] = TaskData.ipxThread;
   }
// Terminate thrTrap
if (TaskData.trapThread)
   {
   if (TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_NT)
      { // NT-specific stuff
      // set events to signal thrTrap to exit
      SetEvent(TaskData.trapEvent);
      // unblock thrTrap if necessary
      SetEvent(TaskData.trapOl.hEvent); 
      }
   hTemp[nHandles++] = TaskData.trapThread;
   }
WaitForMultipleObjects (nHandles, hObjects, TRUE, 5000);
while (nHandles > 0)
   {
   nHandles--;
   CloseHandle (hTemp[nHandles]);
   }
if (TaskData.trapPipe != INVALID_HANDLE_VALUE)
   CloseHandle (TaskData.trapPipe);
if (TaskData.trapEvent != NULL)
   CloseHandle(TaskData.trapEvent);
if (TaskData.trapOl.hEvent != NULL)
   CloseHandle(TaskData.trapOl.hEvent);
if (TaskData.hExitEvent)
   CloseHandle(TaskData.hExitEvent);
   
// Do the main thing
ZeroMemory (&TaskData, sizeof(TASK));
LeaveCriticalSection (&cs_TASK);
// Close down WinSock connection
WSACleanup ();
//

//
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpCleanup

// Open a session (v1 and v2)
HSNMP_SESSION SNMPAPI_CALL SnmpOpen (IN HWND hWnd, IN UINT wMsg)
{
return (SnmpCreateSession (hWnd, wMsg, NULL, NULL));
} // end_SnmpOpen

// Open a session, w/callback option (v2)
HSNMP_SESSION SNMPAPI_CALL
   SnmpCreateSession (IN HWND hWnd, IN UINT wMsg,
                      IN SNMPAPI_CALLBACK fCallBack,
                      IN LPVOID lpClientData)
{
DWORD nSession;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPSESSION pSession;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// Check for window/message notification mode argument validity
if (fCallBack == NULL)
   if (!IsWindow(hWnd))
      {
      lError = SNMPAPI_HWND_INVALID;
      goto ERROR_OUT;
      }
//
EnterCriticalSection (&cs_SESSION);
lError = snmpAllocTableEntry(&SessDescr, &nSession);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pSession = snmpGetTableEntry(&SessDescr, nSession);

pSession->nTask        = TaskData.hTask;
pSession->hWnd         = hWnd;
pSession->wMsg         = wMsg;
pSession->fCallBack    = fCallBack;
pSession->lpClientData = lpClientData;
if (fCallBack)
   {
   DWORD thrId;
   pSession->thrEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
   if (NULL == pSession->thrEvent)
      {
      lError = SNMPAPI_ALLOC_ERROR;
      snmpFreeTableEntry(&SessDescr, nSession);
      goto ERROR_PRECHECK;
      }
   pSession->thrCount = 0;
   pSession->thrHandle = (HANDLE)_beginthreadex
      (NULL, 0, thrNotify, (LPVOID) ULongToPtr(nSession), 0, &thrId);
   if (NULL == pSession->thrHandle)
      {
      lError = SNMPAPI_TL_RESOURCE_ERROR;
      snmpFreeTableEntry(&SessDescr, nSession);
      CloseHandle(pSession->thrEvent);
      pSession->thrEvent = NULL;
      goto ERROR_PRECHECK;
      }
   }
pSession->nLastError = SNMPAPI_SUCCESS;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_SESSION);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_SESSION) ULongToPtr(nSession+1));
ERROR_OUT:
return ((HSNMP_SESSION) ULongToPtr(SaveError (0, lError)));
} // end_SnmpOpen

// SnmpClose
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpClose (IN HSNMP_SESSION hSession)
{
HANDLE thrTemp;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
DWORD nSes = HandleToUlong(hSession) - 1;
DWORD i;
LPSESSION pSession;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, nSes))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
pSession = snmpGetTableEntry(&SessDescr, nSes);

// Strategy:
// 1st:  Stop notifications to session
// 2nd:  Stop accepting new messages
//       Traps
//       Agents
// 3rd:  Clear out pending messages
// 4th:  Free up all other resources
//
// PART_1:  Stop notifications to the closing Session
// Block window/message notification (in all cases!)
pSession->hWnd = NULL;
// Block callback notification (if required)
if (pSession->fCallBack != NULL)
   {
   // Save thrHandle for WaitForSingleObject call
   EnterCriticalSection (&cs_SESSION);
   thrTemp = pSession->thrHandle;
   // If this is a callback session, must stop thrNotify instance
   pSession->thrHandle = NULL;
   // 0xFFFFFFFF signals thrNotify instance to terminate itself
   pSession->thrCount = 0xFFFFFFFF;
   // SetEvent signals thrNotify instance to run
   SetEvent (pSession->thrEvent);
   LeaveCriticalSection (&cs_SESSION);

   // Wait for termination signal from thread handle
   WaitForSingleObject (thrTemp, 30000);
   // Close thrNotify instance handle
   CloseHandle (thrTemp);
   // Close thrNotify event handle
   CloseHandle (pSession->thrEvent);
   }

// PART_2:  Stop accepting new messages for the closing Session
// Free Notifications registered by the closing Session
EnterCriticalSection (&cs_TRAP);
for (i = 0; i < TrapDescr.Allocated && TrapDescr.Used != 0; i++)
   {
   LPTRAPNOTICE pTrap = snmpGetTableEntry(&TrapDescr, i);
   if (pTrap->Session == hSession)
      FreeRegister (i);
   } // end_for (Traps)
LeaveCriticalSection (&cs_TRAP);
// Free Agents registered by the closing Session
EnterCriticalSection (&cs_AGENT);
for (i = 0; i < AgentDescr.Allocated && AgentDescr.Used != 0; i++)
   {
   LPAGENT pAgent = snmpGetTableEntry(&AgentDescr, i);
   if (pAgent->Session == hSession)
      SnmpListen (pAgent->Entity, SNMPAPI_OFF);
   }
LeaveCriticalSection (&cs_AGENT);
// PART_3:  Free all pending messages for the closing Session
EnterCriticalSection (&cs_MSG);
for (i = 0; i < MsgDescr.Allocated && MsgDescr.Used != 0; i++)
   {
   LPSNMPMSG pMsg = snmpGetTableEntry(&MsgDescr, i);
   if (pMsg->Session == hSession)
      FreeMsg (i);
   }
LeaveCriticalSection (&cs_MSG);
// PART_4:  Free all other resources
// Free Entities allocated by the closing Session
EnterCriticalSection (&cs_ENTITY);
for (i = 0; i < EntsDescr.Allocated && EntsDescr.Used != 0; i++)
   {
   LPENTITY pEntity = snmpGetTableEntry(&EntsDescr, i);
   if (pEntity->Session == hSession)
      SnmpFreeEntity ((HSNMP_ENTITY) ULongToPtr(i+1));
   }
LeaveCriticalSection (&cs_ENTITY);
// Free Contexts allocated by the closing Session
EnterCriticalSection (&cs_CONTEXT);
for (i = 0; i < CntxDescr.Allocated && CntxDescr.Used != 0; i++)
   {
   LPCTXT pCtxt = snmpGetTableEntry(&CntxDescr, i);
   if (pCtxt->Session == hSession)
      SnmpFreeContext ((HSNMP_CONTEXT) ULongToPtr(i+1));
   }
LeaveCriticalSection (&cs_CONTEXT);
// Free VBLs allocated by the closing Session
EnterCriticalSection (&cs_VBL);
for (i = 0; i < VBLsDescr.Allocated && VBLsDescr.Used != 0; i++)
   {
   LPVBLS pVbl = snmpGetTableEntry(&VBLsDescr, i);
   if (pVbl->Session == hSession)
      SnmpFreeVbl ((HSNMP_VBL) ULongToPtr(i+1));
   }
LeaveCriticalSection (&cs_VBL);
// Free PDUs allocated by the closing Session
EnterCriticalSection (&cs_PDU);

for (i = 0; i < PDUsDescr.Allocated && PDUsDescr.Used != 0; i++)
   {
   LPPDUS pPDU = snmpGetTableEntry(&PDUsDescr, i);
   if (pPDU->Session == hSession)
      SnmpFreePdu ((HSNMP_PDU) ULongToPtr(i+1));
   }

LeaveCriticalSection (&cs_PDU);
// Free the Session table entry used by the closing Session
EnterCriticalSection (&cs_SESSION);
snmpFreeTableEntry(&SessDescr, nSes);
LeaveCriticalSection (&cs_SESSION);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
// As of 19980808 there are no error cases with a valid session
return (SaveError (0, lError));
} // end_SnmpClose

// SnmpSendMsg
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSendMsg (IN HSNMP_SESSION hSession,
                IN HSNMP_ENTITY hSrc,
                IN HSNMP_ENTITY hDst,
                IN HSNMP_CONTEXT hCtx,
                IN HSNMP_PDU hPdu)
{
LPPDUS sendPdu;
BOOL fMsg;
DWORD nMsg;
DWORD pduType;
smiINT32 dllReqId;
smiOCTETS tmpContext;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
//
DWORD thrId;
SOCKET *pSock;
int tFamily;
SOCKADDR tAddr;
HANDLE *pThread;
//
DWORD nSrc;
DWORD nDst;
DWORD nCtx;
DWORD nPdu;
//
BOOL  fBroadcast;
//
LPPDUS pPdu;
LPENTITY pEntSrc, pEntDst;
LPCTXT pCtxt;
LPSNMPMSG pMsg;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }

// Save valid session for later error returns
lSession = hSession;
if (hSrc)  // Allowed to be NULL
   {
   nSrc = HandleToUlong(hSrc) - 1;
   if (!snmpValidTableEntry(&EntsDescr, nSrc))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntSrc = snmpGetTableEntry(&EntsDescr, nSrc);
   }
nDst = HandleToUlong(hDst) - 1;
if (!snmpValidTableEntry(&EntsDescr, nDst))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntDst = snmpGetTableEntry(&EntsDescr, nDst);

nCtx = HandleToUlong(hCtx) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

nPdu = HandleToUlong(hPdu) - 1;
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

if (!snmpValidTableEntry(&VBLsDescr, HandleToUlong(pPdu->VBL)-1))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
//--------------
tFamily = pEntDst->addr.inet.sin_family;

// enter the critical section for the TaskData structure to insure
// the atomicity of the Test&Set operation of the TaskData.[ip|ipx]Thread
EnterCriticalSection (&cs_TASK);

pThread = (tFamily==AF_IPX) ? &TaskData.ipxThread : &TaskData.ipThread;
pSock = (tFamily==AF_IPX) ? &TaskData.ipxSock : &TaskData.ipSock;

if (*pThread)   // ASSERT(*pSock != INVALID_SOCKET)
   {
   LeaveCriticalSection(&cs_TASK);
   goto CHANNEL_OPEN;
   }
*pSock = socket (tFamily, SOCK_DGRAM, (tFamily==AF_IPX)?NSPROTO_IPX:0);

if (*pSock == INVALID_SOCKET)
   {
   LeaveCriticalSection(&cs_TASK);
   lError = SNMPAPI_TL_NOT_SUPPORTED;
   goto ERROR_OUT;
   }

// try to set the socket for broadcasts. No matter the result
// a possible error will be caught later
// The following setsockopt call will be removed in Longhorn
fBroadcast = TRUE;
setsockopt (*pSock,
            SOL_SOCKET,
            SO_BROADCAST,
            (CHAR *) &fBroadcast,
            sizeof ( BOOL )
           );

// Kludge for Win95 WinSock/IPX bug...have to "bind"
ZeroMemory (&tAddr, sizeof(SOCKADDR));
tAddr.sa_family = (USHORT)tFamily;
bind (*pSock, &tAddr, (tFamily==AF_IPX)?sizeof(SOCKADDR_IPX):sizeof(SOCKADDR_IN));
// Start "listener" and timer threads

*pThread = (HANDLE)_beginthreadex (NULL, 0, thrManager, (LPVOID)pSock, 0, &thrId);
if (*pThread == NULL)
   {
   closesocket (*pSock);
   *pSock = INVALID_SOCKET;
   lError = SNMPAPI_TL_RESOURCE_ERROR;
   LeaveCriticalSection (&cs_TASK);
   goto ERROR_OUT;
   }
LeaveCriticalSection (&cs_TASK);
//---------------
CHANNEL_OPEN:
pduType = pPdu->type;
sendPdu = pPdu;
if (pEntDst->version == 1)
    { // Test for special v2 msg -> v1 dst operations
   if (pduType == SNMP_PDU_TRAP)
      { // RFC 2089 v2 to v1 trap conversion
      sendPdu =  MapV2TrapV1 (hPdu);
      if (sendPdu == NULL)
         {
         lError = SNMPAPI_OTHER_ERROR;
         goto ERROR_OUT;
         }
      pduType = SNMP_PDU_V1TRAP;
      }
   else if (pduType == SNMP_PDU_INFORM)
      {
      lError = SNMPAPI_OPERATION_INVALID;
      goto ERROR_OUT;
      }
   }
// Space check
EnterCriticalSection (&cs_MSG);
lError = snmpAllocTableEntry(&MsgDescr, &nMsg);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pMsg = snmpGetTableEntry(&MsgDescr, nMsg);

// Now Build it
if (pduType == SNMP_PDU_RESPONSE || pduType == SNMP_PDU_TRAP)
   dllReqId = pPdu->appReqId;
else
   dllReqId = ++(TaskData.nLastReqId);
tmpContext.len = pCtxt->commLen;
tmpContext.ptr = pCtxt->commStr;
// Save BuildMessage status for later check
fMsg = BuildMessage (pEntDst->version-1, &tmpContext, sendPdu,
       dllReqId, &(pMsg->Addr), &(pMsg->Size));
// If v2 to v1 trap conversion was required, then cleanup...
if (pduType == SNMP_PDU_V1TRAP)
   {
   FreeVarBindList (sendPdu->VBL_addr);   // Checks for NULL
   FreeV1Trap (sendPdu->v1Trap);          // Checks for NULL
   GlobalFree (sendPdu);
   }
// If BuildMessage failed, that's all folks!
if (!fMsg)
   {
   snmpFreeTableEntry(&MsgDescr, nMsg);
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_PRECHECK;
   }
pMsg->Session = hSession;
pMsg->Status = NP_SEND;  // "send"
pMsg->Type = pduType;
pMsg->nRetransmitMode = TaskData.nRetransmitMode;
pMsg->dllReqId = dllReqId;
pMsg->appReqId = pPdu->appReqId;
pMsg->agentEntity = hDst;
pMsg->ourEntity   = hSrc;
pMsg->Context     = hCtx;
LeaveCriticalSection (&cs_MSG);
// Update reference counts for entities and contexts,
EnterCriticalSection (&cs_ENTITY);
if (hSrc)
   pEntSrc->refCount++;
pEntDst->refCount++;
LeaveCriticalSection (&cs_ENTITY);
EnterCriticalSection (&cs_CONTEXT);
pCtxt->refCount++;
LeaveCriticalSection (&cs_CONTEXT);
// Prepare addressing info for traps
EnterCriticalSection (&cs_MSG);
CopyMemory (&(pMsg->Host), &pEntDst->addr, sizeof(SAS));
if (pduType == SNMP_PDU_V1TRAP ||
    pduType == SNMP_PDU_TRAP ||
    pduType == SNMP_PDU_INFORM)
   {
   if (tFamily == AF_IPX)
      {
      if (pMsg->Host.ipx.sa_socket == ntohs (IPX_SNMP_PORT))
         pMsg->Host.ipx.sa_socket = htons (IPX_TRAP_PORT);
      }
   else // Assume AF_INET
      {
      if (pMsg->Host.inet.sin_port == ntohs (IP_SNMP_PORT))
         pMsg->Host.inet.sin_port = htons(IP_TRAP_PORT);
      }
   }
// Send the packet
thrId = sendto (*pSock, pMsg->Addr, pMsg->Size,
                0, (LPSOCKADDR)&(pMsg->Host), sizeof(SAS));
if (thrId == SOCKET_ERROR)
   {
   FreeMsg (nMsg);
   lError = SNMPAPI_TL_OTHER;
   goto ERROR_PRECHECK;
   }
// Need to check for SOCKET_ERROR!
if (pduType == SNMP_PDU_TRAP ||
    pduType == SNMP_PDU_V1TRAP ||
    pduType == SNMP_PDU_RESPONSE)
   {
   FreeMsg (nMsg);
   }
else
   {
   pMsg->Status = NP_SENT;
   // Time entity's timeout value is stored as centiseconds in 32 bits
   pMsg->Wait   = pEntDst->nPolicyTimeout;
   // Converting to milliseconds for timer operations could overflow
   if (pMsg->Wait <= MAXCENTISECONDS)  // So check first...if ok
      pMsg->Wait *= 10;                // Convert to milliseconds
   else                                         // eles...
      pMsg->Wait = MAXMILLISECONDS;    // Set to max milliseconds
   pMsg->Tries  = pMsg->PolicyTries = pEntDst->nPolicyRetry;
   pMsg->Ticks  = GetTickCount();
   }
ERROR_PRECHECK:
LeaveCriticalSection (&cs_MSG);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpSendMsg

// SnmpRecvMsg
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpRecvMsg (IN HSNMP_SESSION hSession,
                OUT LPHSNMP_ENTITY srcEntity,
                OUT LPHSNMP_ENTITY dstEntity,
                OUT LPHSNMP_CONTEXT context,
                OUT LPHSNMP_PDU pdu)
{
DWORD nMsg;
DWORD nPdu;
int pduType;
smiLPOCTETS community;
smiUINT32 version;
smiUINT32 nMode;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
DWORD nSes = HandleToUlong(hSession) - 1;
LPPDUS pPdu;
LPENTITY pEntity;
LPSNMPMSG pMsg;
DWORD lTime; // holds the local time for updating the nActualTimeout value

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, nSes))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// Valid session...save for possible error return
lSession = hSession;

EnterCriticalSection (&cs_MSG);
// Find a message for the calling session
for (nMsg = 0; nMsg < MsgDescr.Allocated; nMsg++)
   {
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
   if (pMsg->Session == hSession &&
       pMsg->Status == NP_READY)
      break;
   }
if (nMsg == MsgDescr.Allocated)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_PRECHECK1;
   }
if (!pMsg->Addr)
   {
   lError = SNMPAPI_MESSAGE_INVALID;
   goto ERROR_PRECHECK1;
   }
ERROR_PRECHECK1:
LeaveCriticalSection (&cs_MSG);

if (lError != SNMPAPI_SUCCESS)
   goto ERROR_OUT;

// Allocate a slot in PDU table
EnterCriticalSection (&cs_PDU);
lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK2;
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

nMode = ParseMessage (pMsg->Addr, pMsg->Size,
                      &version, &community, pPdu);
if (nMode != 0) // non-zero = error code
   {
   snmpFreeTableEntry(&PDUsDescr, nPdu);
   FreeMsg (nMsg);
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_PRECHECK2;
   }
pPdu->Session  = hSession;
pPdu->appReqId = pMsg->appReqId;
ERROR_PRECHECK2:
LeaveCriticalSection (&cs_PDU);

if (lError != SNMPAPI_SUCCESS)
   goto ERROR_OUT;
pduType = pPdu->type;

EnterCriticalSection (&cs_ENTITY);
// for RESPONSE messages only, update the 'ActualRetry' and 'ActualTimeout' parameters
// for all the other messages, these params are meaningless
if (pduType == SNMP_PDU_RESPONSE)
{
    // locate the agent (source) entity here
    pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);

    // update the nActualTimeout param of the agent (source) entity.
    lTime = GetTickCount();
    if (pMsg->Ticks > lTime)
        // handle the time wrap case
        // (~pMsg->Ticks + 1) is 2's complement of pMsg->Ticks
        pEntity->nActualTimeout = (lTime + ~pMsg->Ticks + 1)/10;
    else
        pEntity->nActualTimeout = (lTime - pMsg->Ticks)/10;

    // update the nActualRetry param of the agent (source) entity
    pEntity->nActualRetry = pMsg->PolicyTries - pMsg->Tries;
}

if (srcEntity)
   {
    if (pduType == SNMP_PDU_TRAP ||
       pduType == SNMP_PDU_INFORM ||
       pduType != SNMP_PDU_RESPONSE)
      {
      int afType = pMsg->Host.ipx.sa_family;
      char afHost[MAX_PATH+1];
      afHost[MAX_PATH] = '\0';
      EnterCriticalSection (&cs_XMODE);
      SnmpGetTranslateMode (&nMode);
      SnmpSetTranslateMode (SNMPAPI_UNTRANSLATED_V1);
      if (afType == AF_IPX)
         SnmpIpxAddressToStr (pMsg->Host.ipx.sa_netnum,
                              pMsg->Host.ipx.sa_nodenum,
                              afHost);
      else // AF_INET
         {
         char * pszIpAddr;
         pszIpAddr = inet_ntoa (pMsg->Host.inet.sin_addr);
         if (NULL == pszIpAddr)
            { 
            LeaveCriticalSection (&cs_XMODE);
            lError = SNMPAPI_TL_OTHER;
            goto ERROR_PRECHECK3;
            }
         strncpy (afHost, pszIpAddr, MAX_PATH);
         }
      if ((pMsg->agentEntity = SnmpStrToEntity (hSession, afHost)) == SNMPAPI_FAILURE)
         {
          LeaveCriticalSection (&cs_XMODE);
          lError = SNMPAPI_OTHER_ERROR;
          goto ERROR_PRECHECK3;
         }
      pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);
      if (afType == AF_IPX)
         pEntity->addr.ipx.sa_socket = pMsg->Host.ipx.sa_socket;
      else // AF_INET
         pEntity->addr.inet.sin_port = pMsg->Host.inet.sin_port;
      SnmpSetTranslateMode (nMode);
      LeaveCriticalSection (&cs_XMODE);
      }
   // Deliberate assignment...
   if (*srcEntity = pMsg->agentEntity)
      {
      pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);
      pEntity->refCount++;
      }
   }

if (dstEntity)
   { // Deliberate assignment...
   if (*dstEntity = pMsg->ourEntity)
      {
      pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->ourEntity)-1);
      pEntity->refCount++;
      }
   }
ERROR_PRECHECK3:
LeaveCriticalSection (&cs_ENTITY);
if (lError != SNMPAPI_SUCCESS)
   {
   FreeOctetString (community);
   SnmpFreePdu ((HSNMP_PDU) ULongToPtr(nPdu+1));
   FreeMsg (nMsg);
   goto ERROR_OUT;
   }

EnterCriticalSection (&cs_CONTEXT);
if (context)
   {
   if (pduType == SNMP_PDU_TRAP ||
       pduType == SNMP_PDU_INFORM ||
       pduType != SNMP_PDU_RESPONSE)
      {
      EnterCriticalSection (&cs_XMODE);
      SnmpGetTranslateMode (&nMode);
      SnmpSetTranslateMode (SNMPAPI_UNTRANSLATED_V1);
      if ((pMsg->Context = SnmpStrToContext (hSession, community)) == SNMPAPI_FAILURE)
         {
         LeaveCriticalSection (&cs_XMODE);
         lError = SNMPAPI_OTHER_ERROR;
         goto ERROR_PRECHECK4;
         }
      SnmpSetTranslateMode (nMode);
      LeaveCriticalSection (&cs_XMODE);
      }
   // Deliberate assignment...
   if (*context = pMsg->Context)
      ((LPCTXT)snmpGetTableEntry(&CntxDescr, HandleToUlong(pMsg->Context)-1))->refCount++;
   }
ERROR_PRECHECK4:
LeaveCriticalSection (&cs_CONTEXT);
if (lError != SNMPAPI_SUCCESS)
   {
   // rollback
   if (context && *context)
      {
      SnmpFreeContext(*context);
      *context = NULL;
      }
   if (dstEntity && *dstEntity)
      {
      SnmpFreeEntity(*dstEntity);
      *dstEntity = NULL;
      }
   if (srcEntity && *srcEntity)
      {
      SnmpFreeEntity(*srcEntity);
      *srcEntity = NULL;
      }
   FreeOctetString (community);
   SnmpFreePdu ((HSNMP_PDU) ULongToPtr(nPdu+1));
   FreeMsg (nMsg);
   goto ERROR_OUT;
   }

FreeOctetString (community);
if (pdu)
   *pdu = (HSNMP_PDU) ULongToPtr(nPdu+1);
else
   SnmpFreePdu ((HSNMP_PDU) ULongToPtr(nPdu+1));
// Mark SendRecv slot as free
FreeMsg (nMsg);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpRecvMsg

// Allocates a generic ACL to be used for the security descriptor of the SNMPTRAP service
PACL AllocGenericACL()
{
    PACL                        pAcl;
    PSID                        pSidAdmins, pSidUsers;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;
    DWORD                       dwAclLength;

    pSidAdmins = pSidUsers = NULL;

    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ) )
    {
        return NULL;
    }

    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidUsers ))
    {
        FreeSid(pSidAdmins);
        return NULL;
    }

    dwAclLength = sizeof(ACL) + 
                  sizeof(ACCESS_ALLOWED_ACE) -
                  sizeof(ULONG) +
                  GetLengthSid(pSidAdmins) +
                  sizeof(ACCESS_ALLOWED_ACE) - 
                  sizeof(ULONG) +
                  GetLengthSid(pSidUsers);

    pAcl = GlobalAlloc (GPTR, dwAclLength);
    if (pAcl != NULL)
    {
        if (!InitializeAcl( pAcl, dwAclLength, ACL_REVISION) ||
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   pSidAdmins ) || 
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_READ | GENERIC_EXECUTE,
                                   pSidUsers ))
        {
            GlobalFree(pAcl);
            pAcl = NULL;
        }
    }

    FreeSid(pSidAdmins);
    FreeSid(pSidUsers);

    return pAcl;
}

// frees a generic ACL
void FreeGenericACL( PACL pAcl)
{
    if (pAcl != NULL)
        GlobalFree(pAcl);
}

// SnmpRegister
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpRegister (IN HSNMP_SESSION hSession,
                 IN HSNMP_ENTITY hSrc,
                 IN HSNMP_ENTITY hDst,
                 IN HSNMP_CONTEXT hCtx,
                 IN smiLPCOID notification,
                 IN smiUINT32 status)
{
DWORD nNotice, nFound;
smiINT32 nCmp;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
DWORD nSes = HandleToUlong(hSession) - 1;
DWORD nSrc;
DWORD nDst;
DWORD nCtx;
LPENTITY pEntSrc, pEntDst;
LPCTXT pCtxt;
LPTRAPNOTICE pTrap;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (status != SNMPAPI_OFF) status = SNMPAPI_ON;
if (status == SNMPAPI_ON)
   {
   if (!snmpValidTableEntry(&SessDescr, nSes))
      {
      lError = SNMPAPI_SESSION_INVALID;
      goto ERROR_OUT;
      }
   else // Got a valid session...save for possible error return
      lSession = hSession;
   }
if (hSrc)
   {
   nSrc = HandleToUlong(hSrc) - 1;
   if (!snmpValidTableEntry(&EntsDescr, nSrc))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntSrc = snmpGetTableEntry(&EntsDescr, nSrc);
   }
if (hDst)
   {
   nDst = HandleToUlong(hDst) - 1;
   if (!snmpValidTableEntry(&EntsDescr, nDst))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntDst = snmpGetTableEntry(&EntsDescr, nDst);
   }
if (hCtx)
   {
   nCtx = HandleToUlong(hCtx) - 1;
   if (!snmpValidTableEntry(&CntxDescr, nCtx))
      {
      lError = SNMPAPI_CONTEXT_INVALID;
      goto ERROR_OUT;
      }
   pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);
   }
if (notification)
   {
   if ((!notification->len) || notification->len > MAXOBJIDSIZE)
      {
      lError = SNMPAPI_SIZE_INVALID;
      goto ERROR_OUT;
      }
   if (!notification->ptr)
      {
      lError = SNMPAPI_OID_INVALID;
      goto ERROR_OUT;
      }
   }
EnterCriticalSection (&cs_TRAP);
for (nNotice = 0, nFound = 0; nNotice < TrapDescr.Allocated &&
                              nFound < TrapDescr.Used; nNotice++)
   { // First, count now many we've tested
   pTrap = snmpGetTableEntry(&TrapDescr, nNotice);
   if (pTrap->Session) nFound++;
   // then search for a parameter matches
   if ((pTrap->Session == hSession) &&
       (pTrap->ourEntity == hSrc) &&
       (pTrap->agentEntity == hDst) &&
       (pTrap->Context == hCtx))
      { // Ok, we found one
      if (!notification)
         // if the notification parameter is null, then we
         // want to either turn on or turn off all notifications
         // from this match...so clear any entries already in
         // the table and we'll add this wildcard entry if the
         // operation is SNMPAPI_ON at the end.
         {
         DWORD dwUsed = TrapDescr.Used;
         FreeRegister (nNotice);
         if (dwUsed == TrapDescr.Used+1)
            {
            // Adjustment to nFound because FreeRegister has just decremented 
            // TrapDescr.Used by 1
            nFound--;
            }
         continue;
         }
      else // notification specified
         {
         if (!pTrap->notification.len)
            {
            // Redundant request (already wildcarded)
            // Skip it and return!
            goto ERROR_PRECHECK;
            }
         else // pTrap->notification
            {
            // compare OIDs
            SnmpOidCompare (notification, &(pTrap->notification),
                            0, &nCmp);
            if (nCmp)      // no match
               continue;   // ...try the next one
            else // !nCcmp
               { // got a match...
               // if SNMPAPI_ON, redundant request...skip it and return
               // if SNMPAPI_OFF, free the entry first
               if (status != SNMPAPI_ON)
                  FreeRegister (nNotice); // SNMPAPI_OFF
               goto ERROR_PRECHECK;
               } // end_else_!nCmp
            } // end_else_TrapTable[nNotice].notificatin
         } // end_else_notification_specified
      } // end_if_we_found_one
   } // end_for
if (status == SNMPAPI_OFF)
   { // Found nothing to turn off...that's ok.
   goto ERROR_PRECHECK;
   }
//

// Special check for NT...is SNMPTRAP service running?
if (TaskData.trapThread == NULL &&
    TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_NT)
   {
   DWORD   dwReturn  = SNMPAPI_TL_NOT_INITIALIZED;
   DWORD   pMode     = PIPE_WAIT | PIPE_READMODE_MESSAGE;
   LPCTSTR svcName   = "SNMPTRAP";
   LPCTSTR svcDesc   = "SNMP Trap Service";
   LPCTSTR svcPath   = "%SystemRoot%\\system32\\snmptrap.exe";
   SC_HANDLE scmHandle = NULL;
   SC_HANDLE svcHandle = NULL;
   SERVICE_STATUS svcStatus;
   BOOL fStatus;
   // Minimal SCM connection, for case when SNMPTRAP is running
   scmHandle = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
   if (scmHandle == NULL)
      goto DONE_SC;
   svcHandle = OpenService (scmHandle, svcName, SERVICE_QUERY_STATUS);
   if (svcHandle == NULL)
      {
      if (GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST)
         goto DONE_SC;
      else
         { // Must attempt to create service
         PACL pAcl;
         SECURITY_DESCRIPTOR S_Desc;
         // Need new scmHandle with admin priv
         CloseServiceHandle (scmHandle);
         scmHandle = OpenSCManager (NULL, NULL, SC_MANAGER_CREATE_SERVICE);
         if (scmHandle == NULL)
            goto DONE_SC; // Could not open SCM with admin priv
         // Bug# 179644 The SNMP trap service should not run in the LocalSystem account
         // We create the service with LocalService account instead of LocalSystem.
         svcHandle = CreateService (scmHandle, svcName, svcDesc,
                                    WRITE_DAC|SERVICE_QUERY_STATUS,
                                    SERVICE_WIN32_OWN_PROCESS,
                                    SERVICE_DEMAND_START,
                                    SERVICE_ERROR_NORMAL,
                                    svcPath,
                                    NULL, NULL,
                                    "TCPIP\0EventLog\0\0",
                                    "NT AUTHORITY\\LocalService", NULL);
         if (svcHandle == NULL)
            goto DONE_SC; // Could not create service
         if (!InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION))
            {
            goto DONE_SC;
            }
         if ((pAcl = AllocGenericACL()) == NULL ||
             !SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
            {
            FreeGenericACL(pAcl); // will free if necessary
            goto DONE_SC;
            }
         if (!SetServiceObjectSecurity (svcHandle, DACL_SECURITY_INFORMATION, &S_Desc))
            {
            FreeGenericACL(pAcl);
            goto DONE_SC;
            }
         FreeGenericACL(pAcl);
         }
      }
   fStatus = QueryServiceStatus (svcHandle, &svcStatus);
   while (fStatus)
      {
      switch (svcStatus.dwCurrentState)
         {
         case SERVICE_RUNNING:
         dwReturn = SNMPAPI_SUCCESS;
         goto DONE_SC;

         case SERVICE_STOPPED:
         // Start SNMPTRAP service if necessary
         CloseServiceHandle (svcHandle);
         svcHandle = OpenService (scmHandle, svcName, SERVICE_START|SERVICE_QUERY_STATUS);
         if (svcHandle == NULL)
            goto DONE_SC; // Could not start service
         svcStatus.dwCurrentState = SERVICE_START_PENDING;
         fStatus = StartService (svcHandle, 0, NULL);
         break;

         case SERVICE_STOP_PENDING:
         case SERVICE_START_PENDING:
         Sleep (MAX_PENDING_WAIT);
         fStatus = QueryServiceStatus (svcHandle, &svcStatus);
         break;

         case SERVICE_PAUSED:
         case SERVICE_PAUSE_PENDING:
         case SERVICE_CONTINUE_PENDING:
         default:
         fStatus = FALSE;  // Nothing to do about these
         break;
         }
      }
DONE_SC:
   if (scmHandle)
      CloseServiceHandle (scmHandle);
   if (svcHandle)
      CloseServiceHandle (svcHandle);
   if (dwReturn != SNMPAPI_SUCCESS)
      {
ERROR_PRECHECK1:
      lError = dwReturn;
      goto ERROR_PRECHECK;
      }
   // Setup for pipe-oriented operations
   dwReturn = SNMPAPI_TL_RESOURCE_ERROR;
   // block on instance of server pipe becoming available
   if (!WaitNamedPipe (SNMPTRAPPIPE, TRAPSERVERTIMEOUT))
      goto ERROR_PRECHECK1;
   TaskData.trapPipe =
      // Bug# 270672 Change FILE_ATTRIBUTE_NORMAL to FILE_FLAG_OVERLAPPED
      CreateFile (SNMPTRAPPIPE, GENERIC_READ|GENERIC_WRITE,
                  FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                  OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL); 
   if (TaskData.trapPipe == INVALID_HANDLE_VALUE)
      goto ERROR_PRECHECK1;
   if (!SetNamedPipeHandleState (TaskData.trapPipe, &pMode, NULL, NULL))
      {
      CloseHandle (TaskData.trapPipe);
      TaskData.trapPipe = INVALID_HANDLE_VALUE;
      goto ERROR_PRECHECK1;
      }
   } // end_NT check for SNMPTRAP service

//If we got this far, add it
lError = snmpAllocTableEntry(&TrapDescr, &nNotice);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pTrap = snmpGetTableEntry(&TrapDescr, nNotice);

// add it
pTrap->Session = hSession;
// Deliberate assignments in next three if statements
if (pTrap->ourEntity = hSrc)
   //EntityTable[nSrc-1].refCount++; -- was this a bug??? nSrc is already 0 based
    pEntSrc->refCount++;
if (pTrap->agentEntity = hDst)
   //EntityTable[nDst-1].refCount++; -- was this a bug??? nDst is already 0 based
    pEntDst->refCount++;
if (pTrap->Context = hCtx)
   //ContextTable[nCtx-1].refCount++; -- was this a bug?? nCtx is already 0 based
   pCtxt->refCount++;
if (notification)
   { // Reproduce the OID
   pTrap->notification.ptr = NULL;
   // Deliberate assignment in next statement
   if (pTrap->notification.len = notification->len)
      {
      if (pTrap->notification.len > MAXTRAPIDS)
         pTrap->notification.len = MAXTRAPIDS;
      if (notification->ptr)
         {
         // Deliberate assignment in next statement
         pTrap->notification.ptr = &(pTrap->notificationValue[0]);
         CopyMemory (pTrap->notification.ptr, notification->ptr,
                     pTrap->notification.len * sizeof(smiUINT32));
         }
      }
   }
if (TaskData.trapThread == NULL)
   {
   DWORD thrId;
   TaskData.trapThread = (HANDLE)_beginthreadex (NULL, 0, thrTrap, NULL, 0, &thrId);
   if (TaskData.trapThread == NULL)
      {
      FreeRegister(nNotice);
      lError = SNMPAPI_TL_RESOURCE_ERROR;
      }
   }
ERROR_PRECHECK:
LeaveCriticalSection (&cs_TRAP);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpRegister

void FreeMsg (DWORD nMsg)
{
LPSNMPMSG pMsg;
EnterCriticalSection (&cs_MSG);
// Decrement reference counts
pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
SnmpFreeEntity (pMsg->agentEntity);
SnmpFreeEntity (pMsg->ourEntity);
SnmpFreeContext (pMsg->Context);
if (pMsg->Addr)
   GlobalFree (pMsg->Addr);
snmpFreeTableEntry(&MsgDescr, nMsg);
LeaveCriticalSection (&cs_MSG);
return;
} // end_FreeMsg

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpListen (IN HSNMP_ENTITY hEntity,
               IN smiUINT32 status)
{
smiUINT32 nAgent = 0;
DWORD thrId;
DWORD nEntity = HandleToUlong(hEntity) - 1;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPENTITY pEntity;
LPAGENT pAgent;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
lSession = pEntity->Session;
if (status != SNMPAPI_ON && status != SNMPAPI_OFF)
   {
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_ENTITY);
EnterCriticalSection (&cs_AGENT);
if (status)
   { // status == SNMPAPI_ON
   int nProto = IPPROTO_UDP;
   int nSize = sizeof(SOCKADDR_IN);
   int nFamily = pEntity->addr.inet.sin_family;
   if (pEntity->Agent)
      { // Entity already running as agent
      lError = SNMPAPI_NOOP;
      goto ERROR_PRECHECK;
      }
   // Allocate a slot in AGENT table
   lError = snmpAllocTableEntry(&AgentDescr, &nAgent);
   if (lError != SNMPAPI_SUCCESS)
       goto ERROR_PRECHECK;
   pAgent = snmpGetTableEntry(&AgentDescr, nAgent);

// Agent table entry allocated...setup for agent thread
   if (nFamily == AF_IPX)
      {
      nProto = NSPROTO_IPX;
      nSize = sizeof(SOCKADDR_IPX);
      }
   pAgent->Socket = socket (nFamily, SOCK_DGRAM, nProto);
   if (pAgent->Socket == INVALID_SOCKET)
      {
      snmpFreeTableEntry(&AgentDescr, nAgent);
      lError = SNMPAPI_TL_RESOURCE_ERROR;
      goto ERROR_PRECHECK;
      }
   if (bind (pAgent->Socket,
            (LPSOCKADDR)&pEntity->addr, nSize)
      == SOCKET_ERROR)
      {
      closesocket (pAgent->Socket);
      snmpFreeTableEntry(&AgentDescr, nAgent);
      lError = SNMPAPI_TL_OTHER;
      goto ERROR_PRECHECK;
      }
   // Make Entity and Agent point to each other
   pEntity->Agent = nAgent + 1;
   pAgent->Entity = hEntity;
   pAgent->Session = lSession;
   // Create agent thread...needs error checking
   pAgent->Thread = (HANDLE)_beginthreadex (NULL, 0, thrAgent, (LPVOID) ULongToPtr(nAgent), 0, &thrId);
   if (pAgent->Thread == NULL)
      {
      closesocket(pAgent->Socket);
      snmpFreeTableEntry(&AgentDescr, nAgent);
      lError = SNMPAPI_TL_RESOURCE_ERROR;
      goto ERROR_PRECHECK;
      }
   } // end_if status == SNMPAPI_ON
else
   { // status == SNMPAPI_OFF
   if (!pEntity->Agent)
      { // Entity not running as agent
      lError = SNMPAPI_NOOP;
      goto ERROR_PRECHECK;
      }
   // Entity is running as agent
   nAgent = pEntity->Agent - 1;
   pAgent = snmpGetTableEntry(&AgentDescr, nAgent);
   closesocket (pAgent->Socket);
   WaitForSingleObject (pAgent->Thread, INFINITE);
   CloseHandle (pAgent->Thread);
   snmpFreeTableEntry(&AgentDescr, nAgent);
   // Must terminate entity's agent status
   pEntity->Agent = 0;
   // Must terminate entity if nothing else was using it
   if (pEntity->refCount == 0)
      SnmpFreeEntity (hEntity);
   } // end_else status == SNMPAPI_OFF
ERROR_PRECHECK:
LeaveCriticalSection (&cs_AGENT);
LeaveCriticalSection (&cs_ENTITY);
ERROR_OUT:
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
else
   return (SaveError (lSession, lError));
} // end_SnmpListen()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpCancelMsg (HSNMP_SESSION hSession, smiINT32 nReqID)
{
DWORD nMsg = 0;
DWORD nFound = 0;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPSNMPMSG pMsg;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession;
EnterCriticalSection (&cs_MSG);

while (nFound < MsgDescr.Used && nMsg < MsgDescr.Allocated)
   {
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
   // Deliberate assignement in next conditional
   if (pMsg->Session)
      {
      nFound++;
      if (pMsg->Session == hSession)
         {
         if (pMsg->Status == NP_SENT &&
             pMsg->appReqId == (smiUINT32)nReqID)
            {
            FreeMsg (nMsg);
            goto ERROR_PRECHECK;
            }
         }
      }
   nMsg++;
   }
// Falied to find a MSG that matched the request
lError = SNMPAPI_PDU_INVALID;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_MSG);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
// else...failure case
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpCancelMsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_ma.c ===
// wsnmp_ma.c
//
// WinSNMP Initialization Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 970310 - Free table memory on PROCESS_DETACH
//        - Refine snmpAllocTable() code
// 970417 - GetVersionEx added to check for
//        - NT vs 95 and adjust code accordingly
//
#include "winsnmp.h"
#include "winsnmpn.h"
// Memory descriptors
SNMPTD   SessDescr;
SNMPTD   PDUsDescr;
SNMPTD   VBLsDescr;
SNMPTD   EntsDescr;
SNMPTD   CntxDescr;
SNMPTD   MsgDescr;
SNMPTD   TrapDescr;
SNMPTD   AgentDescr;

TASK     TaskData;

CRITICAL_SECTION cs_TASK;
CRITICAL_SECTION cs_SESSION;
CRITICAL_SECTION cs_PDU;
CRITICAL_SECTION cs_VBL;
CRITICAL_SECTION cs_ENTITY;
CRITICAL_SECTION cs_CONTEXT;
CRITICAL_SECTION cs_MSG;
CRITICAL_SECTION cs_TRAP;
CRITICAL_SECTION cs_AGENT;
CRITICAL_SECTION cs_XMODE;

//-----------------------------------------------------------------
// snmpAllocTable - This function is used to initialize and to increase
// the size of WinSNMP internal tables. The caller must always ensure
// that this function is executed only within a critical section block
// on the target table's CRITICAL_SECTION object.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpAllocTable (LPSNMPTD pTableDescr)

{
    LPVOID ptr;
    DWORD nLen;
    SNMPAPI_STATUS lResult = SNMPAPI_FAILURE;

    LPSNMPBD pBufDescr;

    // allocate a buffer large enough for the SNMPBD header plus the space
    // needed to hold 'BlockToAdd' blocks of size 'BlockSize' each.
    // the memory is already zero-ed because of the GPTR flag.
    pBufDescr = GlobalAlloc(GPTR, sizeof(SNMPBD) + (pTableDescr->BlockSize * pTableDescr->BlocksToAdd));
    if (pBufDescr == NULL)
        return SNMPAPI_FAILURE;

    // see if other buffers are present in the table
    if (pTableDescr->Allocated == 0)
    {
        // no blocks previously allocated => pTableDescr->Buffer = NULL at this point
        // pNewBufDescr is the first buffer in the table.
        pBufDescr->next = pBufDescr->prev = pBufDescr;
        pTableDescr->HeadBuffer = pBufDescr;
    }
    else
    {
        // there is at least one other block into the table, so insert the
        // new buffer into the circular list, just before the head of the list
        pBufDescr->next = pTableDescr->HeadBuffer;
        pBufDescr->prev = pTableDescr->HeadBuffer->prev;
        pBufDescr->next->prev = pBufDescr;
        pBufDescr->prev->next = pBufDescr;
    }

    // increase 'Allocated' with the additional 'BlocksToAdd' newly allocated entries.
    pTableDescr->Allocated += pTableDescr->BlocksToAdd;
    
    return SNMPAPI_SUCCESS;
}

//-----------------------------------------------------------------
// snmpInitTableDescr - initializes the table descriptor with the 
// parameters given as arguments. Creates a first chunck of table.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpInitTableDescr(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwBlocksToAdd, /*in*/DWORD dwBlockSize)
{
	ZeroMemory (pTableDescr, sizeof(SNMPTD));
	pTableDescr->BlocksToAdd = dwBlocksToAdd;
	pTableDescr->BlockSize = dwBlockSize;

	return snmpAllocTable (pTableDescr);
}

//-----------------------------------------------------------------
// snmpFreeTableDescr - releases any memory allocated for the table.
//-----------------------------------------------------------------
VOID snmpFreeTableDescr(/*in*/LPSNMPTD pTableDescr)
{
    // do nothing if the table does not contain any entries
	if (pTableDescr->HeadBuffer == NULL)
        return;

    // break the circular list by setting the 'next' of
    // the buffer before the head to NULL
    pTableDescr->HeadBuffer->prev->next = NULL;

    while (pTableDescr->HeadBuffer != NULL)
    {
        LPSNMPBD pBufDescr;

        pBufDescr = pTableDescr->HeadBuffer;
        pTableDescr->HeadBuffer = pBufDescr->next;
        GlobalFree(pBufDescr);
    }
}

//-----------------------------------------------------------------
// snmpAllocTableEntry - finds an empty slot in the table described
// by pTableDescr, and returns its index. If none could be 
// found, table is extended in order to get some new empty slots.
// It is not an API call so it doesn't check its parameters.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpAllocTableEntry(/*in*/LPSNMPTD pTableDescr, /*out*/LPDWORD pdwIndex)
{
     // check if there are any empty entries into the table ..
    if (pTableDescr->Allocated == pTableDescr->Used)
    {
        // .. if not, enlarge the table ..
        if (!snmpAllocTable (pTableDescr))
            return SNMPAPI_ALLOC_ERROR;
        // .. and return the first empty slot
        *pdwIndex = pTableDescr->Used;

        // don't forget to update the 'Used' fields. The first one markes a new entry in use
        // in the buffer, the second one marks a new entry in use in the table as a whole
        (pTableDescr->HeadBuffer->prev->Used)++;
        pTableDescr->Used++;
    }
    else
    {
        DWORD dwBufferIndex, dwInBufferIndex;
        LPSNMPBD pBufDescr;
        LPBYTE pTblEntry; // cursor on the entries in the table

        // scan the list of buffers searching for the buffer that
        // holds at least one available entry.
        for (pBufDescr = pTableDescr->HeadBuffer, dwBufferIndex=0;
             pBufDescr->Used >= pTableDescr->BlocksToAdd;
             pBufDescr = pBufDescr->next, dwBufferIndex++)
        {
             // just a precaution: make sure we are not looping infinitely here
             // this shouldn't happen as far as 'Allocated' and 'Used' say there
             // are available entries, hence at least a buffer should match
             if (pBufDescr->next == pTableDescr->HeadBuffer)
                 return SNMPAPI_OTHER_ERROR;
        }

        // now that we have the buffer with available entries,
        // search in it for the first one available.
        for ( pTblEntry = (LPBYTE)pBufDescr + sizeof(SNMPBD), dwInBufferIndex = 0;
              dwInBufferIndex < pTableDescr->BlocksToAdd;
              dwInBufferIndex++, pTblEntry += pTableDescr->BlockSize)
        {
              // an empty slot into the table has the first field = (HSNMP_SESSION)0
              if (*(HSNMP_SESSION *)pTblEntry == 0)
                  break;
        }

        // make sure the buffer is not corrupted (it is so if 'Used' shows at
        // least an entry being available, but none seems to be so)
        if (dwInBufferIndex == pTableDescr->BlocksToAdd)
            return SNMPAPI_OTHER_ERROR;

        // don't forget to update the 'Used' fields. The first one markes a new entry in use
        // in the buffer, the second one marks a new entry in use in the table as a whole
        pBufDescr->Used++;
        pTableDescr->Used++;

        // we have the index of the buffer that contains the available entry
        // and the index of that entry inside the buffer. So just compute
        // the overall index and get out.
        (*pdwIndex) = dwBufferIndex * pTableDescr->BlocksToAdd + dwInBufferIndex;
    }

    return SNMPAPI_SUCCESS;
}

//-----------------------------------------------------------------
// snmpFreeTableEntry - releases the entry at index dwIndex from the
// table described by pTableDescr. It checks the validity of the index
// and returns SNMPAPI_INDEX_INVALID if it is not in the range of the
// allocated entries. It does not actually frees the memory, it cleares
// it up and adjusts internal counters.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpFreeTableEntry(/*in*/LPSNMPTD pTableDescr, /*out*/DWORD dwIndex)
{
    LPSNMPBD pBufDescr;
    LPBYTE pTableEntry;

    if (dwIndex >= pTableDescr->Allocated)
        return SNMPAPI_INDEX_INVALID;

    // scan for the buffer that holds the entry at index dwIndex
    for (pBufDescr = pTableDescr->HeadBuffer;
         dwIndex >= pTableDescr->BlocksToAdd;
         pBufDescr = pBufDescr->next, dwIndex -= pTableDescr->BlocksToAdd);

    // we have the buffer, get the actual pointer to the entry
    pTableEntry = (LPBYTE)pBufDescr + sizeof(SNMPBD);
    pTableEntry += dwIndex * pTableDescr->BlockSize;

    // zero the entry - having the first HSNMP_SESSION field set to 0
    // makes this entry available for further allocations
    ZeroMemory (pTableEntry, pTableDescr->BlockSize);

    // update the 'Used' fields to show that one entry less is in use
    if (pBufDescr->Used > 0)
        (pBufDescr->Used)--;
    if (pTableDescr->Used > 0)
        (pTableDescr->Used)--;

    return SNMPAPI_SUCCESS;
}

//-----------------------------------------------------------------
// snmpGetTableEntry - takes as arguments a table description (pTableDescr)
// and the zero based index (dwIndex) of the entry requested from the table
// and returns in pointer to the entry requested.
//-----------------------------------------------------------------
PVOID snmpGetTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex)
{
    LPSNMPBD pBufDescr;
    LPBYTE pTableEntry;

    // this is an internal API, we make the assumption the index is correct
    // scan for the buffer that holds the entry at index dwIndex
    for (pBufDescr = pTableDescr->HeadBuffer;
         dwIndex >= pTableDescr->BlocksToAdd;
         pBufDescr = pBufDescr->next, dwIndex -= pTableDescr->BlocksToAdd);

    // we have the buffer, get the actual pointer to the entry
    pTableEntry = (LPBYTE)pBufDescr + sizeof(SNMPBD);
    pTableEntry += dwIndex * pTableDescr->BlockSize;

    // this is it, pTableEntry can be returned to the caller
    return pTableEntry;
}

//-----------------------------------------------------------------
// snmpValidTableEntry - returns TRUE or FALSE as the entry at zero
// based index dwIndex from the table described by pTableDescr has
// valid data (is allocated) or not
//-----------------------------------------------------------------
BOOL snmpValidTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex)
{
    return (dwIndex < pTableDescr->Allocated) &&
           (*(HSNMP_SESSION *)snmpGetTableEntry(pTableDescr, dwIndex) != 0);
}

// Save error value as session/task/global error and return 0
SNMPAPI_STATUS SaveError(HSNMP_SESSION hSession, SNMPAPI_STATUS nError)
{
	TaskData.nLastError = nError;
	if (hSession)
	{
		LPSESSION pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(hSession)-1);
		pSession->nLastError = nError;
	}
	return (SNMPAPI_FAILURE);
}

SNMPAPI_STATUS CheckRange (DWORD index, LPSNMPTD block)
{
if ((!index) || (index > block->Allocated))
   return (SNMPAPI_FAILURE);
else
   return (SNMPAPI_SUCCESS);
}

int snmpInit (void)
{
// Initialize Tables
if (snmpInitTableDescr(&SessDescr,  DEFSESSIONS, sizeof(SESSION)) != SNMPAPI_SUCCESS ||
	snmpInitTableDescr(&PDUsDescr,  DEFPDUS, sizeof(PDUS)) != SNMPAPI_SUCCESS        ||
	snmpInitTableDescr(&VBLsDescr,  DEFVBLS, sizeof(VBLS)) != SNMPAPI_SUCCESS        ||
    snmpInitTableDescr(&EntsDescr,  DEFENTITIES, sizeof(ENTITY)) != SNMPAPI_SUCCESS  ||
    snmpInitTableDescr(&CntxDescr,  DEFCONTEXTS, sizeof(CTXT)) != SNMPAPI_SUCCESS    ||
    snmpInitTableDescr(&MsgDescr,   DEFMSGS, sizeof(SNMPMSG)) != SNMPAPI_SUCCESS     ||
    snmpInitTableDescr(&TrapDescr,  DEFTRAPS, sizeof(TRAPNOTICE)) != SNMPAPI_SUCCESS  ||
    snmpInitTableDescr(&AgentDescr, DEFAGENTS, sizeof(AGENT)) != SNMPAPI_SUCCESS)
    return (SNMPAPI_FAILURE);
//
return (SNMPAPI_SUCCESS);
} // end_snmpInit()

void snmpFree (void)
{
snmpFreeTableDescr(&SessDescr);
snmpFreeTableDescr(&PDUsDescr);
snmpFreeTableDescr(&VBLsDescr);
snmpFreeTableDescr(&EntsDescr);
snmpFreeTableDescr(&CntxDescr);
snmpFreeTableDescr(&MsgDescr);
snmpFreeTableDescr(&TrapDescr);
snmpFreeTableDescr(&AgentDescr);
} // end_snmpFree()

BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    BOOL errCode = FALSE;
    LPCRITICAL_SECTION pCSArray[10]; // ten critical sections to initialize (cs_TASK..cs_XMODE)
    INT nCS;                         // counter in pCSArray

    pCSArray[0] = &cs_TASK;
    pCSArray[1] = &cs_SESSION;
    pCSArray[2] = &cs_PDU;
    pCSArray[3] = &cs_VBL;
    pCSArray[4] = &cs_ENTITY;
    pCSArray[5] = &cs_CONTEXT;
    pCSArray[6] = &cs_MSG;
    pCSArray[7] = &cs_TRAP;
    pCSArray[8] = &cs_AGENT;
    pCSArray[9] = &cs_XMODE;

    switch (dwReason)
    {
       case DLL_PROCESS_ATTACH:
           // Init task-specific data area
           ZeroMemory (&TaskData, sizeof(TASK));
           // Build tables
           __try
           {
               for (nCS = 0; nCS < 10; nCS++)
                    InitializeCriticalSection (pCSArray[nCS]);
           }
           __except(EXCEPTION_EXECUTE_HANDLER)
           {
               // if an exception was raised, rollback the successfully initialized CS
               while (nCS > 0)
                   DeleteCriticalSection(pCSArray[--nCS]);
               break;
           }

           if (snmpInit() == SNMPAPI_SUCCESS)
               errCode = TRUE;
           break;

       case DLL_THREAD_ATTACH:
           // A new thread is being created in the current process.
           break;

       case DLL_THREAD_DETACH:
           // A thread is exiting cleanly.
           break;

       case DLL_PROCESS_DETACH:
           // The calling process is detaching the DLL from its address space.
           for (nCS = 0; nCS < 10; nCS++)
               DeleteCriticalSection(pCSArray[nCS]);

           snmpFree();
           errCode = TRUE;
           break;

       default:
           break;
    }
    return (errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_no.c ===
// wsnmp_no.c
//
// WinSNMP Notification Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 970310 - Added callback session support
//        - Added v2 to v1 trap mapping
//        - Refined v1 to v2 trap mapping
//
#include "winsnmp.inc"
//
BOOL DispatchTrap (LPSAS host, smiLPOCTETS community, LPPDUS pdu);
BOOL MapV1TrapV2 (LPPDUS pdu);
smiUINT32 ParsePduHdr (smiLPBYTE msgPtr, smiUINT32 msgLen, smiLPUINT32 version, smiLPINT type, smiLPUINT32 reqID);
BOOL SetPduType (smiLPBYTE msgPtr, smiUINT32 msgLen, int pduType);
THR_TYPE WINAPI thrNotify (LPVOID);

smiUINT32 sysUpTimeValue[9]    = {1,3,6,1,2,1,1,3,0};
smiOID sysUpTimeName   = {9, sysUpTimeValue};
smiUINT32 snmpTrapOidValue[11] = {1,3,6,1,6,3,1,1,4,1,0};
smiOID snmpTrapOidName = {11, snmpTrapOidValue};
smiUINT32 snmpTrapsValue[10]   = {1,3,6,1,6,3,1,1,5,999};
smiOID snmpTrapsName   = {10, snmpTrapsValue};
smiUINT32 snmpTrapEntValue[11] = {1,3,6,1,6,3,1,1,4,3,0};
smiOID snmpTrapEntName = {11, snmpTrapEntValue};
smiUINT32 snmpTrapAddrValue[7] = {1,3,6,1,3,1057,1};
smiOID snmpTrapAddrName = {7, snmpTrapAddrValue};

void MsgNotify (smiUINT32 msgType, smiLPBYTE msgAddr, smiUINT32 msgLen, smiUINT32 nAgent, LPSAS host)
{
DWORD nFound;
DWORD nMsg;
smiUINT32 version;
smiINT pduType;
smiUINT32 reqID;
LPSESSION pSession;
LPSNMPMSG pMsg;

nMsg = ParsePduHdr (msgAddr, msgLen, &version, &pduType, &reqID);
if (nMsg != 0) // ParsePduHdr returns 0 == no_error
   {
   if (msgAddr)
      GlobalFree (msgAddr);
   return;
   }
switch (msgType)
   {
   case NP_TRAP:
   if (TrapDescr.Used && // Discard traps if no registrations
         (pduType == SNMP_PDU_INFORM ||
          pduType == SNMP_PDU_TRAP ||
          pduType == SNMP_PDU_V1TRAP))
      {
      smiLPOCTETS community;
      LPPDUS pdu;
      BOOL bConvert;
      pdu = GlobalAlloc (GPTR, sizeof(PDUS));
      if (pdu == NULL)
         goto DONE_TRAP;
      nMsg = ParseMessage (msgAddr, msgLen, &version, &community, pdu);
      if (nMsg != 0) // ParseMessage returns 0 == no_error
         goto DONE_PDU;
      if (pduType == SNMP_PDU_INFORM)
         { // Send the Inform acknowledgment response
         SOCKET s;
         SetPduType (msgAddr, msgLen, SNMP_PDU_RESPONSE);
         if (host->ipx.sa_family == AF_IPX)
            s = TaskData.ipxSock;
         else
            s = TaskData.ipSock;
         sendto (s, msgAddr, msgLen, 0, (LPSOCKADDR)host, sizeof(SOCKADDR));
         SetPduType (msgAddr, msgLen, SNMP_PDU_INFORM);
         }
      bConvert = TRUE;
      if (pduType == SNMP_PDU_V1TRAP)           // If v1 trap...
         bConvert = MapV1TrapV2 (pdu);          // convert to v2 trap
      if (bConvert)
         DispatchTrap (host, community, pdu);   // always v2 here
      // Cleanup is the same regardless of success or failure
      FreeVarBindList (pdu->VBL_addr);  // Checks for NULL
      FreeV1Trap (pdu->v1Trap);         // ditto
      FreeOctetString (community);      // ditto
      DONE_PDU:
      GlobalFree (pdu);
      } // end_if Trap_or_Inform PDU
   DONE_TRAP:
   GlobalFree (msgAddr);
   return; // end_case NP_TRAP

   case NP_RESPONSE:
   if (pduType != SNMP_PDU_RESPONSE)
      {
      GlobalFree (msgAddr);
      return;
      }
   EnterCriticalSection (&cs_MSG);

   for (nFound=0, nMsg=0; nFound<MsgDescr.Used && nMsg<MsgDescr.Allocated; nMsg++)
      {
      pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
      if (!pMsg->Session)
         continue;
      nFound++;
      if ((pMsg->Status == NP_SENT) && // Must have been sent!
          (pMsg->dllReqId == reqID))   // Must match up!
         {
         pMsg->Status = NP_RCVD;       // ResponsePDU!
         // Release sent packet message
         if (pMsg->Addr)
            GlobalFree (pMsg->Addr);
         // Point to received packet message
         pMsg->Addr = msgAddr;
         pMsg->Size = msgLen;
         LeaveCriticalSection (&cs_MSG);
         pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
         if (pSession->fCallBack)
            { // callback session notification mode
            EnterCriticalSection (&cs_SESSION);
            if (pSession->thrHandle)
               {
               if (pSession->thrCount != 0xFFFFFFFF)
                  pSession->thrCount++;
               SetEvent (pSession->thrEvent);
               }
            else
               FreeMsg (nMsg);
            LeaveCriticalSection (&cs_SESSION);
            }
         else
            { // window/message session notification mode
            if (IsWindow(pSession->hWnd))
               {
               pMsg->Status = NP_READY;
               PostMessage (pSession->hWnd,
                            pSession->wMsg,
                            0, pMsg->appReqId);
               }
            else
               FreeMsg (nMsg);
            }
         return;  // Matched response with request
         } // end_if
      } // end_for
   // If we fall through the for loop without finding a match,
   //  this must be a spurious message from agent...discard
   GlobalFree (msgAddr);
   LeaveCriticalSection (&cs_MSG);
   return; // end_case NP_RESPONSE

   case NP_REQUEST:
   // To allow for AgentX Master Agents and Mid-Level-Managers
   // any type of PDU may be accepted on this channel - BobN 4/8/97
   // Get a msg slot
   EnterCriticalSection (&cs_MSG);
   if (snmpAllocTableEntry(&MsgDescr, &nMsg) != SNMPAPI_SUCCESS)
   {
       LeaveCriticalSection(&cs_MSG);
       GlobalFree (msgAddr);
       return;
   }
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);

   pMsg->Session = ((LPAGENT)snmpGetTableEntry(&AgentDescr, nAgent))->Session;
   pMsg->Status = NP_RCVD;       // In-bound request
   pMsg->Type = pduType;
   pMsg->Addr = msgAddr;
   pMsg->Size = msgLen;
   pMsg->appReqId = pMsg->dllReqId = reqID;
   CopyMemory (&(pMsg->Host), host, sizeof(SAS));
   LeaveCriticalSection (&cs_MSG);
   pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
   if (pSession->fCallBack)
      { // callback session notification mode
     EnterCriticalSection (&cs_SESSION);
      if (pSession->thrHandle)
         {
         if (pSession->thrCount != 0xFFFFFFFF)
            pSession->thrCount++;
         SetEvent (pSession->thrEvent);
         }
      else
         {
         FreeMsg (nMsg);
         }
      LeaveCriticalSection (&cs_SESSION);
      }
   else
      {
      if (IsWindow(pSession->hWnd))
         {
         pMsg->Status = NP_READY;
         PostMessage (pSession->hWnd,
                      pSession->wMsg,
                      0, pMsg->appReqId);
         }
      else
         FreeMsg (nMsg);
      }
   break;

   default:
   GlobalFree (msgAddr);
   break;
   } // end_switch msgType
return;
} // end_MsgNotify

THR_TYPE WINAPI thrNotify (LPVOID cbSessionSlot)
{
    DWORD           nSes = (DWORD)((DWORD_PTR)cbSessionSlot);
    HSNMP_SESSION   hSession = (HSNMP_SESSION) ULongToPtr(nSes + 1);
    DWORD           nUsed, nMsg;
    WPARAM          wParam;
    LPARAM          lParam;
    BOOL            bFound, bWillBlock;
    LPSESSION       pSession;
    LPSNMPMSG       pMsg;

    // pSession->thrCount counts the number of requests. External threads increment it
    // each time they know something has changed in the message table (message expired or received)
    // thrNotify decrements it each time it scans the message table.
    do
    {
        EnterCriticalSection (&cs_SESSION);
        pSession = snmpGetTableEntry(&SessDescr, nSes);
        if (pSession->thrCount != 0xFFFFFFFF &&
            pSession->thrCount != 0)
            pSession->thrCount-- ;
        bWillBlock = pSession->thrCount == 0;
        LeaveCriticalSection (&cs_SESSION);

        // The thread will block only if the pSession->thrCount was 0 (tested in critical
        // section). It will be unblocked by external threads, from inside the same critical section.
        if (bWillBlock)
            WaitForSingleObject (pSession->thrEvent, INFINITE);

        // termination is requested, just break the loop
        if (pSession->thrCount == 0xFFFFFFFF)
            break;

        bFound = FALSE;
        // Find a waiting Msg for this session to process
        EnterCriticalSection (&cs_MSG);
        for (nUsed=0, nMsg=0;
             nUsed<MsgDescr.Used && nMsg<MsgDescr.Allocated;
             nMsg++)
        {
            pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
            if (pMsg->Session == hSession &&
                (pMsg->Status == NP_RCVD || pMsg->Status == NP_EXPIRED))
            {
                // the message was found. It might be already received, or it might
                // be timed out. Either case, the notification function has to be called.
                wParam = pMsg->Status == NP_RCVD ? 0 : SNMPAPI_TL_TIMEOUT ;
                lParam = pMsg->appReqId;

                if (wParam == SNMPAPI_TL_TIMEOUT)
                    FreeMsg(nMsg); // no more need for this expired bugger
                else
                    pMsg->Status = NP_READY; // mark it for SnmpRecvMsg()

                bFound = TRUE;
                // as the message was found, no reason to loop further
                break;
            }

            // update nFound to avoid searching more than the messages available
            nUsed += (pMsg->Session != 0);
        }
        LeaveCriticalSection (&cs_MSG);

        if (bFound)
        {
            //if a message was found for this session, call the notification function
            (*(pSession->fCallBack)) (hSession,
                                      pSession->hWnd,
                                      pSession->wMsg,
                                      wParam,
                                      lParam,
                                      pSession->lpClientData);
        }

    } while (TRUE);

    _endthreadex(0);

    return (0);
} // end_thrNotify

THR_TYPE WINAPI thrManager (LPVOID xSock)
{
DWORD  iBytes;
int    nSock;
fd_set readFDS;
SOCKET *pSock = (SOCKET*)xSock;
SOCKET tSock = *pSock;
SAS    host;
smiLPBYTE rMsgPtr;
int    fLen;
struct timeval tvTimeout;             // timeout for select

// select with timeout so that we can response to hExitEvent in signaled state
tvTimeout.tv_sec = 1;  // 1 sec. timeout value
tvTimeout.tv_usec = 0; // When select returns, the contents of the
                       // tvTimeout structure are not altered.
while (TRUE)
   {
   if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.hExitEvent, 0))
      {  
      goto DONE; // we're asked to exit
      }
   FD_ZERO (&readFDS);
   // Note:  strategy used in this block to assign a value
   // to "fLen" is important for Solaris and benign for Win32
   FD_SET (tSock, &readFDS);
   fLen = (int)tSock;
   fLen++;
   // Must preserve value of fLen across loops
   nSock = select (fLen, &readFDS, NULL, NULL, &tvTimeout);            
   if (0 == nSock)
      {
      // timeout
      continue;
      }
   else if (nSock == SOCKET_ERROR || *pSock == INVALID_SOCKET)
      {
      goto DONE; // terminate thread
      }
   // Only one socket monitored per thread, hence
   // FD_ISSET can be safely assumed at this point
   nSock = ioctlsocket (tSock, FIONREAD, &iBytes);
   if (nSock == SOCKET_ERROR || *pSock == INVALID_SOCKET)
      goto DONE;
   // Find the message buffer address...
   rMsgPtr = GlobalAlloc (GPTR, iBytes);
   if (rMsgPtr == NULL)
      { // No space error...throw away the message...
      recvfrom (tSock, (LPSTR)&nSock, 1, 0, NULL, NULL);
      if (*pSock == INVALID_SOCKET)
          goto DONE;
      // ...and call it quits.
      continue;
      }
   nSock = sizeof(SAS);
   // get the datagram and the address of the host that sent it
   iBytes = recvfrom (tSock, rMsgPtr, iBytes, 0, (LPSOCKADDR)&host, &nSock);
   if (iBytes != SOCKET_ERROR && *pSock != INVALID_SOCKET)
      MsgNotify (NP_RESPONSE, rMsgPtr, iBytes, 0, &host);
   else
      GlobalFree(rMsgPtr); // BUG# 458343
   } // end_while
DONE:
return (0);
} // end_thrManager

THR_TYPE WINAPI thrTimer (LPVOID nTask)
{ // Clean-up any timed-out messages
BOOL bFree;
DWORD lTicks, nMsg;
DWORD nFound;
SOCKET tSock;
LPSNMPMSG pMsg;

// This thread won't be needed immediately upon creation.
// It sleeps/suspends itself as appropriate.
// SnmpSendMsg() resumes it for each message sent
// SnmpCleanup() resumes it to signal termination.
while (TRUE)
   {// Once per second granularity
   Sleep (1000);
   // Check for termination request
   if (TaskData.timerThread == NULL)
      goto DONE;
   // If no msgs, go back to sleep
   if (MsgDescr.Used == 0)
      continue;
   EnterCriticalSection (&cs_MSG);
   for (nMsg=0, nFound=0; nFound<MsgDescr.Used && nMsg<MsgDescr.Allocated; nMsg++)
      {
      pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
      if (!pMsg->Session)           // Skip unused slots
         continue;
      nFound++; // Signal break when last used slot is processed
      if (pMsg->Status != NP_SENT)  // Skip pending and
         continue;                           // received messages
      lTicks = GetTickCount();               // update current time
      // Following test revised on 10/18/96 by BobN
      // Message "tick-time" rather than "TTL" now stored in MSG
      // to enable test for Windows timer wrap (49.7 days)

      // pMsg->PolicyTries - pMsg->Tries is the number of retries so far
      if ((pMsg->PolicyTries - pMsg->Tries+1)*pMsg->Wait + pMsg->Ticks > lTicks  &&  // MSG TTL test
          pMsg->Ticks <= lTicks)                 // Timer wrap test
         continue;                            // Retain the message
      
      bFree = TRUE; // Prepare to free the message slot
      if (pMsg->nRetransmitMode)
         {
         if (pMsg->Tries)
            {
             LPENTITY pEntity;

            //WriteSocket (nMsg);
            // Determine which socket to use
            if (pMsg->Host.ipx.sa_family == AF_IPX)
               tSock = TaskData.ipxSock;
            else
               tSock = TaskData.ipSock;
            // Send the data
            sendto (tSock, pMsg->Addr, pMsg->Size,
                    0, (LPSOCKADDR)&(pMsg->Host), sizeof(SAS));
            // Need to check for SOCKET_ERROR!
            // end_WriteSocket
            //pMsg->Ticks is the time for the first SnmpSendMessage
            pMsg->Tries--;    // Record the attempt
                     
            // update the destination entity's nActualRetry
            EnterCriticalSection (&cs_ENTITY);         
            // locate the agent (source) entity here
            pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);

            // update the nActualRetry param of the agent (source) entity
            pEntity->nActualRetry = pMsg->PolicyTries - pMsg->Tries;
            LeaveCriticalSection (&cs_ENTITY);
            
            if (!pMsg->Tries) // No further retries?
               {                       // Release buffer space
               GlobalFree (pMsg->Addr);
               pMsg->Addr = NULL;
               pMsg->Size = 0;
               }
            bFree = FALSE;             // Retain the message slot
            }
         else
            {
            LPSESSION pSession;

            pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
            if (pSession->fCallBack)
               { // callback session notification mode
               EnterCriticalSection (&cs_SESSION);
               if (pSession->thrHandle)
                  {
                  bFree = FALSE; // thrNotify will free it
                  pMsg->Status = NP_EXPIRED;
                  if (pSession->thrCount != 0xFFFFFFFF)
                     pSession->thrCount++;
                  SetEvent (pSession->thrEvent);
                  }
               LeaveCriticalSection (&cs_SESSION);
               }
            else
               { // windows/message session notification mode
               if (IsWindow(pSession->hWnd))
                  {
                  PostMessage (pSession->hWnd,
                               pSession->wMsg,
                               SNMPAPI_TL_TIMEOUT,
                               pMsg->appReqId);
                  }
               }
            } // end_else (no retry left)
         } // end_if (retransmitMode)
      if (bFree) FreeMsg (nMsg);
      } // end_for
   LeaveCriticalSection (&cs_MSG);
   } // end_while
DONE:
return (0);
} // end_thrTimer

// Client side trap processing for Win32
THR_TYPE WINAPI thrTrap (LPVOID lpTask)
{
#define TRAPBUFSIZE 4096
typedef struct
   {
   SOCKADDR Addr;
   int      AddrLen;
   UINT     TrapBufSz;
   char     TrapBuf[TRAPBUFSIZE];
   } SNMP_TRAP, *PSNMP_TRAP;
SNMP_TRAP recvTrap;
DWORD iBytes;
smiLPBYTE rMsgPtr;
BOOL bSuccess;
//
// Approach differs for NT (SNMPTRAP) vs '95
//
if (TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_NT)
{
    // IMPORTANT NOTE FOR NT:
    // This code must be consistent with the SNMPTRAP code
    // wrt TRAPBUFSIZE, SNMPTRAPPIPE, and the SNMP_TRAP struct

    while (TRUE)
    {
        // check if thread termination required, Bug# 270672
        if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.trapEvent, 0))
        {
            break;
        }

        if (ReadFile(
                TaskData.trapPipe,
                (LPBYTE)&recvTrap,
                sizeof(SNMP_TRAP) - sizeof(recvTrap.TrapBuf), // message header size 
                &iBytes,
                &TaskData.trapOl))
        {
            // It is impossible for ReadFile to succeed because
            // the specified number of bytes to read is less than 
            // the size of the next message.

            break;
        }
        else
        {
            if (ERROR_IO_PENDING == GetLastError())
            {    
                // block to wait until the reading of pipe message header completes
                // or we need to exit this thread
                bSuccess = GetOverlappedResult(
                                TaskData.trapPipe,
                                &TaskData.trapOl,
                                &iBytes,
                                TRUE); // Block

                // check if thread termination required
                if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.trapEvent, 0))
                {
                    break;
                }

                // reset event to non-signaled state for next I/O
                ResetEvent(TaskData.trapOl.hEvent);

                
                if (!bSuccess)
                {
                    if (ERROR_MORE_DATA != GetLastError())
                    {
                        break;
                    }
                    // we are here because the last overlapped read completes but we supplied
                    // a smaller buffer than the pipe message, we'll read the rest of the message
                    // below.
                }
            }
            else if (ERROR_MORE_DATA != GetLastError())
            {
                break;
            }
        }


        // Find the message buffer address...
        rMsgPtr = GlobalAlloc (GPTR, 2*recvTrap.TrapBufSz);
        if (rMsgPtr == NULL)
        {
            // No space error: E_OUTOFMEMORY
            break;
        }

        // read the rest of the pipe message
        if (
            !ReadFile(
                TaskData.trapPipe,
                (LPBYTE)rMsgPtr,
                2*recvTrap.TrapBufSz,
                &iBytes,
                &TaskData.trapOl))
        {
            if (ERROR_IO_PENDING == GetLastError())
            {
                // block to wait until the reading of pipe message body completes
                // or we need to exit this thread
                bSuccess = GetOverlappedResult(
                                TaskData.trapPipe,
                                &TaskData.trapOl,
                                &iBytes,
                                TRUE); // Block

                // check if thread termination required
                if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.trapEvent, 0))
                {
                    GlobalFree(rMsgPtr);
                    break;
                }

                // reset event to non-signaled state for next I/O
                ResetEvent(TaskData.trapOl.hEvent);

                if (!bSuccess)
                {
                    GlobalFree(rMsgPtr);
                    break;  
                }
            }
            else
            {
                GlobalFree(rMsgPtr);
                break;
            }
        }

        // get the datagram and the address of the host that sent it
        MsgNotify (NP_TRAP, rMsgPtr, iBytes, 0, (LPSAS)&recvTrap.Addr);
    } // end while()
} // end_NT_thrTrap

return (0);
} // end_Win32_thrTrap

THR_TYPE WINAPI thrAgent (LPVOID newAgent)
{
DWORD  iBytes;
int    iLen;
fd_set readFDS;
SAS    host;
smiLPBYTE rMsgPtr;
DWORD  nAgent = (DWORD)((DWORD_PTR)newAgent);
SOCKET sAgent = ((LPAGENT)snmpGetTableEntry(&AgentDescr, nAgent))->Socket;
// fLen logic needed for Solaris; ignored in Win32
int    fLen = (int)sAgent + 1;
while (TRUE)
   {
   FD_ZERO (&readFDS);
   FD_SET (sAgent, &readFDS);
   // Must preserve value of fLen acroos loops
   iLen = select (fLen, &readFDS, NULL, NULL, NULL);
   if (iLen == SOCKET_ERROR)
      goto DONE;
   // Only one socket per thread, therefore
   // we can safely assume FD_ISSET here
   iLen = ioctlsocket (sAgent, FIONREAD, &iBytes);
   if (iLen == SOCKET_ERROR)
      goto DONE;
   if (iBytes == 0)
      continue;
   // Find the message buffer address...
   rMsgPtr = GlobalAlloc (GPTR, iBytes);
   if (rMsgPtr == NULL)
      { // No space error...throw away the message...
      recvfrom (sAgent, (LPSTR)&iLen, 1, 0, NULL, NULL);
      // ...and call it quits.
      continue;
      }
   iLen = sizeof(SAS);
   // get the datagram and the address of the host that sent it
   iBytes = recvfrom (sAgent, rMsgPtr, iBytes, 0, (LPSOCKADDR)&host, &iLen);
   if (iBytes != SOCKET_ERROR)
      MsgNotify (NP_REQUEST, rMsgPtr, iBytes, nAgent, &host);
   else
      GlobalFree(rMsgPtr);
   } // end_while
DONE:
return (0);
} // end_thrAgent

BOOL MapV1TrapV2 (LPPDUS pdu)
{
LPVARBIND VbTicks = NULL;
LPVARBIND VbTrap = NULL;
LPVARBIND VbAddress = NULL;
LPVARBIND VbEnterprise = NULL;
LPVARBIND endPtr;
smiLPUINT32 ptrTrap;
smiUINT32 lenTrap;
if (!pdu)
   return (FALSE);
// Adjust "generic" for v2 values
pdu->v1Trap->generic_trap++;        // as oid in v2 is v1 # +1
if (pdu->v1Trap->generic_trap == 7) // specific?
   pdu->v1Trap->generic_trap = 0;   // v2
// rfc1908:(2)  If a Trap-PDU is received, then it is mapped into a
// SNMPv2-Trap-PDU.  This is done by prepending onto the variable-bindings
// field two new bindings: sysUpTime.0 [12], which takes its value from the
// timestamp field of the Trap-PDU; and.......
if (!(VbTicks = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   return (FALSE);
if (SnmpOidCopy (&sysUpTimeName, &VbTicks->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbTicks->value.syntax = SNMP_SYNTAX_TIMETICKS;
VbTicks->value.value.uNumber = pdu->v1Trap->time_ticks;
// ..... snmpTrapOID.0 [13], which is calculated thusly: if the value of
// generic-trap field is `enterpriseSpecific', then the value used is the
// concatenation of the enterprise field from the Trap-PDU with two additional
// sub-identifiers, `0', and the value of the specific-trap field; otherwise,
// the value of the corresponding trap defined in [13] is used.  (For example,
// if the value of the generic-trap field is `coldStart', then the coldStart
// trap [13] is used.)
if (!(VbTrap = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   goto ERROROUT;
if (SnmpOidCopy (&snmpTrapOidName, &VbTrap->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbTrap->value.syntax = SNMP_SYNTAX_OID;
if (snmpTrapsValue[9] = pdu->v1Trap->generic_trap) // Deliberate assignment
   { // SNMP_TRAP_GENERIC
   lenTrap = sizeof(snmpTrapsValue);
   VbTrap->value.value.oid.len = lenTrap / sizeof(smiUINT32);
   ptrTrap = snmpTrapsValue;
   }
else
   { // SNMP_TRAP_ENTERPRISE
   lenTrap = pdu->v1Trap->enterprise.len * sizeof(smiUINT32);
   VbTrap->value.value.oid.len = pdu->v1Trap->enterprise.len + 2;
   ptrTrap = pdu->v1Trap->enterprise.ptr;
   }
if (!(VbTrap->value.value.oid.ptr = (smiLPUINT32)GlobalAlloc
      (GPTR, VbTrap->value.value.oid.len * sizeof(smiUINT32))))
   goto ERROROUT;
CopyMemory (VbTrap->value.value.oid.ptr, ptrTrap, lenTrap);
if (!pdu->v1Trap->generic_trap)
   { // SNMP_TRAP_ENTERPRISE
   VbTrap->value.value.oid.ptr[pdu->v1Trap->enterprise.len+1] =
      pdu->v1Trap->specific_trap;
   }
// Special code to retain v1Trap AgentAddress info in an experimental object
// This is *not* part of the WinSNMP v2.0 standard at this time (6/25/98)
if (TaskData.conveyAddress != SNMPAPI_ON)
   goto DO_ENTERPRISE;
if (!(VbAddress = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   goto ERROROUT;
if (SnmpOidCopy (&snmpTrapAddrName, &VbAddress->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbAddress->value.syntax = SNMP_SYNTAX_IPADDR;
// *Re-use* this OID parsed in WSNMP_BN code
VbAddress->value.value.string.len = pdu->v1Trap->agent_addr.len;
VbAddress->value.value.string.ptr = pdu->v1Trap->agent_addr.ptr;
pdu->v1Trap->agent_addr.len = 0;    // Setting .ptr to NULL required
pdu->v1Trap->agent_addr.ptr = NULL; // for later call to FreeV1Trap()
DO_ENTERPRISE:
// Then,......one new binding is appended onto the variable-bindings field:
// snmpTrapEnterpriseOID.0 [13], which takes its value from the enterprise field
// of the Trap-PDU.
//
// WINSNMP specs in SnmpRecvMsg specifies this append for both the generic and
// specific traps and not only for specific as RFC 1452 does.
if (!(VbEnterprise = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   goto ERROROUT;
if (SnmpOidCopy (&snmpTrapEntName, &VbEnterprise->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbEnterprise->value.syntax = SNMP_SYNTAX_OID;
// *Re-use* this OID parsed in WSNMP_BN code
VbEnterprise->value.value.oid.len = pdu->v1Trap->enterprise.len;
VbEnterprise->value.value.oid.ptr = pdu->v1Trap->enterprise.ptr;
pdu->v1Trap->enterprise.len = 0;    // Setting .ptr to NULL required
pdu->v1Trap->enterprise.ptr = NULL; // for later call to FreeV1Trap()

//We have all the variables set, just need to link them together
//backup the head of the original vbs
endPtr = pdu->VBL_addr;
// setup the new head of the list
pdu->VBL_addr = VbTicks;
VbTicks->next_var = VbTrap;
VbTrap->next_var = endPtr;
// position endPtr on the last varbind from the list
if (endPtr != NULL)
{
    // set it on the last varbind from the original V1 trap
    while (endPtr->next_var != NULL)
        endPtr = endPtr->next_var;
}
else
{
    // set it on VbTrap if no varbinds were passed in the V1 trap
    endPtr = VbTrap;
}
// append VbAddress if any and set endPtr on the new ending
if (VbAddress != NULL)
{
    endPtr->next_var = VbAddress;
    endPtr = VbAddress;
}
// append VbEnterprise
endPtr->next_var = VbEnterprise;
VbEnterprise->next_var = NULL;
//
// make it say it's an SNMPv2 Trap PDU
pdu->type = SNMP_PDU_TRAP;
// Assign a RequestID (not in SNMPv1 Trap PDUs (no need to lock)
pdu->appReqId = ++(TaskData.nLastReqId);
return (TRUE);
//
ERROROUT:
// Free only those resources created in this function
// FreeVarBind is a noop on NULLs, so no need to check first
FreeVarBind (VbEnterprise);
FreeVarBind (VbAddress);
FreeVarBind (VbTrap);
FreeVarBind (VbTicks);
return (FALSE);
} // end_MapV1TrapV2

BOOL DispatchTrap (LPSAS host, smiLPOCTETS community, LPPDUS pdu)
{
#define MAXSLOTS 10 // maximum active trap receivers
DWORD nCmp;
DWORD nFound = 0;
DWORD nTrap = 0;
DWORD nTraps[MAXSLOTS];
DWORD nMsg = 0;
LPSNMPMSG pMsg;
LPTRAPNOTICE pTrap;

EnterCriticalSection (&cs_TRAP);
for (nTrap = 0; nTrap < TrapDescr.Allocated; nTrap++)
   {
   pTrap = snmpGetTableEntry(&TrapDescr, nTrap);
   if (!pTrap->Session) continue;  // Active trap registration and
   if (pTrap->notification.len)    // all Traps?
      {                            // Nope, specific test

      SNMPAPI_STATUS lError;
      // Next line is critical...do not remove...BN 3/8/96
      pTrap->notification.ptr = &(pTrap->notificationValue[0]);
      // 2nd param below assumes well-formed trap/inform...BN 1/21/97
      lError = SnmpOidCompare (&(pTrap->notification),
         &pdu->VBL_addr->next_var->value.value.oid,
         pTrap->notification.len, &nCmp);
      if (lError != SNMPAPI_SUCCESS || nCmp) continue;  // not equal...
      }
   if (pTrap->agentEntity)         // Specific agent?
      {
      int nResult;
      LPENTITY pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pTrap->agentEntity) - 1);
      if (host->ipx.sa_family == AF_IPX)
         nResult = memcmp (&host->ipx.sa_netnum,
                   &(pEntity->addr.ipx.sa_netnum), AF_IPX_ADDR_SIZE);
      else // AF_IPX
         nResult = memcmp (&host->inet.sin_addr,
                   &(pEntity->addr.inet.sin_addr), AF_INET_ADDR_SIZE);
      if (nResult)
         continue;                           // not equal...
      }
   if (pTrap->Context)             // Specific context?
      {
      LPCTXT pCtxt = snmpGetTableEntry(&CntxDescr, HandleToUlong(pTrap->Context) - 1);
      if (community->len != pCtxt->commLen)
         continue;                           // not equal...lengths
      if (memcmp (community->ptr, pCtxt->commStr,
                  (size_t)community->len))
         continue;                           // not equal...values
      }
   nTraps[nFound] = nTrap;                   // Got a match!
   nFound++; // Count the number found and check it against maximums
   if ((nFound == (MAXSLOTS)) || (nFound == TrapDescr.Used))
      break;
   } // end_for
LeaveCriticalSection (&cs_TRAP);
if (nFound == 0)  // Nothing to do
   return (SNMPAPI_FAILURE);
//
nCmp = nFound;    // Save count for later user
EnterCriticalSection (&cs_MSG);
while (nFound)
   {
   DWORD lError;

   lError = snmpAllocTableEntry(&MsgDescr, &nMsg);
   if (lError != SNMPAPI_SUCCESS)
   {
       LeaveCriticalSection(&cs_MSG);
       return lError;
   }
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);

   --nFound;
   nTrap = nTraps[nFound];
   nTraps[nFound] = nMsg;   // Need for later use
   pTrap = snmpGetTableEntry(&TrapDescr, nTrap);

   pMsg->Session = pTrap->Session;
   pMsg->Status = NP_RCVD;
   pMsg->Type = pdu->type;
   // 960522 - BN...
   // Need to increment the eventual "dstEntity" if
   // one was specified on the SnmpRegister() filter (unusual).
   // Deliberate assignment...
   if (pMsg->ourEntity = pTrap->ourEntity)
      {
      LPENTITY pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pTrap->ourEntity)-1);
      pEntity->refCount++;
      }

   // end_960522 - BN
   pMsg->dllReqId = pMsg->appReqId = pdu->appReqId;
   pMsg->Ticks = pMsg->Tries = pMsg->PolicyTries = 0;
   CopyMemory (&(pMsg->Host), host, sizeof(SAS));
   if (!(BuildMessage (1, community, pdu, pdu->appReqId,
         &(pMsg->Addr), &(pMsg->Size))))
      {
      // rollback for all messages from nCmp to nFound
      while (nCmp != nFound)
         {
         nMsg = nTraps[--nCmp];
         FreeMsg (nMsg);
         }
      LeaveCriticalSection (&cs_MSG);
      return (SNMPAPI_PDU_INVALID);
      }
   } // end_while (nFound)
LeaveCriticalSection (&cs_MSG);
//
// The next while loop actually sends the one or more trap messages
// to the application(s)...
// This is due to the fact that we "clone" the incoming trap msg
// if there are multiple registrations for it.  BobN 2/20/95
while (nCmp) // Saved message count
   { // Now actually send the message(s)
   LPSESSION pSession;

   nMsg = nTraps[--nCmp];
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
   pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
   if (pSession->fCallBack)
      { // callback session notification mode
      EnterCriticalSection (&cs_SESSION);
      if (pSession->thrHandle)
         {
         if (pSession->thrCount != 0xFFFFFFFF)
            pSession->thrCount++;
         SetEvent (pSession->thrEvent);
         }
      else
         FreeMsg (nMsg);
      LeaveCriticalSection (&cs_SESSION);
      }
   else
      { // window/message session notification mode
      if (IsWindow(pSession->hWnd))
         {
         pMsg->Status = NP_READY;
         PostMessage (pSession->hWnd,
                      pSession->wMsg, 0, 0L);
         }
      else
         FreeMsg (nMsg);
      }
   } // end_while (nCmp)
return (SNMPAPI_SUCCESS);
} // end_DispatchTrap

LPPDUS MapV2TrapV1 (HSNMP_PDU hPdu)
{
// Convert SNMPv2 trap to SNMPv1 trap, for sending only
HSNMP_VBL hNewVbl = NULL;
LPPDUS oldPdu = NULL;
LPPDUS newPdu = NULL;
smiUINT32 lCount;
smiUINT32 lCmp;
smiUINT32 i;
smiLPBYTE tmpPtr = NULL;
smiOID sName;
smiVALUE sValue;
//
if (hPdu == NULL)
   return (NULL);
oldPdu = snmpGetTableEntry(&PDUsDescr, HandleToUlong(hPdu)-1);
if (oldPdu->type != SNMP_PDU_TRAP)
   return (NULL);
if (SnmpGetPduData (hPdu, NULL, NULL, NULL, NULL, &hNewVbl) == SNMPAPI_FAILURE)
   return (NULL);
if (hNewVbl == NULL)
   return (NULL);
newPdu = GlobalAlloc (GPTR, sizeof(PDUS));
if (newPdu == NULL)
   goto ERR_OUT;
// From RFC 2089
// 3.3  Processing an outgoing SNMPv2 TRAP
//
// If SNMPv2 compliant instrumentation presents an SNMPv2 trap to the
// SNMP engine and such a trap passes all regular checking and then is
// to be sent to an SNMPv1 destination, then the following steps must be
// followed to convert such a trap to an SNMPv1 trap.  This is basically
// the reverse of the SNMPv1 to SNMPv2 mapping as described in RFC1908
// [3].
newPdu->type = SNMP_PDU_V1TRAP;
newPdu->v1Trap = GlobalAlloc (GPTR, sizeof(V1TRAP));
if (newPdu->v1Trap == NULL)
   goto ERR_OUT;
//
//   1.  If any of the varBinds in the varBindList has an SNMPv2 syntax
//       of Counter64, then such varBinds are implicitly considered to
//       be not in view, and so they are removed from the varBindList to
//       be sent with the SNMPv1 trap.
//
// We will do that step later, but check the VB count for now:
lCount = SnmpCountVbl (hNewVbl); // SNMPAPI_FAILURE is 0
// Need at least 2 for sysUptime and snmpTrapOID!
if (lCount < 2)
   goto ERR_OUT;
//
//   2.  The 3 special varBinds in the varBindList of an SNMPv2 trap
//       (sysUpTime.0 (TimeTicks), snmpTrapOID.0 (OBJECT IDENTIFIER) and
//       optionally snmpTrapEnterprise.0 (OBJECT IDENTIFIER)) are
//       removed from the varBindList to be sent with the SNMPv1 trap.
//       These 2 (or 3) varBinds are used to decide how to set other
//       fields in the SNMPv1 trap PDU as follows:
//
//       a.  The value of sysUpTime.0 is copied into the timestamp field
//           of the SNMPv1 trap.
//
if (SnmpGetVb (hNewVbl, 1, &sName, &sValue) == SNMPAPI_FAILURE)
   goto ERR_OUT;
if (SnmpOidCompare (&sysUpTimeName, &sName, 0, &lCmp) == SNMPAPI_FAILURE)
{
   // sValue is a number, no need to free
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   goto ERR_OUT;
}
SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName); // ignore error
  
if (lCmp != 0)
   goto ERR_OUT;
newPdu->v1Trap->time_ticks = sValue.value.uNumber;
if (SnmpDeleteVb (hNewVbl, 1) == SNMPAPI_FAILURE)
   goto ERR_OUT;
lCount--;
//
//       b.  If the snmpTrapOID.0 value is one of the standard traps
//           the specific-trap field is set to zero and the generic
//           trap field is set according to this mapping:
//
//              value of snmpTrapOID.0                generic-trap
//              ===============================       ============
//              1.3.6.1.6.3.1.1.5.1 (coldStart)                  0
//              1.3.6.1.6.3.1.1.5.2 (warmStart)                  1
//              1.3.6.1.6.3.1.1.5.3 (linkDown)                   2
//              1.3.6.1.6.3.1.1.5.4 (linkUp)                     3
//              1.3.6.1.6.3.1.1.5.5 (authenticationFailure)      4
//              1.3.6.1.6.3.1.1.5.6 (egpNeighborLoss)            5
//
if (SnmpGetVb (hNewVbl, 1, &sName, &sValue) == SNMPAPI_FAILURE)
   goto ERR_OUT;
if (SnmpOidCompare (&snmpTrapOidName, &sName, 0, &lCmp) == SNMPAPI_FAILURE)
{
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid);
   goto ERR_OUT;
}
SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName); // ignore error
if (lCmp != 0)
{
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid);
   goto ERR_OUT;
}
if (SnmpOidCompare (&snmpTrapsName, &sValue.value.oid, 9, &lCmp) == SNMPAPI_FAILURE)
{
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid);
   goto ERR_OUT;
}
if (!lCmp)
   {
   newPdu->v1Trap->generic_trap = sValue.value.oid.ptr[9] - 1;
   newPdu->v1Trap->specific_trap = 0;
//           The enterprise field is set to the value of
//           snmpTrapEnterprise.0 if this varBind is present, otherwise
//           it is set to the value snmpTraps as defined in RFC1907 [4].
   i = snmpTrapsName.len - 1;
   tmpPtr = (smiLPBYTE)snmpTrapsValue;
   }
//
//       c.  If the snmpTrapOID.0 value is not one of the standard
//           traps, then the generic-trap field is set to 6 and the
//           specific-trap field is set to the last subid of the
//           snmpTrapOID.0 value.
else
   {
   newPdu->v1Trap->generic_trap = 6;
   i = sValue.value.oid.len;
   newPdu->v1Trap->specific_trap = sValue.value.oid.ptr[i-1];
   tmpPtr = (smiLPBYTE)sValue.value.oid.ptr;
//
//           o   If the next to last subid of snmpTrapOID.0 is zero,
//               then the enterprise field is set to snmpTrapOID.0 value
//               and the last 2 subids are truncated from that value.
   if (sValue.value.oid.ptr[i-2] == 0)
      i -= 2;
//           o   If the next to last subid of snmpTrapOID.0 is not zero,
//               then the enterprise field is set to snmpTrapOID.0 value
//               and the last 1 subid is truncated from that value.
   else
      i -= 1;
//           In any event, the snmpTrapEnterprise.0 varBind (if present)
//           is ignored in this case.
   }
//
newPdu->v1Trap->enterprise.len = i;
i *= sizeof(smiUINT32);
// This allocation might have to be freed later,
// if generic trap and SnmpTrapEnterprise.0 is present in the varbindlist.
newPdu->v1Trap->enterprise.ptr = GlobalAlloc (GPTR, i);
if (newPdu->v1Trap->enterprise.ptr == NULL)
   {
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid);
   goto ERR_OUT;
   }
CopyMemory (newPdu->v1Trap->enterprise.ptr, tmpPtr, i);
SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid); // ignore error
if (SnmpDeleteVb (hNewVbl, 1) == SNMPAPI_FAILURE)
   goto ERR_OUT;
lCount--;
//
i = 1;
while (i <= lCount)
   {
   if (SnmpGetVb (hNewVbl, i, &sName, &sValue) == SNMPAPI_FAILURE)
      goto ERR_OUT;
   if (sValue.syntax == SNMP_SYNTAX_CNTR64)
      {
      if (SnmpDeleteVb (hNewVbl, i) == SNMPAPI_FAILURE)
         goto ERR_LOOP;
      lCount--;
      goto LOOP;
      }
   if (SnmpOidCompare (&snmpTrapEntName, &sName, 0, &lCmp) == SNMPAPI_FAILURE)
      goto ERR_LOOP;
   if (lCmp == 0)
      {
      if (newPdu->v1Trap->specific_trap == 0)
         {
         if  (newPdu->v1Trap->enterprise.ptr)
            GlobalFree (newPdu->v1Trap->enterprise.ptr);
         lCmp = sValue.value.oid.len * sizeof(smiUINT32);
         newPdu->v1Trap->enterprise.ptr = GlobalAlloc (GPTR, lCmp);
         if (newPdu->v1Trap->enterprise.ptr == NULL)
            goto ERR_LOOP;
         newPdu->v1Trap->enterprise.len = sValue.value.oid.len;
         CopyMemory (newPdu->v1Trap->enterprise.ptr,
                     sValue.value.oid.ptr, lCmp);
         }
      if (SnmpDeleteVb (hNewVbl, i) == SNMPAPI_FAILURE)
         goto ERR_LOOP;
      lCount--;
      goto LOOP;
      }
   i++;
LOOP:
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   SnmpFreeDescriptor (sValue.syntax, (smiLPOPAQUE)&sValue.value.oid);
   }
goto DONE_LOOP; // jump over error handling code

ERR_LOOP:
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   SnmpFreeDescriptor (sValue.syntax, (smiLPOPAQUE)&sValue.value.oid);
   goto ERR_OUT;

DONE_LOOP:

if (lCount > 0)
   {
   LPVBLS pVbl = snmpGetTableEntry(&VBLsDescr, HandleToUlong(hNewVbl)-1);
   // Retain existing varbindlist remainder
   newPdu->VBL_addr = pVbl->vbList;
   // Flag it as gone for subsequent call to SnmpFreeVbl
   pVbl->vbList = NULL;
   }
SnmpFreeVbl (hNewVbl);
//
//   3.  The agent-addr field is set with the appropriate address of the
//       the sending SNMP entity, which is the IP address of the sending
//       entity of the trap goes out over UDP; otherwise the agent-addr
//       field is set to address 0.0.0.0.
newPdu->v1Trap->agent_addr.len = sizeof(DWORD);
newPdu->v1Trap->agent_addr.ptr = GlobalAlloc (GPTR, sizeof(DWORD));
if (newPdu->v1Trap->agent_addr.ptr == NULL)
   goto ERR_OUT;
if (TaskData.localAddress == 0)
   { // Get the local machine address (for outgoing v1 traps)
   char szLclHost [MAX_HOSTNAME];
   LPHOSTENT lpstHostent;
   if (gethostname (szLclHost, MAX_HOSTNAME) != SOCKET_ERROR)
      {
      lpstHostent = gethostbyname ((LPSTR)szLclHost);
      if (lpstHostent)
         TaskData.localAddress = *((LPDWORD)(lpstHostent->h_addr));
      }
   }
*(LPDWORD)newPdu->v1Trap->agent_addr.ptr = TaskData.localAddress;
// end_RFC2089
return (newPdu);
//
ERR_OUT:
SnmpFreeVbl (hNewVbl);
if (newPdu)
   {
   FreeVarBindList (newPdu->VBL_addr); // Checks for NULL
   FreeV1Trap (newPdu->v1Trap);        // Checks for NULL
   GlobalFree (newPdu);
   }
return (NULL);
} // end_MapV2TrapV1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_ut.c ===
// wsnmp_ut.c
//
// WinSNMP Utility Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980424 - BobN
//        - Mods to SnmpStrToIpxAddress() to permit '.' char
//        - as netnum/nodenum separator
// 970310 - Removed extraneous functions
//
#include "winsnmp.inc"

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetLastError (IN HSNMP_SESSION hSession)
{
	DWORD nSes;

	if (TaskData.hTask == 0)
	   return (SNMPAPI_NOT_INITIALIZED);
	nSes = HandleToUlong(hSession) - 1;
	if (snmpValidTableEntry(&SessDescr, nSes))
	{
		LPSESSION pSession = snmpGetTableEntry(&SessDescr, nSes);
		return pSession->nLastError;
	}
	else
	   return (TaskData.nLastError);
} // end_SnmpGetLastError

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpStrToOid (IN LPCSTR string,
                 OUT smiLPOID dstOID)
{
smiUINT32 i;
smiUINT32 compIdx;
SNMPAPI_STATUS lError;
CHAR c;
LPSTR pSep;

// Must be initialized
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }

// use __try, __except to figure out if 'string' is a
// valid pointer. We cannot use IsBadReadPtr() here, as far as
// we have no idea for how many octets we should look.
__try
{
    smiUINT32 sLen;

    sLen = strlen(string);
    if (sLen == 0 || sLen >= MAXOBJIDSTRSIZE)
    {
        lError = SNMPAPI_OID_INVALID;
        goto ERROR_OUT;
    }
}
__except(EXCEPTION_EXECUTE_HANDLER)
{
    lError = SNMPAPI_ALLOC_ERROR;
        goto ERROR_OUT;
}

// see if the dstOID pointer provided by the caller points to 
// a valid memory range. If null is provided, there is nothing
// the API was requested to do!
if (IsBadWritePtr (dstOID, sizeof(smiOID)))
{
   lError = (dstOID == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
}

// Ignore initial '.' in string (UNIX-ism)
if (string[0] == '.')
    string++;

// figure out how many components this OID has
// count the number of '.' in the string. The OID should 
// contain this count + 1 components
dstOID->len = 0;
pSep = (LPSTR)string;
while((pSep = strchr(pSep, '.')) != NULL)
{
    pSep++;
    dstOID->len++;
}
dstOID->len++;

// don't allow less than 2 components
if (dstOID->len < 2)
{
    lError = SNMPAPI_OID_INVALID;
    goto ERROR_OUT;
}

// allocate memory for holding the numeric OID components
// this should be released by the caller, through 'SnmpFreeDescriptor()'
dstOID->ptr = (smiLPUINT32)GlobalAlloc(GPTR, dstOID->len * sizeof(smiUINT32));
if (dstOID->ptr == NULL)
{
    lError = SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
}

compIdx = 0;
// when entering the loop, 'string' doesn't have a heading '.'
// NOTE: 123. will be accepted as 123.0
//       (123..  a12.3.4  1234....5.6) are considered as invalid OIDs instead
//        of truncated to (123.0   0   1234.0).
while (*string != '\0')
{
    dstOID->ptr[compIdx++] = strtoul(string, &pSep, 10);

    // if one of the components was overflowing, release the memory and bail out.
    if (errno == ERANGE)
    {
        errno = 0;
        lError = SNMPAPI_OID_INVALID;
        GlobalFree(dstOID->ptr);
        dstOID->ptr = NULL;
        goto ERROR_OUT;
    }

    // if strtoul did not make any progress on the string (two successive dots)
    // or it was blocked on something else than a separator or null-termination, then
    // there was an error. The OID is invalid. API return failure
    if (pSep == string ||
        (*pSep != '.' && *pSep != '\0'))
    {
        lError =  SNMPAPI_OID_INVALID; // invalid char in sequence
        if (GlobalFree (dstOID->ptr))  // returns not-NULL on error
        {
            lError = SNMPAPI_OTHER_ERROR;
            goto ERROR_OUT;
        }
        dstOID->ptr = NULL;
        dstOID->len = 0;
        goto ERROR_OUT;                                                                
    }

    // pSep can point only to '.' or '\0'
    if (*pSep == '.')
        pSep++;

    // restart with string from this point
    string = pSep;
}

if (dstOID->len < 2)
{
    GlobalFree(dstOID->ptr);
    dstOID->ptr = NULL;
    lError = SNMPAPI_OID_INVALID;
    goto ERROR_OUT;
}

return dstOID->len;

ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpStrToOid()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpOidToStr (IN smiLPCOID srcOID,
                 IN smiUINT32 strLen,
                 OUT LPSTR strPtr)
{
SNMPAPI_STATUS lError;
smiUINT32 retLen = 0;      // used for successful return
smiUINT32 oidIdx = 0;      // max subids is 128
smiUINT32 tmpLen;          // used for size of decoded string (with '.')
LPSTR tmpPtr = strPtr;     // used for advancing strPtr
char tmpBuf[64];           // enough room for 1 32-bit decode and '.'
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }

if (!strLen)
   {
   lError = SNMPAPI_SIZE_INVALID;
   goto ERROR_OUT;
   }

if (IsBadReadPtr(srcOID, sizeof(smiOID)) ||
    IsBadWritePtr(strPtr, strLen))
   {
    lError = (strPtr == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
   }

if (srcOID->len == 0 || srcOID->len > 128 ||
    IsBadReadPtr (srcOID->ptr, srcOID->len * sizeof(smiUINT32)))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }

while (oidIdx < srcOID->len)
   {
   _ultoa (srcOID->ptr[oidIdx++], tmpBuf, 10);
   lstrcat (tmpBuf, ".");
   tmpLen = lstrlen (tmpBuf);
   if (strLen < (tmpLen + 1))
      {
      tmpBuf[strLen] = '\0';
      lstrcpy (tmpPtr, tmpBuf);
      lError = SNMPAPI_OUTPUT_TRUNCATED;
      goto ERROR_OUT;
      }
   lstrcpy (tmpPtr, tmpBuf);
   strLen -= tmpLen;
   tmpPtr += tmpLen;
   retLen += tmpLen;
   }  // end_while
*(--tmpPtr) = '\0';
return (retLen);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpOidToStr

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpOidCopy (IN smiLPCOID srcOID,
                OUT smiLPOID dstOID)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (IsBadReadPtr (srcOID, sizeof(smiOID)) ||
    IsBadReadPtr (srcOID->ptr, srcOID->len) ||
    IsBadWritePtr (dstOID, sizeof(smiOID)))
   {
   lError = (dstOID == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Check input OID size
if ((srcOID->len == 0) ||(srcOID->len > MAXOBJIDSIZE))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }
// Using dstOID-> temporarily for byte count
dstOID->len = srcOID->len * sizeof(smiUINT32);
// App must free following alloc via SnmpFreeDescriptor()
if (!(dstOID->ptr = (smiLPUINT32)GlobalAlloc (GPTR, dstOID->len)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
CopyMemory (dstOID->ptr, srcOID->ptr, dstOID->len);
// Now make dstOID->len mean the right thing
dstOID->len = srcOID->len;
return (dstOID->len);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpOidCopy()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeDescriptor (IN smiUINT32 syntax,
                       IN smiLPOPAQUE ptr)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!syntax || !ptr || !ptr->ptr)
   {
   lError = SNMPAPI_OPERATION_INVALID;
   goto ERROR_OUT;
   }
switch (syntax)
   {
   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_OPAQUE:
   case SNMP_SYNTAX_OID:
   if (GlobalFree (ptr->ptr)) // returns not-NULL on error
      {
      lError = SNMPAPI_OTHER_ERROR;
      goto ERROR_OUT;
      }
   ptr->ptr = NULL;
   ptr->len = 0;
   break;

   default:
   lError = SNMPAPI_SYNTAX_INVALID;
   goto ERROR_OUT;
   } // end_switch
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
}  // end_SnmpFreeDescriptor

// SnmpOidCompare
//
// Re-worked by 3/17/95 BobN
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpOidCompare (IN smiLPCOID xOID,
                   IN smiLPCOID yOID,
                   IN smiUINT32 maxlen,
                   OUT smiLPINT result)
{
smiUINT32 i = 0;
smiUINT32 j = 0;
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (maxlen > MAXOBJIDSIZE)
   {
   lError = SNMPAPI_SIZE_INVALID;
   goto ERROR_OUT;
   }

if (IsBadReadPtr (xOID, sizeof(smiOID)) ||
    IsBadReadPtr (yOID, sizeof(smiOID)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

if (IsBadReadPtr (xOID->ptr, xOID->len * sizeof(UINT)) ||
    IsBadReadPtr (yOID->ptr, yOID->len * sizeof(UINT)))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }

// Test input pointers for readability
if (IsBadWritePtr (result, sizeof(smiINT)))
    {
    lError = (result == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
    }

j = min(xOID->len, yOID->len);
if (maxlen) j = min(j, maxlen);
while (i < j)
   {
   if (*result = xOID->ptr[i] - yOID->ptr[i]) // deliberate assignment
      return (SNMPAPI_SUCCESS);               // not equal...got a winner!
   i++;
   }
if (j == maxlen)                              // asked for a limit
   return (SNMPAPI_SUCCESS);                  // and...got a draw!
*result = xOID->len - yOID->len;              // size matters!
return SNMPAPI_SUCCESS;
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpOidCompare

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpEncodeMsg (IN HSNMP_SESSION hSession,
                  IN HSNMP_ENTITY hSrc,
                  IN HSNMP_ENTITY hDst,
                  IN HSNMP_CONTEXT hCtx,
                  IN HSNMP_PDU hPdu,
                  IN OUT smiLPOCTETS msgBufDesc)
{
smiUINT32 version = 0;
DWORD nCtx;
DWORD nPdu;
DWORD nVbl;
smiOCTETS tmpContext;
smiLPBYTE msgAddr = NULL;
smiUINT32 lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;
LPENTITY pEntSrc, pEntDst;
LPCTXT pCtxt;

// Basic error checks
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
// Check for writable output buffer
if (IsBadWritePtr (msgBufDesc, sizeof(smiOCTETS)))
   {
   lError = (msgBufDesc == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// srcEntity not currently used
if (hSrc)
   {
    if (!snmpValidTableEntry(&EntsDescr, HandleToUlong(hSrc)-1))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
    pEntSrc = snmpGetTableEntry(&EntsDescr, HandleToUlong(hSrc)-1);
   }
// dstEntity is required for *accurate* msg version info
if (hDst)
   {
   if (!snmpValidTableEntry(&EntsDescr, HandleToUlong(hDst)-1))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntDst = snmpGetTableEntry(&EntsDescr, HandleToUlong(hDst)-1);
   version = pEntDst->version-1;
   }
nCtx = HandleToUlong(hCtx) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

nPdu = HandleToUlong(hPdu) - 1;
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
ERROR_PDU:
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

// Necessary PDU data checks
nVbl = HandleToUlong(pPdu->VBL);
if (!snmpValidTableEntry(&VBLsDescr, nVbl-1))
   goto ERROR_PDU;
// Check out for SNMPv1 Trap PDU type...uses different PDU structure!
// ???
// Check for SNMPv2c PDU types
if (pPdu->type == SNMP_PDU_TRAP ||
    pPdu->type == SNMP_PDU_INFORM)
   version = 1;
// Now Build it
tmpContext.len = pCtxt->commLen;
tmpContext.ptr = pCtxt->commStr;
if (!(BuildMessage (version, &tmpContext,
                    pPdu, pPdu->appReqId,
                    &msgAddr, &msgBufDesc->len)))
   goto ERROR_PDU;
// Copy Snmp message to caller's buffer...
// App must free following alloc via SnmpFreeDescriptor()
if (!(msgBufDesc->ptr = (smiLPBYTE)GlobalAlloc (GPTR, msgBufDesc->len)))
   lError = SNMPAPI_ALLOC_ERROR;
else // SUCCESS
   CopyMemory (msgBufDesc->ptr, msgAddr, msgBufDesc->len);
ERROR_OUT:
// Clean up
if (msgAddr)
   GlobalFree (msgAddr);
if (lError == SNMPAPI_SUCCESS)
   return (msgBufDesc->len);
else // Failure cases
   return (SaveError (lSession, lError));
}

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpDecodeMsg (IN HSNMP_SESSION hSession,
                  OUT LPHSNMP_ENTITY hSrc,
                  OUT LPHSNMP_ENTITY hDst,
                  OUT LPHSNMP_CONTEXT hCtx,
                  OUT LPHSNMP_PDU hPdu,
                  IN smiLPCOCTETS msgPtr)
{
DWORD nPdu;
smiLPOCTETS community;
smiUINT32 version;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// Valid session...save for possible error return
lSession = hSession;

if (IsBadReadPtr(msgPtr, sizeof(smiOCTETS)) ||
    IsBadReadPtr(msgPtr->ptr, msgPtr->len))
{
    lError = SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
}

if (hSrc == NULL && hDst == NULL && hCtx == NULL && hPdu == NULL)
{
    lError = SNMPAPI_NOOP;
    goto ERROR_OUT;
}

if ((hDst != NULL && IsBadWritePtr(hDst, sizeof(HSNMP_ENTITY))) ||
    (hSrc != NULL && IsBadWritePtr(hSrc, sizeof(HSNMP_ENTITY))))
{
    lError = SNMPAPI_ENTITY_INVALID;
    goto ERROR_OUT;
}

if (hCtx != NULL && IsBadWritePtr(hCtx, sizeof(HSNMP_CONTEXT)))
{
    lError = SNMPAPI_CONTEXT_INVALID;
    goto ERROR_OUT;
}

if (IsBadWritePtr(hPdu, sizeof(HSNMP_PDU)))
{
    lError = SNMPAPI_PDU_INVALID;
    goto ERROR_OUT;
}

EnterCriticalSection (&cs_PDU);
lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

if (ParseMessage (msgPtr->ptr, msgPtr->len, &version, &community, pPdu))
   { // non-zero = some error code
   lError = SNMPAPI_MESSAGE_INVALID;
   SnmpFreePdu((HSNMP_PDU) ULongToPtr(nPdu+1));
   goto ERROR_PRECHECK;
   }
if (hDst != NULL) *hDst = 0;
if (hSrc != NULL) *hSrc = 0;
if (hCtx != NULL)
   {
   smiUINT32 nMode;
   EnterCriticalSection (&cs_XMODE);
   SnmpGetTranslateMode (&nMode);
   SnmpSetTranslateMode (SNMPAPI_UNTRANSLATED_V1);
   if ((*hCtx = SnmpStrToContext (hSession, community)) == SNMPAPI_FAILURE)
      {
      LeaveCriticalSection (&cs_XMODE);
      lError = SNMPAPI_OTHER_ERROR;
      FreeOctetString (community);
      SnmpFreePdu((HSNMP_PDU) ULongToPtr(nPdu+1));
      goto ERROR_PRECHECK;
      }
   SnmpSetTranslateMode (nMode);
   LeaveCriticalSection (&cs_XMODE);
   }
FreeOctetString (community);
pPdu->Session  = hSession;
if (hPdu != NULL)
    *hPdu = (HSNMP_PDU) ULongToPtr(nPdu+1);
else
    SnmpFreePdu((HSNMP_PDU) ULongToPtr(nPdu+1));

ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);
if (lError == SNMPAPI_SUCCESS)
{
   SaveError(lSession, lError);
   return (msgPtr->len);
}

ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpDecodeMsg()

#define NETLEN  4
#define NODELEN 6
char *cHexDigits = "0123456789ABCDEF";
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpStrToIpxAddress (LPCSTR str, LPBYTE netnum, LPBYTE nodenum)
{
LPSTR netPtr, nodePtr, pStr;
DWORD i, j;
char tmpStr[24+1];
BYTE c1, c2;
if (!str || !netnum || !nodenum)
   return (SNMPAPI_FAILURE);
strncpy (tmpStr, str,24);
tmpStr[24] = '\0';
netPtr = strtok (tmpStr, "-:.");
if (netPtr == NULL)
   return (SNMPAPI_FAILURE);
if (lstrlen (netPtr) != NETLEN*2)
   return (SNMPAPI_FAILURE);
nodePtr = netPtr + (NETLEN*2) + 1;
if (lstrlen (nodePtr) != NODELEN*2)
   return (SNMPAPI_FAILURE);
_strupr (netPtr);
for (i = 0, j = 0; j < NETLEN; j++)
   {
   pStr = strchr (cHexDigits, netPtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c1 = (BYTE)(pStr - cHexDigits);
   pStr = strchr (cHexDigits, netPtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c2 = (BYTE)(pStr - cHexDigits);
   netnum[j] = c2 | c1 << 4;
   }
_strupr (nodePtr);
for (i = 0, j = 0; j < NODELEN; j++)
   {
   pStr = strchr (cHexDigits, nodePtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c1 = (BYTE)(pStr - cHexDigits);
   pStr = strchr (cHexDigits, nodePtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c2 = (BYTE)(pStr - cHexDigits);
   nodenum[j] = c2 | c1 << 4;
   }
return (SNMPAPI_SUCCESS);
}

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpIpxAddressToStr (LPBYTE netnum, LPBYTE nodenum, LPSTR str)
{
DWORD i, j;
for (i = 0, j = 0; i < NETLEN; i++)
   {
   str[j++] = cHexDigits[(netnum[i] & 0xF0) >> 4];
   str[j++] = cHexDigits[netnum[i] & 0x0F];
   }
str[j++] = ':';
for (i = 0; i < NODELEN; i++)
   {
   str[j++] = cHexDigits[(nodenum[i] & 0xF0) >> 4];
   str[j++] = cHexDigits[nodenum[i] & 0x0F];
   }
str[j] = '\0';
return (SNMPAPI_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_sp.c ===
// wsnmp_sp.c
//
// Special functions for the WinSNMP library
// Copyright 1998 ACE*COMM Corp
//
// Bob Natale (bnatale@acecomm.com)
//
#include "winsnmp.inc"

__declspec(dllexport)
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetAgentAddress (LPSTR agentAddress)
{
DWORD tmpAddress = 0;
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// A null arg resets the localAddress trigger value
if (agentAddress == NULL)
   goto DONE;
// Otherwise, convert to IP address
tmpAddress = inet_addr (agentAddress);
if (tmpAddress == INADDR_NONE)
   { // Invalid IP addresses cannot be accepted
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
DONE:
// Plug new agent_address value into localAddress
// for future v1 trap sends
EnterCriticalSection (&cs_TASK);
TaskData.localAddress = tmpAddress;
LeaveCriticalSection (&cs_TASK);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}

__declspec(dllexport)
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpConveyAgentAddress (SNMPAPI_STATUS mode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// mode can only be on or off...
if (mode != SNMPAPI_ON)
   mode = SNMPAPI_OFF;  // ...force off if not on
EnterCriticalSection (&cs_TASK);
TaskData.conveyAddress = mode;
LeaveCriticalSection (&cs_TASK);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\inc\pragmas.h ===
#ifndef _PRAGMAS_H_
#define _PRAGMAS_H_
#pragma warning (disable : 4001) // single  line comments
//
// pragma.h
//
// Utility include for NetPlus WinSNMP
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
#define __export
#define WAKRELVER "Release 3.MS"
#define WAKRELDATE "19970221" 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\exe\snmptrap.c ===
// snmptrap.c
//
// Original Microsoft code modified by ACE*COMM
// for use with WSNMP32.DLL and other trap receiving
// clients, per contract.
//
// Bob Natale, ACE*COMM (bnatale@acecomm.com)
// For NT v5 Beta, v970228
// Additional enhancements planned.
//
// This version of SNMPTRAP has no dependencies
// on either MGMTAPI.DLL or WSNMP32.DLL.
//
// WinSNMP clients use the SnmpRegister() function.
//
// Other clients will need to match the following
// values and structures:
//
//    SNMP_TRAP structure
//    SNMPTRAPPIPE name
//    TRAPBUFSIZE value
//
// Change log:
// ------------------------------------------------
// 4.0.1381.3  Apr 8, 1998 Bob Natale
//
// 1.  Re-worked the trap port monitoring thread into
//     two threads...one for IP and one for IPX, to
//     comply with WinSock v2's restrictions against
//     multi-protocol select().
//
// 2.  General clean-up/streamlining wrt "legacy" code
//     from original MS version...more to do here, esp.
//     wrt error handling code that does not do anything.
// ------------------------------------------------
// 4.0.1381.4  Apr. 10, 1998 Bob Natale
//
// 1.  Replaced mutex calls with critical_sectin calls.
//
// 2.  Cleaned out some dead code (removed commented out code)
// ------------------------------------------------
// Jan. 2, 2001 Frank Li
// 1. remove TerminateThread
// 2. add debug build loggings
// ------------------------------------------------
#include <windows.h>
#include <winsock.h>
#include <wsipx.h>
#include <process.h>

#ifdef DBG // include files for debug trace only
#include <stdio.h>
#include <time.h>
#endif

//--------------------------- PRIVATE VARIABLES -----------------------------
#define SNMPMGRTRAPPIPE "\\\\.\\PIPE\\MGMTAPI"
#define MAX_OUT_BUFS    16
#define TRAPBUFSIZE     4096
#define IP_TRAP_PORT    162
#define IPX_TRAP_PORT   36880
#define SNMPTRAP_WAIT_HINT 20000

//
// constants added to allocate trap buffer for fixing trap data of length 
// > 8192 bytes. Here is the buffer allocation scheme based on the common
// cases that trap data sizes are less than 4-KBytes:
// 1. LargeTrap 
//    if (trap data size >= 8192 bytes), allocate MAX_UDP_SIZE sized buffer
// 2. MediumTrap
//    if (trap data size <= 4096 bytes), allocate FOUR_K_BUF_SIZE sized buffer
// 3. SmallTrap
//    if (4096 < trap data size < 8192), allocate just enough buffer size.
// Note:
// - when LargeTrap is received, the allocated buffer will stay for a time of
//   MAXUDPLEN_BUFFER_TIME from the last LargeTrap received.
// - Once MediumTrap is received, subsequent SmallTrap will reuse the
//   last MediumTrap allocated buffer. 
//
#define MAX_UDP_SIZE    (65535-8)  // max udp len - 8bytes udp header
#define MAX_FIONREAD_UDP_SIZE 8192 // max winsock FIONREAD reported size (8kB)
#define FOUR_K_BUF_SIZE   4096       // buffer of 4-KBytes in size
#define MAXUDPLEN_BUFFER_TIME (2*60*1000)  // max. 2 mins to keep the
                                           // last allocated large buffer.   
// ******** INITIALIZE A LIST HEAD ********
#define ll_init(head) (head)->next = (head)->prev = (head);
// ******** TEST A LIST FOR EMPTY ********
#define ll_empt(head) ( ((head)->next) == (head) )
// ******** Get ptr to next entry ********
#define ll_next(item,head)\
( (ll_node *)(item)->next == (head) ? 0 : \
(ll_node *)(item)->next )
// ******** Get ptr to prev entry ********
#define ll_prev(item)\
( (ll_node *)(item)->prev )
// ******** ADD AN ITEM TO THE END OF A LIST ********
#define ll_adde(item,head)\
   {\
   ll_node *pred = (head)->prev;\
   ((ll_node *)(item))->next = (head);\
   ((ll_node *)(item))->prev = pred;\
   (pred)->next = ((ll_node *)(item));\
   (head)->prev = ((ll_node *)(item));\
   }
// ******** REMOVE AN ITEM FROM A LIST ********
#define ll_rmv(item)\
   {\
   ll_node *pred = ((ll_node *)(item))->prev;\
   ll_node *succ = ((ll_node *)(item))->next;\
   pred->next = succ;\
   succ->prev = pred;\
   }
// ******** List head/node ********
typedef struct ll_s
   { // linked list structure
   struct  ll_s *next;  // next node
   struct  ll_s *prev;  // prev. node
   } ll_node;           // linked list node
typedef struct
   {// shared by server trap thread and pipe thread
   ll_node  links;
   HANDLE   hPipe;
   } svrPipeListEntry;
typedef struct
   {
   SOCKADDR Addr;              
   int      AddrLen;           
   UINT     TrapBufSz;
   char     TrapBuf[TRAPBUFSIZE];   // the size of this array should match the size of the structure
                                    // defined in wsnmp_no.c!!!
   }        SNMP_TRAP, *PSNMP_TRAP;
typedef struct
{
    SOCKET s;
    OVERLAPPED ol;
} TRAP_THRD_CONTEXT, *PTRAP_THRD_CONTEXT;

HANDLE hExitEvent = NULL;
LPCTSTR svcName = "SNMPTRAP";
SERVICE_STATUS_HANDLE hService = 0;
SERVICE_STATUS status =
  {SERVICE_WIN32, SERVICE_STOPPED, SERVICE_ACCEPT_STOP, NO_ERROR, 0, 0, 0};
SOCKET ipSock = INVALID_SOCKET;
SOCKET ipxSock = INVALID_SOCKET;
HANDLE ipThread = NULL;
HANDLE ipxThread = NULL;
CRITICAL_SECTION cs_PIPELIST;
ll_node *pSvrPipeListHead = NULL;

// global variables added to remove the TerminateThread call
OVERLAPPED g_ol; // overlapped struct for svrPipeThread
TRAP_THRD_CONTEXT g_ipThreadContext;  // context for ip svrTrapThread
TRAP_THRD_CONTEXT g_ipxThreadContext; // context for ipx svrTrapThread

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMPTRAP Debugging Prototypes                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#if DBG
VOID
WINAPI
SnmpTrapDbgPrint(
    IN LPSTR szFormat,
    IN ...
    );
#define SNMPTRAPDBG(_x_)                    SnmpTrapDbgPrint _x_
#else
#define SNMPTRAPDBG(_x_)
#endif

//--------------------------- PRIVATE PROTOTYPES ----------------------------
DWORD WINAPI svrTrapThread (IN OUT LPVOID threadParam);
DWORD WINAPI svrPipeThread (IN LPVOID threadParam);
VOID WINAPI svcHandlerFunction (IN DWORD dwControl);
VOID WINAPI svcMainFunction (IN DWORD dwNumServicesArgs,
                             IN LPSTR *lpServiceArgVectors);
void FreeSvrPipeEntryList(IN ll_node* head);

//--------------------------- PRIVATE PROCEDURES ----------------------------
VOID WINAPI svcHandlerFunction (IN DWORD dwControl)
{
    if (dwControl == SERVICE_CONTROL_STOP)
    {
        status.dwCurrentState = SERVICE_STOP_PENDING;
        status.dwCheckPoint++;
        status.dwWaitHint = SNMPTRAP_WAIT_HINT;
        if (!SetServiceStatus(hService, &status))
            exit(1);
        // set event causing trap thread to terminate
        if (!SetEvent(hExitEvent))
        {
            status.dwCurrentState = SERVICE_STOPPED;
            status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
            status.dwServiceSpecificExitCode = 1; // OPENISSUE - svc err code
            status.dwCheckPoint = 0;
            status.dwWaitHint = 0;
            // We are exiting in any case, so ignore any error...
            SetServiceStatus (hService, &status);
            exit(1);
        }
    }
    else
    //   dwControl == SERVICE_CONTROL_INTERROGATE
    //   dwControl == SERVICE_CONTROL_PAUSE
    //   dwControl == SERVICE_CONTROL_CONTINUE
    //   dwControl == <anything else>
    {
        if (status.dwCurrentState == SERVICE_STOP_PENDING ||
            status.dwCurrentState == SERVICE_START_PENDING)
            status.dwCheckPoint++;
        if (!SetServiceStatus (hService, &status))
            exit(1);
    }
} // end_svcHandlerFunction()

VOID WINAPI svcMainFunction (IN DWORD dwNumServicesArgs,
                             IN LPSTR *lpServiceArgVectors)
{
    WSADATA WinSockData;
    HANDLE  hPipeThread = NULL;
    DWORD   dwThreadId;
    //---------------------------------------------------------------------
    hService = RegisterServiceCtrlHandler (svcName, svcHandlerFunction);
    if (hService == 0)
    {
        // We are exiting in any case, so ignore any error...
        SNMPTRAPDBG((
            "svcMainFunction: RegisterServiceCtrlHandler error 0x%08lx .\n",
            GetLastError() 
            ));
        exit(1);
    }
    status.dwCurrentState = SERVICE_START_PENDING;
    status.dwWaitHint = SNMPTRAP_WAIT_HINT;

    if (!SetServiceStatus(hService, &status))
        exit(1);

    __try
    {
        InitializeCriticalSection (&cs_PIPELIST);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        exit(1);
    }

    memset(&g_ipThreadContext.ol, 0, sizeof(g_ipThreadContext.ol));
    memset(&g_ipxThreadContext.ol, 0, sizeof(g_ipxThreadContext.ol));

    if (WSAStartup ((WORD)0x0101, &WinSockData))
        goto CLOSE_OUT; // WinSock startup failure


    // allocate linked-list header for client received traps
    if ((pSvrPipeListHead = (ll_node *)GlobalAlloc (GPTR, sizeof(ll_node))) == NULL)
        goto CLOSE_OUT;
    ll_init(pSvrPipeListHead);
    if ((hPipeThread = (HANDLE)_beginthreadex
                    (NULL, 0, svrPipeThread, NULL, 0, &dwThreadId)) == 0)
        goto CLOSE_OUT;
    
    //-----------------------------------------------------------------------------------
    //CHECK_IP:
    ipSock = socket (AF_INET, SOCK_DGRAM, 0);
    if (ipSock != INVALID_SOCKET)
    {
        struct sockaddr_in localAddress_in;
        struct servent *serv;
        ZeroMemory (&localAddress_in, sizeof(localAddress_in));
        localAddress_in.sin_family = AF_INET;
        if ((serv = getservbyname ("snmp-trap", "udp")) == NULL)
            localAddress_in.sin_port = htons (IP_TRAP_PORT);
        else
            localAddress_in.sin_port = (SHORT)serv->s_port;
        localAddress_in.sin_addr.s_addr = htonl (INADDR_ANY);
        if (bind (ipSock, (LPSOCKADDR)&localAddress_in, sizeof(localAddress_in)) != SOCKET_ERROR)
        {
            g_ipThreadContext.s = ipSock;
            // init the overlapped struct with manual reset non-signaled event
            g_ipThreadContext.ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == g_ipThreadContext.ol.hEvent)    
                goto CLOSE_OUT;    
            
            ipThread = (HANDLE)_beginthreadex
                    (NULL, 0, svrTrapThread, (LPVOID)&g_ipThreadContext, 0, &dwThreadId);
        }
    }
    //-----------------------------------------------------------------------------------
    //CHECK_IPX:
    ipxSock = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
    if (ipxSock != INVALID_SOCKET)
    {
        struct sockaddr_ipx localAddress_ipx;
        ZeroMemory (&localAddress_ipx, sizeof(localAddress_ipx));
        localAddress_ipx.sa_family = AF_IPX;
        localAddress_ipx.sa_socket = htons (IPX_TRAP_PORT);
        if (bind (ipxSock, (LPSOCKADDR)&localAddress_ipx, sizeof(localAddress_ipx)) != SOCKET_ERROR)
        {
            g_ipxThreadContext.s = ipxSock;
            // init the overlapped struct with manual reset non-signaled event
            g_ipxThreadContext.ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == g_ipxThreadContext.ol.hEvent)
                goto CLOSE_OUT;    
             
            ipxThread = (HANDLE)_beginthreadex
                    (NULL, 0, svrTrapThread, (LPVOID)&g_ipxThreadContext, 0, &dwThreadId);
        }
    }
    //-----------------------------------------------------------------------------------
    // We are ready to listen for traps...
    status.dwCurrentState = SERVICE_RUNNING;
    status.dwCheckPoint   = 0;
    status.dwWaitHint     = 0;
    if (!SetServiceStatus(hService, &status))
        goto CLOSE_OUT;
    WaitForSingleObject (hExitEvent, INFINITE);
    //-----------------------------------------------------------------------------------
CLOSE_OUT:
    
    // make sure we can bail out if we are here because of goto statements above
    SetEvent(hExitEvent); 

    status.dwCurrentState = SERVICE_STOP_PENDING; // in case we need to report
    // reporting progress in stopping service
    status.dwCheckPoint++;
    if (!SetServiceStatus(hService, &status))
    {
        SNMPTRAPDBG((
            "svcMainFunction: error 0x%08lx setting service status.\n",
            GetLastError() 
            ));
    }
    
    if (hPipeThread != NULL)
    {
        SNMPTRAPDBG(("svcMainFunction: enter SetEvent g_ol.hEvent.\n"));
        SetEvent(g_ol.hEvent); // signal to terminate the svrPipeThread thread
        WaitForSingleObject (hPipeThread, INFINITE);
        SNMPTRAPDBG(("svcMainFunction: WaitForSingleObject hPipeThread INFINITE done.\n"));
        // reporting progress in stopping service
        status.dwCheckPoint++;
        if (!SetServiceStatus(hService, &status))
        {
            SNMPTRAPDBG((
                "svcMainFunction: error 0x%08lx setting service status.\n",
                GetLastError() 
                ));
        }
        CloseHandle (hPipeThread);
    }


    if (ipThread != NULL)
    {
        SNMPTRAPDBG(("svcMainFunction: enter SetEvent g_ipThreadContext.ol.hEvent.\n"));
        SetEvent(g_ipThreadContext.ol.hEvent); // signal to terminate thread
        WaitForSingleObject (ipThread, INFINITE);
        // reporting progress in stopping service
        status.dwCheckPoint++;
        if (!SetServiceStatus(hService, &status))
        {
            SNMPTRAPDBG((
                "svcMainFunction: error 0x%08lx setting service status.\n",
                GetLastError() 
                ));
        }
        CloseHandle (ipThread);
    }
    if (ipSock != INVALID_SOCKET)
        closesocket (ipSock);
    if (g_ipThreadContext.ol.hEvent)
        CloseHandle(g_ipThreadContext.ol.hEvent);


    if (ipxThread != NULL)
    {
        SNMPTRAPDBG(("svcMainFunction: enter SetEvent g_ipxThreadContext.ol.hEvent.\n"));
        SetEvent(g_ipxThreadContext.ol.hEvent); // signal to terminate thread
        WaitForSingleObject (ipxThread, INFINITE);
        // reporting progress in stopping service
        status.dwCheckPoint++;
        if (!SetServiceStatus(hService, &status))
        {
            SNMPTRAPDBG((
                "svcMainFunction: error 0x%08lx setting service status.\n",
                GetLastError() 
                ));
        }
        CloseHandle (ipxThread);
    }
    if (ipxSock != INVALID_SOCKET)
        closesocket (ipxSock);
    if (g_ipxThreadContext.ol.hEvent)
        CloseHandle(g_ipxThreadContext.ol.hEvent);

    EnterCriticalSection (&cs_PIPELIST);
    if (pSvrPipeListHead != NULL)
    {
        FreeSvrPipeEntryList(pSvrPipeListHead);
        pSvrPipeListHead = NULL;
    }
    LeaveCriticalSection (&cs_PIPELIST);
    
    DeleteCriticalSection (&cs_PIPELIST);
    WSACleanup();
    
    status.dwCurrentState = SERVICE_STOPPED;
    status.dwCheckPoint = 0;
    status.dwWaitHint = 0;
    if (!SetServiceStatus(hService, &status))
        exit(1);
} // end_svcMainFunction()

//--------------------------- PUBLIC PROCEDURES -----------------------------
int __cdecl main ()
{
    BOOL fOk;
    SERVICE_TABLE_ENTRY svcStartTable[2] =
    {
        {(LPTSTR)svcName, svcMainFunction},
        {NULL, NULL}
    };
    
    // create event to synchronize trap server shutdown
    hExitEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
    if (NULL == hExitEvent)
    {
        exit(1);
    }
    // init the overlapped struct used by svrTrapThread
    // with manual reset non-signaled event
    memset(&g_ol, 0, sizeof(g_ol));
    g_ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_ol.hEvent)
    {
        CloseHandle(hExitEvent);
        exit(1);
    }
    // this call will not return until service stopped
    fOk = StartServiceCtrlDispatcher (svcStartTable);
    CloseHandle (hExitEvent);
    CloseHandle(g_ol.hEvent);
    
    return fOk; 
} // end_main()

//
DWORD WINAPI svrTrapThread (LPVOID threadParam)
// This thread takes a SOCKET from the TRAP_THRD_CONTEXT parameter, 
// loops on select()
// for data in-coming over that socket, writing it back
// out to clients over all pipes currently on the list of
// trap notification pipes shared by this thread and the
// pipe thread
{
    PSNMP_TRAP pRecvTrap = NULL;
    struct fd_set readfds;
    PTRAP_THRD_CONTEXT pThreadContext = (PTRAP_THRD_CONTEXT) threadParam;
    SOCKET fd = INVALID_SOCKET;
    int len;
    DWORD dwLastAllocatedUdpDataLen = 0;  // the last allocated UDP data buffer size
    DWORD dwLastBigBufferRequestTime = 0; // the tick count that the last  
                                          // LargeTrap received
    BOOL fTimeoutForMaxUdpLenBuffer = FALSE; // need to deallocate the big buffer
    struct timeval tvTimeout;             // timeout for select
    

    //
    if (NULL == pThreadContext)
        return 0;
    fd = pThreadContext->s;
    dwLastBigBufferRequestTime = GetTickCount();
    
    // select with timeout so that we can response to SERVICE_CONTROL_STOP
    tvTimeout.tv_sec = 5;  // 5 sec. timeout value
    tvTimeout.tv_usec = 0; // When select returns, the contents of the
                           // tvTimeout structure are not altered.
    while (TRUE)
    {

        ULONG ulTrapSize = 0;
        DWORD dwError = 0;
        int nRet = 0;

        if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
        {
            SNMPTRAPDBG(("svrTrapThread: exit 0.\n"));
            break;
        }

        // construct readfds which gets destroyed by select()
        FD_ZERO(&readfds);
        FD_SET(fd, &readfds);

        nRet = select (0, &readfds, NULL, NULL, &tvTimeout);            
        if (0 == nRet)
        {
            // timeout
            continue;
        }
        else if (SOCKET_ERROR == nRet)
        {
            SNMPTRAPDBG(("svrTrapThread: select failed %d.\n", WSAGetLastError()));
            break; // terminate thread
        }
        
        if (!(FD_ISSET(fd, &readfds)))
            continue;

        if (ioctlsocket(
                    fd,              // socket to query
                    FIONREAD,        // query for the size of the incoming datagram
                    &ulTrapSize      // unsigned long to store the size of the datagram
                    ) != 0)
        {
            dwError = WSAGetLastError();
            SNMPTRAPDBG((
                "ioctlsocket FIONREAD failed: lasterror: 0x%08lx\n", 
                dwError));

            continue;              // continue if we could not determine the size of the
                                   // incoming datagram
        }
        
        if (ulTrapSize >= MAX_FIONREAD_UDP_SIZE)
        {
            dwLastBigBufferRequestTime = GetTickCount(); // update tickcount
            
            // the ulTrapSize is not accurate on reporting the size of the 
            // next UDP datagram message. KB Q192599 and KB Q140263
            if ( NULL == pRecvTrap ||
                 dwLastAllocatedUdpDataLen < MAX_UDP_SIZE )
            {
                if (pRecvTrap)
                {
                    GlobalFree(pRecvTrap);
                    pRecvTrap = NULL;
                    dwLastAllocatedUdpDataLen = 0;
                }
                SNMPTRAPDBG((
                    "allocate LargeTrap of size : %d\n", 
                    sizeof(SNMP_TRAP) - TRAPBUFSIZE + MAX_UDP_SIZE));
                // allocate for the trap header + max udp size
                pRecvTrap = (PSNMP_TRAP)GlobalAlloc(GPTR, (sizeof(SNMP_TRAP) - 
                                                TRAPBUFSIZE + MAX_UDP_SIZE));
                if (NULL == pRecvTrap)
                {
                    SNMPTRAPDBG(("svrTrapThread: GlobalAlloc failed.\n"));
                    dwLastAllocatedUdpDataLen = 0;
                    break;       
                }      
                dwLastAllocatedUdpDataLen = MAX_UDP_SIZE;
            }
        }
        else
        {
            // winsock has reported the exact amount of UDP datagram 
            // size to be recieved as long as the next datagram is less than
            // 8-kbyte

            //
            // if we've allocated a big buffer before, check to see if we need
            // to deallocate it to save the usage of resource.
            //
            fTimeoutForMaxUdpLenBuffer = FALSE; // reset timeout flag
            if (MAX_UDP_SIZE == dwLastAllocatedUdpDataLen)
            {
                // we've allocated a big buffer before
                DWORD dwCurrTime = GetTickCount();
                if (dwCurrTime < dwLastBigBufferRequestTime)
                {
                    // wrap around occured. we just simply assume it is time to 
                    // release the big buffer.
                    fTimeoutForMaxUdpLenBuffer = TRUE;
                    SNMPTRAPDBG((
                        "Timeout to free LargeTrap buffer of size %d bytes.\n",
                                dwLastAllocatedUdpDataLen));
                }
                else
                {
                    if ( (dwCurrTime-dwLastBigBufferRequestTime) > 
                         MAXUDPLEN_BUFFER_TIME )
                    {
                        // after quite a long time, we don't have a large UDP
                        // datagram received.
                        fTimeoutForMaxUdpLenBuffer = TRUE;
                        SNMPTRAPDBG((
                            "Timeout to free LargeTrap buffer size of %d bytes.\n",
                            dwLastAllocatedUdpDataLen));
                    }
                }
            }

            if (pRecvTrap == NULL ||
                fTimeoutForMaxUdpLenBuffer ||
                dwLastAllocatedUdpDataLen < ulTrapSize)
            {
                // allocate/reallocate buffer
                if (pRecvTrap != NULL)
                {
                    GlobalFree(pRecvTrap);
                    pRecvTrap = NULL;
                    dwLastAllocatedUdpDataLen = 0;
                }
                
                if (FOUR_K_BUF_SIZE >= ulTrapSize)
                {
                    // allocate at least 4 KBytes buffer to avoid 
                    // re-allocations on different sizes of small trap received
                    pRecvTrap = (PSNMP_TRAP)GlobalAlloc(GPTR, (sizeof(SNMP_TRAP) - 
                                                TRAPBUFSIZE + FOUR_K_BUF_SIZE));
                    dwLastAllocatedUdpDataLen = FOUR_K_BUF_SIZE; 
                    SNMPTRAPDBG((
                        "allocate SmallTrap of size : %d\n", 
                        sizeof(SNMP_TRAP) - TRAPBUFSIZE + FOUR_K_BUF_SIZE));
                }
                else
                {
                    // allocate what is necessary
                    pRecvTrap = (PSNMP_TRAP)GlobalAlloc(GPTR, (sizeof(SNMP_TRAP) - 
                                                TRAPBUFSIZE + ulTrapSize));
                    dwLastAllocatedUdpDataLen = ulTrapSize;
                    SNMPTRAPDBG((
                        "allocate MediumTrap of size : %d\n", 
                        sizeof(SNMP_TRAP) - TRAPBUFSIZE + ulTrapSize));
                }
                if (NULL == pRecvTrap) // if there is so few memory that we can't allocate a bit ..
                {                      // bail out and stop the SNMPTRAP service (bug? - other option => 100% CPU which is worst)
                    SNMPTRAPDBG(("svrTrapThread: GlobalAlloc failed.\n"));
                    dwLastAllocatedUdpDataLen = 0;
                    break;       
                }       
            }
        }

        pRecvTrap->TrapBufSz = dwLastAllocatedUdpDataLen; // actual buffer size
        pRecvTrap->AddrLen = sizeof(pRecvTrap->Addr);

        len = recvfrom (
                fd,
                pRecvTrap->TrapBuf,
                pRecvTrap->TrapBufSz,
                0, 
                &(pRecvTrap->Addr),
                &(pRecvTrap->AddrLen));
        
        if (len == SOCKET_ERROR)
        {
            dwError = WSAGetLastError();
            SNMPTRAPDBG((
                "recvfrom failed: ulTrapSize: %d bytes, TrapBufSz: %d bytes, lasterror: 0x%08lx\n", 
                ulTrapSize, pRecvTrap->TrapBufSz, dwError));
            continue;
        }

        EnterCriticalSection (&cs_PIPELIST);
        pRecvTrap->TrapBufSz = len; // the acutal trap data len received
        // add header to length
        len += sizeof(SNMP_TRAP) - sizeof(pRecvTrap->TrapBuf); // - TRAPBUFSIZE
        if (!ll_empt(pSvrPipeListHead))
        {
            DWORD written;
            ll_node *item = pSvrPipeListHead;
            while (item = ll_next(item, pSvrPipeListHead))
            {
                if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
                {
                    SNMPTRAPDBG(("svrTrapThread: exit 1.\n"));
                    LeaveCriticalSection (&cs_PIPELIST);
                    goto EXIT_TRAP_THREAD;
                }
                if (!WriteFile(
                        ((svrPipeListEntry *)item)->hPipe,
                        (LPBYTE)pRecvTrap,
                        len,
                        &written,
                        &pThreadContext->ol))
                {
                    if (ERROR_IO_PENDING == GetLastError())
                    {
                        SNMPTRAPDBG(("svrTrapThread: before GetOverlappedResult.\n"));
                        GetOverlappedResult(
                            ((svrPipeListEntry *)item)->hPipe,
                            &pThreadContext->ol,
                            &written,
                            TRUE // Block
                            );
                        SNMPTRAPDBG(("svrTrapThread: after GetOverlappedResult.\n"));
                        if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
                        {
                            SNMPTRAPDBG(("svrTrapThread: exit 2.\n"));
                            LeaveCriticalSection (&cs_PIPELIST);
                            goto EXIT_TRAP_THREAD;
                        }
                        // reset event to non-signaled state for next I/O
                        ResetEvent(pThreadContext->ol.hEvent);
                    }
                    else
                    {
                        ll_node *hold;

                        if (!DisconnectNamedPipe(((svrPipeListEntry *)item)->hPipe))
                        {
                            ; // Placeholder for error handling
                        }
                        if (!CloseHandle(((svrPipeListEntry *)item)->hPipe))
                        {
                            ; // Placeholder for error handling
                        }
                        hold = ll_prev(item);
                        ll_rmv(item);
                        GlobalFree(item); // check for errors?
                        item = hold;
                    }
                } // end_if !WriteFile
                else if (written != (DWORD)len)
                {
                    SNMPTRAPDBG(("svrTrapThread: written != len\n"));
                    ; // Placeholder for error handling
                }
            } // end_while item = ll_next
        } // end_if !ll_empt
        LeaveCriticalSection (&cs_PIPELIST);
    } // end while TRUE

EXIT_TRAP_THREAD:
   if (pRecvTrap != NULL)
       GlobalFree(pRecvTrap);

   return 0;
} // end svrTrapThread()

PACL AllocGenericACL()
{
    PACL                        pAcl;
    PSID                        pSidAdmins, pSidUsers, pSidLocalService;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;
    DWORD                       dwAclLength;

    pSidAdmins = pSidUsers = pSidLocalService = NULL;

    // Bug# 179644 The SNMP trap service should not run in the LocalSystem account
    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ) ||
         !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidUsers ) ||
         !AllocateAndInitializeSid( &Authority,
                                    1,
                                    SECURITY_LOCAL_SERVICE_RID,
                                    0,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidLocalService ))
    {
        if (pSidAdmins)
        {
            FreeSid(pSidAdmins);
        }
        if (pSidUsers)
        {
            FreeSid(pSidUsers);
        }
        return NULL;
    }

    dwAclLength = sizeof(ACL) + 
                  sizeof(ACCESS_ALLOWED_ACE) -
                  sizeof(ULONG) +
                  GetLengthSid(pSidAdmins) +
                  sizeof(ACCESS_ALLOWED_ACE) - 
                  sizeof(ULONG) +
                  GetLengthSid(pSidUsers) +
                  sizeof(ACCESS_ALLOWED_ACE) - 
                  sizeof(ULONG) +
                  GetLengthSid(pSidLocalService);

    pAcl = GlobalAlloc (GPTR, dwAclLength);
    if (pAcl != NULL)
    {
        if (!InitializeAcl( pAcl, dwAclLength, ACL_REVISION) ||
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_READ | GENERIC_WRITE,
                                   pSidLocalService ) || 
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_READ | GENERIC_WRITE,
                                   pSidAdmins ) || 
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   (GENERIC_READ | (FILE_GENERIC_WRITE & ~FILE_CREATE_PIPE_INSTANCE)),
                                   pSidUsers ))
        {
            GlobalFree(pAcl);
            pAcl = NULL;
        }
    }

    FreeSid(pSidAdmins);
    FreeSid(pSidUsers);
    FreeSid(pSidLocalService);

    return pAcl;
}

void FreeGenericACL( PACL pAcl)
{
    if (pAcl != NULL)
        GlobalFree(pAcl);
}

DWORD WINAPI svrPipeThread (LPVOID threadParam)
{
    // This thread creates a named pipe instance and
    // blocks waiting for a client connection.  When
    // client connects, the pipe handle is added to the
    // list of trap notification pipes.
    // It then waits for another connection.
    DWORD  nInBufLen = sizeof(SNMP_TRAP);
    DWORD  nOutBufLen = sizeof(SNMP_TRAP) * MAX_OUT_BUFS;
    SECURITY_ATTRIBUTES S_Attrib;
    SECURITY_DESCRIPTOR S_Desc;
    PACL   pAcl;
    DWORD dwRead;
    // construct security decsriptor
    InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION);

    if ((pAcl = AllocGenericACL()) == NULL ||
        !SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
    {
        FreeGenericACL(pAcl);
        return (0);
    }

    S_Attrib.nLength = sizeof(SECURITY_ATTRIBUTES);
    S_Attrib.lpSecurityDescriptor = &S_Desc;
    S_Attrib.bInheritHandle = TRUE;

    while (TRUE)
    {
        HANDLE hPipe;
        svrPipeListEntry *item;
        BOOL bSuccess;

        // eliminate the TerminateThread call in CLOSE_OUT of svcMainFunction
        if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
        {
            SNMPTRAPDBG(("svrPipeThread: exit 0.\n"));
            break;
        }
        hPipe = CreateNamedPipe (SNMPMGRTRAPPIPE,
                    PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                    (PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE),
                    PIPE_UNLIMITED_INSTANCES,
                    nOutBufLen, nInBufLen, 0, &S_Attrib);

        if (hPipe == INVALID_HANDLE_VALUE)
        {
            SNMPTRAPDBG(("svrPipeThread: CreateNamedPipe failed 0x%08lx.\n", GetLastError()));
            break;
        }
        else 
        {
            bSuccess = ConnectNamedPipe(hPipe, &g_ol);
            if (!bSuccess && GetLastError() == ERROR_IO_PENDING)  
            {
                // blocking wait until g_ol.hEvent signaled by system for a new client
                // connection request or by our own termination.
                SNMPTRAPDBG(("svrPipeThread: before GetOverlappedResult.\n"));
                bSuccess = GetOverlappedResult(hPipe, &g_ol, &dwRead, TRUE);
                SNMPTRAPDBG(("svrPipeThread: after GetOverlappedResult.\n"));
                if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
                {
                    SNMPTRAPDBG(("svrPipeThread: exit 1.\n"));
                    CloseHandle(hPipe);
                    break;
                }
                // reset event to non-signaled state for next I/O
                ResetEvent(g_ol.hEvent);
            }
            // check return from either ConnectNamedPipe or GetOverlappedResult.
            // If a client managed to connect between the CreateNamedPipe and
            // ConnectNamedPipe calls, ERROR_PIPE_CONNECTED will result
            if (!bSuccess && GetLastError() != ERROR_PIPE_CONNECTED)
            {
                // something went wrong, close instance and try again
                SNMPTRAPDBG(("svrPipeThread: ConnectNamedPipe 0x%08lx.\n", GetLastError()));
                CloseHandle(hPipe);
                continue;
            }
        }
        
        if (!(item = (svrPipeListEntry *)
                 GlobalAlloc (GPTR, sizeof(svrPipeListEntry))))
        {
            SNMPTRAPDBG(("svrPipeThread: E_OUTOFMEMORY\n"));
            DisconnectNamedPipe(hPipe);
            CloseHandle(hPipe);
            break;
        }
        else
        {
            ll_node *crt;
            item->hPipe = hPipe;

            SNMPTRAPDBG(("svrPipeThread: add connected client to pipe list\n"));

            EnterCriticalSection (&cs_PIPELIST);
            ll_adde(item, pSvrPipeListHead);
            crt = pSvrPipeListHead;

            // scan all the pipe instances to detect the ones that are disconnected
            while (crt = ll_next(crt, pSvrPipeListHead))
            {
                DWORD dwError;

                // subsequent ConnectNamePipe() on a handle already connected return:
                // - ERROR_PIPE_CONNECTED if the client is still there
                // - ERROR_NO_DATA if the client has disconnected
                ConnectNamedPipe(
                            ((svrPipeListEntry *)crt)->hPipe,
                            NULL);

                dwError = GetLastError();

                // For anything else but ERROR_PIPE_CONNECTED, conclude there has been
                // something wrong with the client/pipe so disconect and close the handle
                // and release the memory
                if (dwError != ERROR_PIPE_CONNECTED)
                {
                    ll_node *hold;

                    SNMPTRAPDBG(("svrPipeThread: disconnect client pipe handle 0x%08lx.\n", ((svrPipeListEntry *)crt)->hPipe));
                    if (!DisconnectNamedPipe(((svrPipeListEntry *)crt)->hPipe))
                    {
                        ; // Placeholder for error handling
                    }
                    if (!CloseHandle(((svrPipeListEntry *)crt)->hPipe))
                    {
                        ; // Placeholder for error handling
                    }

                    hold = ll_prev(crt);
                    ll_rmv(crt);
                    GlobalFree(crt); // check for errors?
                    crt = hold;
                } // end_if
            }

            LeaveCriticalSection (&cs_PIPELIST);
        } // end_else
   } // end_while TRUE

    FreeGenericACL(pAcl);
    return(0);

} // end_svrPipeThread()


void FreeSvrPipeEntryList(ll_node* head)
{
    if (head)
    {
        ll_node* current;
        current = head;
        while (current = ll_next(current, head))
        {
            ll_node *hold;
            if (!DisconnectNamedPipe(((svrPipeListEntry *)current)->hPipe))
            {
                ; // Placeholder for error handling
            }
            if (!CloseHandle(((svrPipeListEntry *)current)->hPipe))
            {
                ; // Placeholder for error handling
            }

            hold = ll_prev(current);
            ll_rmv(current);
            GlobalFree(current); // check for errors?
            current = hold;
        }
        GlobalFree(head);
    }
}


#if DBG
// modified from snmp\common\dll\dbg.c
#define MAX_LOG_ENTRY_LEN 512
VOID 
WINAPI 
SnmpTrapDbgPrint(
    LPSTR szFormat, 
    ...
    )

/*++

Routine Description:

    Prints debug message.

Arguments:


    szFormat - formatting string (see printf).

Return Values:

    None. 

--*/

{
    va_list arglist;

    // 640 octets should be enough to encode oid's of 128 sub-ids.
    // (one subid can be encoded on at most 5 octets; there can be at
    // 128 sub-ids per oid. MAX_LOG_ENTRY_LEN = 512
    char szLogEntry[4*MAX_LOG_ENTRY_LEN];

    time_t now;

    // initialize variable args
    va_start(arglist, szFormat);

    time(&now);
    strftime(szLogEntry, MAX_LOG_ENTRY_LEN, "%H:%M:%S :", localtime(&now));

    // transfer variable args to buffer
    vsprintf(szLogEntry + strlen(szLogEntry), szFormat, arglist);

    // output entry to debugger
    OutputDebugStringA(szLogEntry);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\inc\winsnmpn.h ===
#ifndef _INC_WINSNMPN
#define _INC_WINSNMPN
//
// winsnmpn.h
//
// Private include file for ACE*COMM's
// NetPlus Win32 WinSNMP implementation
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 970310 - Removed NPWSNMPSTATUSREPORT structure
//        - Added localAddress to TaskData
//        - Removed unused #defines
//
// 970417 - Added OSVERSIONINFO to TaskData
//
#include <winsock.h>
#include <wsipx.h>
//
#ifdef SOLARIS
#define THR_FLAGS THR_BOUND|THR_DETACHED
#define THR_TYPE LPVOID
#else // Win32
#define THR_TYPE DWORD
#endif // SOLARIS
//
#define DEFSESSIONS           10 // just for testing -- should be rolled back to 10
#define DEFVBLS               100 // just for testing -- should be rolled back to 100
#define DEFPDUS               100 // just for testing -- should be rolled back to 100
#define DEFENTITIES           100 // just for testing -- should be rolled back to 100
#define DEFCONTEXTS           100 // just for testing -- should be rolled back to 100
#define DEFMSGS               100 // just for testing -- should be rolled back to 100
#define DEFTRAPS              10 // just for testing -- should be rolled back to 10
#define DEFAGENTS             5 // just for testing -- should be rolled back to 5

#define MAXCENTISECONDS       429496729U
#define MAXMILLISECONDS       4294967295U
#define DEFTIMEOUT            300      // centisecs = 3 seconds
#define DEFRETRY              3
#define IP_SNMP_PORT          161
#define IP_TRAP_PORT          162
#define IPX_SNMP_PORT         36879
#define IPX_TRAP_PORT         36880
#define SNMPTRAPPIPE          "\\\\.\\PIPE\\MGMTAPI"
#define TRAPSERVERTIMEOUT     30000     // millisecs = 30 seconds
#define NP_WSX95              "NP_WSX95"
#define NP_WSX95_EXE          "NP_WSX95.EXE"
#define WSNMP_TRAPS_ON        WM_USER + 12
#define WSNMP_TRAPS_OFF       WM_USER + 13
#define LOOPBACK_ADDR         "127.0.0.1"
#define MAXTRAPIDS            20    // Max sub-ids in trap matches
#define MAX_FRIEND_NAME_LEN   31
#define MAX_CONTEXT_LEN       256
#define MAX_HOSTNAME          64
#define AF_INET_ADDR_SIZE     4
#define AF_IPX_ADDR_SIZE      10
#define NP_SEND               1 // "To send" msg status
#define NP_SENT               2 // "Sent" msg status
#define NP_RCVD               3 // "Received" msg status
#define NP_READY              4 // "Ready" for pickup by app
#define NP_EXPIRED            5 // "Timed out" for thrNotify
#define NP_REQUEST            1 // Agent request/response msg type
#define NP_RESPONSE           2 // Mgr request/response msg type
#define NP_TRAP               3 // Trap msg type
#define MAX_PENDING_WAIT      1000 // Trap service status period

typedef union
   {
   SOCKADDR_IN  inet;
   SOCKADDR_IPX ipx;
   } SAS, *LPSAS;

typedef struct _VB
   {
   smiOID      name;
   smiVALUE    value;
   smiINT32    data_length;
   struct _VB  *next_var;
   } VARBIND, *LPVARBIND;

typedef struct
   {
   smiOID         enterprise;
   smiIPADDR      agent_addr;
   smiINT32       generic_trap;
   smiINT32       specific_trap;
   smiTIMETICKS   time_ticks;
   } V1TRAP, *LPV1TRAP;

typedef struct _tdBuffer       // SNMP Buffer Descriptor
   {
   struct _tdBuffer *next;     // Link to the next buffer of the table
   struct _tdBuffer *prev;     // Link to the previous buffer of the table
   DWORD  Used;                // Number of entries in use in this buffer
   } SNMPBD, FAR *LPSNMPBD;

typedef struct                 // SNMP Table Descriptor
{
   DWORD    Used;              // Number currently ulilized
   DWORD    Allocated;         // Number currently allocated
   DWORD    BlocksToAdd;       // Incremented in chunks of this many records
   DWORD    BlockSize;         // Record size (bytes)
   LPSNMPBD HeadBuffer;        // circular list to the buffers of the table
                               // 'HeadBuffer' points to a SNMPBD structure suffixed with
                               // 'BlocksToAdd' blocks of size 'BlockSize' each
   } SNMPTD, FAR *LPSNMPTD;

typedef struct
   {
   HSNMP_SESSION  hTask;
   smiUINT32      nTranslateMode;
   smiUINT32      nRetransmitMode;
   DWORD          localAddress;
   SNMPAPI_STATUS conveyAddress; // SNMPAPI_ON/OFF
   HANDLE         timerThread;
   SOCKET         ipSock;
   HANDLE         ipThread;
   SOCKET         ipxSock;
   HANDLE         ipxThread;
   SOCKET         trapSock;   // Win95-only
   HANDLE         trapThread;
   HWND           trapWnd;    // Win95-only
   HANDLE         trapPipe;   // NT-only
   OVERLAPPED     trapOl;     // for overlapped pipe I/O, bug# 270672
   HANDLE         trapEvent;  // for termination of thrTrap
   HANDLE         hExitEvent; // for termination of thrManager
   smiUINT32      nLastReqId;
   SNMPAPI_STATUS nLastError;
   OSVERSIONINFO  sEnv;       // Operating System
   } TASK, FAR *LPTASK;

typedef struct
   {
   HSNMP_SESSION    nTask;
   HWND             hWnd;
   DWORD            wMsg;
   SNMPAPI_CALLBACK fCallBack;
   LPVOID           lpClientData;
   HANDLE           thrEvent;
   HANDLE           thrHandle;
   DWORD            thrCount;
   SNMPAPI_STATUS   nLastError;
   } SESSION, FAR *LPSESSION;                      
typedef struct
   {
   HSNMP_SESSION  Session;
   smiINT32       type;
   smiINT32       appReqId;
   smiINT32       errStatus;
   smiINT32       errIndex;
   HSNMP_VBL      VBL;
   LPVARBIND      VBL_addr;
   LPV1TRAP       v1Trap;
   } PDUS, FAR *LPPDUS;
typedef struct
   {
   HSNMP_SESSION  Session;
   LPVARBIND      vbList;
   } VBLS, FAR *LPVBLS;
typedef struct
   {
   HSNMP_SESSION  Session;
   smiUINT32      refCount;
   smiUINT32      version;
   smiBYTE        name[MAX_FRIEND_NAME_LEN+1];  // friendly name
   smiTIMETICKS   nPolicyTimeout;               // centiseconds
   smiTIMETICKS   nActualTimeout;               // centiseconds
   smiUINT32      nPolicyRetry;
   smiUINT32      nActualRetry;
   smiUINT32      Agent;
   SAS            addr;
   } ENTITY, FAR *LPENTITY;
typedef struct
   {
   HSNMP_SESSION  Session;
   smiUINT32      refCount;
   smiUINT32      version;
   smiBYTE        name[MAX_FRIEND_NAME_LEN+1];  // friendly name
   smiUINT32      commLen;                      // len of commStr
   smiBYTE        commStr[MAX_CONTEXT_LEN];     // raw value
   } CTXT, FAR *LPCTXT;
typedef struct
   {
   HSNMP_SESSION  Session;
   DWORD          Status;        // NP_SEND|SENT|RCVD|READY
   DWORD          Type;          // PDU type
   HSNMP_ENTITY   agentEntity;
   HSNMP_ENTITY   ourEntity;
   HSNMP_CONTEXT  Context;
   smiUINT32      dllReqId;
   smiUINT32      appReqId;
   smiUINT32      nRetransmitMode;
   smiUINT32      Ticks;   // Msg sent time
   smiUINT32      Wait;    // Msg timeout interval (millisecs)
   smiUINT32      Tries;   // Msg retry count
   smiLPBYTE      Addr;
   smiUINT32      Size;
   SAS            Host;
   smiUINT32      PolicyTries; // the Tries counter started from here
   } SNMPMSG, FAR *LPSNMPMSG;
typedef struct
   {
   HSNMP_SESSION  Session;
   HSNMP_ENTITY   ourEntity;
   HSNMP_ENTITY   agentEntity;
   HSNMP_CONTEXT  Context;
   smiOID         notification;
   smiUINT32      notificationValue[MAXTRAPIDS];
   } TRAPNOTICE, FAR *LPTRAPNOTICE;
typedef struct
   {
   HSNMP_SESSION  Session;
   HSNMP_ENTITY   Entity;
   SOCKET         Socket;
   HANDLE         Thread;
   } AGENT, FAR *LPAGENT;

#endif // _INC_WINSNMPN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\dll\wsnmp_vb.c ===
// wsnmp_vb.c
//
// WinSNMP VarBind Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980705 - Changed test on return from SnmpMakeVB()
//          in SnmpCreateVbl() to "!= SNMPAPI_SUCCESS".
//
#include "winsnmp.inc"

BOOL IsBadReadSMIValue(smiLPCVALUE value)
{
    if (IsBadReadPtr((LPVOID)value, sizeof(smiLPCVALUE)))
        return TRUE;

    switch(value->syntax)
    {
    case SNMP_SYNTAX_OCTETS:
    case SNMP_SYNTAX_BITS:
    case SNMP_SYNTAX_OPAQUE:
    case SNMP_SYNTAX_IPADDR:
    case SNMP_SYNTAX_NSAPADDR:
        return IsBadReadPtr((LPVOID)(value->value.string.ptr),
                            value->value.string.len);

    case SNMP_SYNTAX_OID:
        return IsBadReadPtr((LPVOID)(value->value.oid.ptr),
                            value->value.oid.len);
    }
    return FALSE;
}

SNMPAPI_STATUS SnmpMakeVB (smiLPCOID name,
                           smiLPCVALUE value,
                           LPVARBIND FAR *pvb)
{
LPVARBIND vb;
if (!(vb =(LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   return (SNMPAPI_ALLOC_ERROR);
vb->next_var = NULL;
vb->name.ptr = NULL;
if (vb->name.len = name->len) // Deliberate assignment in conditional
   {
   if (name->ptr)
      {
      smiUINT32 len = vb->name.len * sizeof(smiUINT32);
      if (vb->name.ptr = (smiLPUINT32)GlobalAlloc (GPTR, len))
         CopyMemory (vb->name.ptr, name->ptr, len);
      }
   }
if (!vb->name.ptr)
   {
   FreeVarBind (vb);
   return (SNMPAPI_OID_INVALID);
   }
//
if (value)
   {
   switch (value->syntax)
      {
      case SNMP_SYNTAX_OCTETS:
//      case SNMP_SYNTAX_BITS:  -- removed per Bob Natale mail from 10/09/98
      case SNMP_SYNTAX_OPAQUE:
      case SNMP_SYNTAX_IPADDR:
      case SNMP_SYNTAX_NSAPADDR:
      vb->value.value.string.ptr = NULL;
      if (vb->value.value.string.len = value->value.string.len)
         { // Deliberate assignment, above and below
         if (!(vb->value.value.string.ptr =
            (smiLPBYTE)GlobalAlloc (GPTR, value->value.string.len)))
            {
            FreeVarBind (vb);
            return (SNMPAPI_ALLOC_ERROR);
            }
         CopyMemory (vb->value.value.string.ptr, value->value.string.ptr,
                      value->value.string.len);
         }
      break;

      case SNMP_SYNTAX_OID:
      vb->value.value.oid.ptr = NULL;
      if (vb->value.value.oid.len = value->value.oid.len)
         { // Deliberate assignment, above and below
         smiUINT32 len = value->value.oid.len * sizeof(smiUINT32);
         if (!(vb->value.value.oid.ptr = (smiLPUINT32)GlobalAlloc (GPTR, len)))
            {
            FreeVarBind (vb);
            return (SNMPAPI_ALLOC_ERROR);
            }
         CopyMemory (vb->value.value.oid.ptr, value->value.oid.ptr, len);
         }
      break;

      case SNMP_SYNTAX_NULL:
      case SNMP_SYNTAX_NOSUCHOBJECT:
      case SNMP_SYNTAX_NOSUCHINSTANCE:
      case SNMP_SYNTAX_ENDOFMIBVIEW:
      break;

      case SNMP_SYNTAX_INT:
      //case SNMP_SYNTAX_INT32: -- it have the same value as above
      vb->value.value.sNumber = value->value.sNumber;
      break;

      case SNMP_SYNTAX_CNTR32:
      case SNMP_SYNTAX_GAUGE32:
      case SNMP_SYNTAX_TIMETICKS:
      case SNMP_SYNTAX_UINT32:
      vb->value.value.uNumber = value->value.uNumber;
      break;

      case SNMP_SYNTAX_CNTR64:
      vb->value.value.hNumber = value->value.hNumber;
      break;

      default:
      // Clean up the allocated VarBind structure
      FreeVarBind (vb);
      return (SNMPAPI_SYNTAX_INVALID);
      } // end_switch
   vb->value.syntax = value->syntax;
   } // end_if
else
   vb->value.syntax = SNMP_SYNTAX_NULL;
//
*pvb = vb;
return (SNMPAPI_SUCCESS);
} //end_SnmpMakeVB

LPVARBIND SnmpCopyVbl (LPVARBIND VarBindFrom)
{
SNMPAPI_STATUS status;
LPVARBIND VarBindTo;
LPVARBIND VarBindToPrev;
LPVARBIND VarBindNewFrom = NULL; // base VB address
DWORD count = 0;
while (VarBindFrom)
   {
   status = SnmpMakeVB (&VarBindFrom->name, &VarBindFrom->value, &VarBindTo);
   if (status != SNMPAPI_SUCCESS)
      {
      FreeVarBindList(VarBindNewFrom); // Checks for NULL
      VarBindNewFrom = NULL;
      SaveError (0, status);
      break;
      }
   if (!count)
      VarBindNewFrom = VarBindTo;
   else
      VarBindToPrev->next_var = VarBindTo;
   VarBindToPrev = VarBindTo;
   VarBindFrom = VarBindFrom->next_var;
   count++;
   }
return (VarBindNewFrom);
} // end_SnmpCopyVBL

HSNMP_VBL SNMPAPI_CALL
   SnmpCreateVbl  (IN HSNMP_SESSION hSession,
                   IN smiLPCOID name,
                   IN smiLPCVALUE value)
{
DWORD nVbl;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPVARBIND VarBindPtr = NULL;  // must initialize to NULL
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }

lSession = hSession; // save it for possible error return

if (name != NULL)
   {
   if (IsBadReadPtr((LPVOID)name, sizeof(smiOID)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
       
   if (name->len != 0 &&
       name->ptr != NULL &&
       IsBadReadPtr((LPVOID)name->ptr, name->len))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   }
if (value != NULL &&
    IsBadReadSMIValue(value))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

// We have a valid session at this point...
if (name != NULL && name->ptr != NULL)
   {
   lError = SnmpMakeVB (name, value, &VarBindPtr);
   if (lError != SNMPAPI_SUCCESS)
      goto ERROR_OUT;
   else
      VarBindPtr->next_var = NULL;
   }
EnterCriticalSection (&cs_VBL);
lError = snmpAllocTableEntry(&VBLsDescr, &nVbl);
if (lError != SNMPAPI_SUCCESS)
	goto ERROR_PRECHECK;
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

pVbl->Session = hSession;
pVbl->vbList = VarBindPtr;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_VBL);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_VBL) ULongToPtr(nVbl+1));
ERROR_OUT:
FreeVarBind (VarBindPtr); // Hnadles NULL case
return ((HSNMP_VBL) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpCreateVbl

// SnmpSetVb
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetVb(IN HSNMP_VBL hVbl,
             IN smiUINT32 index,
             IN smiLPCOID name,
             IN smiLPCVALUE value)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
LPVARBIND VarBindList = NULL;
LPVARBIND VarBindPtr  = NULL;
LPVARBIND VarBindPrev = NULL;
SNMPAPI_STATUS lError = 0;
HSNMP_SESSION lSession = 0;
smiUINT32 i;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

// We have a valid session at this point...
lSession = pVbl->Session; // save it for possible error return

i = SnmpCountVbl (hVbl);

// make sure the index has a valid value
if ( index > i) // index is unsigned long => no need to test for (index < 0)
{
    lError = SNMPAPI_INDEX_INVALID;
    goto ERROR_OUT;
}

// check for valid data in 'name' parameter
if (IsBadReadPtr((LPVOID)name, sizeof(smiOID)))
{
   // if index points to an existent varbind and the
   // name parameter was not provided, take it from the
   // original varbind.
   if (index != 0 && name == NULL)
   {
       smiUINT32 iVar;

       // look for the original varbind
       for (iVar = 1, VarBindPtr = pVbl->vbList;
            iVar < index;
            iVar++, VarBindPtr = VarBindPtr->next_var);

       // make name to point to that varbind name
       name = &(VarBindPtr->name);
   }
   else
   {
       // either adding a value with NULL OID or specifying an
       // invalid value for 'name' is an SNMPAPI_ALLOC_ERROR
       lError = SNMPAPI_ALLOC_ERROR;
       goto ERROR_OUT;
   }
}

// If the index is 0 then a new varbind is to be added to the list.
// If it is non-zero it references a varbind in the list.
// Except we are currently allow index = count+1 to signal add to
// accommodate FTP Software's faulty implementation as used by HP OpenView
if (!index)      // Allow 0 for FTP/HP OpenView mistake
   index = i+1;  // But make it look like the right thing!
       
if (name->len != 0 &&
   name->ptr != NULL &&
   IsBadReadPtr((LPVOID)name->ptr, name->len))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }

if (value != NULL &&
    IsBadReadSMIValue(value))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

lError = SnmpMakeVB (name, value, &VarBindPtr);
if (lError != SNMPAPI_SUCCESS)
   goto ERROR_OUT;
VarBindPrev = VarBindList = pVbl->vbList;
if (index == i+1)
   { // Adding a VarBind
   if (VarBindList)
      {
      while (VarBindList->next_var != NULL)
         VarBindList = VarBindList->next_var;
      VarBindList->next_var = VarBindPtr;
      }
   else
      {
      VarBindList = VarBindPtr;
      pVbl->vbList = VarBindPtr;
      }
   }
else
   { // Updating a VarBind
   for (i = 1; i < index; i++)
      { // Position and prepare
      VarBindPrev = VarBindList;
      VarBindList = VarBindList->next_var;
      } // end_for
   // Replace
   VarBindPtr->next_var = VarBindList->next_var;
   VarBindPrev->next_var = VarBindPtr;
   if (index == 1)
      pVbl->vbList = VarBindPtr;
   FreeVarBind (VarBindList);
  } // end_else
return (index);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpSetVb

HSNMP_VBL SNMPAPI_CALL
   SnmpDuplicateVbl  (IN HSNMP_SESSION hSession, IN HSNMP_VBL hVbl)
{
DWORD lVbl;
DWORD nVbl;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPVBLS pVblOld, pVblNew;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
lVbl = HandleToUlong(hVbl) - 1;
if (!snmpValidTableEntry(&VBLsDescr, lVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVblOld = snmpGetTableEntry(&VBLsDescr, lVbl);

EnterCriticalSection (&cs_VBL);
lError = snmpAllocTableEntry(&VBLsDescr, &nVbl);
if (lError != SNMPAPI_SUCCESS)
	goto ERROR_PRECHECK;
pVblNew = snmpGetTableEntry(&VBLsDescr, nVbl);

if (pVblOld->vbList)
   { // Deliberate assignment follows
   if (!(pVblNew->vbList = SnmpCopyVbl (pVblOld->vbList)))
      { // Inherit error code from SnmpCopy Vbl
      snmpFreeTableEntry(&VBLsDescr, nVbl);
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_PRECHECK;
      }
   }
pVblNew->Session = hSession;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_VBL);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_VBL) ULongToPtr(nVbl+1));
ERROR_OUT:
return ((HSNMP_VBL) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpDuplicateVbl

// SnmpFreeVbl
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeVbl (IN HSNMP_VBL hVbl)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
SNMPAPI_STATUS lError = 0;
DWORD i;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

EnterCriticalSection (&cs_PDU);
if (PDUsDescr.Used)
   {
   for (i = 0; i < PDUsDescr.Allocated; i++)
      {
      LPPDUS pPdu = snmpGetTableEntry(&PDUsDescr, i);
      if (pPdu->VBL == hVbl)
         pPdu->VBL = 0;
      }
   }
LeaveCriticalSection (&cs_PDU);
EnterCriticalSection (&cs_VBL);
// Free all substructures
FreeVarBindList (pVbl->vbList);
// Clean VBL List
snmpFreeTableEntry(&VBLsDescr, nVbl);
LeaveCriticalSection (&cs_VBL);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpFreeVbl

// SnmpCountVbl
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpCountVbl (IN HSNMP_VBL hVbl)
{
DWORD nVbl;
smiUINT32 count;
SNMPAPI_STATUS lError;
LPVARBIND VarBindPtr;
HSNMP_SESSION lSession = 0;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nVbl = HandleToUlong(hVbl) - 1;
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

count = 0;
VarBindPtr = pVbl->vbList;
lSession = pVbl->Session;
while (VarBindPtr)
   {
   VarBindPtr = VarBindPtr->next_var;
   count++;
   }
if (!count)  // No varbinds
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
return (count);
//
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpCountVbl

// SnmpDeleteVb
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpDeleteVb (IN HSNMP_VBL hVbl, IN smiUINT32 index)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
HSNMP_SESSION hSession;
smiUINT32 status;
smiUINT32 lError = 0;
HSNMP_SESSION lSession = 0;
UINT i= 0;
LPVARBIND VarBindList;
LPVARBIND VarBindPtr;
LPVARBIND VarBindPrev;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

hSession =  pVbl->Session;
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // Load for SaveError() return
status = SnmpCountVbl (hVbl);
if ((!index) || (index > status))
   {
   lError = SNMPAPI_INDEX_INVALID;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_VBL);
// Following cannot be NULL due to passing above test
VarBindPtr = VarBindList = pVbl->vbList;
// Deleting a VarBind
for (i = 1; i <= index; i++)
   { // Position
   VarBindPrev = VarBindPtr;
   VarBindPtr  = VarBindList;
   VarBindList = VarBindList->next_var;
   } // end_for
if (index == 1)
   { // Replace
   pVbl->vbList = VarBindList;
   }
else
   { // Skip
   VarBindPrev->next_var = VarBindList;
   } // end_else
FreeVarBind (VarBindPtr);
LeaveCriticalSection (&cs_VBL);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpDeleteVb

// SnmpGetVb
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetVb (IN HSNMP_VBL hVbl,
              IN smiUINT32 index,
              OUT smiLPOID name,
              OUT smiLPVALUE value)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
LPVARBIND VarBindPtr;
SNMPAPI_STATUS lError = 0;
HSNMP_SESSION lSession = 0;
smiUINT32 nLength;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);
lSession = pVbl->Session;

if (!name && !value)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }

// Test for output descriptor address validity
if ((name && IsBadWritePtr (name, sizeof(smiOID))) ||
    (value && IsBadWritePtr (value, sizeof(smiVALUE))))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

nLength = SnmpCountVbl (hVbl);
if ((!index) || (index > nLength))
   {
   lError = SNMPAPI_INDEX_INVALID;
   goto ERROR_OUT;
   }
if (!(VarBindPtr = pVbl->vbList))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
// SnmpFillOidValue
for (nLength = 1; nLength < index; nLength++)
      VarBindPtr = VarBindPtr->next_var;

if (name != NULL)
{
    ZeroMemory (name, sizeof(smiOID));

    // Copy the name OID
    if ((VarBindPtr->name.len == 0) || (VarBindPtr->name.len > MAXOBJIDSIZE))
       {
       lError = SNMPAPI_OID_INVALID;
       goto ERROR_OUT;
       }
    nLength = VarBindPtr->name.len * sizeof(smiUINT32);
    // App must free following alloc via SnmpFreeDescriptor()
    if (!(name->ptr = (smiLPUINT32)GlobalAlloc (GPTR, nLength)))
       {
       lError = SNMPAPI_ALLOC_ERROR;
       goto ERROR_OUT;
       }
    CopyMemory (name->ptr, VarBindPtr->name.ptr, nLength);
    name->len = VarBindPtr->name.len;
}

if (value != NULL)
{
    // Initialize output structure
    ZeroMemory (value, sizeof(smiVALUE));
    // Copy the VALUE structure
    switch (VarBindPtr->value.syntax)
       {
       case SNMP_SYNTAX_OCTETS:
       case SNMP_SYNTAX_IPADDR:
       case SNMP_SYNTAX_OPAQUE:
       case SNMP_SYNTAX_NSAPADDR:
       // Do copy only if nLength is non-zero
       if (nLength = VarBindPtr->value.value.string.len) // Deliberate assignment
          { // App must free following alloc via SnmpFreeDescriptor()
          if (!(value->value.string.ptr = (smiLPBYTE)GlobalAlloc (GPTR, nLength)))
             {
             lError = SNMPAPI_ALLOC_ERROR;
             goto ERROR_PRECHECK;
             }
          CopyMemory (value->value.string.ptr, VarBindPtr->value.value.string.ptr, nLength);
          value->value.string.len = nLength;
          }
       break;

       case SNMP_SYNTAX_OID:
       nLength = VarBindPtr->value.value.oid.len;
       if (nLength > MAXOBJIDSIZE)
          {
          lError = SNMPAPI_OID_INVALID;
          goto ERROR_PRECHECK;
          }
       if (nLength)
          { // Do copy only if nLength is non-zero
          nLength *= sizeof(smiUINT32);
          // App must free following alloc via SnmpFreeDescriptor()
          if (!(value->value.oid.ptr = (smiLPUINT32)GlobalAlloc (GPTR, nLength)))
             {
             lError = SNMPAPI_ALLOC_ERROR;
             goto ERROR_PRECHECK;
             }
          CopyMemory (value->value.oid.ptr,
                       VarBindPtr->value.value.oid.ptr, nLength);
          value->value.oid.len = VarBindPtr->value.value.oid.len;
          }
       break;

       case SNMP_SYNTAX_NULL:
       case SNMP_SYNTAX_NOSUCHOBJECT:
       case SNMP_SYNTAX_NOSUCHINSTANCE:
       case SNMP_SYNTAX_ENDOFMIBVIEW:
       // Use initialized (NULL) smiVALUE
       break;

       case SNMP_SYNTAX_INT:
       value->value.sNumber = VarBindPtr->value.value.sNumber;
       break;

       case SNMP_SYNTAX_CNTR32:
       case SNMP_SYNTAX_GAUGE32:
       case SNMP_SYNTAX_TIMETICKS:
       case SNMP_SYNTAX_UINT32:
       value->value.uNumber = VarBindPtr->value.value.uNumber;
       break;

       case SNMP_SYNTAX_CNTR64:
       value->value.hNumber = VarBindPtr->value.value.hNumber;
       break;

       default:
       lError = SNMPAPI_SYNTAX_INVALID;
       goto ERROR_PRECHECK;
       } // end_switch
    value->syntax = VarBindPtr->value.syntax;
}
return (SNMPAPI_SUCCESS);
// Post-name allocation failure modes
ERROR_PRECHECK:
if (name && name->ptr)
   {
   GlobalFree (name->ptr);
   ZeroMemory (name, sizeof(smiOID));
   }
if (value && value->value.string.ptr)
   {
   GlobalFree (value->value.string.ptr);
   ZeroMemory (value, sizeof(smiVALUE));
   }
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpGetVb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\mibs\dummy.c ===
/**
    This is just a dummy C file for the compiler to have
**/

void dummy_main(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\manager\winsnmp\inc\wsnmpext.h ===
#ifndef _INC_WSNMPEXT
#define _INC_WSNMPEXT
//
// wsnmpext.h
//
// Externals include for NetPlus WinSNMP
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
//
#ifdef __cplusplus
extern "C" {
#endif
extern TASK          TaskData;
extern SNMPTD        SessDescr;
extern SNMPTD        PDUsDescr;
extern SNMPTD        VBLsDescr;
extern SNMPTD        EntsDescr;
extern SNMPTD        CntxDescr;
extern SNMPTD        MsgDescr;       
extern SNMPTD        TrapDescr;
extern SNMPTD        AgentDescr;
extern CRITICAL_SECTION cs_TASK;
extern CRITICAL_SECTION cs_SESSION;
extern CRITICAL_SECTION cs_PDU;
extern CRITICAL_SECTION cs_VBL;
extern CRITICAL_SECTION cs_ENTITY;
extern CRITICAL_SECTION cs_CONTEXT;
extern CRITICAL_SECTION cs_MSG;
extern CRITICAL_SECTION cs_TRAP;
extern CRITICAL_SECTION cs_AGENT;
extern CRITICAL_SECTION cs_XMODE;

extern SNMPAPI_STATUS SaveError(HSNMP_SESSION hSession, SNMPAPI_STATUS nError);

extern SNMPAPI_STATUS snmpAllocTable(LPSNMPTD table);
extern SNMPAPI_STATUS SNMPAPI_CALL SnmpIpxAddressToStr (LPBYTE, LPBYTE, LPSTR);
extern BOOL BuildMessage (smiUINT32 version, smiLPOCTETS community,
            LPPDUS pdu, smiINT32 dllReqId, smiLPBYTE *msgAddr, smiLPUINT32 msgSize);
extern smiUINT32 ParseMessage (smiLPBYTE msgPtr, smiUINT32 msgLen, smiLPUINT32 version, smiLPOCTETS *community, LPPDUS pdu);
extern void FreeMsg (DWORD nMsg);
extern void FreeOctetString (smiLPOCTETS os_ptr);
extern void FreeVarBind (LPVARBIND vb_ptr);
extern void FreeVarBindList (LPVARBIND vb_ptr);
extern void FreeV1Trap (LPV1TRAP v1Trap_ptr);
extern SNMPAPI_STATUS CheckRange (DWORD index, LPSNMPTD block);

//-----------------------------------------------------------------
// snmpInitTableDescr - initializes the table descriptor with the 
// parameters given as arguments. Creates and zeroes a first chunck of table.
extern SNMPAPI_STATUS snmpInitTableDescr(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwBlocksToAdd, /*in*/DWORD dwBlockSize);
//-----------------------------------------------------------------
// snmpFreeTableDescr - releases any memory allocated for the table
extern VOID snmpFreeTableDescr(/*in*/LPSNMPTD pTableDescr);
//-----------------------------------------------------------------
// snmpAllocTableEntry - finds an empty entry into the table. If none
// already exists, table is enlarged.
extern SNMPAPI_STATUS snmpAllocTableEntry(/*in*/LPSNMPTD pTableDescr, /*out*/LPDWORD pIndex);
//-----------------------------------------------------------------
// snmpFreeTableEntry - free the location at index dwIndex from the
// table described by pTableDescr. 
extern SNMPAPI_STATUS snmpFreeTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex);
//-----------------------------------------------------------------
// snmpGetTableEntry - returns the entry at zero-based index dwIndex
// from the table described by pTableDescr
extern PVOID snmpGetTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex);
//-----------------------------------------------------------------
// snmpValidTableEntry - returns TRUE or FALSE as an entry in the table
// has valid data (is allocated) or not
extern BOOL snmpValidTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex);


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\args.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    args.c

Abstract:

    Contains routines for processing command line arguments.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "args.h"
#include "stdlib.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessArguments(
    DWORD  NumberOfArgs,
    LPSTR ArgumentPtrs[]
    )

/*++

Routine Description:

    Processes command line arguments.

Arguments:

    NumberOfArgs - number of command line arguments.
    ArgumentPtrs - array of pointers to arguments.

Return Values:

    Returns true if successful.

--*/

{
    DWORD  dwArgument;
    LPSTR pCurrentArg;

    // initialize logging arguments
    g_CmdLineArguments.nLogLevel = INVALID_ARGUMENT;
    g_CmdLineArguments.nLogType  = INVALID_ARGUMENT;

    // initialize service controller argument
    g_CmdLineArguments.fBypassCtrlDispatcher = FALSE;

    // process arguments
    while (NumberOfArgs--) {

        // retrieve argument pointer
        pCurrentArg = ArgumentPtrs[NumberOfArgs];

        // make sure valid argument passed
        if (IS_ARGUMENT(pCurrentArg, LOGLEVEL)) {

            // convert string into dword argument
            dwArgument = DWORD_ARGUMENT(pCurrentArg, LOGLEVEL);

            // store in global argument structure
            g_CmdLineArguments.nLogLevel = dwArgument;

            // modify the level at which logging occurs
            SnmpSvcSetLogLevel(g_CmdLineArguments.nLogLevel);

        } else if (IS_ARGUMENT(pCurrentArg, LOGTYPE)) {

            // convert string into dword argument
            dwArgument = DWORD_ARGUMENT(pCurrentArg, LOGTYPE);

            // store in global argument structure
            g_CmdLineArguments.nLogType = dwArgument;

            // modify the log type used during logging 
            SnmpSvcSetLogType(g_CmdLineArguments.nLogType);

        } else if (IS_ARGUMENT(pCurrentArg, DEBUG)) {

            // disable service controller when debugging
            g_CmdLineArguments.fBypassCtrlDispatcher = TRUE;

        } else if (NumberOfArgs) {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: Ignoring argument %s.\n",
                pCurrentArg
                ));
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\mibs\makefile.inc ===
MIBCC=mibcc.exe

# wins.mib must come before dhcp.mib
#
MIB_COMPONENTS=\
    rfc2571.mib \
    accserv.mib \
    acs.mib	\
    authserv.mib \
    wins.mib \
    dhcp.mib \
    ftp.mib \
    gopherd.mib \
    hostmib.mib \
    http.mib \
    igmpv2.mib \
    inetsrv.mib \
    ipforwd.mib \
    lmmib2.mib \
    mcastmib.mib \
    mib_ii.mib \
    mipx.mib \
    mripsap.mib \
    msft.mib \
    printmib.mib \

$(O)\mib.bin: $(MIB_COMPONENTS)
    $(MIBCC) -o$(O)\mib.bin $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\globals.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    Contains global data for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD  g_dwUpTimeReference = 0;
HANDLE g_hTerminationEvent = NULL;
HANDLE g_hRegistryEvent = NULL;

// notification event for changes in the default parameters registry tree
HANDLE g_hDefaultRegNotifier;
HKEY   g_hDefaultKey;
// notification event for changes in the policy parameters registry tree
HANDLE g_hPolicyRegNotifier;
HKEY   g_hPolicyKey;

LIST_ENTRY g_Subagents          = { NULL };
LIST_ENTRY g_SupportedRegions   = { NULL };
LIST_ENTRY g_ValidCommunities   = { NULL };
LIST_ENTRY g_TrapDestinations   = { NULL };
LIST_ENTRY g_PermittedManagers  = { NULL };
LIST_ENTRY g_IncomingTransports = { NULL };
LIST_ENTRY g_OutgoingTransports = { NULL };

CMD_LINE_ARGUMENTS g_CmdLineArguments;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\makefile.inc ===
snmpevts.h : snmpevts.mc
    mc -h ..\inc -v snmpevts.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\mem.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    Contains memory allocation routines for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "mem.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define AGENT_HEAP_FLAGS            0
#define AGENT_HEAP_INITIAL_SIZE     0xffff
#define AGENT_HEAP_MAXIMUM_SIZE     0


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE g_hAgentHeap = NULL;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procudures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AgentHeapCreate(
    )

/*++

Routine Description:

    Creates private heap for master agent private structures.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // create master agent heap
    g_hAgentHeap = HeapCreate(
                        AGENT_HEAP_FLAGS, 
                        AGENT_HEAP_INITIAL_SIZE, 
                        AGENT_HEAP_MAXIMUM_SIZE
                        );

    // validate heap handle
    if (g_hAgentHeap == NULL) {
            
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d creating agent heap.\n",
            GetLastError()
            ));
    }

    // return success if created
    return (g_hAgentHeap != NULL);
}


BOOL
AgentHeapDestroy(
    )

/*++

Routine Description:

    Destroys private heap for master agent private structures.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // validate handle
    if (g_hAgentHeap != NULL) {

        // release heap handle
        HeapDestroy(g_hAgentHeap);

        // re-initialize
        g_hAgentHeap = NULL;
    }

    return TRUE;
}


LPVOID
AgentMemAlloc(
    UINT nBytes
    )

/*++

Routine Description:

    Allocates memory from master agent's private heap.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // allocate memory from private heap (and initialize)
    return HeapAlloc(g_hAgentHeap, HEAP_ZERO_MEMORY, nBytes);
}


VOID
AgentMemFree(
    LPVOID pMem
    )

/*++

Routine Description:

    Frees memory from master agent's private heap.

Arguments:

    pMem - pointer to memory block to release.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pMem != NULL) {

        // release agent memory
        HeapFree(g_hAgentHeap, 0, pMem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\contexts.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    contexts.c

Abstract:

    Contains routines for manipulating SNMP community structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "contexts.h"
#include "snmpthrd.h"

#define DYN_REGISTRY_UPDATE 1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AddValidCommunity(
    LPWSTR pCommunity,
    DWORD dwAccess
    )

/*++

Routine Description:

    Adds valid community to list.

Arguments:

    pCommunity - pointer to community to add.

    dwAccess - access rights for community.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PCOMMUNITY_LIST_ENTRY pCLE = NULL;
    AsnOctetString CommunityOctets;
    
    // initialize octet string info
    CommunityOctets.length  = wcslen(pCommunity) * sizeof(WCHAR);
    CommunityOctets.stream  = (LPBYTE)pCommunity;
    CommunityOctets.dynamic = FALSE;

    // attempt to locate in list    
    if (FindValidCommunity(&pCLE, &CommunityOctets)) {
                    
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: updating community %s.\n",
            StaticUnicodeToString((LPWSTR)pCommunity)
            ));

        // update access rights
        pCLE->dwAccess = dwAccess;

        // success
        fOk = TRUE;

    } else {

        // allocate community structure
        if (AllocCLE(&pCLE, pCommunity)) {
                            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: adding community %s.\n",
                CommunityOctetsToString(&(pCLE->Community), TRUE)
                ));

            // insert into valid communities list
            InsertTailList(&g_ValidCommunities, &pCLE->Link);

            // update access rights
            pCLE->dwAccess = dwAccess;

            // success
            fOk = TRUE;
        }
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocCLE(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    LPWSTR                  pCommunity
    )

/*++

Routine Description:

    Allocates community structure and initializes.

Arguments:

    ppCLE - pointer to receive pointer to entry.

    pCommunity - pointer to community string.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PCOMMUNITY_LIST_ENTRY pCLE = NULL;

    // attempt to allocate structure
    pCLE = AgentMemAlloc(sizeof(COMMUNITY_LIST_ENTRY));

    // validate
    if (pCLE != NULL) {
        
        // determine string length
        DWORD nBytes = wcslen(pCommunity) * sizeof(WCHAR);

        // allocate memory for string (include terminator)
        pCLE->Community.stream = SnmpUtilMemAlloc(nBytes + sizeof(WCHAR));

        // validate community string stream
        if (pCLE->Community.stream != NULL) {

            // set length of manager string
            pCLE->Community.length = nBytes;
    
            // set memory allocation flag 
            pCLE->Community.dynamic = TRUE;

            // transfer community string into octets
            wcscpy((LPWSTR)(pCLE->Community.stream), pCommunity);

            // success
            fOk = TRUE;

        } else {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not copy community string %s.\n",
                StaticUnicodeToString(pCommunity)
                ));

            // release 
            FreeCLE(pCLE);

            // re-init
            pCLE = NULL;            
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate context entry for %s.\n",
            StaticUnicodeToString(pCommunity)
            ));
    }

    // transfer
    *ppCLE = pCLE;

    return fOk;
}


BOOL 
FreeCLE(
    PCOMMUNITY_LIST_ENTRY pCLE
    )

/*++

Routine Description:

    Releases community structure.

Arguments:

    pCLE - pointer to community list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pCLE != NULL) {

        // release octet string contents
        SnmpUtilOctetsFree(&pCLE->Community);

        // release structure
        AgentMemFree(pCLE);
    }

    return TRUE;
}


BOOL
FindValidCommunity(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    AsnOctetString *        pCommunity
    )

/*++

Routine Description:

    Locates valid community in list.

Arguments:

    ppCLE - pointer to receive pointer to entry.

    pCommunity - pointer to community to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PCOMMUNITY_LIST_ENTRY pCLE;

    // initialize
    *ppCLE = NULL;

    // obtain pointer to list head
    pLE = g_ValidCommunities.Flink;

    // process all entries in list
    while (pLE != &g_ValidCommunities) {

        // retrieve pointer to community structure
        pCLE = CONTAINING_RECORD(pLE, COMMUNITY_LIST_ENTRY, Link);

        // compare community string with entry
        if (!SnmpUtilOctetsCmp(&pCLE->Community, pCommunity)) {

            // transfer
            *ppCLE = pCLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


DWORD
ParsePermissionMask(
    DWORD bitMask
    )
/*++

Routine Description:

    Translates the permission mask from the bit-mask format (registry)
    into the internal constant value (constants from public\sdk\inc\snmp.h).
    The function works no longer if:
    - more than sizeof(DWORD)*8 permission values are defined
    - constant values (access policy) changes

Arguments:

    bit-mask.

Return Values:

    permission's constant value.

--*/
{
    DWORD dwPermission;

    for(dwPermission = 0; (bitMask & ((DWORD)(-1)^1)) != 0; bitMask>>=1, dwPermission++);

    return dwPermission;
}

#ifdef DYN_REGISTRY_UPDATE
LONG UpdateRegistry(
    HKEY hKey,
    LPWSTR wszBogus,
    LPWSTR wszCommunity
    )
/*++

Routine Description:

    Updates the registry configuration in order to be able to associate
    permission masks to each community:
                name            type        data
    old format: <whatever>      REG_SZ      community_name
    new format: community_name  REG_DWORD   permission_mask
Arguments:

    hKey - open handle to the key that contains the value
    szBogus - old format value name; useless data
    szCommunity - pointer to community name, as it was specified in the old format.

Return Values:

    Returns ERROR_SUCCESS if successful.

--*/
{
    LONG lStatus;
    DWORD dwDataType;

    // make sure the update was not tried (and breaked) before
    lStatus = RegQueryValueExW(
                hKey,
                wszCommunity,
                0,
                &dwDataType,
                NULL,
                NULL);

    // if no previous (breaked) update, convert community to the new format
    if (lStatus != ERROR_SUCCESS || dwDataType != REG_DWORD)
    {
        // permissions to be assigned to community
        DWORD dwPermissionMask;
        
        // all communities that are converted to new format at this point,
        // are converted to READ-ONLY permissions to tighten the security
        dwPermissionMask = 1 << SNMP_ACCESS_READ_ONLY;

        // set the new format value
        lStatus = RegSetValueExW(
                    hKey,
                    wszCommunity,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&dwPermissionMask,
                    sizeof(DWORD));

        if (lStatus != ERROR_SUCCESS)
            return lStatus;
    }

    // delete the old format value
    lStatus = RegDeleteValueW(
                hKey,
                wszBogus);

    return lStatus;
}
#endif


BOOL
LoadValidCommunities(
    BOOL bFirstCall
    )

/*++

Routine Description:

    Constructs list of valid communities.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    WCHAR wszName[MAX_PATH];  // get the UNICODE encoding for szName
    DWORD dwNameSize;
    DWORD dwDataType;
    WCHAR wszData[MAX_PATH];  // get the UNICODE encoding for szData
    DWORD dwDataSize;
    BOOL fPolicy;
    LPTSTR pszKey;
    BOOL fOk = FALSE;

    
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading valid communities.\n"
        ));

#ifdef _POLICY
    // we need to provide precedence to the parameters set through the policy
    fPolicy = TRUE;
#else
    fPolicy = FALSE;
#endif

    do
    {
        // if the policy is to be enforced, check the policy registry location first
        pszKey = fPolicy ? REG_POLICY_VALID_COMMUNITIES : REG_KEY_VALID_COMMUNITIES;

        // open registry subkey    
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    pszKey,
                    0,
#ifdef DYN_REGISTRY_UPDATE
                    bFirstCall ? KEY_READ | KEY_SET_VALUE : KEY_READ,
#else
                    KEY_READ,
#endif
                    &hKey
                    );

        // if the call succeeded or we were not checking the policy, break the loop
        if (lStatus == ERROR_SUCCESS || !fPolicy)
            break;

        // being at this point, this means we were checking for the policy parameters.
        // If and only if the policy is not defined (registry key is missing) we
        // reset the error, mark 'fPolicy already tried' and go back into the loop
        if (lStatus == ERROR_FILE_NOT_FOUND)
        {
            lStatus = ERROR_SUCCESS;
            fPolicy = FALSE;
        }
    } while (lStatus == ERROR_SUCCESS);


    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // initialize
        dwIndex = 0;

        // loop until error or end of list
        for (dwIndex = 0;
             lStatus == ERROR_SUCCESS; 
             dwIndex++)

        {
            // initialize buffer sizes
            dwNameSize = sizeof(wszName) / sizeof(wszName[0]); // size in number of WCHARs, not the size in bytes
            dwDataSize = sizeof(wszData); // size in number of bytes

            // read next value
            lStatus = RegEnumValueW(
                        hKey, 
                        dwIndex, 
                        wszName, 
                        &dwNameSize,
                        NULL, 
                        &dwDataType, 
                        (LPBYTE)wszData, 
                        &dwDataSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                // dynamically update values that are not of DWORD type
                if (dwDataType != REG_DWORD)
                {
#ifdef DYN_REGISTRY_UPDATE
                    if (dwDataType == REG_SZ)
                    {
                        // BUG# 638837, do not update ValidCommunities 
                        // registry format in case we're working with policy
                        if (bFirstCall && !fPolicy)
                        {
                            if(UpdateRegistry(hKey, wszName, wszData) == ERROR_SUCCESS)
                            {
                                SNMPDBG((
                                    SNMP_LOG_WARNING, 
                                    "SNMP: SVC: updated community registration\n"
                                ));

                                // current value has been deleted, need to keep the index
                                dwIndex--;
                                continue;
                            }
                        }
                        else
                        {
                            SNMPDBG((
                                SNMP_LOG_WARNING,
                                "SNMP: SVC: old format community to be considered with read-only right"));

                            wcscpy(wszName, wszData);
                            *(DWORD *)wszData = (1 << SNMP_ACCESS_READ_ONLY);
                        }
                    }
                    else
#endif
                    {
                        SNMPDBG((
                            SNMP_LOG_WARNING, 
                            "SNMP: SVC: wrong format in ValidCommunities[%d] registry entry\n",
                            dwIndex
                        ));
                        continue;
                    }
                }

                // add valid community to list with related permissions
                if (AddValidCommunity(wszName, ParsePermissionMask(*(DWORD *)wszData)))
                {

                    SNMPDBG((
                        SNMP_LOG_WARNING, 
                        "SNMP: SVC: rights set to %d for community '%s'\n",
                        *(DWORD *)wszData,
                        StaticUnicodeToString(wszName)
                    ));

                }
                else
                {
                    // reset status to reflect failure
                    lStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            
            }
            else if (lStatus == ERROR_NO_MORE_ITEMS)
            {
                // success
                fOk = TRUE; 
            }
        }
        RegCloseKey(hKey);
    } 
    else
        // it doesn't matter how the values are, the key has to exist,
        // so mark as bFirstCall in order to log an event if this is not true.
        bFirstCall = TRUE;  
    
    if (!fOk) {
            
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing ValidCommunities subkey.\n",
            lStatus
            ));

        // report an event only for the first call (initialization of the service).
        // otherwise subsequent registry ops through regedit might flood the event log with
        // unsignificant records
        if (bFirstCall)
            // report event
            ReportSnmpEvent(
                SNMP_EVENT_INVALID_REGISTRY_KEY, 
                1, 
                &pszKey, 
                lStatus
                );
    }
    return fOk;
}


BOOL
UnloadValidCommunities(
    )

/*++

Routine Description:

    Destroys list of valid communities.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PCOMMUNITY_LIST_ENTRY pCLE;

    // process entries until list is empty
    while (!IsListEmpty(&g_ValidCommunities)) {

        // extract next entry from head of list
        pLE = RemoveHeadList(&g_ValidCommunities);

        // retrieve pointer to community structure
        pCLE = CONTAINING_RECORD(pLE, COMMUNITY_LIST_ENTRY, Link);
 
        // release
        FreeCLE(pCLE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\network.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Contains routines for manipulating transport structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "network.h"
#include "varbinds.h"
#include "query.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
IsValidSockAddr(
    struct sockaddr *pAddress
    )
/*++

Routine Description:

    Verifies if an IP or IPX address is valid.
    An IP address is valid if it is AF_INET and it is not 0.0.0.0
    An IPX address is valid if is AF_IPX and the node-number is not null: xxxxxx.000000000000

Arguments:

    pAddress - pointer to a generic network address to be tested

Return Values:

    Returns true if the address is valid.

--*/
{
    if (pAddress == NULL)
        return FALSE;

    if (pAddress->sa_family == AF_INET)
    {
        return (((struct sockaddr_in *)pAddress)->sin_addr.s_addr != 0);
    }
    else if (pAddress->sa_family == AF_IPX)
    {
        char zeroBuff[6] = {0, 0, 0, 0, 0, 0};

        return memcmp(((struct sockaddr_ipx *)pAddress)->sa_nodenum,
                       zeroBuff,
                       sizeof(zeroBuff)) != 0;
    }

    // the address is neither IP nor IPX hence it is definitely an invalid address
    return FALSE;
}

BOOL
AllocNLE(
    PNETWORK_LIST_ENTRY * ppNLE
    )

/*++

Routine Description:

    Allocates transport structure and initializes.

Arguments:

    ppNLE - pointer to receive pointer to list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PNETWORK_LIST_ENTRY pNLE;
    
    // attempt to allocate structure
    pNLE = AgentMemAlloc(sizeof(NETWORK_LIST_ENTRY));

    // validate pointer
    if (pNLE != NULL) {

        // allocate buffer to be used for io
        pNLE->Buffer.buf = AgentMemAlloc(NLEBUFLEN);

        // validate pointer
        if (pNLE->Buffer.buf != NULL) {

            // initialize socket to socket
            pNLE->Socket = INVALID_SOCKET;

            // initialize buffer length
            pNLE->Buffer.len = NLEBUFLEN;

            // initialize subagent query list
            InitializeListHead(&pNLE->Queries);

            // initialize variable bindings list
            InitializeListHead(&pNLE->Bindings);

            // success
            fOk = TRUE;

        } else {
                
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not allocate network io buffer.\n"
                ));
            
            // release
            FreeNLE(pNLE);

            // re-init
            pNLE = NULL;
        }
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate network entry.\n"
            ));
    }

    // transfer
    *ppNLE = pNLE;

    return fOk;
}


BOOL 
FreeNLE(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Releases transport structure.

Arguments:

    pNLE - pointer to transport structure.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pNLE != NULL) {

        // check to see if socket valid
        if (pNLE->Socket != INVALID_SOCKET) {

            // release socket
            closesocket(pNLE->Socket);
        }

        // release pdu
        UnloadPdu(pNLE);

        // release query list
        UnloadQueries(pNLE);

        // release bindings list
        UnloadVarBinds(pNLE);

        // release network buffer
        AgentMemFree(pNLE->Buffer.buf);

        // release memory
        AgentMemFree(pNLE);
    }

    return TRUE;
}


BOOL
LoadIncomingTransports(
    )

/*++

Routine Description:

    Creates entries for each incoming interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fUdpOk = FALSE;
    BOOL fIpxOk = FALSE;
    PNETWORK_LIST_ENTRY pNLE = NULL;
    INT nStatus;

    // allocate tcpip
    if (AllocNLE(&pNLE)) {

        struct servent * pServEnt;
        struct sockaddr_in * pSockAddr;

        // initialize sockaddr structure size
        pNLE->SockAddrLen = sizeof(struct sockaddr_in);

        // obtain pointer to sockaddr structure
        pSockAddr = (struct sockaddr_in *)&pNLE->SockAddr;

        // attempt to get server information
        pServEnt = getservbyname("snmp","udp");

        // initialize address structure
        pSockAddr->sin_family = AF_INET;
        pSockAddr->sin_addr.s_addr = INADDR_ANY;
        pSockAddr->sin_port = (pServEnt != NULL)
                                ? (SHORT)pServEnt->s_port
                                : htons(DEFAULT_SNMP_PORT_UDP)
                                ;
        
        // allocate tpcip socket 
        pNLE->Socket = WSASocket(
                            AF_INET,
                            SOCK_DGRAM,
                            0,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            // BUG# 553100 SNMP Agent should not respond to requests to a 
            //             subnet broadcast address
            DWORD dwOption = 0;
            nStatus = setsockopt(pNLE->Socket, 
                                IPPROTO_IP, 
                                IP_RECEIVE_BROADCAST, 
                                (PCHAR)&dwOption, 
                                sizeof(dwOption)
                                );
            if (nStatus == SOCKET_ERROR) {
                
                SNMPDBG((
                    SNMP_LOG_WARNING,
                    "SNMP: SVC: ignore error %d, setsockopt with IP_RECEIVE_BROADCAST on socket %p.\n",
                    WSAGetLastError(),
                    pNLE->Socket
                    ));
            }

            // attempt to bind 
            nStatus = bind(pNLE->Socket, 
                          &pNLE->SockAddr, 
                          pNLE->SockAddrLen
                          );

            // validate return code
            if (nStatus != SOCKET_ERROR) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: successfully bound to udp port %d.\n",
                    ntohs(pSockAddr->sin_port)
                    ));

                // insert transport into list of incoming
                InsertTailList(&g_IncomingTransports, &pNLE->Link);

                // success
                fUdpOk = TRUE;
            
            } else {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: error %d binding to udp port %d.\n",
                    WSAGetLastError(),
                    ntohs(pSockAddr->sin_port)
                    ));
            }

        } else { 
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating udp socket.\n",
                WSAGetLastError()
                ));
        }    

        if (!fUdpOk) {
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // allocate ipx
    if (AllocNLE(&pNLE)) {

        struct sockaddr_ipx * pSockAddr;

        // initialize sockaddr structure size
        pNLE->SockAddrLen = sizeof(struct sockaddr_ipx);

        // obtain pointer to sockaddr structure
        pSockAddr = (struct sockaddr_ipx *)&pNLE->SockAddr;

        // initialize address structure
        pSockAddr->sa_family = AF_IPX;
        pSockAddr->sa_socket = htons(DEFAULT_SNMP_PORT_IPX);
        
        // allocate ipx socket 
        pNLE->Socket = WSASocket(
                            AF_IPX,
                            SOCK_DGRAM,
                            NSPROTO_IPX,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            // attempt to bind 
            nStatus = bind(pNLE->Socket, 
                          &pNLE->SockAddr, 
                          pNLE->SockAddrLen
                          );

            // validate return code
            if (nStatus != SOCKET_ERROR) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: successfully bound to ipx port %d.\n",
                    ntohs(pSockAddr->sa_socket)
                    ));

                // insert transport into list of incoming
                InsertTailList(&g_IncomingTransports, &pNLE->Link);

                // success
                fIpxOk = TRUE;

            } else {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: error %d binding to ipx port %d.\n",
                    WSAGetLastError(),
                    ntohs(pSockAddr->sa_socket)
                    ));
            }

        } else { 
                
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating ipx socket.\n",
                WSAGetLastError()
                ));
        }    

        if (!fIpxOk) {
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // need one transport min
    return (fUdpOk || fIpxOk);
}


BOOL
UnloadTransport(
    PNETWORK_LIST_ENTRY pNLE
    )
{

    // make sure the parameter is valid, otherwise the macro below AVs
    if (pNLE == NULL)
        return FALSE;

    // remove the entry from the list
    RemoveEntryList(&(pNLE->Link));
    
    // release the memory
    FreeNLE(pNLE);

    return TRUE;
}


BOOL
UnloadIncomingTransports(
    )

/*++

Routine Description:

    Destroys entries for each outgoing interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PNETWORK_LIST_ENTRY pNLE;

    // process entries until empty
    while (!IsListEmpty(&g_IncomingTransports)) {

        // extract next entry from head 
        pLE = RemoveHeadList(&g_IncomingTransports);

        // retrieve pointer to mib region structure 
        pNLE = CONTAINING_RECORD(pLE, NETWORK_LIST_ENTRY, Link);

        // release
        FreeNLE(pNLE);
    }

    return TRUE; 
}


BOOL
LoadOutgoingTransports(
    )

/*++

Routine Description:

    Creates entries for each outgoing interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fUdpOk = FALSE;
    BOOL fIpxOk = FALSE;
    PNETWORK_LIST_ENTRY pNLE = NULL;

    // allocate tcpip
    if (AllocNLE(&pNLE)) {

        // allocate tpcip socket 
        pNLE->Socket = WSASocket(
                            AF_INET,
                            SOCK_DGRAM,
                            0,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            pNLE->SockAddr.sa_family = AF_INET;

            // insert transport into list of incoming
            InsertTailList(&g_OutgoingTransports, &pNLE->Link);

            // success
            fUdpOk = TRUE;

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating udp socket.\n",
                WSAGetLastError()
                ));
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // allocate ipx
    if (AllocNLE(&pNLE)) {

        // allocate ipx socket 
        pNLE->Socket = WSASocket(
                            AF_IPX,
                            SOCK_DGRAM,
                            NSPROTO_IPX,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            pNLE->SockAddr.sa_family = AF_IPX;

            // insert transport into list of incoming
            InsertTailList(&g_OutgoingTransports, &pNLE->Link);

            // success
            fIpxOk = TRUE;

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating ipx socket.\n",
                WSAGetLastError()
                ));
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // need one transport min
    return (fUdpOk || fIpxOk);
}


BOOL
UnloadOutgoingTransports(
    )

/*++

Routine Description:

    Destroys entries for each outgoing interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PNETWORK_LIST_ENTRY pNLE;

    // process entries until empty
    while (!IsListEmpty(&g_OutgoingTransports)) {

        // extract next entry from head 
        pLE = RemoveHeadList(&g_OutgoingTransports);

        // retrieve pointer to mib region structure 
        pNLE = CONTAINING_RECORD(pLE, NETWORK_LIST_ENTRY, Link);

        // release
        FreeNLE(pNLE);
    }

    return TRUE; 
}


BOOL
UnloadPdu(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Releases resources allocated in pdu structure.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    // release community string
    SnmpUtilOctetsFree(&pNLE->Community);

    // release varbinds in pdu
    SnmpUtilVarBindListFree(&pNLE->Pdu.Vbl);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\registry.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Contains routines for manipulating registry parameters.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "registry.h"
#include "contexts.h"
#include "regions.h"
#include "trapmgrs.h"
#include "snmpmgrs.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT
InitRegistryNotifiers(
    )
/*++

Routine Description:

    Setup registry notifiers

Arguments:

    None.

Return Values:

    Returns the number of events that have been registered successfully

--*/
{
    DWORD  nEvents = 0;

    // on first call only create the default notifier
    if (g_hDefaultRegNotifier == NULL)
        g_hDefaultRegNotifier = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hDefaultKey == NULL)
    {
        RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_SNMP_PARAMETERS,
                0,
                KEY_READ,
                &g_hDefaultKey
                );
    }

    // setup the default registry notifier
    if (g_hDefaultRegNotifier &&
        g_hDefaultKey &&
        RegNotifyChangeKeyValue(
            g_hDefaultKey,
            TRUE,
            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
            g_hDefaultRegNotifier,
            TRUE
            ) == ERROR_SUCCESS)
    {
        SNMPDBG((SNMP_LOG_TRACE,
                 "SNMP: REG: Default reg notifier initialized successfully.\n"));
        nEvents++;
    }
    else
    {
        SNMPDBG((SNMP_LOG_TRACE,
            "SNMP: REG: Default reg notifier initialization failed.\n"));
        
        if (g_hDefaultRegNotifier != NULL)
        {
            CloseHandle(g_hDefaultRegNotifier);
            g_hDefaultRegNotifier = NULL;
        }
        if (g_hDefaultKey != NULL)
        {
            RegCloseKey(g_hDefaultKey);
            g_hDefaultKey = NULL;
        }
    }

#ifdef _POLICY
    // on first call only create the policy notifier
    if (g_hPolicyRegNotifier == NULL)
        g_hPolicyRegNotifier = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hPolicyKey == NULL)
    {
        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REG_POLICY_PARAMETERS,
            0,
            KEY_READ,
            &g_hPolicyKey
            );
    }

    // setup the policy registry notifier
    if (g_hPolicyRegNotifier &&
        g_hPolicyKey &&
        RegNotifyChangeKeyValue(
            g_hPolicyKey,
            TRUE,
            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
            g_hPolicyRegNotifier,
            TRUE
            ) == ERROR_SUCCESS)
    {
        SNMPDBG((SNMP_LOG_TRACE,
                "SNMP: REG: Policy reg notifier initialized successfully.\n"));
        nEvents++;
    }
    else
    {
        SNMPDBG((SNMP_LOG_TRACE,
            "SNMP: REG: Policy reg notifier initialization failed.\n"));

        if (g_hPolicyRegNotifier != NULL)
        {
            CloseHandle(g_hPolicyRegNotifier);
            g_hPolicyRegNotifier = NULL;
        }
        if (g_hPolicyKey != NULL)
        {
            RegCloseKey(g_hPolicyKey);
            g_hPolicyKey = NULL;
        }
    }

#endif

    SNMPDBG((SNMP_LOG_TRACE,
        "SNMP: REG: Initialized notifiers ... %d.\n", nEvents));

    return nEvents;
}

BOOL UnloadRegistryNotifiers();

INT
WaitOnRegNotification(
    )
/*++

Routine Description:

    Blocking call - waits for a notification that one of the registry parameters has change

Arguments:

    None.

Return Values:

    Returns the notifyer index (0 for the termination event, !=0 for parameter change)

--*/
{
    HANDLE hNotifiers[3]; // hack - we now (hardcoded) that we are not going to wait for more than three events.
    DWORD  dwNotifiers = 0;
    DWORD  retCode;

    hNotifiers[dwNotifiers++] = g_hTerminationEvent;
    
    if (g_hDefaultRegNotifier != NULL)
        hNotifiers[dwNotifiers++] = g_hDefaultRegNotifier;

#ifdef _POLICY
    if (g_hPolicyRegNotifier != NULL)
        hNotifiers[dwNotifiers++] = g_hPolicyRegNotifier;
#endif

    SNMPDBG((SNMP_LOG_WARNING,
            "SNMP: REG: Will listen for params changes on %d notifiers.\n",
            dwNotifiers));

    retCode = WaitForMultipleObjects(
                dwNotifiers,
                hNotifiers,
                FALSE,
                INFINITE);

    UnloadRegistryNotifiers();

    return retCode;
}
                       
/*++
    Inplace parser for the string formatted OID.
    It is done in O(n) where n is the length of the string formatted OID (two passes)
--*/
BOOL
ConvStringToOid(
    LPTSTR  pStr,
    AsnObjectIdentifier *pOid)
{
    LPTSTR pDup;
    int    iComp;
    DWORD  dwCompValue;
    enum
    {   DOT,
        DIGIT
    }  state = DIGIT;

    // no need to check for parameters consistency (internal call->correct call :o)

    // check the consistency and determine the number of components
    pOid->idLength = 0;

    if (*pStr == _T('.'))   // skip a possible leading '.'
        pStr++;

    for (pDup = pStr; *pDup != _T('\0'); pDup++)
    {
        switch(state)
        {
        case DOT:
            // note: a trailing dot results in a trailing 0
            if (*pDup == _T('.'))
            {
                pOid->idLength++;
                state = DIGIT;
                break;
            }
            // intentionally missing 'break'
        case DIGIT:
            if (*pDup < _T('0') || *pDup > _T('9'))
                return FALSE;
            state = DOT;
            break;
        }
    }
    // add one to the id length as a trailing dot might not be present
    pOid->idLength++;

    // accept oids with two components at least;
    // alloc memory and check for success;
    if (pOid->idLength < 2 ||
        (pOid->ids = SnmpUtilMemAlloc(pOid->idLength * sizeof(UINT))) == NULL)
        return FALSE;

    // we have now enough buffer and a correct input string. Just convert it to OID
    iComp = 0;
    dwCompValue = 0;
    for (pDup = pStr; *pDup != _T('\0'); pDup++)
    {
        if (*pDup == _T('.'))
        {
            pOid->ids[iComp++] = dwCompValue;
            dwCompValue = 0;
        }
        else
        {
            dwCompValue = dwCompValue * 10 + (*pDup - _T('0'));
        }
    }
    pOid->ids[iComp] = dwCompValue;

    return TRUE;
}

BOOL
LoadScalarParameters(
    )

/*++

Routine Description:

    Reads authentication trap flags key and manager timeout value.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    TCHAR szName[MAX_PATH];
    TCHAR szValue[MAX_PATH];
    LPTSTR pszKey = REG_KEY_SNMP_PARAMETERS;
    BOOL  bChangedSysID = FALSE;

    // default value for the IsnmpNameResolutionRetries counter
    // an address will resist to no more than MGRADDR_DYING (16 by default) 
    // consecutive name resolution failures.
    snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number = MGRADDR_DYING;

    // open registry subkey    
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS) 
    {
        // initialize
        dwIndex = 0;

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) 
        {

            // initialize buffer sizes
            dwNameSize  = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
            dwValueSize = sizeof(szValue); // size in number of bytes

            // read next value
            lStatus = RegEnumValue(
                        hKey, 
                        dwIndex, 
                        szName, 
                        &dwNameSize,
                        NULL, 
                        &dwValueType, 
                        (LPBYTE)szValue, 
                        &dwValueSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS)
            {

                // validate name of value
                if (!lstrcmpi(szName, REG_VALUE_AUTH_TRAPS))
                {
                    // set the 'EnableAuthenTraps' in the internal management structure
                    mgmtISet(IsnmpEnableAuthenTraps, *((PDWORD)szValue));
                }
                else if (!lstrcmpi(szName, REG_VALUE_MGRRES_COUNTER))
                {
                    // set the 'NameResolutionRetries' in the internal management structure
                    mgmtISet(IsnmpNameResolutionRetries, *((PDWORD)szValue));
                }
                            
                // next
                dwIndex++;

            }
        }

        RegCloseKey(hKey);
    } 

    // look into MIB2 subtree ..SNMP\Parameters\RFC1156Agent for sysObjectID parameter
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_MIB2,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        LPTSTR  pszOid = szValue;

        dwValueSize = sizeof(szValue); // size in number of bytes

        // first, get the size of the buffer required for the sysObjectID parameter
        lStatus = RegQueryValueEx(
                    hKey,
                    REG_VALUE_SYS_OBJECTID,
                    0,
                    &dwValueType,
                    (LPBYTE)pszOid,
                    &dwValueSize);

        // the ERROR_MORE_DATA is the only error code we expect at this point
        if (lStatus == ERROR_MORE_DATA)
        {
            pszOid = SnmpUtilMemAlloc(dwValueSize);

            // if a buffer was set up correctly, go an read the oid value
            if (pszOid != NULL)
            {
                lStatus = RegQueryValueEx(
                            hKey,
                            REG_VALUE_SYS_OBJECTID,
                            0,
                            &dwValueType,
                            (LPBYTE)pszOid,
                            &dwValueSize);
            }
        }

        // at this point we should succeed
        if (lStatus == ERROR_SUCCESS)
        {
            AsnObjectIdentifier sysObjectID;
            // we have the string representation of the oid, convert it now to an AsnObjectIdentifier

            // implement the convertion here, as I don't want to make this a public function in SNMPAPI.DLL
            // otherwise I'll be forced to handle a lot of useless limit cases..
            if (dwValueType == REG_SZ &&
                ConvStringToOid(pszOid, &sysObjectID))
            {
                // don't free what has been alocated in ConvStringToOid as the buffer will be passed
                // to the management variable below.
                bChangedSysID = (mgmtOSet(OsnmpSysObjectID, &sysObjectID, FALSE) == ERROR_SUCCESS);
            }
            else
            {
                SNMPDBG((SNMP_LOG_WARNING,
                         "SNMP: SVC: LoadScalarParameters() - invalid type or value for sysObjectID param.\n"));

                ReportSnmpEvent(
                    SNMP_EVENT_INVALID_ENTERPRISEOID,
                    0,
                    NULL,
                    0);
            }
        }

        // cleanup the buffer if it was dynamically allocated
        if (pszOid != szValue)
            SnmpUtilMemFree(pszOid);

        // cleanup the registry key
        RegCloseKey(hKey);
    }

    if (!bChangedSysID)
    {
        mgmtOSet(OsnmpSysObjectID, SnmpSvcGetEnterpriseOID(), TRUE);
    }
    // all parameters here have default values, so there is no reason for this function to fail
    // if a parameter could not be found into the registry, its default value will be considered.
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadRegistryParameters(
    )

/*++

Routine Description:

    Loads registry parameters.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // first thing to do is to setup the registry notifiers. If we don't do this before reading
    // the registry values we might not sense an initial change of the registry.
    InitRegistryNotifiers();

    // need to load first the scalar parameters especially to know how
    // to handle further the name resolution
    LoadScalarParameters();

    // load managers
    LoadPermittedManagers(TRUE);

    // load trap destinations
    LoadTrapDestinations(TRUE);

    // load communities with dynamic update
    LoadValidCommunities(TRUE);

    // load subagents
    LoadSubagents();

    // determine regions
    LoadSupportedRegions();

    return TRUE;
}

BOOL
UnloadRegistryNotifiers(
    )
/*++

Routine Description:

    Unloads registry notifiers

Arguments:

    None.

Return Values:

    Returns TRUE

--*/
{
    if (g_hDefaultRegNotifier != NULL)
    {
        CloseHandle(g_hDefaultRegNotifier);
        g_hDefaultRegNotifier = NULL;
    }
#ifdef _POLICY
    if (g_hPolicyRegNotifier != NULL)
    {
        CloseHandle(g_hPolicyRegNotifier);
        g_hPolicyRegNotifier = NULL;
    }
#endif

    if (g_hDefaultKey != NULL)
    {
        RegCloseKey(g_hDefaultKey);
        g_hDefaultKey = NULL;
    }
#ifdef _POLICY
    if (g_hPolicyKey != NULL)
    {
        RegCloseKey(g_hPolicyKey);
        g_hPolicyKey = NULL;
    }
#endif

    return TRUE;
}


BOOL
UnloadRegistryParameters(
    )

/*++

Routine Description:

    Unloads registry parameters.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // unload the registry notifiers as the first thing to do
    UnloadRegistryNotifiers();

    // unload managers
    UnloadPermittedManagers();

    // unload trap destinations
    UnloadTrapDestinations();

    // unload communities
    UnloadValidCommunities();

    // unload subagents
    UnloadSubagents();

    // unload mib regions
    UnloadSupportedRegions();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\query.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    query.c

Abstract:

    Contains routines for querying subagents.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "varbinds.h"
#include "network.h"
#include "query.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindQueryBySLE(
    PQUERY_LIST_ENTRY * ppQLE,
    PNETWORK_LIST_ENTRY pNLE,
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Allocates query list entry.

Arguments:

    ppQLE - pointer to receive query entry pointer.

    pNLE - pointer to network list entry.

    pSLE - pointer to subagent list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE = NULL;

    // point to first query
    pLE = pNLE->Queries.Flink;

    // process each query
    while (pLE != &pNLE->Queries) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // compare subagents
        if (pQLE->pSLE == pSLE) {

            // transfer
            *ppQLE = pQLE;

            // success
            return TRUE;
        }
            
        // next entry
        pLE = pLE->Flink;        
    }

    // initialize
    *ppQLE = NULL;

    // failure
    return FALSE;
}


BOOL
LoadSubagentData(
    PNETWORK_LIST_ENTRY pNLE,
    PQUERY_LIST_ENTRY   pQLE
    )

/*++

Routine Description:

    Loads data to be passed to the subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    pQLE - pointer to current query.

Return Values:

    Returns true if successful.

--*/

{   
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
        
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: query 0x%08lx loading.\n", pQLE
        ));    

    // attempt to allocate varbind list    
    pQLE->SubagentVbl.list = SnmpUtilMemAlloc(
                                pQLE->nSubagentVbs * sizeof(SnmpVarBind)
                                );

    // validate varbind list pointer
    if (pQLE->SubagentVbl.list != NULL) {

        // point to first varbind
        pLE = pQLE->SubagentVbs.Flink;

        // process each outgoing varbind
        while (pLE != &pQLE->SubagentVbs) {

            // retrieve pointer to varbind entry from query link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, QueryLink);

            // transfer varbind
            if (SnmpUtilVarBindCpy(
                &pQLE->SubagentVbl.list[pQLE->SubagentVbl.len],
                &pVLE->ResolvedVb
                ) == 0)
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: could not transfer varbind to subagent.\n"
                    ));

                return FALSE;
            }

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: variable %d copied to query 0x%08lx.\n",
                pVLE->nErrorIndex,
                pQLE
                ));
            
            // increment
            pQLE->SubagentVbl.len++;

            // next entry
            pLE = pLE->Flink;        
        }

    
    } else {

        SNMPDBG((   
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate varbind list.\n"
            ));
        
        // failure    
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
UnloadSubagentData(
    PQUERY_LIST_ENTRY pQLE 
    )

/*++

Routine Description:

    Unloads data passed to the subagent DLL.

Arguments:

    pQLE - pointer to current query.

Return Values:

    Returns true if successful.

--*/

{   
    __try {
    
        // release subagent varbind list
        SnmpUtilVarBindListFree(&pQLE->SubagentVbl);

    
    } __except (EXCEPTION_EXECUTE_HANDLER) {
                
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx processing structure from %s.\n",
            GetExceptionCode(),
            (pQLE->pSLE != NULL)
                ? pQLE->pSLE->pPathname 
                : "<unknown>"
            ));

        // failure
        return FALSE;    
    }

    // success
    return TRUE;
}


BOOL
UpdateResolvedVarBind(
    PQUERY_LIST_ENTRY   pQLE,
    PVARBIND_LIST_ENTRY pVLE,
    UINT                iVb
    )

/*++

Routine Description:

    Updates resolved varbind with data from subagent DLL.

Arguments:

    pQLE - pointer to current query.

    pVLE - pointer to varbind.

    iVb - index of varbind.

Return Values:

    Returns true if successful.

--*/

{
    // see if this is non-repeater
    if (pVLE->nMaxRepetitions == 1) {

        // flag varbind as resolved
        pVLE->nState = VARBIND_RESOLVED;

        // release memory for current varbind
        SnmpUtilVarBindFree(&pVLE->ResolvedVb);

        // transfer varbind from subagent
        if (SnmpUtilVarBindCpy(&pVLE->ResolvedVb, 
                           &pQLE->SubagentVbl.list[iVb]
                           ) == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not transfer varbind from subagent.\n"
                ));

            return FALSE;
        }

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: variable %d name %s.\n",
            pVLE->nErrorIndex,
            SnmpUtilOidToA(&pVLE->ResolvedVb.name)
            ));    

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: variable %d state '%s'.\n",
            pVLE->nErrorIndex,
            VARBINDSTATESTRING(pVLE->nState)
            ));    

        // success
        return TRUE;
    } 
    
    // see if varbind list allocated
    if ((pVLE->ResolvedVbl.len == 0) &&
        (pVLE->ResolvedVbl.list == NULL)) {

        if (sizeof(SnmpVarBind) > (UINT_MAX/pVLE->nMaxRepetitions))
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: arithmetic overflow: sizeof(SnmpVarBind) 0x%x, pVLE->nMaxRepetitions 0x%x.\n",
                sizeof(SnmpVarBind), pVLE->nMaxRepetitions
                ));

            return FALSE; // bail...
        }

        // allocate varbind list to fill in
        pVLE->ResolvedVbl.list = SnmpUtilMemAlloc(
                                    pVLE->nMaxRepetitions *
                                    sizeof(SnmpVarBind)
                                    );    
        // validate pointer before continuing
        if (pVLE->ResolvedVbl.list == NULL) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not allocate new varbinds.\n"
                ));
    
            // failure
            return FALSE;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: pVLE->ResolvedVbl.len %d pVLE->nMaxRepetitions %d.\n",
        pVLE->ResolvedVbl.len, pVLE->nMaxRepetitions
        ));

    // release working varbind name
    SnmpUtilOidFree(&pVLE->ResolvedVb.name);

    // transfer name for next iteration
    if (SnmpUtilOidCpy(&pVLE->ResolvedVb.name,
                   &pQLE->SubagentVbl.list[iVb].name 
                   ) == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not transfer name for next iteration.\n"
            ));

        return FALSE;
    }

    // transfer varbind
    if (SnmpUtilVarBindCpy( 
        &pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len],
        &pQLE->SubagentVbl.list[iVb]) == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not transfer varbind from subagent.\n"
            ));

        return FALSE;
    }

    // increment count
    pVLE->ResolvedVbl.len++;
                
    // see if this is the last varbind to retrieve
    pVLE->nState = (pVLE->nMaxRepetitions > pVLE->ResolvedVbl.len)
                        ? VARBIND_PARTIALLY_RESOLVED
                        : VARBIND_RESOLVED
                        ;            

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: variable %d name %s.\n",
        pVLE->nErrorIndex,
        SnmpUtilOidToA(&pVLE->ResolvedVb.name)
        ));    

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: variable %d state '%s'.\n",
        pVLE->nErrorIndex,
        VARBINDSTATESTRING(pVLE->nState)
        ));    

    // success
    return TRUE;
}


BOOL
UpdateVarBind(
    PNETWORK_LIST_ENTRY pNLE,
    PQUERY_LIST_ENTRY   pQLE,
    PVARBIND_LIST_ENTRY pVLE,
    UINT                iVb
    )

/*++

Routine Description:

    Updates varbind with data from subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    pQLE - pointer to current query.

    pVLE - pointer to varbind.

    iVb - index of varbind.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    INT nDiff1;
    INT nDiff2;

    __try {
                        
        // determine order of returned varbind
        nDiff1 = SnmpUtilOidCmp(&pQLE->SubagentVbl.list[iVb].name,
                                &pVLE->ResolvedVb.name
                                );

        // see if this is getnext or getbulk 
        if ((pNLE->Pdu.nType == SNMP_PDU_GETNEXT) ||
            (pNLE->Pdu.nType == SNMP_PDU_GETBULK)) {
            
            // determine whether returned varbind in range
            nDiff2 = SnmpUtilOidCmp(&pQLE->SubagentVbl.list[iVb].name,
                                    &pVLE->pCurrentRLE->LimitOid
                                    );

            // make sure returned oid in range
            if ((nDiff1 > 0) && (nDiff2 < 0)) {

                // update resolved variable binding
                return UpdateResolvedVarBind(pQLE, pVLE, iVb);

            } else if (nDiff2 >= 0) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: %s received getnext request for %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: %s returned out-of-range oid %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                    ));
                
                // retrieve pointer to next region
                pLE = pVLE->pCurrentRLE->Link.Flink;

                // see if we exhausted regions
                if (pLE != &g_SupportedRegions) {

                    PMIB_REGION_LIST_ENTRY pNextRLE;

                    // retrieve pointer to mib region 
                    pNextRLE = CONTAINING_RECORD(pLE, 
                                                 MIB_REGION_LIST_ENTRY, 
                                                 Link
                                                 );
                                            
                    // see if next region supported by same subagent
                    if (pVLE->pCurrentRLE->pSLE == pNextRLE->pSLE) {

                        BOOL retCode;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: SVC: next region also supported by %s.\n",
                            pVLE->pCurrentRLE->pSLE->pPathname
                            ));    

                        // update resolved variable binding
                        retCode = UpdateResolvedVarBind(pQLE, pVLE, iVb);
                        if (pQLE->SubagentVbl.list[iVb].value.asnType != ASN_NULL)
                        {
                            return retCode;
                        }
                        else
                        {
                            SNMPDBG((
                                SNMP_LOG_VERBOSE,
                                "SNMP: SVC: pQLE->SubagentVbl.list[%d].name = %s got ASN_NULL value.\n",
                                iVb, SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                                ));
                            
                            // BUG# 610475
                            if (retCode)
                            {
                                // UpdateResolvedVarBind succeeds but 
                                // pQLE->SubagentVbl.list[iVb].value has 
                                // ASN_NULL value.
                                if (pVLE->nMaxRepetitions > 1)
                                {
                                    // rollback what has been done in
                                    // UpdateResolvedVarBind when
                                    // (pVLE->nMaxRepetitions > 1).
                                    if (pVLE->ResolvedVbl.len)
                                    {
                                        SNMPDBG((
                                            SNMP_LOG_VERBOSE,
                                            "SNMP: SVC: rollback what has been done in UpdateResolvedVarBind.\n"
                                            ));

                                        // decrement count
                                        pVLE->ResolvedVbl.len--;

                                        // free any resource allocated by UpdateResolvedVarBind
                                        SnmpUtilVarBindFree(&pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len]);
                                    }
                                }
                                // pVLE->nState will set to  
                                // VARBIND_PARTIALLY_RESOLVED to make another 
                                // query below.
                            }
                            else
                            {
                                SNMPDBG((
                                    SNMP_LOG_ERROR,
                                    "SNMP: SVC: UpdateVarBind: UpdateResolvedVarBind failed. pQLE->SubagentVbl.list[%d].name = %s.\n",
                                    iVb, SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                                    ));    
                        
                                return retCode;
                            }
                        }
                    }

                    // point to next region 
                    pVLE->pCurrentRLE = pNextRLE;
                    
                    // change state to partially resolved
                    pVLE->nState = VARBIND_PARTIALLY_RESOLVED;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: SVC: variable %d re-assigned to %s.\n",
                        pVLE->nErrorIndex,
                        pVLE->pCurrentRLE->pSLE->pPathname
                        ));    
                } 
                
                else if ((pVLE->ResolvedVbl.len == 0) &&
                    (pVLE->ResolvedVbl.list == NULL)) {

                    // flag varbind as resolved
                    pVLE->nState = VARBIND_RESOLVED;

                    // set default varbind to eomv
                    pVLE->ResolvedVb.value.asnType = 
                        SNMP_EXCEPTION_ENDOFMIBVIEW;
                        
                    // update error status counter for the operation
                    mgmtCTick(CsnmpOutNoSuchNames);

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    

                } else {                
                
                    // transfer name
                    if (SnmpUtilOidCpy(
                        &pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len].name,
                        &pVLE->ResolvedVb.name) == 0)
                    {
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: could not transfer name at line %d.\n",
                            __LINE__
                            ));

                        return FALSE;
                    }

                    // flag varbind as resolved
                    pVLE->nState = VARBIND_RESOLVED;

                    // set current varbind to eomv
                    pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len].value.asnType =
                        SNMP_EXCEPTION_ENDOFMIBVIEW;

                    // increment count
                    pVLE->ResolvedVbl.len++;

                    // update error status counter for the operation
                    mgmtCTick(CsnmpOutNoSuchNames);

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    
                }                                                

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s received getnext request for %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s returned invalid oid %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                    ));

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: Ban %s subagent, forward the request to a different one.\n",
                    pQLE->pSLE->pPathname
                    ));

                // trying to forward this getnext request to the next region but only if not handled
                // by the same subagent!
                pLE = pVLE->pCurrentRLE->Link.Flink;
                while( pLE != &g_SupportedRegions)
                {
                    PMIB_REGION_LIST_ENTRY pNextRLE;

                   // retrieve pointer to mib region 
                    pNextRLE = CONTAINING_RECORD(pLE, 
                                                 MIB_REGION_LIST_ENTRY, 
                                                 Link
                                                 );

                    // if this 'next' region is handled by the same subagent, skip to the next!
                    if (pVLE->pCurrentRLE->pSLE == pNextRLE->pSLE)
                    {
                        pLE = pNextRLE->Link.Flink;
                        continue;
                    }

                    // ok, we have one, forward the original GetNext request to it
                    pVLE->pCurrentRLE = pNextRLE;
                    pVLE->nState = VARBIND_PARTIALLY_RESOLVED;

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: SVC: variable %d re-assigned to %s.\n",
                        pVLE->nErrorIndex,
                        pVLE->pCurrentRLE->pSLE->pPathname
                        ));
                    
                    return TRUE;
                }

                // failure
                // here I should emulate a (NO_SUCH_NAME) EndOfMibView, resolve the variable and return TRUE.
                pVLE->nState = VARBIND_RESOLVED;
                pVLE->ResolvedVb.value.asnType = SNMP_EXCEPTION_ENDOFMIBVIEW;
                pVLE->pCurrentRLE = NULL;

                // update error status counter
                mgmtCTick(CsnmpOutNoSuchNames);

                return TRUE;
            }

        } else if (pNLE->Pdu.nType == SNMP_PDU_GET) {

            // must match
            if (nDiff1 == 0) {

                // flag varbind as resolved
                pVLE->nState = VARBIND_RESOLVED;

                // release memory for current varbind
                SnmpUtilVarBindFree(&pVLE->ResolvedVb);

                // transfer varbind from subagent
                if (SnmpUtilVarBindCpy(&pVLE->ResolvedVb, 
                                   &pQLE->SubagentVbl.list[iVb]) == 0)
                {
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: could not transfer varbind from subagent at line %d.\n",
                        __LINE__
                        ));

                    return FALSE;
                }

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d name %s.\n",
                    pVLE->nErrorIndex,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s received get request for %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s returned invalid oid %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                    ));
                
                // failure
                return FALSE;
            }

        } else if (nDiff1 != 0) { 
            // set request failed -> invalid oid            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: %s received set request for %s.\n",
                pQLE->pSLE->pPathname,
                SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                ));

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: %s returned invalid oid %s.\n",
                pQLE->pSLE->pPathname,
                SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                ));
            
            // failure
            return FALSE;
        } else {

            // set request, oids match
            // WARNING!! - state might be set prematurely on SET_TEST / SET_CLEANUP
            pVLE->nState = VARBIND_RESOLVED;
            return TRUE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
                
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx processing structure from %s.\n",
            GetExceptionCode(),
            pQLE->pSLE->pPathname
            ));

        // failure
        return FALSE;        
    }

    // success
    return TRUE;   
}


BOOL
UpdateVarBinds(
    PNETWORK_LIST_ENTRY pNLE,
    PQUERY_LIST_ENTRY   pQLE 
    )

/*++

Routine Description:

    Updates varbind list entries with data from subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    pQLE - pointer to current query.

Return Values:

    Returns true if successful.

--*/

{   
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
    BOOL fOk = TRUE;
    UINT iVb = 0;
            
    // point to first varbind
    pLE = pQLE->SubagentVbs.Flink;

    // see if error encountered during callback
    if (pQLE->nErrorStatus == SNMP_ERRORSTATUS_NOERROR) {
    
        // process each outgoing varbind
        while (pLE != &pQLE->SubagentVbs) {

            // retrieve pointer to varbind entry from query link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, QueryLink);
            
            // update individual varbind
            if (!UpdateVarBind(pNLE, pQLE, pVLE, iVb++)) {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: variable %d could not be updated.\n", 
                    pQLE->nErrorIndex
                    ));    

                // update pdu with the proper varbind error index    
                pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                // failure
                return FALSE;
            }

            // next entry
            pLE = pLE->Flink; 
        }
    
    } else {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: searching for errant variable.\n" 
            ));    

        // update pdu with status returned from subagent
        pNLE->Pdu.Pdu.NormPdu.nErrorStatus = pQLE->nErrorStatus;

        // process each outgoing varbind
        while (pLE != &pQLE->SubagentVbs) {

            // retrieve pointer to varbind entry from query link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, QueryLink);
            
            // see if errant varbind nErrorIndex is starts from 1 !!
            if (pQLE->nErrorIndex == ++iVb) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: variable %d involved in failure.\n",
                    pVLE->nErrorIndex
                    ));    

                // update pdu with the proper varbind error index    
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex = pVLE->nErrorIndex;

                // the error code was successfully identified
                return  TRUE;
            }

            // next entry
            pLE = pLE->Flink; 
        }
        
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: no variable involved in failure.\n"
            ));    

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
CallSubagent(
    PQUERY_LIST_ENTRY pQLE,
    UINT              nRequestType,
    UINT              nTransactionId
    )

/*++

Routine Description:
    Invokes method from subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    nRequestType - type of request to post to subagent.

    nTransactionId - identifies snmp pdu sent from manager.

Return Values:

    Returns true if successful.

--*/

{   
    BOOL fOk = FALSE;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: --- query %s begin ---\n", 
        pQLE->pSLE->pPathname
        ));    

    __try {
        
        // determine which version of query supported
        if (pQLE->pSLE->pfnSnmpExtensionQueryEx != NULL) {

            // process query using new interface
            fOk = (*pQLE->pSLE->pfnSnmpExtensionQueryEx)(
                        nRequestType,
                        nTransactionId,
                        &pQLE->SubagentVbl,
                        &pQLE->ContextInfo,
                        &pQLE->nErrorStatus,
                        &pQLE->nErrorIndex
                        );
                                                
        // see if query is actually valid for downlevel call
        } else if ((pQLE->pSLE->pfnSnmpExtensionQuery != NULL) &&
                  ((nRequestType == SNMP_EXTENSION_GET) ||
                   (nRequestType == SNMP_EXTENSION_GET_NEXT) ||
                   (nRequestType == SNMP_EXTENSION_SET_COMMIT))) {
            
            // process query using old interface
            fOk = (*pQLE->pSLE->pfnSnmpExtensionQuery)(
                        (BYTE)(UINT)nRequestType,
                        &pQLE->SubagentVbl,
                        &pQLE->nErrorStatus,
                        &pQLE->nErrorIndex
                        );

        // see if query can be completed successfully anyway
        } else if ((nRequestType == SNMP_EXTENSION_SET_TEST) ||
                   (nRequestType == SNMP_EXTENSION_SET_CLEANUP)) { 

            // fake it
            fOk = TRUE;    
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx calling %s.\n",
            GetExceptionCode(),
            pQLE->pSLE->pPathname
            ));
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: --- query %s end ---\n", 
        pQLE->pSLE->pPathname
        ));    

    // validate
    if (!fOk) {
    
        // identify failing subagent
        pQLE->nErrorStatus = SNMP_ERRORSTATUS_GENERR;
        pQLE->nErrorIndex  = 1; 

    } else if (pQLE->nErrorStatus != SNMP_ERRORSTATUS_NOERROR) {

        // see if error index needs to be adjusted
        if ((pQLE->nErrorIndex > pQLE->nSubagentVbs) ||
            (pQLE->nErrorIndex == 0)) {

            // set to first varbind
            pQLE->nErrorIndex = 1; 
        }
    
    } else {

        // re-initialize
        pQLE->nErrorIndex = 0; 
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: query 0x%08lx %s, errorStatus=%s, errorIndex=%d.\n", 
        pQLE,
        (pQLE->nErrorStatus == SNMP_ERRORSTATUS_NOERROR)
            ? "succeeded"
            : "failed"
            ,
        SNMPERRORSTRING(pQLE->nErrorStatus),
        pQLE->nErrorIndex
        ));    

    return TRUE;
}


BOOL
ProcessSet(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Processes SNMP_PDU_SET requests.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE = NULL;
    PQUERY_LIST_ENTRY pQLE;
    BOOL fOk = TRUE;

    // load subagent queries
    if (!LoadQueries(pNLE)) {

        // unload immediately
        UnloadQueries(pNLE);

        // failure
        return FALSE;
    }
    
    // point to first query
    pLE = pNLE->Queries.Flink;

    // process each subagent query 
    while (fOk && (pLE != &pNLE->Queries)) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // load outgoing varbinds
        fOk = LoadSubagentData(pNLE, pQLE);

        // validate
        if (fOk) {

            // dispatch 
            CallSubagent(
                pQLE, 
                SNMP_EXTENSION_SET_TEST,
                pNLE->nTransactionId
                );

            // process results returned
            fOk = UpdateVarBinds(pNLE, pQLE);
        }

        // next entry (or reverse direction)
        pLE = fOk ? pLE->Flink : pLE->Blink;
    }
    
    // validate
    if (fOk) {

        // if this line is missing => GenErr on UpdatePdu()
        pLE = pNLE->Queries.Flink;

        // process each subagent query 
        while (fOk && (pLE != &pNLE->Queries)) {

            // retrieve pointer to query entry from link
            pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

            // dispatch 
            CallSubagent(
                pQLE, 
                SNMP_EXTENSION_SET_COMMIT,
                pNLE->nTransactionId
                );

            // process results returned
            fOk = UpdateVarBinds(pNLE, pQLE);

            // next entry (or reverse direction)
            pLE = fOk ? pLE->Flink : pLE->Blink;
        }

        // validate
        if (!fOk) {

            // process each subagent query 
            while (pLE != &pNLE->Queries) {

                // retrieve pointer to query entry from link
                pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

                // dispatch 
                CallSubagent(
                    pQLE, 
                    SNMP_EXTENSION_SET_UNDO,
                    pNLE->nTransactionId
                    );

                // process results returned
                UpdateVarBinds(pNLE, pQLE);

                // previous entry 
                pLE = pLE->Blink;
            }
        }

        // point to last query
        pLE = pNLE->Queries.Blink;
    }
        
    // process each subagent query 
    while (pLE != &pNLE->Queries) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // dispatch 
        CallSubagent(
            pQLE, 
            SNMP_EXTENSION_SET_CLEANUP,
            pNLE->nTransactionId
            );

        // process results returned
        UpdateVarBinds(pNLE, pQLE);

        // previous entry 
        pLE = pLE->Blink;
    }

    // cleanup queries
    UnloadQueries(pNLE);

    return TRUE;
}


BOOL
ProcessGet(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Queries subagents to resolve varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE = NULL;
    BOOL fOk = TRUE;

    // load subagent queries
    if (!LoadQueries(pNLE)) {

        // unload immediately
        UnloadQueries(pNLE);

        // failure
        return FALSE;
    }
        
    // point to first query
    pLE = pNLE->Queries.Flink;

    // process each subagent query 
    while (fOk && (pLE != &pNLE->Queries)) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // load outgoing varbinds
        fOk = LoadSubagentData(pNLE, pQLE);

        // validate
        if (fOk) {

            // dispatch 
            CallSubagent(
                pQLE, 
                SNMP_EXTENSION_GET,
                pNLE->nTransactionId
                );

            // process results returned
            fOk = UpdateVarBinds(pNLE, pQLE);
        }

        // next entry
        pLE = pLE->Flink;        
    }
    
    // cleanup queries
    UnloadQueries(pNLE);

    return fOk;
}


BOOL
ProcessGetBulk(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Queries subagents to resolve varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE = NULL;
    BOOL fOk = TRUE;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: getbulk request, non-repeaters %d, max-repetitions %d.\n",
        pNLE->Pdu.Pdu.BulkPdu.nNonRepeaters,
        pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions
        ));

    // loop
    while (fOk) {

        // load subagent queries
        fOk = LoadQueries(pNLE);

        // validate
        if (fOk && !IsListEmpty(&pNLE->Queries)) {

            // point to first query
            pLE = pNLE->Queries.Flink;

            // process each subagent query 
            while (fOk && (pLE != &pNLE->Queries)) {

                // retrieve pointer to query entry from link
                pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

                // load outgoing varbinds
                fOk = LoadSubagentData(pNLE, pQLE);

                // validate
                if (fOk) {

                    // dispatch 
                    CallSubagent(
                        pQLE, 
                        SNMP_EXTENSION_GET_NEXT,
                        pNLE->nTransactionId
                        );

                    // process results returned
                    fOk = UpdateVarBinds(pNLE, pQLE);
                }

                // next entry
                pLE = pLE->Flink;        
            }

        } else if (IsListEmpty(&pNLE->Queries)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: no more queries to process.\n"
                ));

            break; // finished...
        }

        // cleanup queries
        UnloadQueries(pNLE);
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocQLE(
    PQUERY_LIST_ENTRY * ppQLE
    )

/*++

Routine Description:

    Allocates query list entry.

Arguments:

    ppQLE - pointer to receive list entry pointer.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PQUERY_LIST_ENTRY pQLE = NULL;

    // attempt to allocate structure
    pQLE = AgentMemAlloc(sizeof(QUERY_LIST_ENTRY));

    // validate
    if (pQLE != NULL) {

        // initialize outgoing varbind list
        InitializeListHead(&pQLE->SubagentVbs);        

        // success
        fOk = TRUE;
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate query.\n"
            ));
    }    

    // transfer
    *ppQLE = pQLE;

    return fOk;
}


BOOL
FreeQLE(
    PQUERY_LIST_ENTRY pQLE
    )

/*++

Routine Description:

    Creates queries from varbind list entries.

Arguments:

    pNLE - pointer to network list entry with SNMP message.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pQLE != NULL) {

        // release subagent info
        UnloadSubagentData(pQLE);

        // release structure
        AgentMemFree(pQLE);
    }

    return TRUE;
}


BOOL
LoadQueries(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Creates queries from varbind list entries.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
    PQUERY_LIST_ENTRY pQLE = NULL;

    // point to first varbind
    pLE = pNLE->Bindings.Flink;

    // process each binding
    while (pLE != &pNLE->Bindings) {

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

        // analyze current state of varbind        
        if ((pVLE->nState == VARBIND_INITIALIZED) ||
            (pVLE->nState == VARBIND_PARTIALLY_RESOLVED)) {

            // attempt to locate existing query
            if (FindQueryBySLE(&pQLE, pNLE, pVLE->pCurrentRLE->pSLE)) {

                // attach varbind entry to query via query link
                InsertTailList(&pQLE->SubagentVbs, &pVLE->QueryLink);

                // change varbind state
                pVLE->nState = VARBIND_RESOLVING;

                // increment total
                pQLE->nSubagentVbs++;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d added to existing query 0x%08lx.\n",
                    pVLE->nErrorIndex,
                    pQLE
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

            // attempt to allocate entry
            } else if (AllocQLE(&pQLE)) {
                
                // obtain subagent pointer
                pQLE->pSLE = pVLE->pCurrentRLE->pSLE;

                // insert into query list 
                InsertTailList(&pNLE->Queries, &pQLE->Link);

                // attach varbind entry to query via query link
                InsertTailList(&pQLE->SubagentVbs, &pVLE->QueryLink);

                // change varbind state
                pVLE->nState = VARBIND_RESOLVING;

                // increment total
                pQLE->nSubagentVbs++;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d added to new query 0x%08lx.\n",
                    pVLE->nErrorIndex,
                    pQLE
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

            } else {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: could not contruct query.\n"
                    ));

                // failure
                return FALSE;
            }
        }

        // next entry
        pLE = pLE->Flink;
    }
    
    // success    
    return TRUE;
}


BOOL
UnloadQueries(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Destroys queries from varbind list entries.

Arguments:

    pNLE - pointer to network list entry with SNMP message.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE;
    
    // process each query entry
    while (!IsListEmpty(&pNLE->Queries)) {

        // point to first query
        pLE = RemoveHeadList(&pNLE->Queries);

        // retrieve pointer to query from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // release
        FreeQLE(pQLE);
    }

    return TRUE;
}


BOOL
ProcessQueries(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Queries subagents to resolve varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    // determine pdu
    switch (pNLE->Pdu.nType) {

    case SNMP_PDU_GETNEXT:
    case SNMP_PDU_GETBULK:
        
        // multiple non-exact reads
        return ProcessGetBulk(pNLE);

    case SNMP_PDU_GET:
    
        // single exact read
        return ProcessGet(pNLE);

    case SNMP_PDU_SET:

        // single exact write
        return ProcessSet(pNLE);
    }                

    // failure
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\regions.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    regions.c

Abstract:

    Contains routines for manipulating MIB region structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "subagnts.h"
#include "regions.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define WRAP_FOK(hResult) \
    do\
        {\
        fOk = (hResult);\
        if (!fOk)\
          {\
            goto Error;\
          }\
        }\
    while (FALSE)

BOOL
UpdateSupportedRegion(
    PMIB_REGION_LIST_ENTRY pExistingRLE,
    PMIB_REGION_LIST_ENTRY pRLE
    )

/*++

Routine Description:

    Updates MIB region properties based on supporting subagent.

Arguments:

    pExisingRLE - pointer to existing MIB region to be updated.

    pRLE - pointer to subagent MIB region to be analyzed and saved.

Return Values:

    Returns true if successful.

--*/

{
    INT nDiff;
    PMIB_REGION_LIST_ENTRY pSubagentRLE;

    // see if source is subagent
    if (pRLE->pSubagentRLE == NULL) {
    
        // save pointer
        pSubagentRLE = pRLE;

    } else {

        // save pointer
        pSubagentRLE = pRLE->pSubagentRLE;
    }    

    // see if target uninitialized    
    if (pExistingRLE->pSubagentRLE == NULL) {

        // save pointer to subagent region
        pExistingRLE->pSubagentRLE = pSubagentRLE;

        // save pointer to supporting subagent
        pExistingRLE->pSLE = pSubagentRLE->pSLE;        

    } else {

        UINT nSubIds1;
        UINT nSubIds2;

        // determine length of existing subagent's original prefix
        nSubIds1 = pExistingRLE->pSubagentRLE->PrefixOid.idLength;

        // determine length of new subagent's prefix
        nSubIds2 = pSubagentRLE->PrefixOid.idLength;

        // update if more specific
        if (nSubIds1 <= nSubIds2) {
        
            // save pointer to subagent region
            pExistingRLE->pSubagentRLE = pSubagentRLE;

            // save pointer to supporting subagent
            pExistingRLE->pSLE = pSubagentRLE->pSLE;        
        }             
    }

    return TRUE;
}


BOOL
SplitSupportedRegion(
    PMIB_REGION_LIST_ENTRY   pRLE1,
    PMIB_REGION_LIST_ENTRY   pRLE2,
    PMIB_REGION_LIST_ENTRY * ppLastSplitRLE
    )

/*++

Routine Description:

    Splits existing MIB region in order to insert new region.

Arguments:

    pRLE1 - pointer to first MIB region to be split.

    pRLE2 - pointer to second MIB region to be split (not released).

    ppLastSplitRLE - pointer to receiver pointer to last split MIB region.

Return Values:

    Returns true if successful.

--*/

{
    INT nLimitDiff;
    INT nPrefixDiff;
    PMIB_REGION_LIST_ENTRY pRLE3 = NULL;
    PMIB_REGION_LIST_ENTRY pRLE4 = NULL;
    PMIB_REGION_LIST_ENTRY pRLE5 = NULL;
    BOOL fOk = TRUE;

    // allocate regions
    if (!AllocRLE(&pRLE3) ||
        !AllocRLE(&pRLE4) ||
        !AllocRLE(&pRLE5)) {

        // release
        FreeRLE(pRLE3);
        FreeRLE(pRLE4);
        FreeRLE(pRLE5);

        // initialize OUT pointer to NULL for failure case
        *ppLastSplitRLE = NULL;
    
        // failure
        return FALSE;
    }

    // initialize pointer
    *ppLastSplitRLE = pRLE5;

    // calculate difference betweeen mib region limits
    nLimitDiff = SnmpUtilOidCmp(&pRLE1->LimitOid, &pRLE2->LimitOid);
        
    // calculate difference betweeen mib region prefixes
    nPrefixDiff = SnmpUtilOidCmp(&pRLE1->PrefixOid, &pRLE2->PrefixOid);
        
    // check for same prefix        
    if (nPrefixDiff != 0) {

        // first prefix less 
        if (nPrefixDiff < 0) {

            // r3.prefix equals min(rl.prefix,r2.prefix)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE3->PrefixOid, &pRLE1->PrefixOid));

            // r3.limit equals max(rl.prefix,r2.prefix)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE2->PrefixOid));

            // r3 is supported by r1 subagent 
            UpdateSupportedRegion(pRLE3, pRLE1);

        } else {

            // r3.prefix equals min(rl.prefix,r2.prefix)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE3->PrefixOid, &pRLE2->PrefixOid));

            // r3.limit equals max(rl.prefix,r2.prefix)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE1->PrefixOid));

            // r3 is supported by r2 subagent 
            UpdateSupportedRegion(pRLE3, pRLE2);
        }

        // r4.prefix equals r3.limit
        WRAP_FOK(SnmpUtilOidCpy(&pRLE4->PrefixOid, &pRLE3->LimitOid));

        // r4 is supported by both subagents
        UpdateSupportedRegion(pRLE4, pRLE1);
        UpdateSupportedRegion(pRLE4, pRLE2);

        // first limit less 
        if (nLimitDiff < 0) {

            // r4.limit equals min(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE1->LimitOid));

            // r5.prefix equals r4.limit
            WRAP_FOK(SnmpUtilOidCpy(&pRLE5->PrefixOid, &pRLE4->LimitOid));

            // r5.limit equals max(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE5->LimitOid, &pRLE2->LimitOid));

            // r5 is supported by r2 subagent 
            UpdateSupportedRegion(pRLE5, pRLE2);

            // insert third mib region into list first
            InsertHeadList(&pRLE1->Link, &pRLE5->Link);

        } else if (nLimitDiff > 0) {

            // r4.limit equals min(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE2->LimitOid));

            // r5.prefix equals r4.limit
            WRAP_FOK(SnmpUtilOidCpy(&pRLE5->PrefixOid, &pRLE4->LimitOid));

            // r5.limit equals max(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE5->LimitOid, &pRLE1->LimitOid));

            // r5 is supported by r1 subagent 
            UpdateSupportedRegion(pRLE5, pRLE1);

            // insert third mib region into list first
            InsertHeadList(&pRLE1->Link, &pRLE5->Link);

        } else {

            // r4.limit equals min(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE2->LimitOid));

            // return r4 as last
            *ppLastSplitRLE = pRLE4;

            // release
            FreeRLE(pRLE5);
        }

        // insert remaining mib regions into list
        InsertHeadList(&pRLE1->Link, &pRLE4->Link);
        InsertHeadList(&pRLE1->Link, &pRLE3->Link);

        // remove existing
        RemoveEntryList(&pRLE1->Link);

        // release
        FreeRLE(pRLE1);

    } else if (nLimitDiff != 0) {

        // r3.prefix equals same prefix for r1 and r2
        WRAP_FOK(SnmpUtilOidCpy(&pRLE3->PrefixOid, &pRLE1->PrefixOid));

        // r3 is supported by both subagents
        UpdateSupportedRegion(pRLE3, pRLE1);
        UpdateSupportedRegion(pRLE3, pRLE2);

        // first limit less 
        if (nLimitDiff < 0) {

            // r3.limit equals min(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE1->LimitOid));

            // r4.prefix equals r3.limit
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->PrefixOid, &pRLE3->LimitOid));

            // r4.limit equals max(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE2->LimitOid));

            // r4 is supported by r2 subagent
            UpdateSupportedRegion(pRLE4, pRLE2);

        } else {

            // r3.limit equals min(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE2->LimitOid));

            // r4.prefix equals r3.limit
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->PrefixOid, &pRLE3->LimitOid));

            // r4.limit equals max(rl.limit,r2.limit)
            WRAP_FOK(SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE1->LimitOid));

            // r4 is supported by r1 subagent
            UpdateSupportedRegion(pRLE4, pRLE1);
        } 

        // return r4 as last
        *ppLastSplitRLE = pRLE4;

        // insert mib regions into list
        InsertHeadList(&pRLE1->Link, &pRLE4->Link);
        InsertHeadList(&pRLE1->Link, &pRLE3->Link);

        // remove existing
        RemoveEntryList(&pRLE1->Link);

        // release
        FreeRLE(pRLE1);
        FreeRLE(pRLE5);

    } else {

        // region supported existing subagent
        UpdateSupportedRegion(pRLE1, pRLE2);

        // return r1 as last
        *ppLastSplitRLE = pRLE1;

        // release
        FreeRLE(pRLE3);
        FreeRLE(pRLE4);
        FreeRLE(pRLE5);
    }

    // success
    return TRUE;

Error:

    SNMPDBG((
        SNMP_LOG_ERROR,
        "SNMP: SVC: SnmpUtilOidCpy failed at %d.\n",
        __LINE__
        ));

    // release
    FreeRLE(pRLE3);
    FreeRLE(pRLE4);
    FreeRLE(pRLE5);

    *ppLastSplitRLE = NULL;
    return FALSE;

}


BOOL
InsertSupportedRegion(
    PMIB_REGION_LIST_ENTRY pExistingRLE,
    PMIB_REGION_LIST_ENTRY pRLE
    )

/*++

Routine Description:

    Splits existing MIB region in order to insert new region.

Arguments:

    pExisingRLE - pointer to existing MIB region to be split.

    pRLE - pointer to MIB region to be inserted.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pLastSplitRLE = NULL;
    INT nDiff;
    
    // attempt to split mib regions into pieces parts
    fOk = SplitSupportedRegion(pExistingRLE, pRLE, &pLastSplitRLE);

    // process remaining entries
    while (pLastSplitRLE != NULL) {

        // re-use stack pointer
        pExistingRLE = pLastSplitRLE;    

        // re-initialize 
        pLastSplitRLE = NULL;

        // obtain pointer to next entry        
        pLE = pExistingRLE->Link.Flink;

        // make sure entries remaining
        if (pLE != &g_SupportedRegions) {

            // retrieve pointer to mib region that follows last split one
            pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

            // compare mib regions
            nDiff = SnmpUtilOidCmp(
                        &pExistingRLE->LimitOid,
                        &pRLE->PrefixOid
                        );

            // overlapped?
            if (nDiff > 0) {

                // remove from list
                RemoveEntryList(&pRLE->Link);

                // split the two new overlapped mib regions
                fOk = SplitSupportedRegion(pExistingRLE, pRLE, &pLastSplitRLE);

                // release
                FreeRLE(pRLE);
            }
        }
    }                

    return fOk;
}
/*---debug purpose only----
void PrintSupportedRegion()
{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // obtain pointer to list head
    pLE = g_SupportedRegions.Flink;

    // process all entries in list
    while (pLE != &g_SupportedRegions) {

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);
        SNMPDBG((SNMP_LOG_VERBOSE,"\t[%s\n", SnmpUtilOidToA(&(pRLE->PrefixOid))));
        SNMPDBG((SNMP_LOG_VERBOSE,"\t\t%s]\n", SnmpUtilOidToA(&(pRLE->LimitOid))));

        // next entry
        pLE = pLE->Flink;
    }
    SNMPDBG((SNMP_LOG_VERBOSE,"----\n"));
}
*/

BOOL
AddSupportedRegion(
    PMIB_REGION_LIST_ENTRY pRLE
    )

/*++

Routine Description:

    Add subagent's MIB region into master agent's list.

Arguments:

    pRLE - pointer to MIB region to add to supported list.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE2;
    PMIB_REGION_LIST_ENTRY pExistingRLE;
    BOOL fFoundOk = FALSE;
    BOOL fOk = FALSE;
    INT nDiff;

//    PrintSupportedRegion();

    // attempt to locate prefix in existing mib regions
    if (FindFirstOverlappingRegion(&pExistingRLE, pRLE)) {
            
        // split existing region into bits
        fOk = InsertSupportedRegion(pExistingRLE, pRLE);

    } else {

        // obtain pointer to list head
        pLE = g_SupportedRegions.Flink;

        // process all entries in list
        while (pLE != &g_SupportedRegions) {

            // retrieve pointer to mib region 
            pExistingRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

            // compare region prefix
            nDiff = SnmpUtilOidCmp(&pRLE->PrefixOid, &pExistingRLE->PrefixOid);

            // found match?
            if (nDiff < 0) {

                // success
                fFoundOk = TRUE;

                break; // bail...
            } 

            // next entry
            pLE = pLE->Flink;
        }

        // validate pointer
        if (AllocRLE(&pRLE2)) {

            // transfer prefix oid from subagent region
            if (! SnmpUtilOidCpy(&pRLE2->PrefixOid, &pRLE->PrefixOid))
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: SnmpUtilOidCpy failed at %d.\n",
                    __LINE__
                    ));

                FreeRLE(pRLE2);
                goto Exit;
            }
        
            // transfer limit oid from subagent region
            if (! SnmpUtilOidCpy(&pRLE2->LimitOid, &pRLE->LimitOid))
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: SnmpUtilOidCpy failed at %d.\n",
                    __LINE__
                    ));
                
                FreeRLE(pRLE2);
                goto Exit;
            }

            // save region pointer
            pRLE2->pSubagentRLE = pRLE;

            // save subagent pointer
            pRLE2->pSLE = pRLE->pSLE;

            // validate
            if (fFoundOk) {

                // add new mib range into supported list 
                InsertTailList(&pExistingRLE->Link, &pRLE2->Link);

            } else {

                // add new mib range into global supported list
                InsertTailList(&g_SupportedRegions, &pRLE2->Link);
            }

            // success
            fOk = TRUE;
        }
    }

Exit:
    return fOk; 
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocRLE(
    PMIB_REGION_LIST_ENTRY * ppRLE    
    )

/*++

Routine Description:

    Allocates MIB region structure and initializes.

Arguments:

    ppRLE - pointer to receive pointer to list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMIB_REGION_LIST_ENTRY pRLE;
    
    // attempt to allocate structure
    pRLE = AgentMemAlloc(sizeof(MIB_REGION_LIST_ENTRY));

    // validate pointer
    if (pRLE != NULL) {

        // initialize links
        InitializeListHead(&pRLE->Link);

        // success
        fOk = TRUE;
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate region entry.\n"
            ));
    }    

    // transfer
    *ppRLE = pRLE;

    return fOk;
}


BOOL 
FreeRLE(
    PMIB_REGION_LIST_ENTRY pRLE    
    )

/*++

Routine Description:

    Releases MIB region structure.

Arguments:

    ppRLE - pointer to MIB region to be freed.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pRLE != NULL) {

        // release memory for prefix oid
        SnmpUtilOidFree(&pRLE->PrefixOid);

        // release memory for limit oid
        SnmpUtilOidFree(&pRLE->LimitOid);

        // release memory
        AgentMemFree(pRLE);
    }

    return TRUE;
}

BOOL    
UnloadRegions(
    PLIST_ENTRY pListHead
    )

/*++

Routine Description:

    Destroys list of MIB regions.

Arguments:

    pListHead - pointer to list of regions.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // process entries until empty
    while (!IsListEmpty(pListHead)) {

        // extract next entry from head 
        pLE = RemoveHeadList(pListHead);

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

        // release
        FreeRLE(pRLE);
    }

    return TRUE;
}

BOOL
FindFirstOverlappingRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    PMIB_REGION_LIST_ENTRY pNewRLE
    )
/*++

Routine Description:

    Detects if any existent region overlapps with the new one to be added.

Arguments:

    ppRLE - pointer to receive pointer to list entry.

    pNewRLE - pointer to new region to be tested
    
Return Values:

    Returns true if match found.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // initialize
    *ppRLE = NULL;

    // obtain pointer to list head
    pLE = g_SupportedRegions.Flink;

    // process all entries in list
    while (pLE != &g_SupportedRegions) {

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

        if (SnmpUtilOidCmp(&pNewRLE->PrefixOid, &pRLE->LimitOid) < 0 &&
            SnmpUtilOidCmp(&pNewRLE->LimitOid, &pRLE->PrefixOid) > 0)
        {
            *ppRLE = pRLE;
            return TRUE;
        } 

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
FindSupportedRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    AsnObjectIdentifier *    pPrefixOid,
    BOOL                     fAnyOk
    )

/*++

Routine Description:

    Locates MIB region in list.

Arguments:

    ppRLE - pointer to receive pointer to list entry.

    pPrefixOid - pointer to OID to locate within MIB region.
    
    fAnyOk - true if exact match not necessary.

Return Values:

    Returns true if match found.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;
    INT nDiff;

    // initialize
    *ppRLE = NULL;

    // obtain pointer to list head
    pLE = g_SupportedRegions.Flink;

    // process all entries in list
    while (pLE != &g_SupportedRegions) {

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

        // region prefix should be also the prefix for the given OID
        nDiff = SnmpUtilOidNCmp(pPrefixOid, &pRLE->PrefixOid, pRLE->PrefixOid.idLength);

        // found match?
        if ((nDiff < 0 && fAnyOk) ||
            (nDiff == 0 && SnmpUtilOidCmp(pPrefixOid, &pRLE->LimitOid) < 0))
        {
            *ppRLE = pRLE;
            return TRUE;
        } 

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
LoadSupportedRegions(
    )

/*++

Routine Description:

    Creates global list of supported MIB regions from subagent MIB regions.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE1;
    PLIST_ENTRY pLE2;
    PSUBAGENT_LIST_ENTRY pSLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // get subagent list head
    pLE1 = g_Subagents.Flink;

    // process all entries in list
    while (pLE1 != &g_Subagents) {

        // retrieve pointer to subagent structure 
        pSLE = CONTAINING_RECORD(pLE1, SUBAGENT_LIST_ENTRY, Link);

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: Scan views supported by %s.\n",
            pSLE->pPathname
            ));

        // get supported regions list head
        pLE2 = pSLE->SupportedRegions.Flink;
        
        // process all entries in list
        while (pLE2 != &pSLE->SupportedRegions) {

            // retrieve pointer to mib region structure
            pRLE = CONTAINING_RECORD(pLE2, MIB_REGION_LIST_ENTRY, Link);

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: view %s\n",
                SnmpUtilOidToA(&pRLE->PrefixOid)
                ));

            // attempt to add mib region    
            if (!AddSupportedRegion(pRLE)) {

                // failure
                return FALSE;
            }

            // next mib region
            pLE2 = pLE2->Flink;
        }

        // next subagent
        pLE1 = pLE1->Flink;
    }

    // success
    return TRUE;
}


BOOL
UnloadSupportedRegions(
    )

/*++

Routine Description:

    Destroys list of MIB regions.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // unload global supported regions
    return UnloadRegions(&g_SupportedRegions);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\regthrd.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    regthrd.c

Abstract:

    Contains routines for thread listening to registry changes.

Environment:

    User Mode - Win32

Revision History:

    Rajat Goel -- 24 Feb 1999
        - Creation

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "contexts.h"
#include "regions.h"
#include "snmpmgrs.h"
#include "trapmgrs.h"
#include "trapthrd.h"
#include "network.h"
#include "varbinds.h"
#include "snmpmgmt.h"
#include "registry.h"
#include <stdio.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
ProcessSubagentChanges(
    )

/*++

Routine Description:

    Procedure for checking for any changes in the Extension Agents parameter in
    the registry

Arguments:

Return Values:

    Returns true if successful.

--*/

{
    DWORD retval;
    DWORD cnt;
    HKEY hExAgentsKey = NULL;

    // Open the ..SNMP\Parameters\ExtensionAgents key
    retval = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_EXTENSION_AGENTS,
                0,
                KEY_READ,
                &hExAgentsKey
             );

    cnt = 0;

    if (retval != ERROR_SUCCESS)
    {
        LPTSTR pszKey = REG_KEY_EXTENSION_AGENTS;

        ReportSnmpEvent(
            SNMP_EVENT_INVALID_REGISTRY_KEY,
            1,
            &pszKey,
            retval);

        return retval;
    }

    while (retval == ERROR_SUCCESS)
    {
        DWORD dwNameSize;
        DWORD dwValueSize;
        DWORD dwValueType;
        DWORD dwPathSize;
        HKEY  hAgentKey = NULL;
        TCHAR szName[MAX_PATH];
        TCHAR szValue[MAX_PATH];
        CHAR szPath[MAX_PATH];
        CHAR szExpPath[MAX_PATH];
        PSUBAGENT_LIST_ENTRY pSLE = NULL;

        dwNameSize = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
        dwValueSize = sizeof(szValue); // size in number of bytes
        dwPathSize = sizeof(szPath);

        // Retrieve the registry path for the Extension Agent DLL key
        retval = RegEnumValue(
                    hExAgentsKey,
                    cnt, 
                    szName, 
                    &dwNameSize, 
                    NULL, 
                    &dwValueType, 
                    (LPBYTE)szValue, 
                    &dwValueSize
                    );

        // if failed to Enum the registry value, this is serious enough to break the loop
        if (retval != ERROR_SUCCESS)
            break;

        if (dwValueType != REG_SZ)
        {
            // invalid value type, skip
            cnt++;
            continue;
        }

        // Open the registry key for the current extension agent
        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szValue,
                    0,
                    KEY_READ,
                    &hAgentKey) == ERROR_SUCCESS)
        {
            // get the full pathname of the extension agent DLL
            if (RegQueryValueExA(
                            hAgentKey,
                            REG_VALUE_SUBAGENT_PATH, 
                            NULL,
                            &dwValueType, 
                            szPath, 
                            &dwPathSize
                            ) == ERROR_SUCCESS && 
                 (dwValueType == REG_EXPAND_SZ || dwValueType == REG_SZ))
            {
                DWORD dwRet = 0;
                
                // Expand path

                // If the function succeeds, the return value is the number of 
                // TCHARs stored in the destination buffer, including the 
                // terminating null character. If the destination buffer is too
                // small to hold the expanded string, the return value is the 
                // required buffer size, in TCHARs. 
                // If the function fails, the return value is zero. To get 
                // extended error information, call GetLastError. 

                dwRet = ExpandEnvironmentStringsA(
                                szPath,
                                szExpPath,
                                sizeof(szExpPath)/sizeof(szExpPath[0]));
                
                if ((dwRet != 0) && (dwRet <= sizeof(szExpPath)/sizeof(szExpPath[0])))
                {

                    // Check if the DLL has already been loaded. If it has,
                    // mark it. If not load it.
                    if (FindSubagent(&pSLE, szExpPath))
                    {
                        // If this extension agent already exists in the list,
                        // mark it such that it is not removed further
                        pSLE->uchFlags |= FLG_SLE_KEEP;
                    }
                    else
                    {
                        // This is a new DLL, add it to the list and mark it to be kept
                        // while looking for the extension agents to be removed
                        if (!AddSubagentByDll(szExpPath, FLG_SLE_KEEP))
                        {
                            SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: SVC: unable to load extension agent '%s'.\n", 
                                szExpPath
                                ));
                        }
             
                    }
                }
                else
                {
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: unable to expand extension agent path '%s'.\n", 
                        szPath
                        ));
                }
            }
            else
            {
                // we couldn't open the registry key which provides the full path to the DLL.
                // report the error but don't break the loop as there might be more subagents to handle
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: unable to retrieve extension agent '%s' value.\n", 
                    REG_VALUE_SUBAGENT_PATH
                    ));
            }

            RegCloseKey(hAgentKey);

        }
        else
        {
            LPTSTR pSzValue = szValue;

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: unable to open extension agent %s key.\n", szValue
                ));

            ReportSnmpEvent(
                SNMP_EVENT_INVALID_EXTENSION_AGENT_KEY,
                1,
                &pSzValue,
                retval);
        }

        cnt++;
    }

    // Go through the list of subagents. Unload any DLL's that were not marked
    // in the previous loop
    {
        PLIST_ENTRY pLE;
        PSUBAGENT_LIST_ENTRY pSLE;

        pLE = g_Subagents.Flink;

        while (pLE != &g_Subagents)
        {

            pSLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);


            if (!(pSLE->uchFlags & FLG_SLE_KEEP))
            {

                RemoveEntryList(&(pSLE->Link));
                pLE = pLE->Flink;
                FreeSLE(pSLE);
                continue;

            }
            else
            {
                // reset the flag for next updates
                pSLE->uchFlags ^= FLG_SLE_KEEP;
            }

            pLE = pLE->Flink;
        }
    }
    
    if (retval == ERROR_NO_MORE_ITEMS)
        retval = ERROR_SUCCESS;

    if (hExAgentsKey != NULL)
        RegCloseKey(hExAgentsKey);

    return retval;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
ProcessRegistryMessage(
    PVOID pParam
    )

/*++

Routine Description:

    Thread procedure for processing Registry Changes

Arguments:

    pParam - unused.

Return Values:

    Returns true if successful.

--*/

{
    DWORD retval = ERROR_SUCCESS;

    do
    {
        DWORD evntIndex;
        BOOL  bEvntSetOk;

        // Wait for registry change or Main thread termination
        evntIndex = WaitOnRegNotification();
        // for one change into the registry several notifications occur (key renaming, value addition,
        // value change, etc). In order to avoid useless (and counterproductive) notifications, wait
        // here for half of SHUTDOWN_WAIT_HINT.
        Sleep(SHUTDOWN_WAIT_HINT/2);
        // first thing to do is to re initialize the registry notifiers
        // otherwise we might miss some changes
        InitRegistryNotifiers();

        if (evntIndex == WAIT_FAILED)
        {
            retval = GetLastError();
            break;
        }

        if (evntIndex == WAIT_OBJECT_0)
        {
            // termination was signaled
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: shutting down the registry listener thread.\n"
            ));
            
            break;
        }

        //
        // unload and reload the registry parameters
        //

        // Used in ProcessSnmpMessages->RecvCompletionRoutine
        EnterCriticalSection(&g_RegCriticalSectionA);

        // Used in ProcessSubagentEvents
        EnterCriticalSection(&g_RegCriticalSectionB);

        // Used in GenerateTrap
        EnterCriticalSection(&g_RegCriticalSectionC);

        UnloadPermittedManagers();
        UnloadTrapDestinations();
        UnloadValidCommunities();
        UnloadSupportedRegions();

        // start reloading the registry with scalar parameters first
        // this is needed in order to know how to perform the name resolution
        // when loading PermittedManagers and TrapDestinations.
        LoadScalarParameters();

        // Check for subagent changes (extension agent dll's)
        if (ProcessSubagentChanges() != ERROR_SUCCESS)
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: an error occured while trying to track registry subagent changes.\n"
            ));

        LoadSupportedRegions();

        LoadPermittedManagers(FALSE);
        LoadTrapDestinations(FALSE);
        // don't direct dynamic update for the ValidCommunities at this point!
        // if a REG_SZ entry occurs at this time, then it should be left as it is.
        LoadValidCommunities(FALSE);

        SetEvent(g_hRegistryEvent);

        LeaveCriticalSection(&g_RegCriticalSectionC);

        LeaveCriticalSection(&g_RegCriticalSectionB);

        LeaveCriticalSection(&g_RegCriticalSectionA);


        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: a registry change was detected.\n"
            ));

        ReportSnmpEvent(
            SNMP_EVENT_CONFIGURATION_UPDATED,
            0,
            NULL,
            0);

    } while(retval == ERROR_SUCCESS);

    if (retval != ERROR_SUCCESS)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ** Failed in listening for registry changes **.\n"
            ));

        // log an event to system log file - SNMP service is going on but will not update on registry changes
        ReportSnmpEvent(
            SNMP_EVENT_REGNOTIFY_THREAD_FAILED, 
            0, 
            NULL, 
            retval);
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\service.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    service.c

Abstract:

    Contains service controller code for SNMP service.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "service.h"
#include "startup.h"
#include "trapthrd.h"
#include "registry.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SERVICE_STATUS_HANDLE g_SnmpSvcHandle = 0;
SERVICE_STATUS g_SnmpSvcStatus = {
    SERVICE_WIN32,      // dwServiceType                
    SERVICE_STOPPED,    // dwCurrentState    
    0,                  // dwControlsAccepted    
    NO_ERROR,           // dwWin32ExitCode    
    0,                  // dwServiceSpecificExitCode    
    0,                  // dwCheckPoint    
    0                   // dwWaitHint    
    };     


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
TerminateService(
    )

/*++

Routine Description:

    Shutdown SNMP service.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // signal io thread to terminate
    BOOL fOk = SetEvent(g_hTerminationEvent);
    
    if (!fOk) {
                
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error 0x%08lx setting termination event.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
UpdateController(
    DWORD dwCurrentState,
    DWORD dwWaitHint
    )

/*++

Routine Description:

    Notify service controller of SNMP service status.

Arguments:

    dwCurrentState - state of the service.

    dwWaitHint - worst case estimate to next checkpoint.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate handle
    if (g_SnmpSvcHandle != 0) {

        static DWORD dwCheckPoint = 1;

        // check to see if the service is starting    
        if (dwCurrentState == SERVICE_START_PENDING) {

            // do not accept controls during startup
            g_SnmpSvcStatus.dwControlsAccepted = 0;

        } else {

            // only accept stop command during operation
            g_SnmpSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        }

        // if checkpoint needs incrementing
        if ((dwCurrentState == SERVICE_RUNNING) ||
            (dwCurrentState == SERVICE_STOPPED)) {

            // re-initialize checkpint    
            g_SnmpSvcStatus.dwCheckPoint = 0;
    
        } else {
            
            // increment checkpoint to denote processing
            g_SnmpSvcStatus.dwCheckPoint = dwCheckPoint++;
        }

        // update global status structure
        g_SnmpSvcStatus.dwCurrentState = dwCurrentState;
        g_SnmpSvcStatus.dwWaitHint     = dwWaitHint;
            
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: setting service status to %s (0x%08lx).\n",
            SERVICE_STATUS_STRING(g_SnmpSvcStatus.dwCurrentState),
            g_SnmpSvcStatus.dwCheckPoint
            ));
    
        // register current state with service controller
        fOk = SetServiceStatus(g_SnmpSvcHandle, &g_SnmpSvcStatus);

        if (!fOk) {
            
            SNMPDBG((
                SNMP_LOG_WARNING, 
                "SNMP: SVC: error 0x%08lx setting service status.\n",
                GetLastError()
                ));
        }
    }

    return fOk;
}


VOID
ProcessControllerRequests(
    DWORD dwOpCode
    )

/*++

Routine Description:

    Control handling function of SNMP service.

Arguments:

    dwOpCode - requested control code.

Return Values:

    None.

--*/

{
    DWORD dwCurrentState = SERVICE_RUNNING;
    DWORD dwWaitHint     = 0;
        
    SNMPDBG((
        SNMP_LOG_VERBOSE, 
        "SNMP: SVC: processing request to %s service.\n",
        SERVICE_CONTROL_STRING(dwOpCode)
        ));

    // handle command
    switch (dwOpCode) {

    case SERVICE_CONTROL_STOP:

        // change service status to stopping
        dwCurrentState = SERVICE_STOP_PENDING;    
        dwWaitHint     = SNMP_WAIT_HINT;

        break; 

    case SERVICE_CONTROL_INTERROGATE:

        //
        // update controller below...
        //

        break;

    default:

        // check for parameters 
        if (IS_LOGLEVEL(dwOpCode)) {

            UINT nLogLevel;

            // derive the new log level from the opcode            
            nLogLevel = dwOpCode - SNMP_SERVICE_LOGLEVEL_BASE;
            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: changing log level to %s.\n",
                SNMP_LOGLEVEL_STRING(nLogLevel)
                ));

            // store the new log level                     
            SnmpSvcSetLogLevel(nLogLevel);

        } else if (IS_LOGTYPE(dwOpCode)) {

            UINT nLogType;

            // derive the new log type from opcode
            nLogType = dwOpCode - SNMP_SERVICE_LOGTYPE_BASE;
            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: changing log type to %s.\n",
                SNMP_LOGTYPE_STRING(nLogType)
                ));

            // store the new log type
            SnmpSvcSetLogType(nLogType);

        } else {
                                           
            SNMPDBG((
                SNMP_LOG_WARNING, 
                "SNMP: SVC: unhandled control code %d.\n",
                dwOpCode
                ));
        }

        break;        
    }

    // report status to controller
    UpdateController(dwCurrentState, dwWaitHint);

    // make sure to set shutdown event    
    if (dwCurrentState == SERVICE_STOP_PENDING) {

        // terminate
        TerminateService();
    }
}


BOOL 
WINAPI
ProcessConsoleRequests(
    DWORD dwOpCode
    )

/*++

Routine Description:

    Handle console control events.

Arguments:

    dwOpCode - requested control code.

Return Values:

    Returns true if request processed.

--*/

{
    BOOL fOk = FALSE;

    // check if user wants to exit
    if ((dwOpCode == CTRL_C_EVENT) ||
        (dwOpCode == CTRL_BREAK_EVENT)) {
                
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: processing ctrl-c request.\n"
            ));

        // stop service
        fOk = TerminateService();
    }
    
    return fOk;
} 


VOID
ServiceMain(
    IN DWORD  NumberOfArgs,
    IN LPTSTR  ArgumentPtrs[]
    )

/*++

Routine Description:

    Entry point of SNMP service.

Arguments:

    NumberOfArgs - number of command line arguments.
    ArgumentPtrs - array of pointers to arguments.

Return Values:

    None.

--*/

{
    // check if we need to bypass dispatcher
    if (!g_CmdLineArguments.fBypassCtrlDispatcher) {

        // register snmp with service controller
        g_SnmpSvcHandle = RegisterServiceCtrlHandler(
                                SNMP_SERVICE,
                                ProcessControllerRequests
                                );

        // validate handle
        if (g_SnmpSvcHandle == 0) { 

            // save error code in service status structure
            g_SnmpSvcStatus.dwWin32ExitCode = GetLastError();    
            
            SNMPDBG((
                SNMP_LOG_ERROR, 
                "SNMP: SVC: error 0x%08lx registering service.\n",
                g_SnmpSvcStatus.dwWin32ExitCode
                ));

            return; // bail...
        }
    }
    
    // report status to service controller
    UpdateController(SERVICE_START_PENDING, SNMP_WAIT_HINT);

    // startup agent
    if (StartupAgent()) {

        // report status to service controller
        UpdateController(SERVICE_RUNNING, NO_WAIT_HINT);

        // load registry
        // this is done after notifying the service controller that SNMP is up and running
        // because of the potential delay taken to load each subagent apart.
        // it is done here and not in the thread resumed below, because this call has to complete
        // before ProcessSubagentEvents() (data structures used in ProcessSubagentEvents() are initialized in
        // LoadRegistryParameters())
        // bugs: #259509 & #274055.
        LoadRegistryParameters();

        if (ResumeThread(g_hAgentThread) != 0xFFFFFFFF)
        {
            if (ResumeThread(g_hRegistryThread) == 0xFFFFFFFF) 
            {
                DWORD errCode = GetLastError();

                SNMPDBG((
                    SNMP_LOG_ERROR, 
                    "SNMP: SVC: error 0x%08lx starting the ProcessRegistryMessages thread.\n",
                    errCode
                    ));
                // log an event to system log file - SNMP service is going on but will not update on registry changes
                ReportSnmpEvent(
                    SNMP_EVENT_REGNOTIFY_THREAD_FAILED, 
                    0, 
                    NULL, 
                    errCode
                    );
            }
            // service subagents 
            ProcessSubagentEvents(); 
        }
        else
        {
            SNMPDBG((
                SNMP_LOG_ERROR, 
                "SNMP: SVC: error 0x%08lx starting the ProcessMessages thread.\n",
                GetLastError()
                ));
        }
    }

    // report status to service controller
    UpdateController(SERVICE_STOP_PENDING, SNMP_WAIT_HINT);

    // stop agent
    ShutdownAgent();
    
    // report status to service controller
    UpdateController(SERVICE_STOPPED, NO_WAIT_HINT);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT 
__cdecl 
main(
    DWORD  NumberOfArgs,
    LPSTR ArgumentPtrs[]
    )

/*++

Routine Description:

    Entry point of program.

Arguments:

    NumberOfArgs - number of command line arguments.
    ArgumentPtrs - array of pointers to arguments.

Return Values:

    None.

--*/

{
    BOOL fOk;
    DWORD dwLastError;

    static SERVICE_TABLE_ENTRY SnmpServiceTable[] =
        {{SNMP_SERVICE, ServiceMain}, {NULL, NULL}};

    // process command line arguments before starting
    if (ProcessArguments(NumberOfArgs, ArgumentPtrs)) {

        // create manual reset termination event for service
        g_hTerminationEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        // check if we need to bypass dispatcher
        if (g_CmdLineArguments.fBypassCtrlDispatcher) {
            
            SNMPDBG((    
                SNMP_LOG_TRACE,     
                "SNMP: SVC: bypassing service controller...\n"
                ));    
             
        
            // install console command handler
            SetConsoleCtrlHandler(ProcessConsoleRequests, TRUE);

            // dispatch snmp service manually
            ServiceMain(NumberOfArgs, (LPTSTR*)ArgumentPtrs);

        } else {
                            
            SNMPDBG((    
                SNMP_LOG_TRACE,     
                "SNMP: SVC: connecting to service controller...\n"
                ));    
             

            // attempt to connect to service controller
            fOk = StartServiceCtrlDispatcher(SnmpServiceTable);

            if (!fOk) {
        
                // retrieve controller failure
                dwLastError = GetLastError();

                // check to see whether or not the error was unexpected
                if (dwLastError == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT) {
                        
                    SNMPDBG((    
                        SNMP_LOG_TRACE,     
                        "SNMP: SVC: unable to connect so manually starting...\n"
                        ));    
                     

                    // make note that service is not connected
                    g_CmdLineArguments.fBypassCtrlDispatcher = TRUE;
                    
                    // install console command handler
                    SetConsoleCtrlHandler(ProcessConsoleRequests, TRUE);

                    // attempt to dispatch service manually
                    ServiceMain(NumberOfArgs, (LPTSTR*)ArgumentPtrs);

                } else {
                    
                    SNMPDBG((    
                        SNMP_LOG_ERROR,     
                        "SNMP: SVC: error 0x%08lx connecting to controller.\n", 
                        dwLastError
                        ));    
                }
            }
        }

        // close termination event
        CloseHandle(g_hTerminationEvent);
    }
    
    SNMPDBG((    
        SNMP_LOG_TRACE,     
        "SNMP: SVC: service exiting 0x%08lx.\n",    
        g_SnmpSvcStatus.dwWin32ExitCode
        ));    

    // return service status code
    return g_SnmpSvcStatus.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\snmpmgmt.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgmt.h

Abstract:

    Contains functions for handling/updating
	snmp management variables (defined in RFC1213)

Environment:

    User Mode - Win32

Revision History:

    30-Mar-1998 FlorinT
--*/
#include <snmputil.h>
#include "snmpmgmt.h"

SNMP_MGMTVARS snmpMgmtBase;	// instance of the service management variables

/*++
	Initializes the management variable arrays.
--*/
void mgmtInit()
{
	int i;

	for (i=0; i<NC_MAX_COUNT; i++)
    {
        snmpMgmtBase.AsnCounterPool[i].asnType = ASN_COUNTER32;
		snmpMgmtBase.AsnCounterPool[i].asnValue.counter = 0;
    }
	for (i=0; i<NI_MAX_COUNT; i++)
    {
        snmpMgmtBase.AsnIntegerPool[i].asnType = ASN_INTEGER;
		snmpMgmtBase.AsnIntegerPool[i].asnValue.number = 0;
    }
    for (i=0; i<NO_MAX_COUNT; i++)
    {
        snmpMgmtBase.AsnObjectIDs[i].asnType = ASN_OBJECTIDENTIFIER;
        snmpMgmtBase.AsnObjectIDs[i].asnValue.object.idLength = 0;
        snmpMgmtBase.AsnObjectIDs[i].asnValue.object.ids = NULL;
    }

    // particular case: default the IsnmpEnableAuthenTraps to TRUE
    snmpMgmtBase.AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number = 1;

    // particular case: default the IsnmpNameResolutionRetries to 0
    snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number = 0;

    // particular case: default the OsnmpSysObjectID to the hard coded value given by SvcGetEnterpriseOID
    mgmtOSet(OsnmpSysObjectID, SnmpSvcGetEnterpriseOID(), TRUE);
}

/*++
	Releases any memory that has been allocated for the management variables
--*/
void mgmtCleanup()
{
    int i;

    for (i=0; i<NO_MAX_COUNT; i++)
    {
        SnmpUtilOidFree(&(snmpMgmtBase.AsnObjectIDs[i].asnValue.object));
    }
}

/*++
	Increment the specified Counter variable
Returns:
	ERROR_SUCCESS on success;
	ERROR_INVALID_INDEX if index out of range;
	ERROR_ARITHMETIC_OVERFLOW if overflowing the MAXINT value.
--*/
int mgmtCTick(int index)
{
	AsnCounter	oldValue;

	if (index < 0 || index >= NC_MAX_COUNT)
		return ERROR_INVALID_INDEX	;

	oldValue = snmpMgmtBase.AsnCounterPool[index].asnValue.counter;
	snmpMgmtBase.AsnCounterPool[index].asnValue.counter++;
	return snmpMgmtBase.AsnCounterPool[index].asnValue.counter > oldValue ? ERROR_SUCCESS : ERROR_ARITHMETIC_OVERFLOW;
}

/*++
	Add a value to a counter
Returns:
	ERROR_SUCCESS on success;
	ERROR_INVALID_INDEX if index out of range;
	ERROR_ARITHMETIC_OVERFLOW if overflowing the MAXINT value.
--*/
int  mgmtCAdd(int index, AsnCounter value)
{
    AsnCounter  oldValue;

    if (index < 0 || index >= NC_MAX_COUNT)
        return ERROR_INVALID_INDEX;

    oldValue = snmpMgmtBase.AsnCounterPool[index].asnValue.counter;
    snmpMgmtBase.AsnCounterPool[index].asnValue.counter += value;
    return snmpMgmtBase.AsnCounterPool[index].asnValue.counter > oldValue ? ERROR_SUCCESS : ERROR_ARITHMETIC_OVERFLOW;
}

/*++
	Set the value of a certain AsnInteger mgmt variable
Returns:
	ERROR_SUCCESS on success;
	ERROR_INVALID_INDEX if index out of range;
--*/
int mgmtISet(int index, AsnInteger value)
{
	if (index < 0 || index > NI_MAX_COUNT)
		return ERROR_INVALID_INDEX;
	snmpMgmtBase.AsnIntegerPool[index].asnValue.number = value;
	return ERROR_SUCCESS;
}

/*++
    Set the value of a certain AsnObjectIdentifier mgmt variable
Returns:
    ERROR_SUCCESS on success;
    ERROR_INVALID_INDEX if index out of range;
    other WinErr if smth else went wrong
Remarks:
    If bAlloc = TRUE, the variable is moved (no mem is allocated) to the management variable
    If bAlloc = FALSE the value of the input variable is copied (and mem is allocated) to the mgmt variable
---*/
int mgmtOSet(int index, AsnObjectIdentifier *pValue, BOOL bAlloc)
{
    AsnObjectIdentifier oldObject;

    if (index < 0 || index > NO_MAX_COUNT)
        return ERROR_INVALID_INDEX;
    if (pValue == NULL)
        return ERROR_INVALID_PARAMETER;

    // make a backup of the original object. If something goes wrong, the original object will not be free-ed.
    oldObject.idLength = snmpMgmtBase.AsnObjectIDs[index].asnValue.object.idLength;
    oldObject.ids = snmpMgmtBase.AsnObjectIDs[index].asnValue.object.ids;

    if (bAlloc)
    {
        // the object is to be copied and mem is to be allocated
        if (SnmpUtilOidCpy(&(snmpMgmtBase.AsnObjectIDs[index].asnValue.object), pValue) != SNMPAPI_NOERROR)
            return GetLastError();
    }
    else
    {
        // the object is to be moved, no mem will be allocated
        snmpMgmtBase.AsnObjectIDs[index].asnValue.object.idLength = pValue->idLength;
        snmpMgmtBase.AsnObjectIDs[index].asnValue.object.ids = pValue->ids;
    }

    // everything went fine, so release the memory for the previous value
    SnmpUtilOidFree(&oldObject);

    return ERROR_SUCCESS;
}

/*++
    Updates the MIB counters for the IN_errStatus or OUT_errStatus value
Returns:
    void
--*/
void mgmtUtilUpdateErrStatus(UINT flag, DWORD errStatus)
{
    UINT index;

    switch(errStatus)
    {
    case SNMP_ERRORSTATUS_TOOBIG:
        index = flag == IN_errStatus ? CsnmpInTooBigs : CsnmpOutTooBigs;
        break;

    case SNMP_ERRORSTATUS_NOSUCHNAME:
        index = flag == IN_errStatus ? CsnmpInNoSuchNames : CsnmpOutNoSuchNames;
        break;

    case SNMP_ERRORSTATUS_BADVALUE:
        index = flag == IN_errStatus ? CsnmpInBadValues : CsnmpOutBadValues;
        break;

    case SNMP_ERRORSTATUS_READONLY:
        if (flag != IN_errStatus)
            return;
        index = CsnmpInReadOnlys;
        break;

    case SNMP_ERRORSTATUS_GENERR:
        index = flag == IN_errStatus ? CsnmpInGenErrs : CsnmpOutGenErrs;
        break;

    default:
        return;
    }

    mgmtCTick(index);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\snmpmgrs.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgrs.c

Abstract:

    Contains routines for manipulating manager structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "snmpmgrs.h"
#include "network.h"



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocMLE(
    PMANAGER_LIST_ENTRY * ppMLE,
    LPSTR                 pManager
    )

/*++

Routine Description:

    Allocates manager structure and initializes.

Arguments:

    pManager - pointer to manager string.

    ppMLE - pointer to receive pointer to entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMANAGER_LIST_ENTRY pMLE = NULL;
    DWORD dwIpAddr;
    LPSTR pszManager;

    // attempt to allocate structure
    pMLE = AgentMemAlloc(sizeof(MANAGER_LIST_ENTRY));

    // validate
    if (pMLE != NULL) {

        // allocate memory for manager string
        pMLE->pManager = AgentMemAlloc(strlen(pManager)+1);

        // validate
        if (pMLE->pManager != NULL) {

            // transfer manager string
            strcpy(pMLE->pManager, pManager);

            // Attempt to resolve manager network address 
            // For IPX addresses, this call always succeeds
            // When SnmpSvcAddrToSocket fails, this means we deal with a dynamic IP Address
            // for which the gethostbyname() failed.
            if (SnmpSvcAddrToSocket(pMLE->pManager, &pMLE->SockAddr)) {

                // see if tcpip address
                if (pMLE->SockAddr.sa_family == AF_INET) {

                    // save structure size for later use
                    pMLE->SockAddrLen = sizeof(struct sockaddr_in);

                    pszManager = pMLE->pManager;

                    // attempt to convert address directly
                    dwIpAddr = inet_addr(pMLE->pManager);

                    // assume address is dynamic if error occurs
                    pMLE->fDynamicName = (dwIpAddr == SOCKET_ERROR);

                    // note time manager addr updated
                    pMLE->dwLastUpdate = GetCurrentTime();

                    // success
                    fOk = TRUE;

                } else if (pMLE->SockAddr.sa_family == AF_IPX) {

                    // save structure size for later use
                    pMLE->SockAddrLen = sizeof(struct sockaddr_ipx);

                    // no name lookup for ipx
                    pMLE->fDynamicName = FALSE;

                    // success
                    fOk = TRUE;
                }

                pMLE->dwAge = MGRADDR_ALIVE;

            } else {
                LPTSTR tcsManager;

#ifdef UNICODE
                SnmpUtilUTF8ToUnicode(&tcsManager, pMLE->pManager, TRUE);
#else
                tcsManager=pMLE->pManager;
#endif
                // at this point the address can be only an IP address!
                // so we know pMLE->SockAddrLen as the size of the struct sockaddr_in!
                pMLE->SockAddrLen = sizeof(struct sockaddr_in);

                // since SnmpSvcAddrToSocket failed, that means inet_addr() failed hence
                // we deal with a dynamic IP address
                pMLE->fDynamicName = TRUE;

                // set 'age' to dying
                pMLE->dwAge = snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number;

                // if the registry parameter is -1 this stands for 'keep retrying forever'
                // in this case set the dwAge to the default MGRADDR_DYING(16) and never decrement it
                if (pMLE->dwAge == (DWORD)-1)
                    pMLE->dwAge = MGRADDR_DYING;

                // report a warning to the system log
                ReportSnmpEvent(
                    SNMP_EVENT_NAME_RESOLUTION_FAILURE,
                    1,
                    &tcsManager,
                    0);

#ifdef UNICODE
                SnmpUtilMemFree(tcsManager);
#endif

                // success
                fOk = TRUE;
            }
        }
    
        // cleanup
        if (!fOk) {
    
            // release
            FreeMLE(pMLE);                

            // re-init
            pMLE = NULL;            
        }
    }

    // transfer
    *ppMLE = pMLE;

    return fOk;
}


BOOL
FreeMLE(
    PMANAGER_LIST_ENTRY pMLE
    )

/*++

Routine Description:

    Releases manager structure.

Arguments:

    pMLE - pointer to manager list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pMLE != NULL) {

        // release string
        AgentMemFree(pMLE->pManager);

        // release structure
        AgentMemFree(pMLE);
    }

    return TRUE;
}


BOOL
UpdateMLE(
    PMANAGER_LIST_ENTRY pMLE
    )

/*++

Routine Description:

    Updates manager structure.
	An address will be resolved only if it is not marked as being 'DEAD'. A 'DEAD' address failed to be resolved for
	more than MGRADDR_DYING times. A 'DEAD' address will no longer be used as a trap destination, but it will still
	be validating the incoming SNMP requests if it could be resolve at least once since the service started up.

Arguments:

    pMLE - pointer to manager list entry to be updated.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    DWORD dwElaspedTime;
    struct sockaddr SockAddr;

    SNMPDBG((SNMP_LOG_TRACE,
             "SNMP: SVC: Update manager '%s' with age %d.\n",
             pMLE->pManager,
             pMLE->dwAge));

    // don't try to resolve this address if it is already dead
	if (pMLE->dwAge == MGRADDR_DEAD)
		return FALSE;

    // see if name dynamic
    if (pMLE->fDynamicName) {

        // determine elasped time since last update
        dwElaspedTime = GetCurrentTime() - pMLE->dwLastUpdate;

        // resolve the address only if it failed to be resolved on last update 
        // or its update time expired.
        if (pMLE->dwAge != MGRADDR_ALIVE || dwElaspedTime > DEFAULT_NAME_TIMEOUT) {
        
            // attempt to resolve manager network address
            // for IPX addresses, this call always succeeds
            fOk = SnmpSvcAddrToSocket(pMLE->pManager, &SockAddr);

            // validate
            if (fOk) {

                // update entry with new address
                memcpy(&pMLE->SockAddr, &SockAddr, sizeof(SockAddr));

                // note time dynamic name resolved
                pMLE->dwLastUpdate = GetCurrentTime();

                // make sure manager age is 'ALIVE'
                pMLE->dwAge = MGRADDR_ALIVE;

            } else if (pMLE->dwAge == MGRADDR_ALIVE) {

                // Previously 'ALIVE' address cannot be resolved anymore
				// set its age to the one specified by 'NameResolutionRetries' parameter in
				// order to give some more chances.
                pMLE->dwAge = snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number;

                // if the registry parameter is -1 this stands for 'keep retrying forever'
                // in this case set the dwAge to the default MGRADDR_DYING(16) which will never be decremented
                if (pMLE->dwAge == (DWORD)-1)
                    pMLE->dwAge = MGRADDR_DYING;

            } else if (pMLE->dwAge != MGRADDR_DEAD) {

				// the address could not be resolved before and it still cannot be resolved
				// decrement its retry counter only if the 'NameResolutionRetries' parameter says so
                if (snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number != -1)
                    pMLE->dwAge--;
            }
        }        
    }

    return fOk;
}


BOOL
FindManagerByName(
    PMANAGER_LIST_ENTRY * ppMLE,
    PLIST_ENTRY           pListHead,
    LPSTR                 pManager
    )

/*++

Routine Description:

    Locates manager in list.

Arguments:

    ppMLE - pointer to receive pointer to entry.

    pListHead - pointer to head of manager list.

    pManager - pointer to manager to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMANAGER_LIST_ENTRY pMLE;

    // initialize
    *ppMLE = NULL;

    // obtain pointer to list head
    pLE = pListHead->Flink;

    // process all entries in list
    while (pLE != pListHead) {

        // retrieve pointer to community structure
        pMLE = CONTAINING_RECORD(pLE, MANAGER_LIST_ENTRY, Link);

        // compare community string with entry
        if (!strcmp(pMLE->pManager, pManager)) {

            // transfer
            *ppMLE = pMLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
IsManagerAddrLegal(
    struct sockaddr_in *  pAddr
    )
{
    DWORD dwHostMask;
    DWORD dwAddress = ntohl(pAddr->sin_addr.S_un.S_addr);

    // check address legality only for Ip addresses
    if (pAddr->sin_family != AF_INET)
        return TRUE;

    // disallow multicast (or future use) source addresses
    // local broadcast will be filtered out here as well
    if ((dwAddress & 0xe0000000) == 0xe0000000)
        return FALSE;

    // get hostmask for class 'C' addresses
    if ((dwAddress & 0xc0000000) == 0xc0000000)
        dwHostMask = 0x000000ff;

    // get hostmask for class 'B' addresses
    else if ((dwAddress & 0x80000000) == 0x80000000)
        dwHostMask = 0x0000ffff;

    // get hostidmask for class 'A' addresses
    else
        dwHostMask = 0x00ffffff;

    SNMPDBG((SNMP_LOG_TRACE,"SNMP: dwAddress=%08x, dwHostMask=%08x, port=%d\n",
             dwAddress, dwHostMask, ntohs(pAddr->sin_port)));

    return ((dwAddress & dwHostMask) != 0                              // check against net address
            && ((dwAddress & dwHostMask) != (0x00ffffff & dwHostMask)) // check against broadcast address
//          && ntohs(pAddr->sin_port) >= 1024                          // check against reserved port 
           );
}


BOOL
FindManagerByAddr(
    PMANAGER_LIST_ENTRY * ppMLE,
    struct sockaddr *     pSockAddr
    )

/*++

Routine Description:

    Locates permitted manager in list.

Arguments:

    ppMLE - pointer to receive pointer to entry.

    pSockAddr - pointer to socket address to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMANAGER_LIST_ENTRY pMLE;
    DWORD dwSockAddrLen;
    enum
    {
        SRCH_ALIVE,
        SRCH_DYING,
        SRCH_DONE
    } state;

    // initialize
    *ppMLE = NULL;

    // loop twice through the list of permitted managers
    // in the first loop look only through 'ALIVE' managers
    // in the second loop look through the 'DYING' or 'DEAD' managers.
    // ... this logic minimizes the response time for regular SNMP requests,
    // as far as there is a bigger chance to have the request comming from an 'ALIVE' manager.
    // otherwise, gethostbyname() called in UpdateMLE() lasts about 1/2 sec!!!
    for (state = SRCH_ALIVE, pLE = g_PermittedManagers.Flink;
         state != SRCH_DONE;
         pLE=pLE->Flink)
    {
        // retrieve pointer to manager structure
        pMLE = CONTAINING_RECORD(pLE, MANAGER_LIST_ENTRY, Link);

        // if we are in the first loop ..
        if (state == SRCH_ALIVE)
        {
            // .. but reached its end ..
            if (pLE == &g_PermittedManagers)
            {
                // .. go further with the second loop
                state = SRCH_DYING;
                continue;
            }

            // .. pass over the managers that are not 'ALIVE'
            if (pMLE->dwAge != MGRADDR_ALIVE)
                continue;
        }

        // if we are in the second loop ..
        if (state == SRCH_DYING)
        {
            // .. but reached its end ..
            if (pLE == &g_PermittedManagers)
            {
                // .. mark the end of scanning
                state = SRCH_DONE;
                continue;
            }

            // .. pass over the managers that are 'ALIVE'
            if (pMLE->dwAge == MGRADDR_ALIVE || pMLE->dwAge == MGRADDR_DEAD)
                continue;
        }

		// update name:
		// 'DEAD' addresses will no longer be resolved,
		// 'DYING' addresses will be given another chance to resolve until they become 'DEAD'
		// 'ALIVE' addresses that fail to resolve will become 'DYING'
		// next, all managers with a valid address will participate to validation (see below)
		UpdateMLE(pMLE);

        // compare address families
        if (IsValidSockAddr(&pMLE->SockAddr) &&
            pMLE->SockAddr.sa_family == pSockAddr->sa_family) 
        {
        
            // determine address family
            if (pMLE->SockAddr.sa_family == AF_INET) 
            {
        
                struct sockaddr_in * pSockAddrIn1; 
                struct sockaddr_in * pSockAddrIn2; 

                // obtain pointer to protocol specific structure
                pSockAddrIn1= (struct sockaddr_in *)pSockAddr;
                pSockAddrIn2= (struct sockaddr_in *)&pMLE->SockAddr;

				// acknowledge this manager only if its address matches
				// a permitted manager with a valid (not NULL) IP address.
				// This is tested regardless the 'dwAge' of the permitted manager.
                if (!memcmp(&pSockAddrIn1->sin_addr,
                            &pSockAddrIn2->sin_addr,
                            sizeof(pSockAddrIn2->sin_addr))) 
                {

                    // transfer
                    *ppMLE = pMLE;

                    // success
                    return TRUE;
                }
        
            }
            else if (pMLE->SockAddr.sa_family == AF_IPX) 
            {

                struct sockaddr_ipx * pSockAddrIpx1; 
                struct sockaddr_ipx * pSockAddrIpx2; 

                // obtain pointer to protocol specific structure
                pSockAddrIpx1= (struct sockaddr_ipx *)pSockAddr;
                pSockAddrIpx2= (struct sockaddr_ipx *)&pMLE->SockAddr;

                // acknowledge this manager only if its ipx address matches a 
				// permitted manager with a valid (nodenum != 0) IPX address.
				// This is tested regardless the 'dwAge' of the permitted manager.
                if (!memcmp(pSockAddrIpx1->sa_netnum,
                            pSockAddrIpx2->sa_netnum,
                            sizeof(pSockAddrIpx2->sa_netnum)) &&
                    !memcmp(pSockAddrIpx1->sa_nodenum,
                            pSockAddrIpx2->sa_nodenum,
                            sizeof(pSockAddrIpx2->sa_nodenum))) 
                {

                    // transfer
                    *ppMLE = pMLE;

                    // success
                    return TRUE;
                }
            }
        }
    }

    // failure
    return FALSE;
}


BOOL
AddManager(
    PLIST_ENTRY pListHead,
    LPSTR       pManager
    )

/*++

Routine Description:

    Adds manager structure to list.

Arguments:

    pListHead - pointer to head of list.

    pManager - pointer to manager to add.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMANAGER_LIST_ENTRY pMLE = NULL;

    // attempt to locate in list    
    if (FindManagerByName(&pMLE, pListHead, pManager)) {
                    
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: updating manager %s.\n",
            pManager
            ));

        // success
        fOk = TRUE;

    } else {

        // allocate manager structure
        if (AllocMLE(&pMLE, pManager)) {
                        
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: adding manager %s.\n",
                pManager
                ));

            // insert into managers list
            InsertTailList(pListHead, &pMLE->Link);

            // success
            fOk = TRUE;
        }
    }

    return fOk;
}


BOOL
LoadManagers(
    HKEY        hKey,
    PLIST_ENTRY pListHead
    )

/*++

Routine Description:

    Constructs list of permitted managers.

Arguments:

    hKey - registry key containing manager values.

    pListHead - pointer to head of list.

Return Values:

    Returns true if successful.

--*/

{
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    CHAR  szName[MAX_PATH];
    CHAR  szValue[MAX_PATH]; // buffer for holding the translation UNICODE->UTF8
    BOOL fOk = FALSE;
    
    // initialize
    dwIndex = 0;
    lStatus = ERROR_SUCCESS;

    // loop until error or end of list
    while (lStatus == ERROR_SUCCESS)
    {
        // initialize buffer sizes
        dwNameSize  = sizeof(szName)/sizeof(szName[0]); // size in TCHARs
        dwValueSize = sizeof(szValue); // size in bytes

        szValue[0] = '\0';

        // read next value
        lStatus = RegEnumValueA(
                    hKey, 
                    dwIndex, 
                    szName, 
                    &dwNameSize,
                    NULL, 
                    &dwValueType, 
                    szValue, 
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            szValue[dwValueSize]='\0';

            if (AddManager(pListHead, szValue)) // add valid manager to manager list
                dwIndex++;  //next
            else
                lStatus = ERROR_NOT_ENOUGH_MEMORY;   // reset status to reflect failure
        }
        else if (lStatus == ERROR_NO_MORE_ITEMS)
            fOk = TRUE;     // success
    }
    
    return fOk;
}


BOOL
UnloadManagers(
    PLIST_ENTRY pListHead
    )

/*++

Routine Description:

    Destroys list of permitted managers.

Arguments:

    pListHead - pointer to head of list.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMANAGER_LIST_ENTRY pMLE;

    // process entries until empty
    while (!IsListEmpty(pListHead)) {

        // extract next entry 
        pLE = RemoveHeadList(pListHead);

        // retrieve pointer to manager structure
        pMLE = CONTAINING_RECORD(pLE, MANAGER_LIST_ENTRY, Link);
 
        // release
        FreeMLE(pMLE);
    }

    return TRUE;
}


BOOL
LoadPermittedManagers(
    BOOL bFirstCall
    )

/*++

Routine Description:

    Constructs list of permitted managers.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    BOOL  fPolicy;
    LPTSTR pszKey;
    BOOL fOk = FALSE;
    
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading permitted managers.\n"
        ));

#ifdef _POLICY
    // we need to provide precedence to the parameters set through the policy
    fPolicy = TRUE;
#else
    fPolicy = FALSE;
#endif

    do
    {
        // if the policy is to be enforced, check the policy registry location first
        pszKey = fPolicy ? REG_POLICY_PERMITTED_MANAGERS : REG_KEY_PERMITTED_MANAGERS;

        // open registry subkey    
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    pszKey,
                    0,
                    KEY_READ,
                    &hKey
                    );
        // if the call succeeded or we were not checking the policy, break the loop
        if (lStatus == ERROR_SUCCESS || !fPolicy)
            break;

        // being at this point, this means we were checking for the policy parameters.
        // If and only if the policy is not defined (registry key is missing) we
        // reset the error, mark 'fPolicy already tried' and go back into the loop
        if (lStatus == ERROR_FILE_NOT_FOUND)
        {
            lStatus = ERROR_SUCCESS;
            fPolicy = FALSE;
        }
    } while (lStatus == ERROR_SUCCESS);

    // validate return code
    if (lStatus == ERROR_SUCCESS) {
        
        // call routine to load managers into global list 
        LoadManagers(hKey, &g_PermittedManagers);

        // close key
        RegCloseKey(hKey);

        // at this point consider success (errors localized at particular managers were logged already)
        fOk = TRUE;
    } 
    else
        // it doesn't matter how the values are, the key has to exist,
        // so mark as bFirstCall in order to log an event if this is not true.
        bFirstCall = TRUE;
    
    if (!fOk) {
        
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing PermittedManagers subkey.\n",
            lStatus
            ));

        // report an error only if on first call (service initialization)
        // otherwise, due to registry operations through regedit, the event log
        // might be flooded with records
        if (bFirstCall)
            // report event
            ReportSnmpEvent(
                SNMP_EVENT_INVALID_REGISTRY_KEY, 
                1, 
                &pszKey, 
                lStatus
                );
    }

    return fOk;
}


BOOL
UnloadPermittedManagers(
    )

/*++

Routine Description:

    Destroys list of permitted managers.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // call common routine with global list
    return UnloadManagers(&g_PermittedManagers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\snmppdus.c ===
/*

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmppdus.c

Abstract:

    Contains routines for manipulating SNMP PDUs.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "trapthrd.h" // for doing authentication in this module
#include "network.h"
#include "snmpmgmt.h"
#include "contexts.h" // for doing authentication in this module
#include "snmpthrd.h" // for doing authentication in this module

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define BERERR  ((LONG)-1)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
DoLenLen(
    LONG lLen
    )

/*

Routine Description:

    Calculates number of bytes required to encode length.

Arguments:

    lLen - length of interest.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine len length 
    if (0x80 > lLen) return (1);
    if (0x100 > lLen) return (2);
    if (0x10000 > lLen) return (3);
    if (0x1000000 > lLen) return (4);
    
    SNMPDBG((
        SNMP_LOG_ERROR,
        "SNMP: SVC: length field too large.\n"
        ));

    // failure
    return BERERR; 
}


LONG
FindLenInt(
    AsnInteger32 nValue
    )

/*

Routine Description:

    Calculates length of integer.

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // negative?
    if (nValue < 0) {

        // determine length of negative int
        if ((ULONG)0x80 >= -nValue) return (1);
        if ((ULONG)0x8000 >= -nValue) return (2);
        if ((ULONG)0x800000 >= -nValue) return (3);

    } else {

        // determine length of positive int
        if ((ULONG)0x80 > nValue) return (1);
        if ((ULONG)0x8000 > nValue) return (2);
        if ((ULONG)0x800000 > nValue) return (3);
    }    
    
    // default
    return (4);
}


LONG
FindLenIntEx(
    AsnInteger32 nValue
    )

/*

Routine Description:

    Calculates length of integer (including type and lenlen).

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // negative?
    if (nValue < 0) {

        // determine length of negative int
        if ((ULONG)0x80 >= -nValue) return (3);
        if ((ULONG)0x8000 >= -nValue) return (4);
        if ((ULONG)0x800000 >= -nValue) return (5);

    } else {

        // determine length of positive int
        if ((ULONG)0x80 > nValue) return (3);
        if ((ULONG)0x8000 > nValue) return (4);
        if ((ULONG)0x800000 > nValue) return (5);
    }    
    
    // default
    return (6);
}


LONG 
FindLenUInt(
    AsnUnsigned32 nValue
    )

/*

Routine Description:

    Calculates encoded length of unsigned integer.

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{   
    // determine length of unsigned int
    if ((ULONG)0x80 > nValue) return (1);
    if ((ULONG)0x8000 > nValue) return (2);
    if ((ULONG)0x800000 > nValue) return (3);
    if ((ULONG)0x80000000 > nValue) return (4);

    // default
    return (5);
}



LONG 
FindLenUIntEx(
    AsnUnsigned32 nValue
    )

/*

Routine Description:

    Calculates encoded length of unsigned integer (including type and lenlen).

Arguments:

    nValue - integer data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{   
    // determine length of unsigned int
    if ((ULONG)0x80 > nValue) return (3);
    if ((ULONG)0x8000 > nValue) return (4);
    if ((ULONG)0x800000 > nValue) return (5);
    if ((ULONG)0x80000000 > nValue) return (6);

    // default
    return (7);
}


LONG
FindLenCntr64(
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Calculates encoded length of 64-bit counter.

Arguments:

    pCntr64 - counter data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // retrieve 64-bit unsigned value
    ULONGLONG nValue = pCntr64->QuadPart;

    // determine length of unsigned int
    if ((ULONGLONG)0x80 > nValue) return (1);
    if ((ULONGLONG)0x8000 > nValue) return (2);
    if ((ULONGLONG)0x800000 > nValue) return (3);
    if ((ULONGLONG)0x80000000 > nValue) return (4);
    if ((ULONGLONG)0x8000000000 > nValue) return (5);
    if ((ULONGLONG)0x800000000000 > nValue) return (6);
    if ((ULONGLONG)0x80000000000000 > nValue) return (7);
    if ((ULONGLONG)0x8000000000000000 > nValue) return (8);

    // default
    return (9);
}


LONG
FindLenCntr64Ex(
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Calculates encoded length of 64-bit counter (including type and lenlen).

Arguments:

    pCntr64 - counter data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // retrieve 64-bit unsigned value
    ULONGLONG nValue = pCntr64->QuadPart;

    // determine length of unsigned int
    if ((ULONGLONG)0x80 > nValue) return (3);
    if ((ULONGLONG)0x8000 > nValue) return (4);
    if ((ULONGLONG)0x800000 > nValue) return (5);
    if ((ULONGLONG)0x80000000 > nValue) return (6);
    if ((ULONGLONG)0x8000000000 > nValue) return (7);
    if ((ULONGLONG)0x800000000000 > nValue) return (8);
    if ((ULONGLONG)0x80000000000000 > nValue) return (9);
    if ((ULONGLONG)0x8000000000000000 > nValue) return (10);

    // default
    return (11);
}


LONG
FindLenOctets(
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Calculates length of octet string.

Arguments:

    pOctets - pointer to octet string.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // return size
    return pOctets->length;
}


LONG
FindLenOctetsEx(
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Calculates length of octet string (including type and lenlen).

Arguments:

    pOctets - pointer to octet string.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;

    // calculate bytes needed to encode 
    lLenLen = DoLenLen(pOctets->length);

    // return total size
    return (lLenLen != BERERR)
                ? (pOctets->length + lLenLen + 1)
                : BERERR
                ; 
}


LONG 
FindLenOid(
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Calculates length of object identifier.

Arguments:

    pOid - pointer object identifier.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lDataLen;

    // first two 
    lDataLen = 1;

    // assume first two oids present
    for (i = 2; i < pOid->idLength; i++) {

        if (0x80 > pOid->ids[i]) {         
            lDataLen += 1;
        } else if (0x4000 > pOid->ids[i]) {   
            lDataLen += 2;
        } else if (0x200000 > pOid->ids[i]) {  
            lDataLen += 3;
        } else if (0x10000000 > pOid->ids[i]) {     
            lDataLen += 4;
        } else {
            lDataLen += 5;
        }
    } 

    // return size
    return (pOid->idLength >= 2) ? lDataLen : BERERR;
} 


LONG 
FindLenOidEx(
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Calculates length of object identifier (including type and lenlen).

Arguments:

    pOid - pointer object identifier.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lLenLen;
    LONG lDataLen;

    // first two 
    lDataLen = 1;

    // assume first two oids present
    for (i = 2; i < pOid->idLength; i++) {

        if (0x80 > pOid->ids[i]) {         
            lDataLen += 1;
        } else if (0x4000 > pOid->ids[i]) {   
            lDataLen += 2;
        } else if (0x200000 > pOid->ids[i]) {  
            lDataLen += 3;
        } else if (0x10000000 > pOid->ids[i]) {     
            lDataLen += 4;
        } else {
            lDataLen += 5;
        }
    } 

    // calculate len length
    lLenLen = DoLenLen(lDataLen);

    // return total size
    return ((lLenLen != BERERR) &&
            (pOid->idLength >= 2))
                ? (lDataLen + lLenLen + 1)
                : BERERR
                ;
} 


LONG 
FindLenAsnAny(
    AsnAny * pAny       
    )

/*

Routine Description:

    Find length of variable binding value.

Arguments:

    pAny - pointer to variable binding value.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine syntax
    switch (pAny->asnType) {
    
    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return FindLenOctets(&pAny->asnValue.string);

    case ASN_OBJECTIDENTIFIER:
       
        return FindLenOid(&pAny->asnValue.object);
    
    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        return (0);
    
    case ASN_INTEGER32:

        return FindLenInt(pAny->asnValue.number);
    
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return FindLenUInt(pAny->asnValue.unsigned32);

    case ASN_COUNTER64:

        return FindLenCntr64(&pAny->asnValue.counter64);
    } 

    return BERERR;
} 


LONG 
FindLenAsnAnyEx(
    AsnAny * pAny       
    )

/*

Routine Description:

    Find length of variable binding value (including type and lenlen).

Arguments:

    pAny - pointer to variable binding value.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine syntax
    switch (pAny->asnType) {
    
    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return FindLenOctetsEx(&pAny->asnValue.string);

    case ASN_OBJECTIDENTIFIER:
       
        return FindLenOidEx(&pAny->asnValue.object);
    
    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        return (2);
    
    case ASN_INTEGER32:

        return FindLenIntEx(pAny->asnValue.number);
    
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return FindLenUIntEx(pAny->asnValue.unsigned32);

    case ASN_COUNTER64:

        return FindLenCntr64Ex(&pAny->asnValue.counter64);
    } 

    return BERERR;
} 


LONG 
FindLenVarBind(
    SnmpVarBind * pVb
    )

/*

Routine Description:

    Find length of variable binding.

Arguments:

    pVb - pointer to variable binding.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;
    LONG lOidLen;
    LONG lValueLen;

    // determine length of name
    lOidLen = FindLenOidEx(&pVb->name);
    
    // determine length of value
    lValueLen = FindLenAsnAnyEx(&pVb->value);

    // return total size
    return ((lOidLen != BERERR) &&
            (lValueLen != BERERR)) 
                ? (lOidLen + lValueLen)
                : BERERR
                ;    
} 


LONG 
FindLenVarBindEx(
    SnmpVarBind * pVb
    )

/*

Routine Description:

    Find length of variable binding (including type and lenlen).

Arguments:

    pVb - pointer to variable binding.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;
    LONG lOidLen;
    LONG lValueLen;

    // determine length of name
    lOidLen = FindLenOidEx(&pVb->name);
    
    // determine length of value
    lValueLen = FindLenAsnAnyEx(&pVb->value);

    // determine length of varbind length
    lLenLen = DoLenLen(lOidLen + lValueLen);

    // return total size
    return ((lLenLen != BERERR) &&
            (lOidLen != BERERR) &&
            (lValueLen != BERERR)) 
                ? (lOidLen + lValueLen + lLenLen + 1)
                : BERERR
                ;    
} 


LONG 
FindLenVarBindList(
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Find length of variable binding list.

Arguments:

    pVbl - pointer to variable binding list.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lVbLen = 0;
    LONG lVblLen = 0;

    // process each variable binding in the list
    for (i = 0; (lVbLen != BERERR) && (i < pVbl->len); i++) {

        // determine length of variable binding
        lVbLen = FindLenVarBindEx(&pVbl->list[i]);

        // add to total
        lVblLen += lVbLen;
    }

    // return total size
    return (lVbLen != BERERR) 
                ? lVblLen 
                : BERERR
                ;
}


LONG 
FindLenVarBindListEx(
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Find length of variable binding list (including type and lenlen).

Arguments:

    pVbl - pointer to variable binding list.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lVbLen = 0;
    LONG lVblLen = 0;
    LONG lLenLen;

    // process each variable binding in the list
    for (i = 0; (lVbLen != BERERR) && (i < pVbl->len); i++) {

        // determine length of variable binding
        lVbLen = FindLenVarBindEx(&pVbl->list[i]);

        // add to total
        lVblLen += lVbLen;
    }

    // determine list length 
    lLenLen = DoLenLen(lVblLen);

    // return total size
    return ((lVbLen != BERERR) &&
            (lLenLen != BERERR))
                ? (lVblLen + lLenLen + 1)
                : BERERR
                ;
}


VOID 
AddNull(
    LPBYTE * ppByte, 
    INT      nType
    )

/*

Routine Description:

    Adds null into stream.

Arguments:

    ppByte - pointer to pointer to current stream.

    nType - exact syntax.

Return Values:

    None.

*/

{
    // encode actual syntax 
    *(*ppByte)++ = (BYTE)(0xFF & nType);
    *(*ppByte)++ = 0x00;
}


VOID
AddLen(
    LPBYTE * ppByte, 
    LONG     lLenLen, 
    LONG     lDataLen
    )

/*

Routine Description:

    Adds data length field to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    lLenLen - length of data length.

    lDataLen - actual data length.

Return Values:

    None.

*/

{
    LONG i;
    if (lLenLen == 1) {
        *(*ppByte)++ = (BYTE)lDataLen;
    } else {
        *(*ppByte)++ = (BYTE)(0x80 + lLenLen - 1);
        for (i = 1; i < lLenLen; i++) {
            *(*ppByte)++ = (BYTE)((lDataLen >>
                (8 * (lLenLen - i - 1))) & 0xFF);
        } 
    } 
} 


LONG
AddInt(
    LPBYTE *     ppByte, 
    INT          nType, 
    AsnInteger32 nInteger32
    )

/*

Routine Description:

    Adds integer to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of integer.

    nInteger32 - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG lLenLen;

    // determine length of integer
    lDataLen = FindLenInt(nInteger32);

    // lenlen
    lLenLen = 1;  

    // encode nType of integer
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // encode length of integer
    AddLen(ppByte, lLenLen, lDataLen);

    // add encoded integer
    for (i = 0; i < lDataLen; i++) {
       *(*ppByte)++ = (BYTE)(nInteger32 >> 
            (8 * ((lDataLen - 1) - i) & 0xFF));
    }

    return (0);
}


LONG 
AddUInt(
    LPBYTE *      ppByte, 
    INT           nType, 
    AsnUnsigned32 nUnsigned32
    )

/*

Routine Description:

    Adds unsigned integer to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of integer.

    nUnsigned32 - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG lLenLen;

    // determine length of integer
    lDataLen = FindLenUInt(nUnsigned32);

    // < 127 octets 
    lLenLen = 1; 

    // encode actual syntax
    *(*ppByte)++ = (BYTE)(0xFF & nType);
    
    // encode data length
    AddLen(ppByte, lLenLen, lDataLen);

    // analyze length
    if (lDataLen == 5) {

        // put 00 in first octet 
        *(*ppByte)++ = (BYTE)0;

        // encode unsigned integer
        for (i = 1; i < lDataLen; i++) {
            *(*ppByte)++ = (BYTE)(nUnsigned32 >>
                (8 * ((lDataLen - 1) - i) & 0xFF));
        }
    
    } else {

        // encode unsigned integer
        for (i = 0; i < lDataLen; i++) {
            *(*ppByte)++ = (BYTE)(nUnsigned32 >>
                (8 * ((lDataLen - 1) - i) & 0xFF));
        }
    } 

    return (0);
}


LONG 
AddCntr64(
    LPBYTE *       ppByte, 
    INT            nType, 
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Adds 64-bit counter to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of counter.

    pCntr64 - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG lLenLen;

    // determine length of counter64
    lDataLen = FindLenCntr64(pCntr64);

    // < 127 octets 
    lLenLen = 1; 

    // encode actual syntax        
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // encode data length
    AddLen(ppByte, lLenLen, lDataLen);

    // adjust lDataLen
    if (lDataLen == 9) {
        // put 00 in first octet 
        *(*ppByte)++ = (BYTE)0;
        lDataLen--;
    }

    // encode counter data
    for (i = lDataLen; i > 4; i--) {
        *(*ppByte)++ = (BYTE)(pCntr64->HighPart >>
            (8 * (i - 5) & 0xFF));
    }
    for (; i > 0; i--) {
        *(*ppByte)++ = (BYTE)(pCntr64->LowPart >>
            (8 * (i - 1) & 0xFF));
    }

    return (0);
}


LONG 
AddOctets(
    LPBYTE *         ppByte, 
    INT              nType, 
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Adds octet string to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of string.

    pOctets - actual data.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lLenLen;
    LONG lDataLen;

    // determine oid length
    if ((lDataLen = FindLenOctets(pOctets)) == BERERR)
        return BERERR;

    // calculate octet string length
    if ((lLenLen = DoLenLen(lDataLen)) == BERERR)
        return BERERR;

    // encode actual syntax 
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // encode octet string length
    AddLen(ppByte, lLenLen, lDataLen);

    // usless copy avoided
    if (*ppByte != pOctets->stream)
    {
        // encode actual octets    
        for (i = 0; i < pOctets->length; i++)
            *(*ppByte)++ = pOctets->stream[i];
    }
    else
    {
        (*ppByte) += pOctets->length;
    }

    return (0);
}


LONG 
AddOid(
    LPBYTE * ppByte, 
    INT      nType, 
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Adds object identifier to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    nType - exact syntax of object identifier.

    pOid - pointer to object identifier.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;
    LONG lLenLen = 0;
    LONG lDataLen;

    // determine oid length
    if ((lDataLen = FindLenOid(pOid)) == BERERR)
        return BERERR;

    // calculate number of bytes required for length
    if ((lLenLen = DoLenLen(lDataLen)) == BERERR)
        return BERERR;

    // add syntax to stream
    *(*ppByte)++ = (BYTE)(0xFF & nType);

    // add object identifier length
    AddLen(ppByte, lLenLen, lDataLen);

    // add first subid
    if (pOid->idLength < 2)
       *(*ppByte)++ = (BYTE)(pOid->ids[0] * 40);
    else
       *(*ppByte)++ = (BYTE)((pOid->ids[0] * 40) + pOid->ids[1]);

    // walk remaining subidentifiers
    for (i = 2; i < pOid->idLength; i++) {

        if (pOid->ids[i] < 0x80) {

            // 0 - 0x7f 
            *(*ppByte)++ = (BYTE)pOid->ids[i];

        } else if (pOid->ids[i] < 0x4000) {

            // 0x80 - 0x3fff 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);

        } else if (pOid->ids[i] < 0x200000) {
   
            // 0x4000 - 0x1FFFFF 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 14) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);
      
        } else if (pOid->ids[i] < 0x10000000) {
      
            // 0x200000 - 0xFFfffff 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 21) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 14) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);

        } else {
      
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 28) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 21) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 14) | 0x80); // set high bit 
            *(*ppByte)++ = (BYTE)
            (((pOid->ids[i]) >> 7) | 0x80);  // set high bit 
            *(*ppByte)++ = (BYTE)(pOid->ids[i] & 0x7f);
        }
    } 

    return (0);
}


LONG 
AddAsnAny(
    LPBYTE * ppByte, 
    AsnAny * pAny
    )

/*

Routine Description:

    Adds variable binding value to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pAny - variable binding value.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    // determine syntax        
    switch (pAny->asnType) {

    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return AddUInt(
                ppByte, 
                (INT)pAny->asnType, 
                pAny->asnValue.unsigned32
                );

    case ASN_INTEGER32:

        return AddInt(
                ppByte, 
                (INT)pAny->asnType, 
                pAny->asnValue.number
                );

    case ASN_OBJECTIDENTIFIER:

        return AddOid(
                ppByte, 
                (INT)pAny->asnType,
                &pAny->asnValue.object
                );

    case ASN_COUNTER64:

        return AddCntr64(
                ppByte, 
                (INT)pAny->asnType,
                &pAny->asnValue.counter64
                );

    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return AddOctets(
                ppByte, 
                (INT)pAny->asnType,
                &pAny->asnValue.string
                );

    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        AddNull(ppByte, (INT)pAny->asnType);
        return (0);
    }
    
    return BERERR;
}


LONG 
AddVarBind(
    LPBYTE *      ppByte, 
    SnmpVarBind * pVb 
    )

/*

Routine Description:

    Adds variable binding to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pVb - pointer to variable binding.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG lLenLen;
    LONG lDataLen;

    // determine actual length of varbind data
    if ((lDataLen = FindLenVarBind(pVb)) == BERERR)
       return BERERR;

    // determine length of varbind data length
    if ((lLenLen = DoLenLen(lDataLen)) == BERERR)
       return BERERR;

    // encode as sequence
    *(*ppByte)++ = ASN_SEQUENCE;

    // encode data length    
    AddLen(ppByte, lLenLen, lDataLen);

    // encode variable binding name
    if (AddOid(ppByte, ASN_OBJECTIDENTIFIER, &pVb->name) == BERERR)
        return BERERR;

    // encode variable binding value
    if (AddAsnAny(ppByte, &pVb->value) == BERERR)
        return BERERR;

    return (0);
}


LONG 
AddVarBindList(
    LPBYTE *          ppByte, 
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Adds variable binding list to current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pVbl - pointer to variable binding list.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    UINT i;

    // add each variable binding 
    for (i = 0; i < pVbl->len; i++) {
        if (AddVarBind(ppByte, &pVbl->list[i]) == BERERR)
            return BERERR;
    }

    return (0);
}


LONG
ParseLength(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte
    )

/*

Routine Description:

    Parse length from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    LONG i;
    LONG lLenLen;
    LONG lDataLen;

    if (*ppByte >= pLastByte)
        return BERERR;

    lDataLen = (LONG)*(*ppByte)++;

    if (lDataLen < 0x80)
       return (lDataLen);

    // check for long form
    lLenLen = lDataLen & 0x7f;

    // validate long form and bounds checking
    if ((lLenLen > 4) || (lLenLen < 1) || (lLenLen > (pLastByte - (*ppByte)))) 
       return BERERR;

    lDataLen = 0L;

    for (i = 0; i < lLenLen; i++) {
       lDataLen = (lDataLen << 8) + *(*ppByte)++;
    }

    return (lDataLen);
}


LONG 
ParseType(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte
    )

/*

Routine Description:

    Parse type from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

Return Values:

    Returns BERERR if unsuccessful.

*/

{
    SHORT nType = BERERR;

    if (*ppByte >= pLastByte)
       return BERERR;

    nType = *(*ppByte)++;

    switch (nType) {

    case ASN_INTEGER32:
    case ASN_OCTETSTRING:
    case ASN_OBJECTIDENTIFIER:
    case ASN_SEQUENCE:
    case ASN_IPADDRESS:
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_OPAQUE:
    case ASN_UNSIGNED32:
    case ASN_COUNTER64:
    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:
    case SNMP_PDU_GET:
    case SNMP_PDU_GETNEXT:
    case SNMP_PDU_RESPONSE:
    case SNMP_PDU_SET:
    case SNMP_PDU_V1TRAP:
    case SNMP_PDU_GETBULK:
    case SNMP_PDU_INFORM:
    case SNMP_PDU_TRAP:
        break;

    default:
        nType = BERERR;
        break;
    }
    
    return (LONG)(SHORT)(nType);
} 


BOOL 
ParseNull(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte
    )

/*

Routine Description:

    Parse null from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG lDataLen;

    if (ParseType(ppByte, pLastByte) == BERERR)
        return (FALSE);
    
    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);
    
    if (lDataLen != 0)
        return (FALSE);
    
    return (TRUE);
} 


BOOL 
ParseSequence(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte, 
    LONG *   plDataLen
    )

/*

Routine Description:

    Parse sequence from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    plDataLen - pointer to receive sequence length.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG lDataLen;

    if ((ParseType(ppByte, pLastByte)) != ASN_SEQUENCE)
        return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if (plDataLen)
        *plDataLen = lDataLen;

    return (TRUE);
} 


BOOL 
ParseInt(
    LPBYTE *       ppByte, 
    LPBYTE         pLastByte, 
    AsnInteger32 * pInteger32
    )

/*

Routine Description:

    Parse integer from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pInteger32 - pointer to receive integer.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lSign;
    LONG lDataLen;

    if (ParseType(ppByte, pLastByte) == BERERR)
       return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
       return (FALSE);

    if ((lDataLen <= 0) || (lDataLen > (pLastByte - (*ppByte))))
        return (FALSE);

    if (lDataLen > 4)
       return (FALSE);

    lSign = ((*(*ppByte) & 0x80) == 0x00) ? 0x00 : 0xFF;

    *pInteger32 = 0;

    for (i = 0; i < lDataLen; i++)
       *pInteger32 = (*pInteger32 << 8) + (UINT)*(*ppByte)++;

    // sign-extend upper bits
    for (i = lDataLen; i < 4; i++)
       *pInteger32 = *pInteger32 + (lSign << i * 8);

    return (TRUE);
}


BOOL 
ParseUInt(
    LPBYTE *        ppByte, 
    LPBYTE          pLastByte, 
    AsnUnsigned32 * pUnsigned32
    )

/*

Routine Description:

    Parse unsigned integer from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pUnsigned32 - pointer to receive integer.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;

    if (ParseType(ppByte, pLastByte) == BERERR)
       return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
       return (FALSE);

    if ((lDataLen <= 0) || (lDataLen > (pLastByte - (*ppByte))))
        return (FALSE);

    if ((lDataLen > 5) || ((lDataLen > 4) && (*(*ppByte) != 0x00)))
       return (FALSE);

    // leading null octet?
    if (*(*ppByte) == 0x00)  {
       (*ppByte)++;          // if so, skip it
       lDataLen--;           // and don't count it
    }

    *pUnsigned32 = 0;

    for (i = 0; i < lDataLen; i++)
       *pUnsigned32 = (*pUnsigned32 << 8) + (UINT)*(*ppByte)++;

    return (TRUE);
} 


BOOL
ParseCntr64(
    LPBYTE *       ppByte, 
    LPBYTE         pLastByte,
    AsnCounter64 * pCntr64
    )

/*

Routine Description:

    Parse 64-bit counter from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pCntr64 - pointer to receive counter.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG nType;

    // initialize
    pCntr64->HighPart = 0L;
    pCntr64->LowPart = 0L;

    if ((nType = ParseType(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if (nType != ASN_COUNTER64)
        return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if ((lDataLen <= 0) || (lDataLen > (pLastByte - (*ppByte))))
        return (FALSE);

    if ((lDataLen > 9) || ((lDataLen > 8) && (*(*ppByte) != 0x00)))
        return (FALSE);

    // leading null octet?
    if (*(*ppByte) == 0x00) { 
       (*ppByte)++;          // if so, skip it
       lDataLen--;           // and don't count it
    }

    for (i = 0; i < lDataLen; i++) {
        pCntr64->HighPart = (pCntr64->HighPart << 8) +
            (pCntr64->LowPart >> 24);
        pCntr64->LowPart = (pCntr64->LowPart << 8) +
            (unsigned long) *(*ppByte)++;
    }


    return TRUE;
} 


BOOL
ParseOctets(
    LPBYTE *         ppByte, 
    LPBYTE           pLastByte, 
    AsnOctetString * pOctets
    )

/*

Routine Description:

    Parse octet string from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pOctets - pointer to receive string.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG lDataLen;
    // initialize
    pOctets->length  = 0;
    pOctets->stream  = NULL;
    pOctets->dynamic = FALSE;

    if (ParseType(ppByte, pLastByte) == BERERR)
        return (FALSE);

    // make sure no conversion to UINT is done before testing
    // (pOctets->length is UINT)
    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    // note: we don't reject zero length Octet String
    if ((lDataLen < 0) || (lDataLen > (pLastByte - (*ppByte))))
        return (FALSE);

    pOctets->length = (UINT)lDataLen;

    // validate length
    if (pOctets->length) {

        // point into buffer
        pOctets->stream = *ppByte;  // WARNING! WARNING!
    }

    *ppByte += pOctets->length;

    return (TRUE);
} 


BOOL 
ParseOid(
    LPBYTE *              ppByte, 
    LPBYTE                pLastByte, 
    AsnObjectIdentifier * pOid
    )

/*

Routine Description:

    Parse object identifier from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pOid - pointer to receive oid.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    LONG i;
    LONG lDataLen;
    LONG nType;

    // initialize
    pOid->idLength = 0;
    pOid->ids = NULL;

    if ((nType = ParseType(ppByte, pLastByte)) == BERERR)
        return (FALSE);

    if (nType != ASN_OBJECTIDENTIFIER)
        return (FALSE);

    if ((lDataLen = ParseLength(ppByte, pLastByte)) == BERERR)
        return (FALSE);


    if (lDataLen <= 0) //--ft 03/02/98 removed trailing "|| lDataLen > SNMP_MAX_OID_LEN)"
    {                  // check is done in the while loop below
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ParseOid: lDataLen <= 0, lDataLen=%d.\n",
            lDataLen
            ));
        return (FALSE); 
    }
    
    // BUG# 486089
    // the ((lDataLen + 2) * sizeof(UINT)) expression might cause overflow in 
    // SnmpUtilMemAlloc below. adding one more check to limit its max. value.
    if ( lDataLen > (pLastByte - (*ppByte)) )
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ParseOid: invalid lDataLen=%d, pLastByte=%p,  *ppByte=%p.\n",
            lDataLen, pLastByte, *ppByte
            ));
        return (FALSE);
    }

    pOid->ids = SnmpUtilMemAlloc((DWORD)((lDataLen + 2) * sizeof(UINT)));

    if (pOid->ids == NULL)
        return (FALSE);

    // pOid->ids array space is pre-zero'd via SnmpUtilMemAlloc()
    while (lDataLen && (pOid->idLength < SNMP_MAX_OID_LEN))
    {
        if (pOid->ids[pOid->idLength] & 0xFE000000)
        {
            // overflow in the next left shift
            SnmpUtilMemFree(pOid->ids);
            pOid->ids = NULL;
            pOid->idLength = 0;
            return (FALSE);
        }
        pOid->ids[pOid->idLength] =
            (pOid->ids[pOid->idLength] << 7) | (*(*ppByte) & 0x7F);
        if ((*(*ppByte)++ & 0x80) == 0)
        {   // on the last octet of this sub-id
            if (pOid->idLength == 0)  // check for first sub-id
            {                         // ASN.1/BER packs two into it
                pOid->ids[1] = pOid->ids[0];
                pOid->ids[0] /= 40;
                if (pOid->ids[0] > 2)
                    pOid->ids[0] = 2;
                pOid->ids[1] -= (pOid->ids[0] * 40);
                pOid->idLength++; // extra bump
            }
            pOid->idLength++; // increment the count on sub-id
        }
        lDataLen--;
    } // end_while (lDataLen)

    // BUG 506192
    // Invalid OID BER of the form like "06 07 FF FF FF FF FF FF FF"
    // causes pOid->idLength becomes 0. Each subidentifier should be
    // encoded as a non-negative integer using as few 7-bit blocks as possible.
    // The blocks are packed in octets with the first bit of each octet equal
    // to 1 except for the last octet of each subidentifier. The example above
    // does not have the last octet. Added the (0 == pOid->idLength) test below.
    if (lDataLen || (0 == pOid->idLength)) 
    {
        // the above while loop is terminated without finishing the parsing of the stream
        SnmpUtilMemFree(pOid->ids);
        pOid->ids = NULL;
        pOid->idLength = 0;
        return (FALSE);
    }

    return (TRUE);
} 


BOOL
ParseAsnAny(
    LPBYTE * ppByte, 
    LPBYTE   pLastByte, 
    AsnAny * pAny
    )

/*

Routine Description:

    Parse variable binding value from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pAny - pointer to variable binding value.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    // determine asn type
    switch (pAny->asnType) {
   
    case ASN_COUNTER32:
    case ASN_GAUGE32:
    case ASN_TIMETICKS:
    case ASN_UNSIGNED32:

        return ParseUInt(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.unsigned32
                );

    case ASN_INTEGER32:

        return ParseInt(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.number
                );

    case ASN_OBJECTIDENTIFIER:

        return ParseOid(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.object
                );

    case ASN_COUNTER64:

        return ParseCntr64(
                ppByte, 
                pLastByte,
                &pAny->asnValue.counter64
                );

    case ASN_OCTETSTRING:
    case ASN_IPADDRESS:
    case ASN_OPAQUE:

        return ParseOctets(
                ppByte, 
                pLastByte, 
                &pAny->asnValue.string
                );

    case ASN_NULL:
    case SNMP_EXCEPTION_NOSUCHOBJECT:
    case SNMP_EXCEPTION_NOSUCHINSTANCE:
    case SNMP_EXCEPTION_ENDOFMIBVIEW:

        return ParseNull(ppByte, pLastByte);
    } 

    return (FALSE);
}

BOOL
ValidateContext(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Checks access rights of given context.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if manager allowed access.
    Also, pNLE->fAccessOk is TRUE if manager allowed access.
--*/

{
    PCOMMUNITY_LIST_ENTRY pCLE = NULL;
    AsnOctetString unicodeCommunity;
    LPWSTR         pUnicodeName;

    pNLE->fAccessOk = TRUE;
    if (pNLE->Community.length != 0)
    {
        unicodeCommunity.length = pNLE->Community.length * sizeof(WCHAR);
        unicodeCommunity.stream = SnmpUtilMemAlloc(unicodeCommunity.length);
        unicodeCommunity.dynamic = TRUE;

        if (unicodeCommunity.stream == NULL) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: ValidateContext: SnmpUtilMemAlloc failed to allocate %u bytes.\n",
                unicodeCommunity.length
                ));

            pNLE->fAccessOk = FALSE;
            return pNLE->fAccessOk;
        }

        pNLE->fAccessOk = (MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        pNLE->Community.stream,             // lpMultiByteStr 
                        pNLE->Community.length,             // cbMultiByte 
                        (LPWSTR)(unicodeCommunity.stream),  // lpWideCharStr 
                        pNLE->Community.length) != 0);      // cchWideChar
        
        if (!pNLE->fAccessOk) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: ValidateContext: MultiByteToWideChar returns 0 for request from community %s.\n",
                CommunityOctetsToString(&(pNLE->Community), FALSE)
                ));

            goto Error;
        }
    }
    else
    {
        unicodeCommunity.length = 0;
        unicodeCommunity.stream = NULL;
        unicodeCommunity.dynamic = FALSE;
    }
        
    // search for community string
    if (FindValidCommunity(&pCLE, &unicodeCommunity)) 
    {
        // check access per pdu type
        if (pNLE->Pdu.nType == SNMP_PDU_SET) {
        
            // check flags for write privileges
            pNLE->fAccessOk = (pCLE->dwAccess >= SNMP_ACCESS_READ_WRITE);

        } else {

            // check flags for read privileges
            pNLE->fAccessOk = (pCLE->dwAccess >= SNMP_ACCESS_READ_ONLY);
        }

        if (!pNLE->fAccessOk) {

            // Community does not have the right access

            // register wrong operation for specified community into management structure
            mgmtCTick(CsnmpInBadCommunityUses);
        }
    }
    else
    {
        pNLE->fAccessOk = FALSE;
        
        // register community name failure into the management structure
        mgmtCTick(CsnmpInBadCommunityNames);
    }

    // see if access attempt should be logged
    if (!pNLE->fAccessOk && snmpMgmtBase.AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number) {

        // send authentication trap
        GenerateAuthenticationTrap();        
    }

Error:   
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: %s request from community %s.\n",
        pNLE->fAccessOk 
            ? "accepting"
            : "rejecting"
            ,
        CommunityOctetsToString(&(pNLE->Community), FALSE)
        ));

    SnmpUtilOctetsFree(&unicodeCommunity);

    return (pNLE->fAccessOk);
}

BOOL
ParseVarBind(
    LPBYTE *      ppByte, 
    LPBYTE        pLastByte,
    SnmpVarBind * pVb
    )

/*

Routine Description:

    Parse variable binding from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pVb - pointer to variable binding.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    if (!(ParseSequence(ppByte, pLastByte, NULL)))
        return (FALSE);

    if (!(ParseOid(ppByte, pLastByte, &pVb->name)))
        return (FALSE);

    if (*ppByte >= pLastByte)
    {
        // free memory allocated by ParseOid
        SnmpUtilOidFree(&pVb->name);
        return (FALSE);
    }
        
    pVb->value.asnType = (UINT)*(*ppByte);

    if (!(ParseAsnAny(ppByte, pLastByte, &pVb->value)))
    {
        // free memory allocated by ParseOid
        SnmpUtilOidFree(&pVb->name);
        return (FALSE);
    }

    return TRUE;    
}


BOOL
ParseVarBindList(
    LPBYTE *          ppByte, 
    LPBYTE            pLastByte,
    SnmpVarBindList * pVbl
    )

/*

Routine Description:

    Parse variable binding from current stream.

Arguments:

    ppByte - pointer to pointer to current stream.
     
    pLastByte - pointer to end of current stream.

    pVbl - pointer to variable binding list.

Return Values:

    Returns FALSE if unsuccessful.

*/

{
    SnmpVarBind Vb;
    SnmpVarBind * pVb = NULL;

    // initialize
    pVbl->list = NULL;
    pVbl->len = 0;

    // loop while data is left
    while (*ppByte < pLastByte) {
        
        if (!(ParseVarBind(ppByte, pLastByte, &Vb)))
            return (FALSE);

        // copy pointer
        pVb = pVbl->list;

        // attempt to allocate new variable binding
        pVb = SnmpUtilMemReAlloc(pVb, (pVbl->len + 1) * sizeof(SnmpVarBind));

        // validate
        if (pVb == NULL) 
        {
            SnmpUtilVarBindFree(&Vb);
            return FALSE;
        }
        // update varbind
        pVb[pVbl->len] = Vb;

        // update list
        pVbl->list = pVb;
        pVbl->len++;            
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures (based on snmp\manager\winsnmp\dll\wsnmp_bn.c)          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
BuildMessage(
    AsnInteger32      nVersion,
    AsnOctetString *  pCommunity,
    PSNMP_PDU         pPdu,
    PBYTE             pMessage,
    PDWORD            pMessageSize
    )

/*

Routine Description:

    Builds outgoing SNMP PDU based on structure.

Arguments:

    nVersion - SNMP version.

    pCommunity - pointer to community string.

    pPdu - pointer to PDU data structure.

    pMessage - pointer to buffer in which to build message.

    pMessageSize - pointer to receive size of message.

Return Values:

    Returns true if successful.

*/

{
    LONG nVbDataLength;
    LONG nVbLenLength; 
    LONG nVbTotalLength;
    LONG nPduDataLength; 
    LONG nPduLenLength;
    LONG nPduTotalLength;
    LONG nMsgDataLength; 
    LONG nMsgLenLength;
    LONG nMsgTotalLength;    
    LONG nMsgAvailLength;
    LONG nTmpDataLength;

    LPBYTE tmpPtr = pMessage;

    // determine bytes available
    nMsgAvailLength = *pMessageSize;

    // find length of variable bindings list
    if ((nVbDataLength = FindLenVarBindList(&pPdu->Vbl)) == BERERR)
        return FALSE; 

    // find length of length of variable bindings    
    if ((nVbLenLength = DoLenLen(nVbDataLength)) == BERERR)
        return FALSE; 

    // calculate total bytes required to encode varbinds
    nVbTotalLength = 1 + nVbLenLength + nVbDataLength;

    // determine pdu nType
    switch (pPdu->nType) {

    case SNMP_PDU_GET:
    case SNMP_PDU_GETNEXT:
    case SNMP_PDU_RESPONSE:
    case SNMP_PDU_SET:
    case SNMP_PDU_GETBULK:
    case SNMP_PDU_INFORM:
    case SNMP_PDU_TRAP:

        // calculate bytes required to encode pdu entries
        nPduDataLength = FindLenIntEx(pPdu->Pdu.NormPdu.nRequestId)
                       + FindLenIntEx(pPdu->Pdu.NormPdu.nErrorStatus)
                       + FindLenIntEx(pPdu->Pdu.NormPdu.nErrorIndex)
                       + nVbTotalLength;
        break;

    case SNMP_PDU_V1TRAP:

        // calculate bytes required to encode pdu entries
        nPduDataLength = FindLenIntEx(pPdu->Pdu.TrapPdu.nGenericTrap)
                       + FindLenIntEx(pPdu->Pdu.TrapPdu.nSpecificTrap)
                       + FindLenUIntEx(pPdu->Pdu.TrapPdu.nTimeticks)
                       + nVbTotalLength;
        
        // find oid length
        if ((nTmpDataLength = 
                FindLenOidEx(&pPdu->Pdu.TrapPdu.EnterpriseOid)) == BERERR)
            return FALSE; 

        // add EnterpriseOid oid length
        nPduDataLength += nTmpDataLength;

        // find address length
        if ((nTmpDataLength = 
                FindLenOctetsEx(&pPdu->Pdu.TrapPdu.AgentAddr)) == BERERR)
            return FALSE; 

        // add agent address length
        nPduDataLength += nTmpDataLength;
        break;

    default:
        return FALSE; 
    }

    // find length of pdu length
    if ((nPduLenLength = DoLenLen(nPduDataLength)) == BERERR)
        return FALSE; 

    // calculate total bytes required to encode pdu
    nPduTotalLength = 1 + nPduLenLength + nPduDataLength;

    // find community string length
    if ((nTmpDataLength = FindLenOctetsEx(pCommunity)) == BERERR)
        return FALSE;

    // find length of message data
    nMsgDataLength = FindLenUIntEx(nVersion)
                   + nTmpDataLength
                   + nPduTotalLength;

    // find length of message data length
    if ((nTmpDataLength = DoLenLen(nMsgDataLength)) == BERERR)
        return FALSE;
    nMsgLenLength = nTmpDataLength;

    // calculate total bytes required to encode message
    nMsgTotalLength = 1 + nMsgLenLength + nMsgDataLength;

    // record bytes required
    *pMessageSize = nMsgTotalLength;

    // make sure message fits in buffer
    if (nMsgTotalLength <= nMsgAvailLength) {
        LONG oldLength; // the length of the request PDU
        LONG delta;     // difference between the request PDU length and the responce PDU length
        BYTE *newStream;// new location for the community stream inside the response PDU.

        // encode message as asn sequence        
        *tmpPtr++ = ASN_SEQUENCE;

        // the pointer to the community string points either directly in the incoming buffer 
        // (for req PDUs) or in the TRAP_DESTINATION_LIST_ENTRY for the outgoing traps.
        // In the first case, when building the outgoing message on the same buffer as the
        // incoming message, we need to take care not to overwrite the community name (in case
        // the length field is larger than for the initial message). Hence, in this case only
        // we shift the community name with a few octets, as many as the difference between the
        // encodings of the two lengths (the length of the outgoing response - the length of the
        // incoming request).
        if (pPdu->nType != SNMP_PDU_V1TRAP)
        {
            // here tmpPtr points exactly to the length of the request pdu  
            oldLength = (LONG)(*tmpPtr); // bug# 176433
            // compute the offset the community stream should be shifted with
            delta = nMsgLenLength - ((oldLength & 0x80) ? (oldLength & 0x7f) + 1 : 1);
            if (delta > 0)
            {   // move memory in case the response nMsgLenLength > oldLength
                newStream = pCommunity->stream + delta;
                // pCommunity->stream is shifted regardles memory regions overlapp
                memmove(newStream, pCommunity->stream, pCommunity->length);
                // make old community to point to the new location
                pCommunity->stream = newStream;
            }
        }

        // encode global message information
        AddLen(&tmpPtr, nMsgLenLength, nMsgDataLength);
        AddUInt(&tmpPtr, ASN_INTEGER32, nVersion);
        if (AddOctets(&tmpPtr, ASN_OCTETSTRING, pCommunity) == BERERR)
            return (FALSE);

        // encode pdu header information
        *tmpPtr++ = (BYTE)pPdu->nType;
        AddLen(&tmpPtr, nPduLenLength, nPduDataLength);        

        // determine pdu nType
        switch (pPdu->nType) {

        case SNMP_PDU_RESPONSE:
        case SNMP_PDU_TRAP:

            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.NormPdu.nRequestId);
            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.NormPdu.nErrorStatus);
            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.NormPdu.nErrorIndex);
            break;

        case SNMP_PDU_V1TRAP:

            if (AddOid(
                    &tmpPtr, 
                    ASN_OBJECTIDENTIFIER,        
                    &pPdu->Pdu.TrapPdu.EnterpriseOid)== BERERR)
                return FALSE; 

            if (AddOctets(
                    &tmpPtr, 
                    ASN_IPADDRESS, 
                    &pPdu->Pdu.TrapPdu.AgentAddr) == BERERR)
                return FALSE; 

            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.TrapPdu.nGenericTrap);
            AddInt(&tmpPtr, ASN_INTEGER32, pPdu->Pdu.TrapPdu.nSpecificTrap);
            AddUInt(&tmpPtr, ASN_TIMETICKS, pPdu->Pdu.TrapPdu.nTimeticks);
            break;

        case SNMP_PDU_GET:
        case SNMP_PDU_GETNEXT:
        case SNMP_PDU_SET:
        case SNMP_PDU_INFORM:
        case SNMP_PDU_GETBULK:
        default:
            return FALSE; 
        } 

        // encode variable bindings
        *tmpPtr++ = ASN_SEQUENCE;

        AddLen(&tmpPtr, nVbLenLength, nVbDataLength);

        if (AddVarBindList(&tmpPtr, &pPdu->Vbl) == BERERR)
            return FALSE; 

        // success
        return TRUE; 
    }

    // failure
    return FALSE;
}

BOOL
ParseMessage(
    PNETWORK_LIST_ENTRY pNLE
    )

/*

Routine Description:

    Parses incoming SNMP PDU into structure.

Arguments:
    pNLE - pointer to network list entry.


Return Values:

    Returns true if successful.

Note:
    When TRUE is returned, pNLE->nVersion, pNLE->Community, pNLE->Pdu are 
    updated with structure data parsed from pNLE->Buffer.buf.

    When FALSE is returned AND pNLE->fAccessOk is FALSE, the failure is due to
    authentication instead of ASN parsing errors.
    

*/

{
    LONG lLength;
    LPBYTE pByte;
    LPBYTE pLastByte;
    AsnInteger32 *   pVersion = &pNLE->nVersion;    // pointer to receive SNMP version.
    AsnOctetString * pCommunity = &pNLE->Community; // pointer to receive community string.
    PSNMP_PDU        pPdu = &pNLE->Pdu;             // pointer to receive remaining PDU data.
    PBYTE            pMessage = pNLE->Buffer.buf;   // pointer to message to parse.
    DWORD            dwMessageSize = pNLE->dwBytesTransferred; // number of bytes in message.

    // initialize authentication to a successful state
    pNLE->fAccessOk = TRUE;

    // initialize community
    pCommunity->stream = NULL;
    pCommunity->length = 0;

    // initialize vbl
    pPdu->Vbl.len = 0;
    pPdu->Vbl.list = NULL;

    // validate pointer
    if (!(pByte = pMessage))  
        goto cleanup;

    // set limit based on packet size
    pLastByte = pByte + dwMessageSize;

    // decode asn sequence message wrapper     
    if (!(ParseSequence(&pByte, pLastByte, &lLength)))
        goto cleanup;

    // check for packet fragments
    if ( (lLength <= 0) || (lLength > (pLastByte - pByte)) )
        goto cleanup;

    // re-adjust based on data
    pLastByte = pByte + lLength;
    
    // decode snmp version
    if (!(ParseUInt(&pByte, pLastByte, pVersion)))
        goto cleanup;

    // validate snmp version
    if ((*pVersion != SNMP_VERSION_1) && 
        (*pVersion != SNMP_VERSION_2C)) 
    {
        // register version mismatch into the management structure
        mgmtCTick(CsnmpInBadVersions);

        goto cleanup;
    }

    // decode community string
    if (!(ParseOctets(&pByte, pLastByte, pCommunity)))
        goto cleanup;

    // decode nType of incoming pdu
    if ((pPdu->nType = ParseType(&pByte, pLastByte)) == BERERR)
        goto cleanup;

    // decode length of incoming pdu
    if ((lLength = ParseLength(&pByte, pLastByte)) == BERERR)
        goto cleanup;

    // validate length
    if ( (lLength <= 0) || (lLength > (pLastByte - pByte)) )
        goto cleanup;

    // BUG# 552295 validate context before parsing the PDU 
    switch (pPdu->nType) {
    case SNMP_PDU_GET:                                                          
    case SNMP_PDU_GETNEXT:                                                      
    case SNMP_PDU_SET:  
    case SNMP_PDU_GETBULK:
        if (!ValidateContext(pNLE)) {
            goto cleanup;
        }
        break;
    case SNMP_PDU_INFORM:                                                       
    case SNMP_PDU_RESPONSE:                                                     
    case SNMP_PDU_TRAP:                                                         
    case SNMP_PDU_V1TRAP:                                                       
    default:                                                                    
        goto cleanup;
    }

    // determine pdu nType
    switch (pPdu->nType) {

    case SNMP_PDU_GET:                                                          
    case SNMP_PDU_GETNEXT:                                                      
    case SNMP_PDU_SET:                                                          

        // decode the pdu header information
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.NormPdu.nRequestId)))    
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.NormPdu.nErrorStatus)))  
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.NormPdu.nErrorIndex)))   
            goto cleanup;                                                           

        // update the management counters for the incoming errorStatus coding
        mgmtUtilUpdateErrStatus(IN_errStatus, pPdu->Pdu.NormPdu.nErrorStatus);

        // no reason here to have any ErrorStatus and ErrorIndex.
        // initialize error status variables to NOERROR
        pPdu->Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOERROR;
        pPdu->Pdu.NormPdu.nErrorIndex  = 0;

        break;                                                                      
                                                                                   
    case SNMP_PDU_GETBULK:                                                      

        // decode the getbulk pdu header information
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.BulkPdu.nRequestId)))    
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.BulkPdu.nNonRepeaters)))  
            goto cleanup;                                                           
        if (!(ParseInt(&pByte, pLastByte, &pPdu->Pdu.BulkPdu.nMaxRepetitions)))   
            goto cleanup;                                                           

        // see if value needs to be adjusted
        if (pPdu->Pdu.BulkPdu.nNonRepeaters < 0) {

            // adjust non-repeaters to zero
            pPdu->Pdu.BulkPdu.nNonRepeaters = 0;    
        }

        // see if value needs to be adjusted
        if (pPdu->Pdu.BulkPdu.nMaxRepetitions < 0) {

            // adjust max-repetitions to zero
            pPdu->Pdu.BulkPdu.nMaxRepetitions = 0;
        }

        // initialize status information
        pPdu->Pdu.BulkPdu.nErrorStatus = SNMP_ERRORSTATUS_NOERROR;
        pPdu->Pdu.BulkPdu.nErrorIndex  = 0;

        break;                                                                      
                                                                                   
    case SNMP_PDU_INFORM:                                                       
    case SNMP_PDU_RESPONSE:                                                     
    case SNMP_PDU_TRAP:                                                         
    case SNMP_PDU_V1TRAP:                                                       
    default:                                                                    
        goto cleanup;
    } 

    // parse over sequence
    if (!(ParseSequence(&pByte, pLastByte, NULL)))                            
        goto cleanup;                                                           

    // parse variable binding list
    if (!(ParseVarBindList(&pByte, pLastByte, &pPdu->Vbl)))
        goto cleanup;                                                           

    // success
    return TRUE;

cleanup:

    // cleanup community string    
    SnmpUtilOctetsFree(pCommunity);

    // cleanup any allocated varbinds 
    SnmpUtilVarBindListFree(&pPdu->Vbl);

    // failure
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\snmpthrd.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpthrd.c

Abstract:

    Contains routines for master agent network thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <tchar.h>
#include <stdio.h>
#include "globals.h"
#include "contexts.h"
#include "regions.h"
#include "snmpmgrs.h"
#include "trapmgrs.h"
#include "trapthrd.h"
#include "network.h"
#include "varbinds.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT g_nTransactionId = 0;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MAX_IPX_ADDR_LEN    64
#define MAX_COMMUNITY_LEN   255

#define ERRMSG_TRANSPORT_IP     _T("IP")
#define ERRMSG_TRANSPORT_IPX    _T("IPX")


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSTR
AddrToString(
    struct sockaddr * pSockAddr
    )

/*++

Routine Description:

    Converts sockaddr to display string.

Arguments:

    pSockAddr - pointer to socket address.

Return Values:

    Returns pointer to string.

--*/

{
    static CHAR ipxAddr[MAX_IPX_ADDR_LEN];

    // determine family
    if (pSockAddr->sa_family == AF_INET) {

        struct sockaddr_in * pSockAddrIn;

        // obtain pointer to protocol specific structure
        pSockAddrIn = (struct sockaddr_in * )pSockAddr;

        // forward to winsock conversion function
        return inet_ntoa(pSockAddrIn->sin_addr);

    } else if (pSockAddr->sa_family == AF_IPX) {

        struct sockaddr_ipx * pSockAddrIpx;

        // obtain pointer to protocol specific structure
        pSockAddrIpx = (struct sockaddr_ipx * )pSockAddr;

        // transfer ipx address to static buffer
        sprintf(ipxAddr, 
            "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x",
            (BYTE)pSockAddrIpx->sa_netnum[0],
            (BYTE)pSockAddrIpx->sa_netnum[1],
            (BYTE)pSockAddrIpx->sa_netnum[2],
            (BYTE)pSockAddrIpx->sa_netnum[3],
            (BYTE)pSockAddrIpx->sa_nodenum[0],
            (BYTE)pSockAddrIpx->sa_nodenum[1],
            (BYTE)pSockAddrIpx->sa_nodenum[2],
            (BYTE)pSockAddrIpx->sa_nodenum[3],
            (BYTE)pSockAddrIpx->sa_nodenum[4],
            (BYTE)pSockAddrIpx->sa_nodenum[5]
            );

        // return addr
        return ipxAddr;
    }

    // failure
    return NULL;
}


LPSTR
CommunityOctetsToString(
    AsnOctetString  *pAsnCommunity,
    BOOL            bUnicode
    )

/*++

Routine Description:

    Converts community octet string to display string.

Arguments:

    pAsnCommunity - pointer to community octet string.

Return Values:

    Returns pointer to string.

--*/

{
    static CHAR Community[MAX_COMMUNITY_LEN+1];
    LPSTR pCommunity = Community;

    // terminate string
    *pCommunity = '\0';

    // validate pointer
    if (pAsnCommunity != NULL)
    {
        DWORD nChars = 0;
    
        // determine number of characters to transfer
        nChars = min(pAsnCommunity->length, MAX_COMMUNITY_LEN);

        if (bUnicode)
        {
            WCHAR wCommunity[MAX_COMMUNITY_LEN+1];

            // tranfer memory into buffer
            memset(wCommunity, 0, nChars+sizeof(WCHAR));
            memcpy(wCommunity, pAsnCommunity->stream, nChars);
            SnmpUtilUnicodeToAnsi(&pCommunity, wCommunity, FALSE);
        }
        else
        {
            memcpy(Community, pAsnCommunity->stream, nChars);
            Community[nChars] = '\0';
        }
    }

    // success
    return pCommunity;
}


LPSTR
StaticUnicodeToString(
    LPWSTR wszUnicode
    )

/*++

Routine Description:

    Converts null terminated UNICODE string to static LPSTR

Arguments:

    pOctets - pointer to community octet string.

Return Values:

    Returns pointer to string.

--*/

{
    static CHAR szString[MAX_COMMUNITY_LEN+1];
    LPSTR       pszString = szString;

    // terminate string
    *pszString = '\0';

    // validate pointer
    if (wszUnicode != NULL)
    {
        WCHAR wcBreak;
        BOOL  bNeedBreak;

        bNeedBreak = (wcslen(wszUnicode) > MAX_COMMUNITY_LEN);

        if (bNeedBreak)
        {
            wcBreak = wszUnicode[MAX_COMMUNITY_LEN];
            wszUnicode[MAX_COMMUNITY_LEN] = L'\0';
        }

        SnmpUtilUnicodeToAnsi(&pszString, wszUnicode, FALSE);

        if (bNeedBreak)
            wszUnicode[MAX_COMMUNITY_LEN] = wcBreak;
    }

    // success
    return pszString;
}


BOOL
ValidateManager(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Checks access rights of given manager.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if manager allowed access.

--*/

{
    BOOL fAccessOk = FALSE;
    PMANAGER_LIST_ENTRY pMLE = NULL;

    fAccessOk = IsManagerAddrLegal((struct sockaddr_in *)&pNLE->SockAddr) &&
                (FindManagerByAddr(&pMLE, &pNLE->SockAddr) ||
                 IsListEmpty(&g_PermittedManagers)
                );

    if (!fAccessOk &&
        snmpMgmtBase.AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number)
        GenerateAuthenticationTrap();

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: %s request from %s.\n",
        fAccessOk 
            ? "accepting"
            : "rejecting"
            ,
        AddrToString(&pNLE->SockAddr)
        ));

    return fAccessOk;
}


BOOL
ProcessSnmpMessage(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Parse SNMP message and dispatch to subagents.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // decode request
    if (ParseMessage(pNLE)) 
    {

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: %s request, community %s, %d variable(s).\n",
            PDUTYPESTRING(pNLE->Pdu.nType),
            CommunityOctetsToString(&(pNLE->Community), FALSE),
            pNLE->Pdu.Vbl.len
            ));        
        
        if (ProcessVarBinds(pNLE)) 
        {
            // initialize buffer length
            pNLE->Buffer.len = NLEBUFLEN;

            // reset pdu type to response
            pNLE->Pdu.nType = SNMP_PDU_RESPONSE;
            
            // encode response
            fOk = BuildMessage(
                    pNLE->nVersion,
                    &pNLE->Community,
                    &pNLE->Pdu,
                    pNLE->Buffer.buf,
                    &pNLE->Buffer.len
                    );
        }
    }
    else 
    {
        if (pNLE->fAccessOk) 
        {
            // BUG# 552295
            // authentication succeeded or not done yet, 
            // the error is due to BER decoding failure           
            
            // register BER decoding failure into the management structures
            mgmtCTick(CsnmpInASNParseErrs);
        }
    }

    // release pdu
    UnloadPdu(pNLE);

    return fOk; 
}         


void CALLBACK
RecvCompletionRoutine(
    IN  DWORD           dwStatus,
    IN  DWORD           dwBytesTransferred,
    IN  LPWSAOVERLAPPED pOverlapped,
    IN  DWORD           dwFlags
    )

/*++

Routine Description:

    Callback for completing asynchronous reads.

Arguments:

    Status - completion status for the overlapped operation.

    BytesTransferred - number of bytes transferred.

    pOverlapped - pointer to overlapped structure.

    Flags - receive flags.

Return Values:

    None.

--*/

{
    PNETWORK_LIST_ENTRY pNLE; 

    EnterCriticalSection(&g_RegCriticalSectionA);

    // retreive pointer to network list entry from overlapped structure
    pNLE = CONTAINING_RECORD(pOverlapped, NETWORK_LIST_ENTRY, Overlapped);

    // copy receive completion information
    pNLE->nTransactionId = ++g_nTransactionId;
    pNLE->dwBytesTransferred = dwBytesTransferred;
    pNLE->dwStatus = dwStatus;
    pNLE->dwFlags = dwFlags;
        
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: --- transaction %d begin ---\n",
        pNLE->nTransactionId
        ));        
        
    // validate status
    if (dwStatus == NOERROR) {

        // register incoming packet into the management structure
        mgmtCTick(CsnmpInPkts);

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: received %d bytes from %s.\n",
            pNLE->dwBytesTransferred,
            AddrToString(&pNLE->SockAddr)
            ));        
        
        // check manager address
        if (ValidateManager(pNLE)) {

            // process snmp message 
            if (ProcessSnmpMessage(pNLE)) {

                // synchronous send
                dwStatus = WSASendTo(
                              pNLE->Socket,
                              &pNLE->Buffer,
                              1,
                              &pNLE->dwBytesTransferred,
                              pNLE->dwFlags,
                              &pNLE->SockAddr,
                              pNLE->SockAddrLenUsed,
                              NULL,
                              NULL
                              );

                // register outgoing packet into the management structure
                mgmtCTick(CsnmpOutPkts);
                // register outgoing Response PDU
                mgmtCTick(CsnmpOutGetResponses);

                // validate return code
                if (dwStatus != SOCKET_ERROR) {

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: SVC: sent %d bytes to %s.\n",
                        pNLE->dwBytesTransferred,
                        AddrToString(&pNLE->SockAddr)
                        ));

                } else {
                    
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: error %d sending response.\n",
                        WSAGetLastError()
                        ));
                }
            }
        }

    } else {
    
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d receiving snmp request.\n",
            dwStatus
            ));
    }

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: --- transaction %d end ---\n",
        pNLE->nTransactionId
        ));        

    LeaveCriticalSection(&g_RegCriticalSectionA);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
ProcessSnmpMessages(
    PVOID pParam
    )

/*++

Routine Description:

    Thread procedure for processing SNMP PDUs.

Arguments:

    pParam - unused.

Return Values:

    Returns true if successful.

--*/

{
    DWORD dwStatus;
    PLIST_ENTRY pLE;
    PNETWORK_LIST_ENTRY pNLE;
    
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Registry Parameters.\n"
        ));

    // fire cold start trap
    GenerateColdStartTrap();

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: starting pdu processing thread.\n"
        ));

    ReportSnmpEvent(
        SNMP_EVENT_SERVICE_STARTED,
        0,
        NULL,
        0);

    // loop
    for (;;)
    {
        // obtain pointer to first transport
        pLE = g_IncomingTransports.Flink;

        // loop through incoming transports
        while (pLE != &g_IncomingTransports)
        {
            // retreive pointer to network list entry from link
            pNLE = CONTAINING_RECORD(pLE, NETWORK_LIST_ENTRY, Link);

            // make sure recv is not pending
            if (pNLE->dwStatus != WSA_IO_PENDING)
            {
                // reset completion status
                pNLE->dwStatus = WSA_IO_PENDING;

                // intialize address structure size 
                pNLE->SockAddrLenUsed = pNLE->SockAddrLen;

                // initialize buffer length
                pNLE->Buffer.len = NLEBUFLEN;

                // re-initialize
                pNLE->dwFlags = 0;

                // post receive buffer
                dwStatus = WSARecvFrom(
                                pNLE->Socket,
                                &pNLE->Buffer,
                                1, // dwBufferCount
                                &pNLE->dwBytesTransferred,
                                &pNLE->dwFlags,
                                &pNLE->SockAddr,
                                &pNLE->SockAddrLenUsed,
                                &pNLE->Overlapped,
                                RecvCompletionRoutine
                                );

                // handle network failures
                if (dwStatus == SOCKET_ERROR)
                {
                    // retrieve last error
                    dwStatus = WSAGetLastError();

                    // if WSA_IO_PENDING everything is ok, just waiting for incoming traffic. Otherwise...
                    if (dwStatus != WSA_IO_PENDING)
                    {
                        // WSAECONNRESET means the last 'WSASendTo' (the one from RecvCompletionRoutine) failed
                        // most probably because the manager closed the socket (so we got back 'unreacheable destination port')
                        if (dwStatus == WSAECONNRESET)
                        {
                            SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: SVC: Benign error %d posting receive buffer. Retry...\n",
                                dwStatus
                                ));

                            // just go one more time and setup the port. It shouldn't ever loop continuously
                            // and hence hog the CPU..
                            pNLE->dwStatus = ERROR_SUCCESS;
                            continue;
                        }
                        else
                        {
                            // prepare the event log insertion string
                            LPTSTR pMessage = (pNLE->SockAddr.sa_family == AF_INET) ?
                                                ERRMSG_TRANSPORT_IP :
                                                ERRMSG_TRANSPORT_IPX;

                            // another error occurred. We don't know how to handle it so it is a fatal
                            // error for this transport. Will shut it down.
                            SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: SVC: Fatal error %d posting receive buffer. Skip transport.\n",
                                dwStatus
                                ));

                            ReportSnmpEvent(
                                SNMP_EVNT_INCOMING_TRANSPORT_CLOSED,
                                1,
                                &pMessage,
                                dwStatus);

                            // first step next with the pointer
                            pLE = pLE->Flink;

                            // delete this transport from the incoming transports list
                            UnloadTransport(pNLE);

                            // go on further
                            continue;
                        }
                    }
                }
            }

            pLE = pLE->Flink;
        }

        // we might want to shut the service down if no incoming transport remains.
        // we might as well consider letting the service up in order to keep sending outgoing traps.
        // for now, keep the service up (code below commented)
        //if (IsListEmpty(&g_IncomingTransports))
        //{
        //    ReportSnmpEvent(...);
        //    ProcessControllerRequests(SERVICE_CONTROL_STOP);
        //}

        // wait for incoming requests or indication of process termination 
        dwStatus = WaitForSingleObjectEx(g_hTerminationEvent, INFINITE, TRUE);

        // validate return code
        if (dwStatus == WAIT_OBJECT_0) {
                
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: exiting pdu processing thread.\n"
                ));

            // success
            return NOERROR;

        } else if (dwStatus != WAIT_IO_COMPLETION) {

            // retrieve error
            dwStatus = GetLastError();
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for request.\n",
                dwStatus
                ));
            
            // failure
            return dwStatus;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\startup.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    startup.c

Abstract:

    Contains routines for starting SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "startup.h"
#include "network.h"
#include "registry.h"
#include "snmpthrd.h"
#include "regthrd.h"
#include "trapthrd.h"
#include "args.h"
#include "mem.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE g_hAgentThread = NULL;
HANDLE g_hRegistryThread = NULL; // Used to track registry changes
CRITICAL_SECTION g_RegCriticalSectionA;
CRITICAL_SECTION g_RegCriticalSectionB;
CRITICAL_SECTION g_RegCriticalSectionC; // protect the generation of trap from 
                                        // registry changes
// All CriticalSection inited or not, this flag is only used in this file.
static BOOL g_fCriticalSectionsInited = FALSE;

// privileges that we want to keep
static const LPCWSTR c_arrszPrivilegesToKeep[] = {
    L"SeChangeNotifyPrivilege",
    L"SeSecurityPrivilege"
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadWinsock(
    )

/*++

Routine Description:

    Startup winsock.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    WSADATA WsaData;
    WORD wVersionRequested = MAKEWORD(2,0);
    INT nStatus;
    
    // attempt to startup winsock    
    nStatus = WSAStartup(wVersionRequested, &WsaData);

    // validate return code
    if (nStatus == SOCKET_ERROR) {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d starting winsock.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}

BOOL
UnloadWinsock(
    )

/*++

Routine Description:

    Shutdown winsock.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    INT nStatus;

    // cleanup
    nStatus = WSACleanup();

    // validate return code
    if (nStatus == SOCKET_ERROR) {
            
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d stopping winsock.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}

/*++

Routine Description:

    Get all privileges to be removed except the ones specified in 
    c_arrszPrivilegesToKeep.

Arguments:

    hToken       [IN]    An opened access token
    ppPrivs      [OUT]   An array of privileges to be returned
    pdwNumPrivs  [OUT]   Number of privileges in ppPrivs


Return Values:

    Returns ERROR_SUCCESS if successful.

Note: It is caller's responsibility to call AgentMemFree on *ppPrivs if
      ERROR_SUCCESS is returned and *ppPrivs is not NULL

--*/
static DWORD GetAllPrivilegesToRemoveExceptNeeded(
    HANDLE                  hToken, 
    PLUID_AND_ATTRIBUTES*   ppPrivs,
    PDWORD                  pdwNumPrivs)
{
    DWORD dwRet = ERROR_SUCCESS;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    PLUID_AND_ATTRIBUTES pPrivsToRemove = NULL;
    DWORD dwPrivsToDel = 0;
    DWORD dwPrivNameSize = 0;
    
    // init return values
    *ppPrivs = NULL;
    *pdwNumPrivs = 0;

    do
    {
        LPWSTR pszPrivName = NULL;
        DWORD i, dwSize = 0;
    
        GetTokenInformation(hToken,
                            TokenPrivileges,
                            NULL,
                            0,
                            &dwSize);

        if (0 == dwSize)
        {
            // process has no privileges to be removed
            return dwRet;
        }

        pTokenPrivs = (PTOKEN_PRIVILEGES) AgentMemAlloc(dwSize);
        if (NULL == pTokenPrivs)
        {
            dwRet = ERROR_OUTOFMEMORY;
            break;
        }
        
        if (!GetTokenInformation(
            hToken,
            TokenPrivileges,
            pTokenPrivs,
            dwSize, &dwSize))
        {
            dwRet = GetLastError();
            break;
        }
        
        pPrivsToRemove = (PLUID_AND_ATTRIBUTES) AgentMemAlloc(
                            sizeof(LUID_AND_ATTRIBUTES) * pTokenPrivs->PrivilegeCount);
        
        if (NULL == pPrivsToRemove)
        {
            dwRet = ERROR_OUTOFMEMORY;
            break;
        }
        
        // LookupPrivilegeName need the buffer size in char and NOT including 
        // the NULL terminator
        dwPrivNameSize = MAX_PATH;
        pszPrivName = (LPWSTR) AgentMemAlloc((dwPrivNameSize + 1) * sizeof(WCHAR));
        if (NULL == pszPrivName)
        {
            dwRet = ERROR_OUTOFMEMORY;
            break;
        }

        for (i=0; i < pTokenPrivs->PrivilegeCount; i++) 
        {
            BOOL bFound;
            DWORD j;
            DWORD dwTempSize = dwPrivNameSize;            
            
            ZeroMemory(pszPrivName, (dwPrivNameSize + 1) * sizeof(WCHAR));
            if (!LookupPrivilegeNameW(NULL,
                    &pTokenPrivs->Privileges[i].Luid,
                    pszPrivName,
                    &dwTempSize))
            {
                dwRet = GetLastError();
                if (ERROR_INSUFFICIENT_BUFFER == dwRet && dwTempSize > dwPrivNameSize)
                {
                    //reallocate a bigger buffer
                    dwRet = ERROR_SUCCESS;
                    AgentMemFree(pszPrivName);
                    pszPrivName = (LPWSTR) AgentMemAlloc((dwTempSize + 1) * sizeof(WCHAR));
                    if (NULL == pszPrivName)
                    {
                        dwRet = ERROR_OUTOFMEMORY;
                        break;
                    }
                    // AgentMemAlloc zero'ed the allocated memory
                    dwPrivNameSize = dwTempSize;

                    //try it again
                    if (!LookupPrivilegeNameW(NULL,
                        &pTokenPrivs->Privileges[i].Luid,
                        pszPrivName,
                        &dwTempSize))
                    {
                        dwRet = GetLastError();
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            bFound = FALSE;
            for (j = 0; 
                j < sizeof(c_arrszPrivilegesToKeep)/sizeof(c_arrszPrivilegesToKeep[0]); 
                ++j)
            {
                if (0 == lstrcmpiW(pszPrivName, c_arrszPrivilegesToKeep[j]))
                {
                    bFound = TRUE;
                    break;
                }
            }

            if (bFound)
                continue;

            pPrivsToRemove[dwPrivsToDel] = pTokenPrivs->Privileges[i];
            dwPrivsToDel++;
        }
        
        // free memory if necessary
        AgentMemFree(pszPrivName);
        
    } while (FALSE);
    
    // free memory if necessary
    AgentMemFree(pTokenPrivs);

    if (ERROR_SUCCESS == dwRet)
    {
        // transfer values
        *pdwNumPrivs = dwPrivsToDel;
        *ppPrivs = pPrivsToRemove;
    }
    else if (pPrivsToRemove)
    {
        AgentMemFree(pPrivsToRemove);
    }
        
    return dwRet;
}

/*++

Routine Description:

    BuildTokenPrivileges 

Arguments:

    pPrivs                  [IN]    An array of privileges
    dwNumPrivs              [IN]    Number of privileges in pPrivs
    ppTokenPrivs            [OUT]   Pointer to TOKEN_PRIVILEGES to be returned
    pdwTokenPrivsBufferSize [OUT]   Buffer size in bytes that *ppTokenPrivs has 

Return Values:

    Returns ERROR_SUCCESS if successful.

Note: It's caller's responsibility to call AgentMemFree on *ppPrivs if
      ERROR_SUCCESS is returned and *ppPrivs is not NULL

--*/
static DWORD BuildTokenPrivileges(
    PLUID_AND_ATTRIBUTES    pPrivs,
    DWORD                   dwNumPrivs,
    DWORD                   dwAttributes,
    PTOKEN_PRIVILEGES*      ppTokenPrivs,
    PDWORD                  pdwTokenPrivsBufferSize)
{
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    DWORD i, dwBufferSize;

    
    // design by contract, parameters have to be valid. e.g. 
    // dwNumPrivs > 0
    // *ppTokenPrivs == NULL
    // *pdwTokenPrivsBufferSize == 0

    // allocate the privilege buffer
    dwBufferSize = sizeof(TOKEN_PRIVILEGES) + 
                    ((dwNumPrivs-1) * sizeof(LUID_AND_ATTRIBUTES));
    pTokenPrivs = (PTOKEN_PRIVILEGES) AgentMemAlloc(dwBufferSize);
    if (NULL == pTokenPrivs)
    {
        return ERROR_OUTOFMEMORY;
    }
    
    // build the desired TOKEN_PRIVILEGES
    pTokenPrivs->PrivilegeCount = dwNumPrivs;
    for (i = 0; i < dwNumPrivs; ++i)
    {
        pTokenPrivs->Privileges[i].Luid        = pPrivs[i].Luid;
        pTokenPrivs->Privileges[i].Attributes  = dwAttributes;
    }

    // transfer values
    *ppTokenPrivs = pTokenPrivs;
    *pdwTokenPrivsBufferSize = dwBufferSize;

    return ERROR_SUCCESS;
}

/*++

Routine Description:

    RemoveUnnecessaryTokenPrivileges 

Arguments:


Return Values:

    Returns TRUE if successful.

--*/
static BOOL RemoveUnnecessaryTokenPrivileges()
{
    DWORD dwRet = ERROR_SUCCESS;
    HANDLE hProcessToken = NULL;
    PLUID_AND_ATTRIBUTES pPrivsToRemove = NULL;
    DWORD dwNumPrivs = 0;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    DWORD dwTokenPrivsBufferSize = 0;
    
    do
    {
        if (!OpenProcessToken( GetCurrentProcess(), 
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hProcessToken ))
        {
            dwRet = GetLastError();
            break;
        }

        dwRet = GetAllPrivilegesToRemoveExceptNeeded(hProcessToken, 
                                                    &pPrivsToRemove,
                                                    &dwNumPrivs);
        if (ERROR_SUCCESS != dwRet )
        {
            break;
        }

        // Assert: dwRet == ERROR_SUCCESS
        if ( (NULL==pPrivsToRemove) || (0==dwNumPrivs) )
        {
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: No privileges need to be removed.\n"
                ));

            break;
        }

        dwRet = BuildTokenPrivileges(pPrivsToRemove, 
                                        dwNumPrivs, 
                                        SE_PRIVILEGE_REMOVED,
                                        &pTokenPrivs,
                                        &dwTokenPrivsBufferSize);
        if (ERROR_SUCCESS != dwRet )
        {
            break;
        }

        if (!AdjustTokenPrivileges(hProcessToken, 
                                    FALSE,
                                    pTokenPrivs,
                                    dwTokenPrivsBufferSize, 
                                    NULL, 
                                    NULL))
        {
            dwRet = GetLastError();
            break;
        }
    } while(FALSE);

    // free resources if necessary
    if (hProcessToken)
        CloseHandle(hProcessToken);
    AgentMemFree(pPrivsToRemove);
    AgentMemFree(pTokenPrivs);

    if (dwRet != ERROR_SUCCESS)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: RemoveUnnecessaryTokenPrivileges failed 0x%x\n", 
            dwRet));

        return FALSE;
    }
    else
        return TRUE;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
StartupAgent(
    )

/*++

Routine Description:

    Performs essential initialization of master agent.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    DWORD dwThreadId = 0;
    DWORD regThreadId = 0;
    INT nCSOk = 0;          // counts the number of CS that were successfully initialized

    // initialize management variables
    mgmtInit();

    // initialize list heads
    InitializeListHead(&g_Subagents);
    InitializeListHead(&g_SupportedRegions);
    InitializeListHead(&g_ValidCommunities);
    InitializeListHead(&g_TrapDestinations);
    InitializeListHead(&g_PermittedManagers);
    InitializeListHead(&g_IncomingTransports);
    InitializeListHead(&g_OutgoingTransports);

    __try
    {
        InitializeCriticalSection(&g_RegCriticalSectionA); nCSOk++;
        InitializeCriticalSection(&g_RegCriticalSectionB); nCSOk++;
        InitializeCriticalSection(&g_RegCriticalSectionC); nCSOk++;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        if (nCSOk == 1)
            DeleteCriticalSection(&g_RegCriticalSectionA);
        if (nCSOk == 2)
        {
            DeleteCriticalSection(&g_RegCriticalSectionA);
            DeleteCriticalSection(&g_RegCriticalSectionB);
        }
        // nCSOk can't be 3 as far as we are here

        fOk = FALSE;
    }
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Initialize critical sections...%s\n", fOk? "Ok" : "Failed"));

    if (fOk)
    {
        g_fCriticalSectionsInited = TRUE;
    }

    fOk = fOk &&
          (g_hRegistryEvent = CreateEvent(NULL, FALSE, TRUE, NULL)) != NULL;


    g_dwUpTimeReference = SnmpSvcInitUptime();
    // retreive system uptime reference
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Getting system uptime...%d\n", g_dwUpTimeReference));

    // allocate essentials
    fOk = fOk && AgentHeapCreate();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Creating agent heap...%s\n", fOk? "Ok" : "Failed"));

    if (fOk)
    {
        // Remove unnecessary privileges from the service
        RemoveUnnecessaryTokenPrivileges();
        // any error is ignored
    }

    fOk = fOk && LoadWinsock();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Winsock stack...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk && LoadIncomingTransports();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Incoming transports...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk && LoadOutgoingTransports();
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Loading Outgoing transports...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk &&
            // attempt to start main thread
          (g_hAgentThread = CreateThread(
                               NULL,               // lpThreadAttributes
                               0,                  // dwStackSize
                               ProcessSnmpMessages,
                               NULL,               // lpParameter
                               CREATE_SUSPENDED,   // dwCreationFlags
                               &dwThreadId
                               )) != NULL;
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Starting ProcessSnmpMessages thread...%s\n", fOk? "Ok" : "Failed"));

    fOk = fOk &&
           // attempt to start registry listener thread
          (g_hRegistryThread = CreateThread(
                               NULL,
                               0,
                               ProcessRegistryMessage,
                               NULL,
                               CREATE_SUSPENDED,
                               &regThreadId)) != NULL;
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: SVC: Starting ProcessRegistryMessages thread...%s\n", fOk? "Ok" : "Failed"));

    return fOk;        
}


BOOL
ShutdownAgent(
    )

/*++

Routine Description:

    Performs final cleanup of master agent.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    DWORD dwStatus;

    // make sure shutdown signalled
    fOk = SetEvent(g_hTerminationEvent);

    if (!fOk) {
                    
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d signalling termination.\n",
            GetLastError()
            ));
    }

    // check if thread created
    if ((g_hAgentThread != NULL) && (g_hRegistryThread != NULL)) {
        HANDLE hEvntArray[2];

        hEvntArray[0] = g_hAgentThread;
        hEvntArray[1] = g_hRegistryThread;

        dwStatus = WaitForMultipleObjects(2, hEvntArray, TRUE, SHUTDOWN_WAIT_HINT);

        // validate return status
        if ((dwStatus != WAIT_OBJECT_0) &&
            (dwStatus != WAIT_OBJECT_0 + 1) &&
            (dwStatus != WAIT_TIMEOUT)) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for thread(s) termination.\n",
                GetLastError()
                ));
        }
    } else if (g_hAgentThread != NULL) {

        // wait for pdu processing thread to terminate
        dwStatus = WaitForSingleObject(g_hAgentThread, SHUTDOWN_WAIT_HINT);

        // validate return status
        if ((dwStatus != WAIT_OBJECT_0) &&
            (dwStatus != WAIT_TIMEOUT)) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for main thread termination.\n",
                GetLastError()
                ));
        }
    } else if (g_hRegistryThread != NULL) {

        // wait for registry processing thread to terminate
        dwStatus = WaitForSingleObject(g_hRegistryThread, SHUTDOWN_WAIT_HINT);

        // validate return status
        if ((dwStatus != WAIT_OBJECT_0) &&
            (dwStatus != WAIT_TIMEOUT)) {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: error %d waiting for registry thread termination.\n",
                GetLastError()
                ));
        }
    }

    if (g_fCriticalSectionsInited)
    {
        // in case registry processing thread hasn't terminated yet, we need
        // to make sure critical section are safe for deletion and
        // common resources in UnloadRegistryParameters() are still protected.
        
        EnterCriticalSection(&g_RegCriticalSectionA);
        EnterCriticalSection(&g_RegCriticalSectionB);
        EnterCriticalSection(&g_RegCriticalSectionC);
    }

    // unload incoming transports
    UnloadIncomingTransports();

    // unload outgoing transports
    UnloadOutgoingTransports();

    // unload registry info
    UnloadRegistryParameters();

    // unload the winsock stack
    UnloadWinsock();

    // cleanup the internal management buffers
    mgmtCleanup();

    // nuke private heap
    AgentHeapDestroy();

    if (g_fCriticalSectionsInited)
    {
        LeaveCriticalSection(&g_RegCriticalSectionC);
        LeaveCriticalSection(&g_RegCriticalSectionB);
        LeaveCriticalSection(&g_RegCriticalSectionA);

        // clean up critical section resources
        DeleteCriticalSection(&g_RegCriticalSectionA);
        DeleteCriticalSection(&g_RegCriticalSectionB);
        DeleteCriticalSection(&g_RegCriticalSectionC);
    }

    ReportSnmpEvent(
        SNMP_EVENT_SERVICE_STOPPED,
        0,
        NULL,
        0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\snmpevts.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpevts.c

Abstract:

    Eventlog message routines for the SNMP Service.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
ReportSnmpEvent(
    DWORD   nMsgId, 
    DWORD   nSubStrings, 
    LPTSTR *ppSubStrings,
    DWORD   nErrorCode
    )

/*++

Routine Description:

    Reports event with EventLog service.

Arguments:

    nMsgId - message identifier.

    nSubStrings - number of message strings.
    
    ppSubStrings - pointer to array of message strings.
    
    nErrorCode - error code to be attached to event.            

Return Values:

    Returns true if successful.

--*/

{
    HANDLE lh;
    WORD   wEventType;
    LPVOID lpData;
    WORD   cbData;

    //    
    // determine type of event from message id.  note that
    // all debug messages regardless of their severity are
    // listed under SNMP_EVENT_DEBUG_TRACE (informational).
    // see snmpevts.h for the entire list of event messages.
    //

    switch ( nMsgId >> 30 ) {

    case STATUS_SEVERITY_INFORMATIONAL:
    case STATUS_SEVERITY_SUCCESS:
        wEventType = EVENTLOG_INFORMATION_TYPE;
        break;

    case STATUS_SEVERITY_WARNING:
        wEventType = EVENTLOG_WARNING_TYPE;
        break;

    case STATUS_SEVERITY_ERROR:
    default:
        wEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    // determine size of data by whether error present
    cbData = (nErrorCode == NO_ERROR) ? 0 : sizeof(DWORD);
    lpData = (nErrorCode == NO_ERROR) ? NULL : &nErrorCode;

    // attempt to register event sources
    if (lh = RegisterEventSource(NULL, TEXT("SNMP"))) {

        // report
        ReportEvent(
           lh,
           wEventType,
           0,                  // event category
           nMsgId,
           NULL,               // user sids
           (WORD)nSubStrings,
           cbData,
           ppSubStrings,
           lpData
           );

        // deregister event source
        DeregisterEventSource(lh);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\subagnts.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    subagnts.c

Abstract:

    Contains definitions for manipulating subagent structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "subagnts.h"
#include "regions.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindSubagent(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                 pPathname
    )

/*++

Routine Description:

    Locates subagent in list.

Arguments:

    ppSLE - pointer to receive pointer to entry.

    pPathname - pointer to pathname to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PSUBAGENT_LIST_ENTRY pSLE;

    // initialize
    *ppSLE = NULL;

    // obtain pointer to head
    pLE = g_Subagents.Flink;

    // process all entries in list
    while (pLE != &g_Subagents) {

        // retrieve pointer to trap destination structure
        pSLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);

        // compare pathname string with entry
        if (!strcmp(pSLE->pPathname, pPathname)) {

            // transfer
            *ppSLE = pSLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
AddSubagentRegion(
    PSUBAGENT_LIST_ENTRY  pSLE,
    AsnObjectIdentifier * pPrefixOid
    )

/*++

Routine Description:

    Adds subagent supported region to structure.

Arguments:

    pSLE - pointer to subagent structure.

    pPrefixOid - pointer to supported region.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMIB_REGION_LIST_ENTRY pRLE = NULL;

    // allocate region
    if (AllocRLE(&pRLE)) {

        // copy prefix to structure
        if (SnmpUtilOidCpy(&pRLE->PrefixOid, pPrefixOid) == 0)
        {
            FreeRLE(pRLE);
            return fOk;
        }

        // copy prefix as temporary limit
        if (SnmpUtilOidCpy(&pRLE->LimitOid, pPrefixOid) == 0)
        {
            FreeRLE(pRLE);
            return fOk;
        }

        // save pointer
        pRLE->pSLE = pSLE;

        // modify limit oid to be one past the prefix
        ++pRLE->LimitOid.ids[pRLE->LimitOid.idLength - 1];
        
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: %s supports %s.\n",
            pSLE->pPathname,
            SnmpUtilOidToA(&pRLE->PrefixOid)
            ));

        // attach to mib region to subagent structure
        InsertTailList(&pSLE->SupportedRegions, &pRLE->Link);

        // success
        fOk = TRUE;
    }

    return fOk;
}

BOOL
OfferInternalMgmtVariables(
    PSUBAGENT_LIST_ENTRY pSLE
    )
/*++

Routine Description:

    if the subagent is willing to monitor the SNMP service
    this function is offering it a pointer to the internal
    management variables

Arguments:

    pSLE - pointer to subagent structure.

Return Values:

    Returns true anyway.

--*/
{
    if (pSLE->pfnSnmpExtensionMonitor != NULL)
    {
       __try {

            // attempt to initialize agent
            (*pSLE->pfnSnmpExtensionMonitor)(&snmpMgmtBase);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: exception 0x%08lx offering internals to %s.\n",
                GetExceptionCode(),
                pSLE->pPathname
                ));

            // failure
            return FALSE;
        }
    }
    
    return TRUE;
}


BOOL
LoadSubagentRegions(
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Loads subagent supported regions.

Arguments:

    pSLE - pointer to subagent structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    HANDLE hSubagentTrapEvent = NULL;
    AsnObjectIdentifier PrefixOid = { 0, NULL };

    __try {

        // attempt to initialize agent
        if ((*pSLE->pfnSnmpExtensionInit)(
                        g_dwUpTimeReference,    
                        &hSubagentTrapEvent,
                        &PrefixOid
                        )) {

            // store subagent trap event handle
            pSLE->hSubagentTrapEvent = hSubagentTrapEvent;

            // add subagent region to list entry
            fOk = AddSubagentRegion(pSLE, &PrefixOid);

            // check to see if subagent supports additional regions
            if (fOk && (pSLE->pfnSnmpExtensionInitEx != NULL)) {    

                BOOL fMoreRegions = TRUE;

                // get other regions
                while (fOk && fMoreRegions) {
    
                    // retrieve next supported region
                    fMoreRegions = (*pSLE->pfnSnmpExtensionInitEx)(
                                                &PrefixOid
                                                );

                    // validate
                    if (fMoreRegions) {

                        // add subagent region to list entry
                        fOk = AddSubagentRegion(pSLE, &PrefixOid);
                    }
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx loading %s.\n",
            GetExceptionCode(),
            pSLE->pPathname
            ));

        // failure
        fOk = FALSE;
    }
    
    return fOk;
}


BOOL
LoadSubagent(
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Loads subagent dll and initializes.

Arguments:

    pSLE - pointer to subagent structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;    

    // attempt to load subagent library - we use the altered search path flag so that
    // the subagent can load DLLs that live in its directory
    pSLE->hSubagentDll = LoadLibraryExA(pSLE->pPathname, 0, LOAD_WITH_ALTERED_SEARCH_PATH);

    // validate handle
    if (pSLE->hSubagentDll != NULL) {

        // load primary initialization routine
        pSLE->pfnSnmpExtensionInit = (PFNSNMPEXTENSIONINIT)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_INIT
                );

        // load secondary initialization routine
        pSLE->pfnSnmpExtensionInitEx = (PFNSNMPEXTENSIONINITEX)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_INIT_EX
                );

                // load secondary initialization routine
        pSLE->pfnSnmpExtensionClose = (PFNSNMPEXTENSIONCLOSE)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_CLOSE
                );

        // load the extension monitor routine
        pSLE->pfnSnmpExtensionMonitor = (PFNSNMPEXTENSIONMONITOR)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_MONITOR
                );

        // load snmpv1-based subagent request routine
        pSLE->pfnSnmpExtensionQuery = (PFNSNMPEXTENSIONQUERY)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_QUERY
                );

        // load snmpv2-based subagent request routine
        pSLE->pfnSnmpExtensionQueryEx = (PFNSNMPEXTENSIONQUERYEX)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_QUERY_EX
                );

        // load snmpv1-based subagent trap routine
        pSLE->pfnSnmpExtensionTrap = (PFNSNMPEXTENSIONTRAP)
            GetProcAddress(
                pSLE->hSubagentDll,
                SNMP_EXTENSION_TRAP
                );

        // validate subagent agent entry points
        if ((pSLE->pfnSnmpExtensionInit != NULL) &&
           ((pSLE->pfnSnmpExtensionQuery != NULL) ||
            (pSLE->pfnSnmpExtensionQueryEx != NULL))) {

            // load supported regions
            if (fOk = LoadSubagentRegions(pSLE)) // !!intentional assignement!!
            {
                // offering internal management variables;
                fOk = OfferInternalMgmtVariables(pSLE);
            }
        }

    }
    else
    {
        DWORD errCode = GetLastError();
        LPTSTR pPathname;

#ifdef UNICODE
        SnmpUtilUTF8ToUnicode(&pPathname, pSLE->pPathname, TRUE);
#else
        pPathname = pSLE->pPathname;
#endif
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d loading subagent.\n",
            errCode
            ));

        ReportSnmpEvent(
            SNMP_EVENT_INVALID_EXTENSION_AGENT_DLL,
            1,
            &pPathname,
            errCode);

#ifdef UNICODE
        SnmpUtilMemFree(pPathname);
#endif
    }

    return fOk;
}


BOOL
AddSubagentByDll(
    LPSTR pPathname,
    UCHAR uchInitFlags
    )

/*++

Routine Description:

    Adds subagent to list.

Arguments:

    pPathname - pointer to subagent's dll path.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY pSLE = NULL;
    
    // attempt to locate in list    
    if (FindSubagent(&pSLE, pPathname)) {
                    
        SNMPDBG((
            SNMP_LOG_WARNING, 
            "SNMP: SVC: duplicate entry for %s.\n",
            pPathname
            ));
        
        // success
        fOk = TRUE;

    } else {

        // allocate subagent structure
        if (AllocSLE(&pSLE, pPathname, uchInitFlags)) {
                        
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: processing subagent %s.\n",
                pPathname
                ));

            // initialize subagent
            if (LoadSubagent(pSLE)) {

                // insert into valid communities list
                InsertTailList(&g_Subagents, &pSLE->Link);

                // success
                fOk = TRUE;
            } 
            
            // cleanup
            if (!fOk) {

                // release
                FreeSLE(pSLE);
            }
        }
    }

    return fOk;
}


BOOL
AddSubagentByKey(
    LPTSTR pKey
    )

/*++

Routine Description:

    Adds subagent to list.

Arguments:

    pKey - pointer to subagent's registry key path.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    CHAR szName[MAX_PATH];
    CHAR szValue[MAX_PATH];
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY pSLE = NULL;


    // open registry subkey    
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS) {
        
        // initialize
        dwIndex = 0;

        // initialize buffer sizes
        dwNameSize  = sizeof(szName)/sizeof(szName[0]); // size in TCHARs
        dwValueSize = sizeof(szValue);                  // size in bytes

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) {

            // read next value
            lStatus = RegEnumValueA(
                        hKey, 
                        dwIndex, 
                        szName, 
                        &dwNameSize,
                        NULL, 
                        &dwValueType, 
                        szValue, 
                        &dwValueSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                if (dwValueType == REG_EXPAND_SZ || dwValueType == REG_SZ) 
                {
            
                    // check to see if value is pathname
                    if (!_stricmp(szName, REG_VALUE_SUBAGENT_PATH)) {
    
                        DWORD dwRequired;
                        CHAR szExpanded[MAX_PATH];
                    
                        // expand environment strings in path
                        dwRequired = ExpandEnvironmentStringsA(
                                        szValue,
                                        szExpanded,
                                        sizeof(szExpanded)/sizeof(szExpanded[0])
                                        );

                        if ((dwRequired != 0) && 
                            (dwRequired <= sizeof(szExpanded)/sizeof(szExpanded[0]))
                           )
                        {

                            // load subagent library - no flags set
                            fOk = AddSubagentByDll(szExpanded, 0);
                        }
            
                        break; // bail...
                    }
                }

                // initialize buffer sizes
                dwNameSize  = sizeof(szName)/sizeof(szName[0]);
                dwValueSize = sizeof(szValue);

                // next
                dwIndex++;
            
            } else if (lStatus == ERROR_NO_MORE_ITEMS) {

                // failure
                fOk = FALSE; 
            }
        }

        // release handle
        RegCloseKey(hKey);
    }
    else
    {
        // the registry key for this subagent could not be located.
        ReportSnmpEvent(
            SNMP_EVENT_INVALID_EXTENSION_AGENT_KEY,
            1,
            &pKey,
            lStatus);
    }

    return fOk;    
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocSLE(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                  pPathname,
    UCHAR                  uchInitFlags
    )

/*++

Routine Description:

    Allocates trap destination structure and initializes.

Arguments:

    ppSLE - pointer to receive pointer to entry.

    pPathname - pointer to subgent's dll path.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY pSLE = NULL;

    // attempt to allocate structure
    pSLE = AgentMemAlloc(sizeof(SUBAGENT_LIST_ENTRY));

    // validate
    if (pSLE != NULL) {

        // allocate memory for trap destination string
        pSLE->pPathname = AgentMemAlloc(strlen(pPathname)+1);

        // validate
        if (pSLE->pPathname != NULL) {

            // transfer trap destination string
            strcpy(pSLE->pPathname, pPathname);

            // set the initial flags value
            pSLE->uchFlags = uchInitFlags;

            // initialize list of supported regions
            InitializeListHead(&pSLE->SupportedRegions);

            // success
            fOk = TRUE;
        } 

        // cleanup        
        if (!fOk) {

            // release 
            FreeSLE(pSLE);

            // re-init
            pSLE = NULL;            
        }
    }

    // transfer
    *ppSLE = pSLE;

    return fOk;
}


BOOL 
FreeSLE(
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Releases subagent structure.

Arguments:

    pSLE - pointer to list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pSLE != NULL) {

        SNMPDBG((  
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: unloading %s.\n",
            pSLE->pPathname
            ));

        // release manager structures
        UnloadRegions(&pSLE->SupportedRegions);

        // validate subagent dll handle    
        if (pSLE->hSubagentDll != NULL) {

            __try {
                if (pSLE->pfnSnmpExtensionClose != NULL)
                    (*pSLE->pfnSnmpExtensionClose)();


            } __except (EXCEPTION_EXECUTE_HANDLER) {
        
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: exception 0x%08lx unloading %s.\n",
                    GetExceptionCode(),
                    pSLE->pPathname
                    ));
                
            }

            // unload subagent
            FreeLibrary(pSLE->hSubagentDll);
            pSLE->hSubagentDll = NULL;
        }

        // release string
        AgentMemFree(pSLE->pPathname);

        // release structure
        AgentMemFree(pSLE);
    }

    return TRUE;
}


BOOL
LoadSubagents(
    )

/*++

Routine Description:

    Constructs list of subagents.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    TCHAR szName[MAX_PATH];
    TCHAR szValue[MAX_PATH];
    LPTSTR pszKey = REG_KEY_EXTENSION_AGENTS;
    BOOL fOk = FALSE;
        
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading subagents.\n"
        ));
    
    // Open the ..SNMP\Parameters\ExtensionAgents subkey   
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // initialize
        dwIndex = 0;

        // initialize buffer sizes
        dwNameSize  = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
        dwValueSize = sizeof(szValue); // size in number of bytes

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) {

            // read next value
            lStatus = RegEnumValue(
                        hKey, 
                        dwIndex, 
                        szName, 
                        &dwNameSize,
                        NULL, 
                        &dwValueType, 
                        (LPBYTE)szValue, 
                        &dwValueSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                if (dwValueType == REG_SZ)
                {

                    // add subagent to list 
                    AddSubagentByKey(szValue);
                }
                
                // re-initialize buffer sizes
                dwNameSize  = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
                dwValueSize = sizeof(szValue); // size in number of bytes

                // next
                dwIndex++;

            } else if (lStatus == ERROR_NO_MORE_ITEMS) {

                // success
                fOk = TRUE; 
            }
        }
    } 
    
    if (!fOk) {
        
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing Subagents subkey.\n",
            lStatus
            ));
        
        // report event
        ReportSnmpEvent(
            SNMP_EVENT_INVALID_REGISTRY_KEY, 
            1, 
            &pszKey, 
            lStatus
            );
    }

    return fOk;
}


BOOL
UnloadSubagents(
    )

/*++

Routine Description:

    Destroys list of subagents.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PSUBAGENT_LIST_ENTRY pSLE;

    // process entries until list is empty
    while (!IsListEmpty(&g_Subagents)) {

        // extract next entry from head of list
        pLE = RemoveHeadList(&g_Subagents);

        // retrieve pointer to community structure
        pSLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);
 
        // release
        FreeSLE(pSLE);
    }

    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\trapmgrs.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapmgrs.c

Abstract:

    Contains routines for manipulating trap destination structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "snmpmgrs.h"
#include "trapmgrs.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindTrapDestination(
    PTRAP_DESTINATION_LIST_ENTRY * ppTLE,
    LPSTR                          pCommunity
    )

/*++

Routine Description:

    Locates valid trap destination in list.

Arguments:

    ppTLE - pointer to receive pointer to entry.

    pCommunity - pointer to trap destination to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE;

    // initialize
    *ppTLE = NULL;

    // obtain pointer to list head
    pLE = g_TrapDestinations.Flink;

    // process all entries in list
    while (pLE != &g_TrapDestinations) {

        // retrieve pointer to trap destination structure
        pTLE = CONTAINING_RECORD(pLE, TRAP_DESTINATION_LIST_ENTRY, Link);

        // compare trap destination string with entry
        if (!strcmp(pTLE->pCommunity, pCommunity)) {

            // transfer
            *ppTLE = pTLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
AddTrapDestination(
    HKEY   hKey,
    LPWSTR pwCommunity
    )

/*++

Routine Description:

    Adds trap destination to list.

Arguments:

    hKey - trap destination subkey.

    pwCommunity - pointer to trap destination to add.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hSubKey;
    LONG lStatus;
    BOOL fOk = FALSE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE = NULL;
    LPSTR pCommunity = NULL;

    // open registry subkey    
    lStatus = RegOpenKeyExW(
                hKey,
                pwCommunity,
                0,
                KEY_READ,
                &hSubKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS &&
        SnmpUtilUnicodeToUTF8(
            &pCommunity,
            pwCommunity,
            TRUE) == 0) {

        // attempt to locate in list    
        if (FindTrapDestination(&pTLE, pCommunity)) {
                            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: updating trap destinations for %s.\n",
                pCommunity
                ));
            
            // load associated managers
            LoadManagers(hSubKey, &pTLE->Managers);

            // success
            fOk = TRUE;

        } else {

            // allocate trap destination structure
            if (AllocTLE(&pTLE, pCommunity)) {
                                
                SNMPDBG((
                    SNMP_LOG_TRACE, 
                    "SNMP: SVC: adding trap destinations for %s.\n",
                    pCommunity
                    ));

                // load associated managers
                if (LoadManagers(hSubKey, &pTLE->Managers)) {

                    // insert into valid communities list
                    InsertTailList(&g_TrapDestinations, &pTLE->Link);

                    // success
                    fOk = TRUE;
                }

                // cleanup
                if (!fOk) {

                    // release
                    FreeTLE(pTLE);
                }
            }
        }

        // release subkey
        RegCloseKey(hSubKey);

        SnmpUtilMemFree(pCommunity);
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocTLE(
    PTRAP_DESTINATION_LIST_ENTRY * ppTLE,
    LPSTR                          pCommunity 
    )

/*++

Routine Description:

    Allocates trap destination structure and initializes.

Arguments:

    ppTLE - pointer to receive pointer to entry.

    pCommunity - pointer to trap destination string.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE = NULL;

    // attempt to allocate structure
    pTLE = AgentMemAlloc(sizeof(TRAP_DESTINATION_LIST_ENTRY));

    // validate
    if (pTLE != NULL) {

        // allocate memory for trap destination string
        pTLE->pCommunity = AgentMemAlloc(strlen(pCommunity)+1);

        // validate
        if (pTLE->pCommunity != NULL) {

            // transfer trap destination string
            strcpy(pTLE->pCommunity, pCommunity);

            // initialize list of managers
            InitializeListHead(&pTLE->Managers);

            // success
            fOk = TRUE;
        } 

        // cleanup        
        if (!fOk) {

            // release 
            FreeTLE(pTLE);

            // re-init
            pTLE = NULL;            
        }
    }

    // transfer
    *ppTLE = pTLE;

    return fOk;
}


BOOL 
FreeTLE(
    PTRAP_DESTINATION_LIST_ENTRY pTLE
    )

/*++

Routine Description:

    Releases trap destination structure.

Arguments:

    pTLE - pointer to trap destination list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pTLE != NULL) {

        // release manager structures
        UnloadManagers(&pTLE->Managers);

        // release string
        AgentMemFree(pTLE->pCommunity);

        // release structure
        AgentMemFree(pTLE);
    }

    return TRUE;
}


BOOL
LoadTrapDestinations(
    BOOL bFirstCall
    )

/*++

Routine Description:

    Constructs list of trap destinations.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    WCHAR wszName[MAX_PATH+1];
    BOOL  fPolicy;
    LPTSTR pszKey;
    BOOL fOk = FALSE;
        
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading trap destinations.\n"
        ));

#ifdef _POLICY
    // we need to provide precedence to the parameters set through the policy
    fPolicy = TRUE;
#else
    fPolicy = FALSE;
#endif

    do
    {
        // if the policy is to be enforced, check the policy registry location first
        pszKey = fPolicy ? REG_POLICY_TRAP_DESTINATIONS : REG_KEY_TRAP_DESTINATIONS;

        // open registry subkey    
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    pszKey,
                    0,
                    KEY_READ,
                    &hKey
                    );
        // if the call succeeded or we were not checking the policy, break the loop
        if (lStatus == ERROR_SUCCESS || !fPolicy)
            break;

        // being at this point, this means we were checking for the policy parameters.
        // If and only if the policy is not defined (registry key is missing) we
        // reset the error, mark 'fPolicy already tried' and go back into the loop
        if (lStatus == ERROR_FILE_NOT_FOUND)
        {
            lStatus = ERROR_SUCCESS;
            fPolicy = FALSE;
        }
    } while (lStatus == ERROR_SUCCESS);

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // initialize
        dwIndex = 0;

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) {

            // read next value
            lStatus = RegEnumKeyW(
                        hKey, 
                        dwIndex, 
                        wszName, 
                        sizeof(wszName) / sizeof(wszName[0])
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                // add trap destination to list 
                if (AddTrapDestination(hKey, wszName)) {

                    // next
                    dwIndex++;

                } else {

                    // reset status to reflect failure
                    lStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            
            } else if (lStatus == ERROR_NO_MORE_ITEMS) {

                // success
                fOk = TRUE; 
            }
        }
        RegCloseKey(hKey);
    }
    else
        // it doesn't matter how the values are, the key has to exist,
        // so mark as bFirstCall in order to log an event if this is not true.
        bFirstCall = TRUE;    
    
    if (!fOk) {
        
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing TrapDestinations subkey.\n",
            lStatus
            ));

        // log an event only if on first call (service initialization)
        // otherwise, due to registry operations through regedit, the event log
        // might get flooded with records
        if (bFirstCall)
            // report event
            ReportSnmpEvent(
                SNMP_EVENT_INVALID_REGISTRY_KEY, 
                1, 
                &pszKey, 
                lStatus
                );
    }

    return fOk;
}


BOOL
UnloadTrapDestinations(
    )

/*++

Routine Description:

    Destroys list of trap destinations.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE;

    // process entries until list is empty
    while (!IsListEmpty(&g_TrapDestinations)) {

        // extract next entry from head of list
        pLE = RemoveHeadList(&g_TrapDestinations);

        // retrieve pointer to trap destination structure
        pTLE = CONTAINING_RECORD(pLE, TRAP_DESTINATION_LIST_ENTRY, Link);
 
        // release
        FreeTLE(pTLE);
    }

    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\trapthrd.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapthrd.c

Abstract:

    Contains routines for trap processing thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "trapthrd.h"
#include "subagnts.h"
#include "trapmgrs.h"
#include "snmpmgrs.h"
#include "network.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static SnmpVarBindList g_NullVbl = { NULL, 0 };


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadWaitObjects(
    DWORD * pnWaitObjects,
    PHANDLE * ppWaitObjects,
    PSUBAGENT_LIST_ENTRY ** pppNLEs
    )

/*++

Routine Description:

    Loads arrays with necessary wait object information.

Arguments:

    pnWaitObjects - pointer to receive count of wait objects.

    ppWaitObjects - pointer to receive wait object handles.

    pppNLEs - pointer to receive array of associated subagents pointers.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PSUBAGENT_LIST_ENTRY pNLE;
    PSUBAGENT_LIST_ENTRY * ppNLEs = NULL;
    PHANDLE pWaitObjects = NULL;
    DWORD nWaitObjects = 2;
    BOOL fOk = FALSE;

    EnterCriticalSection(&g_RegCriticalSectionB);
    
    // point to first subagent
    pLE = g_Subagents.Flink;

    // process each subagent
    while (pLE != &g_Subagents) {

        // retreive pointer to subagent list entry from link
        pNLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);

        // check for subagent trap event
        if (pNLE->hSubagentTrapEvent != NULL) {
        
            // increment        
            nWaitObjects++;
        }            

        // next entry
        pLE = pLE->Flink;
    }
    
    // attempt to allocate array of subagent pointers
    ppNLEs = AgentMemAlloc(nWaitObjects * sizeof(PSUBAGENT_LIST_ENTRY));
        
    // validate pointers
    if (ppNLEs != NULL) {

        // attempt to allocate array of event handles
        pWaitObjects = AgentMemAlloc(nWaitObjects * sizeof(HANDLE));

        // validate pointer
        if (pWaitObjects != NULL) {

            // success
            fOk = TRUE;

        } else {
                
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not allocate handle array.\n"
                ));

            // release array
            AgentMemFree(ppNLEs);
    
            // re-init
            ppNLEs = NULL;
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate subagent pointers.\n"
            ));
    }
    
    if (fOk) {
    
        // initialize
        DWORD dwIndex = 0;

        // point to first subagent
        pLE = g_Subagents.Flink;

        // process each subagent and check for overflow
        while ((pLE != &g_Subagents) && (dwIndex < nWaitObjects - 2)) {

            // retreive pointer to subagent list entry from link
            pNLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);

            // check for subagent trap event
            if (pNLE->hSubagentTrapEvent != NULL) {
            
                // copy subagent trap event handle
                pWaitObjects[dwIndex] = pNLE->hSubagentTrapEvent;

                // copy subagent pointer
                ppNLEs[dwIndex] = pNLE;

                // next
                dwIndex++;
            }            

            // next entry
            pLE = pLE->Flink;
        }

        // copy registry update event into second last entry
        pWaitObjects[dwIndex++] = g_hRegistryEvent;

        // copy termination event into last entry
        pWaitObjects[dwIndex++] = g_hTerminationEvent;

        // validate number of items
        if (dwIndex != nWaitObjects) {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: updating number of events from %d to %d.\n",
                nWaitObjects,
                dwIndex
                ));

            // use latest number
            nWaitObjects = dwIndex;
        }
    }

    // transfer wait object information 
    *pnWaitObjects = fOk ? nWaitObjects : 0;
    *ppWaitObjects = pWaitObjects;
    *pppNLEs = ppNLEs;

    LeaveCriticalSection(&g_RegCriticalSectionB);

    return fOk;
}


BOOL
UnloadWaitObjects(
    PHANDLE pWaitObjects,
    PSUBAGENT_LIST_ENTRY * ppNLEs
    )

/*++

Routine Description:

    Loads arrays with necessary wait object information.

Arguments:

    pWaitObjects - pointer to wait object handles.

    ppNLEs - pointer to array of associated subagents pointers.

Return Values:

    Returns true if successful.

--*/

{
    // release array
    AgentMemFree(pWaitObjects);

    // release array
    AgentMemFree(ppNLEs);
    
    return TRUE;
}


BOOL
GenerateExtensionTrap(
    AsnObjectIdentifier * pEnterpriseOid,
    AsnInteger32          nGenericTrap,
    AsnInteger32          nSpecificTrap,
    AsnTimeticks          nTimeStamp,
    SnmpVarBindList *     pVbl
    )

/*

Routine Description:

    Generates trap for subagent.

Arguments:

    pEnterpriseOid - pointer to EnterpriseOid OID.

    nGenericTrap - generic trap identifier.

    nSpecificTrap - EnterpriseOid specific trap identifier.

    nTimeStamp - timestamp to include in trap.

    pVbl - pointer to optional variables.

Return Values:

    Returns true if successful.

*/

{
    SNMP_PDU Pdu;
    BOOL fOk = FALSE;

    // note this is in older format
    Pdu.nType = SNMP_PDU_V1TRAP;

    // validate pointer 
    if (pVbl != NULL) {

        // copy varbinds 
        Pdu.Vbl = *pVbl;

    } else {

        // initialize
        Pdu.Vbl.len = 0;
        Pdu.Vbl.list = NULL;
    }

    // validate enterprise oid
    if ((pEnterpriseOid != NULL) &&
        (pEnterpriseOid->ids != NULL) &&
        (pEnterpriseOid->idLength != 0)) {

        // transfer specified enterprise oid
        Pdu.Pdu.TrapPdu.EnterpriseOid = *pEnterpriseOid;

    } else {

        // transfer microsoft enterprise oid 
        // Note: transfer the AsnObjectIdentifier structure as a whole, but no new memory is allocated
        // for the 'ids' buffer. Hence, Pdu....EnterpriseOid should not be 'SnmpUtilFreeOid'!!
        Pdu.Pdu.TrapPdu.EnterpriseOid = snmpMgmtBase.AsnObjectIDs[OsnmpSysObjectID].asnValue.object;
    }    

    // make sure that the system uptime is consistent by overriding
    Pdu.Pdu.TrapPdu.nTimeticks = nTimeStamp ? SnmpSvcGetUptime() : 0;

    // transfer the remaining parameters 
    Pdu.Pdu.TrapPdu.nGenericTrap  = nGenericTrap;
    Pdu.Pdu.TrapPdu.nSpecificTrap = nSpecificTrap;

    // initialize agent address structure
    Pdu.Pdu.TrapPdu.AgentAddr.dynamic = FALSE;
    Pdu.Pdu.TrapPdu.AgentAddr.stream  = NULL;
    Pdu.Pdu.TrapPdu.AgentAddr.length  = 0;

    // send trap to managers
    return GenerateTrap(&Pdu);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessSubagentEvents(
    )

/*++

Routine Description:

    Processes subagent trap events.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PSUBAGENT_LIST_ENTRY * ppNLEs = NULL;
    PHANDLE pWaitObjects = NULL;
    DWORD nWaitObjects = 0;
    DWORD dwIndex;

    // attempt to load waitable objects into array
    if (LoadWaitObjects(&nWaitObjects, &pWaitObjects, &ppNLEs)) {

        // loop
        for (;;) {

            // subagent event or termination 
            dwIndex = WaitForMultipleObjects(
                            nWaitObjects,
                            pWaitObjects,
                            FALSE,
                            INFINITE
                            );

            // check for process termination event first 
            // note: g_hTerminationEvent is a manual reset event
            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hTerminationEvent, 0)) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: shutting down trap thread.\n"
                    ));
                
                break; // bail...

            // check for registry update event next
            } else if (dwIndex == (WAIT_OBJECT_0 + nWaitObjects - 2)) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: recalling LoadWaitObjects.\n"
                    ));
                
                if (!LoadWaitObjects(&nWaitObjects, &pWaitObjects, &ppNLEs))
                    break;

            // check for subagent trap notification event
            } else if (dwIndex < (WAIT_OBJECT_0 + nWaitObjects - 2)) {

                AsnObjectIdentifier EnterpriseOid;
                AsnInteger          nGenericTrap;
                AsnInteger          nSpecificTrap;
                AsnInteger          nTimeStamp;
                SnmpVarBindList     Vbl;

                PFNSNMPEXTENSIONTRAP pfnSnmpExtensionTrap;

                // retrieve pointer to subagent trap entry point
                pfnSnmpExtensionTrap = ppNLEs[dwIndex]->pfnSnmpExtensionTrap;
                                
                // validate function pointer                    
                if (pfnSnmpExtensionTrap != NULL) {            

                    __try {

                        // loop until false is returned
                        while ((*pfnSnmpExtensionTrap)(
                                    &EnterpriseOid,
                                    &nGenericTrap,
                                    &nSpecificTrap,
                                    &nTimeStamp,
                                    &Vbl)) {
                                    
                            // send extension trap                                
                            GenerateExtensionTrap(
                                &EnterpriseOid,
                                nGenericTrap,
                                nSpecificTrap,
                                nTimeStamp,
                                &Vbl
                                );

                            SnmpUtilVarBindListFree(&Vbl);
                            
                            // check for process termination event while we are in this while loop 
                            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hTerminationEvent, 0)) 
                            {
                
                                SNMPDBG((
                                    SNMP_LOG_TRACE,
                                    "SNMP: SVC: shutting down trap thread in \"while((*pfnSnmpExtensionTrap)\" loop.\n"
                                    ));
                
                                break; // bail...
                            }
                        }
                    
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: exception 0x%08lx polling %s.\n",
                            GetExceptionCode(),
                            ppNLEs[dwIndex]->pPathname
                            ));
                    }
                }
            }            
        }
    
        // release memory for wait objects
        UnloadWaitObjects(pWaitObjects, ppNLEs);
    }

    return fOk;
}


BOOL
GenerateTrap(
    PSNMP_PDU pPdu
    )

/*

Routine Description:

    Generates trap for agent.

Arguments:

    pPdu - pointer to initialized TRAP or TRAPv1 PDU.

Return Values:

    Returns true if successful.

*/

{
    BOOL fOk = TRUE;
    PLIST_ENTRY pLE1;
    PLIST_ENTRY pLE2;
    PLIST_ENTRY pLE3;
    PNETWORK_LIST_ENTRY pNLE;
    PMANAGER_LIST_ENTRY pMLE;
    PTRAP_DESTINATION_LIST_ENTRY pTLE;
    AsnOctetString CommunityOctets;
    DWORD dwStatus;
    DWORD dwIPAddr;

    EnterCriticalSection(&g_RegCriticalSectionC);
    // obtain first trap destination
    pLE1 = g_TrapDestinations.Flink;

    // process each trap destination
    while (pLE1 != &g_TrapDestinations) {

        // retrieve pointer to outgoing transport structure
        pTLE = CONTAINING_RECORD(pLE1, TRAP_DESTINATION_LIST_ENTRY, Link);

        // copy community string into octet structure
        CommunityOctets.length  = strlen(pTLE->pCommunity);
        CommunityOctets.stream  = pTLE->pCommunity;
        CommunityOctets.dynamic = FALSE;

        // obtain first manager
        pLE2 = pTLE->Managers.Flink;

        // process each receiving manager
        while (pLE2 != &pTLE->Managers) {

            // retrieve pointer to next manager
            pMLE = CONTAINING_RECORD(pLE2, MANAGER_LIST_ENTRY, Link);
            
            // refresh addr 
            UpdateMLE(pMLE);

            // don't send traps to addresses that are DEAD or NULL
            if (pMLE->dwAge == MGRADDR_DEAD || 
                !IsValidSockAddr(&pMLE->SockAddr))
            {
                pLE2 = pLE2->Flink;
                continue;
            }
        
            // obtain first outgoing transport
            pLE3 = g_OutgoingTransports.Flink;

            // process each outgoing transport
            while (pLE3 != &g_OutgoingTransports) {

                // retrieve pointer to outgoing transport structure
                pNLE = CONTAINING_RECORD(pLE3, NETWORK_LIST_ENTRY, Link);

                // initialize buffer length
                pNLE->Buffer.len = NLEBUFLEN;

                // can only send on same protocol
                if (pNLE->SockAddr.sa_family != pMLE->SockAddr.sa_family)
                {
                    pLE3 = pLE3->Flink;
                    continue;
                }

                // modify agent address
                if (pNLE->SockAddr.sa_family == AF_INET) 
                {

                    struct sockaddr_in * pSockAddrIn;
                    DWORD                szSockToBind;

                    // see if the trap destination address is valid and if the
                    // card to use for sending the trap could be determined
                    if (WSAIoctl(pNLE->Socket,
                             SIO_ROUTING_INTERFACE_QUERY,
                             &pMLE->SockAddr,
                             sizeof(pMLE->SockAddr),
                             &pNLE->SockAddr,
                             sizeof(pNLE->SockAddr),
                             &szSockToBind,
                             NULL,
                             NULL) == SOCKET_ERROR)
                    {
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: cannot determine interface to use for trap destination %s [err=%d].\n",
                            inet_ntoa(((struct sockaddr_in *)&pMLE->SockAddr)->sin_addr),
                            WSAGetLastError()
                            ));
                        // if we can't determine on what interface the trap will be sent from, just bail.
                        pLE3 = pLE3->Flink;
                        continue;
                    }
                    
                    // obtain pointer to protocol specific structure
                    pSockAddrIn = (struct sockaddr_in * )&pNLE->SockAddr;

                    // copy agent address into temp buffer
                    dwIPAddr = pSockAddrIn->sin_addr.s_addr;

                    // initialize agent address structure
                    pPdu->Pdu.TrapPdu.AgentAddr.dynamic = FALSE;
                    pPdu->Pdu.TrapPdu.AgentAddr.stream  = (LPBYTE)&dwIPAddr;
                    pPdu->Pdu.TrapPdu.AgentAddr.length  = sizeof(dwIPAddr);

                } else {

                    // re-initialize agent address structure
                    pPdu->Pdu.TrapPdu.AgentAddr.dynamic = FALSE;
                    pPdu->Pdu.TrapPdu.AgentAddr.stream  = NULL;
                    pPdu->Pdu.TrapPdu.AgentAddr.length  = 0;
                }

                // build message
                if (BuildMessage(
                        SNMP_VERSION_1,
                        &CommunityOctets,
                        pPdu,
                        pNLE->Buffer.buf,
                        &pNLE->Buffer.len
                        )) {
                                
                    // synchronous send
                    dwStatus = WSASendTo(
                                  pNLE->Socket,
                                  &pNLE->Buffer,
                                  1,
                                  &pNLE->dwBytesTransferred,
                                  pNLE->dwFlags,
                                  &pMLE->SockAddr,
                                  pMLE->SockAddrLen,
                                  NULL,
                                  NULL
                                  );
                            
                    // register outgoing packet into the management structure
                    mgmtCTick(CsnmpOutPkts);
                    // retister outgoing trap into the management structure
                    mgmtCTick(CsnmpOutTraps);

                    // validate return code
                    if (dwStatus == SOCKET_ERROR) {
                        
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: error code %d on sending trap to %s.\n",
                            WSAGetLastError(),
                            pTLE->pCommunity
                            ));
                    }
                }    

                // next entry
                pLE3 = pLE3->Flink;
            }

            // next entry
            pLE2 = pLE2->Flink;
        }

        // next entry
        pLE1 = pLE1->Flink;                
    }
    LeaveCriticalSection(&g_RegCriticalSectionC);

    return fOk;
}


BOOL
GenerateColdStartTrap(
    )

/*

Routine Description:

    Generates cold start trap.

Arguments:

    None.

Return Values:

    Returns true if successful.

*/

{
    // generate cold start
    return GenerateExtensionTrap(
                NULL,   // pEnterpriseOid
                SNMP_GENERICTRAP_COLDSTART,
                0,      // nSpecificTrapId
                0,      // nTimeStamp
                &g_NullVbl
                );    
}


BOOL
GenerateAuthenticationTrap(
    )

/*

Routine Description:

    Generates authentication trap.

Arguments:

    None.

Return Values:

    Returns true if successful.

*/

{
    // generate cold start
    return GenerateExtensionTrap(
                NULL,   // pEnterpriseOid
                SNMP_GENERICTRAP_AUTHFAILURE,
                0,      // nSpecificTrapId
                SnmpSvcGetUptime(),
                &g_NullVbl
                );    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\mem.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Contains memory allocation routines for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _MEM_H_
#define _MEM_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AgentHeapCreate(
    );

BOOL
AgentHeapDestroy(
    );

LPVOID
AgentMemAlloc(
    UINT nBytes
    );

VOID
AgentMemFree(
    LPVOID pMem
    );

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\args.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    args.h

Abstract:

    Contains definitions for processing command line arguments.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _ARGS_H_
#define _ARGS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _CMD_LINE_ARGUMENTS {

    UINT nLogType;
    UINT nLogLevel;
    BOOL fBypassCtrlDispatcher;

} CMD_LINE_ARGUMENTS, *PCMD_LINE_ARGUMENTS;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessArguments(
    DWORD  NumberOfArgs,
    LPSTR ArgumentPtrs[]
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFINE_ARGUMENT(x) \
    (x ## _ARGUMENT)

#define IS_ARGUMENT(x,y) \
    (!_strnicmp(((LPSTR)(x)),DEFINE_ARGUMENT(y),strlen(DEFINE_ARGUMENT(y))))

#define DWORD_ARGUMENT(x,y) \
    (atoi(&((LPSTR)(x))[strlen(DEFINE_ARGUMENT(y))]))

#define DEBUG_ARGUMENT      "/debug"
#define LOGTYPE_ARGUMENT    "/logtype:"
#define LOGLEVEL_ARGUMENT   "/loglevel:"

#define INVALID_ARGUMENT    0xffffffff

#endif // _ARGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\contexts.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    contexts.h

Abstract:

    Contains definitions for manipulating SNMP community structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _CONTEXTS_H_
#define _CONTEXTS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _COMMUNITY_LIST_ENTRY {

    LIST_ENTRY     Link;
    DWORD          dwAccess;     
    AsnOctetString Community;

} COMMUNITY_LIST_ENTRY, *PCOMMUNITY_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocCLE(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    LPWSTR                  pCommunity
    );

BOOL 
FreeCLE(
    PCOMMUNITY_LIST_ENTRY pCLE
    );

BOOL
FindValidCommunity(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    AsnOctetString *        pCommunity
    );

BOOL
LoadValidCommunities(
    BOOL    bFirstCall
    );

BOOL
UnloadValidCommunities(
    );

#endif // _CONTEXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\globals.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Contains global definitions for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _GLOBALS_H_
#define _GLOBALS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <windef.h>
#include <winsvc.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <wsipx.h>
#include <snmputil.h>
#include <limits.h> // for UINT_MAX
#include "snmpevts.h"
#include "args.h"
#include "mem.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#define SHUTDOWN_WAIT_HINT 5000


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD  g_dwUpTimeReference;
extern HANDLE g_hTerminationEvent;
extern HANDLE g_hRegistryEvent;

extern HANDLE g_hDefaultRegNotifier;
extern HKEY   g_hDefaultKey;
extern HANDLE g_hPolicyRegNotifier;
extern HKEY   g_hPolicyKey;

extern LIST_ENTRY g_Subagents;
extern LIST_ENTRY g_SupportedRegions;
extern LIST_ENTRY g_ValidCommunities;
extern LIST_ENTRY g_TrapDestinations;
extern LIST_ENTRY g_PermittedManagers;
extern LIST_ENTRY g_IncomingTransports;
extern LIST_ENTRY g_OutgoingTransports;

extern CRITICAL_SECTION g_RegCriticalSectionA;
extern CRITICAL_SECTION g_RegCriticalSectionB;
extern CRITICAL_SECTION g_RegCriticalSectionC;

extern CMD_LINE_ARGUMENTS g_CmdLineArguments;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Registry definitions                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#define REG_POLICY_ROOT               \
    TEXT("SOFTWARE\\Policies")

#define REG_POLICY_PARAMETERS         \
    TEXT("SOFTWARE\\Policies\\SNMP\\Parameters")

#define REG_POLICY_VALID_COMMUNITIES  \
    REG_POLICY_PARAMETERS TEXT("\\ValidCommunities")

#define REG_POLICY_TRAP_DESTINATIONS  \
    REG_POLICY_PARAMETERS TEXT("\\TrapConfiguration")

#define REG_POLICY_PERMITTED_MANAGERS \
    REG_POLICY_PARAMETERS TEXT("\\PermittedManagers")

#define REG_KEY_SNMP_PARAMETERS     \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters")

#define REG_KEY_EXTENSION_AGENTS    \
    REG_KEY_SNMP_PARAMETERS TEXT("\\ExtensionAgents")

#define REG_KEY_VALID_COMMUNITIES   \
    REG_KEY_SNMP_PARAMETERS TEXT("\\ValidCommunities")

#define REG_KEY_TRAP_DESTINATIONS   \
    REG_KEY_SNMP_PARAMETERS TEXT("\\TrapConfiguration")

#define REG_KEY_PERMITTED_MANAGERS  \
    REG_KEY_SNMP_PARAMETERS TEXT("\\PermittedManagers")

#define REG_KEY_MIB2 \
    REG_KEY_SNMP_PARAMETERS TEXT("\\RFC1156Agent")


#define REG_VALUE_SUBAGENT_PATH     "Pathname"
#define REG_VALUE_AUTH_TRAPS        TEXT("EnableAuthenticationTraps")
#define REG_VALUE_MGRRES_COUNTER    TEXT("NameResolutionRetries")
#define REG_VALUE_SYS_OBJECTID      TEXT("sysObjectID")

#define MAX_VALUE_NAME_LEN          256
#define MAX_VALUE_DATA_LEN          256


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define PDUTYPESTRING(nPduType) \
            ((nPduType == SNMP_PDU_GETNEXT) \
                ? "getnext" \
                : (nPduType == SNMP_PDU_GETBULK) \
                    ? "getbulk" \
                    : (nPduType == SNMP_PDU_GET) \
                        ? "get" \
                        : (nPduType == SNMP_PDU_SET) \
                            ? "set" \
                            : "unknown")

#define SNMPERRORSTRING(nErr) \
            ((nErr == SNMP_ERRORSTATUS_NOERROR) \
              ? "NOERROR" \
              : (nErr == SNMP_ERRORSTATUS_GENERR) \
               ? "GENERR" \
               : (nErr == SNMP_ERRORSTATUS_NOSUCHNAME) \
                ? "NOSUCHNAME" \
                : (nErr == SNMP_ERRORSTATUS_NOTWRITABLE) \
                 ? "NOTWRITABLE" \
                 : (nErr == SNMP_ERRORSTATUS_TOOBIG) \
                  ? "TOOBIG" \
                  : (nErr == SNMP_ERRORSTATUS_BADVALUE) \
                   ? "BADVALUE" \
                   : (nErr == SNMP_ERRORSTATUS_READONLY) \
                    ? "READONLY" \
                    : (nErr == SNMP_ERRORSTATUS_WRONGTYPE) \
                     ? "WRONGTYPE" \
                     : (nErr == SNMP_ERRORSTATUS_WRONGLENGTH) \
                      ? "WRONGLENGTH" \
                      : (nErr == SNMP_ERRORSTATUS_WRONGENCODING) \
                       ? "WRONGENCODING" \
                       : (nErr == SNMP_ERRORSTATUS_WRONGVALUE) \
                        ? "WRONGVALUE" \
                        : (nErr == SNMP_ERRORSTATUS_NOCREATION) \
                         ? "NOCREATION" \
                         : (nErr == SNMP_ERRORSTATUS_INCONSISTENTVALUE) \
                          ? "INCONSISTENTVALUE" \
                          : (nErr == SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE) \
                           ? "RESOURCEUNAVAILABLE" \
                           : (nErr == SNMP_ERRORSTATUS_COMMITFAILED) \
                            ? "COMMITFAILED" \
                            : (nErr == SNMP_ERRORSTATUS_UNDOFAILED) \
                             ? "UNDOFAILED" \
                             : (nErr == SNMP_ERRORSTATUS_AUTHORIZATIONERROR) \
                              ? "AUTHORIZATIONERROR" \
                              : (nErr == SNMP_ERRORSTATUS_NOACCESS) \
                               ? "NOACCESS" \
                               : (nErr == SNMP_ERRORSTATUS_INCONSISTENTNAME) \
                                ? "INCONSISTENTNAME" \
                                : "unknown")
 
 



























































































#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\network.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    network.h

Abstract:

    Contains definitions for manipulating transport structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _NETWORK_H_
#define _NETWORK_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions for snmppdus                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _NORMAL_PDU {

    AsnInteger32 nRequestId;
    AsnInteger32 nErrorStatus;
    AsnInteger32 nErrorIndex;

} NORMAL_PDU, *PNORMAL_PDU;

typedef struct _BULK_PDU {

    AsnInteger32 nRequestId;
    AsnInteger32 nErrorStatus;
    AsnInteger32 nErrorIndex;
    AsnInteger32 nNonRepeaters;
    AsnInteger32 nMaxRepetitions;

} BULK_PDU, *PBULK_PDU;

typedef struct _TRAP_PDU {

    AsnObjectIdentifier EnterpriseOid;
    AsnIPAddress        AgentAddr;
    AsnInteger32        nGenericTrap;
    AsnInteger32        nSpecificTrap;
    AsnTimeticks        nTimeticks;

} TRAP_PDU, *PTRAP_PDU;

typedef struct _SNMP_PDU {

    UINT            nType;
    SnmpVarBindList Vbl;
    union {
        TRAP_PDU   TrapPdu;
        BULK_PDU   BulkPdu;
        NORMAL_PDU NormPdu;
    } Pdu;

} SNMP_PDU, *PSNMP_PDU;

#define SNMP_VERSION_1  0
#define SNMP_VERSION_2C 1


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions for network                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _NETWORK_LIST_ENTRY {

    LIST_ENTRY      Link;
    SOCKET          Socket;
    struct sockaddr SockAddr;
    INT             SockAddrLen;
    INT             SockAddrLenUsed;
    WSAOVERLAPPED   Overlapped;
    DWORD           dwStatus;
    DWORD           dwBytesTransferred;
    DWORD           dwFlags;
    WSABUF          Buffer;
    LIST_ENTRY      Bindings;
    LIST_ENTRY      Queries;
    SNMP_PDU        Pdu;
    UINT            nVersion;
    UINT            nTransactionId;
    BOOL            fAccessOk;          // authentication succeeds or fails
    AsnOctetString  Community;

} NETWORK_LIST_ENTRY, *PNETWORK_LIST_ENTRY;

#define NLEBUFLEN   65535


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes for snmppdus                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
BuildMessage(
    AsnInteger32      nVersion,
    AsnOctetString *  pCommunity,
    PSNMP_PDU         pPdu,
    PBYTE             pMessage,
    PDWORD            pMessageSize
    );

BOOL
ParseMessage(
	PNETWORK_LIST_ENTRY pNLE
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes for network                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
IsValidSockAddr(
    struct sockaddr *pAddress
    );

BOOL
AllocNLE(
    PNETWORK_LIST_ENTRY * ppNLE
    );

BOOL 
FreeNLE(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
LoadIncomingTransports(
    );

BOOL
UnloadTransport(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
UnloadIncomingTransports(
    );

BOOL
LoadOutgoingTransports(
    );

BOOL
UnloadOutgoingTransports(
    );

BOOL
UnloadPdu(
    PNETWORK_LIST_ENTRY pNLE
    );

#endif // _NETWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\exe\varbinds.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    varbinds.c

Abstract:

    Contains routines for manipulating varbinds.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "varbinds.h"
#include "query.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadVarBind(
    PNETWORK_LIST_ENTRY pNLE,
    UINT                iVb
    )

/*++

Routine Description:

    Creates varbind list entry from varbind structure.

Arguments:

    pNLE - pointer to network list entry.

    iVb - index of variable binding.

Return Values:

    Returns true if successful.

--*/

{
    SnmpVarBind * pVb;
    PVARBIND_LIST_ENTRY pVLE = NULL;
    PMIB_REGION_LIST_ENTRY pRLE = NULL;
    BOOL fAnyOk;
    BOOL fOk;

    // allocate list entry
    if (fOk = AllocVLE(&pVLE)) {

        // save varbind list index
        pVLE->nErrorIndex = iVb + 1;    

        // retrieve varbind pointer
        pVb = &pNLE->Pdu.Vbl.list[iVb];

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: variable %d name %s.\n",
            pVLE->nErrorIndex,
            SnmpUtilOidToA(&pVb->name)
            ));    

        // initialize type of resolved variable
        pVLE->ResolvedVb.value.asnType = ASN_NULL;

        // copy varbind name to working structure
        if (SnmpUtilOidCpy(&pVLE->ResolvedVb.name, &pVb->name) == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not copy vb name to working structure.\n"
                ));    

            // free allocated resources
            FreeVLE(pVLE);

            return FALSE;
        }

        // see if specific object asked for
        fAnyOk = ((pNLE->Pdu.nType == SNMP_PDU_GETNEXT) ||
                  (pNLE->Pdu.nType == SNMP_PDU_GETBULK));

        // attempt to lookup variable name in supported regions
        if (FindSupportedRegion(&pRLE, &pVb->name, fAnyOk)) {

            // save pointer to region
            pVLE->pCurrentRLE = pRLE;

            // structure has been initialized
            pVLE->nState = VARBIND_INITIALIZED;

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: variable %d assigned to %s.\n",
                pVLE->nErrorIndex,
                pVLE->pCurrentRLE->pSLE->pPathname
                ));    

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: variable %d state '%s'.\n",
                pVLE->nErrorIndex,
                VARBINDSTATESTRING(pVLE->nState)
                ));    

            // see if this is a getnext request
            if (pNLE->Pdu.nType == SNMP_PDU_GETNEXT) {    

                // only need single rep
                pVLE->nMaxRepetitions = 1;

            } else if (pNLE->Pdu.nType == SNMP_PDU_GETBULK) {

                // see if this non-repeater which is in bounds
                if (pNLE->Pdu.Pdu.BulkPdu.nNonRepeaters > (int)iVb) {

                    // only need single rep
                    pVLE->nMaxRepetitions = 1;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d max repetitions %d.\n",
                        pVLE->nErrorIndex,
                        pVLE->nMaxRepetitions
                        ));    

                // see if max-repetitions is non-zero
                } else if (pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions > 0) {

                    // set max-repetitions to value in getbulk pdu
                    pVLE->nMaxRepetitions = pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d max repetitions %d.\n",
                        pVLE->nErrorIndex,
                        pVLE->nMaxRepetitions
                        ));    

                } else {

                    // modify state to resolved 
                    pVLE->nState = VARBIND_RESOLVED;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d value NULL.\n",
                        pVLE->nErrorIndex
                        ));    
                }

            } else if (pNLE->Pdu.nType == SNMP_PDU_SET) {

                // copy varbind value to working structure
                if (SnmpUtilAsnAnyCpy(&pVLE->ResolvedVb.value, &pVb->value) == 0)
                {
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: could not copy vb value to working structure.\n"
                        ));    

                    // free allocated resources
                    FreeVLE(pVLE);

                    return FALSE;
                }

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d value %s.\n",
                    pVLE->nErrorIndex,
                    "<TBD>"
                    ));    
            }
    
        } else {

            // null pointer to region
            pVLE->pCurrentRLE = NULL;
            
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: variable %d unable to be assigned.\n",
                pVLE->nErrorIndex
                ));    

            // getbulk            
            if (fAnyOk) {

                // modify state to resolved 
                pVLE->nState = VARBIND_RESOLVED;

                // set the exception in the variable's type field
                pVLE->ResolvedVb.value.asnType = SNMP_EXCEPTION_ENDOFMIBVIEW;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d value ENDOFMIBVIEW.\n",
                    pVLE->nErrorIndex
                    ));    

            } else if (pNLE->Pdu.nType == SNMP_PDU_GET) {

                // modify state to resolved 
                pVLE->nState = VARBIND_RESOLVED;

                // set the exception in the variable's type field
                pVLE->ResolvedVb.value.asnType = SNMP_EXCEPTION_NOSUCHOBJECT;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d value NOSUCHOBJECT.\n",
                    pVLE->nErrorIndex
                    ));    

            } else {

                // modify state to resolved
                //pVLE->nState = VARBIND_ABORTED;
                pVLE->nState = VARBIND_RESOLVED;

                // save error status in network list entry
                pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOTWRITABLE;
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d error %s.\n",
                    pVLE->nErrorIndex,
                    SNMPERRORSTRING(pNLE->Pdu.Pdu.NormPdu.nErrorStatus)
                    ));    
                
                // failure
                //fOk = FALSE;
            }
        }

        // add to existing varbind list
        InsertTailList(&pNLE->Bindings, &pVLE->Link);
    }
    
    return fOk;
}


BOOL
LoadVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Creates list of varbind entries from varbind structure.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    UINT iVb;
    BOOL fOk = TRUE;
    
    // process each varbind in list
    for (iVb = 0; (fOk && (iVb < pNLE->Pdu.Vbl.len)); iVb++) {

        // load individual varbind
        fOk = LoadVarBind(pNLE, iVb);
    }

    return fOk;
}


BOOL
UnloadVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Destroys list of varbind entries.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;

    // process each varbind entry
    while (!IsListEmpty(&pNLE->Bindings)) {

        // point to first varbind
        pLE = RemoveHeadList(&pNLE->Bindings);

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

        // release
        FreeVLE(pVLE);
    }    

    return TRUE;
}


BOOL
ValidateVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Updates error status based on query results and version.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;

    // see if error has already report during processing
    if (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR) {
        
        // point to first varbind
        pLE = pNLE->Bindings.Flink;

        // process each varbind entry
        while (pLE != &pNLE->Bindings) {

            // retrieve pointer to varbind entry from link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

            // see if varbind has been resolved
            if (pVLE->nState != VARBIND_RESOLVED) {       

                SNMPDBG((
                    SNMP_LOG_WARNING,
                    "SNMP: SVC: variable %d unresolved.\n",
                    pVLE->nErrorIndex
                    ));

                // report internal error has occurred
                pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                break; // bail...
            
            } else if (pNLE->nVersion == SNMP_VERSION_1) {
        
                // report error if exceptions are present instead of values
                if ((pVLE->ResolvedVb.value.asnType == SNMP_EXCEPTION_NOSUCHOBJECT) ||
                    (pVLE->ResolvedVb.value.asnType == SNMP_EXCEPTION_NOSUCHINSTANCE) ||
                    (pVLE->ResolvedVb.value.asnType == SNMP_EXCEPTION_ENDOFMIBVIEW)) {
                        
                    SNMPDBG((
                        SNMP_LOG_WARNING,
                        "SNMP: SVC: variable %d unresolved in SNMPv1.\n",
                        pVLE->nErrorIndex
                        ));

                    // report that variable could not be found
                    pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
                    pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                    break; // bail...
                }
            }

            // next entry
            pLE = pLE->Flink;
        }    
    }

    // see if this is first version
    if (pNLE->nVersion == SNMP_VERSION_1) {

        // adjust status code
        switch (pNLE->Pdu.Pdu.NormPdu.nErrorStatus) {

        case SNMP_ERRORSTATUS_NOERROR:
        case SNMP_ERRORSTATUS_TOOBIG:
        case SNMP_ERRORSTATUS_NOSUCHNAME:
        case SNMP_ERRORSTATUS_BADVALUE:
        case SNMP_ERRORSTATUS_READONLY:
        case SNMP_ERRORSTATUS_GENERR:
            break;

        case SNMP_ERRORSTATUS_NOACCESS:
        case SNMP_ERRORSTATUS_NOCREATION:
        case SNMP_ERRORSTATUS_NOTWRITABLE:
        case SNMP_ERRORSTATUS_AUTHORIZATIONERROR:
        case SNMP_ERRORSTATUS_INCONSISTENTNAME:
            pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;

        case SNMP_ERRORSTATUS_WRONGTYPE:
        case SNMP_ERRORSTATUS_WRONGLENGTH:
        case SNMP_ERRORSTATUS_WRONGENCODING:
        case SNMP_ERRORSTATUS_WRONGVALUE:
        case SNMP_ERRORSTATUS_INCONSISTENTVALUE:
            pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_BADVALUE;
            break;

        case SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE:
        case SNMP_ERRORSTATUS_COMMITFAILED:
        case SNMP_ERRORSTATUS_UNDOFAILED:
        default:
            pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
            break;
        }
    }

    return (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR);
}


BOOL
UpdateVarBindsFromResolvedVb(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Updates varbinds with results containing single varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
    
    // point to first varbind
    pLE = pNLE->Bindings.Flink;

    // process each varbind entry
    while (pLE != &pNLE->Bindings) {

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: variable %d resolved name %s.\n",
            pVLE->nErrorIndex,
            SnmpUtilOidToA(&pVLE->ResolvedVb.name)
            ));    

        // release memory for original varbind
        SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[pVLE->nErrorIndex - 1]);

        // copy resolved varbind structure into pdu varbindlist
        if (SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[pVLE->nErrorIndex - 1], 
                           &pVLE->ResolvedVb) == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not copy resolved vb struct into pdu vbl.\n"
                ));    

            return FALSE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // success
    return TRUE;
}


BOOL
UpdateVarBindsFromResolvedVbl(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Updates varbinds with results containing multiple varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    UINT nRepeaters;
    UINT nNonRepeaters;
    UINT nMaxRepetitions;
    UINT nIterations;
    UINT nVarBindsLast;
    UINT nVarBinds = 0;
    SnmpVarBind * pVarBind;
    PVARBIND_LIST_ENTRY pVLE;
    PLIST_ENTRY pLE1;
    PLIST_ENTRY pLE2;

    // retrieve getbulk parameters from pdu
    nNonRepeaters   = pNLE->Pdu.Pdu.BulkPdu.nNonRepeaters;
    nMaxRepetitions = pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions;
    nRepeaters      = (pNLE->Pdu.Vbl.len >= nNonRepeaters)
                         ? (pNLE->Pdu.Vbl.len - nNonRepeaters)
                         : 0
                         ;

    // see if we need to expand size of varbind list
    if ((nRepeaters > 0) && (nMaxRepetitions > 1)) {
    
        UINT nMaxVarBinds;
        SnmpVarBind * pVarBinds;

        if (nMaxRepetitions > (UINT_MAX/nRepeaters))
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: arithmetic overflow: nMaxRepetitions 0x%x, nRepeaters 0x%x.\n",
                nMaxRepetitions, nRepeaters
                ));

            return FALSE; // bail...
        }
        if ((nMaxRepetitions * nRepeaters) > (UINT_MAX - nNonRepeaters))
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: arithmetic overflow: nMaxRepetitions 0x%x, nRepeaters 0x%x, nNonRepeaters 0x%x.\n",
                nMaxRepetitions, nRepeaters, nNonRepeaters
                ));

            return FALSE; // bail...
        }

        // calculate maximum number of varbinds possible
        nMaxVarBinds = nNonRepeaters + (nMaxRepetitions * nRepeaters);

        if (sizeof(SnmpVarBind) > (UINT_MAX/nMaxVarBinds))
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: arithmetic overflow: sizeof(SnmpVarBind) 0x%x, nMaxVarBinds 0x%x.\n",
                sizeof(SnmpVarBind), nMaxVarBinds
                ));

            return FALSE; // bail...
        }

        // BTW, we might want to restrict 
        // (nMaxVarBinds * sizeof(SnmpVarBind)) < 65535
        // because this vbl has to be less than the size of udp datagram.
    
        // reallocate varbind list to fit maximum
        pVarBinds = SnmpUtilMemReAlloc(pNLE->Pdu.Vbl.list, 
                                       nMaxVarBinds * sizeof(SnmpVarBind)
                                       );

        // validate pointer
        if (pVarBinds == NULL) {    
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: Could not re-allocate varbind list.\n"
                ));

            return FALSE; // bail...
        }

        // restore varbind pointer
        pNLE->Pdu.Vbl.list = pVarBinds;
    }

    // point to first varbind
    pLE1 = pNLE->Bindings.Flink;

    // process each varbind entry
    while (pLE1 != &pNLE->Bindings) {

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE1, VARBIND_LIST_ENTRY, Link);

        // see if this is non-repeater
        if (pVLE->nMaxRepetitions == 1) {

            // release memory for original varbind
            SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[nVarBinds]);

            // copy resolved varbind into pdu structure
            if (SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[nVarBinds],
                               &pVLE->ResolvedVb) == 0)
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: could not copy resolved vb into pdu struct at line %d.\n",
                    __LINE__
                    ));  

                return FALSE;   
            }

            // increment
            nVarBinds++;

        } else {

            //
            // finished processing non-repeaters 
            //

            break;
        }

        // next entry
        pLE1 = pLE1->Flink;
    }

    // initialize
    nIterations = 0;

    // store
    pLE2 = pLE1; 

    // process any repeaters until max
    while (nIterations < nMaxRepetitions) {

        // restore
        pLE1 = pLE2;        

        // process each varbind entry
        while (pLE1 != &pNLE->Bindings) {

            // retrieve pointer to varbind entry from link
            pVLE = CONTAINING_RECORD(pLE1, VARBIND_LIST_ENTRY, Link);

            // see if value stored in default
            if (pVLE->ResolvedVbl.len == 0) {

                // release memory for original varbind 
                SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[nVarBinds]);

                // copy resolved varbind into pdu varbind list
                if (SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[nVarBinds],
                                   &pVLE->ResolvedVb) == 0)
                {
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: could not copy resolved vb into pdu vbl at line %d.\n",
                        __LINE__
                    )); 
                                    
                    // save varbind count processed so far
                    pNLE->Pdu.Vbl.len = nVarBinds;

                    return FALSE;
                }

                // increment
                nVarBinds++;

            // see if value available in this iteration
            } else if (pVLE->ResolvedVbl.len > nIterations) {

                // release memory for original varbind 
                SnmpUtilVarBindFree(&pNLE->Pdu.Vbl.list[nVarBinds]);

                // copy resolved varbind into pdu varbind list
                if (SnmpUtilVarBindCpy(&pNLE->Pdu.Vbl.list[nVarBinds],
                                   &pVLE->ResolvedVbl.list[nIterations]) == 0)
                {
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SVC: could not copy resolved vb into pdu vbl at line %d.\n",
                        __LINE__
                    ));    
                                    
                    // save varbind count processed so far
                    pNLE->Pdu.Vbl.len = nVarBinds;

                    return FALSE;
                }

                // increment
                nVarBinds++;
            }

            // next entry
            pLE1 = pLE1->Flink;
        }
    
        // increment
        nIterations++;
    }

    // save new varbind count
    pNLE->Pdu.Vbl.len = nVarBinds;

    // success
    return TRUE;
}


BOOL
UpdatePdu(
    PNETWORK_LIST_ENTRY pNLE,
    BOOL                fOk
    )

/*++

Routine Description:

    Updates pdu with query results.

Arguments:

    pNLE - pointer to network list entry.

    fOk - true if process succeeded to this point.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;

    // validate
    if (fOk) {
        
        // make sure varbinds valid
        fOk = ValidateVarBinds(pNLE);

        // validate
        if (fOk) {

            // see if pdu type is getnext or getbulk
            if (pNLE->Pdu.nType != SNMP_PDU_GETBULK) {

                // update varbinds with single result
                fOk = UpdateVarBindsFromResolvedVb(pNLE);

            } else {

                // update varbinds with multiple results
                fOk = UpdateVarBindsFromResolvedVbl(pNLE);
            }
        }
    }

    // trap internal errors that have not been accounted for as of yet
    if (!fOk && (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR)) {

        // report status that was determined above
        pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
        pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = 0;
    }

    if (pNLE->Pdu.Pdu.NormPdu.nErrorStatus == SNMP_ERRORSTATUS_NOERROR)
    {
        switch(pNLE->Pdu.nType)
        {
        case SNMP_PDU_GETNEXT:
        case SNMP_PDU_GETBULK:
        case SNMP_PDU_GET:
            // update counter for successful GET-NEXT GET-BULK
            mgmtCAdd(CsnmpInTotalReqVars, pNLE->Pdu.Vbl.len);
            break;
        case SNMP_PDU_SET:
            // update counter for successful SET
            mgmtCAdd(CsnmpInTotalSetVars, pNLE->Pdu.Vbl.len);
            break;
        }
    }
    else
    {
        // update here counters for all OUT errors
        mgmtUtilUpdateErrStatus(OUT_errStatus, pNLE->Pdu.Pdu.NormPdu.nErrorStatus);
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocVLE(
    PVARBIND_LIST_ENTRY * ppVLE
    )

/*++

Routine Description:

    Allocates varbind structure and initializes.

Arguments:

    ppVLE - pointer to receive pointer to entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PVARBIND_LIST_ENTRY pVLE = NULL;

    // attempt to allocate structure
    pVLE = AgentMemAlloc(sizeof(VARBIND_LIST_ENTRY));

    // validate
    if (pVLE != NULL) {

        // success
        fOk = TRUE;
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate varbind entry.\n"
            ));
    }    

    // transfer
    *ppVLE = pVLE;

    return fOk;
}


BOOL 
FreeVLE(
    PVARBIND_LIST_ENTRY pVLE
    )

/*++

Routine Description:

    Releases varbind structure.

Arguments:

    pVLE - pointer to list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pVLE != NULL) {

        // release current varbind
        SnmpUtilVarBindFree(&pVLE->ResolvedVb);

        // release current varbind list
        SnmpUtilVarBindListFree(&pVLE->ResolvedVbl);

        // release structure
        AgentMemFree(pVLE);
    }

    return TRUE;
}


BOOL
ProcessVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Creates list of varbind entries from varbind structure.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate type before processing
    if ((pNLE->Pdu.nType == SNMP_PDU_SET) ||
        (pNLE->Pdu.nType == SNMP_PDU_GET) ||
        (pNLE->Pdu.nType == SNMP_PDU_GETNEXT) ||
        (pNLE->Pdu.nType == SNMP_PDU_GETBULK)) {

        // initialize varbinds
        if (LoadVarBinds(pNLE)) {

            // process queries 
            fOk = ProcessQueries(pNLE);
        }

        // transfer results 
        UpdatePdu(pNLE, fOk);
    
        // unload varbinds
        UnloadVarBinds(pNLE);

        // update management counters for accepted and processed requests
        switch(pNLE->Pdu.nType)
        {
        case SNMP_PDU_GET:
            mgmtCTick(CsnmpInGetRequests);
            break;
        case SNMP_PDU_GETNEXT:
        case SNMP_PDU_GETBULK:
            mgmtCTick(CsnmpInGetNexts);
            break;
        case SNMP_PDU_SET:
            mgmtCTick(CsnmpInSetRequests);
            break;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ignoring unknown pdu type %d.\n",
            pNLE->Pdu.nType
            ));
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\registry.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Contains definitions for manipulating registry parameters.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadRegistryParameters(
    );

BOOL
LoadScalarParameters(
    );

INT
InitRegistryNotifiers(
    );

INT
WaitOnRegNotification(
    );

BOOL
UnloadRegistryParameters(
    );

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\query.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    query.h

Abstract:

    Contains definitions for querying subagents.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _QUERY_H_
#define _QUERY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "subagnts.h"
#include "network.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _QUERY_LIST_ENTRY {

    LIST_ENTRY           Link;
    LIST_ENTRY           SubagentVbs;
    SnmpVarBindList      SubagentVbl;
    AsnOctetString       ContextInfo;
    UINT                 nSubagentVbs;
    UINT                 nErrorStatus;
    UINT                 nErrorIndex;
    PSUBAGENT_LIST_ENTRY pSLE;

} QUERY_LIST_ENTRY, *PQUERY_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessQueries(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
LoadQueries(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
UnloadQueries(
    PNETWORK_LIST_ENTRY pNLE
    );

#endif // _QUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\snmpmgmt.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgmt.h

Abstract:

    Contains the definitions of service management variables (as defined in RFC1213)

Environment:

    User Mode - Win32

Revision History:

    30-Mar-1998 FlorinT
--*/

#ifndef _SNMPMIB_H
#define _SNMPMIB_H

#include <snmp.h>

// defines the number of AsnCounters in the SNMP_MGMTVARS.AsnCounterPool[]
#define NC_MAX_COUNT				27

// indices in the SNMP_MGMTVARS.AsnCounterPool[]
#define CsnmpInPkts                 0
#define CsnmpOutPkts                1

#define CsnmpInBadVersions          2
#define CsnmpInBadCommunityNames    3
#define CsnmpInBadCommunityUses     4
#define CsnmpInASNParseErrs         5

#define CsnmpInTooBigs              6
#define CsnmpInNoSuchNames          7
#define CsnmpInBadValues            8
#define CsnmpInReadOnlys            9
#define CsnmpInGenErrs              10

#define CsnmpInTotalReqVars         11
#define CsnmpInTotalSetVars         12
#define CsnmpInGetRequests          13
#define CsnmpInGetNexts             14
#define CsnmpInSetRequests          15
#define CsnmpInGetResponses         16
#define CsnmpInTraps                17

#define CsnmpOutTooBigs             18
#define CsnmpOutNoSuchNames         19
#define CsnmpOutBadValues           20
#define CsnmpOutGenErrs             21

#define CsnmpOutGetRequests         22
#define CsnmpOutGetNexts            23
#define CsnmpOutSetRequests         24
#define CsnmpOutGetResponses        25
#define CsnmpOutTraps               26

// defines the number of AsnIntegers in the SNMP_MGMTVARS.AsnIntegerPool[]
#define NI_MAX_COUNT				2

// indices in the SNMP_MGMTVARS.AsnIntegerPool[]
#define IsnmpEnableAuthenTraps		0
#define IsnmpNameResolutionRetries	1

// defines the number of AsnObjects in the SNMP_MGMTVARS.AsnObjectIDs[]
#define NO_MAX_COUNT                1

 // indices in the SNMP_MGMTVARS.AsnObjectIDs[]
#define OsnmpSysObjectID            0

// flag for mgmtUtilUpdate* functions
#define IN_errStatus                0
#define OUT_errStatus               1

typedef struct _snmp_mgmtvars
{
  AsnAny    	AsnCounterPool[NC_MAX_COUNT];	// storage place for management counters.
  AsnAny    	AsnIntegerPool[NI_MAX_COUNT];	// storage place for management integers.
  AsnAny        AsnObjectIDs[NO_MAX_COUNT];     // storage place for management obj IDs.
} SNMP_MGMTVARS, *PSNMP_MGMTVARS;

extern SNMP_MGMTVARS snmpMgmtBase;

void mgmtInit();
void mgmtCleanup();
int  mgmtCTick(int index);
int  mgmtCAdd(int index, AsnCounter value);
int  mgmtISet(int index, AsnInteger value);
int  mgmtOSet(int index, AsnObjectIdentifier *pValue, BOOL bAlloc);

// utility functions
void mgmtUtilUpdateErrStatus(UINT flag, DWORD errStatus);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\snmpthrd.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpthrd.h

Abstract:

    Contains definitions for master agent network thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

#ifndef _SNMPTHRD_H_
#define _SNMPTHRD_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSTR
CommunityOctetsToString(
    AsnOctetString  *pAsnCommunity,
    BOOL            bUnicode
    );

LPSTR
StaticUnicodeToString(
    LPWSTR wszUnicode
    );

DWORD
WINAPI
ProcessSnmpMessages(
    LPVOID lpParam
    );

#endif // _SNMPTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\regthrd.h ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    regthrd.h

Abstract:

    Contains routines for thread listening to registry changes.

Environment:

    User Mode - Win32

Revision History:

    Rajat Goel -- 24 Feb 1999
        - Creation

--*/

#ifndef _REGTHRD_H_
#define _REGTHRD_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
ProcessRegistryMessage(
	LPVOID lpParam
	);

#endif // _REGTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\regions.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    regions.h

Abstract:

    Contains definitions for manipulating MIB region structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _REGIONS_H_
#define _REGIONS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "subagnts.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _MIB_REGION_LIST_ENTRY {

    AsnObjectIdentifier             PrefixOid;
    AsnObjectIdentifier             LimitOid;
    LIST_ENTRY                      Link;      
    PSUBAGENT_LIST_ENTRY            pSLE;
    struct _MIB_REGION_LIST_ENTRY * pSubagentRLE;

} MIB_REGION_LIST_ENTRY, *PMIB_REGION_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocRLE(
    PMIB_REGION_LIST_ENTRY * ppRLE    
    );

BOOL 
FreeRLE(
    PMIB_REGION_LIST_ENTRY pRLE    
    );

BOOL
FindFirstOverlappingRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    PMIB_REGION_LIST_ENTRY pNewRLE
    );

BOOL
FindSupportedRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    AsnObjectIdentifier *    pPrefixOid,
    BOOL                     fAnyOk
    );

BOOL    
UnloadRegions(
    PLIST_ENTRY pListHead
    );

BOOL
LoadSupportedRegions(
    );

BOOL
UnloadSupportedRegions(
    );

#endif // _REGIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\service.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    service.h

Abstract:

    Contains service definitions for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _SERVICE_H_
#define _SERVICE_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service name                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_SERVICE                TEXT("SNMP")

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP log level limits (must be consistent with SNMP_LOG_ contants)        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOGLEVEL_MINIMUM       0  
#define SNMP_LOGLEVEL_MAXIMUM       20 

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP log type limits (must be consistent with SNMP_OUTPUT_ contants)      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOGTYPE_MINIMUM        0   
#define SNMP_LOGTYPE_MAXIMUM        10  

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service parameter offsets (used in control handler)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_SERVICE_CONTROL_BASE   128
#define SNMP_SERVICE_LOGLEVEL_BASE  SNMP_SERVICE_CONTROL_BASE
#define SNMP_SERVICE_LOGTYPE_BASE   \
    (SNMP_SERVICE_LOGLEVEL_BASE + SNMP_LOGLEVEL_MAXIMUM + 1)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service parameter macro definitions                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define IS_LOGLEVEL(x) \
    (((x) >= (SNMP_SERVICE_LOGLEVEL_BASE + SNMP_LOGLEVEL_MINIMUM)) && \
     ((x) <= (SNMP_SERVICE_LOGLEVEL_BASE + SNMP_LOGLEVEL_MAXIMUM)))

#define IS_LOGTYPE(x) \
    (((x) >= (SNMP_SERVICE_LOGTYPE_BASE + SNMP_LOGTYPE_MINIMUM)) && \
     ((x) <= (SNMP_SERVICE_LOGTYPE_BASE + SNMP_LOGTYPE_MAXIMUM)))

#define IS_LOGLEVEL_VALID(x) \
    (((x) >= SNMP_LOGLEVEL_MINIMUM) && ((x) <= SNMP_LOGLEVEL_MAXIMUM))

#define IS_LOGTYPE_VALID(x) \
    (((x) >= SNMP_LOGTYPE_MINIMUM) && ((x) <= SNMP_LOGTYPE_MAXIMUM))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service status definitions                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define NO_WAIT_HINT    0
#define SNMP_WAIT_HINT  30000


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMP service debug string macro definitions                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SNMP_LOGLEVEL_STRING(x) \
    (((x) == SNMP_LOG_SILENT) \
        ? "SILENT" \
        : ((x) == SNMP_LOG_FATAL) \
            ? "FATAL" \
            : ((x) == SNMP_LOG_ERROR) \
                ? "ERROR" \
                : ((x) == SNMP_LOG_WARNING) \
                    ? "WARNING" \
                    : ((x) == SNMP_LOG_TRACE) \
                        ? "TRACE" \
                        : ((x) == SNMP_LOG_VERBOSE) \
                            ? "VERBOSE" \
                            : "UNKNOWN" \
                            )

#define SNMP_LOGTYPE_STRING(x) \
    (((x) == SNMP_OUTPUT_TO_CONSOLE) \
        ? "CONSOLE" \
        : ((x) == SNMP_OUTPUT_TO_LOGFILE) \
            ? "LOGFILE" \
            : ((x) == SNMP_OUTPUT_TO_EVENTLOG) \
                ? "EVENTLOG" \
                : ((x) == SNMP_OUTPUT_TO_DEBUGGER) \
                    ? "DEBUGGER" \
                    : "UNKNOWN" \
                    )

#define SERVICE_STATUS_STRING(x) \
    (((x) == SERVICE_STOPPED) \
        ? "STOPPED" \
        : ((x) == SERVICE_START_PENDING) \
              ? "START PENDING" \
              : ((x) == SERVICE_STOP_PENDING) \
                    ? "STOP PENDING" \
                    : ((x) == SERVICE_RUNNING) \
                          ? "RUNNING" \
                          : ((x) == SERVICE_CONTINUE_PENDING) \
                                ? "CONTINUE PENDING" \
                                : ((x) == SERVICE_PAUSE_PENDING) \
                                      ? "PAUSE PENDING" \
                                      : ((x) == SERVICE_PAUSED) \
                                            ? "PAUSED" \
                                            : "UNKNOWN" \
                                            )

#define SERVICE_CONTROL_STRING(x) \
    (((x) == SERVICE_CONTROL_STOP) \
        ? "STOP" \
        : ((x) == SERVICE_CONTROL_PAUSE) \
            ? "PAUSE" \
            : ((x) == SERVICE_CONTROL_CONTINUE) \
                ? "CONTINUE" \
                : ((x) == SERVICE_CONTROL_INTERROGATE) \
                    ? "INTERROGATE" \
                    : ((x) == SERVICE_CONTROL_SHUTDOWN) \
                        ? "SHUTDOWN" \
                        : "CONFIGURE" \
                        )

#endif // _SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\snmpmgrs.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgrs.h

Abstract:

    Contains definitions for manipulating managers structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _SNMPMGRS_H_
#define _SNMPMGRS_H_


#include "snmpmgmt.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MGRADDR_ALIVE	-1
#define MGRADDR_DEAD	0
#define MGRADDR_DYING	16

typedef struct _MANAGER_LIST_ENTRY {

    LIST_ENTRY      Link;
    struct sockaddr SockAddr;
    INT             SockAddrLen;
    LPSTR           pManager;
    BOOL            fDynamicName;
    DWORD           dwLastUpdate;
    AsnInteger      dwAge;

} MANAGER_LIST_ENTRY, *PMANAGER_LIST_ENTRY;

#define DEFAULT_NAME_TIMEOUT    0x0036EE80  // one hour timeout


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocMLE(
    PMANAGER_LIST_ENTRY * ppMLE,
    LPSTR                pManager
    );

BOOL
FreeMLE(
    PMANAGER_LIST_ENTRY pMLE
    );

BOOL
UpdateMLE(
    PMANAGER_LIST_ENTRY pMLE
    );

BOOL
AddManager(
    PLIST_ENTRY pListHead,
    LPSTR       pManager
    );

BOOL
FindManagerByName(
    PMANAGER_LIST_ENTRY * ppMLE,
    PLIST_ENTRY           pListHead,
    LPSTR                 pManager
    );    

BOOL
IsManagerAddrLegal(
    struct sockaddr_in *  pAddr
    );

BOOL
FindManagerByAddr(
    PMANAGER_LIST_ENTRY * ppMLE,
    struct sockaddr *     pAddr
    );    

BOOL
LoadManagers(
    HKEY        hKey,
    PLIST_ENTRY pListHead
    );

BOOL
UnloadManagers(
    PLIST_ENTRY pListHead
    );

BOOL
LoadPermittedManagers(
    BOOL bFirstCall
    );

BOOL
UnloadPermittedManagers(
    );

#endif // _SNMPMGRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\startup.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    startup.h

Abstract:

    Contains definitions for starting SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _STARTUP_H_
#define _STARTUP_H_

extern HANDLE g_hAgentThread;
extern HANDLE g_hRegistryThread;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
StartupAgent(
    );

BOOL
ShutdownAgent(
    );

#endif // _STARTUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\trapthrd.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapthrd.h

Abstract:

    Contains definitions for trap processing thread.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _TRAPTHRD_H_
#define _TRAPTHRD_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "network.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessSubagentEvents(
    );

BOOL
GenerateTrap(
    PSNMP_PDU pPdu
    );

BOOL
GenerateColdStartTrap(
    );

BOOL
GenerateAuthenticationTrap(
    );

#endif // _TRAPTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\varbinds.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    varbinds.h

Abstract:

    Contains definitions for manipulating varbinds.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _VARBINDS_H_
#define _VARBINDS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "regions.h"
#include "network.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _VARBIND_LIST_ENTRY {

    LIST_ENTRY             Link;
    LIST_ENTRY             QueryLink;
    SnmpVarBind            ResolvedVb;        
    SnmpVarBindList        ResolvedVbl;
    UINT                   nState;
    UINT                   nErrorIndex;  
    UINT                   nMaxRepetitions;
    PMIB_REGION_LIST_ENTRY pCurrentRLE;

} VARBIND_LIST_ENTRY, *PVARBIND_LIST_ENTRY;
                                            
#define VARBIND_UNINITIALIZED          0 // varbind info invalid
#define VARBIND_INITIALIZED            1 // varbind info valid
#define VARBIND_RESOLVING              2 // involved in query now
#define VARBIND_PARTIALLY_RESOLVED     3 // subsequent query needed
#define VARBIND_RESOLVED               4 // completed successfully
#define VARBIND_ABORTED                5 // completed unsuccessfully

#define VARBINDSTATESTRING(nState) \
            ((nState == VARBIND_INITIALIZED) \
                ? "initialized" \
                : (nState == VARBIND_PARTIALLY_RESOLVED) \
                    ? "partially resolved" \
                    : (nState == VARBIND_RESOLVED) \
                        ? "resolved" \
                        : (nState == VARBIND_RESOLVING) \
                            ? "resolving" \
                            : (nState == VARBIND_UNINITIALIZED) \
                                ? "uninitialized" \
                                : "aborted")


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
UnloadVarBinds(
    PNETWORK_LIST_ENTRY pNLE
    );

BOOL
AllocVLE(
    PVARBIND_LIST_ENTRY * ppVLE
    );

BOOL 
FreeVLE(
    PVARBIND_LIST_ENTRY pVLE
    );

#endif // _VARBINDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\trapmgrs.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    trapmgrs.h

Abstract:

    Contains definitions for manipulating trap destination structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _TRAPMGRS_H_
#define _TRAPMGRS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _TRAP_DESTINATION_LIST_ENTRY {

    LIST_ENTRY Link;
    LIST_ENTRY Managers;
    LPSTR      pCommunity;

} TRAP_DESTINATION_LIST_ENTRY, *PTRAP_DESTINATION_LIST_ENTRY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocTLE(
    PTRAP_DESTINATION_LIST_ENTRY * ppTLE,
    LPSTR                          pCommunity    
    );

BOOL
FreeTLE(
    PTRAP_DESTINATION_LIST_ENTRY pTLE
    );

BOOL
LoadTrapDestinations(
    BOOL bFirstCall
    );

BOOL
UnloadTrapDestinations(
    );

#endif // _TRAPMGRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\genmsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MSG_BAD_TRAP_INDEX
//
// MessageText:
//
//  No trap sent.
//  %1!s!
//
#define MSG_BAD_TRAP_INDEX               0x80000000L

//
// MessageId: MSG_BAD_TRAP_VARIABLE_COUNT
//
// MessageText:
//
//  Trap was sent with no arguments.
//  %1!s!
//
#define MSG_BAD_TRAP_VARIABLE_COUNT      0x80000001L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\newagent\inc\subagnts.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    subagnts.h

Abstract:

    Contains definitions for manipulating subagent structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
#ifndef _SUBAGNTS_H_
#define _SUBAGNTS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// flag values to be used in _SUBAGENT_LIST_ENTRY:uchFlags
#define FLG_SLE_KEEP    0x01

typedef struct _SUBAGENT_LIST_ENTRY {
    
    LIST_ENTRY              Link;          
    LIST_ENTRY              SupportedRegions;
    PFNSNMPEXTENSIONINIT    pfnSnmpExtensionInit;
    PFNSNMPEXTENSIONINITEX  pfnSnmpExtensionInitEx;
    PFNSNMPEXTENSIONCLOSE   pfnSnmpExtensionClose;
    PFNSNMPEXTENSIONMONITOR pfnSnmpExtensionMonitor;
    PFNSNMPEXTENSIONQUERY   pfnSnmpExtensionQuery;
    PFNSNMPEXTENSIONQUERYEX pfnSnmpExtensionQueryEx;
    PFNSNMPEXTENSIONTRAP    pfnSnmpExtensionTrap;
    HANDLE                  hSubagentTrapEvent;
    HANDLE                  hSubagentDll;
    UCHAR                   uchFlags;
    LPSTR                   pPathname;

} SUBAGENT_LIST_ENTRY, *PSUBAGENT_LIST_ENTRY;

#define SNMP_EXTENSION_INIT     "SnmpExtensionInit"
#define SNMP_EXTENSION_INIT_EX  "SnmpExtensionInitEx"
#define SNMP_EXTENSION_CLOSE    "SnmpExtensionClose"
#define SNMP_EXTENSION_MONITOR  "SnmpExtensionMonitor"
#define SNMP_EXTENSION_QUERY    "SnmpExtensionQuery"
#define SNMP_EXTENSION_QUERY_EX "SnmpExtensionQueryEx"
#define SNMP_EXTENSION_TRAP     "SnmpExtensionTrap"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindSubagent(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                  pPathname
    );

BOOL
AddSubagentByDll(
    LPSTR pPathname,
    UCHAR uchInitFlags
    );

BOOL
AllocSLE(
    PSUBAGENT_LIST_ENTRY * ppSLE,
    LPSTR                  pPathname,
    UCHAR                  uchInitFlags
    );

BOOL
FreeSLE(
    PSUBAGENT_LIST_ENTRY pSLE
    );

BOOL
LoadSubagents(
    );

BOOL
UnloadSubagents(
    );

#endif // _SUBAGNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\gennt.h ===
/*
 *  gennt.h v0.15   March 21, 1996
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    Agent.
 *
 *    This module contains the definitions for the table driven SNMP dlls.
 *
 *  Author:
 *     Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *     2/17/95
 *
 *  Revision History:
 *  v0.11   11/15/95  ags  added mib-2 definitions.
 *  v0.12   Feb 14, 1996  ags  changed SMIGet/SetBoolean to SMIGet/SetNSMBoolean
 *  v0.13   Mar 12, 1996  kkf  revised trap_control_block so that VarBindList
 *                        is built prior to queuing to the trap_queue
 *  v0.14   Mar 19, 1996  kkf  fixed numerous trap related bugs
 *  v0.15   Mar 22, 1996  kkf  fixed mib-2 code definition (should be 1 not 2)
 *
 */

#ifndef gennt_h
#define gennt_h

// Necessary includes.

#include <snmp.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>


// MIB function actions.

#define MIB_ACTION_GET         ASN_RFC1157_GETREQUEST
#define MIB_ACTION_SET         ASN_RFC1157_SETREQUEST
#define MIB_ACTION_GETNEXT     ASN_RFC1157_GETNEXTREQUEST

typedef enum
    { NSM_READ_ONLY, NSM_WRITE_ONLY, NSM_READ_WRITE, NSM_NO_ACCESS } access_mode_t ;

typedef enum
{
    NON_TABLE = 0 ,
    TABLE = 1
} table_type_t ;

typedef int (* PF)() ;
typedef void (* PFV)() ;

//
//  The variable structure is used to construct the variable table.
//  Each variable is represented by an entry in the table.  The table
//  driven design indexes into the table to access information specific
//  to the variable, such as its oid, access, get and set routines.
//  "Holes" in the sequence of variables are represented by NULL entries.
//

typedef struct variable
{
    AsnObjectIdentifier *oid ;
    BYTE type ;
    access_mode_t access_mode ;
    PF VarGet ;
    PF VarSet ;
    PF SMIGet ;
    PF SMISet ;
} variable_t ;

//
//  The class structure is used to construct the class_info table.  It
//  is this table that represents the groups composing the mib view of
//  this dll.  The table driven design uses this table in conjuction
//  with the variable tables to process the SNMP requests.
//

typedef struct class
{
    table_type_t table ;
    AsnObjectIdentifier *oid ;
    unsigned long int var_index ;
    unsigned long int min_index ;
    unsigned long int max_index ;
    PF FindInstance ;
    PF FindNextInstance ;
    PF ConvertInstance ;
    PFV FreeInstance ;
    variable_t *variable ;
} class_t ;

//
//  The trap structure is used to construct the trap_info table.  It
//  is this table that represents the trap for this mib view.  The
//  table driven design uses this table to process the trap.  A event
//  is sent to tell the Extendible Agent to call this dll's SnmpExtensionTrap
//  routine to "collect" a trap.  This routine dequeues a trap from the
//  trap queue and then indexes into the trap_info table to fill in the
//  trap information for the trap pdu.
//

typedef struct trap_variable
{
    AsnObjectIdentifier *oid ;
    PF SMIBuild ;
} tvt_t ;

typedef struct trap
{
    AsnObjectIdentifier *oid ;  /* enterprise OID */
    AsnInteger type ;		/* SNMP_GENERICTRAP_ENTERSPECIFIC */
    AsnInteger specific ;	/* trap value */
    UINT number_of_variables ;
    tvt_t *variables ;
} trap_t ;

typedef struct q_hdr
{
    char *lifo_a ;
    char *fifo_a ;
} q_hdr_t ;

typedef struct trap_control_block
{
    q_hdr_t chain_q ;
    AsnObjectIdentifier enterprise ;
    AsnInteger genericTrap ;
    AsnInteger specificTrap ;
    AsnTimeticks timeStamp ;
    RFC1157VarBindList varBindList ;
} tcb_t ;

//
// Definitions of the oid sequence : 1.3.6.1.4.1.36.2 also described as:
//    iso.memberbody.dod.internet.mib.private.dec.ema
//

#define ISO_CODE 1
#define ISO 1
#define ISO_SEQ ISO_CODE
#define ISO_LENGTH 1

#define ORG_CODE 3
#define ORG 3
#define ORG_SEQ ISO_SEQ, ORG_CODE
#define ORG_LENGTH ( ISO_LENGTH + 1 )

#define DOD_CODE 6
#define DOD 6
#define DOD_SEQ ORG_SEQ, DOD_CODE
#define DOD_LENGTH ( ORG_LENGTH + 1 )

#define INTERNET_CODE 1
#define INTERNET 1
#define INTERNET_SEQ DOD_SEQ, INTERNET_CODE
#define INTERNET_LENGTH ( DOD_LENGTH + 1 )

#define DIRECTORY_CODE 1
#define DIRECTORY 1
#define DIRECTORY_SEQ INTERNET_SEQ, DIRECTORY_CODE
#define DIRECTORY_LENGTH ( INTERNET_LENGTH + 1 )

#define MGMT_CODE 2
#define MGMT 2
#define MGMT_SEQ INTERNET_SEQ, MGMT_CODE
#define MGMT_LENGTH ( INTERNET_LENGTH + 1 )

#define EXPERIMENTAL_CODE 3
#define EXPERIMENTAL 3
#define EXPERIMENTAL_SEQ INTERNET_SEQ, EXPERIMENTAL_CODE
#define EXPERIMENTAL_LENGTH ( INTERNET_LENGTH + 1 )

#define PRIVATE_CODE 4
#define PRIVATE 4
#define PRIVATE_SEQ INTERNET_SEQ, PRIVATE_CODE
#define PRIVATE_LENGTH ( INTERNET_LENGTH + 1 )

#define ENTERPRISES_CODE 1
#define ENTERPRISES 1
#define ENTERPRISES_SEQ PRIVATE_SEQ, ENTERPRISES_CODE
#define ENTERPRISES_LENGTH ( PRIVATE_LENGTH + 1 )

#define DEC_CODE 36
#define DEC 36
#define DEC_SEQ ENTERPRISES_SEQ, DEC_CODE
#define DEC_LENGTH ( ENTERPRISES_LENGTH + 1 )

#define EMA_CODE 2
#define EMA 2
#define EMA_SEQ DEC_SEQ, EMA_CODE
#define EMA_LENGTH ( DEC_LENGTH + 1 )

#define MIB_2_CODE 1
#define MIB_2 2
#define MIB_2_SEQ MGMT_SEQ, MIB_2_CODE
#define MIB_2_LENGTH ( MGMT_LENGTH + 1 )


//
//  Macros
//

#define SUCCESS  1
#define FAILURE  0

#define CHECK_VARIABLE( VarBind, cindex, vindex, status )                   \
{                                                                           \
    if ( VarBind->name.idLength > class_info[ cindex ].var_index )          \
    {                                                                       \
        vindex = VarBind->name.ids[ class_info[ cindex ].var_index - 1 ] ;  \
        if ( ( vindex >= class_info[ cindex ].min_index ) &&                \
             ( vindex <= class_info[ cindex ].max_index ) )                 \
            status = SUCCESS ;                                              \
        else                                                                \
            status = FAILURE ;                                              \
    }                                                                       \
    else                                                                    \
        status = FAILURE ;                                                  \
}


#define CHECK_ACCESS( cindex, vindex, PduAction, status )           \
{                                                                   \
    access_mode_t tmp ;                                             \
                                                                    \
    tmp = class_info[ cindex ].variable[ vindex ].access_mode ;     \
    if ( PduAction == MIB_ACTION_SET )                              \
    {                                                               \
        if ( ( tmp == NSM_WRITE_ONLY ) || ( tmp == NSM_READ_WRITE ) )       \
            status = SUCCESS ;                                      \
        else                                                        \
            status = FAILURE ;                                      \
    }                                                               \
    else                                                            \
    {                                                               \
        if ( ( tmp == NSM_READ_ONLY ) || ( tmp == NSM_READ_WRITE ) )        \
            status = SUCCESS ;                                      \
        else                                                        \
            status = FAILURE ;                                      \
    }                                                               \
}

//
//  These macros are used by the trap logic.  There is only one queue
//  used by the generic code - a trap queue.  These macros can be used
//  elsewhere.  The macros assume that the queue structure is the first
//  element in the queue entry structure.
//
#define QUEUE_ENTER( queue_head, entry )             \
{                                                    \
    q_hdr_t *old_chain ;                             \
                                                     \
    old_chain = (q_hdr_t *)(queue_head.lifo_a) ;     \
    entry->chain_q.lifo_a = queue_head.lifo_a ;      \
    queue_head.lifo_a = (char *)entry ;              \
    entry->chain_q.fifo_a = NULL ;                   \
    if ( old_chain == NULL )                         \
        queue_head.fifo_a = (char *)entry ;          \
    else                                             \
        old_chain->fifo_a = (char *)entry ;          \
}

#define QUEUE_REMOVE( queue_head, entry )                  \
{                                                          \
    q_hdr_t *dequeue_chain ;                               \
    q_hdr_t *prev_chain ;                                  \
                                                           \
    dequeue_chain = (q_hdr_t *)(queue_head.fifo_a) ;       \
    entry = (tcb_t *)dequeue_chain ;                       \
    if ( dequeue_chain != NULL )                           \
    {                                                      \
        prev_chain = (q_hdr_t *)(dequeue_chain->fifo_a) ;  \
        queue_head.fifo_a = (char *)prev_chain ;           \
        if ( prev_chain != NULL )                          \
            prev_chain->lifo_a = NULL ;                    \
        else                                               \
            queue_head.lifo_a = NULL ;                     \
    }                                                      \
}

//
// Function Prototypes
//

UINT UserMibInit(
        IN OUT HANDLE *hPollForTrapEvent ) ;

void TrapInit(
        IN OUT HANDLE *hPollForTrapEvent ) ;

UINT ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind , // Variable Binding to resolve
	    IN UINT PduAction ) ;            // Action specified in PDU

UINT FindClass(
        IN RFC1157VarBind *VarBind,      // Variable Binding
        IN OUT UINT *cindex ) ;          // Index into class_info table

UINT ResolveGetNext(
        IN OUT RFC1157VarBind *VarBind,  // Variable Binding
        IN OUT UINT *cindex,             // Class Info table index
        IN OUT UINT *vindex ,            // Variable table index
        OUT AsnObjectIdentifier *instance ) ;

void SetupTrap(
		IN OUT tcb_t **entryBlock ,
		IN int trapIndex ) ;

UINT AddTrapVar(
		IN tcb_t *entry ,
		IN int trapIndex ,
		IN int varIndex ,
		IN AsnObjectIdentifier *instance ,
		IN char *value ) ;

void PostTrap(
		IN tcb_t *entry ,
		IN int trapIndex ) ;

//
// Externals
//

extern UINT SMIGetInteger() ;
extern UINT SMIGetNSMBoolean() ;
extern UINT SMIGetBIDTEnum() ;
extern UINT SMIGetOctetString() ;
extern UINT SMIGetObjectId() ;
extern UINT SMIGetCounter() ;
extern UINT SMIGetGauge() ;
extern UINT SMIGetTimeTicks() ;
extern UINT SMIGetIpAddress() ;
extern UINT SMIGetDispString() ;
extern UINT SMISetInteger() ;
extern UINT SMISetBIDTEnum() ;
extern UINT SMISetOctetString() ;
extern UINT SMISetObjectId() ;
extern UINT SMISetCounter() ;
extern UINT SMISetGauge() ;
extern UINT SMISetTimeTicks() ;
extern UINT SMISetIpAddress() ;
extern UINT SMISetDispString() ;
extern UINT SMIBuildInteger() ;
extern UINT SMISetNSMBoolean() ;
extern UINT SMIBuildBIDTEnum() ;
extern UINT SMIBuildOctetString() ;
extern UINT SMIBuildObjectId() ;
extern UINT SMIBuildCounter() ;
extern UINT SMIBuildGauge() ;
extern UINT SMIBuildTimeTicks() ;
extern UINT SMIBuildIpAddress() ;
extern UINT SMIBuildDispString() ;
extern void SMIFree() ;

extern q_hdr_t trap_q ;
extern HANDLE hEnabledTraps ;
extern HANDLE hTrapQMutex ;

// Microsoft MIB Specifics.

#define MAX_STRING_LEN            255

#endif /* gennt_h */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\gennt.c ===
/*
 *  gennt.c v0.14  May 15, 1996 
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the generic logic for
 *    processing the SNMP request.  It is table driven.  No user modification
 *    should be done.
 *
 *  Functions:
 *
 *    ResolveVarBind()
 *    FindClass()
 *    ResolveGetNext()
 *
 *  Author:
 *    Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *      2/17/95
 *
 *  Revision History:
 *  6/22/95  krw0001  FindClass - modify to stop checking for valid variable - we only care about valid
 *                              class.
 *                              Rewrite ResolveGetNext
 *  6/26/95  ags      FindClass - stop checking for valid variable
 *                              Rewrite ResolveGetNext
 *  7/31/95  ags      SNMP_oidfree works with CRTDLL.lib, hence use them.
 *  2/14/96  ags   v0.11    one fix for the getnext bug found by Cindy
 *  3/19/96  kff   v0.12    modified for trap support
 *  4/19/96  ags   v0.13    Modified to get rid of trap.c in case of no traps.
 *  5/15/96  cs    v0.14    Modified FindClass in the backward walkthru to tighten
 *                      up the verification
 */


#include <windows.h>
#include <malloc.h>
#include <stdio.h>

#include <snmp.h>

#include "mib.h"
#include "mib_xtrn.h"
#include "smint.h"

extern DWORD dwTimeZero ;

UINT
SnmpUtilOidMatch(AsnObjectIdentifier *pOid1, AsnObjectIdentifier *pOid2)
{
    unsigned long int nScan = min(pOid1->idLength, pOid2->idLength);
    unsigned long int i;

    for (i = 0; i < nScan; i++)
    {
        if (pOid1->ids[i] != pOid2->ids[i])
            break;
    }

    return i;
}



/*
 *  ResolveVarBind
 *
 *    Resolves a single variable binding.  Modifies the variable value pair
 *    on a GET or a GET-NEXT.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    PduAction                  type of request - get, set, or getnext
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
ResolveVarBind( IN OUT RFC1157VarBind *VarBind , // Variable Binding to resolve
                IN UINT PduAction )              // Action specified in PDU

{
    unsigned long int cindex ;  // index into the class info table
    unsigned long int vindex ;  // index into the class's var table
    UINT instance_array[ MAX_STRING_LEN ] ;
    UINT status ;
    UINT result ;               // SNMP PDU error status
    AsnObjectIdentifier instance ;
    InstanceName native_instance ;

    instance.ids = instance_array ;

    // Determine which class the VarBind is for

    status = FindClass( VarBind, &cindex ) ;
    if ( status )
    {
        if ( PduAction != MIB_ACTION_GETNEXT )
        {
            // Check for valid variable as this is a get or set

            CHECK_VARIABLE( VarBind, cindex, vindex, status ) ;
            if ( !status )
                return SNMP_ERRORSTATUS_NOSUCHNAME ;

            // Check for valid instance

            status = ( *class_info[ cindex ].FindInstance )
                     ( (ObjectIdentifier *)&(VarBind->name) ,
                       (ObjectIdentifier *)&instance ) ;
            if ( status != SNMP_ERRORSTATUS_NOERROR )
                return status ;

            // Check for access

            CHECK_ACCESS( cindex, vindex, PduAction, status ) ;
            if ( !status )
            {
                if ( PduAction == MIB_ACTION_SET )
                    return SNMP_ERRORSTATUS_NOTWRITABLE ;
                else
                    return SNMP_ERRORSTATUS_GENERR ;
            }

            // Ok to do the get or set

            if ( PduAction == MIB_ACTION_GET )
            {
                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex].SMIGet )
                         ( VarBind , cindex, vindex, &native_instance ) ;
            }
            else
            {
                if ( VarBind->value.asnType !=
                     class_info[ cindex ].variable[ vindex ].type )
                    return SNMP_ERRORSTATUS_BADVALUE ;

                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex ].SMISet )
                         ( VarBind, cindex, vindex, &native_instance ) ;
            }
        }
        else  // This is a GETNEXT
        {
            //
            //  Call ResolveGetNext() to determine which class, variable, and
            //  instance to do a Get on.
            //

            status = ResolveGetNext( VarBind, &cindex, &vindex, &instance ) ;
            if ( status == SUCCESS )
            {
                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex ].SMIGet )
                         ( VarBind, cindex, vindex, &native_instance ) ;
            }
            else
                return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    }
    else
    {
        //
        // No class found, but its a GETNEXT.. we need to find the class that has the longest
        // with the requested oid and forward the request to it
        //

        if (PduAction == MIB_ACTION_GETNEXT)
        {
            unsigned long int ci;               // index into the class info table
            unsigned long int nLongestMatch;    // max number of ids that matched between names
            unsigned long int nCurrentMatch;    // matching number of IDs at the current iteration

            // scan the class_info table, relying on the fact that the table is ordered
            // ordered ascendingly on the class OID.
            for (ci = 0, nLongestMatch = 0; ci < CLASS_TABLE_MAX; ci++)
            {
                // pick up the number of matching ids between the VarBind and the class name..
                nCurrentMatch = SnmpUtilOidMatch(&VarBind->name, class_info[ci].oid);

                // store in cindex the first class with the highest match number
                if (nCurrentMatch > nLongestMatch)
                {
                    cindex = ci;
                    nLongestMatch = nCurrentMatch;
                }
            }


            // only if VarBind name is longer than the match number we need to look
            // for an even better match
            if (VarBind->name.idLength > nLongestMatch)
            {
                for (;cindex < CLASS_TABLE_MAX; cindex++)
                {
                    // make sure we don't go over the range with the longest Match
                    if (SnmpUtilOidMatch(&VarBind->name, class_info[cindex].oid) != nLongestMatch)
                        break;

                    // if the class matches entirely into the VarBind name, check if the first ID
                    // that follows in VarBind name is inside the range supported by the class
                    if (class_info[cindex].oid->idLength == nLongestMatch)
                    {
                        // this is a hack - we rely the var_index is always 1 more than number of ids in
                        // the class_info name. Since VarBind has already a name longer than nLongestMatch
                        // no buffer overrun happens here.
                        // if the VarBind name is in the right range, then we found the class - just break the loop
                        // (don't forget, var_index is '1' based)
                        if(VarBind->name.ids[class_info[cindex].var_index - 1] <= class_info[cindex].max_index)
                            break;
                    }
                    else
                    {
                        // the VarBind name is longer than the IDs that match, the class_info name is the same
                        // the first ID that follows in both names can't be equal, so we can break the loop if
                        // the VarBind name is just in front of it.
                        if (VarBind->name.ids[nLongestMatch] < class_info[cindex].oid->ids[nLongestMatch])
                            break;
                    }

                }
            }

            if (cindex < CLASS_TABLE_MAX )
                   vindex = class_info[cindex].min_index ;
            else
                   return SNMP_ERRORSTATUS_NOSUCHNAME ;

            SNMP_oidfree( &VarBind->name ) ;
            if (! SNMP_oidcpy( &VarBind->name ,
                         class_info[ cindex ].variable[ vindex ].oid ) )
            {
                return SNMP_ERRORSTATUS_GENERR ;
            }
            status = ResolveGetNext( VarBind, &cindex, &vindex, &instance ) ;
            if ( status == SUCCESS )
            {
                status = ( *class_info[ cindex ].ConvertInstance )
                         ( (ObjectIdentifier *)&instance, &native_instance ) ;
                if ( status == FAILURE )
                    return SNMP_ERRORSTATUS_GENERR ;

                result = ( *class_info[ cindex ].variable[ vindex ].SMIGet )
                         ( VarBind, cindex, vindex, &native_instance ) ;
            }
            else
            {
                return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
        }
        else
            return SNMP_ERRORSTATUS_NOSUCHNAME ;
    }

    ( *class_info[ cindex ].FreeInstance )( &native_instance ) ;
    return result ;

} /* end of ResolveVarBind() */



/*
 *  FindClass
 *
 *    This routine determines the class by walking the class_info table
 *    backwards and comparing the class oids.  The table is walked
 *    backwards because it assumes that the classes are listed in
 *    increasing order.  For example,
 *
 *    Group Name              Group Identifier
 *
 *    group1                  1.3.6.1.4.1.36.2.78
 *    table1                  1.3.6.1.4.1.36.2.78.9
 *    table2                  1.3.6.1.4.1.36.2.78.10
 *
 *    We need to look for the longest exact match on the oid thus we
 *    walk the table backwards.
 *
 *  Arguments:
 *
 *     VarBind                 Variable value pair
 *     class                   Index into the class_info
 *
 *  Return Codes:
 *
 *     SUCCESS                 Class is valid, return index into class_info
 *     FAILURE                 Invalid class
 *
 */

UINT
FindClass( IN RFC1157VarBind *VarBind ,
           IN OUT UINT *cindex )
{
    int index ;
    UINT status, vindex ;
    UINT length ;

    for ( index = CLASS_TABLE_MAX - 1 ; index >= 0 ; index-- )
    {
        if ( class_info[ index ].table )
            // skip over the entry code -- kkf, why?
//            length = class_info[ index ].var_index - 2 ;
            length = class_info[ index ].var_index - 1 ;
        else
            length = class_info[ index ].var_index - 1 ;
        status = SNMP_oidncmp( &VarBind->name ,
                               class_info[ index ].oid ,
                               length ) ;

        // if the oid don't match the class or it is shorter than the
        // class go on to the next one.
        // If the oid requested is shorter than the class we can't stop
        // otherwise we'll point to a wrong (longest match) class.
        if (status != 0 ||
            VarBind->name.idLength < class_info[ index ].var_index)
            continue;

        vindex = VarBind->name.ids[ class_info[ index ].var_index - 1 ] ;
        // cs - added the vindex verification to make sure that the varbind
        // oid definitely belongs in this class (fixed partial table oids)
        
        if ( vindex >= class_info[ index ].min_index &&
             vindex <= class_info[ index ].max_index)
        {
            *cindex = index ;
            return SUCCESS ;
        }
    }

    //  Failed to match by walking list backwards (longest match)
    //  so OID supplied is shorter than expected (e.g., partial OID supplied)
    //  Try matching by forward walking...
    for (index = 0; index < CLASS_TABLE_MAX; index++ ) {
        status = SNMP_oidncmp( &VarBind->name ,
                               class_info[ index ].oid ,
                               VarBind->name.idLength ) ;
        if ( status == 0 ) {
            *cindex = index ;
            return SUCCESS ;
        }
    }

    return FAILURE ;

} /* end of FindClass() */



/*
 *   ResolveGetNext
 *
 *     Determines the class, the variable and the instance that the
 *     GetNext request is to be performed on.  This is a recursive
 *     routine.  The input arguments VarBind and class may be modified
 *     as part of the resolution.
 *
 *     The rules for getnext are:
 *       1. No instance and no variable specified so return the first
 *          variable for the first instance.
 *       2. No instance specified but a variable is specified so return
 *          the variable for the first instance.
 *       3. An instance and a variable are specified
 *              Follow 3a,4b for  Non Tables
 *              Follow 3b, 4b, 5b for  Tables
 *
 *       3a.Return the next variable for the instance.
 *       4a.An instance and a variable are specified but the variable is the
 *          last variable in the group so return the first variable for the
 *          next group.
 *          If there is no next group return FAILURE.
 *
 *       3b. Return the variable for the next instance ( walk down the column).
 *       4b. Reached the bottom of the column, start at the top of next column.
 *       5b. An instance and a variable are specified but it is the last 
 *          variable and the last instace so roll to the next group (class).
 *          If there is no next group return FAILURE.
 *
 *  Arguments:
 *
 *     VarBind                 Variable value pair
 *     cindex                  Index into the class_info
 *     vindex                  address to specify variable for the get
 *
 *  Return Codes:
 *
 *     SUCCESS                 Able to resolve the request to a class, variable
 *                             and instance
 *     FAILURE                 Unable to resolve the request within this  MIB
 *
 */

UINT
ResolveGetNext( IN OUT RFC1157VarBind *VarBind ,
                IN OUT UINT *cindex ,
                IN OUT UINT *vindex ,
                OUT AsnObjectIdentifier *instance )
                {
    UINT status ;
    access_mode_t tmpAccess ;

    
    /*
     * We've come in with a pointer to the class, to start with
     * Do we have a variable specified?
     */
    
    *vindex = 0 ;
    if (VarBind->name.idLength < class_info[ *cindex ].var_index )  {
        /*
         * No variable specified. so pick the first variable (if it exists)
         * to start the search for a valid variable.
         * If not roll over to the next class.
         * Instnace is 0 for non Tables, and the first instance for Tables.
         */

        if ( class_info[ *cindex ].min_index <= class_info[ *cindex ].max_index)   {

            *vindex = class_info[ *cindex ].min_index ;
            goto StartSearchAt;
        } else  {
            goto BumpClass;
        }

    } else {
        /*
         * Yes, a variable is specified.
         * If it is below min_index, start testing for a valid variable at the min_index.
         * If it is ablove max_index roll over to the next class.
         * If we change the variable, Instance is reset to the first (or the only) Instance.
         */
        *vindex = VarBind->name.ids[ class_info[ *cindex ].var_index - 1 ] ;
        
        if ( *vindex < class_info[ *cindex ].min_index) {
            *vindex = class_info[ *cindex ].min_index ;
            goto StartSearchAt;
        }
        
        if ( *vindex > class_info[ *cindex ].max_index)
            goto BumpClass;
        /*
         * A valid variable for this class is specified. Table & NonTable are treated
         * differently.
         * In case of Non Tables:
         *      if instance is specified, we start the serach for a valid variable at the
         *              next variable.
         *      if no instnace is specified, we start search at the specified variable.
         *
         * In case of Tables:
         * We may have
         *      a. No Instance              start at the 1st Instance
         *      b. Partial instance         start at the 1st Instance
         *      c. Invalid instance         start at the 1st Instance
         *      d. Valid Instance           start at the next Instance
         * All these cases will be handled by the FindNextInstance
         * Hence first check that access of the given vaiable, if it is readable
         * get the Next Instance. If not start the search for a valid variable at the next
         * variable.
         */

        if ( class_info[ *cindex ].table == NON_TABLE ) {
            /* test for the Instance */
            if ( VarBind->name.idLength > class_info[ *cindex ].var_index)
                (*vindex)++ ;

            goto StartSearchAt;
        } else {
            /* Start Table case */
            tmpAccess =  class_info[ *cindex ].variable[ *vindex ].access_mode ;
            if ( ( tmpAccess == NSM_READ_ONLY ) || (tmpAccess == NSM_READ_WRITE) ) {
                /*
                 * readable Variable,  walk down the column
                 */
                status = ( *class_info[ *cindex ].FindNextInstance )
                        ( (ObjectIdentifier *)&(VarBind->name) ,
                        (ObjectIdentifier *)instance ) ;
            
                if (status == SNMP_ERRORSTATUS_NOERROR) {           
                    SNMP_oidfree ( &VarBind->name ) ;
                    if (! SNMP_oidcpy ( &VarBind->name,
                                class_info[*cindex ].variable[*vindex].oid ) )
                    {
                        return FAILURE;
                    }
                    if (!SNMP_oidappend ( &VarBind->name, instance ))
                    {
                        return FAILURE;
                    }
                    return SUCCESS ;                   
                    /* we are all done   */
                }
            }
            /*
             * Either at end of the column, or variable specified is non Readable.
             * Hence we need to move to the next column,
             * This means we start at the 1st instnace.
             */
            (*vindex)++ ;
            goto StartSearchAt;
            /* End Table case */
        }
        /* end of variable specified case */
    }
StartSearchAt:
    /*
     * We have a start variable in *vindex.
     * At this point we are moving to the next column in case of a Table
     * Hence if we can't find an NextInstance ( empty Table), move to the
     * next class.
     */
     status = FAILURE;
     while ( *vindex <= class_info[ *cindex ].max_index)  {

        tmpAccess =  class_info[ *cindex ].variable[ *vindex ].access_mode ;
        if ( ( tmpAccess == NSM_READ_ONLY ) || (tmpAccess == NSM_READ_WRITE) ) {
            status = SUCCESS;
            break;
        } else  {
            (*vindex)++;
        }
     }

     if ( status == SUCCESS) {
        /*
         * we hava a valid variable, get the instance
         */
        SNMP_oidfree ( &VarBind->name ) ;
        if (!SNMP_oidcpy ( &VarBind->name, class_info[ *cindex ].variable[*vindex ].oid ))
        {
            return FAILURE;
        }
        if ( class_info[ *cindex ].table == NON_TABLE) {
        
            instance->ids[ 0 ] = 0 ;
            instance->idLength = 1 ;
            if (!SNMP_oidappend ( &VarBind->name, instance ))
            {
                return FAILURE;
            }
            return SUCCESS ;

        } else {

            status = ( *class_info[ *cindex ].FindNextInstance )
                        ( (ObjectIdentifier *)&(VarBind->name) ,
                        (ObjectIdentifier *)instance ) ;
            
            if (status == SNMP_ERRORSTATUS_NOERROR) {           
                if (!SNMP_oidappend ( &VarBind->name, instance ))
                {
                    return FAILURE;
                }
                return SUCCESS ;
            }
        }
     }

/*
 * Come here to move on to the next class
 */

BumpClass:
    {
        (*cindex)++ ;
        if ( *cindex >= CLASS_TABLE_MAX)
            return FAILURE ;
        SNMP_oidfree( &VarBind->name );
        if (!SNMP_oidcpy ( &VarBind->name, class_info[ *cindex ].oid ))
        {
            return FAILURE;
        }
        status = ResolveGetNext( VarBind, cindex, vindex, instance) ;
        return status ;
    }
    
    // This oughtn't to happen
    return FAILURE ;
} /* end of ResolveGetNext() */


#ifndef TRAPS
//
// If there are no traps, TrapInit() is still needed. 
// If there are traps, all this code appears in 
// generated file trap.c
//

UINT number_of_traps = 0 ;

trap_t
    trap_info[] = {
        { NULL, 0, 0, 0, NULL }
} ;

extern
trap_t trap_info[] ;

extern
UINT number_of_traps ;

extern HANDLE hEnabledTraps ;
extern HANDLE hTrapQMutex ;

/*
 *  TrapInit
 *
 *    This routine initializes the trap handle.
 *
 *  Arguments:
 *
 *    hPollForTrapEvent    handle for traps - this is used to coordinate
 *                         between the Extendible Agent and this Extension
 *                         Agent.
 *                             - NULL indicates no traps
 *                             - value from CreateEvent() indicates traps
 *                               are implemented and the Extendible agent
 *                               must poll for them
 *
 *  Return Code:
 *
 *    SUCCESS     Successful initialization
 *    FAILURE     Unable to initialize
 *
 |=========================================================================
 | There are no Traps associated with the HostMIB.  Consequently this
 | routine is taken over and used to create a handle to a timer rather
 | than an event.
 |
 | We want to be entered at "SnmpExtensionTrap()" (in "HOSTMIB.C") on
 | a periodic interval.  When entered, we won't really do any trap processing,
 | instead we'll refresh the cached information associated with SNMP
 | attribute "hrProcessorLoad" (in "HRPROCES.C") thru a call to function
 | "hrProcessLoad_Refresh()" (also in "HRPROCES.C").
 |
 | So the contents of this standard function is replaced.  (Note that the
 | "hTrapQMutex" is no longer created).
 */

VOID
TrapInit( IN OUT HANDLE *hPollForTrapEvent )
{
#if 0
    // The default value for traps is NULL indicating NO traps.

    *hPollForTrapEvent = NULL ;
    hTrapQMutex = NULL ;

    // Call to CreateEvent uses the default security descriptor (therefore
    // the handle is not inheritable), flags auto reset (no call to ResetEvent()
    // required), flags no signal to be sent at the initial state, and does
    // not specify a name for this event.
    //
    // If the CreateEvent() fails the value returned is NULL so traps
    // are not enabled.  Otherwise the setting of this event with will cause
    // the Extendible Agent to call this Extension Agent's SnmpExtensionTrap
    // routine to collect any traps.

    *hPollForTrapEvent = CreateEvent( NULL ,   // Address of security attrib
                                      FALSE ,  // Flag for manual-reset event
                                      FALSE ,  // Flag for initial state 
                                      NULL ) ; // Address of event-object name

    //
    // Save the handle in a global variable for use later in setting a trap.
    //

    hEnabledTraps = *hPollForTrapEvent ;

    //
    //  Create Mutex for assuring single thread access to enque/dequeue on trap_q
    hTrapQMutex = CreateMutex( NULL,  // Address of security attrib
                               FALSE, // Mutex is not initially owned
                   NULL ) ; // Mutex is unnamed

    return ;
#endif
/*
|========================
| Special HostMIB code:
*/
LARGE_INTEGER   due_time;       /* When the timer first goes off */
LONG            period;         /* Frequency: every minute       */
BOOL            waitable;       /* Status from SetWaitable()     */


    *hPollForTrapEvent = NULL ;

    /* Attempt the creation of a waitable timer . . . */
    *hPollForTrapEvent = CreateWaitableTimer(NULL,      // Security
                                             FALSE,     // = Auto-resetting
                                             NULL       // = No name
                                             );

    /*
    | Set a negative due time to mean "relative": We want it to go off
    | in 30 seconds.  Ticks are 100 ns or 1/10th of a millionth of a second.
    |
    */
    due_time.QuadPart = 10000000 * (-30);

    /*
    | Set the period in milliseconds to 1 minute.
    */
    period = 1000 * 60;

    /* If we actually managed to create it, start it */
    if (*hPollForTrapEvent != NULL) {

        waitable = 
            SetWaitableTimer(*hPollForTrapEvent,    // Handle to timer
                             &due_time,             // "Due Time" to go off
                             period,                // Length of period in ms.
                             NULL,                  // no completion routine
                             NULL,                  // no arg to comp. routine
                             FALSE                  // no power-resume in NT
                             );
        }

} /* end of TrapInit() */

#endif /* #ifndef TRAPS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hmcache.h ===
/*
 *  File HMCACHE.H
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module is contains definitions pertaining to the HostMIB
 *    cacheing mechanism.
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V1.0 - 04/17/97  D. D. Burns     Original Creation
 */

#ifndef hmcache_h
#define hmcache_h


/*
|==============================================================================
| Debug Cache Dump Support
|
|    Define "CACHE_DUMP" to get function "PrintCache" defined to enable
|    debug-dumping of any cache for which a debug_print function is defined
|    (in a CACHEHEAD_INSTANCE() macro that defines the list-head of the cache).
|
|    Define "DUMP_FILE" to specify where the dump file is generated.  All
|    opens on this file are for "append", so you must explicitly delete the
|    file if you want to start fresh.  All entries are time-stamped, so any
|    confusion is your own, though.
|
|    NOTE 1: After defining "CACHE_DUMP", grep the sources to see what caches
|            "PrintCache()" may be being invoked on and where.  Typically
|            all caches are dumped immediately after they are built.  The
|            cache for hrSWRun(Perf) table is re-built if it is older than
|            "CACHE_MAX_AGE" (defined in "HRSWRUNE.C") when a request for
|            something in the tables served by the cache comes in.  So it
|            may also be dumped after each (re-)build.
|
|    NOTE 2: Define "PROC_CACHE" to get a periodic dump to "PROC_FILE" of
|            the hrProcessorLoad-specific cache.  This dump occurs on a
|            1-minute timer and will rapidly use up disk space if left
|            running for any long period.  This cache and dump is special
|            to the "hrProcessorLoad" variable in hrProcessor sub-table.
|            (Opens on this file are also for "append").
*/
//#define CACHE_DUMP 1
#define DUMP_FILE \
    "c:\\nt\\private\\net\\snmp\\subagent\\hostmib\\HostMib_Cache.dmp"

//#define PROC_CACHE 1
#define PROC_FILE \
    "c:\\nt\\private\\net\\snmp\\subagent\\hostmib\\Processor_Cache.dmp"


#if defined(CACHE_DUMP) || defined(PROC_CACHE)
#include <stdio.h>
#include <time.h>
#endif

/*
|==============================================================================
| hrStorage Attribute Defines
|
|    Each attribute defined for hrStorage table is associated with one of the
|    #defines below.  These symbols are used as C indices into the list of
|    attributes within a cached-row.
|
|    These symbols are globally accessible so that logic that builds hrFSTable
|    can "peek" at values stored in the hrStorageTable cache.
*/
#define HRST_INDEX 0    // hrStorageIndex
#define HRST_TYPE  1    // hrStorageType
#define HRST_DESCR 2    // hrStorageDescr
#define HRST_ALLOC 3    // hrStorageAllocationUnits
#define HRST_SIZE  4    // hrStorageSize
#define HRST_USED  5    // hrStorageUsed
#define HRST_FAILS 6    // hrStorageAllocationFailures
                   //-->Add more here, change count below!
#define HRST_ATTRIB_COUNT 7


/*
|==============================================================================
| hrFSTable Attribute Defines
|
|    Each attribute defined for hrFSTable is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
|    These symbols are globally accessible so that logic that builds 
|    hrPartition can "peek" at values stored in the hrFSEntry Table cache.
*/
#define HRFS_INDEX    0    // hrFSIndex
#define HRFS_MOUNTPT  1    // hrFSMountPoint
#define HRFS_RMOUNTPT 2    // hrFSRemoteMountPoint
#define HRFS_TYPE     3    // hrFSType
#define HRFS_ACCESS   4    // hrFSAccess
#define HRFS_BOOTABLE 5    // hrFSBootable
#define HRFS_STORINDX 6    // hrFSStorageIndex
#define HRFS_LASTFULL 7    // hrFSLastFullBackupDate
#define HRFS_LASTPART 8    // hrFSLastPartialBackupDate
                      //-->Add more here, change count below!
#define HRFS_ATTRIB_COUNT 9


/*
|==============================================================================
| hrSWRun(Perf) Table Attribute Defines
|
|    Each attribute defined for hrSWRun Table and hrSWRunPerf Table is 
|    associated with one of the #defines below.  These symbols are used as 
|    C indices into the array of attributes within a cached-row.
|
|    These symbols are globally accessible so that logic for hrSWRunPerf table
|    (in "HRSWPREN.C") can reference these as well as logic for hrSWRun table
|    (in "HRSWRUNE.C") since both tables share the same cache.
|
|    Note that "HrSWRunID" is not cached.
*/
#define HRSR_INDEX    0    // HrSWRunIndex
#define HRSR_NAME     1    // HrSWRunName
#define HRSR_PATH     2    // HrSWRunPath
#define HRSR_PARAM    3    // HRSWRunParameters
#define HRSR_TYPE     4    // HrSWRunType
#define HRSR_STATUS   5    // HrSWRunStatus
#define HRSP_CPU      6    // HrSWRunPerfCPU - Performance
#define HRSP_MEM      7    // HrSWRunPerfMem - Performance
                      //-->Add more here, change count below!
#define HRSR_ATTRIB_COUNT 8


/*
|==============================================================================
| These structures are used in the implementation of an in-memory cache
| for the Host Resources MIB subagent.  For a broad overview of the cache
| scheme, see the documentation at the front of "HMCACHE.C".
|==============================================================================
*/


/*
|==============================================================================
| ATTRIB_TYPE
|
|     This enumerated type lists the data-type of a value of an attribute
|     stored in an instance of a ATTRIB structure (one of typically many
|     in a CACHEROW structure for a given table row).
|
|     "CA_STRING"
|       The value is a null-terminated string sitting in 'malloc'ed storage
|       within an ATTRIB structure.
|
|     "CA_NUMBER"
|       The value is a binary numeric value stored directly in the ATTRIB
|       structure.  No additional malloc storage is associated with this
|       type.
|
|     "CA_COMPUTED"
|       The value is not stored in the ATTRIB structure at all, but is
|       dynamic and is computed and returned by the support subagent
|       "get" function.
|
|     "CA_CACHE"
|       The value is a pointer to a CACHEHEAD structure that describes
|       another cache.  The CACHEHEAD structure is in 'malloc'ed storage.
|       This is used for "multiply-indexed" tables.
|
| Note that the instance of this enumerated type (in ATTRIB below) is mainly
| of use in debugging and memory management (when we get to the point where 
| cached-rows may be freed).  Generally the "Get" function that is going to
| reach into the cache is already going to be coded according to what is
| there, and may not even look to see what "type" the value is.
|==============================================================================
*/
typedef
    enum {
        CA_UNKNOWN,     /* Not yet set               */
        CA_STRING,      /* ('malloc'ed storage)      */
        CA_NUMBER,      /* (no 'malloc'ed storage)   */
        CA_COMPUTED,    /* (no 'malloc'ed storage)   */
        CA_CACHE        /* ('malloc'ed storage)      */
        } ATTRIB_TYPE;



/*
|==============================================================================
| ATTRIB
|
|     An array of these structures is logically allocated inside each 
|     instance of a CACHEROW structure.
|
|     An instance of this structure describes the value of one attribute
|     in the cache (in general; in the "CA_COMPUTED" case there is no value
|     present, the GET function "knows" what to do).
|==============================================================================
*/
typedef
    struct {

        ATTRIB_TYPE     attrib_type;    /* STRING, NUMBER, (COMPUTED) */

        union {
            LPSTR       string_value;   /* CA_STRING (malloc)   */
            ULONG       unumber_value;  /* CA_NUMBER (unsigned) */
            LONG        number_value;   /* CA_NUMBER (signed)   */
            void       *cache;          /* CA_CACHE  (malloc)   */
            } u;
            
        } ATTRIB;



/*
|==============================================================================
| CACHEROW
|
|     An instance of this structure occurs for each row in a table.  Instances
|     are strung on a list maintained by a CACHEHEAD structure (below), ordered
|     by the value of "index".
|
|     The "attrib_list[]" array storage is malloc'ed to the appropriate size
|     at the time an instance of this structure is created.  The indices into
|     this array are #DEFINED symbols, all according to the table definition
|     of the attributes in the table.  Typically the #defines are placed in
|     the source module that implements the table.
|
|     The internal arrangement of this structure (and underlying structures)
|     is meant to be such that function "DestroyTableRow()" can release all
|     storage for an instance of this structure without "knowing" the #DEFINE
|     index symbols above (or anything else).
|==============================================================================
*/
typedef
    struct rc_tag{

        ULONG           index;          /* SNMP index of table              */
        struct rc_tag   *next;          /* Next in the cache list           */

        /*
        | Contents of this table row:
        */
        ULONG           attrib_count;   /* # of elements in "attrib_list"[] */
        ATTRIB         *attrib_list;    /* --> array of attributes          */

        } CACHEROW;



/*
|==============================================================================
| CACHEHEAD
|
|     An instance of this structure (created by the macro CACHEHEAD_INSTANCE)
|     occurs for each SNMP "table" cached.
|
|     All CACHEROW elements of the list are ordered by their index values
|     as they are inserted by general function "AddTableRow()".
|
|     See documentation in "HMCACHE.C".
|
|NOTE: If you modify this structure or the macro that initializes static
|      instances of it, be sure to add/change code in "HRPARTIT.C" where
|      instances in dynamic (malloc) memory are created.
|==============================================================================
*/
typedef
    struct {

        ULONG           list_count;     /* (Mainly for ease of debugging) */
        CACHEROW        *list;          /* The row list itself            */
        void            (*print_row)(); /* Debug Print-A-Row function     */
        } CACHEHEAD;

#if defined(CACHE_DUMP)
#define CACHEHEAD_INSTANCE(name,debug_print)       \
        CACHEHEAD  name={ 0, NULL, debug_print };
#else
#define CACHEHEAD_INSTANCE(name,debug_print)       \
        CACHEHEAD  name={ 0, NULL, NULL };
#endif


/*
|==============================================================================
| HMCACHE.C - Function Prototypes
*/

/* CreateTableRow - Create a CACHEROW structure for attributes in a table */
CACHEROW *
CreateTableRow(
               ULONG attribute_count
              );

/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */
void
DestroyTable(
             CACHEHEAD *cache   /* Cache whose rows are to be Released */
             );

/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */
void
DestroyTableRow(
                CACHEROW *row   /* Row to be Released */
                );

/* AddTableRow - Adds a specific "row" into a cached "table" */
BOOL
AddTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEROW   *row,           /* Row to be added to .. */
             CACHEHEAD  *cache          /* this cache            */
              );

/* FindTableRow - Finds a specific "row" in a cached "table" */
CACHEROW *
FindTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEHEAD  *cache          /* Table cache to search */
              );

/* FindNextTableRow - Finds Next row after a specific "row" in a cache */
CACHEROW *
FindNextTableRow(
                 ULONG      index,          /* Index for row desired */
                 CACHEHEAD  *cache          /* Table cache to search */
                 );

/* GetNextTableRow - Gets Next row after a specific "row" or NULL if none */
#define GetNextTableRow(row) row->next


/* ======  DEBUG DUMP SUPPORT ====== */
#if defined(CACHE_DUMP)
/* PrintCache - Dumps for debugging the contents of a cache */
void
PrintCache(
           CACHEHEAD  *cache          /* Table cache to dump */
           );

/* Debug Print Output channel used by PrintCache &  "Print-A-Row" functions*/
#define OFILE Ofile
extern FILE *Ofile;
#endif


/*
|==============================================================================
| Function Prototypes for cache-related function found in other modules:
*/

/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */
BOOL Gen_Hrstorage_Cache( void );       /* "HRSTOENT.C"                      */
extern CACHEHEAD hrStorage_cache;       /* This cache is globally accessible */

/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */
BOOL Gen_HrFSTable_Cache( void );       /* "HRFSENTR.C"                      */
extern CACHEHEAD hrFSTable_cache;       /* This cache is globally accessible */

/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */
BOOL Gen_HrDevice_Cache( void );        /* "HRDEVENT.C"                      */
extern CACHEHEAD hrDevice_cache;        /* This cache is globally accessible */
extern ULONG InitLoadDev_index;         /* From hrDevice for hrSystem        */

/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table        */
BOOL Gen_HrSWInstalled_Cache( void );   /* "HESWINEN.C"                      */

/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table      */
BOOL Gen_HrSWRun_Cache( void );         /* "HRSWRUNE.C"                      */
extern CACHEHEAD hrSWRunTable_cache;    /* Globally accessible for ref from  */
                                        /* "HRSWPREN.C"                      */
extern ULONG SWOSIndex;                 /* From "HRSWRUNE.C" for "HRSWRUN.C" */

/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */
BOOL hrSWRunCache_Refresh( void );
/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */
BOOL hrStorageCache_hrFSTableCache_Refresh( void );

#endif /* hmcache_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hostmsmi.c ===
/*
 * mibtsmi.ntc v0.10
 *  hostmsmi.c
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the SMI envelopes around the callout to the
 *    developer's get and set routines.  Note that the developer can modify
 *    these routines to valid that the types actually conform to contraints
 *    for a given type.
 *
 *  Functions:
 *
 *    SMIGetxxx() and SMISetxxx() for each user defined type.
 *
 *  Author:
 *
 *  David Burns @ Webenable Inc
 *
 *  Date:
 *
 *  Thu Nov 07 16:38:30 1996
 *
 *  Revision History:
 *      generated with v0.10 stub
 *
 *      May 15, 1997 - To Microsoft: 4 changes of "malloc" to "SNMP_malloc"
 */

#include <snmp.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>

#include "smint.h"
#include "hostmsmi.h"
#include "mib.h"
#include "mib_xtrn.h"

/*
 *  SMIGetBoolean
 *    Boolean ::= INTEGER a truth value
 *    
 *    Encompasses the callouts to variables for the data type Boolean
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Boolean outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetBoolean() */

/*
 *  SMISetBoolean
 *    Boolean ::= INTEGER a truth value
 *    
 *    Encompasses the callouts to variables for the data type Boolean
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Boolean *invalue ;
    Boolean outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (Boolean *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetBoolean() */

/*
 *  SMIBuildBoolean
 *    Boolean ::= INTEGER a truth value
 *    
 *    Places the variable of datatype Boolean into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildBoolean() */


/*
 *  SMIGetKBytes
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 *    
 *    Encompasses the callouts to variables for the data type KBytes
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    KBytes outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetKBytes() */

/*
 *  SMISetKBytes
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 *    
 *    Encompasses the callouts to variables for the data type KBytes
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    KBytes *invalue ;
    KBytes outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (KBytes *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetKBytes() */

/*
 *  SMIBuildKBytes
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 *    
 *    Places the variable of datatype KBytes into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildKBytes() */


/*
 *  SMIGetINThrDeviceStatus
 *    INThrDeviceStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDeviceStatus
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDeviceStatus outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrDeviceStatus() */

/*
 *  SMISetINThrDeviceStatus
 *    INThrDeviceStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDeviceStatus
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDeviceStatus *invalue ;
    INThrDeviceStatus outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrDeviceStatus *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrDeviceStatus() */

/*
 *  SMIBuildINThrDeviceStatus
 *    INThrDeviceStatus ::= INTEGER 
 *    
 *    Places the variable of datatype INThrDeviceStatus into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrDeviceStatus() */


/*
 *  SMIGetINThrPrinterStatus
 *    INThrPrinterStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrPrinterStatus
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrPrinterStatus outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrPrinterStatus() */

/*
 *  SMISetINThrPrinterStatus
 *    INThrPrinterStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrPrinterStatus
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrPrinterStatus *invalue ;
    INThrPrinterStatus outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrPrinterStatus *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrPrinterStatus() */

/*
 *  SMIBuildINThrPrinterStatus
 *    INThrPrinterStatus ::= INTEGER 
 *    
 *    Places the variable of datatype INThrPrinterStatus into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrPrinterStatus() */


/*
 *  SMIGetINTAccess
 *    INTAccess ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTAccess
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTAccess outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINTAccess() */

/*
 *  SMISetINTAccess
 *    INTAccess ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTAccess
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTAccess *invalue ;
    INTAccess outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INTAccess *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINTAccess() */

/*
 *  SMIBuildINTAccess
 *    INTAccess ::= INTEGER 
 *    
 *    Places the variable of datatype INTAccess into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINTAccess() */


/*
 *  SMIGetINThrDiskStorageMedia
 *    INThrDiskStorageMedia ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDiskStorageMedia
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDiskStorageMedia outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrDiskStorageMedia() */

/*
 *  SMISetINThrDiskStorageMedia
 *    INThrDiskStorageMedia ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrDiskStorageMedia
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrDiskStorageMedia *invalue ;
    INThrDiskStorageMedia outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrDiskStorageMedia *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrDiskStorageMedia() */

/*
 *  SMIBuildINThrDiskStorageMedia
 *    INThrDiskStorageMedia ::= INTEGER 
 *    
 *    Places the variable of datatype INThrDiskStorageMedia into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrDiskStorageMedia() */


/*
 *  SMIGetINTSWType
 *    INTSWType ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTSWType
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTSWType outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINTSWType() */

/*
 *  SMISetINTSWType
 *    INTSWType ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INTSWType
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INTSWType *invalue ;
    INTSWType outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INTSWType *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINTSWType() */

/*
 *  SMIBuildINTSWType
 *    INTSWType ::= INTEGER 
 *    
 *    Places the variable of datatype INTSWType into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINTSWType() */


/*
 *  SMIGetINThrSWRunStatus
 *    INThrSWRunStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrSWRunStatus
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmii.c v 0.6
 */

UINT
SMIGetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrSWRunStatus outvalue ;
    Access_Credential access ;  // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number =
                               (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetINThrSWRunStatus() */

/*
 *  SMISetINThrSWRunStatus
 *    INThrSWRunStatus ::= INTEGER 
 *    
 *    Encompasses the callouts to variables for the data type INThrSWRunStatus
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    INThrSWRunStatus *invalue ;
    INThrSWRunStatus outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (INThrSWRunStatus *)
              ( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result;

} /* end of SMISetINThrSWRunStatus() */

/*
 *  SMIBuildINThrSWRunStatus
 *    INThrSWRunStatus ::= INTEGER 
 *    
 *    Places the variable of datatype INThrSWRunStatus into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind            pointer to the variable value pair
 *    invalue            address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue )
{
    Integer *svalue = (Integer *)invalue;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;
    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of SMIBuildINThrSWRunStatus() */


/*
 *  SMIGetDateAndTime
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 *    
 *    Encompasses the callouts to variables for the data type DateAndTime
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmio.c v 0.5
 */

UINT
SMIGetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    DateAndTime outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;  // dummy holder for future use

    outvalue.string = stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        if (outvalue.length > 0)
        {
            VarBind->value.asnValue.string.stream =
                SNMP_malloc( outvalue.length * sizeof( char ) ) ;
            if ( VarBind->value.asnValue.string.stream == NULL )
            {
                VarBind->value.asnValue.string.length = 0;
                VarBind->value.asnType = ASN_OCTETSTRING ;
                VarBind->value.asnValue.string.stream = NULL;
                VarBind->value.asnValue.string.dynamic = FALSE ;
                result = SNMP_ERRORSTATUS_GENERR ;
            }
            else
            {
                VarBind->value.asnValue.string.length = outvalue.length ;
                memcpy( VarBind->value.asnValue.string.stream ,
                        outvalue.string ,
                        outvalue.length ) ;
                VarBind->value.asnType = ASN_OCTETSTRING ;
                VarBind->value.asnValue.string.dynamic = TRUE ;
            }
        }
        else
        {
            VarBind->value.asnValue.string.stream = NULL;
            VarBind->value.asnValue.string.length = 0;
            VarBind->value.asnType = ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = FALSE ;
        }
    }

    return result ;
} /* end of SMIGetDateAndTime() */

/*
 *  SMISetDateAndTime
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 *    
 *    Encompasses the callouts to variables for the data type DateAndTime
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result  = SNMP_ERRORSTATUS_NOERROR ;
    DateAndTime invalue ;
    DateAndTime outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;   // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result;
} /* end of SMISetDateAndTime() */

/*
 *  SMIBuildDateAndTime
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 *    
 *    Places the variable of datatype DateAndTime into a Variable Binding
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      invalue                   address of the data
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue )
{
    OctetString *svalue = (OctetString *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    if (svalue->length)
    {
        VarBind->value.asnValue.string.stream =
            SNMP_malloc( svalue->length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
        {
            VarBind->value.asnValue.string.length = 0;
            VarBind->value.asnType = ASN_OCTETSTRING;
            VarBind->value.asnValue.string.dynamic = FALSE;
            status = SNMP_ERRORSTATUS_GENERR ;
        }
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    svalue->string ,
                    svalue->length ) ;
            VarBind->value.asnValue.string.length = svalue->length ;
            VarBind->value.asnType = ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    else
    {
        VarBind->value.asnValue.string.stream = NULL;
        VarBind->value.asnValue.string.length = 0;
        VarBind->value.asnType = ASN_OCTETSTRING ;
        VarBind->value.asnValue.string.dynamic = FALSE;
    }
    return status ;
} /* end of SMIBuildDateAndTime() */


/*
 *  SMIGetInternationalDisplayString
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 *    
 *    Encompasses the callouts to variables for the data type InternationalDisplayString
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmio.c v 0.5
 */

UINT
SMIGetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    InternationalDisplayString outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;  // dummy holder for future use

    outvalue.string = stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        if (outvalue.length > 0)
        {
            VarBind->value.asnValue.string.stream =
                SNMP_malloc( outvalue.length * sizeof( char ) ) ;
            if ( VarBind->value.asnValue.string.stream == NULL )
            {
                VarBind->value.asnValue.string.length = 0;
                VarBind->value.asnType = ASN_OCTETSTRING ;
                VarBind->value.asnValue.string.stream = NULL;
                VarBind->value.asnValue.string.dynamic = FALSE ;
                result = SNMP_ERRORSTATUS_GENERR ;
            }
            else
            {
                memcpy( VarBind->value.asnValue.string.stream ,
                        outvalue.string ,
                        outvalue.length ) ;
                VarBind->value.asnValue.string.length = outvalue.length ;
                VarBind->value.asnType = ASN_OCTETSTRING ;
                VarBind->value.asnValue.string.dynamic = TRUE ;
            }
        }
        else
        {
            VarBind->value.asnValue.string.stream = NULL;
            VarBind->value.asnValue.string.length = 0;
            VarBind->value.asnType = ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = FALSE ;
        }
    }
    return result ;
} /* end of SMIGetInternationalDisplayString() */

/*
 *  SMISetInternationalDisplayString
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 *    
 *    Encompasses the callouts to variables for the data type InternationalDisplayString
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result  = SNMP_ERRORSTATUS_NOERROR ;
    InternationalDisplayString invalue ;
    InternationalDisplayString outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;   // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result;
} /* end of SMISetInternationalDisplayString() */

/*
 *  SMIBuildInternationalDisplayString
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 *    
 *    Places the variable of datatype InternationalDisplayString into a Variable Binding
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      invalue                   address of the data
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue )
{
    OctetString *svalue = (OctetString *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    if (svalue->length)
    {
        VarBind->value.asnValue.string.stream =
            SNMP_malloc( svalue->length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
        {
            VarBind->value.asnValue.string.length = 0;
            VarBind->value.asnType = ASN_OCTETSTRING;
            VarBind->value.asnValue.string.dynamic = FALSE;
            status = SNMP_ERRORSTATUS_GENERR ;
        }
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    svalue->string ,
                    svalue->length ) ;
            VarBind->value.asnValue.string.length = svalue->length ;
            VarBind->value.asnType = ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    else
    {
        VarBind->value.asnValue.string.stream = NULL;
        VarBind->value.asnValue.string.length = 0;
        VarBind->value.asnType = ASN_OCTETSTRING;
        VarBind->value.asnValue.string.dynamic = FALSE;
    }

    return status ;
} /* end of SMIBuildInternationalDisplayString() */


/*
 *  SMIGetProductID
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 *    
 *    Encompasses the callouts to variables for the data type ProductID
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtsmib.c v 0.5
 */

UINT
SMIGetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    UINT status ;
    ProductID outvalue ;
    Access_Credential access ;  // dummy holder for future use

    memset( &outvalue, '\0', sizeof( ProductID ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        status = SNMP_oidcpy( &VarBind->value.asnValue.object, &outvalue ) ;

        if ( !status )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;
        }
        if ( outvalue.idLength != 0 )
            SnmpUtilOidFree( &outvalue ) ;
    }
    return result ;
} /* end of SMIGetProductID() */

/*
 *  SMISetProductID
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 *    
 *    Encompasses the callouts to variables for the data type ProductID
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      cindex                    index to the class of the request
 *      vindex                    index to the variable of the request
 *      instance                  address of the instance specification
 *                                in the form of ordered native datatypes
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMISetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    ProductID *invalue ;
    ProductID outvalue ;
    Access_Credential access ;   // dummy holder for future use

    invalue = (ProductID *)&VarBind->value.asnValue.object ;
    memset( &outvalue, '\0', sizeof( ProductID ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    if ( outvalue.idLength != 0 )
        SnmpUtilOidFree( &outvalue ) ;
    return result ;
} /* end of SMISetProductID() */


/*
 *  SMIBuildProductID
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 *    
 *    Encompasses the callouts to variables for the data type ProductID
 *
 *  Arguments:
 *  VarBind                   pointer to the variable value pair
 *      invalue                   address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 */

UINT
SMIBuildProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue )
{
    AsnObjectIdentifier *svalue = (AsnObjectIdentifier *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;
    UINT sts = TRUE ;

    sts = SNMP_oidcpy( &VarBind->value.asnValue.object ,
                       (AsnObjectIdentifier *)svalue ) ;
    if (!sts)
        status = SNMP_ERRORSTATUS_GENERR ;
    else
        VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;

    return status ;

} /* end of SMIBuildProductID() */


/* end of hostmsmi.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\heswinen.c ===
/*
 *  HrSWInstalledEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWInstalledEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:49:12 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>
#include <winsock.h>      /* For htons()           */

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions           */
#include <regstr.h>       /* For Registry-lookup on software     */
#include <winreg.h>       /* For Registry-lookup on software     */
#include <objbase.h>      /* For CoFileTimeToDosDateTime()       */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
BOOL Gen_SingleDevices( void );


/* AddSWInstalled - Add a row to HrSWInstalled Table */
BOOL AddSWInstalled( HKEY sw_key,  FILETIME *ft);


#if defined(CACHE_DUMP)

/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */
static void
debug_print_hrswinstalled(
                        CACHEROW     *row  /* Row in hrSWInstalled table */
                        );
#endif

/*
|==============================================================================
| Create the list-head for the HrSWInstalled table cache.
|
| (This macro is defined in "HMCACHE.H").
*/
static CACHEHEAD_INSTANCE(hrSWInstalled_cache, debug_print_hrswinstalled);


/*
|==============================================================================
| hrSWInstalledTable Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
*/
#define HRIN_INDEX    0    // hrSWInstalledIndex
#define HRIN_NAME     1    // hrSWInstalledName
#define HRIN_DATE     2    // hrSWInstalledDate
                      //-->Add more here, change count below!
#define HRIN_ATTRIB_COUNT 3



/*
 *  GetHrSWInstalledIndex
 *    A unique value for each piece of software installed on the host.  This
 *    value shall be in the range from 1 to the number of piece
 *
 *    Gets the value for HrSWInstalledIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledIndex
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "A unique value for each piece of software installed on the host.  This value
 | shall be in the range from 1 to the number of pieces of software installed on
 | the host."
 |
 |============================================================================
 | 1.3.6.1.2.1.25.6.3.1.1.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledIndex
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledIndex(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWInstalled_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrSWInstalledIndex" value from this entry
*/
*outvalue = row->attrib_list[HRIN_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledIndex() */


/*
 *  GetHrSWInstalledName
 *    A textual description of this installed piece of software, including the
 *    manufacturer, revision, the name by which it is commonl
 *
 *    Gets the value for HrSWInstalledName.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledName
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE (0..64))
 |
 | "A textual description of this installed piece of software, including the
 | manufacturer, revision, the name by which it is commonly known, and
 | optionally, its serial number."
 |
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs, we use the Registry sub-key name.
 |
 | 1.3.6.1.2.1.25.6.3.1.2.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledName
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledName(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWInstalled_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrSWInstalledName" value from this entry
*/
outvalue->string = row->attrib_list[HRIN_NAME].u.string_value;

/* "Truncate" here to meet RFC as needed*/
if ((outvalue->length = strlen(outvalue->string)) > 64) {
    outvalue->length = 64;
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledName() */


/*
 *  GetHrSWInstalledID
 *    The product ID of this installed piece of software.
 *
 *    Gets the value for HrSWInstalledID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledID
 |
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 |
 | "The product ID of this installed piece of software."
 |
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs we don't know the ProductID as an OID, so we
 |    return the ProductID for "unknown": { 0.0 }
 |
 | 1.3.6.1.2.1.25.6.3.1.3.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledID
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledID(
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0"
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledID() */


/*
 *  GetHrSWInstalledType
 *    The type of this software.
 *
 *    Gets the value for HrSWInstalledType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledType
 |
 |  ACCESS         SYNTAX
 | read-only       INTEGER {unknown(1),operatingSystem(2),deviceDriver(3),
 |                          application(4)}
 |
 | "The type of this software."
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs we presume that all uninstallable software is
 |    an application.  That is the only type we return.
 |
 | 1.3.6.1.2.1.25.6.3.1.4.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledType
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledType(
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

*outvalue = 4;  // 4 = "application"

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledType() */


/*
 *  GetHrSWInstalledDate
 *    The last-modification date of this application as it would appear in a
 *    directory listing.
 *
 *    Gets the value for HrSWInstalledDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledDate
 |
 |  ACCESS         SYNTAX
 |  read-only      DateAndTime
 |
 | "The last-modification date of this application as it would appear in a
 |  directory listing."
 |============================================================================
 | DISCUSSION:
 |    For logo 95 programs we use the date of the last write into the
 |    Registry key associated with the application.
 |
 | 1.3.6.1.2.1.25.6.3.1.5.<instance>
 |                | | | |
 |                | | | *-hrSwInstalledDate
 |                | | *-hrSWInstalledEntry
 |                | *-hrSWInstalledTable
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledDate(
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWInstalled_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrSWInstalledDate" value from this entry
*/
outvalue->string = row->attrib_list[HRIN_DATE].u.string_value;
outvalue->length = 8;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledDate() */


/*
 *  HrSWInstalledEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWINSTALLEDENTRY_VAR_INDEX )
    // No instance was specified
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWINSTALLEDENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

    tmp_instance = FullOid->ids[ HRSWINSTALLEDENTRY_VAR_INDEX ] ;

        /*
        | For hrSWInstalledTable, the instance arc(s) is a single arc, and
        | it must correctly select an entry in the hrSWInstalled Table cache.
        | Check that here.
        */
    if ( FindTableRow(tmp_instance, &hrSWInstalled_cache) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
    }
    else
    {
        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.
        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledEntryFindInstance() */



/*
 *  HrSWInstalledEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSWINSTALLEDENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSWINSTALLEDENTRY_VAR_INDEX ] ;
    }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrSWInstalled_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
    }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledEntryFindNextInstance() */



/*
 *  HrSWInstalledEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWInstalledEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrSWInstalledEntryConvertInstance() */




/*
 *  HrSWInstalledEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWInstalledEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrSWInstalledTable */
} /* end of HrSWInstalledEntryFreeInstance() */

/*
| End of Generated Code
*/


/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table */
/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table */
/* Gen_HrSWInstalled_Cache - Generate a cache for HrSWInstalled Table */

BOOL
Gen_HrSWInstalled_Cache(
                        void
                        )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrSWInstalled table,
|       "hrSWInstalled_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to
|       populate the cache for the HrSWInstalled table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
| DISCUSSION:
|
| This implementation of this entire group is rather problematical without the
| creation of a standard.  It certainly appears that many software manufacturers
| dutifully register SOMETHING in the Registry when software is installed,
| however there appears to be no rhyme nor reason to the information put into
| the Registry in leaves below the manufacturers name.  Consequently, for
| installed application software, there is no easy, reliable way of mapping
| the Registry information into entries in this table.
|
| It is clear that some consistent scheme seems to be currently implemented for
| Microsoft software, however the details of extracting it from the Registry
| (and whether or not all information needed for full population of entries in
| this table is available) is not documented.
|
| Proper implementation of "hrSWInstalled" requires the creation and
| promulgation of a standard for registering ISD software (presumably in the
| Registry).  Information in "hrSWInstalled" includes attributes with
| values of Object Identifiers.  Webenable Inc. is prepared to work with
| Microsoft in establishing a standard for registering software in a fashion
| that allows proper implementation of the "hrSWInstalled" table.
|
| Resolution:
|      Report only logo 95 compliant software initially.
|
|============================================================================
|
| 1.3.6.1.2.1.25.6.1.0....
|                | |
|                | *hrSWInstalledLastChange
|                *-hrSWInstalled
|
| 1.3.6.1.2.1.25.6.2.0....
|                | |
|                | *hrSWInstalledLastUpdateTime
|                *-hrSWInstalled
|
| 1.3.6.1.2.1.25.6.3.1....
|                | | |
|                | | *-hrSWInstalledEntry
|                | *-hrSWInstalledTable
|                *-hrSWInstalled
|
*/

#define SUBKEY_LEN 64   // Long enough for short key-name of software
{
HKEY     subkey;                        /* Handle of subkey for uninstall software */
DWORD    index;                         /* Index counter for enumerating subkeys   */
LONG     enum_status=ERROR_SUCCESS;     /* Status from subkey enumeration          */
CHAR     subkey_name[SUBKEY_LEN+1];     /* Subkey name returned here               */
DWORD    subkey_len=SUBKEY_LEN;         /* Subkey name buffer size                 */
FILETIME keytime;                       /* Time subkey was last written to         */
BOOL     add_status;                    /* Status from add-row operation           */
HKEY     sw_key;                        /* Handle of software key for value enum   */

// ensure null terminated string
subkey_name[SUBKEY_LEN] = 0;

if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,    // hkey - currently open
                 REGSTR_PATH_UNINSTALL, // subkey to open
                 0,                     // options
                 KEY_READ,              // Security access mask
                 &subkey
                 ) == ERROR_SUCCESS) {

    /* Enumerate the keys using the Uninstall subkey */
    for (index = 0; enum_status != ERROR_NO_MORE_ITEMS; index += 1) {

        subkey_len=SUBKEY_LEN;

        enum_status = RegEnumKeyEx(subkey,      // Enumerating this key
                                   index,       // next subkey index
                                   subkey_name, // Buffer to rcv subkey name
                                   &subkey_len, // Buffer size
                                   NULL,        // Reserved
                                   NULL,        // Class name buffer
                                   NULL,        // Class buffer size
                                   &keytime     // Time of last write to subkey
                                   );

        /* Skip if we didn't open OK */
        if (enum_status != ERROR_SUCCESS) {
            continue;
            }


        /* Now try for the software itself */
        if (RegOpenKeyEx(subkey,                // hkey - currently open
                         subkey_name,           // subkey to open
                         0,                     // options
                         KEY_READ,              // Security access mask
                         &sw_key
                         ) == ERROR_SUCCESS) {

            /* Now Enumerate the Values of this key */
            add_status =
                AddSWInstalled(sw_key,   // Key to obtain DisplayName
                               &keytime  // Date and Time installed
                               );
            RegCloseKey(sw_key);

            /* If something blew down below, bail out */
            if (add_status == FALSE) {

                RegCloseKey(subkey);
                return ( FALSE );
                }
            }
        }

        RegCloseKey(subkey);
    }

#if defined(CACHE_DUMP)
PrintCache(&hrSWInstalled_cache);
#endif

/* hrSWInstalled cache initialized */
return ( TRUE );
}


/* UTCDosDateTimeToLocalSysTime - converts UTC msdos date and time to local SYSTEMTIME structure */
/* UTCDosDateTimeToLocalSysTime - converts UTC msdos date and time to local SYSTEMTIME structure */
/* UTCDosDateTimeToLocalSysTime - converts UTC msdos date and time to local SYSTEMTIME structure */
void UTCDosDateTimeToLocalSysTime(WORD msdos_date, WORD msdos_time, LPSYSTEMTIME pSysTime)
{
    SYSTEMTIME utcSysTime;

    utcSysTime.wYear = (msdos_date >> 9) + 1980;
    utcSysTime.wMonth = ((msdos_date >> 5) & 0x0F);
    utcSysTime.wDay = (msdos_date & 0x1F);
    utcSysTime.wDayOfWeek = 0;
    utcSysTime.wHour = (msdos_time >> 11);
    utcSysTime.wMinute = ((msdos_time >> 5) & 0x3F);
    utcSysTime.wSecond = ((msdos_time & 0x1F) * 2);
    utcSysTime.wMilliseconds = 0;

    if (!SystemTimeToTzSpecificLocalTime(
             NULL,           // [in]  use active time zone
             &utcSysTime,    // [in]  utc system time
             pSysTime))      // [out] local time 
    {
        // if the utc time could not be converted to local time,
        // just return the utc time
        memcpy(&utcSysTime, pSysTime, sizeof(SYSTEMTIME));
    }
}


/* AddSWInstalled - Add a row to HrSWInstalled Table */
/* AddSWInstalled - Add a row to HrSWInstalled Table */
/* AddSWInstalled - Add a row to HrSWInstalled Table */

BOOL
AddSWInstalled(
               HKEY         sw_key,
               FILETIME    *ft
               )
/*
|  EXPLICIT INPUTS:
|
|       "sw_key" - an opened key for a piece of software whose Values we
|        must enumerate looking for "DisplayName"
|
|       "ft" - This is the time that the key was last written, and we
|       take it as the time the software was installed.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrSWInstalled table,
|       "hrSWInstalled_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|     The Gen_SWInstalled_cache() function has been invoked to populate
|     the cache, and this function is called when it has found another
|     piece of software for which a row-entry needs to be placed into
|     the cache.
|
|  OTHER THINGS TO KNOW:
|
*/

#define VALUE_LEN 32         // Long enough for "UninstallString"
#define VALUE_DATA_LEN 128   // Long enough for a long "casual" name
{
DWORD    index;                         /* Index counter for enumerating subkeys   */
LONG     enum_status=ERROR_SUCCESS;     /* Status from subkey enumeration          */
CHAR     value_name[VALUE_LEN+1];       /* Value name returned here                */
DWORD    value_len;                     /* Value name buffer size                  */
DWORD    value_type;                    /* Type code for value string              */
CHAR     value_data[VALUE_DATA_LEN+1];  /* Value's value returned here          */
DWORD    value_data_len;                /* Value's value buffer length resides here*/

static                                  /* NOTE: "static" is a 'must'              */
ULONG    table_index=0;                 /* HrDeviceTable index counter             */
CACHEROW *row;                          /* --> Cache structure for row-being built */
WORD     msdos_date;                    /* Conversion area for software date/time  */
WORD     msdos_time;                    /* Conversion area for software date/time  */
char    *octet_string;                  /* Alias for building DateAndTime          */
UINT     i;                             /* Loop index                              */

// make sure null terminated buffer
value_name[VALUE_LEN] = 0;
value_data[VALUE_DATA_LEN] = 0;

/*
| Now go a-lookin' for "DisplayName", the value whose data will give us
| the name of the installed software.
|
| For each Value associated with this software's key . . .
*/
for (index = 0; enum_status != ERROR_NO_MORE_ITEMS; index += 1) {

    /* Make sure these cells continues to reflect the buffer size */
    value_len = VALUE_LEN;
    value_data_len = VALUE_DATA_LEN;

    enum_status = RegEnumValue(sw_key,        // Key whose values we're enuming
                               index,         // index of next value
                               value_name,    // Value name buffer
                               &value_len,    // length of Value name buffer
                               NULL,          // reserved
                               &value_type,   // type of value data
                               value_data,    // Buffer for value's data
                               &value_data_len// Length of data buffer
                               );

    /* Only if we managed to fetch this key do we try to recognize it */
    if (enum_status == ERROR_SUCCESS) {

        /* If the value we just read is for "DisplayName" */
        if ( strcmp(value_name, REGSTR_VAL_UNINSTALLER_DISPLAYNAME) == 0) {

            /*
            | Get a row-entry created.
            */
            if ((row = CreateTableRow( HRIN_ATTRIB_COUNT ) ) == NULL) {
                return ( FALSE );       // Out of memory
                }

            /*
            | Set up the cached hrSWInstalled attributes in the new row
            */

            /* =========== hrSWInstalledIndex ==========*/
            row->attrib_list[HRIN_INDEX].attrib_type = CA_NUMBER;
            row->attrib_list[HRIN_INDEX].u.unumber_value = (table_index += 1) ;


            /* =========== hrSWInstalledName ==========*/
            row->attrib_list[HRIN_NAME].attrib_type = CA_STRING;
            if ( (row->attrib_list[HRIN_NAME].u.string_value
                  = ( LPSTR ) malloc(value_data_len+1)) == NULL) {
                return ( FALSE );       /* out of memory */
                }

            strcpy(row->attrib_list[HRIN_NAME].u.string_value, value_data);


            /* =========== hrSWInstalledDate ==========
            |
            | Here's the deal on this one.  We've got a 64-bit FILETIME
            | representation of when the Registry entry was made for the
            | software. We're taking this as the install time of the software.
            |
            | So we convert to MS-DOS time, then to DateAndTime (in the
            | 8-octet form) below:
            |========================== From RFC1514 ========================
            |
            |    DateAndTime ::= OCTET STRING (SIZE (8 | 11))
            |    --     A date-time specification for the local time of day.
            |    --     This data type is intended to provide a consistent
            |    --     method of reporting date information.
            |    --
            |    --         field  octets  contents                  range
            |    --         _____  ______  ________                  _____
            |    --           1      1-2   year                      0..65536
            |    --                           (in network byte order)
            |    --           2       3    month                     1..12
            |    --           3       4    day                       1..31
            |    --           4       5    hour                      0..23
            |    --           5       6    minutes                   0..59
            |    --           6       7    seconds                   0..60
            |    --                        (use 60 for leap-second)
            |    --           7       8    deci-seconds              0..9
            |    --           8       9    direction from UTC        "+" / "-"
            |    --                        (in ascii notation)
            |    --           9      10    hours from UTC            0..11
            |    --          10      11    minutes from UTC          0..59
            |    --
            |    --         Note that if only local time is known, then
            |    --         timezone information (fields 8-10) is not present.
            |
            |    MS-DOS records file dates and times as packed 16-bit values.
            |    An MS-DOS date has the following format:
            |    Bits   Contents
            |    ----   --------
            |    0-4    Days of the month (1-31).
            |    5-8    Months (1 = January, 2 = February, and so forth).
            |    9-15   Year offset from 1980 (add 1980 to get actual year).
            |
            |    An MS-DOS time has the following format:
            |    Bits   Contents
            |    ----   --------
            |    0-4    Seconds divided by 2.
            |    5-10   Minutes (0-59).
            |    11-15  Hours (0-23 on a 24-hour clock).
            |
            */
            row->attrib_list[HRIN_DATE].attrib_type = CA_STRING;
            if ( (row->attrib_list[HRIN_DATE].u.string_value
                        = octet_string = ( LPSTR ) malloc(8)) == NULL) {
                return ( FALSE );       /* out of memory */
                }
            for (i=0; i < 8; i += 1) octet_string[i] = '\0';

            if (CoFileTimeToDosDateTime(ft, &msdos_date, &msdos_time) == TRUE) {
                SYSTEMTIME localInstTime;
                USHORT year;

                UTCDosDateTimeToLocalSysTime(msdos_date, msdos_time, &localInstTime);

                year = htons(localInstTime.wYear);
                octet_string[0] = (year & 0xFF);
                octet_string[1] = (year >> 8);
                octet_string[2] = (char)localInstTime.wMonth;
                octet_string[3] = (char)localInstTime.wDay;
                octet_string[4] = (char)localInstTime.wHour;
                octet_string[5] = (char)localInstTime.wMinute;
                octet_string[6] = (char)localInstTime.wSecond;
                octet_string[7] = (char)localInstTime.wMilliseconds / 10;
                }

            /*
            | The other standard hrSWInstalled attributes are currently
            | "hardwired" in the Get functions.
            */

            /*
            | Now insert the filled-in CACHEROW structure into the
            | cache-list for the hrDeviceTable.
            */
            if (AddTableRow(row->attrib_list[HRIN_INDEX].u.unumber_value,  /* Index */
                            row,                                           /* Row   */
                            &hrSWInstalled_cache                           /* Cache */
                            ) == FALSE) {
                return ( FALSE );       /* Internal Logic Error! */
                }

            /*
            | Break from the Enumeration loop on the values, we've found
            | the one we want.
            */
            break;
            }
        }
    }  /* for */

/* Add succeeded */
return ( TRUE );
}


#if defined(CACHE_DUMP)


/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */
/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */
/* debug_print_hrswinstalled - Prints a Row from HrSWInstalled table */

static void
debug_print_hrswinstalled(
                        CACHEROW     *row  /* Row in hrSWInstalled table */
                        )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{
UINT    i;

if (row == NULL) {
    fprintf(OFILE, "=========================\n");
    fprintf(OFILE, "hrSWInstalled Table Cache\n");
    fprintf(OFILE, "=========================\n");
    return;
    }

fprintf(OFILE, "hrSWInstalledIndex . . . . %d\n",
        row->attrib_list[HRIN_INDEX].u.unumber_value);

fprintf(OFILE, "hrSWInstalledName  . . . . %s\n",
        row->attrib_list[HRIN_NAME].u.string_value);

fprintf(OFILE, "hrSWInstalledDate  . . . . ");
for (i = 0; i < 8; i += 1) {
    fprintf(OFILE, "%2.2x ",row->attrib_list[HRIN_DATE].u.string_value[i]);
    }
fprintf(OFILE, "\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hmcache.c ===
/*
*
*
*  Facility:
*
*    SNMP Extension Agent
*
*  Abstract:
*  
*    This module contains support functions for the creation and
*    maintenance of the in-memory cache for the HostMIB Subagent.
*
*
*  Author:
*
*    D. D. Burns @ WebEnable, Inc.
*
*
*  Revision History:
*
*    V1.00 - 04/17/97  D. D. Burns     Original Creation
*
*
*/


/*
Host-MIB Cache Overview
-----------------------

This module contains functions that create, maintain and allow for searching
data structures that are used to implement a cache of HOST-MIB information.

Typically, a cache is created on a "per-table" basis and is formed as a
linked-list of CACHEROW structures (all cache structures are defined in
"HMCACHE.H"), one CACHEROW structure for each logical "row" in the table.

The list-head of each cache is a CACHEHEAD structure and is instantiated in
the source module for the functions that service the attributes in that
table (so the CACHEHEAD structure for the cache for the "hrStorage" table is
in module "HRSTOENT.C").

Caches are created at start-up time by special cache-creation functions (coded
to the specs for each table) in each of the "table" source modules.  Those
cache-creation functions (plus the associated "get" and "set" functions) use
the general cache manipulation functions in this module.

For example, a typical cache looks like this:

      HrStorage Table Cache
        "hrStorage_cache"
      (statically allocated
         in "HRSTOENT.C")...

       *============*
       |  CACHEHEAD |
       |  "list"....|--*          ..(Malloced as a single instance in function
       *============*  |          .  "CreateTableRow")
                       V          .
                      *================*                ..(Malloced as an
                      |    CACHEROW    |                . array in function
                   *--|...."next"      |                . "CreateTableRow()")
                   |  |    "index".....|--> "1"         .
                   |  | "attrib_list"..|--> *===============*
                   |  *================*    |    ATTRIB     |
                   |                        | "attrib_type".|-->CA_NUMBER
                   |                        | "u.unumber"...|-->"4"
                   |                        +---------------+
                   |                        |    ATTRIB     |
                   |                        | "attrib_type".|-->CA_STRING
                   |                        | "u.string"....|-->"<string>"
                   |                        +---------------+
                   |                        |    ATTRIB     |
                   |                        | "attrib_type".|-->CA_CACHE
                   |                        |   "u.cache"...|------*
                   |                        +---------------+      |
                   |                                .              |
                   |  *=================*           .              |
                   *->|    CACHEROW     |           .              |
                   *--|...."next"       |                   *============*
                   |  |    "index"......|-->"2"             |  CACHEHEAD |
                   |  |  "attrib_list"..|-->                |  "list"....|--*
                   |  *=================*                   *============*  |
                   V                                         (For doubly    |
                                                              indexed       V
                                                              tables)

The general cache manipulation functions in this module include:

Name                    Purpose
----                    -------
CreateTableRow          Creates an instance of a CACHEROW with a given
                        attribute count.  (This function does not link the
                        instance into any list, it merely mallocs storage).

AddTableRow             Given an index value, a CACHEROW instance (created by
                        "CreateTableRow()" above) and a CACHEHEAD, this
                        function links the CACHEROW instance into the list
                        described by CACHEHEAD in the proper place given the
                        index value.

         These two functions above are used to populate the cache 
         (typically at startup time).

Name                    Purpose
----                    -------
FindTableRow            Given an index value and a CACHEHEAD, this function
                        returns a pointer to the CACHEROW instance in the
                        CACHEHEAD cache that has the given index.  This 
                        function is used to find a given cache entry (ie table
                        "row") in service for a "get" or "set" routine.

FindNextTableRow        Given an index value and a CACHEHEAD, this function
                        returns a pointer to the CACHEROW instance in the
                        CACHEHEAD cache that IMMEDIATELY FOLLOWS the given
                        index.  This function is used to find a given cache
                        entry (ie table "row") in service for "get-next"
                        situations.

GetNextTableRow         Given a CACHEROW row (obtained using either of the
                        routines above), this gets the next entry regardless
                        of index (or NULL if the given row is the last row).
                        (Implemented as a macro in "HMCACHE.H").

RemoveTableRow          Given an index value and a CACHEHEAD, this function
                        unlinks the CACHEROW instance from the cache list
                        described by CACHEHEAD. (TBD in support of PNP)

DestroyTable            Given a pointer to a CACHEHEAD, this function releases
                        every row-instance in the cache (through calls to
                        "DestroyTableRow()" below).  This function presumes
                        that the CACHEHEAD itself is statically allocated.

DestroyTableRow         Given an instance of an (unlinked) CACHEROW, this
                        function releases the storage associated with it.


For Debugging:
Name                    Purpose
----                    -------
PrintCache              Prints a dump on an output file in ASCII of the 
                        contents of a specified cache.  Only works for caches
                        for which a "print-row" function is defined and
                        referenced in the CACHEHEAD structure for the cache.
*/



/*
| INCLUDES:
*/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>      /* for debug printf */
#include <time.h>       /* for debug support */
#include <malloc.h>

#include "hmcache.h"

/*
|==============================================================================
| Debug File Channel
|
*/
#if defined(CACHE_DUMP) || defined(PROC_CACHE)
FILE *Ofile;
#endif




/* CreateTableRow - Create a CACHEROW structure for attributes in a table */
/* CreateTableRow - Create a CACHEROW structure for attributes in a table */
/* CreateTableRow - Create a CACHEROW structure for attributes in a table */

CACHEROW *
CreateTableRow(
               ULONG attribute_count
              )

/*
|  EXPLICIT INPUTS:
|
|       "attribute_count" indicates how much storage to allocate for the
|       array of attributes for this row.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to allocated storage containing an
|       image of a CACHEROW structure.  Enough storage for each attribute
|       in the row has been allocated within array "attrib_list[]" and the
|       count of these elements has been stored in the CACHEROW structure.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the caches for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code for each table to create one CACHEROW
|       structure for each row needed in the table.
|
|       With the advent of PNP, this function can be called after startup
|       time to add rows to an existing table.
|
|       (Note: The actual insertion of an instance returned by this function
|              into a cache table list is done by function "AddTableRow()" ).
|
|  OTHER THINGS TO KNOW:
|
|       "DestroyTableRow()" deallocates storage associated with any instance
|       of a CACHEROW structure created by this function.
|
*/
{
CACHEROW        *new=NULL;      /* New CACHEROW instance to be created */
ULONG           i;              /* handy-dandy Index                   */


/* Create the main CACHEROW structure to be returned . . . */
if ( (new = (CACHEROW *) malloc(sizeof(CACHEROW))) == NULL) {

    /* "Not Enough Storage" */
    return (NULL);
    }

/*
| Now try to allocate enough storage for the array of attributes in this row
*/
if ( (new->attrib_list = (ATTRIB *) malloc(sizeof(ATTRIB) * attribute_count))
    == NULL) {

    /* "Not Enough Storage" */
    free( new ) ;       /* Blow off the CACHEROW we won't be returning */
    return (NULL);
    }

/* Indicate how big this array is so DestroyTableRow() can do the right thing*/
new->attrib_count = attribute_count;

/* Zap each array entry so things are clean */
for (i = 0; i < attribute_count; i += 1) {
    new->attrib_list[i].attrib_type = CA_UNKNOWN;
    new->attrib_list[i].u.string_value = NULL;
    }


new->index = 0;         /* No legal index yet        */
new->next = NULL;       /* Not in the cache list yet */


/* Return the newly allocated CACHEROW structure for further population */
return ( new ) ;
}

/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */
/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */
/* DestroyTable - Destroy all rows in CACHEHEAD structure (Release Storage) */

void
DestroyTable(
             CACHEHEAD *cache   /* Cache whose rows are to be Released */
             )

/*
|  EXPLICIT INPUTS:
|
|       "cache" is the CACHEHEAD instance of a table for which all rows are
|       to be released.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       Function returns, the CACHEHEAD is set to reflect an empty cache.
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the caches for each table in the MIB is
|       populated with rows for each row in the table.  "CreateTableRow" is
|       invoked by the start-up code for each table to create one CACHEROW
|       structure for each row needed in the table.
|
|       With the advent of PNP, this function can be called after startup
|       time to delete all storage associated with such a cache.
|
|
|  OTHER THINGS TO KNOW:
|
|       This function may be recursively invoked through the call to
|       "DestroyTable()" inside "DestroyTableRow()".
|
|       This function may be safely invoked on an "empty" cache-head.
|
|       This function doesn't attempt to release storage associated with
|       the CACHEHEAD structure itself.
|
|  DOUBLE NOTE:
|       This function simply releases storage.  You can't go calling this
|       function willy-nilly on just any cache without taking into
|       consideration the semantics of what maybe being blown away. For
|       instance, some tables in Host MIB contain attributes whose values
|       are indices into other tables.  If a table is destroyed and rebuilt,
|       clearly the references to the rebuilt table must be refreshed in
|       some manner.
*/
{

/*
| If an old copy of the cache exists, blow it away now
*/
while (cache->list != NULL) {

    CACHEROW    *row_to_go;

    /* Pick up the row to blow away */
    row_to_go = cache->list;

    /* Change the cache-head to point to the next row (if any) */
    cache->list = GetNextTableRow(row_to_go);

    DestroyTableRow(row_to_go);
    }

/* Show no entries in the cache */
cache->list_count = 0;
}

/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */
/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */
/* DestroyTableRow - Destroy a CACHEROW structure (Release Storage) */

void
DestroyTableRow(
                CACHEROW *row   /* Row to be Released */
                )

/*
|  EXPLICIT INPUTS:
|
|       "row" is the instance of a row to be released.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       Function returns.
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the caches for each table in the MIB is
|       populated with rows for each row in the table.  "CreateTableRow" is
|       invoked by the start-up code for each table to create one CACHEROW
|       structure for each row needed in the table.
|
|       With the advent of PNP, this function can be called after startup
|       time to delete storage associated with rows being replaced in an
|       existing table.
|
|       (Note: The actual deletion of an row instance from a cache table list
|              must be done before this function is called).
|
|  OTHER THINGS TO KNOW:
|
|       "CreateTableRow()" creates an instance of what this function
|       "destroys".
|
|       This function may be recursively invoked through the call to
|       "DestroyTable()" in the event we are release a row that contains
|       an attribute "value" that is really another table (in the case
|       of a multiply-indexed attribute).
|
|  DOUBLE NOTE:
|       This function simply releases storage.  You can't go calling this
|       function willy-nilly on just any cache without taking into
|       consideration the semantics of what maybe being blown away. For
|       instance, some tables in Host MIB contain attributes whose values
|       are indices into other tables.  If a row is destroyed, clearly the
|       references to the row must be refreshed in some manner.
*/
{
CACHEROW        *new=NULL;      /* New CACHEROW instance to be created */
ULONG           i;              /* handy-dandy Index                   */


/* Zap storage associated each attribute entry (if any) */
for (i = 0; i < row->attrib_count; i += 1) {

    /* Blow off storage for attribute values that have malloc-ed storage */
    switch (row->attrib_list[i].attrib_type) {

        case CA_STRING:
            if ( row->attrib_list[i].u.string_value )
                free( row->attrib_list[i].u.string_value );
            break;


        case CA_CACHE:
            /* Release the contents of the entire cache */
            if (row->attrib_list[i].u.cache)
            {
                DestroyTable( row->attrib_list[i].u.cache );
                /* Free the storage containing the cache */
                free( row->attrib_list[i].u.cache );
            }
            break;

        
        case CA_NUMBER:
        case CA_COMPUTED:
        case CA_UNKNOWN:
            /* No malloced storage associated with these types */
        default:
           break;
        }
    }


/* Free the storage associated with the array of attributes */
free( row->attrib_list);

/* Free the storage for the row itself */
free( row );
}

/* AddTableRow - Adds a specific "row" into a cached "table" */
/* AddTableRow - Adds a specific "row" into a cached "table" */
/* AddTableRow - Adds a specific "row" into a cached "table" */

BOOL
AddTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEROW   *row,           /* Row to be added to .. */
             CACHEHEAD  *cache          /* this cache            */
              )

/*
|  EXPLICIT INPUTS:
|
|       "index" is index inserted into "row" before the
|       "row" is added to "cache".
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the row was successfully
|       added to the cache for the table.
|
|     On Failure:
|       Function returns FALSE, indicating that the row already
|       existed.
|
|  THE BIG PICTURE:
|
|       At startup time the subagent is busy populating the cache for
|       each table.  The rows in any cached table are inserted into
|       the cache by this function.
|
|  OTHER THINGS TO KNOW:
|
|       Code in this function presumes that the list (cache) is in sorted index
|       order.
|
|       Any change of organization of the linked list that constitutes the
|       cache will impact this function and "Find(Next)TableRow()".
|
*/
{
CACHEROW       **index_row;     /* Used for searching cache              */
                                /* NOTE: It always points at a cell that */
                                /*       points to the next list element */
                                /*       (if any is on the list).        */


/* Whip down the list until there is no "next" or "next" is "bigger" . . . */
for ( index_row = &cache->list;
      *index_row != NULL;
      index_row = &((*index_row)->next)
     ) {

    /* If this row MATCHES the to-be-inserted row: Error! */
    if ((*index_row)->index == index) {
        return ( FALSE );
        }

    /*
    | If next cache entry is "Greater Than" new index, then
    | "index_row" points to the cell that should be changed to insert
    | the new entry.
    */
    if ((*index_row)->index > index) {
        break;
        }

    /* Otherwise we should try for a "next" entry in the list */
    }


/*
| When we fall thru here "index_row" contains the address of the cell to
| change to add the new row into the cache (might be in the list-head, 
| might be in a list-entry)
*/
row->next = *index_row;   /* Put cache-list "next" into new row element */
*index_row = row;         /* Insert new row into the list               */

row->index = index;       /* Stick the index into the row entry itself  */

cache->list_count += 1;   /* Count another entry on the cache list      */


/* Successful insertion */
return (TRUE);
}

/* FindTableRow - Finds a specific "row" in a cached "table" */
/* FindTableRow - Finds a specific "row" in a cached "table" */
/* FindTableRow - Finds a specific "row" in a cached "table" */

CACHEROW *
FindTableRow(
             ULONG      index,          /* Index for row desired */
             CACHEHEAD  *cache          /* Table cache to search */
              )

/*
|  EXPLICIT INPUTS:
|
|       "index" indicates which table row entry is desired
|       "cache" indicates the cache list to search for the desired row.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to the instance of a CACHEROW structure
|       for the desired row.
|
|     On any Failure:
|       Function returns NULL (indicating "no such entry" or "cache empty").
|
|  THE BIG PICTURE:
|
|       As the subagent runs, the "get" functions for the attributes that do
|       not "compute" their values dynamically must lookup cached values.
|
|       This function can be used by any "get" function that knows the
|       CACHEHEAD for it's table to find a specific row containing an
|       attribute value to be returned.
|
|  OTHER THINGS TO KNOW:
|
|       Code in this function presumes that the list is in sorted index
|       order (hence it gives up once encountering an entry whose index
|       is "too big").
|
|       Any change of organization of the linked list that constitutes the
|       cache will impact this function and "AddTableRow()".
|
*/
{
CACHEROW        *row=NULL;   /* Row instance to be returned, initially none */


/* Whip down the list until there is no next . . */
for ( row = cache->list; row != NULL; row = row->next ) {

    /* If this is "It": Return it */
    if (row->index == index) {
        return ( row );
        }

    /* If this is "Greater Than IT", it's not in the list: Return NULL */
    if (row->index > index) {
        return ( NULL );
        }

    /* Otherwise we should try for a "next" entry in the list */
    }


/*
| If we fall thru here we didn't find the desired entry because the cache
| list is either empty or devoid of the desired row.
*/
return (NULL);

}

/* FindNextTableRow - Finds Next row after a given "index" in a cache */
/* FindNextTableRow - Finds Next row after a given "index" in a cache */
/* FindNextTableRow - Finds Next row after a given "index" in a cache */

CACHEROW *
FindNextTableRow(
                 ULONG      index,          /* Index for row desired */
                 CACHEHEAD  *cache          /* Table cache to search */
                 )

/*
|  EXPLICIT INPUTS:
|
|       "index" indicates which table row entry AFTER WHICH the NEXT is
|               desired.  The "index" row need not exist (could be before
|               the first row or a missing row "in the middle", but
|               it may not specify a row that would be after the
|               last in the table.
|
|       "cache" indicates the cache list to search for the desired row.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to the instance of a CACHEROW structure
|       for the desired NEXT row.
|
|     On any Failure:
|       Function returns NULL (indicating "no such entry", "cache empty" or
|                              "end-of-cache" reached).
|
|  THE BIG PICTURE:
|
|       As the subagent runs, the "get-next" functions for the attributes 
|       that do not "compute" their values dynamically must lookup cached 
|       values.
|
|       This function can be used by any "FindNextInstance" function that
|       knows the CACHEHEAD for it's table to find the NEXT row following a
|       specific row containing an attribute value to be returned.
|
|  OTHER THINGS TO KNOW:
|
|       To get the first entry in a table, supply an ("illegal") index of 0.
|
|       Any change of organization of the linked list that constitutes the
|       cache will impact this function, "FindTableRow()" and "AddTableRow()".
|
*/
{
CACHEROW        *row=NULL;   /* Row instance to be returned, initially none */


/*
| If there is a non-empty cache and the input "index" is less than
| the first entry in the cache, simply return the first entry.
*/
if (   cache->list != NULL         /* If there is a non-empty cache . . . */
    && index < cache->list->index  /* AND index is LESS THAN first entry  */
    ) {

    /* Return the first entry in the table */
    return (cache->list);
    }

/* Whip down the list until there is no next . . */
for ( row = cache->list; row != NULL; row = row->next ) {

    /* If "index" specifies THIS ROW . . . */
    if (row->index == index) {
        return ( row->next );   /* Return NEXT (or NULL if no "next") */
        }

    /* If this is "Greater Than IT", "index" is not in the list */
    if (row->index > index) {
        return ( row  );        /* Return CURRENT, it is Greater than "index"*/
        }

    /* Otherwise we should try for a "next" entry in the list */
    }

/*
| If we fall thru here then the cache is empty or the "index" specifies
| a row after the last legal row.
*/
return (NULL);
}


#if defined(CACHE_DUMP)

/* PrintCache - Dumps for debugging the contents of a cache */
/* PrintCache - Dumps for debugging the contents of a cache */
/* PrintCache - Dumps for debugging the contents of a cache */

void
PrintCache(
           CACHEHEAD  *cache          /* Table cache to dump */
           )

/*
|  EXPLICIT INPUTS:
|
|       "cache" indicates the cache whose contents is to be dumped.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns.  It may be called recursively by a "Print-Row"
|       function.
|
|
|  THE BIG PICTURE:
|
|     For debugging only.
|
|  OTHER THINGS TO KNOW:
|
|     Define "CACHE_DUMP" at the top of "HMCACHE.H" to enable this debug
|     support.  You can change the file into which output goes by modifying
|     "DUMP_FILE", also in "HMCACHE.H".
|
*/

#define DO_CLOSE  \
   { if ((open_count -= 1) == 0) { fclose(OFILE); } }

{
CACHEROW        *row;                   /* Row instance to dump. */
UINT            i;                      /* Element counter       */
time_t          ltime;                  /* For debug message     */
static
UINT            open_count=0;         /* We can be called recursively */

/* Avoid a recursive open */
if (open_count == 0) {

    /* Open the debug log file */
    if ((Ofile=fopen(DUMP_FILE, "a+")) == NULL) {
        return;
        }

    /*
    | Put a time stamp into the debug file because we're opening for append.
    */
    time( &ltime);
    fprintf(OFILE, "=============== Open for appending: %s\n", ctime( &ltime ));
    }

open_count += 1;

if (cache == NULL) {
    fprintf(OFILE, "Call to PrintCache with NULL CACHEHEAD pointer.\n");

    DO_CLOSE;
    return;
    }

if (cache->print_row == NULL) {
    fprintf(OFILE,
            "Call to PrintCache with NULL CACHEHEAD Print-Routine pointer.\n");

    DO_CLOSE;
    return;
    }

/* Print a Title */
cache->print_row(NULL);

fprintf(OFILE, "Element Count: %d\n", cache->list_count);

/* For every row in the cache . . . */
for (row = cache->list, i = 0; row != NULL; row = row->next, i += 1) {

    fprintf(OFILE, "\nElement #%d, Internal Index %d,  at 0x%x:\n",
            i, row->index, row);

    cache->print_row(row);
    }

fprintf(OFILE, "======== End of Cache ========\n\n");

DO_CLOSE;

}

#endif  // defined(CACHE_DUMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hostmsmi.h ===
/*
 *  mibtsmi.nth  v0.10
 *  hostmsmi.h
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the user defined type definitions.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:31 1996
 *
 *  Revision History:
 *      generated with v0.10 stub
 *
 */

#if !defined(_HOSTMSMI_H_)
#define _HOSTMSMI_H_

#include <snmp.h>
#include "smint.h"
/*
 *    Boolean ::= INTEGER a truth value
 */
typedef enum
{
    true = 1 ,
    false = 2
} Boolean ;
/*
 *    KBytes ::= INTEGER (0..2147483647)  memory size, expressed in units of 
 *    1024 bytes
 */
typedef Integer KBytes ;
/*
 *    INThrDeviceStatus ::= INTEGER 
 */
typedef enum
{
    unknown0 = 1 ,
    running0 = 2 ,
    warning0 = 3 ,
    testing0 = 4 ,
    down0 = 5
} INThrDeviceStatus ;
/*
 *    INThrPrinterStatus ::= INTEGER 
 */
typedef enum
{
    other1 = 1 ,
    unknown1 = 2 ,
    idle1 = 3 ,
    printing1 = 4 ,
    warmup1 = 5
} INThrPrinterStatus ;
/*
 *    INTAccess ::= INTEGER 
 */
typedef enum
{
    readWrite = 1 ,
    readOnly = 2
} INTAccess ;
/*
 *    INThrDiskStorageMedia ::= INTEGER 
 */
typedef enum
{
    other = 1 ,
    unknown = 2 ,
    hardDisk = 3 ,
    floppyDisk = 4 ,
    opticalDiskROM = 5 ,
    opticalDiskWORM = 6 , /* Write once Read Many */
    opticalDiskRW = 7 ,
    ramDisk = 8
} INThrDiskStorageMedia ;
/*
 *    INTSWType ::= INTEGER 
 */
typedef enum
{
    unknown2 = 1 ,
    operatingSystem2 = 2 ,
    deviceDriver2 = 3 ,
    application2 = 4
} INTSWType ;
/*
 *    INThrSWRunStatus ::= INTEGER 
 */
typedef enum
{
    running = 2 ,
    runnable = 2 , /* waiting for resource (CPU, memory, IO) */
    notRunnable = 3 , /* loaded but waiting for event */
    invalid = 4 /* not loaded */
} INThrSWRunStatus ;
/*
 *    DateAndTime ::= OCTET STRING (SIZE ( 8 | 11))  A date-time specification 
 *    for the local time of day.  This data type is intended toprovide a consistent method of  reporting 
 *    dat
 */
typedef OctetString DateAndTime ;
/*
 *    InternationalDisplayString ::= OCTET STRING This data type is used to 
 *    model textual information in some character set.  A network management station should use a local 
 *    algo
 */
typedef OctetString InternationalDisplayString ;
/*
 *    ProductID ::= OBJECT IDENTIFIER This textual convention is intended to 
 *    identify the manufacturer, model, and version of a specific hardware or software 
 *    product.
 */
typedef ObjectIdentifier ProductID ;
#endif /*_HOSTMSMI_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hostmib.c ===
/*
 *  gendll.c v0.11   March 14, 1996
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995, 1996 DIGITAL EQUIPMENT CORPORATION              *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for plugging into the Windows NT Extendible
 *    Agent.  It contains the dll's main routine and the three exported SNMP
 *    routines.
 *
 *  Functions:
 *
 *    DllMain()
 *    SnmpExtensionInit()
 *    SnmpExtensionTrap()
 *    SnmpExtensionQuery()
 *
 *  Author:
 *    Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *    2/17/95
 *
 *  Revision History:
 *    6/26/95 KKF, register using Subroot_oid
 *    7/31/95 ags  readded above code + uncommented calls to SNMP_oidfree
 *    3/14/96 kkf, modified SNMPExtensionTrap
 */



// General notes:
//
// Microsoft's Extendible Agent for Windows NT is implemented by dynamically
// linking to Extension Agent DLLs that implement portions of the MIB.  These
// Extension Agents are configured in the Windows NT Registration Database.
// When the Extendible Agent Service is started, it queries the registry to
// determine which Extension Agent DLLs have been installed and need to be
// loaded and initialized.  The Extendible Agent invokes various DLL entry
// points (examples follow in this file) to request MIB queries and obtain
// Extension Agent generated traps.


// Necessary includes.

#include <windows.h>
#include <malloc.h>
#include <stdio.h>

#include <snmp.h>

//
// The file mib.h is a user supplied header file (could be from a code
// generator).  This file should contain the definition, macros, forward
// declarations, etc.  The file mib_xtrn.h contains the external
// declarations for the variable tables and classes composing this MIB.
//

#include "mib.h"
#include "mib_xtrn.h"


// Extension Agent DLLs need access to the elapsed time that the agent has
// been active.  This is implemented by initializing the Extension Agent
// with a time zero reference, and allowing the agent to compute elapsed
// time by subtracting the time zero reference from the current system time.
// This example Extension Agent implements this reference with dwTimeZero.

DWORD dwTimeZero = 0 ;
extern DWORD dwTimeZero ;

//
// Trap Queue
//

q_hdr_t trap_q = { NULL, NULL } ;

extern q_hdr_t trap_q ;  // make it global
HANDLE hTrapQMutex ;
extern HANDLE hTrapQMutex ;
HANDLE hEnabledTraps ;
extern HANDLE hEnabledTraps ;



/*
 *  DllMain
 *
 *    This is a standard Win32 DLL entry point.  See the Win32 SDK for more
 *    information on its arguments and their meanings.  This example DLL does
 *    not perform any special actions using this mechanism.
 *
 *  Arguments:
 *
 *  Results:
 *
 *  Side Effects:
 *
 */

BOOL WINAPI
DllMain( HINSTANCE    hInstDLL,
         DWORD        dwReason ,
         LPVOID       lpReserved )
{

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH :
            DisableThreadLibraryCalls( hInstDLL );
            break;
        case DLL_PROCESS_DETACH :
        case DLL_THREAD_ATTACH :
        case DLL_THREAD_DETACH :
        default :
            break ;

    }

    return TRUE ;

} /* end of DllMain() (the DllEntryPoint) */



/*
 *  SnmpExtensionInit
 *
 *    Extension Agent DLLs provide the following entry point to coordinate the
 *    initializations of the Extension Agent and the Extendible Agent.  The
 *    Extendible Agent provides the Extension Agent with a time zero reference;
 *    and the Extension Agent provides the Extendible Agent with an Event
 *    handle for communicating occurence of traps, and an object identifier
 *    representing the root of the MIB subtree that the Extension Agent
 *    supports.
 *
 *    Traps support is determined by the user in the UserMibInit() routine.
 *    If a valid handle from CreateEvent() is returned in the argument
 *    hPollForTrapEvent, then traps have been implemented and the SNMP
 *    Extendible Agent will poll this Extension Agent to retrieve the traps
 *    upon notification through the SetEvent() routine.  Polling is done
 *    through the SnmpExtensionTrap() routine.  If NULL is returned in the
 *    argument hPollForTrapEvent, there are no traps.
 *
 *  Arguments:
 *
 *  Results:
 *
 */

BOOL WINAPI
SnmpExtensionInit( IN DWORD dwTimeZeroReference ,
                   OUT HANDLE *hPollForTrapEvent ,
                   OUT AsnObjectIdentifier *supportedView )
{

    // Record the time reference provided by the Extendible Agent.

    dwTimeZero = dwTimeZeroReference ;


    // Indicate the MIB view supported by this Extension Agent, an object
    // identifier representing the sub root of the MIB that is supported.

    *supportedView = Subroot_oid ; // NOTE! structure copy
//    *supportedView = *(class_info[ 0 ].oid) ; // NOTE! structure copy

    // Call the User's initialization routine

    if ( !UserMibInit( hPollForTrapEvent ) )
        return FALSE ;

    // Indicate that Extension Agent initialization was successful.

    return TRUE ;

} /* end of SnmpExtensionInit() */



/*
 *  SnmpExtensionTrap
 *
 *    Extension Agent DLLs provide the following entry point to communicate
 *    traps to the Extendible Agent.  The Extendible Agent will query this
 *    entry point when the trap Event (supplied at initialization time) is
 *    asserted, which indicates that zero or more traps may have occured.
 *    The Extendible Agent will repetedly call this entry point until FALSE
 *    is returned, indicating that all outstanding traps have been processed.
 *
 *  Arguments:
 *
 *  Results:
 *
 |=========================================================================
 | There are no Traps associated with the HostMIB.  Consequently this
 | routine is taken over and used to refresh the cached information
 | associated with SNMP attribute "hrProcessorLoad" (in "HRPROCES.C") thru
 | a call to function "hrProcessLoad_Refresh()" (also in "HRPROCES.C").
 |
 | This function is being entered because a timer has expired that was
 | initialized by code in "TrapInit()" (in "GENNT.C").  The timer automatically
 | resets itself.
 |
 | All the standard generated code is subsumed by a simple call to
 | "hrProcessLoad_Refresh()".
 */

BOOL WINAPI
SnmpExtensionTrap( OUT AsnObjectIdentifier *enterprise ,
                   OUT AsnInteger *genericTrap ,
                   OUT AsnInteger *specificTrap ,
                   OUT AsnTimeticks *timeStamp ,
                   OUT RFC1157VarBindList *variableBindings )
{
#if 0
    tcb_t *entry ;

    // Traps are process by processing the traps on the trap queue.
    // The Extendible Agent will call this routine upon the receipt of
    // the event on the handle passed back in the SnmpExtensionInit routine.
    // The Extendible Agent calls this return back as long as this routine
    // returns true.

    // acquire mutex for trap_q
    WaitForSingleObject( hTrapQMutex, INFINITE ) ;

    // Dequeue a trap entry

    QUEUE_REMOVE( trap_q, entry ) ;

    // release the mutex for trap_q
    ReleaseMutex( hTrapQMutex ) ;

    if (entry == NULL)
       return FALSE ;

    *enterprise = entry->enterprise ;  // note structure copy
    *genericTrap = entry->genericTrap ;
    *specificTrap = entry->specificTrap ;
    *timeStamp = entry->timeStamp ;
    *variableBindings = entry->varBindList ; // note structure copy
    free(entry) ;
    return TRUE ;
#endif

/*
|========================
| Special HostMIB code:
*/
    /* Re-fetch CPU statistics from kernel */
    hrProcessLoad_Refresh();

    /* Don't call again until the timer goes off again */
    return FALSE;

} /* end of SnmpExtensionTrap() */



/*
 *  SnmpExtensionQuery
 *
 *    Extension Agent DLLs provide the following entry point to resolve queries
 *    for MIB variables in their supported MIB view (supplied at initialization
 *    time).  The requestType is Get/GetNext/Set.
 *
 *  Arguments:
 *
 *  Results:
 *
 */


BOOL WINAPI
SnmpExtensionQuery( IN BYTE requestType ,
                    IN OUT RFC1157VarBindList *variableBindings ,
                    OUT AsnInteger *errorStatus ,
                    OUT AsnInteger *errorIndex )
{
    UINT index ;
    UINT *tmp ;
    UINT status ;


    // Iterate through the variable bindings list to resolve individual
    // variable bindings.

    for ( index = 0 ; index < variableBindings->len ; index++ )
    {
        *errorStatus = ResolveVarBind( &variableBindings->list[ index ] ,
                                       requestType ) ;


        // Test and handle case where Get Next past end of MIB view supported
        // by this Extension Agent occurs.  Special processing is required to
        // communicate this situation to the Extendible Agent so it can take
        // appropriate action, possibly querying other Extension Agents.

        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
             requestType == MIB_ACTION_GETNEXT )
        {
            *errorStatus = SNMP_ERRORSTATUS_NOERROR ;

            // Modify variable binding of such variables so the OID points
            // just outside the MIB view supported by this Extension Agent.
            // The Extendible Agent tests for this, and takes appropriate
            // action.

            SNMP_oidfree( &variableBindings->list[ index ].name ) ;
            status = SNMP_oidcpy( &variableBindings->list[ index ].name, &Subroot_oid  ) ;
            if ( !status )
            {
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
            }
            else
            {
                tmp = variableBindings->list[ index ].name.ids ;
                (tmp[ SUBROOT_LENGTH - 1 ])++ ;
            }
        }


        // If an error was indicated, communicate error status and error
        // index to the Extendible Agent.  The Extendible Agent will ensure
        // that the origional variable bindings are returned in the response
        // packet.

        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
            *errorIndex = index + 1 ;
            goto Exit ;
        }
    }

Exit:

    // Indicate that Extension Agent processing was sucessfull.

    return SNMPAPI_NOERROR ;

} /* end of SnmpExtensionQuery() */

/* end of gendll.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrdevent.h ===
/*
 *  File HRDEVENT.H
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module is contains definitions pertaining to the HostMIB
 *    hrDevice table... definitions needed by the "sub-tables" within
 *    the hrDevice table and the functions that deal with these tables.
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V1.0 - 04/28/97  D. D. Burns     Original Creation
 */

#ifndef hrdevent_h
#define hrdevent_h


/*
|==============================================================================
| hrDevice Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below (with the exception of "hrDeviceID" which is never cached
|    and handled exclusively by the GetHrDeviceID() function).
|
|    One special define is used in the same manner as the defines for the
|    real attributes to access a "hidden attribute" value which is never
|    returned as a consequence of an SNMP request, but is stored in the cache
|    to allow "computed" values to be obtained for some of the real attributes.
|
|    An example of a value in the HIDDEN_CTX attribute might be the string
|    needed to look up a value of hrDeviceStatus for this device or another
|    "computed" value in another associated table (such as hrPrintertable).
|
|    These symbols are used as C indices into the array of attributes within a
|    cached-row of the hrDevice Table.
|
*/
#define HRDV_INDEX    0    // hrDeviceIndex
#define HRDV_TYPE     1    // hrDeviceType
#define HRDV_DESCR    2    // hrDeviceDescr
                           // (hrDeviceID omitted)
#define HRDV_STATUS   3    // hrDeviceStatus
#define HRDV_ERRORS   4    // hrDeviceErrors
#define HIDDEN_CTX    5    // (Hidden Context Information).
                      //-->Add more here, change count below!
#define HRDV_ATTRIB_COUNT 6


/*
|==============================================================================
| hrPartition Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
|    These symbols appear in this file so that code in HRDISKST.C can
|    properly initialize rows in the HrPartition table while code in
|    HRPARTIT.C can reference them.
*/
#define HRPT_INDEX     0    // hrPartitionIndex
#define HRPT_LABEL     1    // hrPartitionLabel
#define HRPT_ID        2    // hrPartitionID
#define HRPT_SIZE      3    // hrPartitionSize
#define HRPT_FSINDEX   4    // hrPartitionFSIndex
                      //-->Add more here, change count below!
#define HRPT_ATTRIB_COUNT 5


/*
|==============================================================================
| hrDiskStorage Attribute Defines
|
|    Each attribute defined for this table is associated with one of the
|    #defines below.  These symbols are used as C indices into the array of
|    attributes within a cached-row.
|
*/
#define HRDS_ACCESS    0    // hrDiskStorageAccess
#define HRDS_MEDIA     1    // hrDiskStorageMedia
#define HRDS_REMOVABLE 2    // hrDiskStorageRemovable
#define HRDS_CAPACITY  3    // hrDiskStorageCapacity
                      //-->Add more here, change count below!
#define HRDS_ATTRIB_COUNT 4


/*
|==============================================================================
| hrDevice Type OID Ending Arcs
|
|    RFC1514 specifies an object identifier "{ hrDeviceTypes }" to be used
|    as a prefix to the full OID that specifies a device's type in the
|    hrDevice table.  The symbols below specify the final arc "x" as in
|    "{ hrDeviceTypes x }" to be used for each device type.
|
|    You can't change these symbol values... we're just trying to be
|    mnemonic here.
*/
#define HRDV_TYPE_LASTARC_OTHER         1
#define HRDV_TYPE_LASTARC_UNKNOWN       2
#define HRDV_TYPE_LASTARC_PROCESSOR     3
#define HRDV_TYPE_LASTARC_NETWORK       4
#define HRDV_TYPE_LASTARC_PRINTER       5
#define HRDV_TYPE_LASTARC_DISKSTORAGE   6
#define HRDV_TYPE_LASTARC_VIDEO         10
#define HRDV_TYPE_LASTARC_AUDIO         11
#define HRDV_TYPE_LASTARC_COPROCESSOR   12
#define HRDV_TYPE_LASTARC_KEYBOARD      13
#define HRDV_TYPE_LASTARC_MODEM         14
#define HRDV_TYPE_LASTARC_PARALLELPORT  15
#define HRDV_TYPE_LASTARC_POINTING      16
#define HRDV_TYPE_LASTARC_SERIALPORT    17
#define HRDV_TYPE_LASTARC_TAPE          18
#define HRDV_TYPE_LASTARC_CLOCK         19
#define HRDV_TYPE_LASTARC_VOLMEMORY     20
#define HRDV_TYPE_LASTARC_NONVOLMEMORY  21


/*
|==============================================================================
| HRDEVICE-Related Function Prototypes
*/

/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */
BOOL Gen_HrPrinter_Cache( ULONG type_arc );       /* "HRPRINTE.C" */

/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */
BOOL COMPUTE_hrPrinter_status(
                         CACHEROW *row,
                         UINT     *outvalue
                         );                       /* "HRPRINTE.C" */

/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */
BOOL COMPUTE_hrPrinter_errors(
                         CACHEROW *row,
                         UINT     *outvalue
                         );                       /* "HRPRINTE.C" */

/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
BOOL Gen_HrProcessor_Cache( ULONG type_arc );     /* "HRPROCES.C" */

/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice NETWORK Table */
BOOL Gen_HrNetwork_Cache( ULONG type_arc );       /* "HRNETWOR.C" */

/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */
BOOL Gen_HrDiskStorage_Cache( ULONG type_arc );   /* "HRDISKST.C" */
extern CACHEHEAD hrDiskStorage_cache;    /* This cache is globally accessible */


/* AddrHrDeviceRow - Generate another Row Entry in HrDevice Table
|
|  Special purpose cache-row function just for hrDevice and related sub-tables.
|
|  Source is in "HRDEVENT.C".
*/
CACHEROW *
AddHrDeviceRow(
               ULONG   type_arc,       /* Last Arc value for OID for Type   */
               LPSTR   descr,          /* Description string                */
               void   *hidden_ctx,     /* If non-NULL: Hidden-context value */
               ATTRIB_TYPE  hc_type    /* Type of "hidden_ctx"              */
               );


#endif /* hrdevent_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrnetwor.c ===
/*
 *  HrNetworkEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrNetworkEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:42:33 1996
 *
 */


#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */
#include "iphlpapi.h"     /* Access to MIB2 Utility function */



/*
 *  GetHrNetworkIfIndex
 *    The value of the ifIndex which corresponds to this network device.
 *    
 *    Gets the value for HrNetworkIfIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrNetworkIfIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER
 | 
 | "The value of ifIndex which corresponds to this network device."
 | 
 | DISCUSSION:
 | 
 | <POA-13> A mechanism by which I can map a network interface device (as found
 | in the course of populating the hrDeviceTable) to the "ifIndex" value in
 | MIB-II needs to be described to me.
 | 
 | RESOLVED >>>>>>>>
 | <POA-13> We expose this info via MIB2UTIL.DLL.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.4.1.1.<instance>
 |                | | | |
 |                | | | *-HrNetworkIfIndex
 |                | | *-HrNetworkEntry
 |                | *-HrNetworkTable
 |                *-hrDevice
 */

UINT
GetHrNetworkIfIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }


/*
| By convention with "Gen_HrNetwork_Cache()", the "Hidden Context" attribute
| for the selected row is the value to be returned by hrNetworkIfIndex.
*/
*outvalue = row->attrib_list[HIDDEN_CTX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrNetworkIfIndex() */


/*
 *  HrNetworkEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrNetworkEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT             tmp_instance;  /* Instance arc value                 */
    CACHEROW        *row;           /* Row entry fetched from cache       */

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRNETWORKENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRNETWORKENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRNETWORKENTRY_VAR_INDEX ] ;

        /*
        | For hrNetworkTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDeviceTable cache.
        |
        | Check that here.
        */
	if ( (row = FindTableRow(tmp_instance, &hrDevice_cache)) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
            /*
            | The instance arc selects an hrDeviceTable row entry, but is that
            | entry actually for a device of type "Network"?
            |
            | (We examine the last arc of the OID that specifies the device
            |  type in the row entry selected by the instance arc).
            */
            if (row->attrib_list[HRDV_TYPE].u.unumber_value !=
                HRDV_TYPE_LASTARC_NETWORK) {

                return SNMP_ERRORSTATUS_NOSUCHNAME;
                }

	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.

	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrNetworkEntryFindInstance() */



/*
 *  HrNetworkEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrNetworkEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRNETWORKENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRNETWORKENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    /*
    | The instance arc selects an hrDeviceTable row entry, but is that
    | entry actually for a device of type "Network"?
    |
    | (We examine the last arc of the OID that specifies the device
    |  type in the row entry selected by the instance arc).
    */
    do {
        if (row->attrib_list[HRDV_TYPE].u.unumber_value ==
            HRDV_TYPE_LASTARC_NETWORK) {

            /* Found an hrDeviceTable entry for the right device type */
            break;
            }

        /* Step to the next row in the table */
        row = GetNextTableRow( row );
        }
        while ( row != NULL );

    /* If we found a proper device-type row . . . */
    if ( row != NULL) {
        instance->ids[ 0 ] = row->index ;
        instance->idLength = 1 ;
        }
    else {

        /*
        | Fell off the end of the hrDeviceTable without finding a row
        | entry that had the right device type.
        */
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrNetworkEntryFindNextInstance() */



/*
 *  HrNetworkEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrNetworkEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrNetworkEntryConvertInstance() */




/*
 *  HrNetworkEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrNetworkEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrNetwork Table */
} /* end of HrNetworkEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrNetwork_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */

BOOL
Gen_HrNetwork_Cache(
                      ULONG type_arc
                      )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the HrDevice cache has been fully
|       populated with all rows required for Network devices.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" to
|       populate the cache for the HrDevice table with Network-device 
|       specific entries.
|
|  OTHER THINGS TO KNOW:
|
|       Since all the attributes in the HrNetwork "sub" table are computed
|       upon request (based on cached information in a selected row in the
|       HrDevice table) there is no need to build a cache specifically for
|       this sub-table.  (This routine is only loading the HrDevice cache.
|                                                          --------
|
|       This function holds a convention with the GET routines earlier in
|       this module that the "HIDDEN_CTX" attribute for Network-devices 
|       contains a string that is the value of "hrNetworkIfIndex".
|============================================================================
| 1.3.6.1.2.1.25.3.4.1...
|                | | |
|                | | *-HrNetworkEntry
|                | *-HrNetworkTable
|                *-hrDevice
*/
{
DWORD           dwBytesRequired;    
MIB_IFTABLE    *iftable;        /* --> Heap storage containing table     */
UINT            i;              /* iftable index                         */


/*
| We fetch the IfTable from the Mib2 subsection of the agent and for each
| network interface (ie for every entry in the table) we create a row in
| the hrDeviceTable.
|
| The HIDDEN_CTX attribute value in the row will simply be the "dwIndex"
| entry in the from the iftable entry from which the row was generated.
| This becomes the value of "hrNetworkIfIndex".
*/

/* Initialize */
dwBytesRequired = 0;
iftable = NULL;

/* Ask for the size of the table from "iphlpapi" */
if (GetIfTable(iftable, &dwBytesRequired, TRUE) != ERROR_INSUFFICIENT_BUFFER) {
    return ( FALSE );
    }

/* Allocate necessary memory */
if ((iftable = (MIB_IFTABLE *)malloc(dwBytesRequired)) == NULL) {
    return ( FALSE );
    }

/* Ask for the table information from "iphlpapi" */
if (GetIfTable(iftable, &dwBytesRequired, TRUE) != NO_ERROR ) {

    /* Release */
    free(iftable);

    /* Something blew */
    return ( FALSE );
    }

/* Sweep thru any table creating hrDevice rows */ 
for (i = 0; i < iftable->dwNumEntries; i += 1) {

    /*
    | "Hidden Context" is the ifTable index passed in from the GetIfTable()
    |
    | It will be returned as the value of "hrNetworkIfIndex" by the Get
    | function.
    */

    if (AddHrDeviceRow(type_arc,                     // DeviceType OID Last-Arc
        (unsigned char *) &iftable->table[i].bDescr, // Device Description
                       &iftable->table[i].dwIndex,   // Hidden Ctx "index"
                       CA_NUMBER                     // Hidden Ctx "type"
                       ) == NULL ) {

        /* Release */
        free(iftable);

        /* Something blew */
        return ( FALSE );
        }
    }

/* Release */
free(iftable);

return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrfsentr.c ===
/*
 *  HrFSEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrFSEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/18/97  D. D. Burns     Genned: Thu Nov 07 16:44:44 1996
 *    V1.01 - 06/17/97  D. D. Burns     Fix bug in Gen_HrFSTable_Cache() that
 *                                        precluded finding "hrFSStorageIndex"
 *                                        for drives w/volume labels.
 *  
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions */
#include "string.h"       /* For string manipulation in "Gen_Hrstorage_Cache"*/
#include "stdio.h"        /* For sprintf */
#include <winioctl.h>     /* For PARTITION_INFORMATION */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */
static void
debug_print_hrFSTable(
                      CACHEROW     *row  /* Row in hrFSTable table */
                      );


/*
|==============================================================================
| Create the list-head for the HrFStable cache.
|
| - Global so that code in "ProcessPartitions()" in "HRDISKST.C" can search
|   this cache.
|
| - This macro is defined in "HMCACHE.H".
*/
CACHEHEAD_INSTANCE(hrFSTable_cache, debug_print_hrFSTable);



/*
 *  GetHrFSIndex
 *    A unique value for each file system local to this host.  The value for 
 *    each file system must remain constant at least from one r
 *    
 *    Gets the value for HrFSIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "A unique value for each file system local to this host.  The value for each
 | file system must remain constant at least from one re-initialization of the
 | agent to the next re-initialization."
 | 
 | 
 | DISCUSSION:
 | 
 | An entry is generated for each drive (network or not) returned by
 | "GetLogicalDrives".
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.1.<instance>
 |                | | | |
 |                | | | *hrFSIndex
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSIndex" value from this entry
*/
*outvalue = row->attrib_list[HRFS_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSIndex() */


/*
 *  GetHrFSMountPoint
 *    The path name of the root of this file system.
 *    
 *    Gets the value for HrFSMountPoint.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSMountPoint
 | 
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 | 
 | "The path name of the root of this file system."
 | 
 | DISCUSSION:
 | 
 | The value of this attribute is the proper value returned by
 | "GetLogicalDriveStrings" for the selected entry.
 | 
 | RESOLVED >>>>>>>>
 | <POA-15>  Just return an empty string for the Mount Point variables.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.2.<instance>
 |                | | | |
 |                | | | *hrFSMountPoint
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| The cache has the device string in it, but we return the empty string
| per the spec.
*/
#if 1
    /* Return the empty string */
    outvalue->string = "";
    outvalue->length = 0;
#else
    /* Return the cached string */
    outvalue->string = row->attrib_list[HRFS_MOUNTPT].u.string_value;
    outvalue->length = strlen(outvalue->string);

    /* "Truncate" here to meet RFC as needed*/
    if ((outvalue->length = strlen(outvalue->string)) > 128) {
        outvalue->length = 128;
        }
#endif

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSMountPoint() */


/*
 *  GetHrFSRemoteMountPoint
 *    A description of the name and/or address of the server that this file 
 *    system is mounted from.  This may also include parameters 
 *    
 *    Gets the value for HrFSRemoteMountPoint.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSRemoteMountPoint
 | 
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 | 
 | "A description of the name and/or address of the server that this file system
 | is mounted from.  This may also include parameters such as the mount point on
 | the remote file system.  If this is not a remote file system, this string
 | should have a length of zero."
 | 
 | DISCUSSION:
 | 
 | <POA-15> The starting point for deriving this attribute's value is the logical
 | drive name, which would already be known to represent a network drive.  I can
 | find no Win32 API function that maps a network logical drive to it's server.
 | 
 | RESOLVED >>>>>>>>
 | <POA-15>  Just return an empty string for the Mount Point variables.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.3.<instance>
 |                | | | |
 |                | | | *hrFSRemoteMountPoint
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSRemoteMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/* Return the empty string */
outvalue->string = "";
outvalue->length = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSRemoteMountPoint() */


/*
 *  GetHrFSType
 *    The value of this object identifies the type of this file system.
 *    
 *    Gets the value for HrFSType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSType
 | 
 |  ACCESS         SYNTAX
 |  read-only      OBJECT IDENTIFIER
 | 
 | "The value of this object identifies the type of this file system."
 | 
 | DISCUSSION:
 | 
 |    -- Registration for some popular File System types,
 |    -- for use with hrFSType.
 | 
 |    hrFSTypes               OBJECT IDENTIFIER ::= { hrDevice 9 }
 | 
 |    hrFSOther               OBJECT IDENTIFIER ::= { hrFSTypes 1 }
 |    hrFSUnknown             OBJECT IDENTIFIER ::= { hrFSTypes 2 }
 |    hrFSBerkeleyFFS         OBJECT IDENTIFIER ::= { hrFSTypes 3 }
 |    hrFSSys5FS              OBJECT IDENTIFIER ::= { hrFSTypes 4 }
 |    -- DOS
 |    hrFSFat                 OBJECT IDENTIFIER ::= { hrFSTypes 5 }
 |    -- OS/2 High Performance File System
 |    hrFSHPFS                OBJECT IDENTIFIER ::= { hrFSTypes 6 }
 |    --  Macintosh Hierarchical File System
 |    hrFSHFS                 OBJECT IDENTIFIER ::= { hrFSTypes 7 }
 | 
 | 
 |    -- Macintosh File System
 |    hrFSMFS                 OBJECT IDENTIFIER ::= { hrFSTypes 8 }
 |    -- Windows NT
 |    hrFSNTFS                OBJECT IDENTIFIER ::= { hrFSTypes 9 }
 |    hrFSVNode               OBJECT IDENTIFIER ::= { hrFSTypes 10 }
 |    hrFSJournaled           OBJECT IDENTIFIER ::= { hrFSTypes 11 }
 |    -- CD File systems
 |    hrFSiso9660             OBJECT IDENTIFIER ::= { hrFSTypes 12 }
 |    hrFSRockRidge           OBJECT IDENTIFIER ::= { hrFSTypes 13 }
 | 
 |    hrFSNFS                 OBJECT IDENTIFIER ::= { hrFSTypes 14 }
 |    hrFSNetware             OBJECT IDENTIFIER ::= { hrFSTypes 15 }
 |    -- Andrew File System
 |    hrFSAFS                 OBJECT IDENTIFIER ::= { hrFSTypes 16 }
 |    -- OSF DCE Distributed File System
 |    hrFSDFS                 OBJECT IDENTIFIER ::= { hrFSTypes 17 }
 |    hrFSAppleshare          OBJECT IDENTIFIER ::= { hrFSTypes 18 }
 |    hrFSRFS                 OBJECT IDENTIFIER ::= { hrFSTypes 19 }
 |    -- Data General
 |    hrFSDGCFS               OBJECT IDENTIFIER ::= { hrFSTypes 20 }
 |    -- SVR4 Boot File System
 |    hrFSBFS                 OBJECT IDENTIFIER ::= { hrFSTypes 21 }
 | 
 | Win32 API function "GetVolumeInformation" can provide us with the 
 | information needed to select the correct OID for this attribute's value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.9.n
 |                | | |
 |                | | *-Type indicator
 |                | *-hrFSTypes
 |                *-hrDevice
 |
 | 1.3.6.1.2.1.25.3.8.1.4.<instance>
 |                | | | |
 |                | | | *hrFSType
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrFSTable_Cache()",
| the cached value is the right-most arc we must return as the value.
|
| Hence whatever cache entry we retrieve, we tack the number retrieved
| from the cache for this attribute onto { hrFSTypes ... }.
*/
if ( (outvalue->ids = SNMP_malloc(10 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 10;


/*
| Load in the full hrFSType OID:
|
| 1.3.6.1.2.1.25.3.9.n
|                | | |
|                | | *-Type indicator
|                | *-hrFSTypes
|                *-hrDevice
*/
outvalue->ids[0] = 1;
outvalue->ids[1] = 3;
outvalue->ids[2] = 6;
outvalue->ids[3] = 1;
outvalue->ids[4] = 2;
outvalue->ids[5] = 1;
outvalue->ids[6] = 25;
outvalue->ids[7] = 3;
outvalue->ids[8] = 9;

/* Cached FS Type indicator */
outvalue->ids[9] = row->attrib_list[HRFS_TYPE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSType() */


/*
 *  GetHrFSAccess
 *    An indication if this file system is logically configured by the 
 *    operating system to be readable and writable or only readable. 
 *    
 *    Gets the value for HrFSAccess.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSAccess
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {readWrite(1),readOnly(2)}
 | 
 | "An indication if this file system is logically configured by the operating
 | system to be readable and writable or only readable.  This does not represent
 | any local access-control policy, except one that is applied to the file system
 | as a whole."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "GetVolumeInformation" can provide us with the information
 | needed to select the correct OID for this attribute's value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.5.<instance>
 |                | | | |
 |                | | | *hrFSAccess
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSAccess" value from this entry
*/
*outvalue = row->attrib_list[HRFS_ACCESS].u.unumber_value;


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSAccess() */


/*
 *  GetHrFSBootable
 *    A falg indicating whether this file system is bootable.
 *    
 *    Gets the value for HrFSBootable.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSBootable
 | 
 |  ACCESS         SYNTAX
 |  read-only      Boolean
 | 
 | "A flag indicating whether this file system is bootable."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "CreatFile" and DeviceIoControlcan provide us with the
 | information needed to select the correct OID for this attribute's value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.6.<instance>
 |                | | | |
 |                | | | *hrFSBootable
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSBootable( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSBootable" value from this entry
*/
*outvalue = row->attrib_list[HRFS_BOOTABLE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSBootable() */


/*
 *  GetHrFSStorageIndex
 *    The index of the hrStorageEntry that represents information about this 
 *    file system.  If there is no such information available, 
 *    
 *    Gets the value for HrFSStorageIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSStorageIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 | 
 | "The index of the hrStorageEntry that represents information about this file
 | system.  If there is no such information available, then this value shall be
 | zero.  The relevant storage entry will be useful in tracking the percent usage
 | of this file system and diagnosing errors that may occur when it runs out of
 | space."
 | 
 | DISCUSSION:
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.7.<instance>
 |                | | | |
 |                | | | *hrFSStorageIndex
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSStorageIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrFSTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrFSStorageIndex" value from this entry
*/
*outvalue = row->attrib_list[HRFS_STORINDX].u.unumber_value;


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSStorageIndex() */


/*
 *  GetHrFSLastFullBackupDate
 *    The last date at which this complete file system was copied to another 
 *    storage device for backup.  This information is useful fo
 *    
 *    Gets the value for HrFSLastFullBackupDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSLastFullBackupDate
 | 
 |  ACCESS         SYNTAX
 |  read-write     DateAndTime
 | 
 | "The last date at which this complete file system was copied to another
 | storage device for backup.  This information is useful for ensuring that
 | backups are being performed regularly.  If this information is not known, then
 | this variable shall have the value corresponding to January 1, year 0000,
 | 00:00:00.0, which is encoded as (hex)'00 00 01 01 00 00 00 00'."
 | 
 | DISCUSSION:
 | 
 | This metric is apparently not recorded and is not made available through
 | any documented Win32 API function.  Consequently, we return the appropriate
 | "not known" value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.8.<instance>
 |                | | | |
 |                | | | *hrFSLastFullBackupDate
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSLastFullBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

outvalue->length = 8;
outvalue->string = "\0\0\1\1\0\0\0\0";


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSLastFullBackupDate() */


/*
 *  SetHrFSLastFullBackupDate
 *    The last date at which this complete file system was copied to another 
 *    storage device for backup.  This information is useful fo
 *    
 *    Sets the HrFSLastFullBackupDate value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrFSLastFullBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrFSLastFullBackupDate() */


/*
 *  GetHrFSLastPartialBackupDate
 *    The last date at which a portion of thes file system was copied to 
 *    another storage device for backup.  This information is usefu
 *    
 *    Gets the value for HrFSLastPartialBackupDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrFSLastPartialBackupDate
 | 
 |  ACCESS         SYNTAX
 |  read-write     DateAndTime
 | 
 | "The last date at which a portion of this file system was copied to another
 | storage device for backup.  This information is useful for ensuring that
 | backups are being performed regularly.  If this information is not known, 
 | then this variable shall have the value corresponding to 
 | January 1, year 0000, 00:00:00.0, which is encoded as
 | (hex)'00 00 01 01 00 00 00 00'."
 | 
 | DISCUSSION:
 | 
 | This metric is apparently not recorded and is not made available through
 | any documented Win32 API function.  Consequently, we return the appropriate
 | "not known" value.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.8.1.9.<instance>
 |                | | | |
 |                | | | *hrFSLastPartialBackupDate
 |                | | *hrFSEntry
 |                | *-hrFSTable
 |                *-hrDevice
 */

UINT
GetHrFSLastPartialBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

outvalue->length = 8;
outvalue->string = "\0\0\1\1\0\0\0\0";

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrFSLastPartialBackupDate() */


/*
 *  SetHrFSLastPartialBackupDate
 *    The last date at which a portion of thes file system was copied to 
 *    another storage device for backup.  This information is usefu
 *    
 *    Sets the HrFSLastPartialBackupDate value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrFSLastPartialBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrFSLastPartialBackupDate() */


/*
 *  HrFSEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrFSEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRFSENTRY_VAR_INDEX )
    // No instance was specified
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRFSENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

        tmp_instance = FullOid->ids[ HRFSENTRY_VAR_INDEX ] ;

        /*
        | For hrFSTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrFSTable cache.
        | Check that here.
        */
    if ( FindTableRow(tmp_instance, &hrFSTable_cache) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
    }
    else
    {
        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.
        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrFSEntryFindInstance() */



/*
 *  HrFSEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrFSEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRFSENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRFSENTRY_VAR_INDEX ] ;
    }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrFSTable_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
    }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrFSEntryFindNextInstance() */



/*
 *  HrFSEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrFSEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrFSEntryConvertInstance() */




/*
 *  HrFSEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrFSEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrFSTable */
} /* end of HrFSEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */
/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */
/* Gen_HrFSTable_Cache - Generate a initial cache for HrFSTable */

BOOL
Gen_HrFSTable_Cache(
                    void
                    )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrFSTable,
|       "hrFSTable_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to 
|       populate the cache for the HrStorage table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
| DISCUSSION:
| 
| It appears that there is a one-to-one correspondence between NT logical drives
| and "file systems" as defined by this table.  As a consequence, the contents
| of this table is almost identical to the hrStorageTable except that remote
| network drives (in unix-speak, remotely mounted file systems) are included
| in this table while excluded from hrStorageTable.
| 
| To this end, a combination of Win32 API functions "GetLogicalDrives",
| "GetVolumeInformation", "GetDriveType" and "GetDiskFreeSpace" are used to
| acquire the information for the SNMP attributes in this table.
| 
|============================================================================
| 1.3.6.1.2.1.25.3.8.1...
|                | | |
|                | | *hrFSEntry
|                | *-hrFSTable
|                *-hrDevice
|
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
LPSTR   pDrvStrings;            /* --> allocated storage for drive strings */
LPSTR   pOriginal_DrvStrings;   /* (Needed for final deallocation          */
DWORD   DS_request_len;         /* Storage actually needed                 */
DWORD   DS_current_len;         /* Storage used on 2nd call                */
ULONG   table_index=0;          /* hrFSTable index counter                 */
CACHEROW *row;                  /* --> Cache structure for row-being built */
UINT    i;                      /* Handy-Dandy loop index                  */

#define PHYS_SIZE 32
CHAR    phys_name[PHYS_SIZE+1]; /* Buffer where a string like "\\.C:" (for */
                                /*  example) is built for drive access.    */

phys_name[PHYS_SIZE] = 0; // ensures null terminated string

/*
| Blow away any old copy of the cache
*/
DestroyTable(&hrFSTable_cache);

/*
| We're going to call GetLogicalDriveStrings() twice, once to get the proper
| buffer size, and the second time to actually get the drive strings.
*/
if ((DS_request_len = GetLogicalDriveStrings(2, temp)) == 0) {

    /* Request failed altogether, can't initialize */
    return ( FALSE );
}

/*
| Grab enough storage for the drive strings plus one null byte at the end
*/

if ( (pOriginal_DrvStrings = pDrvStrings = malloc( (DS_request_len + 1) ) )
    == NULL) {

    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
}

/* Go for all of the strings */
if ((DS_current_len = GetLogicalDriveStrings(DS_request_len, pDrvStrings))
    == 0) {

    /* Request failed altogether, can't initialize */
    free( pOriginal_DrvStrings );
    return ( FALSE );
}


/*
|==============================================================================
| As long as we've got an unprocessed drive-string which may correspond to
| a File-System for which we need a table-row entry . . . 
*/
while ( strlen(pDrvStrings) > 0 ) {

    UINT        drivetype;      /* Type of the drive from "GetDriveType()"   */
    ULONG       fs_type;        /* derived File-System type (last-arc value) */
    UINT        bootable;       /* derived "bootable" value (Boolean)        */
    UINT        readwrite;      /* derived "readwrite" value (0 or 1)        */
    UINT        storage_index;  /* Index into hrStorageTable to matching slot*/
    CACHEROW   *row_hrstorage;  /* As returned by FindNextTableRow()         */
    UINT       nPrevErrorMode; /* previous state of error-mode bit flags     */

    /*
    | Get the drive-type so we can decide whether it should participate in
    | this table.  We do both locals and remotes (unlike hrStorage, from
    | which this code was ripped off).
    */
    drivetype = GetDriveType(pDrvStrings);

    if (   drivetype == DRIVE_UNKNOWN
        || drivetype == DRIVE_NO_ROOT_DIR
        ) {

        /* Step to next string, if any */
        pDrvStrings += strlen(pDrvStrings) + 1;

        continue;
    }

    /*
    | OK, we want this one in the table, get a row-entry created.
    */
    if ((row = CreateTableRow( HRFS_ATTRIB_COUNT ) ) == NULL) {
        return ( FALSE );       // Out of memory
    }

    /* =========== hrFSIndex ==========*/
    row->attrib_list[HRFS_INDEX].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_INDEX].u.unumber_value = (table_index += 1) ;


    /* =========== hrFSMountPoint ==========
    | Note: We store the device string in the cache, but the "GET" function
    |       always returns an empty string, per the spec.
    */
    row->attrib_list[HRFS_MOUNTPT].attrib_type = CA_STRING;

    /* Get some space */
    if ( (row->attrib_list[HRFS_MOUNTPT].u.string_value
          = ( LPSTR ) malloc(strlen(pDrvStrings) + 1)) == NULL) {
        DestroyTableRow(row);
        return ( FALSE );       /* out of memory */
    }
    /* Copy the Value into the space */
    strcpy(row->attrib_list[HRFS_MOUNTPT].u.string_value, pDrvStrings);

    /*
    | The GET functions for "computed" attributes expect to be able to use
    | the value of the "hrFSMountPoint" cache value stored above to lookup
    | (using system calls) their respective values.  We may or may not actually
    | report this stored-value as the value of the attribute in initial
    | release.
    */


    /* =========== hrFSRemoteMountPoint ==========*/
    row->attrib_list[HRFS_RMOUNTPT].attrib_type = CA_COMPUTED;


    /* =========== hrFSType     ==========
    |  =========== hrFSAccess   ==========
    |  =========== hrFSBootable ==========
    |
    | We use the first two characters of the drive string (e.g. "C:") to
    | create the special string (e.g. "\\.\C:") needed to obtain a "CreateFile"
    | handle to the device "C" or partition "C".
    |
    | With that, a DeviceIoControl call for partition information gives
    | us an idea as to the type and bootability of the device or partition.
    |
    | If any step in this process fails, the type is "hrFSUnknown", bootable
    | is "FALSE" and Access is presumed "read-write".
    |
    | For hrFSType we store a single number as the cached value of the 
    | hrFSType attribute.  When this attribute is fetched, the cached number 
    | forms the last arc in the OBJECT IDENTIFIER that actually specifies the
    | type: { hrFSTypes x }, where "x" is what gets stored.
    */
    fs_type = 2;        /* 2 = last arc value for "hrFSUnknown" */
    bootable = 0;       /* if unknown, "not bootable"           */
    readwrite = 1;      /* if unknown, "read-write"             */

    /* If we have room in the buffer to build the handle-name string */
    if ((strlen(pDrvStrings) + strlen("\\\\.\\")) < PHYS_SIZE) {

        HANDLE                  hdrv;       /* Handle to device           */
        PARTITION_INFORMATION   part_info;  /* Partition Info from device */
        DWORD                   bytes_out;  /* Bytes retnd into part_info */


        /* Build it for device A: "\\.\A:" */
        _snprintf(phys_name, PHYS_SIZE, "\\\\.\\%2.2s", pDrvStrings);

        /*
        | Suppress any attempt by the system to make the user put a volume in a
        | removable drive ("CreateFile" will just fail).
        */
        nPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        /* Attempt to get a handle using this physical name string */
        if ((hdrv = CreateFile(phys_name,             // Device
                               GENERIC_READ,          // Access
                               FILE_SHARE_READ   |
                               FILE_SHARE_WRITE,      // Share Mode
                               NULL,                  // Security
                               OPEN_EXISTING,         // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL, // FlagsandAttributes
                               NULL                   // Template file
                               )) != INVALID_HANDLE_VALUE) {
            /*
            | Device is Open
            |
            | Try for Partition Information on the "device" we opened
            |
            | (Not supported by Floppy drivers, so this'll probably fail).
            */
            if (DeviceIoControl(hdrv,           // device handle
                                                // IoControlCode (op-code)
                                IOCTL_DISK_GET_PARTITION_INFO,

                                NULL,           // "input buffer"
                                0,              // "input buffer size"
                                &part_info,     // "output buffer"
                                                // "output buffer size"
                                sizeof(PARTITION_INFORMATION),

                                &bytes_out,     // bytes written to part_info
                                NULL            // no Overlapped I/o
                                )) {

                /*
                | We've got Partition Information for the device: use it
                */
                bootable = part_info.BootIndicator;

                /*
                | Assign an OID Type "last-arc number" for those file system
                | types we recognize.
                */
                switch (part_info.PartitionType) {

                    case PARTITION_UNIX:             // Unix
                        fs_type = 3;    // "hrFSBerkeleyFFS"
                        break;

                    case PARTITION_FAT_12:           // 12-bit FAT entries
                    case PARTITION_FAT_16:           // 16-bit FAT entries
                    case PARTITION_HUGE:             // Huge partition MS-DOS V4
                    case PARTITION_FAT32:            // FAT32
                    case PARTITION_FAT32_XINT13:     // FAT32 using extended int13 services
                        fs_type = 5;    // "hrFSFat"
                        break;

                    case PARTITION_IFS:              // IFS Partition
                    case VALID_NTFT:                 // NTFT uses high order bits
                        fs_type = 9;    // "hrFSNTFS"
                        break;

                    case PARTITION_XENIX_1:          // Xenix
                    case PARTITION_XENIX_2:          // Xenix
                    case PARTITION_XINT13:           // Win95 partition using extended int13 services
                    case PARTITION_XINT13_EXTENDED:  // Same as type 5 but uses extended int13 services
                    case PARTITION_EXTENDED:         // Extended partition entry
                    case PARTITION_PREP:             // PowerPC Reference Platform (PReP) Boot Partition
                        fs_type = 1;    // "hrFSOther"
                        break;

                    case PARTITION_ENTRY_UNUSED:     // Entry unused
                    default:
                        /* This will translate to fs_type = 2 "unknown" */
                        break;
                }
            }   /* If (we managed to get partition information) */

            CloseHandle(hdrv);
        }   /* if (we managed to "CreateFile" the device) */

        SetErrorMode(nPrevErrorMode);        /* Turn error suppression mode off */
    }   /* if (we managed to build a device name) */

    /* =========== hrFSType     ========== */
    row->attrib_list[HRFS_TYPE].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_TYPE].u.unumber_value = fs_type;


    /* =========== hrFSAccess   ========== */
    /* Quick check: if its a CD-ROM, we presume it is readonly */
    if (drivetype == DRIVE_CDROM) {
        readwrite = 2;
    }
    row->attrib_list[HRFS_ACCESS].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_ACCESS].u.unumber_value = readwrite;


    /* =========== hrFSBootable ========== */
    row->attrib_list[HRFS_BOOTABLE].attrib_type = CA_NUMBER;
    row->attrib_list[HRFS_BOOTABLE].u.unumber_value = bootable;


    /* =========== hrFSStorageIndex ==========
    | Strategy:
    |
    | We wander up the hrStorage table looking for an exact match between
    | the storage attribute "hrStorageDescr" (which contains the DOS drive
    | string as returned by GetLogicalDriveStrings()) and the current drive
    | string.
    |
    | The first exact match: the index of that hrStorageTable row gets
    | stored here as the value of "hrFSStorageIndex".
    |
    | No Match: Store zero per the RFC spec.
    |
    | Come PnP, this attribute has to become "computed", as entries may come
    | and go from the hrStorage table.
    |
    | NOTE: The length of the comparison of the match is limited by the
    |       drive string we generate in this function, as the "description"
    |       from the hrStorage table may have other stuff appended to the
    |       end of the drive-string.
    */
    row->attrib_list[HRFS_STORINDX].attrib_type = CA_NUMBER;
    storage_index = 0;  /* Presume failure */

    /* Scan the hrStorageTable cache */
    for (row_hrstorage = FindNextTableRow(0, &hrStorage_cache);
         row_hrstorage != NULL;
         row_hrstorage = FindNextTableRow(i, &hrStorage_cache)
         ) {

        /* Obtain the actual row index */
        i = row_hrstorage->index;

        /* If (this entry has an exact match on drive-strings) */
        if (strncmp(row_hrstorage->attrib_list[HRST_DESCR].u.string_value,
                   pDrvStrings,strlen(pDrvStrings)) == 0) {

            /* We found a match, record it and break out */
            storage_index = i;
            break;
            }
        }

    row->attrib_list[HRFS_STORINDX].u.unumber_value = storage_index;


    /* =========== hrFSLastFullBackupDate ==========*/
    row->attrib_list[HRFS_LASTFULL].attrib_type = CA_COMPUTED;


    /* =========== hrFSLastPartialBackupDate ==========*/
    row->attrib_list[HRFS_LASTPART].attrib_type = CA_COMPUTED;


    /*
    | ======================================================
    | Now insert the filled-in CACHEROW structure into the
    | cache-list for the hrFSTable.
    */
    if (AddTableRow(row->attrib_list[HRFS_INDEX].u.unumber_value,  /* Index */
                    row,                                           /* Row   */
                    &hrFSTable_cache                               /* Cache */
                    ) == FALSE) {
        DestroyTableRow(row);
        return ( FALSE );       /* Internal Logic Error! */
    }

    /* Step to next string, if any */
    pDrvStrings += strlen(pDrvStrings) + 1;

} /* while (drive-strings remain . . .) */


free( pOriginal_DrvStrings );


#if defined(CACHE_DUMP)
PrintCache(&hrFSTable_cache);
#endif


/*
| Initialization of this table's cache succeeded
*/

return (TRUE);
}


/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */
/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */
/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */

ULONG
PartitionTypeToLastArc (
                        BYTE p_type
                        )
/*
|  EXPLICIT INPUTS:
|
|       Disk Partition Type as returned in PARTITION_INFORMATINO
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns the value that should be used as the Last-Arc "x"
|       in a "hrFSTypes" Object Identifier.
|
|     On any Failure:
|       Function returns the last-arc value for "UNKNOWN".
|
|  THE BIG PICTURE:
|
|       In more than one spot we need to be able to translate from
|       a Partition Type to our "Last-Arc" value.
|
|  OTHER THINGS TO KNOW:
|
*/
{
ULONG   last_arc = 2;           /* "2" = "UNKNOWN" */

/*
| Assign an OID Type "last-arc number" for those file system
| types we recognize.
*/
switch ( p_type ) {

    case PARTITION_UNIX:             // Unix
        last_arc = 3;    // "hrFSBerkeleyFFS"
        break;

    case PARTITION_FAT_12:           // 12-bit FAT entries
    case PARTITION_FAT_16:           // 16-bit FAT entries
    case PARTITION_HUGE:             // Huge partition MS-DOS V4
    case PARTITION_FAT32:            // FAT32
    case PARTITION_FAT32_XINT13:     // FAT32 using extended int13 services
        last_arc = 5;    // "hrFSFat"
        break;

    case PARTITION_IFS:              // IFS Partition
    case VALID_NTFT:                 // NTFT uses high order bits
        last_arc = 9;    // "hrFSNTFS"
        break;

    case PARTITION_XENIX_1:          // Xenix
    case PARTITION_XENIX_2:          // Xenix
    case PARTITION_XINT13:           // Win95 partition using extended int13 services
    case PARTITION_XINT13_EXTENDED:  // Same as type 5 but uses extended int13 services
    case PARTITION_EXTENDED:         // Extended partition entry
    case PARTITION_PREP:             // PowerPC Reference Platform (PReP) Boot Partition
        last_arc = 1;    // "hrFSOther"
        break;

    case PARTITION_ENTRY_UNUSED:     // Entry unused
    default:
        /* This will translate to "unknown" */
        break;
    }

return ( last_arc );
}

#if defined(CACHE_DUMP)

/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */
/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */
/* debug_print_hrFSTable - Prints a Row from HrFSTable sub-table */

static void
debug_print_hrFSTable(
                      CACHEROW     *row  /* Row in hrFSTable table */
                      )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=====================\n");
    fprintf(OFILE, "hrFSTable Table Cache\n");
    fprintf(OFILE, "=====================\n");
    return;
    }


fprintf(OFILE, "hrFSIndex. . . . . . . . %d\n",
        row->attrib_list[HRFS_INDEX].u.unumber_value);

fprintf(OFILE, "hrFSMountPoint . . . . . \"%s\" (ALWAYS RETURNED AS EMPTY STRING) \n",
        row->attrib_list[HRFS_MOUNTPT].u.string_value);

fprintf(OFILE, "hrFSRemoteMountPoint . . \"%s\"\n",
        row->attrib_list[HRFS_RMOUNTPT].u.string_value);

fprintf(OFILE, "hrFSType . . . . . . . . %d ",
        row->attrib_list[HRFS_TYPE].u.unumber_value);

switch (row->attrib_list[HRFS_TYPE].u.unumber_value) {
    case 1: fprintf(OFILE, "(hrFSOther)\n");            break;
    case 2: fprintf(OFILE, "(hrFSUnknown)\n");          break;
    case 3: fprintf(OFILE, "(hrFSBerkeleyFFS)\n");      break;
    case 5: fprintf(OFILE, "(hrFSFat)\n");              break;
    case 9: fprintf(OFILE, "(hrFSNTFS)\n");             break;
    default:
            fprintf(OFILE, "(???)\n");
    }


fprintf(OFILE, "hrFSAccess . . . . . . . %d ",
        row->attrib_list[HRFS_ACCESS].u.number_value);
switch (row->attrib_list[HRFS_ACCESS].u.unumber_value) {
    case 1: fprintf(OFILE, "(readWrite)\n"); break;
    case 2: fprintf(OFILE, "(readOnly)\n"); break;
    default: 
            fprintf(OFILE, "(???)\n"); break;
    }


fprintf(OFILE, "hrFSBootable . . . . . . %d ",
        row->attrib_list[HRFS_BOOTABLE].u.number_value);

switch (row->attrib_list[HRFS_BOOTABLE].u.unumber_value) {
    case 0: fprintf(OFILE, "(FALSE)\n"); break;
    case 1: fprintf(OFILE, "(TRUE)\n"); break;
    default: 
            fprintf(OFILE, "(???)\n"); break;
    }

fprintf(OFILE, "hrFSStorageIndex . . . . %d\n",
        row->attrib_list[HRFS_STORINDX].u.number_value);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrdevent.c ===
/*
 *  HrDeviceEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrDeviceEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:41:55 1996
 *
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file     */
#include "HMCACHE.H"      /* Cache-related definitions           */
#include "HRDEVENT.H"     /* HrDevice Table  related definitions */
#include <stdio.h>        /* for sprintf                         */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
BOOL
Gen_SingleDevices( void );


#if defined(CACHE_DUMP)

/* debug_print_hrdevice - Prints a Row from HrDevice */
static void
debug_print_hrdevice(
                     CACHEROW     *row  /* Row in hrDiskStorage table */
                     );
#endif


/*
|==============================================================================
| Create the list-head for the HrDevice table cache.
|
| This list-head is globally accessible so the logic that loads the "sub" 
| tables can scan this cache for matches (among other reasons).
|
| (This macro is defined in "HMCACHE.H").
*/
CACHEHEAD_INSTANCE(hrDevice_cache, debug_print_hrdevice);


/*
|==============================================================================
| Initial Load Device
|
| This number is the index into hrDevice table for the entry that corresponds
| to the disk from which the system was initially loaded.
|
| This static location serves as "cache" for the value of 
| "HrSystemInitialLoadDevice" (serviced by code in "HRSYSTEM.C").
|
| It is initialized by function "Gen_Fixed_disks()" in module "HRDISKST.C"
| which is called by way of "Gen_HrDiskStorage_Cache()" invoked from this
| module.  It is during the scan of the fixed disks that we discover from which
| one the system booted.
*/
ULONG   InitLoadDev_index=0;


/*
 *  GetHrDeviceIndex
 *    A unique value for each device contained by the host.  The value for 
 *    each device must remain constant at least from one re-initi
 *    
 *    Gets the value for HrDeviceIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "A unique value for each device contained by the host.  The value for each
 | device must remain constant at least from one re-initialization of the agent
 | to the next re-initialization."
 | 
 | DISCUSSION:
 | 
 | As mentioned in the discussion for this table, all entries for this table
 | are derived from a local cache built at start-up time.  As a consequence the
 | maximum value of this attribute is fixed at SNMP service start-time.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.1.<instance>
 |                | | | |
 |                | | | *hrDeviceIndex
 |                | | *hrDeviceEntry
 |                | *hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDeviceIndex" value from this entry
*/
*outvalue = row->attrib_list[HRDV_INDEX].u.unumber_value;


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceIndex() */


/*
 *  GetHrDeviceType
 *    An indication of the type of device.
 *    
 *    Gets the value for HrDeviceType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceType
 | 
 |  ACCESS         SYNTAX
 |  read-only      OBJECT IDENTIFIER
 | 
 |   "An indication of the type of device.
 | 
 |   If this value is `hrDeviceProcessor { hrDeviceTypes3 }'
 |   then an entry exists in the hrProcessorTable
 |   which corresponds to this device.
 | 
 |   If this value is `hrDeviceNetwork { hrDeviceTypes 4}',
 |   then an entry exists in the hrNetworkTable
 |   which corresponds to this device.
 | 
 |   If this value is `hrDevicePrinter { hrDeviceTypes 5}',
 |   then an entry exists in the hrPrinterTable
 |   which corresponds to this device.
 | 
 |   If this value is `hrDeviceDiskStorage {hrDeviceTypes 6 }',
 |   then an entry exists in the
 |   hrDiskStorageTable which corresponds to this
 |   device."
 | 
 | DISCUSSION:
 | 
 | The list of registered device types (i.e. values that can be used in the
 | hrDeviceType attribute) are:
 | 
 |    hrDeviceOther             OBJECT IDENTIFIER ::= { hrDeviceTypes 1 }
 |    hrDeviceUnknown           OBJECT IDENTIFIER ::= { hrDeviceTypes 2 }
 |    hrDeviceProcessor         OBJECT IDENTIFIER ::= { hrDeviceTypes 3 }
 |    hrDeviceNetwork           OBJECT IDENTIFIER ::= { hrDeviceTypes 4 }
 |    hrDevicePrinter           OBJECT IDENTIFIER ::= { hrDeviceTypes 5 }
 |    hrDeviceDiskStorage       OBJECT IDENTIFIER ::= { hrDeviceTypes 6 }
 |    hrDeviceVideo             OBJECT IDENTIFIER ::= { hrDeviceTypes 10 }
 |    hrDeviceAudio             OBJECT IDENTIFIER ::= { hrDeviceTypes 11 }
 |    hrDeviceCoprocessor       OBJECT IDENTIFIER ::= { hrDeviceTypes 12 }
 |    hrDeviceKeyboard          OBJECT IDENTIFIER ::= { hrDeviceTypes 13 }
 |    hrDeviceModem             OBJECT IDENTIFIER ::= { hrDeviceTypes 14 }
 |    hrDeviceParallelPort      OBJECT IDENTIFIER ::= { hrDeviceTypes 15 }
 |    hrDevicePointing          OBJECT IDENTIFIER ::= { hrDeviceTypes 16 }
 |    hrDeviceSerialPort        OBJECT IDENTIFIER ::= { hrDeviceTypes 17 }
 |    hrDeviceTape              OBJECT IDENTIFIER ::= { hrDeviceTypes 18 }
 |    hrDeviceClock             OBJECT IDENTIFIER ::= { hrDeviceTypes 19 }
 |    hrDeviceVolatileMemory    OBJECT IDENTIFIER ::= { hrDeviceTypes 20 }
 |    hrDeviceNonVolatileMemory OBJECT IDENTIFIER ::= { hrDeviceTypes 21 }
 | 
 | (See discussion above for hrDeviceTable).
 |============================================================================
 | 1.3.6.1.2.1.25.3.1.n
 |                | | |
 |                | | * Identifying arc for type
 |                | *-hrDeviceTypes (OIDs specifying device types)
 |                *-hrDevice
 |
 | 1.3.6.1.2.1.25.3.2.1.2.<instance>
 |                | | | |
 |                | | | *-hrDeviceType
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrDevice_Cache()",
| and it's minions the cached value is the right-most arc we must return
| as the value.
|
| Hence whatever cache entry we retrieve, we tack the number retrieved
| from the cache for this attribute onto { hrDeviceType ... }.
*/
if ( (outvalue->ids = SNMP_malloc(10 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 10;


/*
| Load in the full hrDeviceType OID:
|
| 1.3.6.1.2.1.25.3.1.n
|                | | |
|                | | * Identifying arc for type
|                | *-hrDeviceTypes (OIDs specifying device types)
|                *-hrDevice
*/
outvalue->ids[0] = 1;
outvalue->ids[1] = 3;
outvalue->ids[2] = 6;
outvalue->ids[3] = 1;
outvalue->ids[4] = 2;
outvalue->ids[5] = 1;
outvalue->ids[6] = 25;
outvalue->ids[7] = 3;
outvalue->ids[8] = 1;

/* Cached Device Type indicator */
outvalue->ids[9] = row->attrib_list[HRDV_TYPE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceType() */


/*
 *  GetHrDeviceDesc
 *    A textual description of this device, including the device's 
 *    manufacturer and revision, and optionally, its serial number.
 *    
 *    Gets the value for HrDeviceDesc.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceDescr
 | 
 |  ACCESS         SYNTAX
 |  read-only      DisplayString (SIZE (0..64))
 | 
 | "A textual description of this device, including the device's manufacturer and
 | revision, and optionally, its serial number."
 | 
 | DISCUSSION:
 | 
 | (See discussion above for hrDeviceTable, the information source for this
 |  attribute depends on the device type).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.3.<instance>
 |                | | | |
 |                | | | *-hrDeviceDescr
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceDesc( 
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

outvalue->string = row->attrib_list[HRDV_DESCR].u.string_value;

/* "Truncate" here to meet RFC as needed*/
if ((outvalue->length = strlen(outvalue->string)) > 64) {
    outvalue->length = 64;
    }


return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceDesc() */


/*
 *  GetHrDeviceID
 *    The product ID for this device.
 *    
 *    Gets the value for HrDeviceID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceID
 | 
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 | 
 | "The product ID for this device."
 | 
 |    ProductID ::= OBJECT IDENTIFIER
 | 
 |    "unknownProduct will be used for any unknown ProductID:
 |     unknownProduct OBJECT IDENTIFIER ::= { 0 0 }
 | 
 | DISCUSSION:
 | 
 | <POA-10> I anticipate always using "unknownProduct" as the value for this
 | attribute, as I can envision no systematic means of acquiring a registered
 | OID for all devices to be used as the value for this attribute.
 | 
 | RESOLVED >>>>>>>>
 | <POA-10> Returning an unknown Product ID is acceptable.
 | RESOLVED >>>>>>>>
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.4.<instance>
 |                | | | |
 |                | | | *-hrDeviceID
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0" 
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceID() */


/*
 *  GetHrDeviceStatus
 *    The current operational state of the device described by this row of the 
 *    table.  A value unknown (1) indicates that the current 
 *    
 *    Gets the value for HrDeviceStatus.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceStatus
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {unknown(1),running(2),warning(3),testing(4),
 |                          down(5)}
 | 
 | "The current operational state of the device described by this row of the
 | table.  A value unknown(1) indicates that the current state of the device is
 | unknown.  running(2) indicates that the device is up and running and that no
 | unusual error conditions are known.  The warning(3) state indicates that agent
 | has been informed of an unusual error condition by the operational software
 | (e.g., a disk device driver) but that the device is still 'operational'.  An
 | example would be high number of soft errors on a disk.  A value of testing(4),
 | indicates that the device is not available for use because it is in the
 | testing state.  The state of down(5) is used only when the agent has been
 | informed that the device is not available for any use."
 | 
 | DISCUSSION:
 | 
 | For those devices for which a driver can be queried for the device status,
 | this is done.  For all other circumstances, "unknown(1)" is returned.
 | 
 | (See discussion above for hrDeviceTable, the information source for this
 |  attribute depends on the device type).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.5.<instance>
 |                | | | |
 |                | | | *-hrDeviceStatus
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceStatus( 
        OUT INThrDeviceStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrDevice_Cache()",
| and its minions the cached value in the row just fetched above for
| the "hrDeviceType" attribute (indexed by our symbol "HRDV_TYPE") is the
| last arc in the OID that specifies the type of device for which we need
| to return status/errors.
|
| The scheme for returning status depends on the value of the type to
| dispatch to the correct code to handle that kind of device.
|
| Also, code that initializes the hrDevice cache for any given device
| has the option of storing in the "hidden context" attribute (accessed via 
| our symbol "HIDDEN_CTX") information needed to access that device.
| 
| For instance, the code that enters Printer devices into hrDevice (in
| function "Gen_HrPrinter_Cache()" in "HRPRINTE.C") stores a string in
| "HIDDEN_CTX" that is the printer name thereby allowing logic below to 
| re-open that printer to obtain status/errors.
|
*/
switch ( row->attrib_list[HRDV_TYPE].u.unumber_value ) {

    case HRDV_TYPE_LASTARC_PRINTER:
        /*  (In "HRPRINTE.C") */
        if (!COMPUTE_hrPrinter_status(row, (UINT *) outvalue)) {
            return SNMP_ERRORSTATUS_GENERR;
            }
        break;


    case HRDV_TYPE_LASTARC_PROCESSOR:
        /* Any processor in the table is running */
        *outvalue = 2;
        break;


    case HRDV_TYPE_LASTARC_DISKSTORAGE:
        /* Stored by Gen_hrDiskStorage_cache() */
        *outvalue =  row->attrib_list[HRDV_STATUS].u.unumber_value;
        break;


    case HRDV_TYPE_LASTARC_KEYBOARD:
    case HRDV_TYPE_LASTARC_POINTING:
        /* Any Keyboard or Mouse in the table is reasably presumed "running" */
        *outvalue = 2;  // "running"
        break;


    case HRDV_TYPE_LASTARC_PARALLELPORT:
    case HRDV_TYPE_LASTARC_SERIALPORT:
        *outvalue = 1;  // "Unknown"
        break;


    case HRDV_TYPE_LASTARC_OTHER:
    case HRDV_TYPE_LASTARC_UNKNOWN:
    case HRDV_TYPE_LASTARC_NETWORK:
    case HRDV_TYPE_LASTARC_VIDEO:
    case HRDV_TYPE_LASTARC_AUDIO:
    case HRDV_TYPE_LASTARC_COPROCESSOR:
    case HRDV_TYPE_LASTARC_MODEM:
    case HRDV_TYPE_LASTARC_TAPE:
    case HRDV_TYPE_LASTARC_CLOCK:
    case HRDV_TYPE_LASTARC_VOLMEMORY:
    case HRDV_TYPE_LASTARC_NONVOLMEMORY:

        *outvalue = 1;  // "Unknown"
        break;


    default:
        return SNMP_ERRORSTATUS_GENERR;

    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDeviceStatus() */


/*
 *  GetHrDeviceErrors
 *    The number of errors detected on this device.  It should be noted that as 
 *    this object has a SYNTAX of Counter, that it does not 
 *    
 *    Gets the value for HrDeviceErrors.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDeviceErrors
 |  ACCESS         SYNTAX
 |  read-only      Counter
 | 
 | "The number of errors detected on this device.  It should be noted that as
 | this object has a SYNTAX of Counter, that it does not have a defined initial
 | value.  However, it is recommended that this object be initialized to zero."
 | 
 | 
 | DISCUSSION:
 | 
 | For those devices for which a driver can be queried for the device errors,
 | this is done.  For all other circumstances, "0" is returned.
 | 
 | (See discussion above for hrDeviceTable, the information source for this
 |  attribute depends on the device type).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.2.1.6.<instance>
 |                | | | |
 |                | | | *-hrDeviceErrors
 |                | | *-hrDeviceEntry
 |                | *-hrDeviceTable
 |                *-hrDevice
 */

UINT
GetHrDeviceErrors( 
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_HrDevice_Cache()",
| and its minions the cached value in the row just fetched above for
| the "hrDeviceType" attribute (indexed by our symbol "HRDV_TYPE") is the
| last arc in the OID that specifies the type of device for which we need
| to return status/errors.
|
| The scheme for returning status depends on the value of the type to
| dispatch to the correct code to handle that kind of device.
|
| Also, code that initializes the hrDevice cache for any given device
| has the option of storing in the "hidden context" attribute (accessed via 
| our symbol "HIDDEN_CTX") information needed to access that device.
| 
| For instance, the code that enters Printer devices into hrDevice (in
| function "Gen_HrPrinter_Cache()" in "HRPRINTE.C") stores a string in
| "HIDDEN_CTX" that is the printer name thereby allowing logic below to 
| re-open that printer to obtain status/errors.
|
*/
switch ( row->attrib_list[HRDV_TYPE].u.unumber_value ) {

    case HRDV_TYPE_LASTARC_PRINTER:

        /*  (In "HRPRINTE.C") */
        if (!COMPUTE_hrPrinter_errors(row, outvalue)) {
            return SNMP_ERRORSTATUS_GENERR;
            }
        break;


    case HRDV_TYPE_LASTARC_PROCESSOR:

        /* If 'errors' ain't 0, odds are low you're gonna find out via SNMP */
        *outvalue = 0;
        break;


    case HRDV_TYPE_LASTARC_POINTING:
    case HRDV_TYPE_LASTARC_KEYBOARD:
    case HRDV_TYPE_LASTARC_PARALLELPORT:
    case HRDV_TYPE_LASTARC_SERIALPORT:
        /* 'errors' presumed 0 */
        *outvalue = 0;
        break;


    case HRDV_TYPE_LASTARC_OTHER:
    case HRDV_TYPE_LASTARC_UNKNOWN:
    case HRDV_TYPE_LASTARC_NETWORK:
    case HRDV_TYPE_LASTARC_DISKSTORAGE:
    case HRDV_TYPE_LASTARC_VIDEO:
    case HRDV_TYPE_LASTARC_AUDIO:
    case HRDV_TYPE_LASTARC_COPROCESSOR:
    case HRDV_TYPE_LASTARC_MODEM:
    case HRDV_TYPE_LASTARC_TAPE:
    case HRDV_TYPE_LASTARC_CLOCK:
    case HRDV_TYPE_LASTARC_VOLMEMORY:
    case HRDV_TYPE_LASTARC_NONVOLMEMORY:
        *outvalue = 0;
        break;

    default:
        return SNMP_ERRORSTATUS_GENERR;

    }

return SNMP_ERRORSTATUS_NOERROR ;
} /* end of GetHrDeviceErrors() */


/*
 *  HrDeviceEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDeviceEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRDEVICEENTRY_VAR_INDEX )
    // No instance was specified
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRDEVICEENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

    tmp_instance = FullOid->ids[ HRDEVICEENTRY_VAR_INDEX ] ;

        /*
        | For hrDeviceTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDeviceTable cache.
        | Check that here.
        */
    if ( FindTableRow(tmp_instance, &hrDevice_cache) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
    else
    {
        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.
        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDeviceEntryFindInstance() */



/*
 *  HrDeviceEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDeviceEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRDEVICEENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRDEVICEENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDeviceEntryFindNextInstance() */



/*
 *  HrDeviceEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrDeviceEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrDeviceEntryConvertInstance() */




/*
 *  HrDeviceEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrDeviceEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrDevice Table */
} /* end of HrDeviceEntryFreeInstance() */


/*
| End of Generated Code
*/

/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */
/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */
/* Gen_HrDevice_Cache - Generate a initial cache for HrDevice Table */

BOOL
Gen_HrDevice_Cache(
                    void
                    )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDevice table,
|       "HrDevice_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to 
|       populate the cache for the HrDevice table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
| A Row in the hrDeviceTable
| 
| "A (conceptual) entry for one device contained by the host.  As an example, an
| instance of the hrDeviceType object might be named hrDeviceType.3"
| 
|    HrDeviceEntry ::= SEQUENCE {
|            hrDeviceIndex           INTEGER,
|            hrDeviceType            OBJECT IDENTIFIER,
|            hrDeviceDescr           DisplayString,
|            hrDeviceID              ProductID,
|            hrDeviceStatus          INTEGER,
|            hrDeviceErrors          Counter
|        }
| 
| DISCUSSION:
| 
| This is the largest and most complicated table to populate.  The strategy for
| populating entries in this table is to execute a slug of code for each device
| type (in the list below) in an attempt to find all instances of that device
| type.  For some devices, the code uses standard Win32 API functions, for
| others it is clear that special-purpose code is needed to extract the relevant
| information from the "behind the scenes" (direct NT kernel inquiries).
| 
| This table is fully populated with respect to the other tables in the hrDevice
| group. The other tables are sparse tables augmenting only selected entries in
| hrDeviceTable.
| 
| The list of registered device types (i.e. values that can be used in the
| hrDeviceType attribute) are:
| 
|    hrDeviceOther             OBJECT IDENTIFIER ::= { hrDeviceTypes 1 }
|    hrDeviceUnknown           OBJECT IDENTIFIER ::= { hrDeviceTypes 2 }
|    hrDeviceProcessor         OBJECT IDENTIFIER ::= { hrDeviceTypes 3 }
|    hrDeviceNetwork           OBJECT IDENTIFIER ::= { hrDeviceTypes 4 }
|    hrDevicePrinter           OBJECT IDENTIFIER ::= { hrDeviceTypes 5 }
|    hrDeviceDiskStorage       OBJECT IDENTIFIER ::= { hrDeviceTypes 6 }
|    hrDeviceVideo             OBJECT IDENTIFIER ::= { hrDeviceTypes 10 }
|    hrDeviceAudio             OBJECT IDENTIFIER ::= { hrDeviceTypes 11 }
|    hrDeviceCoprocessor       OBJECT IDENTIFIER ::= { hrDeviceTypes 12 }
|    hrDeviceKeyboard          OBJECT IDENTIFIER ::= { hrDeviceTypes 13 }
|    hrDeviceModem             OBJECT IDENTIFIER ::= { hrDeviceTypes 14 }
|    hrDeviceParallelPort      OBJECT IDENTIFIER ::= { hrDeviceTypes 15 }
|    hrDevicePointing          OBJECT IDENTIFIER ::= { hrDeviceTypes 16 }
|    hrDeviceSerialPort        OBJECT IDENTIFIER ::= { hrDeviceTypes 17 }
|    hrDeviceTape              OBJECT IDENTIFIER ::= { hrDeviceTypes 18 }
|    hrDeviceClock             OBJECT IDENTIFIER ::= { hrDeviceTypes 19 }
|    hrDeviceVolatileMemory    OBJECT IDENTIFIER ::= { hrDeviceTypes 20 }
|    hrDeviceNonVolatileMemory OBJECT IDENTIFIER ::= { hrDeviceTypes 21 }
| 
| All of the foregoing types can be divided into two groups based on the
| approach needed to acquire information about them.  Information for the first
| group can be queried using Win32 API functions while the second group 
| requires special inquiry-code.
| 
| (1) Win32 Device-Types  Win32 Function Used
| ----------------------  -------------------
|    hrDeviceOther
|         Partitions      DeviceIoControl (IOCTL_GET_PARTITION_INFO)
| 
|    hrDeviceProcessor    GetSystemInfo
|    hrDevicePrinter      EnumPrinterDrivers
|    hrDeviceDiskStorage  QueryDosDevice/CreateFile (using physical drive access)
|    hrDeviceKeyboard     GetKeyboardType
|    hrDevicePointing     (Win32 function provides pointer-device button-count)
|
| 
| (2) Special-Inquiry Device-Types
| ---------------------------------
|    hrDeviceNetwork      Access is provided via special "mib2util" DLL
| 
|    hrDeviceParallelPort NtQuerySystemInformation(SYSTEM_DEVICE_INFORMATION)
|    hrDeviceSerialPort
| 
|    hrDeviceVideo        ??? NtQuerySystemInformation(SYSTEM_GDI_DRIVER_INFORMATION)
|    hrDeviceAudio        ???
|    hrDeviceTape         ???
| 
| 
| The following "devices" do not readily fall into either of the above groups
| and no attempt is made to recognize them:
| 
|    hrDeviceModem             OBJECT IDENTIFIER ::= { hrDeviceTypes 14 }
|    hrDeviceVolatileMemory    OBJECT IDENTIFIER ::= { hrDeviceTypes 20 }
|    hrDeviceNonVolatileMemory OBJECT IDENTIFIER ::= { hrDeviceTypes 21 }
|    hrDeviceCoprocessor       OBJECT IDENTIFIER ::= { hrDeviceTypes 12 }
|    hrDeviceClock             OBJECT IDENTIFIER ::= { hrDeviceTypes 19 }
| 
| 
| Other Implementation Details
| ----------------------------
| The bulk of the information for this table (and the associated sparse tables
| hrProcessorTable, hrNetworkTable, hrPrinterTable, hrDiskStorageTable,
| hrPartitionTable and hrFSTable) is acquired and stored in a local cache at the
| time the SNMP agent enrolls the DLL for the Host Resources MIB.  This strategy
| is designed to reduce the hit on system resources when requests are processed.
| The only information that is acquired dynamically (on a per SNMP request) is
| information for variables likely to be dynamic: Status and Error status.
| 
| One consequence of this strategy is that user-implemented changes to the
| system configuration (including changing printer drivers, or disk partition
| layout) will not be reported until the SNMP service is restarted.
| 
| 
|============================================================================
| 1.3.6.1.2.1.25.3.1.n
|                | | |
|                | | * Identifying arc for type
|                | *-hrDeviceTypes (OIDs specifying device types)
|                *-hrDevice
|
| 1.3.6.1.2.1.25.3.2.1....
|                | | |
|                | | *hrDeviceEntry
|                | *hrDeviceTable
|                *-hrDevice
|
*/
{


/*
|============================================================================
|
| Call the "Gen_*_cache()" functions for each of the "sub-tables" within
| the hrDevice table.
|
| Each of these functions is responsible for:
|
|       + populating the hrDevice cache with however many rows are called for
|         given the device(s) available
|
|       + creating and populating their own cache for the sub-table if
|         the sub-table needs a cache.  (If all the sub-table attributes
|         are "computed" on request, then there is no need for a separate 
|         sub-table cache).
*/

// Blow away any old copy of the cache
DestroyTable(&hrDevice_cache);

if (Gen_HrPrinter_Cache(HRDV_TYPE_LASTARC_PRINTER) == FALSE) {
    DestroyTable(&hrDevice_cache);
    return ( FALSE );
    }

if (Gen_HrProcessor_Cache(HRDV_TYPE_LASTARC_PROCESSOR) == FALSE) {
    DestroyTable(&hrDevice_cache);
    return ( FALSE );
    }

if (Gen_HrNetwork_Cache(HRDV_TYPE_LASTARC_NETWORK) == FALSE) {
    DestroyTable(&hrDevice_cache);
    return ( FALSE );
    }

if (Gen_HrDiskStorage_Cache(HRDV_TYPE_LASTARC_DISKSTORAGE) == FALSE) {
    DestroyTable(&hrDevice_cache);
    return ( FALSE );
    }


/*
|============================================================================
|
| Now handle the odd "one-off" devices for which potentially just a single 
| entry is made into the existing hrDevice table cache.
*/
if (Gen_SingleDevices() == FALSE) {
    DestroyTable(&hrDevice_cache);
    return ( FALSE );
    }

#if defined(CACHE_DUMP)
PrintCache(&hrDevice_cache);
PrintCache(&hrDiskStorage_cache);
#endif


/*
| HrDevice cache generation complete.
*/
return ( TRUE );
}


/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */
/* Gen_SingleDevices - Generate Single Device row entries in HrDevice */

BOOL
Gen_SingleDevices( void )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function creates a new row entry populated with all "static" cache-able
|       values for HrDevice table for each "one-off" device and returns TRUE.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       being populated.  This function handles populating hrDevice with
|       a row for each "single-type" device (such as keyboard).
|
|  OTHER THINGS TO KNOW:
|
|       Devices being added by this function are not associated with
|       sub-tables.
|
|       We handle:
|         + Keyboard "device"
|         + Pointing "device"
|         + Parallel and Serial Port "devices"
|
*/
{
UINT    key_status;             /* Value returned from GetKeyboardType()    */
UINT    button_count;           /* Mouse button count from GetSystemMetrics */
CHAR    msg[MAX_PATH+1];        /* (Big enough for constant strings below)  */
UINT    dev_number;

#define PHYS_SIZE 64
CHAR    phys_name[PHYS_SIZE+1]; /* Buffer where a string like "\\.C:" (for */
                                /*  example) is built for drive access.    */
HANDLE                  hdrv;   /* Handle to device                        */
UINT    nPrevErrorMode;         /* previous state of error-mode bit flags  */

// ensures null terminated string
msg[MAX_PATH] = 0;
phys_name[PHYS_SIZE] = 0;

/*
|==============================================================================
| Keyboard Device
|
| If we can get keyboard type... */
if ((key_status = GetKeyboardType(0)) != 0 ) {

    PCHAR       key_type;              /* Description string             */

    /* Select initial part of description string */
    switch (key_status) {
        case 1: key_type = "IBM PC/XT or compatible (83-key) keyboard"; break;
        case 2: key_type = "Olivetti \"ICO\" (102-key) keyboard"; break;
        case 3: key_type = "IBM PC/AT (84-key) or similar keyboard"; break;
        case 4: key_type = "IBM enhanced (101- or 102-key) keyboard"; break;
        case 5: key_type = "Nokia 1050 and similar keyboards"; break;
        case 6: key_type = "Nokia 9140 and similar keyboards"; break;
        case 7: key_type = "Japanese keyboard"; break;
        default: key_type = "Unknown keyboard"; break;
        }

    /* Build the full description string */
    _snprintf(msg, MAX_PATH, "%s, Subtype=(%d)", key_type, GetKeyboardType(1));

    if (AddHrDeviceRow(HRDV_TYPE_LASTARC_KEYBOARD,      // Last Type OID arc
                       msg,                             // Description string
                       NULL,                            // No hidden context
                       CA_UNKNOWN) == NULL) {

        return ( FALSE );       /* Something blew */
        }
    }

/*
|==============================================================================
| Pointing Device
|
| If we can get Mouse Button count... */
if ((button_count = GetSystemMetrics(SM_CMOUSEBUTTONS)) != 0 ) {

    _snprintf(msg, MAX_PATH, "%d-Buttons %s",
            button_count,
            (GetSystemMetrics(SM_MOUSEWHEELPRESENT)) ? " (with wheel)" : "");

 
    if (AddHrDeviceRow(HRDV_TYPE_LASTARC_POINTING,      // Last Type OID arc
                       msg,                             // Description string
                       NULL,                            // No hidden context
                       CA_UNKNOWN) == NULL) {

        return ( FALSE );       /* Something blew */
        }
    }


/*
|==============================================================================
| LPT Devices
|
| For every LPTx device we can open successfully. . .
*/
for (dev_number = 1; dev_number < 4; dev_number += 1) {

    /* Build it for device n: */
    _snprintf(phys_name, PHYS_SIZE, "LPT%d:", dev_number);

    /*
    | Suppress any attempt by the system to talk to the user
    */
    nPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    /* Attempt to get a handle using this physical name string */
    if ((hdrv = CreateFile(phys_name,           // Device
                               GENERIC_READ,    // Access mode
                               FILE_SHARE_READ, // Share Mode
                               NULL,            // Security
                               OPEN_EXISTING,   // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL             // Template file
                           )) != INVALID_HANDLE_VALUE) {

        /*
        | Ok, we managed to get ahold of it, we'll put it in the table.
        */
        CloseHandle(hdrv); // Prefix bug 445177
        if (AddHrDeviceRow(HRDV_TYPE_LASTARC_PARALLELPORT, // Last Type OID arc
                           phys_name,                      // Descr string
                           NULL,                           // No hidden context
                           CA_UNKNOWN) == NULL) {
            SetErrorMode(nPrevErrorMode); /* Turn error suppression mode off */
            return ( FALSE );       /* Something blew */
            }
        
        }   /* if (we managed to "CreateFile" the device) */
    else {
        /*
        | Keep trucking if we couldn't open the device, but quit when we
        | hit this error.
        */
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            SetErrorMode(nPrevErrorMode); /* Turn error suppression mode off */
            break;
            }
        }

    SetErrorMode(nPrevErrorMode);        /* Turn error suppression mode off */
    }   /* For each device */

/*
|==============================================================================
| COM Devices
|
| For every COMx device we can open successfully. . .
*/
for (dev_number = 1; dev_number <= 4; dev_number += 1) {

    /* Build it for device n: */
    _snprintf(phys_name, PHYS_SIZE, "COM%d:", dev_number);

    /*
    | Suppress any attempt by the system to talk to the user
    */
    nPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    /* Attempt to get a handle using this physical name string */
    if ((hdrv = CreateFile(phys_name,           // Device
                               GENERIC_READ,    // Access mode
                               FILE_SHARE_READ, // Share Mode
                               NULL,            // Security
                               OPEN_EXISTING,   // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL             // Template file
                           )) != INVALID_HANDLE_VALUE) {

        /*
        | Ok, we managed to get ahold of it, we'll put it in the table.
        */
        CloseHandle(hdrv); // we don't use it anymore
        if (AddHrDeviceRow(HRDV_TYPE_LASTARC_SERIALPORT,   // Last Type OID arc
                           phys_name,                      // Descr string
                           NULL,                           // No hidden context
                           CA_UNKNOWN) == NULL) {

            SetErrorMode(nPrevErrorMode); /* Turn error suppression mode off */
            return ( FALSE );       /* Something blew */
            }

        }   /* if (we managed to "CreateFile" the device) */
    else {
        /*
        | Keep trucking if we couldn't open the device, but quit when we
        | hit this error (skip share failures).
        */
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            SetErrorMode(nPrevErrorMode); /* Turn error suppression mode off */
            break;
            }
        }

    SetErrorMode(nPrevErrorMode);        /* Turn error suppression mode off */
    }   /* For each device */
    return ( TRUE );    //--ft:09/28-- sundown cleanup
}

/* AddHrDeviceRow - Generate another Row Entry in HrDevice Table */
/* AddHrDeviceRow - Generate another Row Entry in HrDevice Table */
/* AddHrDeviceRow - Generate another Row Entry in HrDevice Table */

CACHEROW *
AddHrDeviceRow(
               ULONG   type_arc,       /* Last Arc value for OID for Type   */
               LPSTR   descr,          /* Description string                */
               void   *hidden_ctx,     /* If non-NULL: Hidden-context value */
               ATTRIB_TYPE  hc_type    /* Type of "hidden_ctx"              */
               )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number that is inserted as the right-most arc in
|       Object Identifier that is the cache entry for the hrDevicetype of the
|       device.
|
|       "descr" is a string pointer that is to be the cached value of
|       the hrDeviceDesc attribute.
|
|       "hidden_ctx" - If non-null, this is a pointer to the value to be
|       stored as the "Hidden Context" attribute in the new row.
|
|       "hc_type" is the type of "hidden_ctx" if hidden_ctx is non-null.
|
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDevice table,
|       "HrDevice_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function creates a new row entry populated with all "static" cache-able
|       values for HrDevice table and returns a pointer to the new row entry.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage" or other
|       internal logic error).
|
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in each of the "sub-hrDevicetable"
|       files to populate the cache for the HrDevice table for the rows
|       pertaining to a particular sub-table (hrProcessorTable, hrPrinterTable
|       etc).
|
|  OTHER THINGS TO KNOW:
|
|  The "hidden_ctx" argument provides an easy way for the caller to stash
|  a value useful for later run-time reference.  For instance, "GET" functions
|  for Printer devices may need a string that identifies the printer (for
|  a given row-entry) in order to lookup the current value of an SNMP 
|  attribute (like the current status).  So the "Hidden Context" attribute
|  may be set to a string that can be submitted to a Win32 function to obtain
|  the current status for the printer.
*/
{
static                          /* NOTE: "static" is a 'must'              */
ULONG     table_index=0;        /* HrDeviceTable index counter             */

CACHEROW *row;                  /* --> Cache structure for row-being built */


/*
| OK, the caller wants another row in the table, get a row-entry created.
*/
if ((row = CreateTableRow( HRDV_ATTRIB_COUNT ) ) == NULL) {
    return ( NULL );       // Out of memory
    }

/*
| Set up the standard-hrDevice attributes in the new row
*/

/* =========== hrDeviceIndex ==========*/
row->attrib_list[HRDV_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRDV_INDEX].u.unumber_value = (table_index += 1) ;


/* =========== hrDeviceType ==========
|
| Some GET functions for "computed" attributes expect to be able to use
| the value of the "hrDeviceType" cache value stored below to dispatch
| to appropriate code based on the device type (using the last type-OID arc
| as the "switch" value).
*/
row->attrib_list[HRDV_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRDV_TYPE].u.unumber_value = type_arc ;


/* =========== hrDeviceDescr ==========*/
row->attrib_list[HRDV_DESCR].attrib_type = CA_STRING;
if ( (row->attrib_list[HRDV_DESCR].u.string_value
      = ( LPSTR ) malloc(strlen(descr) + 1)) == NULL) {
    DestroyTableRow(row);
    return ( NULL );       /* out of memory */
    }
strcpy(row->attrib_list[HRDV_DESCR].u.string_value, descr);


/*
| The rest of the standard hrDevice attributes are "computed" at run time
*/

/* =========== hrDeviceStatus ==========*/
row->attrib_list[HRDV_STATUS].attrib_type = CA_COMPUTED;


/* =========== hrDeviceErrors ==========*/
row->attrib_list[HRDV_ERRORS].attrib_type = CA_COMPUTED;

/*
|================================================================
| If they gave us a hidden-context attribute string, store it now.
*/
if (hidden_ctx != NULL) {

    switch (hc_type) {

        case CA_STRING:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_STRING;
            if ( (row->attrib_list[HIDDEN_CTX].u.string_value
                  = ( LPSTR ) malloc(strlen((LPSTR)hidden_ctx) + 1)) == NULL) {
                DestroyTableRow(row);
                return ( NULL );       /* out of memory */
                }
            strcpy(row->attrib_list[HIDDEN_CTX].u.string_value, hidden_ctx);
            break;

        case CA_NUMBER:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_NUMBER;
            row->attrib_list[HIDDEN_CTX].u.unumber_value =
                                                      *((ULONG *) hidden_ctx);
            break;

        case CA_CACHE:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_CACHE;
            row->attrib_list[HIDDEN_CTX].u.cache = (CACHEHEAD *) hidden_ctx;
            break;

        case CA_UNKNOWN:
            row->attrib_list[HIDDEN_CTX].attrib_type = CA_UNKNOWN;
            break;

        default:
            DestroyTableRow(row);
            return ( NULL );    /* Something wrong */
        }
    }
else {
    /* Show no "Hidden-Context" attribute for this row */
    row->attrib_list[HIDDEN_CTX].attrib_type = CA_UNKNOWN;
    row->attrib_list[HIDDEN_CTX].u.string_value = NULL;
    }

/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrDeviceTable.
*/
if (AddTableRow(row->attrib_list[HRDV_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrDevice_cache                                /* Cache */
                ) == FALSE) {
    DestroyTableRow(row);
    return ( NULL );       /* Internal Logic Error! */
    }

/*
| Meet caller's expectation of receiving a pointer to the new row.
*/
return ( row );
}

#if defined(CACHE_DUMP)

/* debug_print_hrdevice - Prints a Row from HrDevice */
/* debug_print_hrdevice - Prints a Row from HrDevice */
/* debug_print_hrdevice - Prints a Row from HrDevice */

static void
debug_print_hrdevice(
                     CACHEROW     *row  /* Row in hrDiskStorage table */
                     )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{
char    *type;          /* String representation of device type */

if (row == NULL) {
    fprintf(OFILE, "====================\n");
    fprintf(OFILE, "hrDevice Table Cache\n");
    fprintf(OFILE, "====================\n");
    return;
    }

fprintf(OFILE, "hrDeviceIndex. . . . . . . %d\n",
        row->attrib_list[HRDV_INDEX].u.unumber_value);

switch (row->attrib_list[HRDV_TYPE].u.unumber_value) {

    case 1: type = "Other"; break;
    case 2: type = "Unknown"; break;
    case 3: type = "Processor"; break;
    case 4: type = "Network"; break;
    case 5: type = "Printer"; break;
    case 6: type = "DiskStorage"; break;
    case 10: type = "Video"; break;
    case 11: type = "Audio"; break;
    case 12: type = "Coprocessor"; break;
    case 13: type = "Keyboard"; break;
    case 14: type = "Modem"; break;
    case 15: type = "ParallelPort"; break;
    case 16: type = "Pointing"; break;
    case 17: type = "SerialPort"; break;
    case 18: type = "Tape"; break;
    case 19: type = "Clock"; break;
    case 20: type = "VolatileMemory"; break;
    case 21: type = "NonVolatileMemory"; break;
    default: type = "<Unknown!>"; break;
    }

fprintf(OFILE, "hrDeviceType . . . . . . . %d (%s)\n",
        row->attrib_list[HRDV_TYPE].u.unumber_value, type);

fprintf(OFILE, "hrDeviceDescr. . . . . . . %s\n",
        row->attrib_list[HRDV_DESCR].u.string_value);

fprintf(OFILE, "hrDeviceStatus . . . . . . ");
switch (row->attrib_list[HRDV_STATUS].attrib_type) {

    case CA_STRING:
        fprintf(OFILE, "CA_STRING: \"%s\"\n",
                row->attrib_list[HRDV_STATUS].u.string_value);
        break;

    case CA_NUMBER:
        fprintf(OFILE, "CA_NUMBER: %d\n",
                row->attrib_list[HRDV_STATUS].u.unumber_value);
        break;

    case CA_UNKNOWN:
        fprintf(OFILE, "CA_UNKNOWN\n");
        break;

    case CA_COMPUTED:
        fprintf(OFILE, "CA_COMPUTED\n");
        break;

    default:
        fprintf(OFILE, "(INCORRECT)\n");
        break;
    }

fprintf(OFILE, "hrDeviceErrors . . . . . . ");
switch (row->attrib_list[HRDV_ERRORS].attrib_type) {

    case CA_STRING:
        fprintf(OFILE, "CA_STRING: \"%s\"\n",
                row->attrib_list[HRDV_ERRORS].u.string_value);
        break;

    case CA_NUMBER:
        fprintf(OFILE, "CA_NUMBER: %d\n",
                row->attrib_list[HRDV_ERRORS].u.unumber_value);
        break;

    case CA_UNKNOWN:
        fprintf(OFILE, "CA_UNKNOWN\n");
        break;

    case CA_COMPUTED:
        fprintf(OFILE, "CA_COMPUTED\n");
        break;

    default:
        fprintf(OFILE, "(INCORRECT)\n");
        break;
    }


/* Hidden Context */
fprintf(OFILE, "(HIDDEN CONTEXT) . . . . . ");

switch (row->attrib_list[HRDV_TYPE].u.unumber_value) {

    /*
    | What is stored in HIDDEN_CTX is hardwired for these types
    | of cache entries:
    */
    case 3: // "Processor"
        fprintf(OFILE, "CA_NUMBER: %d (Processor Number)\n",
                row->attrib_list[HIDDEN_CTX].u.unumber_value);
        break;


    case 4: // "Network"
        fprintf(OFILE, "CA_NUMBER: %d ( \"hrNetworkIfIndex\" value)\n",
                row->attrib_list[HIDDEN_CTX].u.unumber_value);
        break;


    case 5: // "Printer"
        fprintf(OFILE, "CA_STRING: \"%s\" ( \"OpenPrinter\" string)\n",
                row->attrib_list[HIDDEN_CTX].u.string_value);
        break;


    /* For this type, it varies */
    case 6: // "DiskStorage"

        switch (row->attrib_list[HIDDEN_CTX].attrib_type) {

            case CA_STRING:
                fprintf(OFILE, "CA_STRING: \"%s\"\n",
                        row->attrib_list[HIDDEN_CTX].u.string_value);
                break;

            case CA_NUMBER:
                fprintf(OFILE, "CA_NUMBER: %d\n",
                        row->attrib_list[HIDDEN_CTX].u.unumber_value);
                break;

            case CA_UNKNOWN:
                fprintf(OFILE, "CA_UNKNOWN\n");
                break;

            case CA_COMPUTED:
                fprintf(OFILE, "CA_COMPUTED\n");
                break;

            case CA_CACHE:
                fprintf(OFILE, "CA_CACHE @ 0x%x\n",
                        row->attrib_list[HIDDEN_CTX].u.cache);
                if (row->attrib_list[HIDDEN_CTX].u.cache != NULL) {
                    PrintCache(row->attrib_list[HIDDEN_CTX].u.cache);
                    }
                break;
            }

        break;


    case 10: // "Video"
    case 11: // "Audio"
    case 12: // "Coprocessor"
    case 13: // "Keyboard"
    case 14: // "Modem"
    case 15: // "ParallelPort"
    case 16: // "Pointing"
    case 17: // "SerialPort"
    case 18: // "Tape"
    case 19: // "Clock"
    case 20: // "VolatileMemory"
    case 21: // "NonVolatileMemory"
    case 2: // "Unknown"
    case 1: // "Other"
    default:
        fprintf(OFILE, "<None>\n");
        break;

    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrprinte.c ===
/*
 *  HrPrinterEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrPrinterEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:42:50 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */
#include "HRDEVENT.H"     /* HrDevice Table  related definitions */
#include <winspool.h>     /* Needed to acquire printer-status*/



/*
 *  GetHrPrinterStatus
 *    The current status of this printer device.
 *    
 *    Gets the value for HrPrinterStatus.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPrinterStatus
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {other(1),unknown(2),idle(3),printing(4),warmup(5)}
 | 
 | "The current status of this printer device.  When in the idle(1), printing(2),
 | or warmup(3) state, the corresponding hrDeviceStatus should be running(2) or
 | warning(3).  When in the unknown state, the corresponding hrDeviceStatus
 | should be unknown(1)."
 | 
 | DISCUSSION:
 | 
 | <POA-14> The actual status and error state of a hardware printer is deeply
 | buried with respect to the application level.  Given that we can acquire
 | the name of the printer driver for a printer, some input on how best to
 | report the hardware status and error state would be appreciated.
 | 
 | LIMITED RESOLUTION >>>>>>>>
 | <POA-14> We report logical printers as though they were hardware printers.
 | This results in certain "undercount" and "overcount" situations when using
 | Host MIB values for inventory purposes.  For status purposes, the status
 | of the logical printers is returned.
 | LIMITED RESOLUTION >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.5.1.1.<instance>
 |                | | | |
 |                | | | *hrPrinterStatus
 |                | | *hrPrinterEntry
 |                | *hrPrinterTable
 |                *-hrDevice
 */

UINT
GetHrPrinterStatus( 
        OUT INThrPrinterStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Ok, here's the skinny:  Just about all the status information that can
| be acquired about a printer under NT is acquired by
| "COMPUTE_hrPrinter_status()" that was written to service the need of
| reporting general status for printer devices out of "hrDeviceStatus".
|
| Since we can't gather any more information reliably than this function
| does, we simply call it and map the return codes it provides as values
| for "hrDeviceStatus" into codes appropriate for this attribute variable.
|
*/
if (COMPUTE_hrPrinter_status(row, (UINT *) outvalue) != TRUE) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* We get back:
|               "unknown" = 1   If we can't open the printer at all.
|
|               "running" = 2   If we can open the printer and no status is
|                               showing on it.
|               "warning" = 3   If we can open the printer but PAUSED or
|                               PENDING_DELETION is showing on it.
*/
switch (*outvalue) {

    case 1:             // "unknown" for hrDeviceStatus
        *outvalue = 2;  // goes to-> "unknown" for hrPrinterStatus
        break;


    case 2:             // "running" for hrDeviceStatus
    case 3:             // "warning" for hrDeviceStatus
    default:
        *outvalue = 1;  // goes to-> "other" for hrPrinterStatus
        break;
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPrinterStatus() */


/*
 *  GetHrPrinterDetectedErrorState
 *    The error conditions as detected by the printer.
 *    
 *    Gets the value for HrPrinterDetectedErrorState.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPrinterDetectedErrorState
 | 
 |  ACCESS         SYNTAX
 |  read-only      OCTET STRING
 | 
 | "This object represents any error conditions detected by the printer.  The
 | error conditions are encoded as bits in an octet string, with the following
 | definitions:
 | 
 |     Condition         Bit #    hrDeviceStatus
 | 
 |     lowPaper          0        warning(3)
 |     noPaper           1        down(5)
 |     lowToner          2        warning(3)
 |     noToner           3        down(5)
 |     doorOpen          4        down(5)
 |     jammed            5        down(5)
 |     offline           6        down(5)
 |     serviceRequested  7        warning(3)
 | 
 | If multiple conditions are currently detected and the hrDeviceStatus would not
 | otherwise be unknown(1) or testing(4), the hrDeviceStatus shall correspond to
 | the worst state of those indicated, where down(5) is worse than warning(3)
 | which is worse than running(2).
 | 
 | Bits are numbered starting with the most significant bit of the first byte
 | being bit 0, the least significant bit of the first byte being bit 7, the most
 | significant bit of the second byte being bit 8, and so on.  A one bit encodes
 | that the condition was detected, while a zero bit encodes that the condition
 | was not detected.
 | 
 | This object is useful for alerting an operator to specific warning or error
 | conditions that may occur, especially those requiring human intervention."
 | 
 | DISCUSSION:
 | 
 | (See discussion above for "hrPrinterStatus").
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.5.1.2.<instance>
 |                | | | |
 |                | | | *hrPrinterDetectedErrorState
 |                | | *hrPrinterEntry
 |                | *hrPrinterTable
 |                *-hrDevice
 */

UINT
GetHrPrinterDetectedErrorState( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that under NT, you can barely tell
| if the printer is on, unlike 95, where you can tell if it is on its
| second bottle of toner for the day.
|
| Consequently we return a single all-bits zero octet regardless of 
| the instance value (which by now in the calling sequence of things
| has been validated anyway).
*/

outvalue->length = 1;
outvalue->string = "\0";

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPrinterDetectedErrorState() */


/*
 *  HrPrinterEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPrinterEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT             tmp_instance;  /* Instance arc value                 */
    CACHEROW        *row;           /* Row entry fetched from cache       */

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRPRINTERENTRY_VAR_INDEX )
    // No instance was specified
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRPRINTERENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

    tmp_instance = FullOid->ids[ HRPRINTERENTRY_VAR_INDEX ] ;

        /*
        | For hrPrinterTable, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDeviceTable cache.
        |
        | Check that here.
        */
    if ( (row = FindTableRow(tmp_instance, &hrDevice_cache)) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
    else
    {
            /*
            | The instance arc selects an hrDeviceTable row entry, but is that
            | entry actually for a device of type "Printer"?
            |
            | (We examine the last arc of the OID that specifies the device
            |  type in the row entry selected by the instance arc).
            */
            if (row->attrib_list[HRDV_TYPE].u.unumber_value !=
                HRDV_TYPE_LASTARC_PRINTER) {

                return SNMP_ERRORSTATUS_NOSUCHNAME;
                }

        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.

        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrPrinterEntryFindInstance() */



/*
 *  HrPrinterEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPrinterEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRPRINTERENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRPRINTERENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    /*
    | The instance arc selects an hrDeviceTable row entry, but is that
    | entry actually for a device of type "Printer"?
    |
    | (We examine the last arc of the OID that specifies the device
    |  type in the row entry selected by the instance arc).
    */
    do {
        if (row->attrib_list[HRDV_TYPE].u.unumber_value ==
            HRDV_TYPE_LASTARC_PRINTER) {

            /* Found an hrDeviceTable entry for the right device type */
            break;
            }

        /* Step to the next row in the table */
        row = GetNextTableRow( row );
        }
        while ( row != NULL );

    /* If we found a proper device-type row . . . */
    if ( row != NULL) {
        instance->ids[ 0 ] = row->index ;
        instance->idLength = 1 ;
        }
    else {

        /*
        | Fell off the end of the hrDeviceTable without finding a row
        | entry that had the right device type.
        */
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrPrinterEntryFindNextInstance() */



/*
 *  HrPrinterEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrPrinterEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrPrinterEntryConvertInstance() */




/*
 *  HrPrinterEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrPrinterEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrPrinter Table */
} /* end of HrPrinterEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */
/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */
/* Gen_HrPrinter_Cache - Generate a initial cache for HrDevice PRINTER Table */

BOOL
Gen_HrPrinter_Cache(
                    ULONG type_arc
                    )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the HrDevice cache has been fully
|       populated with all rows required for Printer devices.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" to
|       populate the cache for the HrDevice table with printer-specific
|       entries.
|
|  OTHER THINGS TO KNOW:
|
|       Since all the attributes in the HrPrinter "sub" table are computed
|       upon request (based on cached information in a selected row in the
|       HrDevice table) there is no need to build a cache specifically for
|       this sub-table.  (This routine is loading the HrDevice cache despite
|       it's name).                                   --------
|
|       This function holds a convention with the GET routines earlier in
|       this module that the "HIDDEN_CTX" attribute for printers contains
|       a string that can be used in OpenPrinter to get a handle to that
|       printer.
|============================================================================
| 1.3.6.1.2.1.25.3.5.1...
|                | | |
|                | | *hrPrinterEntry
|                | *hrPrinterTable
|                *-hrDevice
|
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
DWORD   PI_request_len = 0;     /* Printer Info: Storage actually needed   */
DWORD   PI_count = 0;           /* Count of Printer Infos returned         */
UINT    i;                      /* Handy-Dandy loop index                  */
PRINTER_INFO_4 
        *PrinterInfo;           /* --> allocated storage for drive strings */
BOOL    result;                 /* result of winspool API call             */
DWORD   dwLastError;            /* last error                              */


/*
| We're going to call EnumPrinters() twice, once to get the proper
| buffer size, and the second time to actually get the printer info.
*/
result = EnumPrinters(PRINTER_ENUM_LOCAL,  // Flags
                      NULL,                // Name (ignored)
                      4,                   // Level
                      temp,                // Buffer
                      1,                   // "Too Small" Buffer size
                      &PI_request_len,     // Required length... comes back.
                      &PI_count
                      );
if (result)
{
    // When there is no data from spooler *and* spooler is 
    // running, we'll be here.
    return TRUE; // empty table
}

// Assert: result == FALSE
dwLastError = GetLastError();           // save last error

if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
{
    //
    // EnumPrinters Failed and the last error is not 
    // ERROR_INSUFFICIENT_BUFFER, we'll bail out with 0 entries in the 
    // table.
    // For example, if spooler service was down, we will be here.
    //
    
    return TRUE; // empty table
}
// Assert: dwLastError == ERROR_INSUFFICIENT_BUFFER

/*
| Grab enough storage for the enumeration structures
*/
if ( (PrinterInfo = malloc(PI_request_len)) == NULL) {
    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Now get the real stuff */
if (!EnumPrinters(PRINTER_ENUM_LOCAL,  // Flags
                  NULL,                // Name (ignored)
                  4,                   // Level
        (unsigned char *) PrinterInfo, // Buffer to receive enumeration
                  PI_request_len,      // Actual buffer size
                  &PI_request_len,     // Required length... comes back.
                  &PI_count
                  )) {

    /* Failed for some reason */
    free( PrinterInfo );
    return ( TRUE ); // empty table
    }


/*
| Now swing down the list, and for every LOCAL printer,
|
|  + Fetch the description
|  + Make an hrDevice table row entry with the printer name & description
*/
for (i = 0; i < PI_count; i += 1) {

    /* If it is a Local printer ... */
    if (PrinterInfo[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) {

        HANDLE  hprinter;       /* Handle to a printer */

        /* Open it to get a handle */
        if (OpenPrinter(PrinterInfo[i].pPrinterName,    // Printer Name
                        &hprinter,                      // Receive handle here
                        NULL                            // Security
                        ) == TRUE) {

            PRINTER_INFO_2     *p2;
            DWORD              P2_request_len = 0 ; // Bytes-needed by GetPrinter


            /*
            | Printer is Open, get a PRINTER_INFO_2 "slug-o-data"
            |
            | 1st call: Fails, but gets buffer size needed.
            */
            result = GetPrinter(hprinter,  // printer handle
                          2,               // Level 2
                          temp,            // Buffer for INFO_2
                          1,               // Buffer-too-small
                          &P2_request_len  // What we really need
                          ); 
            if (result)
            {
                // 1 byte shouldn't be enough to hold PRINTER_INFO_2 structure
                ClosePrinter( hprinter );
                continue; // skip this printer
            }
            
            // Assert: result == FALSE
            dwLastError = GetLastError();           // save last error
            
            if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
            {
                //
                // GetPrinter Failed and the last error is not 
                // ERROR_INSUFFICIENT_BUFFER, we'll skip this printer.
                // For example, if spooler service was down, we will be here.
                //
                
                ClosePrinter(hprinter);
                continue; // skip this printer
            }
            // Assert: dwLastError == ERROR_INSUFFICIENT_BUFFER

            /*
            | Grab enough storage for the PRINTER_INFO_2 structure
            */
            if ( (p2 = malloc(P2_request_len)) == NULL) {

                /* Storage Request failed altogether, can't initialize */
                free( PrinterInfo );
                ClosePrinter( hprinter );
                return ( FALSE );
                }

            /*
            | 2nd call: Should succeed.
            */
            if (GetPrinter(hprinter,        // printer handle
                           2,               // Level 2
                     (unsigned char *) p2,  // Buffer for INFO_2
                           P2_request_len,  // Buffer-just-right
                           &P2_request_len  // What we really need
                           ) == TRUE) {


                /* Add a row to HrDevice Table
                |
                | We're using the printer-driver name as a "Poor Man's"
                | description: the driver "names" are quite descriptive with
                | version numbers yet!.
                |
                | The Hidden Context is the name needed to open the printer
                | to gain information about its status.
                */
                if (AddHrDeviceRow(type_arc,         // DeviceType OID Last-Arc
                                   p2->pDriverName,  // Used as description
                                   PrinterInfo[i].pPrinterName, // Hidden Ctx
                                   CA_STRING         // Hidden Ctx type
                                   ) == NULL ) {

                    /* Failure at a lower level: drop everything */
                    free( p2 );
                    free( PrinterInfo );
                    ClosePrinter( hprinter );
                    return ( FALSE );
                    }
                }

            /* Close up shop on this printer*/
            free( p2 );
            ClosePrinter( hprinter );
            }
        }
    }

free( PrinterInfo );

return ( TRUE );
}

/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */
/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */
/* COMPUTE_hrPrinter_errors - Compute "hrDeviceErrors" for a Printer device */

BOOL
COMPUTE_hrPrinter_errors(
                         CACHEROW *row,
                         UINT     *outvalue
                         )

/*
|  EXPLICIT INPUTS:
|
|       "row" points to the hrDevice cache row for the printer whose error
|       count is to be returned.
|
|       Attribute "HIDDEN_CTX" has a string value that is the name of the
|       printer by convention with "Gen_HrPrinter_Cache()" above.
|
|       "outvalue" is a pointer to an integer to receive the error count.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE and an error count for the specified printer.
|
|     On any Failure:
|       Function returns FALSE.
|
|  THE BIG PICTURE:
|
|       For an hrDevice attribute whose value is "computed", at the time of 
|       the request to see it is received, we dispatch to a "COMPUTE_" function
|       to get the value.  This is such a routine for printers.
|
|  OTHER THINGS TO KNOW:
|
|       This function holds a convention with the Gen_cache routines earlier in
|       this module that the "HIDDEN_CTX" attribute for printers contains
|       a string that can be used in OpenPrinter to get a handle to that
|       printer.
*/
{

/*
| No way to get any error counts under NT 
*/
*outvalue = 0;
return ( TRUE );

}

/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */
/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */
/* COMPUTE_hrPrinter_status - Compute "hrDeviceStatus" for a Printer device */

BOOL
COMPUTE_hrPrinter_status(
                         CACHEROW *row,
                         UINT     *outvalue
                         )

/*
|  EXPLICIT INPUTS:
|
|       "row" points to the hrDevice cache row for the printer whose status
|       is to be returned.
|
|       Attribute "HIDDEN_CTX" has a string value that is the name of the
|       printer by convention with "Gen_HrPrinter_Cache()" above.
|
|       "outvalue" is a pointer to an integer to receive the status.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE and a status for the specified printer:
|
|               "unknown" = 1   If we can't open the printer at all.
|
|               "running" = 2   If we can open the printer and no status is
|                               showing on it.
|               "warning" = 3   If we can open the printer but PAUSED or
|                               PENDING_DELETION is showing on it.
|
|
|     On any Failure:
|       Function returns FALSE.
|
|  THE BIG PICTURE:
|
|       For an hrDevice attribute whose value is "computed", at the time of 
|       the request to see it is received, we dispatch to a "COMPUTE_" function
|       to get the value.  This is such a routine for printers.
|
|  OTHER THINGS TO KNOW:
|
|       This function holds a convention with the Gen_cache routines earlier in
|       this module that the "HIDDEN_CTX" attribute for printers contains
|       a string that can be used in OpenPrinter to get a handle to that
|       printer.
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
HANDLE  hprinter;               /* Handle to a printer */
BOOL    result;
DWORD   dwLastError;

/* Open Printer whose name is in "Hidden Context"  to get a handle */
if (OpenPrinter(row->attrib_list[HIDDEN_CTX].u.string_value,    // Printer Name
                &hprinter,                      // Receive handle here
                NULL                            // Security
                ) == TRUE ) {

    PRINTER_INFO_2     *p2;
    DWORD              P2_request_len = 0; /* Bytes-needed by GetPrinter */

    
    /*
    | Printer is Open, get a PRINTER_INFO_2 "slug-o-data"
    |
    | 1st call: Fails, get buffer size needed.
    */
    result = GetPrinter(hprinter,        // printer handle
                        2,               // Level 2
                        temp,            // Buffer for INFO_2
                        1,               // Buffer-too-small
                        &P2_request_len  // What we really need
                        );

    if (result)
    {
        // 1 byte shouldn't be enough to hold PRINTER_INFO_2 structure
        *outvalue = 1;      // "unknown"
        ClosePrinter( hprinter );
        return ( TRUE );
    }
    
    // Assert: result == FALSE
    dwLastError = GetLastError();           // save last error
    
    if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
    {
        //
        // GetPrinter Failed and the last error is not 
        // ERROR_INSUFFICIENT_BUFFER, returns with unknown status
        // For example, if spooler service was down, we will be here.
        //
        *outvalue = 1;      // "unknown"
        ClosePrinter(hprinter);
        return ( TRUE );
    }
    // Assert: dwLastError == ERROR_INSUFFICIENT_BUFFER

    /*
    | Grab enough storage for the PRINTER_INFO_2 structure
    */
    if ( (p2 = malloc(P2_request_len)) == NULL) {

        /* Storage Request failed altogether */
        ClosePrinter( hprinter );
        return ( FALSE );
        }

    /*
    | 2nd call: Should succeed.
    */
    if (GetPrinter(hprinter,        // printer handle
                   2,               // Level 2
             (unsigned char *) p2,  // Buffer for INFO_2
                   P2_request_len,  // Buffer-just-right
                   &P2_request_len  // What we really need
                   ) == TRUE) {

        /*
        | As of this writing, only two status values are available
        | under NT:
        |
        |       PRINTER_STATUS_PAUSED
        |       PRINTER_STATUS_PENDING_DELETION
        |
        | Basically, if either of these is TRUE, we'll signal "warning".
        | If neither are TRUE, we'll signal "running" (on the basis that
        | we've managed to open the printer OK and it shows no status).
        */
        if (   (p2->Status & PRINTER_STATUS_PAUSED)
            || (p2->Status & PRINTER_STATUS_PENDING_DELETION)) {

            *outvalue = 3;      // "warning"
            }
        else {
            *outvalue = 2;      // "running"
            }
        }

    /* Free up and return */
    ClosePrinter( hprinter );
    free( p2 );
    }
else {
    *outvalue = 1;      // "unknown"
    }

return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrdiskst.c ===
/*
 *  HrDiskStorageEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrDiskStorageEntry.  Actual 
 *    instrumentation code is supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:43:17 1996
 *
 */


#include <windows.h>
#include <malloc.h>
#include <stdio.h>        /* For sprintf                        */
#include <string.h>
#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file    */
#include "HMCACHE.H"      /* Cache-related definitions          */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */
#include <winioctl.h>     /* For PARTITION_INFORMATION et. al.  */


/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */
static BOOL Gen_nonFixed_disks ( ULONG type_arc );

/* Gen_Fixed_disks - Scan for Fixed Disks */
static BOOL Gen_Fixed_disks ( ULONG type_arc );

/* ProcessPartitions - Process Partition Information into HrDevice Row */
static BOOL ProcessPartitions(
                  HANDLE        hdrv,   /* Fixed-Disk containing partitions */
                  CACHEROW     *dv_row, /* Row in hrDevice table for disk   */
                  CHAR         *pntdev  /* NT Device name for physical disk */
                  );

/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */
static CACHEROW *Process_DS_Row ( 
                ULONG       type_arc,  /* hrDeviceType last arc value        */
                ULONG       access,    /* hrDiskStorageAccess = readWrite(1) */
                ULONG       media,     /* hrDiskStorageMedia = floppyDisk(4) */
                ULONG       removable, /* hrDiskStorageRemovable = TRUE      */
                ULONG       capacityKB,/* hrDiskStorageCapacity, (kilobytes) */
                ULONG       status,    /* hrDeviceStatus = unknown(1)        */
                CHAR       *descr      /* hrDeviceDescr string               */
                );

/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */
static PCHAR
FindPartitionLabel(
                   CHAR   *pntdev, /* NT Device name for physical disk */
                   UINT   part_id  /* Partition Number (1-origined)    */
                   );

/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */
static void
debug_print_hrdiskstorage(
                          CACHEROW     *row  /* Row in hrDiskStorage table */
                          );

/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */
static void
debug_print_hrpartition(
                        CACHEROW     *row  /* Row in hrPartition table */
                        );

/*
|==============================================================================
| Create the list-head for the HrDiskStorage cache.
|
| (This macro is defined in "HMCACHE.H").
*/
CACHEHEAD_INSTANCE(hrDiskStorage_cache, debug_print_hrdiskstorage);




/*
 *  GetHrDiskStorageAccess
 *    An indication if this long-term storage device is readable and writable 
 *    or only readable.  This should reflect the media type, a
 *    
 *    Gets the value for HrDiskStorageAccess.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageAccess
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {readWrite(1), readOnly(2)}
 | 
 | "An indication if this long-term storage device is readable and writable or
 | only readable.  This should reflect the media type, any write-protect
 | mechanism, and any device configuration that affects the entire device."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.1.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageAccess
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageAccess" value from this entry
*/
*outvalue = row->attrib_list[HRDS_ACCESS].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageAccess() */


/*
 *  GetHrDiskStorageMedia
 *    An indication of the type of media used in this long-term storage device.
 *    
 *    Gets the value for HrDiskStorageMedia.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageMedia
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {other(1),unknown(2),hardDisk(3),floppyDisk(4),
 |                          opticalDiskROM(5),opticalDiskWORM(6),opticalDiskRW(7),
 |                          ramDisk(8)}
 | 
 | "An indication of the type of media used in this long-term storage device."
 | 
 | Discussion
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.2.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageMedia
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageMedia( 
        OUT INThrDiskStorageMedia *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageAccess" value from this entry
*/
*outvalue = row->attrib_list[HRDS_MEDIA].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageMedia() */


/*
 *  GetHrDiskStorageRemoveble
 *    Denotes whether or not the disk media may be removed from the drive.
 *    
 *    Gets the value for HrDiskStorageRemoveble.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageRemoveble
 | 
 |  ACCESS         SYNTAX
 |  read-only      Boolean
 | 
 | "Denotes whether or not the disk media may be removed from the drive."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.3.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageRemovable
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageRemoveble( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageRemovable" value from this entry
*/
*outvalue = row->attrib_list[HRDS_REMOVABLE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageRemoveble() */


/*
 *  GetHrDiskStorageCapacity
 *    The total size for this long-term storage device.
 *    
 *    Gets the value for HrDiskStorageCapacity.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrDiskStorageCapacity
 | 
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 | 
 | "The total size for this long-term storage device."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.6.1.4.<instance>
 |                | | | |
 |                | | | *-hrDiskStorageCapacity
 |                | | *-hrDiskStorageEntry
 |                | *-hrDiskStorageTable (the table)
 |                *-hrDevice
 */

UINT
GetHrDiskStorageCapacity( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDiskStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrDiskStorageCapacity" value from this entry
*/
*outvalue = row->attrib_list[HRDS_CAPACITY].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrDiskStorageCapacity() */


/*
 *  HrDiskStorageEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDiskStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRDISKSTORAGEENTRY_VAR_INDEX )
    // No instance was specified
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRDISKSTORAGEENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

    tmp_instance = FullOid->ids[ HRDISKSTORAGEENTRY_VAR_INDEX ] ;

        /*
        | For hrDiskStorage, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrDiskStorage cache.
        | Check that here.
        |
        | Note that if there is a row there, there is also one in the
        | hrDevice table with the same index.
        */
    if ( FindTableRow(tmp_instance, &hrDiskStorage_cache) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
    else
    {
        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.
        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDiskStorageEntryFindInstance() */



/*
 *  HrDiskStorageEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrDiskStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then 
    //  NOSUCHNAME is returned so that correct MIB rollover processing occurs.
    //  If this is a table, then the next instance is the one following the 
    //  current instance.
    //
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRDISKSTORAGEENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRDISKSTORAGEENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDiskStorage_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrDiskStorageEntryFindNextInstance() */



/*
 *  HrDiskStorageEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrDiskStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrDiskStorageEntryConvertInstance() */




/*
 *  HrDiskStorageEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrDiskStorageEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrDiskStorageTable */
} /* end of HrDiskStorageEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */
/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */
/* Gen_HrDiskStorage_Cache - Generate a initial cache for HrDiskStorage Table */

BOOL
Gen_HrDiskStorage_Cache(
                    ULONG type_arc
                    )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that both caches have been fully
|       populated with all "static" cache-able values.  This function populates
|       not only the hrDevice table cache but the hrDiskStorage cache as well.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" ("HRDEVENT.C") 
|       to populate the cache for the HrDiskStorage table AND the hrDevice
|       Table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|       This function differs from all of the other corresponding sub-table
|       function instances in that this sub-table has its own cache, rather
|       than depending solely on that of the hrDevice table.
|
|       As a consequence, we don't need fancy logic in the FindInstance()
|       and FindNextInstance() functions to determine whether a particular
|       instance is valid: if it is, there is a row entry in the local
|       hrDiskStorage cache.
|
|       As another consequence, this function must load both caches with
|       data (and it must use the same "index" numbers in both caches
|       for each row entered).
|
|       ----
|
|       The strategy on getting all disks goes like this:
|
|       * Since the "\\.\PHYSICALDRIVEn" trick with "CreateFile" doesn't allow
|         access to floppies or CD-ROMs, we process these separately as a
|         first step.
|
|         + We presume "A:" and "B:" may be floppies and we look for them
|           explicitly.  Any found are presumed "readWrite" and Removable.
|           If a medium is present, we may get a full description plus an
|           accurate storage size, otherwise we just don't know for sure,
|           (DeviceIoControl for drive info fails if no disk is in the
|            floppy drive).
|
|         + We then scan all logical drive strings looking for instances of 
|           CD-ROM drives. Any found are presumed "readOnly" and Removable.
|           We can't obtain storage sizes even if a disk is present for these,
|           so storage is left at zero.
|
|       * Then the  "\\.\PHYSICALDRIVEn" trick is used to enumerate the real
|         hard disks, and real storage sizes are obtainable.
|
|============================================================================
| 1.3.6.1.2.1.25.3.6....
|                | |
|                | *-hrDiskStorageTable (the table)
|                *-hrDevice
*/
{

// Blow away any old copy of the cache
DestroyTable(&hrDiskStorage_cache);

/*
| Do Floppies and CD-ROM drives (non-fixed disks)
*/
if (Gen_nonFixed_disks( type_arc ) == FALSE) {
    DestroyTable(&hrDiskStorage_cache); // destroy any partial rows if necessary
    return ( FALSE );
    }

/*
| Do Fixed drives
*/
if (Gen_Fixed_disks( type_arc ) == FALSE) {
    DestroyTable(&hrDiskStorage_cache);
    return ( FALSE );
    }

/* Success */
return ( TRUE );
}

/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */
/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */
/* Gen_nonFixed_disks - Scan for Floppies and CD-ROMS */

static BOOL
Gen_nonFixed_disks ( 
                    ULONG type_arc
                    )
/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the both cachees have been fully
|       populated with all non-Fixed disks.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|     Part I of hrDiskStorage cache population.
|
|  OTHER THINGS TO KNOW:
|
|     We scan using the list of Logical Disk drive strings from 
|     GetLogicalDriveStrings() formed up into UNC form, (e.g. "\\.\A:"
|     for "A:\" returned from GetLogicalDriveStrings()).
*/
{
CHAR    temp[8];                /* Temporary buffer for first call         */
LPSTR   pDrvStrings;            /* --> allocated storage for drive strings */
LPSTR   pOriginal_DrvStrings;   /* (Needed for final deallocation          */
DWORD   DS_request_len;         /* Storage actually needed                 */
DWORD   DS_current_len;         /* Storage used on 2nd call                */

#define PHYS_SIZE 32
CHAR    phys_name[PHYS_SIZE+1]; /* Buffer where a string like "\\.C:" (for */
                                /*  example) is built for drive access.    */

phys_name[PHYS_SIZE] = 0;       // ensures null terminated phys_name
/*
| We're going to call GetLogicalDriveStrings() twice, once to get the proper
| buffer size, and the second time to actually get the drive strings.
|
| The Bogus call.
*/
if ((DS_request_len = GetLogicalDriveStrings(2, temp)) == 0) {

    /* Request failed altogether, can't initialize */
    return ( FALSE );
    }

/*
| Grab enough storage for the drive strings plus one null byte at the end
*/

if ( (pOriginal_DrvStrings = pDrvStrings = malloc( (DS_request_len + 2) ) )
    == NULL) {

    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Go for all of the strings
|
| The Real Call.
*/
if ((DS_current_len = GetLogicalDriveStrings(DS_request_len, pDrvStrings))
    == 0) {

    /* Request failed altogether, can't initialize */
    free( pOriginal_DrvStrings );
    return ( FALSE );
    }

/*
|==============================================================================
| For each logical drive . . . 
*/
while ( strlen(pDrvStrings) > 0 ) {

    UINT        drivetype;      /* Type of the drive from "GetDriveType()"   */

    /*
    | Get the drive-type so we can decide whether it should participate in
    | this population effort.  We do only CD-ROMS and REMOVABLES.
    */
    drivetype = GetDriveType(pDrvStrings);

    /* Skip the stuff we don't want to look at */
    if ( drivetype != DRIVE_REMOVABLE && drivetype != DRIVE_CDROM ) {

        /* Step to next string, if any */
        pDrvStrings += strlen(pDrvStrings) + 1;

        continue;
        }


    /* If we have room in the buffer to build the handle-name string */
    if ((strlen(pDrvStrings) + strlen("\\\\.\\")) < PHYS_SIZE) {

        #define DESCR_BSZ 512
        CHAR                    d_buf[DESCR_BSZ+1];/* Dsecription bld buff */
        HANDLE                  hdrv;       /* Handle to device           */
        DWORD                   bytes_out;  /* Bytes retnd into geo_info  */
        DISK_GEOMETRY           geo_info;   /* Geometry Info from drive   */
        char                   *mt;         /* Media Type */

        ULONG       access;     /* hrDiskStorageAccess = readWrite(1) */
        ULONG       media;      /* hrDiskStorageMedia = floppyDisk(4) */
        ULONG       removable;  /* hrDiskStorageRemovable = TRUE      */
        ULONG       capacityKB; /* hrDiskStorageCapacity, (kilobytes) */
        ULONG       status;     /* hrDeviceStatus = unknown(1)        */
        CHAR       *descr;      /* hrDeviceDescr string               */
        UINT    nPrevErrorMode; /* previous state of error-mode bit flags */

        d_buf[DESCR_BSZ] = 0;   // ensures null terminated d_buf
        /*                         012345
        |  Build it for device A: "\\.\A:" */
        _snprintf(phys_name, PHYS_SIZE, "\\\\.\\%2.2s", pDrvStrings);

        /*
        |  Set SNMP variables accordingly
        */
        if (drivetype != DRIVE_CDROM) {     /* Floppy */

            access = 1;          /* hrDiskStorageAccess = readWrite(1) */
            media = 4;           /* hrDiskStorageMedia = floppyDisk(4) */
            removable = TRUE;    /* hrDiskStorageRemovable = TRUE      */
            capacityKB = 0;      /* hrDiskStorageCapacity (unknown)    */
            status = 1;          /* hrDeviceStatus = unknown(1)        */
            descr = pDrvStrings; /* hrDeviceDescr, initial (e.g."A:\") */
            }

        else {                              /* CD-ROM */
            /*
            | We can't get much of anything about CD-ROMs except the fact
            | that there is one.  Capacity cannot be presumed as DVD is
            | now available and some drives read both CD-ROMs and DVD.
            */
            access = 2;          /* hrDiskStorageAccess = readOnly(2)  */
            media = 5;           /* hrDiskStorageMedia = opticalDiskROM(5)*/
            removable = TRUE;    /* hrDiskStorageRemovable = TRUE      */
            capacityKB = 0;      /* hrDiskStorageCapacity (unknown)    */
            status = 1;          /* hrDeviceStatus = unknown(1)        */
            descr = pDrvStrings; /* hrDeviceDescr, initial (e.g."D:\") */
            }


        /*
        | Suppress any attempt by the system to make the user put a volume in a
        | removable drive ("CreateFile" will just fail).
        */
        nPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        /* Attempt to get a handle using this physical name string */
        hdrv = CreateFile(phys_name,                   // Device
                               GENERIC_READ,           // device query
                                                       // Share Mode
                               FILE_SHARE_READ   |
                               FILE_SHARE_WRITE,
                               NULL,                   // Security
                               OPEN_EXISTING,          // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL                    // Template file
                               );

        /* If we successfully opened the device . . . */
        if (hdrv != INVALID_HANDLE_VALUE) {

            /*
            | Device is Open.
            |
            | If it is NOT a CD-ROM, (ie, a floppy) its worth trying to get
            | DRIVE GEOMETRY (which will come back if there is a floppy in
            | the drive).
            */

            if (drivetype != DRIVE_CDROM) {     /* Floppy */

                /* ==========================================================
                |  IOCTL_DISK_GET_DRIVE_GEOMETRY
                |
                |  If we can get this, we get a better description and an
                |  accurate capacity value.
                */
                if (DeviceIoControl(hdrv,           // device handle
                                                    // IoControlCode (op-code)
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY,

                                    NULL,           // "input buffer"
                                    0,              // "input buffer size"
                                    &geo_info,      // "output buffer"
                                                    // "output buffer size"
                                    sizeof(DISK_GEOMETRY),

                                    &bytes_out,     // bytes written to geo_info
                                    NULL            // no Overlapped I/o
                                    )) {

                    /*
                    | Compute capacity
                    */
                    capacityKB = (ULONG)
                        ((geo_info.Cylinders.QuadPart * // 64 bits

                        (geo_info.TracksPerCylinder *   // 32 bits
                         geo_info.SectorsPerTrack *
                         geo_info.BytesPerSector)

                        ) / 1024);


                    /* hrDeviceStatus = running(2) */
                    status = 2;

                    switch ( geo_info.MediaType ) {

                        case  F5_1Pt2_512:    mt = "5.25, 1.2MB,  512 bytes/sector"; break;
                        case  F3_1Pt44_512:   mt = "3.5,  1.44MB, 512 bytes/sector"; break;
                        case  F3_2Pt88_512:   mt = "3.5,  2.88MB, 512 bytes/sector"; break;
                        case  F3_20Pt8_512:   mt = "3.5,  20.8MB, 512 bytes/sector"; break;
                        case  F3_720_512:     mt = "3.5,  720KB,  512 bytes/sector"; break;
                        case  F5_360_512:     mt = "5.25, 360KB,  512 bytes/sector"; break;
                        case  F5_320_512:     mt = "5.25, 320KB,  512 bytes/sector"; break;
                        case  F5_320_1024:    mt = "5.25, 320KB,  1024 bytes/sector"; break;
                        case  F5_180_512:     mt = "5.25, 180KB,  512 bytes/sector"; break;
                        case  F5_160_512:     mt = "5.25, 160KB,  512 bytes/sector"; break;
                        case  F3_120M_512:    mt = "3.5, 120M Floppy"; break;
                        case  F3_640_512:     mt = "3.5 ,  640KB,  512 bytes/sector"; break;
                        case  F5_640_512:     mt = "5.25,  640KB,  512 bytes/sector"; break;
                        case  F5_720_512:     mt = "5.25,  720KB,  512 bytes/sector"; break;
                        case  F3_1Pt2_512:    mt = "3.5 ,  1.2Mb,  512 bytes/sector"; break;
                        case  F3_1Pt23_1024:  mt = "3.5 ,  1.23Mb, 1024 bytes/sector"; break;
                        case  F5_1Pt23_1024:  mt = "5.25,  1.23MB, 1024 bytes/sector"; break;
                        case  F3_128Mb_512:   mt = "3.5 MO 128Mb   512 bytes/sector"; break;
                        case  F3_230Mb_512:   mt = "3.5 MO 230Mb   512 bytes/sector"; break;
                        case  F8_256_128:     mt = "8in,   256KB,  128 bytes/sector"; break;

                        default:
                        case  RemovableMedia:
                        case  FixedMedia:
                        case  Unknown:        mt = "Format is unknown"; break;
                        }

                    /* Format a better description if it'll all fit */
                    if ((strlen(pDrvStrings) + strlen(mt) + 1) < DESCR_BSZ ) {
                        _snprintf(d_buf, DESCR_BSZ, "%s%s", pDrvStrings, mt);
                        descr = d_buf;
                        }
                    } /* If (we managed to get geometry information) */
                }

            CloseHandle(hdrv);

            }   /* if (we managed to "CreateFile" the device successfully) */

        SetErrorMode(nPrevErrorMode);   /* Turn error suppression mode off */

        /*
        | Create a row in HrDevice Table and a corresponding row in
        | hrDiskStorage sub-table.
        */
        if ( Process_DS_Row ( 
                             type_arc,  /* hrDeviceType last arc  */
                             access,    /* hrDiskStorageAccess    */
                             media,     /* hrDiskStorageMedia     */
                             removable, /* hrDiskStorageRemovable */
                             capacityKB,/* hrDiskStorageCapacity  */
                             status,    /* hrDeviceStatus         */
                             descr      /* hrDeviceDescr          */
                             ) == NULL) {

            /* Something blew */
            free( pOriginal_DrvStrings );
            return ( FALSE );
            }
        
        }   /* if (we managed to build a device name) */

    /* Step to next string, if any */
    pDrvStrings += strlen(pDrvStrings) + 1;
    }


free( pOriginal_DrvStrings );

/* Successful scan */
return ( TRUE );
}

/* Gen_Fixed_disks - Scan for Fixed Disks */
/* Gen_Fixed_disks - Scan for Fixed Disks */
/* Gen_Fixed_disks - Scan for Fixed Disks */

static BOOL
Gen_Fixed_disks ( 
                    ULONG type_arc
                    )
/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the both cachees have been fully
|       populated with all non-Fixed disks.  If the device from which the
|       system was booted is encountered, it's hrDevice index is set into
|       "InitLoadDev_index" (defined in "HRDEVENT.C").
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|     Part II of hrDiskStorage cache population.
|
|  OTHER THINGS TO KNOW:
|
|     We scan using the "\\.\PHYSICALDRIVEx" syntax permitted to
|     "CreateFile()".  CreateFile seems to allow opens only on disks
|     that are hard-fixed disks (no floppies, no CD-ROMS).
|
|     This function is also (while it is "at it") looking for the drive
|     from which the system was booted (in order to set a global value
|     (hrdevice table index) for the value of "InitLoadDev_index" (defined
|     in "HRDEVENT.C") which becomes the value of "HrSystemInitialLoadDevice".
*/
{
HANDLE  hdrv;                   /* Handle to device                    */
UINT    dev_number;             /* Current "x" in "\\.\PHYSICALDRIVEx" */

#undef  PHYS_SIZE
#define PHYS_SIZE 64
CHAR    phys_name[PHYS_SIZE+1]; /* Buffer where a string like          */
                                /*  "\\.PHYSICALDRIVE0"  (for example) */
                                /* is built for drive access.          */

DRIVE_LAYOUT_INFORMATION *dl;       /* Drive-layout pointer       */
#define BBSz 768
CHAR                    big[BBSz];  /* Big buffer for layout info */
DWORD                   bytes_out;  /* Bytes retnd into "big"     */

CHAR                    windir[MAX_PATH+1]; /* Current Windows Directory      */
CHAR                    ntdev[MAX_PATH+2];  /* NT Device Name for MSDOS drive */
CHAR                    pntdev[MAX_PATH+2]; /* NT Device Name for PHYSICALDRIVE*/
UINT                    nPrevErrorMode; /* previous state of error-mode bit flags */

phys_name[PHYS_SIZE] = 0;  // ensures null terminated phys_name
/*
|==============================================================================
| Compute the NT "device name" we expect is the device from which the
| system was booted.
|
| Strategy:
|
| - Obtain "current windows directory" and truncate to obtain just the MS-DOS
|   device name.
|
| - Do QueryDosDevice to get the underlying "NT Device Name", which will
|   include a "\PartitionX" on the end of it, where "X" is presumed to be
|   the 1-origined partition number.
|
| - Mangle the NT Device Name so that it sez "....\Partition0" (ie "partition
|   zero") which is the NT Device Name we expect to be associated with the
|   "\\.\PHYSICALDRIVEy" string we generate for each valid fixed disk below.
*/
/* If we can get the current Windows Directory */
if (GetWindowsDirectory(windir, MAX_PATH+1) != 0 ) {

    /* Truncate to just "C:" (or whatever) */
    windir[2] = 0;

    /* Obtain the NT Device Name associated with MS-DOS logical drive */
    if (QueryDosDevice(windir, ntdev, MAX_PATH) != 0) {

        PCHAR   partition;

        /* If the string "\Partition" appears in this string */
        if ((partition = strstr(ntdev,"\\Partition")) != NULL) {

            /* Convert it to say "\Partition0" regardless */
            strcpy(partition, "\\Partition0");
            }
        else {
            /* Failure: Null-terminate so we fail gracefully */
            ntdev[0] = '\0';
            }
        }
    else {
        /* Failure: Null-terminate so we fail gracefully */
        ntdev[0] = '\0';
        }
    }
else {
    /* Failure: Null-terminate so we fail gracefully */
    ntdev[0] = '\0';
    }

/*
|==============================================================================
| For every physical device we can open successfully. . .
*/
for (dev_number = 0; ; dev_number += 1) {

    /* Build it for device n: "\\.\PHYSICALDRIVEn" */
    _snprintf(phys_name, PHYS_SIZE, "\\\\.\\PHYSICALDRIVE%d", dev_number);

    /*
    | Suppress any attempt by the system to make the user put a volume in a
    | removable drive ("CreateFile" will just fail).
    */
    nPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    /* Attempt to get a handle using this physical name string */
    if ((hdrv = CreateFile(phys_name,                  // Device
                               GENERIC_READ,           // Access
                                                       // Share Mode
                               FILE_SHARE_READ   |
                               FILE_SHARE_WRITE,
                               NULL,                   // Security
                               OPEN_EXISTING,          // CreationDistribution
                               FILE_ATTRIBUTE_NORMAL,  // FlagsandAttributes
                               NULL             // Template file
                           )) != INVALID_HANDLE_VALUE) {

        ULONG       access;     /* hrDiskStorageAccess = readWrite(1) */
        ULONG       media;      /* hrDiskStorageMedia = floppyDisk(4) */
        ULONG       removable;  /* hrDiskStorageRemovable = TRUE      */
        ULONG       capacityKB; /* hrDiskStorageCapacity, (kilobytes) */
        ULONG       status;     /* hrDeviceStatus = unknown(1)        */
        CHAR       *descr;      /* hrDeviceDescr string               */
        DWORD       bytes_out;  /* Bytes retnd into geo_info          */
        DISK_GEOMETRY geo_info; /* Geometry Info from drive           */
        char       *mt;         /* Media Type                         */
        CACHEROW   *dv_row;     /* HrDevice table row created for disk*/


        /*
        | Device is Open, so we can presume it really exists, so it goes
        | into the hrDevice table.
        |
        | It is presumed to be a FIXED disk.
        */

        access = 1;          /* hrDiskStorageAccess = readWrite(1) */
        media = 3;           /* hrDiskStorageMedia = hardDisk(3)   */
        removable = FALSE;   /* hrDiskStorageRemovable = FALSE     */
        capacityKB = 0;      /* hrDiskStorageCapacity (unknown)    */
        status = 1;          /* hrDeviceStatus = unknown(1)        */
        descr = "Fixed Disk";/* hrDeviceDescr                      */


        /* ==========================================================
        |  IOCTL_DISK_GET_DRIVE_GEOMETRY
        |
        |  If we can get this, we get a better description and an
        |  accurate capacity value.
        */
        if (DeviceIoControl(hdrv,           // device handle
                                            // IoControlCode (op-code)
                            IOCTL_DISK_GET_DRIVE_GEOMETRY,
                            NULL,           // "input buffer"
                            0,              // "input buffer size"
                            &geo_info,      // "output buffer"
                                            // "output buffer size"
                            sizeof(DISK_GEOMETRY),
                            &bytes_out,     // bytes written to geo_info
                            NULL            // no Overlapped I/o
                            )) {

            /*
            | Compute capacity
            */
            capacityKB = (ULONG) 
                (geo_info.Cylinders.QuadPart *  // 64 bit

                 (geo_info.TracksPerCylinder *  // 32 bits
                  geo_info.SectorsPerTrack *
                  geo_info.BytesPerSector)

                 ) / 1024;

            /* hrDeviceStatus = running(2) */
            status = 2;

            switch ( geo_info.MediaType ) {

                case  FixedMedia:
                    break;

                default:
                    descr = "Unknown Media";
                }
            }


        /*
        | Create a row in HrDevice Table and a corresponding row in
        | hrDiskStorage sub-table.
        */
        if ((dv_row = Process_DS_Row (type_arc,  /* hrDeviceType last arc  */
                                      access,    /* hrDiskStorageAccess    */
                                      media,     /* hrDiskStorageMedia     */
                                      removable, /* hrDiskStorageRemovable */
                                      capacityKB,/* hrDiskStorageCapacity  */
                                      status,    /* hrDeviceStatus         */
                                      descr      /* hrDeviceDescr          */
                                      )
             ) == NULL) {

            /* Something blew */
            CloseHandle(hdrv);
            SetErrorMode(nPrevErrorMode);/* Turn error suppression mode off */
            return ( FALSE );
            }

        /*
        | If it turns out this is the device from which the system was
        | booted, we need to return the index associated with the "dv_row"
        | row into "InitLoadDev_index" (defined in "HRDEVENT.C") to become
        | the value of "HrSystemInitialLoadDevice".
        |
        | See if the NT Device name associated with this "\\.\PHYSICALDRIVEx"
        | matches the value predicted for the system boot device.
        |
        |  If we can get the NT Device name for "PHYSICALDRIVEn" . . . */
        if (QueryDosDevice(&phys_name[4], pntdev, MAX_PATH) != 0 ) {

            /* If it matches the predicted value for boot device . . . */
            if ( strcmp(pntdev, ntdev) == 0) {

                /* Record the index for the current "physicaldrive" */
                InitLoadDev_index = dv_row->index;
                }
            }
        else {
            /*
            | Fail gracefully so things will still work in
            | "ProcessPartition()" below.
            */
            pntdev[0] = '\0';
            }

        /*
        | Create a hrPartition table (in the HrDevice Table row just created
        | for the disk) to represent the partitions on this fixed disk.
        */
        if ( ProcessPartitions( hdrv, dv_row, pntdev ) != TRUE ) {
            
            /* Something blew */
            CloseHandle(hdrv);
            SetErrorMode(nPrevErrorMode);    /* Turn error suppression mode off */
            return ( FALSE );
            }

        /* Fold up shop on this disk */
        CloseHandle(hdrv);
        } /* If we managed to "CreateFile()" the device */

    else {      /* Open failed... give up the scan */
        SetErrorMode(nPrevErrorMode);    /* Turn error suppression mode off */
        break;
        }

    SetErrorMode(nPrevErrorMode);        /* Turn error suppression mode off */
    }   /* For each device */

/* Successful scan */
return ( TRUE );
}

/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */
/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */
/* Process_DS_Row - Process Information into HrDevice and hrDiskStorage Row */

static CACHEROW *
Process_DS_Row ( 
                ULONG       type_arc,  /* hrDeviceType last arc value        */
                ULONG       access,    /* hrDiskStorageAccess = readWrite(1) */
                ULONG       media,     /* hrDiskStorageMedia = floppyDisk(4) */
                ULONG       removable, /* hrDiskStorageRemovable = TRUE      */
                ULONG       capacityKB,/* hrDiskStorageCapacity, (kilobytes) */
                ULONG       status,    /* hrDeviceStatus = unknown(1)        */
                CHAR       *descr      /* hrDeviceDescr string               */
                )
/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|       The rest of the arguments outline above are used to fill in
|       attribute values in both the hrDevice table row and the corresponding
|       hrDiskStorage row.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDiskStorage table,
|       "HrDiskStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns pointer to row entry made to the hrDevice
|       table indicating that the both caches have been fully
|       populated with a new row.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage" or other
|       failure.).
|
|  THE BIG PICTURE:
|
|
|  OTHER THINGS TO KNOW:
|
|     This function contains common "row-insertion" code for the
|     Gen_Fixed_disks() and Gen_nonFixed_disks() functions.
*/
{
CACHEROW   *dv_row;     /* Row created in hrDevice table      */
CACHEROW   *ds_row;     /* Row created in hrDiskStorage table */


/*
|==========================
| Create hrDevice Row entry.
|
| Note we're initializing this as though the Hidden Context is always
| going to be a Cache pointer.  It will be for fixed-disks (that have
| Partition Tables), but for other disks the "NULL" signals "No Partition
| Table".
|
| For fixed-disks, the NULL is overwritten later (in "ProcessPartitions()")
| by a pointer to malloced storage containing an instance of  CACHEHEAD
| structure that carries the hrPartition Table for that fixed-disk).
*/
if ((dv_row = AddHrDeviceRow(type_arc,   // DeviceType OID Last-Arc
                             descr,      // Used as description
                             NULL,       // Hidden Ctx (none)
                             CA_CACHE    // Hidden Ctx type
                             )) == NULL ) {
    /* Something blew */
    return ( NULL );
    }

/* Re-Set hrDeviceStatus */
dv_row->attrib_list[HRDV_STATUS].attrib_type = CA_NUMBER;
dv_row->attrib_list[HRDV_STATUS].u.unumber_value = status;

/*
|===============================
| Create hrDiskStorage Row entry
|
| Note: The index is not recorded IN the row, but the entry
|       is "indexed": by the hrDevice row index.  This happens
|       in the AddTableRow() call below.
*/
if ((ds_row = CreateTableRow( HRDS_ATTRIB_COUNT ) ) == NULL) {
    return ( NULL );       // Out of memory
    }

/*
| Set the attribute values for this row
*/

/* =========== hrDiskStorageAccess ==========*/
ds_row->attrib_list[HRDS_ACCESS].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_ACCESS].u.unumber_value = access;

/* =========== hrDiskStorageAccess ==========*/
ds_row->attrib_list[HRDS_MEDIA].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_MEDIA].u.unumber_value = media;

/* =========== hrDiskStorageRemovable ==========*/
ds_row->attrib_list[HRDS_REMOVABLE].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_REMOVABLE].u.unumber_value = removable;

/* =========== hrDiskStorageCapacity ==========*/
ds_row->attrib_list[HRDS_CAPACITY].attrib_type = CA_NUMBER;
ds_row->attrib_list[HRDS_CAPACITY].u.unumber_value = capacityKB;


/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrDiskStorage Table..
|
| Use the same index that was used to specify the row inserted
| into the hrDevice table.
*/


if (AddTableRow(dv_row->attrib_list[HRDV_INDEX].u.unumber_value,  /* Index */
                ds_row,                                           /* Row   */
                &hrDiskStorage_cache                              /* Cache */
                ) == FALSE) {

    DestroyTableRow(ds_row);
    return ( NULL );       /* Internal Logic Error! */
    }

/* Processing complete */
return ( dv_row );
}

/* ProcessPartitions - Process Partition Information into HrDevice Row */
/* ProcessPartitions - Process Partition Information into HrDevice Row */
/* ProcessPartitions - Process Partition Information into HrDevice Row */

static BOOL
ProcessPartitions(
                  HANDLE        hdrv,   /* Fixed-Disk containing partitions */
                  CACHEROW     *dv_row, /* Row in hrDevice table for disk   */
                  CHAR         *pntdev  /* NT Device name for physical disk */
                  )
/*
|  EXPLICIT INPUTS:
|
|       "hdrv" - handle open to the fixed disk whose partitions are to be
|       enumerated.
|
|       "dv_row" - the HrDevice row into which the new hrPartition Table
|       is to go.
|
|       "pntdev" - NT Device Name for the physical disk we're dealing with.
|                  We need this to infer the logical device name for any
|                  active partition.
|
|  IMPLICIT INPUTS:
|
|       "HrFSTable_cache" - this gets scanned to allow "hrPartitionFSIndex"
|       to be filled in.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the Partition Information
|       for the given disk has been used to populate an hrPartition Table
|       instance.
|
|     On any Failure:
|       Function returns NULL (indicating "not enough storage" or other
|       failure.).
|
|  THE BIG PICTURE:
|
|     This is the function that instantiates hrPartition tables.
|
|  OTHER THINGS TO KNOW:
|
|     Documentation at the top of the hrPartition Table file "HRPARTIT.C"
|     might be of interest.
|
|     BUG: As of build 1515, (and indeed in earlier versions of NT) the
|     "PartitionNumber" returned in response to DeviceIoControl opcode
|     "IOCTL_DISK_GET_DRIVE_LAYOUT" comes back as garbage.  Whatever
|     comes back is reported as the value of "hrPartitionID" (garbage or
|     not).  However when trying to fetch the Volume Label, as part of a
|     workaround attempt, we use the index generated in the code below 
|     in an attempt to approximate the proper Partition Number.
*/
{
#define DL_SIZE 1024
CHAR            dl_buf[DL_SIZE];  /* Drive-Layout info comes back here   */
UINT            i;                /* Handy-Dandy loop index              */
ULONG           table_index=0;    /* hrPartition Table row index counter */
DWORD           bytes_out;        /* Exactly how big "dl_buf" got filled */
DRIVE_LAYOUT_INFORMATION
                *dl;              /* Drive-layout pointer                */


/*
| See if we can grab the Drive's partition layout info.
*/
if (DeviceIoControl(hdrv,                         // device handle
                    IOCTL_DISK_GET_DRIVE_LAYOUT,  // IoControlCode (op-code)
                    NULL,                         // "input buffer"
                    0,                            // "input buffer size"
                    dl_buf,                       // "output buffer"
                    DL_SIZE,                      // "output buffer size"
                    &bytes_out,                   // bytes written to part_info
                    NULL                          // no Overlapped I/o
                    )) {

    CACHEHEAD *ch;

    /*
    | OK, there's presumed to be at least one partition: instantiate the
    | new partition table.
    |
    | Do this by creating its cache list-head structure.
    */
    dv_row->attrib_list[HIDDEN_CTX].attrib_type = CA_CACHE;
    if ((dv_row->attrib_list[HIDDEN_CTX].u.cache
         = ch = (CACHEHEAD *) malloc( sizeof(CACHEHEAD) )) == NULL) {
        return ( FALSE );
        }

    /*
    | Now initialize the contents properly.
    | (This should match what macro CACHEHEAD_INSTANCE does to a static
    |  instance).
    */
    ch->list_count = 0;
    ch->list = NULL;

    #if defined(CACHE_DUMP)
        ch->print_row = debug_print_hrpartition;
    #else
        ch->print_row = NULL;
    #endif


    /* Grab a dereferencable pointer to the Drive Layout info */
    dl = (DRIVE_LAYOUT_INFORMATION *) dl_buf;

    /* For every Partition "slot" returned . . . */
    for (i = 0; i < dl->PartitionCount; i += 1) {

        PARTITION_INFORMATION
                        *p;       /* Partition info thats going to go . . */
        CACHEROW        *row;     /* . . .into this row in HrPartition    */
        CACHEROW        *fs_row;  /* Row ptr in HrFSEntry table           */
        ULONG           last_arc; /* Last OID arc to use as FS-Type       */


        /* Grab a simple pointer to the next PARTITION_INFO to consider */
        p = &(dl->PartitionEntry[i]);

        /*
        | Note: It may be that not all of the PartitionEntry elements are
        |       "live".
        */
        if (p->PartitionType == PARTITION_ENTRY_UNUSED) {
            continue;
            }

        /*
        |===============================
        | Create hrPartition Row entry
        |
        | Note: This table is also "indexed" by the hrDevice row index
        */
        if ((row = CreateTableRow( HRPT_ATTRIB_COUNT ) ) == NULL) {
            return ( FALSE );       // Out of memory
            }

        /* =========== hrPartitionIndex ==========*/
        row->attrib_list[HRPT_INDEX].attrib_type = CA_NUMBER;
        row->attrib_list[HRPT_INDEX].u.unumber_value = (table_index += 1);


        /* =========== hrPartitionLabel ==========*/
        row->attrib_list[HRPT_LABEL].attrib_type = CA_STRING;

        /*
        | If there is an MS-DOS logical device letter assigned to this
        | partition. . .
        */
        if ( p->RecognizedPartition ) {

            /*
            | Go get the label, copy it to malloc'ed storage and return it.
            |
            | NOTE: Due to what seems like a bug, we're passing in "i+1" here
            |       rather than "p->PartitionNumber" (which seems to come
            |       back as garbage).  Clearly "i" is not a proper substitute
            |       in the long run.  See "OTHER THINGS TO KNOW" in the docs
            |       above for this function.
            */
            row->attrib_list[HRPT_LABEL].u.string_value =
                FindPartitionLabel(pntdev, (i+1));
            }
        else {
            /* No label if no MS-DOS device */
            row->attrib_list[HRPT_LABEL].u.string_value = NULL;
            }


        /* =========== hrPartitionID ==========
        |
        | In build 1515, this number is returned as garbage.  See
        | "OTHER THINGS TO KNOW" above.
        */
        row->attrib_list[HRPT_ID].attrib_type = CA_NUMBER;
        row->attrib_list[HRPT_ID].u.unumber_value = p->PartitionNumber;


        /* =========== hrPartitionSize ==========*/
        row->attrib_list[HRPT_SIZE].attrib_type = CA_NUMBER;
        row->attrib_list[HRPT_SIZE].u.unumber_value =
            p->PartitionLength.LowPart / 1024;

        /* =========== hrPartitionFSIndex ==========*/
        row->attrib_list[HRPT_FSINDEX].attrib_type = CA_NUMBER;

        /* Assume no file system mounted (that we can find) */
        row->attrib_list[HRPT_FSINDEX].u.unumber_value = 0;

        /* Find the first Row (if any) in the hrFSTable */
        if ((fs_row = FindNextTableRow(0, &hrFSTable_cache)) == NULL) {

            /* No file systems listed at all.. we're done */
            DestroyTableRow(row);
            continue;
            }

        /*
        | Convert the Partition-Type into the "last-arc" value we use
        | to indicate what kind of file-system it is.
        */
        last_arc = PartitionTypeToLastArc( p->PartitionType );

        do {    /* Walk the hrFSEntry table */

            /*
            | If we found that the hrFSTable entry "fs_row" specifies a
            | file-system TYPE (by arc number) that matches what the current
            | partition's type number translates to ... we're done.
            */
            if (fs_row->attrib_list[HRFS_TYPE].u.unumber_value == last_arc) {
                row->attrib_list[HRPT_FSINDEX].u.unumber_value = fs_row->index;
                break;
                }

            /* Step to the next row */
            fs_row = GetNextTableRow(fs_row);
            }
               while (fs_row != NULL);

        /*
        |===============================
        |Now add the row to the table
        */
        if (AddTableRow(row->attrib_list[HRPT_INDEX].u.unumber_value,/* Index */
                        row,                                         /* Row   */
                        ch                                           /* Cache */
                        ) == FALSE) {

            DestroyTableRow(row);
            return ( FALSE );       /* Internal Logic Error! */
            }

        } /* For each partition */

    }  /* If DeviceIoControl succeeded */


/* Partition Table complete */
return ( TRUE ) ;
}


/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */
/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */
/* FindPartitionLabel - Find MS-DOS Device Label for a Fixed-Disk Partition */

static PCHAR
FindPartitionLabel(
                   CHAR   *pntdev, /* NT Device name for physical disk */
                   UINT   part_id  /* Partition Number (1-origined)    */
                   )
/*
|  EXPLICIT INPUTS:
|
|       "pntdev" - the NT Device Name (e.g. "\Device\Harddisk0\Partition0"
|       for the PHYSICAL device we're working on).
|
|       "part_id" - One-origined Partition number for which we hope to find
|       an MS-DOS Volume Label.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns a pointer to malloc'ed storage containing the
|       MS-DOS Device Volume label (as returned by "GetVolumeInformation()").
|
|     On any Failure:
|       Function returns NULL (indicating "some kind of failure").
|
|  THE BIG PICTURE:
|
|     This "helper" function attempts to map an NT Device Name and a
|     one-origined Partition Number into a Volume Label for return as
|     the value of "hrPartitionLabel".
|
|  OTHER THINGS TO KNOW:
|
|  The algorithm is based on studying the output from "QueryDosDevices()"
|  and blithely assuming that we can "back-map" the string
|  "\Device\HarddiskX\PartitionY" for any Partition "Y" to the associated
|  MS-DOS Device.  There is precious little documentation that sez we can,
|  but we try.
|
|  Here's the approach:
|
|  * Using the NT Device Name for the "PHYSICALDRIVEn", we scrape the
|    "\Partition0" off the end of the name and replace it with "\PartitionY"
|    where "Y" is the Partition number passed as input to this function.
|    This is the "Generated Partition Name".
|
|    ("PHYSICALDRIVE" NT Device Names all seem to have "\Partition0" as
|    the terminating part of their name, and since the Win32 docs say that
|    Partition Numbers are "1-origined", this seems like a safe approach.)
|
|  * We generate a list of all the MS-DOS device names (using QueryDosDevices).
|
|  * We take each MS-DOS Device name and ask for it's current underlying
|    NT Device name mapping.
|
|    + If the first name mapping for any MS-DOS Device matches our
|      "Generated Partition Name", then the MS-DOS Device name is submitted
|      to "GetVolumeInformation()" and the Volume Label returned is used as
|      the "Partition Label".
*/
{
#define BIG_BUFF 1024
CHAR    gen_part_name[MAX_PATH+32];     /* "pntdev" is at most MAX_PATH+2  */
CHAR   *partition;                      /* Where "\Partition0" starts      */
CHAR    MSDOS_devices[BIG_BUFF];        /* List of MS-DOS device names     */
CHAR    NT_device[BIG_BUFF];            /* Mapping of NT device names      */
CHAR   *devname;                        /* Index for MSDOS_devices         */


/* Copy the NT Device Name for the Physical Drive */
strcpy(gen_part_name, pntdev);

/* Obtain a pointer to the beginning of "\Partition0" in this string */
if ((partition = strstr(gen_part_name, "\\Partition")) != NULL) {

    /*
    | Replace "\Partition0" with "\PartitionY" where "Y" is the supplied
    | partition number:  We've got the "Generated Partition Name".
    */
    sprintf(partition, "\\Partition%d", part_id);

    /*
    | Now ask for a list of MS-DOS Device Names
    */
    if ( QueryDosDevice(NULL, MSDOS_devices, BIG_BUFF) != 0) {

        /*
        | Swing down the list of MS-DOS device names and get the NT Device
        | name mappings.
        */
        for (devname = MSDOS_devices;
             *devname != '\0';
             devname += (strlen(devname)+1)) {

            /* Obtain the mappings for device "devname" */
            if (QueryDosDevice(devname, NT_device, BIG_BUFF) == 0)
                continue;

            /* If the first mapping matches the Generated Partition Name */
            if (strcmp(gen_part_name, NT_device) == 0) {

                #define VOL_LABEL_SIZE 128
                CHAR    MSDOS_root[64+1];          /* Root Path Name       */
                CHAR    v_label[VOL_LABEL_SIZE];   /* Volume Label         */
                CHAR    *ret_label;                /* --> Malloced storage */
                DWORD   comp_len;                  /* Filename length      */
                DWORD   flags;


                /*
                | We're obliged to add a root-directory "\" to the MS-DOS
                | device name.
                */
                MSDOS_root[64] = 0; // ensures null terminated string
                _snprintf(MSDOS_root, 64, "%s\\", devname);

                /* Fetch the Volume Information for the MS-DOS Device */
                if (GetVolumeInformation(
                                         MSDOS_root,       // MS-DOS root name
                                         v_label,          // Vol. Label buf
                                         VOL_LABEL_SIZE,   // vol. label size
                                         NULL,             // Serial Number
                                         &comp_len,        // FileName length
                                         &flags,           // Flags
                                         NULL,             // File System name
                                         0                 // Name buff. len
                                         ) != 0) {
                    /*
                    | Allocate storage to hold a returnable copy
                    */
                    if ( (ret_label = (CHAR *) malloc(strlen(v_label) + 1))
                        != NULL) {

                        /* Copy the label to malloced storage */
                        strcpy(ret_label, v_label);

                        return (ret_label);
                        }
                    else {
                        /* Out of storage */
                        return (NULL);
                        }
                    }
                else {
                    /* "GetVolumeInformation" failed on MSDOS name */
                    return (NULL);
                    }
                }
            }                    
        }
    }

return (NULL);  /* Other Failure */
}

#if defined(CACHE_DUMP)

/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */
/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */
/* debug_print_hrdiskstorage - Prints a Row from HrDiskStorage sub-table */

static void
debug_print_hrdiskstorage(
                          CACHEROW     *row  /* Row in hrDiskStorage table */
                          )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=========================\n");
    fprintf(OFILE, "hrDiskStorage Table Cache\n");
    fprintf(OFILE, "=========================\n");
    return;
    }

fprintf(OFILE, "hrDiskStorageAccess. . . . %d ",
        row->attrib_list[HRDS_ACCESS].u.unumber_value);
switch (row->attrib_list[HRDS_ACCESS].u.unumber_value) {
    case 1: fprintf(OFILE, "(readWrite)\n");            break;
    case 2: fprintf(OFILE, "(readOnly)\n");             break;
    default:fprintf(OFILE, "(???)\n");                  break;
    }

fprintf(OFILE, "hrDiskStorageMedia . . . . %d ",
        row->attrib_list[HRDS_MEDIA].u.unumber_value);
switch (row->attrib_list[HRDS_MEDIA].u.unumber_value) {
    case 1: fprintf(OFILE, "(Other)\n");                break;
    case 2: fprintf(OFILE, "(Unknown)\n");              break;
    case 3: fprintf(OFILE, "(hardDisk)\n");             break;
    case 4: fprintf(OFILE, "(floppyDisk)\n");           break;
    case 5: fprintf(OFILE, "(opticalDiskROM)\n");       break;
    case 6: fprintf(OFILE, "(opticalDiskWORM)\n");      break;
    case 7: fprintf(OFILE, "(opticalDiskRW)\n");        break;
    case 8: fprintf(OFILE, "(ramDisk)\n");              break;
    default:fprintf(OFILE, "(???)\n");                  break;
    }

fprintf(OFILE, "hrDiskStorageRemovable . . %d ",
        row->attrib_list[HRDS_REMOVABLE].u.unumber_value);
switch (row->attrib_list[HRDS_REMOVABLE].u.unumber_value) {
    case 0: fprintf(OFILE, "(FALSE)\n"); break;
    case 1: fprintf(OFILE, "(TRUE)\n"); break;
    default: 
            fprintf(OFILE, "(???)\n"); break;
    }

fprintf(OFILE, "hrDiskStorageCapacity. . . %d (KBytes)\n",
        row->attrib_list[HRDS_CAPACITY].u.unumber_value);

}


/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */
/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */
/* debug_print_hrpartition - Prints a Row from HrPartition sub-table */

static void
debug_print_hrpartition(
                        CACHEROW     *row  /* Row in hrPartition table */
                        )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "     =======================\n");
    fprintf(OFILE, "     hrPartition Table Cache\n");
    fprintf(OFILE, "     =======================\n");
    return;
    }


fprintf(OFILE, "     hrPartitionIndex . . . . . %d\n",
        row->attrib_list[HRPT_INDEX].u.unumber_value);

fprintf(OFILE, "     hrPartitionLabel . . . . . \"%s\"\n",
        row->attrib_list[HRPT_LABEL].u.string_value);

fprintf(OFILE, "     hrPartitionID. . . . . . . 0x%x\n",
        row->attrib_list[HRPT_ID].u.unumber_value);

fprintf(OFILE, "     hrPartitionSize. . . . . . %d\n",
        row->attrib_list[HRPT_SIZE].u.unumber_value);

fprintf(OFILE, "     hrPartitionFSIndex . . . . %d\n",
        row->attrib_list[HRPT_FSINDEX].u.unumber_value);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrpartit.c ===
/*
 *  HrPartitionEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrPartitionEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:43:52 1996
 *
 | 
 | The approach envisioned for generating the contents of this table consists 
 | of walking all physical drives (using CreateFile and the "physical drive" 
 | naming convention) and acquiring the partition information for each drive 
 | using Win32 API functions DeviceIoControl (IOCTL_DISK_GET_DRIVE_LAYOUT).
 | 
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions          */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */


/*
|==============================================================================
| A word about the cache for this sub-table.
|
| This is a unique sub-table within the hrDevice table in that it is doubly
| indexed.
|
| As a consequence, there are multiple instances of the cache-head,
| one for each simple instance of this table.  Consequently there is no
| single, static instance of a cache-head to be found (as is typically the
| case for sub-tables of hrDevice) here at the start of the module.
|
| The "value" of the "hidden-context" attribute for a hrDevice table
| row for this sub-table has as its value a pointer to a slug of malloced
| memory containing the cache-head for that instance of this sub-table.
| (See "HMCACHE.C" for storage picture).
|
| Initialization of this sub-table occurs as part of the initialization
| of the HrDiskStorage sub-table (HRDISKST.C) in function "ProcessPartitions".
*/

/*
|==============================================================================
| Function Prototypes for this module.
*/
/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */
static UINT
RollToNextFixedDisk (
UINT       *dev_tmp_instance ,     /* ->Device Table Instance Arc ("1st")    */
UINT       *part_tmp_instance ,    /* ->Partition Table Instance Arc ("2nd") */
CACHEROW  **dev_row,               /* ->> Entry in hrDevice Table            */
CACHEHEAD **part_cache             /* ->> Cache-Header for Partition         */
                     );


/*
 *  GetHrPartitionIndex
 *    A unique value for each partition on this long term storage device.  The 
 *    value for each long-term storage device must remain con
 *    
 *    Gets the value for HrPartitionIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "A unique value for each partition on this long- term storage device.  The
 | value for each long-term storage device must remain constant at least from one
 | re-initialization of the agent to the next re- initialization."
 | 
 | DISCUSSION:
 | 
 | (See discussion above for the table as a whole).
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.1.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionIndex
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = part_row->attrib_list[HRPT_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionIndex() */


/*
 *  GetHrPartitionLabel
 *    A textual description of this partition.
 *    
 *    Gets the value for HrPartitionLabel.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionLabel
 |
 | ACCESS         SYNTAX
 | read-only      InternationalDisplayString (SIZE (0..128))
 |
 | "A textual description of this partition."
 |
 | DISCUSSION:
 |
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.2.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionLabel
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionLabel( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

outvalue->string = part_row->attrib_list[HRPT_LABEL].u.string_value;

if (outvalue->string == NULL) {
    outvalue->length = 0;
    }
else {
    outvalue->length = strlen(outvalue->string);

    /* "Truncate" here to meet RFC as needed*/
    if (outvalue->length > 128) {
        outvalue->length = 128;
        }
    }

return SNMP_ERRORSTATUS_NOERROR ;


} /* end of GetHrPartitionLabel() */


/*
 *  GetHrPartitionID
 *    A descriptor which uniquely represents this partition to the responsible 
 *    operating system.  On some systems, this might take on 
 *    
 *    Gets the value for HrPartitionID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionID
 | 
 |  ACCESS         SYNTAX
 |  read-only      OCTET STRING
 | 
 | "A descriptor which uniquely represents this partition to the responsible
 | operating system.  On some systems, this might take on a binary
 | representation."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.3.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionID
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionID( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

outvalue->string = (char *) &(part_row->attrib_list[HRPT_ID].u.unumber_value);
outvalue->length = 4;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionID() */


/*
 *  GetHrPartitionSize
 *    The size of this partition.
 *    
 *    Gets the value for HrPartitionSize.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionSize
 | 
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 | 
 | "The size of this partition."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.4.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionSize
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionSize( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = part_row->attrib_list[HRPT_SIZE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionSize() */


/*
 *  GetHrPartitionFSIndex
 *    The index of the file system mounted on this partition.  If no file 
 *    system is mounted on this partition, then this value shall b
 *    
 *    Gets the value for HrPartitionFSIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrPartitionFSIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 | 
 | "The index of the file system mounted on this partition.  If no file system is
 | mounted on this partition, then this value shall be zero.  Note that multiple
 | partitions may point to one file system, denoting that that file system
 | resides on those partitions.  Multiple file systems may not reside on one
 | partition."
 | 
 | DISCUSSION:
 | 
 | This information for the entire drive is obtained using Win32 API CreateFile
 | to open the device and DeviceIoControl to retrieve the needed information.
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.7.1.5.<dev-instance>.<partition-instance>
 |                | | | |
 |                | | | *-hrPartitionFSIndex
 |                | | *-hrPartitionEntry
 |                | *-hrPartitionTable
 |                *-hrDevice
 */

UINT
GetHrPartitionFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           disk_index;     /* As fetched from instance structure */
ULONG           part_index;     /* As fetched from instance structure */
CACHEROW        *disk_row;      /* Row entry fetched from Disk cache  */
CACHEROW        *part_row;      /* Row entry fetched from Part. cache */
CACHEHEAD       *part_cache;    /* HrPartition Table cache to search  */


/*
| Grab the instance information
*/
disk_index = GET_INSTANCE(0);
part_index = GET_INSTANCE(1);


/*
|===========
| Index 1
| Use Disk-Index to find the right Disk-row entry in the hrDevice cache
*/
if ((disk_row = FindTableRow(disk_index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Grab a pointer to the hrPartition cache for this disk */
part_cache = disk_row->attrib_list[HIDDEN_CTX].u.cache;


/*
|===========
| Index 2
| Use Partition-Index to find the right row entry in the hrPartition cache
*/
if ((part_row = FindTableRow(part_index, part_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = part_row->attrib_list[HRPT_FSINDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrPartitionFSIndex() */


/*
 *  HrPartitionEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPartitionEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT        dev_tmp_instance ;     /* Device Table Instance Arc     */
    UINT        part_tmp_instance ;    /* Partition Table Instance Arc  */
    CACHEROW    *dev_row;              /* --> Entry in hrDevice Table   */
    CACHEHEAD   *part_cache;           /* --> Cache-Header for Partition*/


    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRPARTITIONENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
        // Instance is 2 arcs for this table:
    else  if ( FullOid->idLength != HRPARTITIONENTRY_VAR_INDEX + 2 )
	// Instance length is more than 2, or 1 exactly, either way: error
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

        /*
        | Check the first of two instance arcs here.  The first should
        | select a valid entry in hrDiskStorage cache.  This guarantees
        | that a disk is being selected.  If a valid entry is present in
        | hrDiskStorage cache, then a corresponding row should be in the
        | main hrDevice table (and having checked hrDiskStorage first, we
        | don't have to verify the type of the entry in hrDevice).
        |
        | The corresponding hrDevice row entry should have a hidden-context
        | that is a non-NULL pointer to a CACHEHEAD **if** the first instance
        | arc is truly selecting a Fixed-Disk (which is the only kind of disk
        | for which HrPartition sub-tables are constructed).
        */
	dev_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX ] ;

	if ( FindTableRow(dev_tmp_instance, &hrDiskStorage_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }

        /*
        | Ok, there is an entry in hrDiskStorage, now go get the corresponding
        | hrDevice entry... it **will be** for a Disk.
        */
        if ( (dev_row = FindTableRow(dev_tmp_instance, &hrDevice_cache))
            == NULL ) {
	    return SNMP_ERRORSTATUS_GENERR ;
            }

        /*
        | Check to be sure there is a cache tucked into the hidden-context,
        | this assures us it is a Fixed Disk and that there is something to
        | search given the second instance arc.  (The cache header may be
        | for an empty cache, but it will support a search).
        */
        if (dev_row->attrib_list[HIDDEN_CTX].attrib_type != CA_CACHE ||
            (part_cache = dev_row->attrib_list[HIDDEN_CTX].u.cache) == NULL) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }

        /*
        | First instance arc ("dev_tmp_instance") is kosher... check the second,
        | ("part_tmp_instance") it should select a valid entry in the cache 
        | whose header pointer is in HIDDEN_CTX.
        */
	part_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX + 1] ;
        if ( FindTableRow(part_tmp_instance, part_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }

	else
	{
	    // the both instances are valid.  Create the instance portion of
	    // the OID to be returned from this call.
	    instance->ids[ 0 ] = dev_tmp_instance ;
	    instance->ids[ 1 ] = part_tmp_instance ;
	    instance->idLength = 2 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrPartitionEntryFindInstance() */



/*
 *  HrPartitionEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrPartitionEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    UINT        dev_tmp_instance=0;   /* Device Table Instance Arc ("1st")   */
    UINT        part_tmp_instance=0;  /* Partition Table Instance Arc ("2nd")*/
    CACHEROW    *hrDevice_row;        /* Looked-up row in hrDevice table     */
    CACHEROW    *dev_row = NULL;      /* --> Entry in hrDiskStorage Table    */
    CACHEROW    *part_row = NULL;     /* --> Entry in hrPartition Table      */
    CACHEHEAD   *part_cache=NULL;     /* --> Cache-Header for Partition      */
    UINT        ret_status;           /* Status to be returned by this func  */


    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    /*
    | With two numeric indices to deal with on this table, we're attempting
    | to cover the following situations:
    |
    | 1) No instance arcs provided at all.  In this case, we need to look up
    |    and return the instance arcs that select the first fixed-disk and
    |    the first partition within that disk.  We cover this case as a
    |    "standalone" case.
    |
    | 2) Only the hrdevice ("disk selecting") first instance arc is provided.
    |    In this case, we'll "assume" an initial partition-selecting instance
    |    arc of "0", and continue processing with the code that covers case 3.
    |
    | 3) Two or more instance arcs are provided, in which case we just use the
    |    first of two arcs as the hrdevice ("disk selecting") "first" instance 
    |    arc and the second arc as the hrPartition ("partition selecting") 
    |    "second" instance arc, ignoring any remaining arcs.
    |
    | The "Party Line" on this logic is that it works even if the "fixed-disk"
    | entries don't have monotonically increasing indices the way the
    | cache-population code currently creates them and even if the partition
    | cache (table) has no entries for a particular disk (it must, however
    | have a cache).
    */
    

    if ( FullOid->idLength <= HRPARTITIONENTRY_VAR_INDEX ) {

        /* CASE 1
        |
        | No instance arcs were provided, so we want to setup local instance
        | arcs that select the first hrDevice table "Fixed Disk" entry and the
        | first "Partition" entry within that disk (if any disk and if any
        | partitions within that disk).
        |
        | Entry into "RollToNextFixedDisk()" is special for this case as
        | "dev_row" is NULL, so it'll roll to the first legal Fixed-Disk.
        */
        ret_status =
            RollToNextFixedDisk(&dev_tmp_instance,     // hrDiskStorage arc
                                &part_tmp_instance,    // hrPartition arc
                                &dev_row,              // row in hrDiskStorage
                                &part_cache            // cache for hrPartition
                                );

        /* If we got a no-good return status */
        if (ret_status != SNMP_ERRORSTATUS_NOERROR) {
            return ( ret_status );
            }

        /*
        | Ok, all we need to do is roll into the hrPartition table using the
        | second instance arc returned above (which will be zero) to find
        | the true first entry in the hrPartition table cache so we can return
        | it's index as the second instance arc, (or keep rolling if the
        | partition table (cache) is empty (which it really shouldn't be, but
        | we have it covered if it is)).
        |
        | All this is performed by the "General Roll" code below.
        */           
        }

    else {  /* Some instance arcs provided */

        if ( FullOid->idLength == HRPARTITIONENTRY_VAR_INDEX + 1 ) {

            /* CASE 2
            |
            | Exactly one instance arc is provided, 
            | so use it and assume the second arc is 0.
            */
            dev_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX ] ;
            part_tmp_instance = 0;
            }

        else {

            /* CASE 3
            |
            | Two or more instance arcs are provided, 
            | so use the first two arcs and ignore the rest.
            */
            dev_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX ] ;
            part_tmp_instance = FullOid->ids[ HRPARTITIONENTRY_VAR_INDEX + 1] ;
            }

        /* Show "No HrPartition Cache Selected Yet" (at entry time: NULL) */

        /*
        | At this point, we need to know whether the first instance arc
        | actually selects a Fixed-Disk entry in hrDevice (and hrDiskStorage)
        | that has an hrPartition table that we can "roll" thru.
        |
        | Attempt a direct ("non-rolling") lookup on the hrDiskStorage table
        | cache with the first instance arc.
        */
        dev_row = FindTableRow(dev_tmp_instance, &hrDiskStorage_cache);

        /*
        | If (an entry is found)
        */
        if ( dev_row != NULL) {

            /* If (the entry is for a "Fixed-Disk") */
            if ( dev_row->attrib_list[HRDS_REMOVABLE].u.unumber_value
                == FALSE) {

                /*
                | Perform "FindTableRow" on hrdevice cache using first 
                | instance arc.
                */
                hrDevice_row = FindTableRow(dev_tmp_instance, &hrDevice_cache);
                
                /*
                | If (no hrdevice entry was found)
                */
                if ( hrDevice_row  == NULL) {
                    return SNMP_ERRORSTATUS_GENERR ;
                    }

                /*
                | If the hrdevice entry DOES NOT have a
                | cache associated with it . . .
                */
                if ( (hrDevice_row->attrib_list[HIDDEN_CTX].attrib_type
                      != CA_CACHE) ||

                     (hrDevice_row->attrib_list[HIDDEN_CTX].u.cache
                      == NULL)) {

                    return SNMP_ERRORSTATUS_GENERR ;
                    }

                /*
                | Select the cache from the hrdevice disk entry as the 
                | HrPartition table cache to be searched in the following
                | logic.
                */
                part_cache = hrDevice_row->attrib_list[HIDDEN_CTX].u.cache;

                } /* if entry was fixed-disk */

            } /* if entry was found */

        /*
        | At this point, if a hrpartition cache has been selected (!NULL),
        | the first instance arc has selected a fixed-disk entry
        | and there is no need to "roll" on the first index.
        |
        | Otherwise we've got to "reset" the second instance arc
        | to "0" and do a rolling lookup on the first arc for
        | another Fixed-disk entry (that should have a partition-cache).
        */

        /* if (an hrpartition cache has NOT been selected) */
        if (part_cache == NULL) {

            /* Perform "RollToNextFixedDisk" processing */
            ret_status =
                RollToNextFixedDisk(&dev_tmp_instance,  // hrDiskStorage arc
                                    &part_tmp_instance, // hrPartition arc
                                    &dev_row,           // row in hrDiskStorage
                                    &part_cache         // hrPartition cache
                                    );

            /* If we got a no-good return status */
            if (ret_status != SNMP_ERRORSTATUS_NOERROR) {
                return ( ret_status );  // (either NOSUCH or GENERR)
                }
            }

        }  /* else Some instance arcs provided */

    /*
    | At this point, we have:
    |
    |   + a valid hrPartition cache to search,
    |   + the second instance arc to search it with (by "rolling"),
    |   + the first instance arc that is valid, (but may need to be
    |       rolled again if there are no valid partitions found).
    |
    | We can now do a "General Roll" to land on the proper Partition entry.
    */

    while (1) {         /* "General Roll" */

        /*
        | Do a "FindNextTableRow" (rolling) lookup on the hrpartition
        | cache with the current value of the second instance arc.
        |
        | if (an entry was found)
        */
        if ((part_row = FindNextTableRow(part_tmp_instance, part_cache))
            != NULL ) {

            /*
            | Return the current first arc and the index from the returned
            | entry as the second instance arc and signal NOERROR.
            */
            instance->ids[ 0 ] = dev_tmp_instance ;
            instance->ids[ 1 ] = part_row->index;
            instance->idLength = 2 ;

            return SNMP_ERRORSTATUS_NOERROR ;
            }

        /*
        | Fell off the end of the current hrPartition cache, must
        | go get another hrPartition cache from the next fixed-disk entry.
        |
        | Perform "RollToNextFixedDisk" processing
        */
        ret_status =
            RollToNextFixedDisk(&dev_tmp_instance,  // hrDiskStorage arc
                                &part_tmp_instance, // hrPartition arc
                                &dev_row,           // row in hrDiskStorage
                                &part_cache         // hrPartition cache
                                );

        if (ret_status != SNMP_ERRORSTATUS_NOERROR) {
            return ( ret_status );   // (either NOSUCH or GENERR)
            }

        } /* while */


} /* end of HrPartitionEntryFindNextInstance() */

/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */
/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */
/* RollToNextFixedDisk - Helper Routine for HrPartitionEntryFindNextInstance */

static UINT
RollToNextFixedDisk (
                                                                  /* Index */
UINT       *dev_tmp_instance,     /* ->Device Table Instance Arc    ("1st") */
UINT       *part_tmp_instance,    /* ->Partition Table Instance Arc ("2nd") */
CACHEROW  **dev_row,              /* ->> Entry in hrDevice Table            */
CACHEHEAD **part_cache            /* ->> Cache-Header for Partition         */
                     )

/*
|  EXPLICIT INPUTS:
|
|       "dev_tmp_instance" & "part_tmp_instance" are pointers to the "current"
|       instance arcs for the hrDevice and hrPartition table respectively.
|
|       Note that "*dev_tmp_instance" is also implicitly the index into the 
|       hrDiskStorage table as well.
|
|       "dev_row" - is a pointer to the pointer to the hrDiskStorage
|       row currently selected by "*dev_tmp_instance".  It is the 
|       case that "*dev_row" might be null, indicating that no row
|       has been selected yet.
|
|       "part_cache" is a pointer to the pointer to any selected hrPartition
|       table (ie a cache taken from an hrDevice row for a fixed-disk).  If
|       no such partition cache has been selected yet, then "*part_cache" is
|       NULL.
|
|  IMPLICIT INPUTS:
|
|       "HrDiskStorage_cache" may be referenced if "*dev_row" is NULL.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns SNMP_ERRORSTATUS_NOERROR when the roll to the next
|       Fixed-Disk hrDiskStorage entry has succeeded.  New "first" and "second"
|       instance arcs are returned as well as the cache for the hrPartition
|       table that needs to be searched using the "second" arc.
|       
|     On any Failure:
|       Function returns SNMP_ERRORSTATUS_GENERR if it bumps into what it
|       thinks should be a Fixed-Disk entry in hrDevice but the entry does
|       not have an hrPartition table cache as it should.
|
|       Function returns SNMP_ERRORSTATUS_NOSUCHNAME if it can't find another
|       hrDevice entry for a Fixed-Disk.
|
|  THE BIG PICTURE:
|
|     This function takes care of the details of "rolling" to the next
|     Fixed-Disk entry in hrDevice (& HrDiskStorage) on behalf of
|     "HrPartitionEntryFindNextInstance()".
|
|  OTHER THINGS TO KNOW:
|
|     Because we rolling at the device "level", we reset the "instance"
|     arc for the partition level back to zero so that a FindNextTableRow
|     using zero will select the first entry in the selected hrPartition
|     Table (cache) being returned by this function.
*/
{
CACHEROW        *hrDevice_row;          /* Looked-up row in hrDevice table */


/* Reset the second instance arc to "0" */
*part_tmp_instance = 0;

while (1) {   /* Forever . . . */

    /*
    | Try to get the "next" hrDiskStorage row 
    | given our pointer to the current row.
    |
    | If no "current" row, start with the first in hrDiskStorage
    | and riffle upward until we get the row "after" the row that
    | the current device instance arc would have selected.
    */

    /* if (there is no current hrDiskStorage row) */
    if (*dev_row == NULL) {

        /* If the cache is empty . . . */
        if ( (*dev_row =
              FindNextTableRow(*dev_tmp_instance, &hrDiskStorage_cache))
              == NULL) {
            return SNMP_ERRORSTATUS_NOSUCHNAME;
            }
        }
    else {

        /*
        | Perform "GetNextTableRow" on current hrdiskstorage entry
        |
        | if (processing returned no-next-entry)
        */
        if ( (*dev_row = GetNextTableRow((*dev_row))) == NULL) {
            return SNMP_ERRORSTATUS_NOSUCHNAME;
            }
        }

    /*
    | Ok, we've got a "next" row in hrDiskStorage.  If it isn't for a fixed
    | disk, we've got to go around again in hopes of finding one that is.
    */

    /* if (entry is not for Fixed-Disk (skip Removables)) */
    if ( (*dev_row)->attrib_list[HRDS_REMOVABLE].u.unumber_value == TRUE) {
      continue;         /* Skippity doo-dah */
      }

    /*
    | Set current first instance arc value to index of current entry:
    | it is the "next" row following the row for which the original
    | device instance arc selected.
    */
    *dev_tmp_instance = (*dev_row)->index;

    /*
    | Ok, now we've got to go over to the big hrDevice table and hope to
    | find the corresponding hrDevice row given the row index we're on in
    | hrDiskStorage.  As this is coded, I realize that we could have put
    | the HIDDEN_CTX attribute in the hrDiskStorage entry rather than
    | the hrDevice entry and saved this lookup, but it matters little.
    */

    /*
    | Do "FindTableRow" on hrdevice cache using first instance arc
    |
    | if (no hrdevice entry was found) */
    if ( (hrDevice_row = FindTableRow(*dev_tmp_instance, &hrDevice_cache))
        == NULL) {
        /*
        | There should be an hrDevice table entry for every entry in
        | hrDiskStorage.  This seems not to be the case for some reason.
        */
        return SNMP_ERRORSTATUS_GENERR ;
        }

    /* If (the hrdevice entry DOES NOT have a cache associated with it) */
    if ( (hrDevice_row->attrib_list[HIDDEN_CTX].attrib_type != CA_CACHE) ||
         (hrDevice_row->attrib_list[HIDDEN_CTX].u.cache == NULL) ) {
        /*
        | There should be a cache in the HIDDEN_CTX attribute for all fixed
        | disks.
        */
        return SNMP_ERRORSTATUS_GENERR ;
        }

    /*
    | Select and return the cache from the hrDevice fixed-disk row entry as 
    | the HrPartition table cache to be searched on return.
    */
    *part_cache = hrDevice_row->attrib_list[HIDDEN_CTX].u.cache;

    return SNMP_ERRORSTATUS_NOERROR;
    }
}


/*
 *  HrPartitionEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrPartitionEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array[2];/* The address of this (char *) is passed back     */
                         /* as an array of pointers to instance arc numbers */

static ULONG    inst1,   /* The addresses of these ULONGs are passed back  */
                inst2;   /* (Obviously, no "free()" action is needed) */

    /* We expect the two arcs in "oid_spec" */
    inst1 = oid_spec->ids[0];
    array[0] = (char *) &inst1;

    inst2 = oid_spec->ids[1];
    array[1] = (char *) &inst2;

    native_spec->count = 2;
    native_spec->array = array;

    return SUCCESS ;

} /* end of HrPartitionEntryConvertInstance() */




/*
 *  HrPartitionEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrPartitionEntryFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrPartitionEntryFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrstoent.c ===
/*
 *  HrStorageEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrStorageEntry.
 *    Actual instrumentation code is supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class, plus the cache
 *    initialization function "Gen_Hrstorage_Cache()".
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/17/97  D. D. Burns     Genned: Thu Nov 07 16:40:22 1996
 *    V1.01 - 05/15/97  D. D. Burns     Move Disk Label/Size acquisitions
 *                                       to cache from real-time
 *    V1.02 - 06/18/97  D. D. Burns     Add spt to scan event log for
 *                                       allocation failures
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions */
#include "string.h"       /* For string manipulation in "Gen_Hrstorage_Cache"*/
#include "stdio.h"        /* For sprintf */
#include <limits.h>

/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */
static UINT
ScanLog_Failures(
                 CHAR   *device
                 );


#if defined(CACHE_DUMP)

/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */
static void
debug_print_hrstorage(
                      CACHEROW     *row  /* Row in hrstorage table */
                      );
#endif

/*
|==============================================================================
| Cache Refresh Time
|
| The cache for the hrStorage and hrFSTable tables are refreshed automatically
| when a request arrives at the hrStorage --AND-- the cache is older than 
| CACHE_MAX_AGE in seconds.
|
*/
static
LARGE_INTEGER   cache_time;   // 100ns Timestamp of cache (when last refreshed)

#define CACHE_MAX_AGE 120     // Maximum age in seconds

/*
|==============================================================================
| Create the list-head for the HrStorage table cache.
|
| This list-head is globally accessible so the logic that loads hrFSTable
| can scan this cache for matches (among other reasons).
|
| (This macro is defined in "HMCACHE.H").
*/
CACHEHEAD_INSTANCE(hrStorage_cache, debug_print_hrstorage);


/*
|==============================================================================
| Local string for this kind of "storage".
*/
#define VM            "Virtual Memory"
#define PHYMEM        "Physical Memory"


/*
 * ============================================================================
 *  GetHrStorageIndex
 *    A unique value for each logical storage are contained by the host.
 *
 *    Gets the value for HrStorageIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageIndex
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "A unique value for each logical storage area contained by the host."
 |
 | DISCUSSION:
 |
 | The value of this attribute is always the number of drives reported by
 | "GetLogicalDrives" (excepting network drives) plus one (for reporting on
 | "Virtual Memory").
 |
 |============================================================================
 | 1.3.6.1.2.1.25.2.3.1.1.<instance>
 |                | | | |
 |                | | | *hrStorageIndex
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageIndex(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */

/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the "hrStorageIndex" value from this entry
*/
*outvalue = row->attrib_list[HRST_INDEX].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageIndex() */


/*
 * ============================================================================
 *  GetHrStorageType
 *    The type of strage represented by this entry.
 *
 *    Gets the value for HrStorageType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageType
 |
 |  ACCESS         SYNTAX
 |  read-only      OBJECT IDENTIFIER
 |
 | "The type of storage represented by this entry."
 |
 |    -- Registration for some storage types, for use with hrStorageType
 |
 |    hrStorageOther          OBJECT IDENTIFIER ::= { hrStorageTypes 1 }
 |    hrStorageRam            OBJECT IDENTIFIER ::= { hrStorageTypes 2 }
 |    -- hrStorageVirtualMemory is temporary storage of swapped
 |    -- or paged memory
 |    hrStorageVirtualMemory  OBJECT IDENTIFIER ::= { hrStorageTypes 3 }
 |    hrStorageFixedDisk      OBJECT IDENTIFIER ::= { hrStorageTypes 4 }
 |    hrStorageRemovableDisk  OBJECT IDENTIFIER ::= { hrStorageTypes 5 }
 |    hrStorageFloppyDisk     OBJECT IDENTIFIER ::= { hrStorageTypes 6 }
 |    hrStorageCompactDisc    OBJECT IDENTIFIER ::= { hrStorageTypes 7 }
 |    hrStorageRamDisk        OBJECT IDENTIFIER ::= { hrStorageTypes 8 }
 |
 | DISCUSSION:
 |
 | The value returned for this attribute is determined by indications from
 | "GetDriveType" for disks.  For the "Virtual Memory" entry, the OID for
 | "hrStorageVirtualMemory" is returned.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.2.3.1.2.<instance>
 |                | | | |
 |                | | | *hrStorageType
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageType(
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure */
CACHEROW        *row;           /* Row entry fetched from cache       */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with the cache-building function "Gen_Hrstorage_Cache()",
| the cached value is the right-most arc we must return as the value.
|
| Hence whatever cache entry we retrieve, we tack the number retrieved
| from the cache for this attribute onto { hrStorageTypes ... }.
*/
if ( (outvalue->ids = SNMP_malloc(10 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 10;


/*
| Load in the full hrStorageType OID:
|
| 1.3.6.1.2.1.25.2.1.n
|                | | |
|                | | *-Type indicator
|                | *-hrStorageTypes (OIDs specifying storage types)
|                *-hrStorage
|
*/
outvalue->ids[0] = 1;
outvalue->ids[1] = 3;
outvalue->ids[2] = 6;
outvalue->ids[3] = 1;
outvalue->ids[4] = 2;
outvalue->ids[5] = 1;
outvalue->ids[6] = 25;
outvalue->ids[7] = 2;
outvalue->ids[8] = 1;

/* Cached Type indicator */
outvalue->ids[9] = row->attrib_list[HRST_TYPE].u.unumber_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageType() */


/*
 *  GetHrStorageDesc
 *    A description of the type and instance of the storage described by this
 *    entry.
 *
 *    Gets the value for HrStorageDesc.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageDescr
 |
 |  ACCESS         SYNTAX
 |  read-only      DisplayString
 |
 | "A description of the type and instance of the storage described by this
 | entry."
 |
 | DISCUSSION:
 |
 | For the Virtual Memory entry, the string "Virtual Memory" is returned.
 |
 | For disks, a string composed of:
 |         + the logical drive letter followed by
 |         + the Volume Identification (for drives containing a volume)
 |           in double quotes
 |         + the Volume Serial Number
 |
 | For instance, the value of this variable for drive C might be
 |                          C: Label="Main Disk"  Serial #=0030-34FE
 |
 | For speed, the label acquisition is done at cache-build time, and
 | as a consequence the removable drives are sampled only once.
 | ===========================================================================
 | 1.3.6.1.2.1.25.2.3.1.3.<instance>
 |                | | | |
 |                | | | *hrStorageDescr
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageDesc(
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Return the description that was computed at cache-build time */
outvalue->length = strlen(row->attrib_list[HRST_DESCR].u.string_value);
outvalue->string = row->attrib_list[HRST_DESCR].u.string_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageDesc() */


/*
 *  GetHrStorageAllocationUnits
 *    The size, in bytes, of the data objects allocated from this pool.  If
 *    this entry is monitoring sectors, blocks, buffers, or pack
 *
 *    Gets the value for HrStorageAllocationUnits.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageAllocationUnits
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "The size, in bytes, of the data objects allocated from this pool.  If this
 | entry is monitoring sectors, blocks, buffers, or packets, for example, this
 | number will commonly be greater than one.  Otherwise this number will
 | typically be one."
 |
 | DISCUSSION:
 |
 | For Virtual Memory, the value returned is that provided as
 | "AllocationGranularity" after a call to "GetSystemInfo".
 |
 | For disks, the size of the "hrStorageAllocationUnits" value is computed as
 | the quantity "BytesPerSector * SectorsPerCluster" as returned by Win32 API
 | function "GetDiskFreeSpace".
 |
 | =============================================================================
 | 1.3.6.1.2.1.25.2.3.1.4.<instance>
 |                | | | |
 |                | | | *hrStorageAllocationUnits
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageAllocationUnits(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRST_ALLOC].u.number_value;
return ( SNMP_ERRORSTATUS_NOERROR );

} /* end of GetHrStorageAllocationUnits() */


/*
 *  GetHrStorageSize
 *    The size of the storage represented by this entry, in units of
 *    hrStorageAllocationUnits.
 *
 *    Gets the value for HrStorageSize.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageSize
 |
 |  ACCESS         SYNTAX
 |  read-write     INTEGER (0..2147483647)
 |
 | "The size of the storage represented by this entry, in units of
 | hrStorageAllocationUnits."
 |
 | DISCUSSION:
 |
 | For Virtual Memory, the value returned is computed as "TotalPageFile" (as
 | returned by "GlobalMemoryStatusEx") divided by "AllocationGranularity" from
 | "GetSystemInfo".
 |
 | For disks, the "hrStorageSize" value is the value of "TotalNumberOfClusters"
 | as returned by Win32 API function "GetDiskFreeSpace".
 |
 | <POA-4> This variable is marked as ACCESS="read-write".  It is unclear to me
 | what effect can be expected from a SET operation on this variable.  I propose
 | making a SET operation have no effect.
 |
 | RESOLVED >>>>>>>
 | <POA-4> Leaving this read-only is fine.
 | RESOLVED >>>>>>>
 |
 | =============================================================================
 | 1.3.6.1.2.1.25.2.3.1.5.<instance>
 |                | | | |
 |                | | | *hrStorageSize
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageSize(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRST_SIZE].u.number_value;
return ( SNMP_ERRORSTATUS_NOERROR )  ;

} /* end of GetHrStorageSize() */


/*
 *  SetHrStorageSize
 *    The size of the storage represented by this entry, in units of
 *    hrStorageAllocationUnits.
 *
 *    Sets the HrStorageSize value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 *
 | =============================================================================
 | 1.3.6.1.2.1.25.2.3.1.5.<instance>
 |                | | | |
 |                | | | *hrStorageSize
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
SetHrStorageSize(
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

#if 0
//debug debug debug debug debug
static int x=0;
if (x==0) {
    /*
    | If it is invoked here, the invocation
    | of it in mib.c must be removed.
    */
    Gen_HrDevice_Cache();
    x =1;
    }
//debug debug debug debug debug
#endif

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrStorageSize() */


/*
 *  GetHrStorageUsed
 *    The amount of the storage represented by this entry that is allocated,
 *    in units of hrStorageAllocationUnits.
 *
 *    Gets the value for HrStorageUsed.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrStorageUsed
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 |
 | "The amount of the storage represented by this entry that is allocated, in
 | units of hrStorageAllocationUnits."
 |
 | DISCUSSION:
 |
 | For Virtual Memory, the value returned is computed as the quantity
 | "TotalPageFile" less "AvailPageFile" (as returned by "GlobalMemoryStatusEx")
 | divided by "AllocationGranularity" (as returned by "GetSystemInfo".
 |
 | For disks, the "hrStorageUsed" value is computed as the quantity
 | "TotalNumberOfClusters - NumberOfFreeClusters" as returned by Win32 API
 | function "GetDiskFreeSpace".
 |
 | ===========================================================================
 | 1.3.6.1.2.1.25.2.3.1.6.<instance>
 |                | | | |
 |                | | | *hrStorageUsed
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageUsed(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */



/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRST_USED].u.number_value;
return ( SNMP_ERRORSTATUS_NOERROR )  ;

} /* end of GetHrStorageUsed() */


/*
 *  GetHrStorageAllocationFailures
 *    The number of requests for storage represented by this entry that could
 *    not be honored due to not enough storage.  It should be
 *
 *    Gets the value for HrStorageAllocationFailures.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 |=============================================================================
 |hrStorageAllocationFailures
 |
 | ACCESS         SYNTAX
 | read-only      Counter
 |
 |"The number of requests for storage represented by this entry that could not
 |be honored due to not enough storage.  It should be noted that as this object
 |has a SYNTAX of Counter, that it does not have a defined initial value.
 |However, it is recommended that this object be initialized to zero."
 |
 |DISCUSSION:
 |
 |<POA-5> This value as very problematical for both Virtual Memory and Disk
 |storage.  There appear to be no Win32 APIs that report allocation failures for
 |either virtual memory or disk storage.  I presume there may be performance
 |monitoring counters stored in the registry, however I'm not able to find the
 |documentation that describes where such information might be stored.  For
 |disks, we need to be able to map whatever counters are stored into logical
 |drives (as that is how this table is organized).
 |
 |RESOLVED >>>>>>>
 |<POA-5> You would have to scan to event log looking for the out of virtual
 |memory and out of disk space events and count them.
 |RESOLVED >>>>>>>
 |=============================================================================
 | 1.3.6.1.2.1.25.2.3.1.7.<instance>
 |                | | | |
 |                | | | *hrStorageAllocationFailures
 |                | | *hrStorageEntry
 |                | *-hrStorageTable
 |                *-hrStorage
 */

UINT
GetHrStorageAllocationFailures(
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
CHAR            device[3];      /* Device Name build-buffer             */
ULONG           index;          /* As fetched from instance structure   */
CACHEROW       *row;            /* Row entry fetched from cache         */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrStorage_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Load the "device[]" array with two characters, either something like "C:"
| (indicating we're interested in allocation failures for "C:") or "VM"
| if we want VM storage allocation failures.... from the HRST_DESCR string.
*/
if (strcmp(row->attrib_list[HRST_DESCR].u.string_value, VM) == 0) {
    /* Storage is really "Virtual Memory" */
    device[0] = 'V';
    device[1] = 'M';
    }
else {
    device[0] = row->attrib_list[HRST_DESCR].u.string_value[0];
    device[1] = row->attrib_list[HRST_DESCR].u.string_value[1];
    }
device[2] = 0;       /* Null-terminate */

/* Riffle thru the Event Log looking for this device's failures */
*outvalue = ScanLog_Failures( device );

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrStorageAllocationFailures() */


/*
 *  HrStorageEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSTORAGEENTRY_VAR_INDEX )
    // No instance was specified
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSTORAGEENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

    tmp_instance = FullOid->ids[ HRSTORAGEENTRY_VAR_INDEX ] ;

        /*
        | Check for age-out and possibly refresh the entire cache for the
        | hrStorage table and hrFSTable before we check to see if the 
        | instance is there.
        */
        if (hrStorageCache_hrFSTableCache_Refresh() == FALSE) {
            return SNMP_ERRORSTATUS_GENERR;
            }

        /*
        | For hrStorage, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrStorageTable cache.
        | Check that here.
        */
    if ( FindTableRow(tmp_instance, &hrStorage_cache) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
    else
    {
        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.
        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageEntryFindInstance() */



/*
 *  HrStorageEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //  Developer supplied code to find the next instance of class goes here.
    //
    //  The purpose of this function is to indicate to the rest of the system
    //  what the exact OID of the "next instance" is GIVEN THAT:
    //
    //          a) The "FullOid" passed in will have enough arcs to specify
    //             both the TABLE and the ATTRIBUTE in the table
    //
    //          b) The "instance" OID array is always big enough to have
    //             as many arcs as needed loaded into it by this function
    //             to specify (exactly) the "next instance"
    //
    //
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //
    //  If the FullOid is so short that it does not specify an instance,
    //  then the only instance of the class should be returned.  If this is a
    //  table, the first row of the table is returned.  To do these things,
    //  set the "instance" OID to just the right arcs such that when
    //  concatenated onto the FullOid, the concatenation exactly specifies
    //  the first instance of this attribute in the table.
    //
    //  If an instance is specified and this is a non-table class, then
    //  NOSUCHNAME is returned so that correct MIB rollover processing occurs.
    //
    //  If this is a table, then the next instance is the one following the
    //  current instance.
    //
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSTORAGEENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSTORAGEENTRY_VAR_INDEX ] ;
        }

    /*
    | Check for age-out and possibly refresh the entire cache for the
    | hrStorage table and hrFSTable before we check to see if the 
    | instance is there.
    */
    if (hrStorageCache_hrFSTableCache_Refresh() == FALSE) {
        return SNMP_ERRORSTATUS_GENERR;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrStorage_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageEntryFindNextInstance() */



/*
 *  HrStorageEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrStorageEntryConvertInstance() */




/*
 *  HrStorageEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrStorageEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrStorageTable */
} /* end of HrStorageEntryFreeInstance() */

/*
| End of Generated Code
*/


/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */
/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */
/* hrStorageCache_hrFSTableCache_Refresh Cache Refresh-Check Routine */

BOOL
hrStorageCache_hrFSTableCache_Refresh(
                     void
                     )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS: 
|
|       The "hrStorage_cache" CACHEHEAD structure and the time when
|       it was last refreshed in module-local cell "cache_time".
|       The "hrFSTable_cache" CACHEHEAD structure which depends on
|       the hrStorage_cache CACHEHEAD structure.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       The function returns TRUE.  Only if the cache-time has aged-out
|       is the cache actually rebuilt.
|
|     On any Failure:
|       If during a rebuild there is an error, this function returns FALSE.
|       The state of the cache is indeterminate.
|
|  THE BIG PICTURE:
|
|       This function is invoked before any reference is made to any SNMP
|       variable in the hrStorage table.  It checks to see
|       if the cache needs to be rebuilt based on the last time it was built.
|       Since the hrFSTable_cache depends on the hrStorage table,
|       hrFSTable_cache will be rebuilt whenever hrStorage table is rebuilt.
|
|       The calls to this function are strategically located in the
|       "FindInstance" and "FindNextInstance" functions in "HRSTOENT.C"
|       (this module).
|
|  OTHER THINGS TO KNOW:
|
*/
{
LARGE_INTEGER   now_time;       /* Current System time in 100 ns ticks */

/* Get the current time in 100 ns ticks*/
if (NtQuerySystemTime (&now_time) != STATUS_SUCCESS)
    return FALSE;

/* If the cache is older than the maximum allowed time (in ticks) . . .  */
if ( (now_time.QuadPart - cache_time.QuadPart) > (CACHE_MAX_AGE * 10000000) )
{
    if (Gen_Hrstorage_Cache())
    {
        // hrFSStorageIndex attribute of hrFSTable depends on the 
        // the index of the hrStorageEntry 
        return (Gen_HrFSTable_Cache());
    }
    else
        return FALSE;
}

return ( TRUE );        /* No Error (because no refresh) */
}

/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */
/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */
/* Gen_Hrstorage_Cache - Generate a initial cache for HrStorage Table */

BOOL
Gen_Hrstorage_Cache(
                    void
                    )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrStorage table,
|       "hrStorage_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "UserMibInit()" ("MIB.C") to
|       populate the cache for the HrStorage table.
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each is found in the respective source file.
|
|=============== From WebEnable Design Spec Rev 3 04/11/97==================
|  DISCUSSION:
|
|  Since this table is meant for diagnosing "out-of-storage" situations and
|  given that the information is meant to be regarded from the point of view
|  of an application, we simply report every instance of what would appear
|  on the "Drive Bar" of the File Manager (excepting network drives) plus
|  one more table entry to reflect information on "Virtual Memory".
|
|  To this end, a combination of Win32 API functions "GetLogicalDrives",
|  "GetVolumeInformation", "GetDriveType" and "GetDiskFreeSpace" are used to
|  acquire the information for the SNMP attributes in this table.
|
|  For reporting on "Virtual Memory", functions "GlobalMemoryStatusEx" and
|  "GetSystemInfo" are invoked.
|============================================================================
| 1.3.6.1.2.1.25.2.1....
|                | |
|                | *-hrStorageTypes (OIDs specifying storage types)
|                *-hrStorage
|
| 1.3.6.1.2.1.25.2.2....
|                | |
|                | *-hrMemorySize   (standalone attribute)
|                *-hrStorage
|
| 1.3.6.1.2.1.25.2.3....
|                | |
|                | *-hrStorageTable (the table)
|                *-hrStorage
*/

#define VOL_NAME_SIZE 256
#define DESCR_SIZE    384

{
CHAR    temp[8];                /* Temporary buffer for first call         */
LPSTR   pDrvStrings;            /* --> allocated storage for drive strings */
LPSTR   pOriginal_DrvStrings;   /* (Needed for final deallocation          */
DWORD   DS_request_len;         /* Storage actually needed                 */
DWORD   DS_current_len;         /* Storage used on 2nd call                */
ULONG   table_index=0;          /* hrStorageTable index counter            */
CACHEROW *row;                  /* --> Cache structure for row-being built */

SYSTEM_INFO     sys_info;       /* Filled in by GetSystemInfo for VM       */

LPSTR   str_descr;              /* String for disk label/serial description*/
CHAR    volname[VOL_NAME_SIZE+1];            /* Volume Name returned here  */
DWORD   volnamesize=VOL_NAME_SIZE;           /* Size of volname buffer     */
DWORD   serial_number;          /* Volume Serial Number                    */
DWORD   max_comp_len;           /* File system file-name component length  */
DWORD   filesys_flags;          /* File System flags (GetVolInformation)   */
CHAR    descr[DESCR_SIZE+1];    /* Full description possibly built here    */

DWORD   SectorsPerCluster;      /* GetDiskFreeSpace() cells */
DWORD   BytesPerSector;
DWORD   NumberOfFreeClusters;
DWORD   TotalNumberOfClusters;

MEMORYSTATUSEX  mem_status;     /* Filled in by GlobalMemoryStatusEx      */
NTSTATUS        ntstatus;       /* Generic return status                  */
UINT            nPrevErrorMode; /* previous state of error-mode bit flags */
DWORDLONG       ullTempStorage;
// ensures null terminated strings
descr[DESCR_SIZE] = 0; 
volname[VOL_NAME_SIZE] = 0;

/*
| Blow away any old copy of the cache
*/
DestroyTable(&hrStorage_cache);

/*
| We're going to call GetLogicalDriveStrings() twice, once to get the proper
| buffer size, and the second time to actually get the drive strings.
|
| Bogus:
*/
if ((DS_request_len = GetLogicalDriveStrings(2, temp)) == 0) {

    /* Request failed altogether, can't initialize */
    return ( FALSE );
    }

/*
| Grab enough storage for the drive strings plus one null byte at the end
*/

if ( (pOriginal_DrvStrings = pDrvStrings = malloc( (DS_request_len + 2) ) )
    == NULL) {

    /* Storage Request failed altogether, can't initialize */
    return ( FALSE );
    }

/* Go for all of the strings */
if ((DS_current_len = GetLogicalDriveStrings(DS_request_len, pDrvStrings))
    == 0) {

    /* Request failed altogether, can't initialize */
    free( pOriginal_DrvStrings );
    return ( FALSE );
    }

/*
| Freshen the time on the cache
|
| Get the current system-time in 100ns intervals . . . */
ntstatus = NtQuerySystemTime (&cache_time);
if (ntstatus != STATUS_SUCCESS)
{
    free( pOriginal_DrvStrings );
    return ( FALSE );
}

/*
|==============================================================================
| As long as we've got an unprocessed drive-string. . .
*/
while ( strlen(pDrvStrings) > 0 ) {

    UINT        drivetype;      /* Type of the drive from "GetDriveType()" */


    /*
    | Get the drive-type so we can decide whether it should participate in
    | this table.
    */
    drivetype = GetDriveType(pDrvStrings);

    if (   drivetype == DRIVE_UNKNOWN
        || drivetype == DRIVE_NO_ROOT_DIR
        || drivetype == DRIVE_REMOTE            /* No Remotes in HrStorage */
        ) {

        /* Step to next string, if any */
        pDrvStrings += strlen(pDrvStrings) + 1;

        continue;
        }

    /*
    | OK, we want this one in the table, get a row-entry created.
    */
    if ((row = CreateTableRow( HRST_ATTRIB_COUNT ) ) == NULL) {
        return ( FALSE );       // Out of memory
        }

    /* =========== hrStorageIndex ==========*/
    row->attrib_list[HRST_INDEX].attrib_type = CA_NUMBER;
    row->attrib_list[HRST_INDEX].u.unumber_value = ++table_index;


    /* =========== hrStorageType ==========*/
    row->attrib_list[HRST_TYPE].attrib_type = CA_NUMBER;

    /*
    | Based on the drive-type returned, we store a single number as
    | the cached value of the hrStorageType attribute.  When this attribute
    | is fetched, the cached number forms the last arc in the OBJECT IDENTIFIER
    | that actually specifies the type: { hrStorageTypes x }, where "x" is
    | what gets stored.
    */
    switch (drivetype) {

        case DRIVE_REMOVABLE:
            row->attrib_list[HRST_TYPE].u.unumber_value = 5;
            break;

        case DRIVE_FIXED:
            row->attrib_list[HRST_TYPE].u.unumber_value = 4;
            break;

        case DRIVE_CDROM:
            row->attrib_list[HRST_TYPE].u.unumber_value = 7;
            break;

        case DRIVE_RAMDISK:
            row->attrib_list[HRST_TYPE].u.unumber_value = 8;
            break;

        default:
            row->attrib_list[HRST_TYPE].u.unumber_value = 1;  // "Other"
            break;
        }


    /* =========== hrStorageDescr ==========
    |
    |  We try and fetch the volume label here, to get a string
    |  that may look like:
    |           C: Label="Main Disk"  Serial #=0030-34FE
    |
    | Handle all kinds of disk storage here:
    |
    |   Try to get volume label and serial number.  If we fail, we just give
    |   'em the root-path name.
    |
    |   Presume that we'll fail, and just return the root-path string.
    */
    str_descr = pDrvStrings;

    /*
    | Suppress any attempt by the system to make the user put a volume in a
    | removable drive.
    */
    nPrevErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if (GetVolumeInformation(pDrvStrings,       /* drive name           */
                             volname,           /* Volume Name Buffer   */
                             volnamesize,       /* Size of buffer       */
                             &serial_number,    /* Vol. # Returned here */
                             &max_comp_len,     /* Max filename length  */
                             &filesys_flags,    /* File System flags    */
                             NULL,              /* Name of Filesystem   */
                             0                  /* Length of name       */
                             )) {
        /*
        | We got something back.
        |
        | If we have room given string lengths, build a description:
        |
        |    <root path> Label:<volume name>  Serial Number: <#>
        */
        #define SPRINTF_FORMAT "%s Label:%s  Serial Number %x"

        if ((strlen(SPRINTF_FORMAT) + strlen(volname) + strlen(str_descr))
            < DESCR_SIZE) {
            _snprintf(descr,
                    DESCR_SIZE,
                    SPRINTF_FORMAT,
                    str_descr,          // root-path
                    volname,            // volume name
                    serial_number);     // volume serial #
            str_descr = descr;
            }
        }


    row->attrib_list[HRST_DESCR].attrib_type = CA_STRING;

    /*
    | Note:
    |       The convention is established that the first characters of
    |       this description string is always the device-string (e.g. "C:")
    |       or the value of local symbol "VM" ("Virtual Memory").
    |
    |       Code in "GetHrStorageAllocationFailures()" attempts to extract
    |       the drive letter (or "Virtual Memory") from the beginning of this
    |       string in order to determine allocation failures from the
    |       Event Log(!).
    */
    if ( (row->attrib_list[HRST_DESCR].u.string_value
          = ( LPSTR ) malloc(strlen(str_descr) + 1)) == NULL) {

        DestroyTableRow(row);
        free( pOriginal_DrvStrings );
        SetErrorMode(nPrevErrorMode);    /* Turn error suppression mode off */
        return ( FALSE );       /* out of memory */
        }
    /* Copy the Value into the space */
    strcpy(row->attrib_list[HRST_DESCR].u.string_value, str_descr);

    row->attrib_list[HRST_ALLOC].attrib_type = CA_NUMBER;
    row->attrib_list[HRST_SIZE].attrib_type = CA_NUMBER;
    row->attrib_list[HRST_USED].attrib_type = CA_NUMBER;

    /*
    | Handle all kinds of disk storage info here:
    |
    |   Try to get volume statistics via GetDiskFreeSpace().
    */
    if (GetDiskFreeSpace(pDrvStrings,           // drive
                         &SectorsPerCluster,
                         &BytesPerSector,
                         &NumberOfFreeClusters,
                         &TotalNumberOfClusters
                         )) {
        /* Success */

        /* =========== hrStorageAllocationUnits ==========*/
        row->attrib_list[HRST_ALLOC].u.unumber_value =
                          BytesPerSector * SectorsPerCluster;

        /* =========== hrStorageSize ==========*/
        row->attrib_list[HRST_SIZE].u.unumber_value = TotalNumberOfClusters;

        /* =========== hrStorageUsed ==========*/
        row->attrib_list[HRST_USED].u.unumber_value =
            TotalNumberOfClusters - NumberOfFreeClusters;
        }
    else {
        /* Failure */

        /* =========== hrStorageAllocationUnits ==========*/
        row->attrib_list[HRST_ALLOC].u.unumber_value = 0;

        /* =========== hrStorageSize ==========*/
        row->attrib_list[HRST_SIZE].u.unumber_value = 0;

        /* =========== hrStorageUsed ==========*/
        row->attrib_list[HRST_USED].u.unumber_value = 0;
        }

    /* =========== hrStorageAllocationFailures ==========*/
    row->attrib_list[HRST_FAILS].attrib_type = CA_COMPUTED;

    SetErrorMode(nPrevErrorMode);        /* Turn error suppression mode off */

    /*
    | Now insert the filled-in CACHEROW structure into the
    | cache-list for the hrStorageTable.
    */
    if (AddTableRow(row->attrib_list[HRST_INDEX].u.unumber_value,  /* Index */
                    row,                                           /* Row   */
                    &hrStorage_cache                               /* Cache */
                    ) == FALSE) {
        
        DestroyTableRow(row);
        free( pOriginal_DrvStrings );
        return ( FALSE );       /* Internal Logic Error! */
        }

    /* Step to next string, if any */
    pDrvStrings += strlen(pDrvStrings) + 1;
    }


free( pOriginal_DrvStrings );

/*
|==============================================================================
| Now handle Virtual Memory as a special case.
|==============================================================================
*/
if ((row = CreateTableRow( HRST_ATTRIB_COUNT ) ) == NULL) {
    return ( FALSE );       // Out of memory
    }

/* =========== hrStorageIndex ==========*/
row->attrib_list[HRST_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRST_INDEX].u.unumber_value = ++table_index;

/* =========== hrStorageType ==========*/
row->attrib_list[HRST_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRST_TYPE].u.unumber_value = 3;        /* Virtual Memory */

/* =========== hrStorageDescr ==========*/
row->attrib_list[HRST_DESCR].attrib_type = CA_STRING;
if ( (row->attrib_list[HRST_DESCR].u.string_value
      = ( LPSTR ) malloc(strlen(VM) + 1)) == NULL) {
    DestroyTableRow(row);
    return ( FALSE );       /* out of memory */
    }
strcpy(row->attrib_list[HRST_DESCR].u.string_value, VM);


/* =========== hrStorageAllocationUnits ==========*/
GetSystemInfo(&sys_info);
row->attrib_list[HRST_ALLOC].attrib_type = CA_NUMBER;
row->attrib_list[HRST_ALLOC].u.unumber_value =
                                             sys_info.dwAllocationGranularity;

/* =========== hrStorageSize ==========*/
/* Acquire current memory statistics */
mem_status.dwLength = sizeof(MEMORYSTATUSEX);
if (!GlobalMemoryStatusEx(&mem_status)) 
{
    RtlZeroMemory(&mem_status, sizeof(MEMORYSTATUSEX));
}
ASSERT(sys_info.dwAllocationGranularity != 0);
ullTempStorage = mem_status.ullTotalPageFile / sys_info.dwAllocationGranularity;
if (ullTempStorage > (DWORDLONG)INT_MAX) 
{
    ullTempStorage = (DWORDLONG)INT_MAX;
}
row->attrib_list[HRST_SIZE].attrib_type = CA_NUMBER;
row->attrib_list[HRST_SIZE].u.unumber_value = (INT)ullTempStorage;


/* =========== hrStorageUsed ==========*/
ullTempStorage = (mem_status.ullTotalPageFile - mem_status.ullAvailPageFile) / 
                    sys_info.dwAllocationGranularity;
if (ullTempStorage > (DWORDLONG)INT_MAX) 
{
    ullTempStorage = (DWORDLONG)INT_MAX;
}
row->attrib_list[HRST_USED].attrib_type = CA_NUMBER;
row->attrib_list[HRST_USED].u.unumber_value = (INT)ullTempStorage;

/* =========== hrStorageAllocationFailures ==========*/
row->attrib_list[HRST_FAILS].attrib_type = CA_COMPUTED;

/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrStorageTable.
*/
if (AddTableRow(row->attrib_list[HRST_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrStorage_cache                               /* Cache */
                ) == FALSE) {
    
    DestroyTableRow(row);
    return ( FALSE );       /* Internal Logic Error! */
    }
/*
|==============================================================================
| End of Virtual Memory
|==============================================================================
*/

/*
|==============================================================================
| Now handle Physical Memory as a special case.
|==============================================================================
*/
if ((row = CreateTableRow( HRST_ATTRIB_COUNT ) ) == NULL) {
    return ( FALSE );       // Out of memory
    }

/* =========== hrStorageIndex ==========*/
row->attrib_list[HRST_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRST_INDEX].u.unumber_value = ++table_index;

/* =========== hrStorageType ==========*/
row->attrib_list[HRST_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRST_TYPE].u.unumber_value = 2;        /* hrStorageRAM */

/* =========== hrStorageDescr ==========*/
row->attrib_list[HRST_DESCR].attrib_type = CA_STRING;
if ( (row->attrib_list[HRST_DESCR].u.string_value
      = ( LPSTR ) malloc(strlen(PHYMEM) + 1)) == NULL) {
    DestroyTableRow(row);
    return ( FALSE );       /* out of memory */
    }
strcpy(row->attrib_list[HRST_DESCR].u.string_value, PHYMEM);


/* =========== hrStorageAllocationUnits ==========*/
// same as granularity with which virtual memory is allocated
row->attrib_list[HRST_ALLOC].attrib_type = CA_NUMBER;
row->attrib_list[HRST_ALLOC].u.unumber_value =
                                             sys_info.dwAllocationGranularity;

/* =========== hrStorageSize ==========*/
ullTempStorage = mem_status.ullTotalPhys / sys_info.dwAllocationGranularity;
if (ullTempStorage > (DWORDLONG)INT_MAX) 
{
    ullTempStorage = (DWORDLONG)INT_MAX;
}
row->attrib_list[HRST_SIZE].attrib_type = CA_NUMBER;
row->attrib_list[HRST_SIZE].u.unumber_value = (INT)ullTempStorage;


/* =========== hrStorageUsed ==========*/
ullTempStorage = (mem_status.ullTotalPhys - mem_status.ullAvailPhys) / 
                    sys_info.dwAllocationGranularity;
if (ullTempStorage > (DWORDLONG)INT_MAX) 
{
    ullTempStorage = (DWORDLONG)INT_MAX;
}
row->attrib_list[HRST_USED].attrib_type = CA_NUMBER;
row->attrib_list[HRST_USED].u.unumber_value = (INT)ullTempStorage;

/* =========== hrStorageAllocationFailures ==========*/
row->attrib_list[HRST_FAILS].attrib_type = CA_COMPUTED;

/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrStorageTable.
*/
if (AddTableRow(row->attrib_list[HRST_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrStorage_cache                               /* Cache */
                ) == FALSE) {
    
    DestroyTableRow(row);
    return ( FALSE );       /* Internal Logic Error! */
    }
/*
|==============================================================================
| End of Physical Memory
|==============================================================================
*/

#if defined(CACHE_DUMP)
PrintCache(&hrStorage_cache);
#endif

/*
| Initialization of this table's cache succeeded
*/
return (TRUE);
}

/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */
/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */
/* ScanLog_Failures - Scan Event Log for Storage Allocation Failures */

static UINT
ScanLog_Failures(
                 CHAR   *device
                 )

/*
|  EXPLICIT INPUTS:
|
|       "device" is either the string "VM" (for "Virtual Memory") or
|       the logical device for which we're looking for failures (e.g. "C:").
|
|  IMPLICIT INPUTS:
|
|       The System Event log file.
|
|  OUTPUTS:
|
|     On Success/Failure:
|       Function returns the number of storage allocation failures
|       found for the specified device.
|
|  THE BIG PICTURE:
|
|       This is a "helper" function for routine "GetHrStorageAllocationFailures"
|       within this module.
|
|  OTHER THINGS TO KNOW:
|
|       We scan backwards (in time) thru the Event Log until we hit the
|       "Event Logging Started" event record (because, presumably, we don't
|       care about failures that happened before the system last came up).
*/

/*
| These symbols select the "Event Log Started" informational message.
*/
#define EVENTLOG_START_ID   0x80001775
#define EVENTLOG_START_TYPE 4
#define EVENTLOG_START_SRC  "EventLog"

{
#define EVL_BUFFER_SIZE 2048
EVENTLOGRECORD *pevlr;
BYTE            bBuffer[EVL_BUFFER_SIZE];
DWORD           dwRead, dwNeeded, cRecords;
HANDLE          h;
BOOL            keep_scanning = TRUE;
UINT            alloc_failures = 0;

/*
| Open the System event log
*/
h = OpenEventLog(NULL,      /* local computer */
                 "System"   /* source name    */
                 );

if (h == NULL) {
    return ( alloc_failures );
    }

pevlr = (EVENTLOGRECORD *) &bBuffer;

/*
| Read records sequentially "Backward in Time" until there
| are no more, or we hit the "Event Logging Started" event.
|
| Read a "Slug 'o Records":
*/
while (ReadEventLog(h,                      // event log handle
                    EVENTLOG_BACKWARDS_READ | // reads backward
                    EVENTLOG_SEQUENTIAL_READ, // sequential read
                    0,                      // ignored for sequential reads
                    pevlr,                  // address of buffer
                    EVL_BUFFER_SIZE,        // size of buffer
                    &dwRead,                // count of bytes read
                    &dwNeeded)              // bytes in next record
       && keep_scanning == TRUE) {


    /* Wind down thru this "slug" . . . */
    while (dwRead > 0) {

        /*
        | Check for "Event Logging Started"
        |
        | (The source name is just past the end of the formal structure).
        */
        if (   pevlr->EventID == EVENTLOG_START_ID
            && pevlr->EventType == EVENTLOG_START_TYPE
            && strcmp( ((LPSTR) ((LPBYTE) pevlr + sizeof(EVENTLOGRECORD))),
                      EVENTLOG_START_SRC) == 0
            ) {
            keep_scanning = FALSE;
            break;
            }

//============================================================================
// INSERT RECORD CHECKING LOGIC OF THIS SORT HERE:
//
//      IF (    <eventrecordID>           == pevlr->EventID
//           && <eventrecordtype>         == pevlr->EventType
//           && <eventrecordsourcestring> == (is the same as..)
//                     ( (LPSTR) ((LPBYTE) pevlr + sizeof(EVENTLOGRECORD)) )
//         ) {
//              // It's an allocation-failure record, if it is for device
//              // "device", then count it.
//              IF (strcmp(device, <eventrecordinstance-data>) {
//                  alloc_failures += 1;
//                  }
//           }
//============================================================================

        dwRead -= pevlr->Length;
        pevlr = (EVENTLOGRECORD *)
            ((LPBYTE) pevlr + pevlr->Length);
        }

    pevlr = (EVENTLOGRECORD *) &bBuffer;
    }

CloseEventLog(h);

/* Give 'em the count */
return (alloc_failures);
}

#if defined(CACHE_DUMP)

/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */
/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */
/* debug_print_hrstorage - Prints a Row from Hrstorage sub-table */

static void
debug_print_hrstorage(
                      CACHEROW     *row  /* Row in hrstorage table */
                      )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=====================\n");
    fprintf(OFILE, "hrStorage Table Cache\n");
    fprintf(OFILE, "=====================\n");
    return;
    }


fprintf(OFILE, "hrStorageIndex . . . . . %d\n",
        row->attrib_list[HRST_INDEX].u.unumber_value);

fprintf(OFILE, "hrStorageType. . . . . . %d ",
        row->attrib_list[HRST_TYPE].u.unumber_value);

switch (row->attrib_list[HRST_TYPE].u.unumber_value) {
    case 1: fprintf(OFILE, "(Other)\n");        break;
    case 2: fprintf(OFILE, "(RAM)\n");        break;
    case 3: fprintf(OFILE, "(Virtual Memory)\n");        break;
    case 4: fprintf(OFILE, "(Fixed Disk)\n");        break;
    case 5: fprintf(OFILE, "(Removable Disk)\n");        break;
    case 6: fprintf(OFILE, "(Floppy Disk)\n");        break;
    case 7: fprintf(OFILE, "(Compact Disk)\n");        break;
    case 8: fprintf(OFILE, "(RAM Disk)\n");        break;
    default:
            fprintf(OFILE, "(Unknown)\n");
    }


fprintf(OFILE, "hrStorageDescr . . . . . \"%s\"\n",
        row->attrib_list[HRST_DESCR].u.string_value);

fprintf(OFILE, "hrStorageAllocationUnits %d\n",
        row->attrib_list[HRST_ALLOC].u.number_value);

fprintf(OFILE, "hrStorageSize. . . . . . %d\n",
        row->attrib_list[HRST_SIZE].u.number_value);

fprintf(OFILE, "hrStorageUsed. . . . . . %d\n",
        row->attrib_list[HRST_USED].u.number_value);

fprintf(OFILE, "hrStorageAllocationFails (Computed)\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrstorag.c ===
/*
 *  HrStorage.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrStorage.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/17/97  D. D. Burns Original Creation: Thu Nov 07 16:39:42 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */


/*
 *  GetHrMemorySize
 *    The amount of physical main memory contained by the host.
 *
 *    Gets the value for HrMemorySize.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrMemorySize
 |
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 |
 | "The amount of physical main memory contained by the host."
 |
 | DISCUSSION:
 |
 | Win32 API function "GlobalMemoryStatus" is invoked and the value returned
 | in structure MEMORYSTATUS for cell "dwTotalPhys" is used to compute the value
 | returned for this attribute.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.2.2.0
 |                | |
 |                | *-hrMemorySize
 |                *-hrStorage
 */

UINT
GetHrMemorySize(
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    MEMORYSTATUSEX    mem_status;     /* For "GlobalMemoryStatusEx()" call */

    /* Get the "mem_status" structure filled in */
    mem_status.dwLength = sizeof(MEMORYSTATUSEX);
    if (!GlobalMemoryStatusEx(&mem_status)) 
    {
        RtlZeroMemory(&mem_status, sizeof(MEMORYSTATUSEX));
    }

    // the maximum amount we can return is 2147483647 KBytes (i.e. INT_MAX)
    // 0x1FFFFFFFC00 = 2147483647 * 1024
    if (mem_status.ullTotalPhys > 0x1FFFFFFFC00) 
    {
        mem_status.ullTotalPhys = 0x1FFFFFFFC00;
    }
    /* Return total available physical bytes reduced to 1024 blocks */
    *outvalue = (KBytes)(mem_status.ullTotalPhys / 1024);


    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrMemorySize() */


/*
 *  HrStorageFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.
    //  However, if there is any context that needs to be set, it can be done
    //  here.

    if ( FullOid->idLength <= HRSTORAGE_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSTORAGE_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSTORAGE_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageFindInstance() */



/*
 *  HrStorageFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrStorageFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then
    //  NOSUCHNAME is returned so that correct MIB rollover processing occurs.
    //
    //  If this is a table, then the next instance is the one following the
    //  current instance.
    //
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSTORAGE_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrStorageFindNextInstance() */



/*
 *  HrStorageConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrStorageConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrStorageConvertInstance() */




/*
 *  HrStorageFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrStorageFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrStorageFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrswinst.c ===
/*
 *  HrSWInstalled.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWInstalled.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/27/97  D. D. Burns     Genned: Thu Nov 07 16:48:30 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file     */


/*
 *  GetHrSWInstalledLastChange
 *    The value of sysUpTime when an entry in the hrSWInstalledTable was last 
 *    added, renamed, or deleted.  Because this table is likel
 *    
 *    Gets the value for HrSWInstalledLastChange.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledLastChange
 | 
 |  ACCESS         SYNTAX
 |  read-only      TimeTicks
 | 
 | "The value of sysUpTime when an entry in the hrSWInstalledTable was last
 | added, renamed, or deleted.  Because this table is likely to contain many
 | entries, polling of this object allows a management station to determine when
 | re-downloading of the table might be useful."
 |
 |============================================================================
 | Decision is made to report the current value of sysUpTime as a means of
 | signalling the SNMP Manager that "whatever he's got now, he should ask
 | for the latest".  Our cache of installed software is never updated after
 | the agent comes up in the first release.
 |============================================================================
 | 1.3.6.1.2.1.25.6.1.0....
 |                | | 
 |                | *hrSWInstalledLastChange
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledLastChange( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    *outvalue = SnmpSvcGetUptime();

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledLastChange() */


/*
 *  GetHrSWInstalledLastUpdateTime
 *    The value of sysUpTime when the hrSWInstalledTAble was last completely 
 *    updated.  Because caching of this data will be a popular 
 *    
 *    Gets the value for HrSWInstalledLastUpdateTime.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWInstalledLastUpdateTime
 | 
 |  ACCESS         SYNTAX
 |  read-only      TimeTicks
 | 
 | "The value of sysUpTime when the hrSWInstalledTable was last completely
 | updated.  Because caching of this data will be a popular implementation
 | strategy, retrieval of this object allows a management station to obtain a
 | guarantee that no data in this table is older than the indicated time."
 |
 |============================================================================
 | Decision is made to report the current value of sysUpTime as a means of
 | signalling the SNMP Manager that "whatever he's got now, he should ask
 | for the latest".  Our cache of installed software is never updated after
 | the agent comes up in the first release.
 |============================================================================
 | 1.3.6.1.2.1.25.6.2.0....
 |                | | 
 |                | *hrSWInstalledLastUpdateTime
 |                *-hrSWInstalled
 */

UINT
GetHrSWInstalledLastUpdateTime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    *outvalue = SnmpSvcGetUptime();

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWInstalledLastUpdateTime() */


/*
 *  HrSWInstalledFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWINSTALLED_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWINSTALLED_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWINSTALLED_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledFindInstance() */



/*
 *  HrSWInstalledFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWInstalledFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSWINSTALLED_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWInstalledFindNextInstance() */



/*
 *  HrSWInstalledConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWInstalledConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrSWInstalledConvertInstance() */




/*
 *  HrSWInstalledFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWInstalledFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWInstalledFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrswpren.c ===
/*
 *  HrSWRunPerfEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWRunPerfEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 05/14/97  D. D. Burns     Genned: Thu Nov 07 16:48:05 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */

/*
| NOTE:
|    The cache used by this table is the same one created for hrSWRun.  The
|    CACHEHEAD structure for it is located in "HRSWRUNE.C".
*/



/*
 *  GetHrSWRunPerfCPU
 *    The number of centi-seconds of the total system's CPU resources consumed 
 *    by this process.  Note that  on a multi-processor syste
 *    
 *    Gets the value for HrSWRunPerfCPU.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunPerfCPU
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER
 | 
 | "The number of centi-seconds of the total system's CPU resources consumed by
 | this process.  Note that on a multi-processor system, this value may increment
 | by more than one centi-second in one centi-second of real (wall clock) time."
 | 
 | DISCUSSION:
 | 
 | <POA-22> Given the performance monitoring counters available in the Registry,
 | how do we compute this SNMP attribute value for a given process?
 | 
 | RESOLVED >>>>>>>>
 | <POA-22> I think we should just use the PerfMon code for this.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.5.1.1.1.<instance>
 |                | | | |
 |                | | | *-hrSWRunPerfCPU
 |                | | *-hrSWRunPerfEntry
 |                | *-hrSWRunPerfTable
 |                *-hrSWRunPerf
 */

UINT
GetHrSWRunPerfCPU( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSP_CPU].u.number_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunPerfCPU() */


/*
 *  GetHrSWRunPerfMem
 *    The total amount of real system memory allocated to this process.
 *    
 *    Gets the value for HrSWRunPerfMem.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunPerfMem
 | 
 |  ACCESS         SYNTAX
 |  read-only      KBytes
 | 
 | "The total amount of real system memory allocated to this process."
 | 
 | DISCUSSION:
 | 
 | <POA-23> Given the performance monitoring counters available in the Registry,
 | how do we compute this SNMP attribute value for a given process?
 | 
 | RESOLVED >>>>>>>>
 | <POA-22> I think we should just use the PerfMon code for this.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.5.1.1.2.<instance>
 |                | | | |
 |                | | | *-hrSWRunPerfMem
 |                | | *-hrSWRunPerfEntry
 |                | *-hrSWRunPerfTable
 |                *-hrSWRunPerf
 */

UINT
GetHrSWRunPerfMem( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSP_MEM].u.number_value;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunPerfMem() */


/*
 *  HrSWRunPerfEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunPerfEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWRUNPERFENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWRUNPERFENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWRUNPERFENTRY_VAR_INDEX ] ;

        /*
        | Check for age-out and possibly refresh the entire cache for the 
        | hrSWRun(Perf) table before we check to see if the instance is there.
        */
        if (hrSWRunCache_Refresh() == FALSE) {
            return SNMP_ERRORSTATUS_GENERR;
            }

        /*
        | For hrSWRunPerf, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrSWRun(Perf) Table cache.
        | Check that here.
        */
	if ( FindTableRow(tmp_instance, &hrSWRunTable_cache) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunPerfEntryFindInstance() */



/*
 *  HrSWRunPerfEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunPerfEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSWRUNPERFENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSWRUNPERFENTRY_VAR_INDEX ] ;
        }

    /*
    | Check for age-out and possibly refresh the entire cache for the 
    | hrSWRun(Perf) table before we check to see if the instance is there.
    */
    if (hrSWRunCache_Refresh() == FALSE) {
        return SNMP_ERRORSTATUS_GENERR;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrSWRunTable_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunPerfEntryFindNextInstance() */



/*
 *  HrSWRunPerfEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWRunPerfEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrSWRunPerfEntryConvertInstance() */




/*
 *  HrSWRunPerfEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWRunPerfEntryFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWRunPerfEntryFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrswrun.c ===
/*
 *  HrSWRun.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWRun.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 05/14/97  D. D. Burns     Genned: Thu Nov 07 16:46:47 1996
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file  */
#include "HMCACHE.H"      /* Cache-related definitions        */


/*
 *  GetHrSWOSIndex
 *    The value of the hrSWRunIndex for the hrSWRunEntry that represents the 
 *    primary operating system running on this host.  This obje
 *    
 *    Gets the value for HrSWOSIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWOSIndex
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 | 
 | "The value of the hrSWRunIndex for the hrSWRunEntry that represents the
 | primary operating system running on this host.  This object is useful for
 | quickly and uniquely identifying that primary operating system."
 | 
 | 
 | DISCUSSION:
 | 
 | The value for this attribute is the index for the process named "System".
 |
 |============================================================================
 | This value is computed in module "HRSWRUNE.C" in function "AddHrSWRunRow()"
 | and stored in that module for global reference by this code.
 |============================================================================
 | 1.3.6.1.2.1.25.4.1.0
 |                | |
 |                | *-hrSWOSIndex
 |                *-hrSWRun
 */

UINT
GetHrSWOSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| Check and Refresh the entire cache for the hrSWRun table
*/
if (hrSWRunCache_Refresh() == FALSE) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = SWOSIndex;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWOSIndex() */


/*
 *  HrSWRunFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWRUN_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWRUN_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSWRUN_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunFindInstance() */



/*
 *  HrSWRunFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSWRUN_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunFindNextInstance() */



/*
 *  HrSWRunConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWRunConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrSWRunConvertInstance() */




/*
 *  HrSWRunFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWRunFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWRunFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrproces.c ===
/*
 *  HrProcessorEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrProcessorEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/28/97  D. D. Burns     Genned: Thu Nov 07 16:42:19 1996
 *
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* Cache-related definitions       */
#include "HRDEVENT.H"     /* HrDevice Table-related definitions */
#include <stdio.h>

/*
|==============================================================================
| "Processor-Information Buffer" Definition
|
| This definition defines a logical "Processor Information Block" where we
| can store all the information returned from an NtQuerySystemInformation()
| call that requests "SystemProcessorPerformanceInformation" for each running
| processor.
*/
typedef
    struct  pi_block {
        struct pi_block  *other;      // Associated "other" buffer

        LARGE_INTEGER     sys_time;   // Time when "pi_array" was last
                                      //      refreshed in 100ns ticks

        SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
                          *pi_array;   // Array: One element per processor
        DWORD              pi_size;    // Size in bytes of "pi_array" storage
                      }
                       PI_BLOCK;

/*
|==============================================================================
| "Processor-Information Buffer" Instances
|
| We create two instances of a Processor Information Buffer, one for the
| "oldest" and a second for "newest" samples of timer values.  Maintaining 
| two enables us to compute the average over time for processor loads.
|
| These blocks are initialized by code in "Gen_HrProcessor_Cache()" in
| this module.
|
| These buffers are refreshed in an alternating manner by function
| "hrProcessLoad_Refresh()" (in this module) that itself is invoked on a
| timer-driven basis.  (See source for the function).
*/
static
PI_BLOCK        pi_buf1;        // First Buffer
static
PI_BLOCK        pi_buf2;        // Second Buffer 


/*
|==============================================================================
| Oldest "Processor-Information Buffer"
|
| This cell points at one of the two PI_BLOCKs above.  It always points to
| the buffer block that has the "oldest" data in it.
*/
static
PI_BLOCK       *oldest_pi=NULL;

#if defined(PROC_CACHE)         // For debug cache dump only
static
int             processor_count;
#endif


/*
 *  GetHrProcessorFrwID
 *    The product ID of the firmware associated with the processor.
 *    
 *    Gets the value for HrProcessorFrwID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrProcessorFrwID
 | 
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 | 
 | "The product ID of the firmware associated with the processor."
 | 
 | DISCUSSION:
 | 
 | <POA-11> The underlying syntax of this attribute is Object Identifier.  None
 | of the documented Win32 API functions seem capable of reporting this value.
 | We are allowed to report "unknownProductID"  ("0.0") in liew of the real
 | value, and this will be hardcoded unless an alternative is specified.
 | 
 | RESOLVED >>>>>>>>
 | <POA-11> Returning an unknown Product ID is acceptable.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | 1.3.6.1.2.1.25.3.3.1.1.<instance>
 |                | | | |
 |                | | | *-hrProcessorFrwID
 |                | | *-hrProcessorEntry
 |                | *-hrProcessorTable
 |                *-hrDevice
 */

UINT
GetHrProcessorFrwID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0" 
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrProcessorFrwID() */


/*
 *  GetHrProcessorLoad
 *    The average, over the last minute, of the percentage of time that this 
 *    processor was not idle.
 *    
 *    Gets the value for HrProcessorLoad.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrProcessorLoad
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..100)
 | 
 | "The average, over the last minute, of the percentage of time that this
 | processor was not idle."
 | 
 | DISCUSSION:
 | 
 | <POA-12> It seems likely to me that this performance statistic might be
 | maintained or be derivable from performance information maintained in the
 | Registry.  Please describe.
 | 
 | RESOLVED >>>>>>>>
 | <POA-12> I think we should just use the PerfMon code for this.
 | RESOLVED >>>>>>>>
 | 
 |============================================================================
 | We reference a continuously updated module-local cache of CPU time-usage
 | info maintained in the buffer-blocks "pi_buf1" and "pi_buf2" defined
 | at the beginning of this module.  In the code below, we reach into these
 | caches and compute the processor load for the processor specified.
 |============================================================================
 | 1.3.6.1.2.1.25.3.3.1.2.<instance>
 |                | | | |
 |                | | | *-hrProcessorLoad
 |                | | *-hrProcessorEntry
 |                | *-hrProcessorTable
 |                *-hrDevice
 */

UINT
GetHrProcessorLoad( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure   */
CACHEROW        *row;           /* Row entry fetched from cache         */
ULONG           p;              /* Selected Processor (number from 0)   */
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
               *oldest, *newest;/* --> CPU data for "n" and "n+1minute" */
LONGLONG        llDendiff;      /* Difference Denominator               */
LONGLONG        llNewNum;       /* Numerator of Newest Time-count       */
LONGLONG        llOldNum;       /* Numerator of Oldest Time-count       */
double          fNum,fDen;      /* Floated versions of LONGLONGs        */
double          fload;          /* Percentage Load                      */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrDevice_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| By convention with "Gen_HrProcessor_Cache()" the cache initialization
| routine, the "hidden context" for devices which are "Processors" is
| the Processor Number, starting with 0.
*/
p = row->attrib_list[HIDDEN_CTX].u.unumber_value;


/*
| We compute the load using "SystemProcessorPerformanceInformation" that
| has been gathered for all processors in buffers maintained in "pi_buf1"
| and "pi_buf2".
|
| Obtain pointers to the "newest" and "oldest" slug of information for
| the specified processor out of "pi_buf1/2".
*/
oldest = &(oldest_pi->pi_array[p]);
newest = &(oldest_pi->other->pi_array[p]);


/*
| The performance info (as of this writing) we need comes from:
|
| typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
|     LARGE_INTEGER IdleTime;
|     LARGE_INTEGER KernelTime;
|     LARGE_INTEGER UserTime;
|     LARGE_INTEGER DpcTime;          // DEVL only
|     LARGE_INTEGER InterruptTime;    // DEVL only
|     ULONG InterruptCount;
| } ....
|
| where "IdleTime" is taken to be time spent by this processor in its
|                  idlethread.
|
|       "KernelTime" is taken to be total time spent by processor in kernel
|                  mode code (including the idle thread).
|
|       "UserTime" is taken to be total time spent by processor in user mode
|                  code.
|
| all in ticks of 100ns (one tenth of a millionth of a second).
|
| So total "Not-Idle" time is "(KernelTime-IdleTime) + UserTime" in ticks.
| Total time for the interval is the difference in the "sys_time" that is
| associated with each buffer ("oldest_pi->" and "oldest_pi->other->").
|
*/
llNewNum = (newest->KernelTime.QuadPart - newest->IdleTime.QuadPart)
                  + newest->UserTime.QuadPart;
llOldNum = (oldest->KernelTime.QuadPart - oldest->IdleTime.QuadPart)
                  + oldest->UserTime.QuadPart;

            /* (Newest System-Time)             -     (Oldest System-Time)  */
llDendiff = oldest_pi->other->sys_time.QuadPart - oldest_pi->sys_time.QuadPart;

/* If there will be no divide by 0 */
if ( llDendiff != 0 ) {

    /*
    | Now float these guys and convert to a percentage.
    */
    fNum = (double) (llNewNum - llOldNum);
    fDen = (double) llDendiff;

    fload = (fNum / fDen) * 100.0;
    }
else {
    fload = 0.0;
    }
 
*outvalue = (int) fload;      // Truncate to integer

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrProcessorLoad() */


/*
 *  HrProcessorEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrProcessorEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT            tmp_instance ;  /* Instance arc value                 */
    CACHEROW        *row;           /* Row entry fetched from cache       */

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRPROCESSORENTRY_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRPROCESSORENTRY_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRPROCESSORENTRY_VAR_INDEX ] ;

        /*
        | For hrProcessorTable, the instance arc(s) is a single arc, and 
        | it must correctly select an entry in the hrDeviceTable cache.
        |
        | Check that here.
        */
	if ( (row = FindTableRow(tmp_instance, &hrDevice_cache)) == NULL ) {
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
	else
	{
            /*
            | The instance arc selects an hrDeviceTable row entry, but is that
            | entry actually for a device of type "Processor"?
            |
            | (We examine the last arc of the OID that specifies the device
            |  type in the row entry selected by the instance arc).
            */
            if (row->attrib_list[HRDV_TYPE].u.unumber_value !=
                HRDV_TYPE_LASTARC_PROCESSOR) {

                return SNMP_ERRORSTATUS_NOSUCHNAME;
                }

	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrProcessorEntryFindInstance() */



/*
 *  HrProcessorEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrProcessorEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRPROCESSORENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first 
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRPROCESSORENTRY_VAR_INDEX ] ;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrDevice_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    /*
    | The instance arc selects an hrDeviceTable row entry, but is that
    | entry actually for a device of type "Processor"?
    |
    | (We examine the last arc of the OID that specifies the device
    |  type in the row entry selected by the instance arc).
    */
    do {
        if (row->attrib_list[HRDV_TYPE].u.unumber_value ==
            HRDV_TYPE_LASTARC_PROCESSOR) {

            /* Found an hrDeviceTable entry for the right device type */
            break;
            }

        /* Step to the next row in the table */
        row = GetNextTableRow( row );
        }
        while ( row != NULL );

    /* If we found a proper device-type row . . . */
    if ( row != NULL) {
        instance->ids[ 0 ] = row->index ;
        instance->idLength = 1 ;
        }
    else {

        /*
        | Fell off the end of the hrDeviceTable without finding a row
        | entry that had the right device type.
        */
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrProcessorEntryFindNextInstance() */



/*
 *  HrProcessorEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrProcessorEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrProcessorEntryConvertInstance() */




/*
 *  HrProcessorEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrProcessorEntryFreeInstance( IN OUT InstanceName *instance )
{

  /* No action needed for hrProcessor Table */
} /* end of HrProcessorEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */
/* Gen_HrProcessor_Cache - Gen. a initial cache for HrDevice PROCESSOR Table */

BOOL
Gen_HrProcessor_Cache(
                      ULONG type_arc
                      )

/*
|  EXPLICIT INPUTS:
|
|       "type_arc" is the number "n" to be used as the last arc in the
|       device-type OID:
|
|        1.3.6.1.2.1.25.3.1.n
|                       | | |
|                       | | * Identifying arc for type
|                       | *-hrDeviceTypes (OIDs specifying device types)
|                       *-hrDevice
|
|        for devices created by this cache-population routine.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the HrDevice cache has been fully
|       populated with all rows required for Processor devices.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in "Gen_HrDevice_Cache()" to
|       populate the cache for the HrDevice table with processor-specific
|       entries.
|
|  OTHER THINGS TO KNOW:
|
|       This function is loading entries into the existing HrDevice cache
|       for devices of type "processor" as well as setting up what logically
|       amounts to a "cache" of information used to compute the value of
|       hrProcessorLoad.
|
|       Specifically, this function initializes module-local cells that
|       describe buffers containing processor-time information for each
|       processor.
|
|       This function holds a convention with the GET routines earlier in
|       this module that the "HIDDEN_CTX" attribute for processors contains
|       a number that can be used to select which processor information
|       is to be returned.  We generate this number here.
|============================================================================
| 1.3.6.1.2.1.25.3.3.1...
|                | | |
|                | | *hrProcessorEntry
|                | *hrProcessorTable
|                *-hrDevice
|
*/
{
SYSTEM_INFO     sys_info;       /* Filled in by GetSystemInfo for processors */
UINT            i;              /* Handy-Dandy loop index                    */
char           *descr;          /* Selected description string               */


/* Acquire system information statistics */
GetSystemInfo(&sys_info);

/*
| Build a description based on the system info.  We presume all processors
| are identical.
*/
switch (sys_info.wProcessorArchitecture) {


    case PROCESSOR_ARCHITECTURE_INTEL:
        switch (sys_info.wProcessorLevel) {
            case 3:     descr = "Intel 80386";     break;
            case 4:     descr = "Intel 80486";     break;
            case 5:     descr = "Intel Pentium";   break;
            default:    descr = "Intel";           break;
            }
        break;
                
    case PROCESSOR_ARCHITECTURE_ALPHA:
        switch (sys_info.wProcessorLevel) {
            case 21064: descr = "Alpha 21064";     break;
            case 21066: descr = "Alpha 21066";     break;
            case 21164: descr = "Alpha 21164";     break;
            default:    descr = "DEC Alpha";       break;
            }
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        switch (sys_info.wProcessorLevel) {
            case 4:     descr = "MIPS R4000";     break;
            default:    descr = "MIPS";           break;
            }
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        switch (sys_info.wProcessorLevel) {
            case 1:     descr = "PPC 601";       break;
            case 3:     descr = "PPC 603";       break;
            case 4:     descr = "PPC 604";       break;
            case 6:     descr = "PPC 603+";      break;
            case 9:     descr = "PPC 604+";      break;
            case 20:    descr = "PPC 620";       break;
            default:    descr = "PPC";           break;
            }
        break;
    
    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        descr = "Unknown Processor Type";
    }

/*
| For every processor we have in the system, fill in a row in the hrDevice
| table.
*/
for (i = 0; i < sys_info.dwNumberOfProcessors; i += 1) {

    /*
    | "Hidden Context" is a generated number starting at 0 which we'll
    | consider to be the processor number..
    */

    if (AddHrDeviceRow(type_arc,        // DeviceType OID Last-Arc
                       descr,           // Device Description
                       &i,              // Hidden Ctx "Processor #"
                       CA_NUMBER        // Hidden Ctx type
                       ) == NULL ) {

        /* Something blew */
        return ( FALSE );
        }
    }

/*
| Now initialize the PI_BLOCK instances needed to compute the hrProcessorLoad
| and the pointer to the PI_BLOCK instance that is to be considered the
| "oldest".
*/

/*
| Storage for both buffers. . . .*/
pi_buf1.pi_size = sys_info.dwNumberOfProcessors *
                  sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
if ((pi_buf1.pi_array = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                        malloc(pi_buf1.pi_size)) == NULL) {
    return ( FALSE );  // Out of Memory
    }

pi_buf2.pi_size = sys_info.dwNumberOfProcessors *
                  sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
if ((pi_buf2.pi_array = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                        malloc(pi_buf2.pi_size)) == NULL) {
    return ( FALSE );  // Out of Memory
    }

/*
| Now "hook" the two buffer blocks together so we can switch between them
| symmetrically.
*/
pi_buf1.other = &pi_buf2;
pi_buf2.other = &pi_buf1;

#if defined(PROC_CACHE)         // For debug cache dump only
processor_count = sys_info.dwNumberOfProcessors;
#endif

/*
| Pretend the first is the oldest and get it refreshed.
*/
oldest_pi = &pi_buf1;     // Select it
hrProcessLoad_Refresh();  // Refresh it, and select the other as "oldest"

SleepEx(1, FALSE);        // Pause one millisecond to avoid divide by 0
hrProcessLoad_Refresh();  // Refresh the second and select other as "oldest"

/*
| Now each Processor Information Block contains full information (about
| all processors) separated in time by 1 millisecond.  The "oldest" will
| be refreshed periodically every minute by the timer which is initialized
| via a call to "TrapInit()" made from source "mib.c" after the initialization
| of caches is complete.  Once the timer begins ticking regularly, the time
| samples in these two PI_BLOCK buffers will differ by one minute, (the period
| of the timer) which is the period required by the definition of
| "hrProcessorLoad".
*/


return ( TRUE );
}


/* hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine */
/* hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine */
/* hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine */

void
hrProcessLoad_Refresh(
                      void
                      )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The "Processor-Information Buffer" specified by module-local cell
|       "oldest_pi" is refreshed with new time information fetched from
|       the kernel.
|
|  OUTPUTS:
|
|     On Success:
|       The PI_Block specified by "oldest_pi" is refreshed and "oldest_pi"
|       is set to point to the other PI_BLOCK.
|
|     On any Failure:
|       Function simply returns.
|
|  THE BIG PICTURE:
|
|       At subagent startup time, a timer is created by code in "TrapInit()"
|       set to "tick" at an interval of one minute.
|
|       Each time the timer goes off, the SNMP Agent calls the 
|       "SnmpExtensionTrap()" standard entry point for the sub agent.  Rather
|       than handle a trap, that function will invoke this function which
|       gathers CPU performance data so that the hrProcessLoad value can be
|       properly computed.
|
|  OTHER THINGS TO KNOW:
|
|       We alternate the buffer into which the newest CPU data is placed
|       by simply changing "oldest_pi" (each time we're invoked) to point
|       to the "other" buffer after we're done refreshing the oldest buffer.
|       In this manner, we always have two buffers of Processor Load info
|       allowing us to compute the load during the times associated with
|       those two buffers.
*/
{
NTSTATUS        ntstatus;
DWORD           bytesused;


/* Get the current system-time in 100ns intervals . . .*/
ntstatus = NtQuerySystemTime (&oldest_pi->sys_time);

/*
| . . . and as rapidly thereafter refresh the oldest buffer with information
|       on all processors */
ntstatus = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                    oldest_pi->pi_array,
                                    oldest_pi->pi_size,
                                    &bytesused);

#if defined(PROC_CACHE)
/* =========================== DEBUG DUMP ================================== */
    {
    FILE            *pfile;                 /* Dump goes here        */
    time_t          ltime;                  /* For debug message     */
    int             i;                      /* Loop index            */
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
                    *oldest, *newest;/* --> CPU data for "n" and "n+1minute" */


    if ((pfile=fopen(PROC_FILE, "a+")) != NULL) {

        time( &ltime);
        fprintf(pfile, "\n=============== Open for appending: %s", ctime( &ltime ));

        fprintf(pfile, "Periodic Refresh of \"oldest_pi\" @ %x\n", oldest_pi);

        /* For each processor . . . */
        for (i=0; i < processor_count; i += 1) {

            fprintf(pfile, "For Processor %d:\n", i);

            oldest = &(oldest_pi->pi_array[i]);
            //newest = &(oldest_pi->other->pi_array[i]);

            fprintf(pfile, "  IdleTime   = (HI) %x  (LO) %x\n",
                    oldest->IdleTime.HighPart, oldest->IdleTime.LowPart);
            fprintf(pfile, "  KernelTime = (HI) %x  (LO) %x\n",
                    oldest->KernelTime.HighPart, oldest->KernelTime.LowPart);
            fprintf(pfile, "  UserTime   = (HI) %x  (LO) %x\n",
                    oldest->UserTime.HighPart, oldest->UserTime.LowPart);
            }
        }

    fclose(pfile);
    }
/* =========================== DEBUG DUMP ================================== */
#endif

/* Now the other buffer contains the "oldest" data, so change "oldest_pi" */
oldest_pi = oldest_pi->other;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrswrune.c ===
/*
 *  HrSWRunEntry.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSWRunEntry.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *  D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 05/14/97  D. D. Burns     Genned: Thu Nov 07 16:47:29 1996
 *
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file    */
#include "HMCACHE.H"      /* Cache-related definitions          */
#include <string.h>



/*
|==============================================================================
| Function prototypes for this module.
|
*/
/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table cache */
static BOOL
AddHrSWRunRow(PSYSTEM_PROCESS_INFORMATION ProcessInfo);

/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */
void
FetchProcessParams(
PSYSTEM_PROCESS_INFORMATION ProcessInfo,   /* Process for parameters     */
CHAR                      **path_str,      /* Returned PATH string       */
CHAR                      **params_str     /* Returned Parameters string */
              );

#if defined(CACHE_DUMP)

/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */
static void
debug_print_hrswrun(
                     CACHEROW     *row  /* Row in hrSWRun(Perf) table */
                     );
#endif


/*
|==============================================================================
| Cache Refresh Time
|
| The cache for the hrSWRun and hrSWRunPerf tables is refreshed automatically
| when a request arrives --AND-- the cache is older than CACHE_MAX_AGE
| in seconds.
|
*/
static
LARGE_INTEGER   cache_time;   // 100ns Timestamp of cache (when last refreshed)

#define CACHE_MAX_AGE 120     // Maximum age in seconds


/*
|==============================================================================
| Create the list-head for the HrSWRun(Perf) Table cache.
|
| This cache contains info for both the hrSWRun and hrSWRunPerf tables.
| (This macro is defined in "HMCACHE.H").
|
| This is global so code for the hrSWRunPerf table ("HRSWPREN.C") can
| reference it.
*/
CACHEHEAD_INSTANCE(hrSWRunTable_cache, debug_print_hrswrun);



/*
|==============================================================================
| Operating System Index
|
|  SNMP attribute "HrSWOSIndex" is the index into hrSWRun to the entry that
|  primary operating system running on the host.  This value is computed in
|  this module in function "AddHrSWRunRow()" and stored here for reference
|  by code in "HRSWRUN.C".
*/
ULONG   SWOSIndex;



/*
 *  GetHrSWRunIndex
 *    A unique value for each piece of software running on the host.  Wherever
 *    possible, this should be the system's native, unique id
 *
 *    Gets the value for HrSWRunIndex.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunIndex
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (1..2147483647)
 |
 | "A unique value for each piece of software running on the host.  Wherever
 | possible, this should be the system's native, unique identification number."
 |
 | DISCUSSION:
 |
 | By using performance monitoring information from the Registry (using code
 | from "PVIEW") this attribute is given the value of the Process ID.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.1.<instance>
 |                | | | |
 |                | | | *-hrSWRunIndex
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunIndex(
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSR_INDEX].u.number_value;
return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunIndex() */


/*
 *  GetHrSWRunName
 *    A textual description of this running piece of software, including the
 *    manufacturer, revision, and the name by which it is commo
 *
 *    Gets the value for HrSWRunName.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunName
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE (0..64))
 |
 | "A textual description of this running piece of software, including the
 | manufacturer, revision, and the name by which it is commonly known.  If this
 | software was installed locally, this should be the same string as used in the
 | corresponding hrSWInstalledName."
 |
 | DISCUSSION:
 |
 | By using performance monitoring information from the Registry (using code
 | from "PVIEW") this attribute is given the value of the Process name.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.2.<instance>
 |                | | | |
 |                | | | *-hrSWRunName
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunName(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/* Return the name that was computed at cache-build time */
outvalue->length = strlen(row->attrib_list[HRSR_NAME].u.string_value);
outvalue->string = row->attrib_list[HRSR_NAME].u.string_value;
if (outvalue->length > 64) {
    outvalue->length = 64;      /* Truncate */
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunName() */


/*
 *  GetHrSWRunID
 *    The product ID of this running piece of software.
 *
 *    Gets the value for HrSWRunID.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunID
 |
 |  ACCESS         SYNTAX
 |  read-only      ProductID
 |
 | "The product ID of this running piece of software."
 |
 | DISCUSSION:
 |
 | <POA-16> I anticipate always using "unknownProduct" as the value for this
 | attribute, as I can envision no systematic means of acquiring a registered
 | OID for all process software to be used as the value for this attribute.
 |
 | RESOLVED >>>>>>>
 | <POA-16> Returning an unknown Product ID is acceptable.
 | RESOLVED >>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.3.<instance>
 |                | | | |
 |                | | | *-hrSWRunID
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunID(
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

/*
| The deal on this attribute is that we'll never have a valid OID value
| for this attribute.  Consequently, we always return the standard
| "unknown" OID value ("0.0") regardless of the instance value (which
| by now in the calling sequence of things has been validated anyway).
*/

if ( (outvalue->ids = SNMP_malloc(2 * sizeof( UINT ))) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }
outvalue->idLength = 2;

/*
| Load in the OID value for "unknown" for ProductID: "0.0"
*/
outvalue->ids[0] = 0;
outvalue->ids[1] = 0;

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunID() */


/*
 *  GetHrSWRunPath
 *    A description of the location on long-term storage (e.g. a disk drive)
 *    from which this software was loaded.
 *
 *    Gets the value for HrSWRunPath.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunPath
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 |
 | "A description of the location on long-term storage (e.g. a disk drive) from
 | which this software was loaded."
 |
 | DISCUSSION:
 |
 | <POA-17> This information is not extracted by the sample PVIEW code from the
 | performance monitoring statistics kept in the Registry.  If this information
 | is available from the Registry or some other source, I need to acquire the
 | description of how to get it.
 |
 | RESOLVED >>>>>>>>
 | <POA-17> This is obtained using PerfMon code pointers provided by Bob Watson.
 | RESOLVED >>>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.4.<instance>
 |                | | | |
 |                | | | *-hrSWRunPath
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunPath(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the Path string that was computed at cache-build time.
| NOTE: This string might be NULL.
*/
if (row->attrib_list[HRSR_PATH].u.string_value == NULL) {
    outvalue->length = 0;
    }
else {
    outvalue->length = strlen(row->attrib_list[HRSR_PATH].u.string_value);
    outvalue->string = row->attrib_list[HRSR_PATH].u.string_value;
    if (outvalue->length > 128) {
        outvalue->length = 128;      /* Truncate */
        }
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunPath() */

/*
 *  GetHrSWRunParameters
 *
 *    A description of the parameters supplied to this software when it was
 *    initially loaded."
 *
 *    Gets the value for HrSWRunParameters.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunParameters
 |
 |  ACCESS         SYNTAX
 |  read-only      InternationalDisplayString (SIZE(0..128))
 |
 | "A description of the parameters supplied to this software when it was
 | initially loaded."
 |
 | DISCUSSION:
 |
 | <POA-18> This information is not extracted by the sample PVIEW code from the
 | performance monitoring statistics kept in the Registry.  If this information
 | is available from the Registry or some other source, I need to acquire the
 | description of how to get it.
 |
 | RESOLVED >>>>>>>>
 | <POA-18> See discussion for "hrSWRunPath" above.
 | RESOLVED >>>>>>>>
 |
 |============================================================================
 | NOTE: This function edited in by hand, as it was not originally generated.
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.5.<instance>
 |                | | | |
 |                | | | *-hrSWRunParameters
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunParameters(
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

/*
| Return the Parameter string that was computed at cache-build time.
| NOTE: This string might be NULL.
*/
if (row->attrib_list[HRSR_PARAM].u.string_value == NULL) {
    outvalue->length = 0;
    }
else {
    outvalue->length = strlen(row->attrib_list[HRSR_PARAM].u.string_value);
    outvalue->string = row->attrib_list[HRSR_PARAM].u.string_value;
    if (outvalue->length > 128) {
        outvalue->length = 128;      /* Truncate */
        }
    }

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunParameters() */


/*
 *  GetHrSWRunType
 *    The type of this software.
 *
 *    Gets the value for HrSWRunType.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunType
 |
 |  ACCESS         SYNTAX
 |  read-only      INTEGER {unknown(1),operatingSystem(2),deviceDriver(3),
 |                           application(4)}
 |
 | "The type of this software."
 |
 | DISCUSSION:
 |
 | <POA-19> This information is not extracted by the sample PVIEW code from the
 | performance monitoring statistics kept in the Registry.  If this information
 | is available from the Registry or some other source, I need to acquire the
 | description of how to get it.
 |
 | >>>>>>>>
 | <POA-19>  I am not sure whether this information is included in the perfmon
 | data block. I will investigate further.
 | >>>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.6.<instance>
 |                | | | |
 |                | | | *-hrSWRunType
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunType(
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSR_TYPE].u.number_value;
return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunType() */


/*
 *  GetHrSWRunStatus
 *    The status of this running piece of software.  Setting this value to
 *    invalid(4) shall cause this software to stop running and be
 *
 *    Gets the value for HrSWRunStatus.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSWRunStatus
 |
 |  ACCESS         SYNTAX
 |  read-write     INTEGER {
 |                         running(1),
 |                         runnable(2), -- waiting for resource (CPU, memory, IO)
 |                         notRunnable(3), -- loaded but waiting for event
 |                         invalid(4)      -- not loaded
 |                         }
 |
 | "The status of this running piece of software.  Setting this value to
 | invalid(4) shall cause this software to stop running and to be unloaded."
 |
 | DISCUSSION:
 |
 | <POA-20> For an SNMP "GET" on this attribute, this information is not extracted
 | by the sample PVIEW code from the performance monitoring statistics kept in
 | the Registry.  If this information is available from the Registry or some
 | other source, I need to acquire the description of how to get it.
 |
 | RESOLVED >>>>>>>
 | <POA-20>  I think running and notRunnable will be all that are applicable
 | here (that latter being returned in situations which are currently labeled
 | "not responding").
 | RESOLVED >>>>>>>
 |
 |============================================================================
 | 1.3.6.1.2.1.25.4.2.1.7.<instance>
 |                | | | |
 |                | | | *-hrSWRunStatus
 |                | | *-hrSWRunEntry
 |                | *-hrSWRunTable
 |                *-hrSWRun
 */

UINT
GetHrSWRunStatus(
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
ULONG           index;          /* As fetched from instance structure     */
CACHEROW       *row;            /* Row entry fetched from cache           */


/*
| Grab the instance information
*/
index = GET_INSTANCE(0);

/*
| Use it to find the right entry in the cache
*/
if ((row = FindTableRow(index, &hrSWRunTable_cache)) == NULL) {
    return SNMP_ERRORSTATUS_GENERR;
    }

*outvalue = row->attrib_list[HRSR_STATUS].u.number_value;
return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSWRunStatus() */


/*
 *  SetHrSWRunStatus
 *    The status of this running piece of software.  Setting this value to
 *    invalid(4) shall cause this software to stop running and be
 *
 *    Sets the HrSWRunStatus value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrSWRunStatus(
        IN INThrSWRunStatus *invalue ,
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrSWRunStatus() */


/*
 *  HrSWRunEntryFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, if
    //  there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSWRUNENTRY_VAR_INDEX )
    // No instance was specified
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSWRUNENTRY_VAR_INDEX + 1 )
    // Instance length is more than 1
    return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
    // The only valid instance for a non-table are instance 0.  If this
    // is a non-table, the following code validates the instances.  If this
    // is a table, developer modification is necessary below.

    tmp_instance = FullOid->ids[ HRSWRUNENTRY_VAR_INDEX ] ;

        /*
        | Check for age-out and possibly refresh the entire cache for the
        | hrSWRun table before we check to see if the instance is there.
        */
        if (hrSWRunCache_Refresh() == FALSE) {
            return SNMP_ERRORSTATUS_GENERR;
            }

        /*
        | For hrSWRun, the instance arc(s) is a single arc, and it must
        | correctly select an entry in the hrSWRun Table cache.
        | Check that here.
        */
    if ( FindTableRow(tmp_instance, &hrSWRunTable_cache) == NULL ) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
            }
    else
    {
        // the instance is valid.  Create the instance portion of the OID
        // to be returned from this call.
        instance->ids[ 0 ] = tmp_instance ;
        instance->idLength = 1 ;
    }

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunEntryFindInstance() */



/*
 *  HrSWRunEntryFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSWRunEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    CACHEROW        *row;
    ULONG           tmp_instance;


    if ( FullOid->idLength <= HRSWRUNENTRY_VAR_INDEX )
    {
        /*
        | Too short: must return the instance arc that selects the first
        |            entry in the table if there is one.
        */
        tmp_instance = 0;
    }
    else {
        /*
        | There is at least one instance arc.  Even if it is the only arc
        | we use it as the "index" in a request for the "NEXT" one.
        */
        tmp_instance = FullOid->ids[ HRSWRUNENTRY_VAR_INDEX ] ;
        }

    /*
    | Check for age-out and possibly refresh the entire cache for the
    | hrSWRun table before we check to see if the instance is there.
    */
    if (hrSWRunCache_Refresh() == FALSE) {
        return SNMP_ERRORSTATUS_GENERR;
        }

    /* Now go off and try to find the next instance in the table */
    if ((row = FindNextTableRow(tmp_instance, &hrSWRunTable_cache)) == NULL) {
        return SNMP_ERRORSTATUS_NOSUCHNAME ;
        }

    instance->ids[ 0 ] = row->index ;
    instance->idLength = 1 ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSWRunEntryFindNextInstance() */



/*
 *  HrSWRunEntryConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSWRunEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
static char    *array;  /* The address of this (char *) is passed back     */
                        /* as though it were an array of length 1 of these */
                        /* types.                                          */

static ULONG    inst;   /* The address of this ULONG is passed back  */
                        /* (Obviously, no "free()" action is needed) */

    /* We only expect the one arc in "oid_spec" */
    inst = oid_spec->ids[0];
    array = (char *) &inst;

    native_spec->count = 1;
    native_spec->array = &array;
    return SUCCESS ;

} /* end of HrSWRunEntryConvertInstance() */




/*
 *  HrSWRunEntryFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSWRunEntryFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSWRunEntryFreeInstance() */

/*
| End of Generated Code
*/

/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table */
/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table */
/* Gen_HrSWRun_Cache - Generate a initial cache for HrSWRun(Perf) Table */

BOOL
Gen_HrSWRun_Cache(
                  void
                  )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrSWRun table,
|       "hrSWRunTable_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns TRUE indicating that the cache has been fully
|       populated with all "static" cache-able values.  This function populates
|       the hrSWRun Table cache, but this cache also includes the two
|       attributes for the hrSWRunPerf Table.  So in effect, one cache serves
|       two tables, but the hrSWRunPerf table is a "one-to-one" extension
|       of hrSWRun table.. that is a row in hrSWRun always has a corresponding
|       "two-entry" row in hrSWRunPerf.
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage").
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the start-up code in  "UserMibInit()" ("MIB.C")  to
|       populate the cache for the HrSWRun table (which also serves the
|       hrSWRunPerf Table).
|
|       It is also re-entered whenever a request for information from this
|       cache comes in and the cache is older than a certain age (symbol
|       "CACHE_MAX_AGE" defined at the beginning of this module).  In this
|       case the cache is rebuilt, and in this way this function is different
|       from all the other "Gen_*_Cache()" functions which only build their
|       caches once (in the initial release).
|
|
|  OTHER THINGS TO KNOW:
|
|       There is one of these function for every table that has a cache.
|       Each cachehead is found in the respective table's source file.
|
|       The strategy on getting running software enumerated revolves around
|       NtQuerySystemInformation(SystemProcessInformation...) invocation.
|
|       Once we have a list of processes, additional information (such as
|       the parameters on the command-line) are fetched by opening the
|       process (if possible) and reading process memory.
|
|       Note that unlike the other cache's in the initial release, this cache
|       for hrSWRun and hrSWRunPerf is updated before it is read if it is
|       older than a specified period of time (set by #define at the beginning
|       of this file).
|
|============================================================================
| 1.3.6.1.2.1.25.4.1.0
|                | |
|                | *-hrSWOSIndex
|                *-hrSWRun
|
| 1.3.6.1.2.1.25.4.2.1..
|                | | |
|                | | *-hrSWRunEntry
|                | *-hrSWRunTable
|                *-hrSWRun
*/
#define LARGE_BUFFER_SIZE       (4096*8)
#define INCREMENT_BUFFER_SIZE   (4096*2)
{                             
DWORD      ProcessBufSize = LARGE_BUFFER_SIZE; /* Initial ProcessBuffer size */
LPBYTE     pProcessBuffer = NULL;  /* Re-used and re-expanded as needed */

PSYSTEM_PROCESS_INFORMATION
           ProcessInfo;            /* --> Next process to process       */
ULONG      ProcessBufferOffset=0;  /* Accumulating offset cell          */
NTSTATUS   ntstatus;               /* Generic return status             */
DWORD      dwReturnedBufferSize;   /* From NtQuerySystemInformation()   */


/*
| Blow away any old copy of the cache
*/
DestroyTable( &hrSWRunTable_cache );


/*
| Grab an initial buffer for Process Information
*/
if ((pProcessBuffer = malloc ( ProcessBufSize )) == NULL) {
    return ( FALSE );
    }


/*
| Go for a (new/refreshed) buffer of current Process Info
*/
    while( (ntstatus = NtQuerySystemInformation(
                                            SystemProcessInformation,
                                            pProcessBuffer,
                                            ProcessBufSize,
                                            &dwReturnedBufferSize
                                            )
           ) == STATUS_INFO_LENGTH_MISMATCH ) 
    {

        LPBYTE  pNewProcessBuffer = NULL;   // For use on realloc

        /* expand buffer & retry */
        ProcessBufSize += INCREMENT_BUFFER_SIZE;

        if ( !(pNewProcessBuffer = realloc(pProcessBuffer,ProcessBufSize)) ) 
        {
            // If realloc failed and left us with the old buffer, free it
            if (pProcessBuffer != NULL) 
            {
                free(pProcessBuffer);
            }
            return (FALSE);                 // Out of memory
        }    
        else 
        {
            // Successful Realloc
            pProcessBuffer = pNewProcessBuffer;
        }
    }

/*
| Freshen the time on the cache
|
| Get the current system-time in 100ns intervals . . . */
ntstatus = NtQuerySystemTime (&cache_time);
if (ntstatus != STATUS_SUCCESS)
{
    free( pProcessBuffer );
    return ( FALSE );
}


/*
| Loop over each instance of Process Information in the ProcessBuffer
| and build a row in the cache for hrSWRun and hrSWRunPerf tables.
*/
for (ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;
     ;  /* Exit check below */
     ProcessBufferOffset += ProcessInfo->NextEntryOffset,
     ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset]
     ) {

    /* Add a Row to the cache */
    if (AddHrSWRunRow(ProcessInfo) != TRUE) {
        if (pProcessBuffer != NULL) {
            free(pProcessBuffer);
            }
        return ( FALSE );       // Out of memory
        }

    /* If this is the last process, bag it */
    if (ProcessInfo->NextEntryOffset == 0) {
        break;
        }
    }

#if defined(CACHE_DUMP)
PrintCache(&hrSWRunTable_cache);
#endif

if (pProcessBuffer != NULL) {
    free(pProcessBuffer);
    }

/* Cache (re)-build successful */
return ( TRUE );
}

/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table */
/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table */
/* AddHrSWRunRow - Generate another Row Entry in HrSWRun/Perf Table */

static BOOL
AddHrSWRunRow(

PSYSTEM_PROCESS_INFORMATION ProcessInfo   /* --> Next process to process */

              )

/*
|  EXPLICIT INPUTS:
|
|       "ProcessInfo" points to the next process (as described by a
|       SYSTEM_PROCESS_INFORMATION structure) for which a row is to be
|       inserted into the HrSWRun(Perf) table cache.
|
|  IMPLICIT INPUTS:
|
|       The module-local head of the cache for the HrDevice table,
|       "hrSWRunTable_cache".
|
|  OUTPUTS:
|
|     On Success:
|       Function creates a new row entry populated with all "static" cache-able
|       values for HrSWRun(Perf) table and returns TRUE.  Note that if the
|       process is the "System Process", the row entry index is stored in
|       module cell "SWOSIndex" for reference by code in "HRSWRUN.C".
|
|     On any Failure:
|       Function returns FALSE (indicating "not enough storage" or other
|       internal logic error).
|
|
|  THE BIG PICTURE:
|
|       At subagent startup time, the cache for each table in the MIB is
|       populated with rows for each row in the table.  This function is
|       invoked by the cache-build code in "Gen_HrSWRun_Cache()" above.
|
|  OTHER THINGS TO KNOW:
|
|    The cache being (re)built by this function serves two tables, hrSWRun
|    and hrSWRunPerf.
|
|    In general, we use the Process's "ProcessID" as the index in the
|    hrSWRun(Perf) table.  However special handling is done for the Idle
|    Process because it's Process ID is zero.   We convert it to "1" to meet
|    the SNMP requirement that indexes be greater than zero.  We note that
|    as of this writing, no process id of 1 is seen in build 1515 (the "System"
|    process has a processID of 2).
|
|    The "type" of software can be unknown(1), operatingSystem(2),
|    deviceDriver(3) and application(4).  We only detect the Idle and System
|    processes (by their names) as "operatingSystem(2)", everything else
|    is presumed "application(4)".
|
|    As for "status", it can be running(1), runnable(2), notRunnable(3) or
|    invalid(4).  If the number of threads is greater than 0, it is presumed
|    "running(1)", otherwise "invalid(4)".
*/
#define ANSI_PNAME_LEN 256
{
ANSI_STRING     pname;          /* ANSI version of UNICODE process name    */
CHAR            pbuf[ANSI_PNAME_LEN+1];    /* Buffer for "pname"           */
CHAR           *pname_str;      /* Pointer to our final process name       */
CHAR           *path_str=NULL;  /* Pointer to our Path name                */
CHAR           *params=NULL;    /* Pointer to any parameters fnd on cmdline*/
UINT            type;           /* SNMP code for type of software          */
UINT            status;         /* SNMP code for the status of software    */
CACHEROW        *row;           /* --> Cache structure for row-being built */
NTSTATUS        ntstatus;       /* Generic return status                   */

/*
| OK, the caller wants another row in the table, get a row-entry created.
*/
if ((row = CreateTableRow( HRSR_ATTRIB_COUNT ) ) == NULL) {
    return ( FALSE );       // Out of memory
    }

/*
| Set up the standard-hrSWRun(Perf) attributes in the new row
*/

type = 4;       /* Presume "application(4)" type software */

if (ProcessInfo->NumberOfThreads > 0) {
    status = 1;     /* Presume "running(1)" for software status */
    }
else {
    status = 4;     /* "invalid(4)", process on the way out */
    }

/* =========== HrSWRunIndex ==========*/
row->attrib_list[HRSR_INDEX].attrib_type = CA_NUMBER;
row->attrib_list[HRSR_INDEX].u.unumber_value =
                                   HandleToUlong(ProcessInfo->UniqueProcessId) ;

/* Special check for system idle process, roll it from 0 to 1 */
if (ProcessInfo->UniqueProcessId == 0) {
    row->attrib_list[HRSR_INDEX].u.unumber_value = 1;
    }



/* =========== HrSWRunName ==========*/
row->attrib_list[HRSR_NAME].attrib_type = CA_STRING;

/* If we actually have a process name for this process . . . */
if (ProcessInfo->ImageName.Buffer != NULL) {

    /* Prep the STRING structure */
    pname.Buffer = pbuf;
    pname.MaximumLength = ANSI_PNAME_LEN;

    /* Convert from Unicode */
    ntstatus = RtlUnicodeStringToAnsiString(&pname,               // Target string
                                 (PUNICODE_STRING)&ProcessInfo->ImageName,//Src
                                 FALSE);               // = Don't Allocate buf

    if (ntstatus != STATUS_SUCCESS)
    {
        DestroyTableRow(row);
        return ( FALSE );
    }
    /*
    | Here we parse not only the process name but any path that may be
    | prepended to it.  (We make no attempt to eliminate any ".EXE" that
    | may be on the end of the image name).
    |
    | NOTE: If you are going to rip off this code, be aware that as-of
    |       build 1515, we NEVER seem to get an image name that has the
    |       path prepended on the front... so most of this code to skip
    |       the possibly-present path is almost certainly superfluous.
    */

    /* Try to "backup" until we hit any "\" */
    if ( (pname_str = strrchr(pname.Buffer,'\\')) != NULL) {
        pname_str++;                     /* Pop to first char after "\" */
        }
    else {
        pname_str = pname.Buffer;        /* Use entire string, no "\" found */

        /*
        | A piece of software with no path means it could be the "System"
        | process.  Check for that here.
        */
        if (strcmp(pname_str, "System") == 0) {
            type = 2;   /* Mark the software as "operatingSystem(2)" type */

            /*
            | We're processing the main System Process, so record it's index
            | in module-level cell for reference from "HRSWRUN.C".
            */
            SWOSIndex = row->attrib_list[HRSR_INDEX].u.unumber_value;
            }
        }
    }
else {
    /* The system idle process has no name */
    pname_str = "System Idle Process";
    type = 2;             /* Mark the software as "operatingSystem(2)" type */
    }

/* Allocate cache storage and copy the process name to it */
if ( (row->attrib_list[HRSR_NAME].u.string_value
      = ( LPSTR ) malloc(strlen(pname_str) + 1)) == NULL) {
    DestroyTableRow(row);
    return ( FALSE );       /* out of memory */
    }
strcpy(row->attrib_list[HRSR_NAME].u.string_value, pname_str);

/*
| We bother to do the overhead of trying to extract path & parameters from
| the command-line that started the process by reading process memory
| only if the type of the software is "application(4)" and status is
| "running(1)".
*/
if (status == 1 && type == 4) {  /* If it is a runnable application . . . */

    FetchProcessParams(ProcessInfo, &path_str, &params);
    }


/* =========== HrSWRunPath ==========*/
row->attrib_list[HRSR_PATH].attrib_type = CA_STRING;
row->attrib_list[HRSR_PATH].u.string_value = NULL;

/* If we did detect a path . . . */
if (path_str != NULL) {

    /* Allocate cache storage and copy the path string to it */
    if ( (row->attrib_list[HRSR_PATH].u.string_value
          = ( LPSTR ) malloc(strlen(path_str) + 1)) == NULL) {
        DestroyTableRow(row);
        return ( FALSE );       /* out of memory */
        }
    strcpy(row->attrib_list[HRSR_PATH].u.string_value, path_str);
    }


/* =========== HrSWRunParameters ==========*/
row->attrib_list[HRSR_PARAM].attrib_type = CA_STRING;
row->attrib_list[HRSR_PARAM].u.string_value = NULL;    /* In case of none */

/* If we did find parameters . . . */
if (params != NULL) {

    /* Allocate cache storage and copy the parameter string to it */
    if ( (row->attrib_list[HRSR_PARAM].u.string_value
          = ( LPSTR ) malloc(strlen(params) + 1)) == NULL) {
        DestroyTableRow(row);
        return ( FALSE );       /* out of memory */
        }
    strcpy(row->attrib_list[HRSR_PARAM].u.string_value, params);
    }


/* =========== HrSWRunType ========== */
row->attrib_list[HRSR_TYPE].attrib_type = CA_NUMBER;
row->attrib_list[HRSR_TYPE].u.unumber_value = type;


/* =========== HrSWRunStatus ========== */
row->attrib_list[HRSR_STATUS].attrib_type = CA_NUMBER;
row->attrib_list[HRSR_STATUS].u.unumber_value = status;

/*
| For hrSWRunPerf Table:
*/

/* =========== HrSWRunPerfCPU ==========
| UserTime + KernelTime are in 100ns (1/10th of a millionth of a second)
| units and HrSWRunPerfCPU is supposed to be in 1/100th of a second units.
|
| So .01        - second intervals
| is .010 000 0 - 100nanoseconds intervals,
|
| so dividing 100ns intervals by 100,000 gives centi-seconds.
*/

row->attrib_list[HRSP_CPU].attrib_type = CA_NUMBER;
row->attrib_list[HRSP_CPU].u.unumber_value = (ULONG)
((ProcessInfo->UserTime.QuadPart + ProcessInfo->KernelTime.QuadPart) / 100000);


/* =========== HrSWRunPerfMem ========== */
row->attrib_list[HRSP_MEM].attrib_type = CA_NUMBER;
row->attrib_list[HRSP_MEM].u.unumber_value =
                                           (ULONG)(ProcessInfo->WorkingSetSize / 1024);


/*
| Now insert the filled-in CACHEROW structure into the
| cache-list for the hrSWRun(Perf) Table.
*/
if (AddTableRow(row->attrib_list[HRSR_INDEX].u.unumber_value,  /* Index */
                row,                                           /* Row   */
                &hrSWRunTable_cache                            /* Cache */
                ) == FALSE) {
    DestroyTableRow(row);
    return ( FALSE );       /* Internal Logic Error! */
    }

return ( TRUE );
}

/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */
/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */
/* hrSWRunCache_Refresh - hrSWRun(Perf) Cache Refresh-Check Routine */

BOOL
hrSWRunCache_Refresh(
                     void
                     )

/*
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       The "hrSWRunTable_cache" CACHEHEAD structure and the time when
|       it was last refreshed in module-local cell "cache_time".
|
|  OUTPUTS:
|
|     On Success/Failure:
|       The function returns TRUE.  Only if the cache-time has aged-out
|       is the cache actually rebuilt.
|
|     On any Failure:
|       If during a rebuild there is an error, this function returns FALSE.
|       The state of the cache is indeterminate.
|
|  THE BIG PICTURE:
|
|       This function is invoked before any reference is made to any SNMP
|       variable in the hrSWRun or hrSWRunPerf table.  It checks to see
|       if the cache needs to be rebuilt based on the last time it was built.
|
|       The calls to this function are strategically located in the
|       "FindInstance" and "FindNextInstance" functions in "HRSWRUNE.C"
|       (this module) and "HRSWPREN.C" (for the RunPerf table) as well
|       as in "HRSWRUN.C" for the stand-alone attribute "hrSWOSIndex".
|
|  OTHER THINGS TO KNOW:
|
*/
{
LARGE_INTEGER   now_time;       /* Current System time in 100 ns ticks */


/* Get the current time in 100 ns ticks*/
if (NtQuerySystemTime (&now_time) != STATUS_SUCCESS )
    return FALSE;

/* If the cache is older than the maximum allowed time (in ticks) . . .  */
if ( (now_time.QuadPart - cache_time.QuadPart) > (CACHE_MAX_AGE * 10000000) ){
    return ( Gen_HrSWRun_Cache() );
    }

return ( TRUE );        /* No Error (because no refresh) */
}

/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */
/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */
/* FetchProcessParams - Fetch Path & Parameter String from Process Cmd line */

void
FetchProcessParams(

PSYSTEM_PROCESS_INFORMATION ProcessInfo,    /* Process for parameters     */
CHAR                      **path_str,       /* Returned PATH string       */
CHAR                      **params_str      /* Returned Parameters string */
              )
/*
|  EXPLICIT INPUTS:
|
|       "ProcessInfo" points to the process (as described by a
|       SYSTEM_PROCESS_INFORMATION structure) for which the path & parameters
|       (from the command-line) are desired.
|
|       "path_str" is the address of a pointer to be set to any "path" string.
|       "params" is the address of a pointer to be set to any "parameters"
|        string.
|
|  IMPLICIT INPUTS:
|
|       None.
|
|  OUTPUTS:
|
|     On Success:
|       Function returns pointers to a static buffer containing the
|       path & parameters section of the command line.  There may be nothing
|       in the buffer (ie just the null-termination).
|
|     On any Failure:
|       Function returns NULLS indicating a problem was encountered
|       attempting to obtain the command-line image from which the
|       path & parameter portion is to be extracted, or indicating that
|       one or both were not present.
|
|  THE BIG PICTURE:
|
|       Called from "AddHrSWRunRow()" above, this is a helper function
|       that serves to isolate the code lifted from "TLIST" from
|       the rest of the subagent.
|
|  OTHER THINGS TO KNOW:
|
|    The black magic here was lifted from sections of "TLIST".
*/
{
HANDLE                      hProcess;
PEB                         Peb;
NTSTATUS                    Status;
PROCESS_BASIC_INFORMATION   BasicInfo;
WCHAR                       szT[(MAX_PATH * 2)+1];
UNICODE_STRING              u_param;
RTL_USER_PROCESS_PARAMETERS ProcessParameters;

#define ANSI_PARAM_LEN (MAX_PATH * 2)
ANSI_STRING     param;          /* ANSI version of UNICODE command line    */
static
CHAR            pbuf[ANSI_PARAM_LEN+1];    /* Buffer for "parameters"      */
CHAR           *param_str;      /* Pointer to our final parameter string   */
SIZE_T          dwbytesret;     /* Count of bytes read from process memory */


pbuf[ANSI_PARAM_LEN] = 0;
szT[MAX_PATH * 2] = 0;

/* Presume failure/nothing obtained */
*path_str = NULL;
*params_str = NULL;

/* get a handle to the process */
hProcess = OpenProcess(PROCESS_VM_READ|PROCESS_QUERY_INFORMATION,
                       FALSE,
                       HandleToUlong(ProcessInfo->UniqueProcessId));
if (!hProcess) {
    return;
    }


Status = NtQueryInformationProcess(hProcess, ProcessBasicInformation,
    &BasicInfo, sizeof(BasicInfo), NULL);
if (!NT_SUCCESS(Status)) {
    CloseHandle(hProcess);
    return;
    }


// get the PEB
if (ReadProcessMemory(hProcess, BasicInfo.PebBaseAddress, &Peb,
    sizeof(PEB), NULL)) {

    // get the processparameters
    if (ReadProcessMemory(hProcess, Peb.ProcessParameters,
        &ProcessParameters, sizeof(ProcessParameters), NULL)) {

        // get cmdline
        if (ReadProcessMemory(hProcess,
                              ProcessParameters.CommandLine.Buffer,
                              szT,
                              sizeof(szT)-2, // minus the last 2 bytes
                              &dwbytesret
                              )
            ) {

            CHAR        *scanner;       /* Used for parsing the command-line */

            /* Prep the STRING structure */
            param.Buffer = pbuf;
            param.MaximumLength = ANSI_PARAM_LEN;
            u_param.Length = (USHORT) ((wcslen(szT) + 1) * 2); // bytes incl. NULL
            u_param.Buffer = szT;
            
            /* Convert from Unicode */
            Status = RtlUnicodeStringToAnsiString(&param, // Target string
                                         &u_param,  /* Src                  */
                                         FALSE);    /* = Don't Allocate buf */

            if (Status != STATUS_SUCCESS)
            {
                CloseHandle(hProcess);
                return;
            }


            // Firstly, we need to check for command line of the form:
            // "c:\program files\blah\blah" -parameter1 -parameter2
            // "C:\Program Files\Internet Explorer\IEXPLORE.EXE"
            // but not:
            // C:\WINDOWS\system32\mmc.exe "C:\WINDOWS\system32\tsmmc.msc" /s
            if ( pbuf[0] == '\"')
                 
            {       
                // get first '\"', see if there is another one
                
                if ((scanner = strchr(pbuf+1, '\"')) != NULL) 
                {
                    // found the 2nd terminating '\"'
                    *params_str = (scanner + 1);
                    *scanner = 0; // Terminate the base string
                    // Path
                    if ((scanner = strrchr(pbuf, '\\')) != NULL) 
                    {
                        // Terminate the path
                        *(scanner+1) = 0;

                        // Return start of buffer as path
                        *path_str = pbuf+1;
                    }
                    else 
                    {
                        // No path
                        *path_str = NULL;
                    }
                }
            }
            else 
            /*
            | OK, we can have the following situations:
            |
            | 1)   "\system\system32\smss.exe -parameter1 -parameter2"
            |       --------path-----         -------parameters------
            |
            | 2)   "\system\system32\smss.exe"
            |       --------path-----
            |
            | 3)   "smss.exe -parameter1 -parameter2"
            |                -------parameters------
            |
            | and we want to handle this by returning "path" and "parameter"
            | as shown, where:
            |
            | 1) both path and parameters are present
            | 2) only path is present
            | 3) only parameters are present
            |
            | We do this:
            |
            |  - Scan forward for a blank.
            |    If we get one:
            |           + return the address following it as "parameters"
            |           + set the blank to a null byte (cutting off parameters)
            |    If not:
            |           + return NULL as "parameters"
            |
            |    ----Parameters are done.
            |
            |  - Perform a reverse search for "\" on whatever is now in the
            |    buffer
            |    If we find a "\":
            |           + Step forward one character and turn it into a null
            |             byte (turning buffer into string containing path).
            |           + Return the buffer address as "path"
            |    If not:
            |           + return NULL as "path"
            */
            /* Parameter */
            {
                if ((scanner = strchr(pbuf, ' ')) != NULL) {

                    /* Return address of char after blank as start of parameters */
                    *params_str = (scanner + 1);
                    *scanner = '\0';             /* Terminate base string */
                }
                else {
                    /* No parameters */
                    *params_str = NULL;
                }

                /* Path */
                if ((scanner = strrchr(pbuf, '\\')) != NULL) {
                    /* Terminate the path */
                    *(scanner+1) = '\0';

                    /* Return start of buffer as path */
                    *path_str = pbuf;
                }
                else {
                    /* No path */
                    *path_str = NULL;
                }
            }

            CloseHandle(hProcess);

            /* Return address of static ANSI string buffer */
            return;
            }
        }
    }

CloseHandle(hProcess);

/* Nothing back */
return;
}

#if defined(CACHE_DUMP)

/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */
/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */
/* debug_print_hrswrun - Prints a Row from HrSWRun(Perf) Table */

static void
debug_print_hrswrun(
                    CACHEROW     *row  /* Row in hrSWRun(Perf) table */
                    )
/*
|  EXPLICIT INPUTS:
|
|       "row" - points to the row to be dumped, if NULL, the function
|       merely prints a suitable title.
|
|  IMPLICIT INPUTS:
|
|       - Symbols used to reference the attributes in the row entry.
|       - File handle defined by OFILE, presumed to be open.
|
|  OUTPUTS:
|
|     On Success:
|       Function prints a dump of the row in ASCII for debugging purposes
|       on file handle OFILE.
|
|  THE BIG PICTURE:
|
|     Debugging only.
|
|  OTHER THINGS TO KNOW:
*/
{

if (row == NULL) {
    fprintf(OFILE, "=================================\n");
    fprintf(OFILE, "hrSWRun & hrSWRunPerf Table Cache\n");
    fprintf(OFILE, "=================================\n");
    return;
    }


fprintf(OFILE, "HrSWRunIndex . . . . . . %d\n",
        row->attrib_list[HRSR_INDEX].u.unumber_value);

fprintf(OFILE, "HrSWRunName. . . . . . . \"%s\"\n",
        row->attrib_list[HRSR_NAME].u.string_value);

fprintf(OFILE, "HrSWRunPath. . . . . . . \"%s\"\n",
        row->attrib_list[HRSR_PATH].u.string_value);

fprintf(OFILE, "HRSWRunParameters. . . . \"%s\"\n",
        row->attrib_list[HRSR_PARAM].u.string_value);

fprintf(OFILE, "HrSWRunType. . . . . . . %d ",
        row->attrib_list[HRSR_TYPE].u.unumber_value);

switch (row->attrib_list[HRSR_TYPE].u.unumber_value) {
    case 1: fprintf(OFILE, "(unknown)\n");        break;
    case 2: fprintf(OFILE, "(operatingSystem)\n");        break;
    case 3: fprintf(OFILE, "(deviceDriver)\n");        break;
    case 4: fprintf(OFILE, "(application)\n");        break;
    default:
            fprintf(OFILE, "(???)\n");
    }

fprintf(OFILE, "HrSWRunStatus. . . . . . %d ",
        row->attrib_list[HRSR_STATUS].u.unumber_value);

switch (row->attrib_list[HRSR_STATUS].u.unumber_value) {
    case 1: fprintf(OFILE, "(running)\n");        break;
    case 2: fprintf(OFILE, "(runnable)\n");        break;
    case 3: fprintf(OFILE, "(notRunnable)\n");        break;
    case 4: fprintf(OFILE, "(invalid)\n");        break;
    default:
            fprintf(OFILE, "(???)\n");
    }

fprintf(OFILE, "HrSWRunPerfCpu . . . . . %d (Centi-seconds)\n",
        row->attrib_list[HRSP_CPU].u.unumber_value);

fprintf(OFILE, "HrSWRunPerfMem . . . . . %d (Kbytes)\n",
        row->attrib_list[HRSP_MEM].u.unumber_value);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\hrsystem.c ===
/*
 *  HrSystem.c v0.10
 *  Generated in conjunction with Management Factory scripts: 
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the code for dealing with the get, set, and
 *    instance name routines for the HrSystem.  Actual instrumentation code is
 *    supplied by the developer.
 *
 *  Functions:
 *
 *    A get and set routine for each attribute in the class.
 *
 *    The routines for instances within the class.
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc
 *
 *  Revision History:
 *
 *    V1.00 - 04/17/97  D. D. Burns     Genned: Thu Nov 07 16:39:21 1996
 *
 *
 */


#include <windows.h>
#include <malloc.h>

#include <snmp.h>

#include <lmcons.h>       /* for NET_API_STATUS    */
#include <lmwksta.h>      /* For NetWkStaGetInfo() */
#include <lmapibuf.h>     /* For NetApiBufferFree()*/
#include <lmerr.h>        /* For NERR_Success      */
#include <winsock.h>      /* For htons()           */

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"
#include "user.h"         /* Developer supplied include file */
#include "HMCACHE.H"      /* For "hrSystemInitialLoadDevice" */


/*
 *  GetHrSystemUptime
 *    The amount of time since this host was last initialized.
 *    
 *    Gets the value for HrSystemUptime.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemUptime
 | 
 |  ACCESS         SYNTAX
 |  read-only      TimeTicks
 | 
 | "The amount of time since this host was last initialized.  Note that this is
 | different from sysUpTime in MIB-II [3] because sysUpTime is the uptime of 
 | the network management portion of the system."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "GetTickCount" is used to obtain the value returned for a
 | GET on this variable.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.1.1.0
 |                | |
 |                | *-hrSystemUptime
 |                *---hrSystem
 */

UINT
GetHrSystemUptime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

*outvalue = GetTickCount();

return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemUptime() */


/*
 *  GetHrSystemDate
 *    The host's notion of the local date and time of day.
 *    
 *    Gets the value for HrSystemDate.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemDate
 | 
 |  ACCESS         SYNTAX
 |  read-write     DateAndTime
 | 
 | "The host's notion of the local date and time of day."
 | 
 | DISCUSSION:
 | 
 | Win32 API function "GetLocalTime" is used to obtain the value returned for a
 | GET on this variable.
 | 
 | Since this variable is "read-write", this implies that the system time can
 | be set by a SET request.  This is done with a Win32 API function
 | "SetLocalTime".
 | 
 | <POA-1> Issuing "SetLocalTime" requires that the issuing process have the
 | "SE_SYSTEMTIME_NAME" privilege which is not the default.  Are there any
 | security concerns about issuing the necessary Win32 API function call
 | "AdjustTokenPrivileges" from inside the SNMP agent to enable setting of
 | the system time?  Any other problems?
 | 
 | RESOLVED >>>>>>>
 | <POA-1> Let's leave this read-only.
 | RESOLVED >>>>>>>
 |
 |========================== From RFC1514 ====================================
 |
 |    DateAndTime ::= OCTET STRING (SIZE (8 | 11))
 |    --        A date-time specification for the local time of day.
 |    --        This data type is intended to provide a consistent
 |    --        method of reporting date information.
 |    --
 |    --            field  octets  contents                  range
 |    --            _____  ______  ________                  _____
 |    --              1      1-2   year                      0..65536
 |    --                           (in network byte order)
 |    --              2       3    month                     1..12
 |    --              3       4    day                       1..31
 |    --              4       5    hour                      0..23
 |    --              5       6    minutes                   0..59
 |    --              6       7    seconds                   0..60
 |    --                           (use 60 for leap-second)
 |    --              7       8    deci-seconds              0..9
 |    --              8       9    direction from UTC        "+" / "-"
 |    --                           (in ascii notation)
 |    --              9      10    hours from UTC            0..11
 |    --             10      11    minutes from UTC          0..59
 |    --
 |    --            Note that if only local time is known, then
 |    --            timezone information (fields 8-10) is not present.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.1.2.0
 |                | |
 |                | *-hrSystemDate
 |                *---hrSystem
 */

UINT
GetHrSystemDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
SYSTEMTIME      localtime;             // Where we retrieve current local time
USHORT          year_networkbyteorder; // Network byte order of year
static
char            octet_time[8];         // OCTET STRING format of "time"

    GetLocalTime(&localtime);

    year_net