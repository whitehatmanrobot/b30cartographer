 %08lX\n", pWinsDataDataDefinition ));
        WINSD_PRINT(( "pCounterBlock       = %08lX\n", pCounterBlock ));
        WINSD_PRINT(( "ByteLength          = %08lX\n", pCounterBlock->PerfCounterBlock.ByteLength ));
        WINSD_PRINT(( "pliCounter          = %08lX\n", pdwCounter ));
    }

    //
    //  Move the DWORDs into the buffer.
    //
    IF_DEBUG( COLLECT )
    {
        WINSD_PRINT(( "pdwCounter          = %08lX\n", pdwCounter ));
    }

    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfUniqueReg;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfGroupReg;
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfUniqueReg +
			pWinsStats->Counters.NoOfGroupReg);

    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfUniqueRef;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfGroupRef;
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfUniqueRef +
				pWinsStats->Counters.NoOfGroupRef);
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfSuccRel +
			     pWinsStats->Counters.NoOfFailRel);
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfSuccQueries +
			    pWinsStats->Counters.NoOfFailQueries);
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfUniqueCnf;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfGroupCnf;
    *pdwCounter++ = (DWORD)(pWinsStats->Counters.NoOfUniqueCnf +
				pWinsStats->Counters.NoOfGroupCnf);
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfSuccRel;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfFailRel;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfSuccQueries;
    *pdwCounter++ = (DWORD)pWinsStats->Counters.NoOfFailQueries;

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)pdwCounter;
    *lpNumObjectTypes = 1;
    *lpcbTotalBytes   = (DWORD)((BYTE *)pdwCounter - (BYTE *)pWinsDataDataDefinition);

    IF_DEBUG( COLLECT )
    {
        WINSD_PRINT(( "pData               = %08lX\n", *lppData ));
        WINSD_PRINT(( "NumObjectTypes      = %08lX\n", *lpNumObjectTypes ));
        WINSD_PRINT(( "cbTotalBytes        = %08lX\n", *lpcbTotalBytes ));
    }

    //
    //  Free the API buffer.
    //
#if 0
    NetApiBufferFree( (LPBYTE)pWinsStats );
#endif

    //
    //  Free the buffers RPC allocates.
    //

    WinsFreeMem( Results.pAddVersMaps );
    WinsFreeMem( Results.WinsStat.pRplPnrs );

    //
    //  Success!  Honest!!
    //

    return NO_ERROR;

}   // CollectWinsPerformanceData

/*******************************************************************

    NAME:       CloseWinsPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseWinsPerformanceData( VOID )
{
    IF_DEBUG( ENTRYPOINTS )
    {
        WINSD_PRINT(( "in CloseWinsPerformanceData\n" ));
    }

    //
    //  No real cleanup to do here.
    //

    cOpens--;


    if (!cOpens)
    {
      //
      // unbind from the nameserver. There could be synch. problems since
      // sfLogOpen is changed in both Open and Close functions. This at the
      // max. will affect logging. It being unclear at this point whether or
      // not Open gets called multiple times (from all looks of it, it is only
      // called once), this flag may even not be necessary.
      //
      MonCloseEventLog();
      sfLogOpen = FALSE;
    }
    return NO_ERROR;

}   // CloseWinsPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
        common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//
#include "debug.h"
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "winsctrs.h"     // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "winsevnt.h"
//
// Global data definitions.
//

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string
HANDLE hEventLog;
DWORD dwLogUsers;

#define  WINSCTRS_LOG_KEY                \
  TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\WinsCtrs")
HKEY  LogRoot;

#define  WINS_LOG_FILE_NAME TEXT("%SystemRoot%\\System32\\winsevnt.dll")
#define  WINS_MSGFILE_SKEY  TEXT("EventMessageFile")

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

TCHAR    WinsMsgFileSKey[]      = WINS_MSGFILE_SKEY;

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    Returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelValueName[] = TEXT("EventLogLevel");

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;
   
    // if global value of the logging level not initialized or is disabled, 
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               WINSCTRS_LOG_KEY,
                               0,                         
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,           
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }
       
    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog == NULL) {
            REPORT_ERROR (WINS_EVT_LOG_OPEN_ERR, LOG_USER);
         }
         
    }
    
    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller
      
Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog) {
        if (dwLogUsers)
            dwLogUsers--;
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (WINS_EVT_LOG_CLOSE, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
            hEventLog = 0;
        }
    }
}


LONG
AddSrcToReg(
 VOID
 )

/*++

Routine Description:
        This function open (or creates) a log file for registering events
        
Arguments:
        None

Externals Used:
        None        

        
Return Value:


Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

   LONG            RetVal = ERROR_SUCCESS;

   DWORD    NewKeyInd;
   TCHAR    Buff[160];
   DWORD    dwData;

   RetVal =  RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value 
                WINSCTRS_LOG_KEY,                //subkey for WINS        
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &LogRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg) -- not 
                                        //looked at 
                );


   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }
        

   /*
        Set the event id message file name
   */
   lstrcpy(Buff, WINS_LOG_FILE_NAME);
  
   /*
       Add the Event-ID message-file name to the subkey
   */
   RetVal = RegSetValueEx(
                        LogRoot,            //key handle
                        WinsMsgFileSKey,   //value name
                        0,                    //must be zero
                        REG_EXPAND_SZ,            //value type
                        (LPBYTE)Buff,
                        (lstrlen(Buff) + 1) * sizeof(TCHAR)   //length of value data
                         );

   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }

   /*
     Set the supported data types flags
   */
   dwData = EVENTLOG_ERROR_TYPE       | 
            EVENTLOG_WARNING_TYPE     | 
            EVENTLOG_INFORMATION_TYPE;
   
 
   RetVal = RegSetValueEx (
                        LogRoot,            //subkey handle
                        TEXT("TypesSupported"),  //value name
                        0,                    //must be zero
                        REG_DWORD,            //value type
                        (LPBYTE)&dwData,    //Address of value data
                        sizeof(DWORD)            //length of value data
                          );
 
   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }
                         
   /*
    * Done with the key.  Close it
   */
   RetVal = RegCloseKey(LogRoot);

   if (RetVal != ERROR_SUCCESS)
   {
        return(RetVal);
   }

   return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\winsctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    winsctrs.h

    Offset definitions for the WINS Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    WinsOpenPerformanceData procedure, they will be added to the
    WINS Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the WINSCTRS.DLL DLL code as well as the
    WINSCTRS.INI definition file.  WINSCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        PradeepB     20-July-1993 Created.

*/


#ifndef _WINSCTRS_H_
#define _WINSCTRS_H_


//
// The range given by Hon-Wah Chan (2/22/94) is the following 
//
#define WINSCTRS_FIRST_COUNTER	920
#define WINSCTRS_FIRST_HELP	921
#define WINSCTRS_LAST_COUNTER	950
#define WINSCTRS_LAST_HELP	951



//
//  The WINS Server counter object.
//

#define WINSCTRS_COUNTER_OBJECT           0


//
//  The individual counters.
//

#define WINSCTRS_UNIQUE_REGISTRATIONS     2
#define WINSCTRS_GROUP_REGISTRATIONS      4
#define WINSCTRS_TOTAL_REGISTRATIONS      6
#define WINSCTRS_UNIQUE_REFRESHES         8
#define WINSCTRS_GROUP_REFRESHES         10
#define WINSCTRS_TOTAL_REFRESHES         12
#define WINSCTRS_RELEASES                14
#define WINSCTRS_QUERIES                 16
#define WINSCTRS_UNIQUE_CONFLICTS        18
#define WINSCTRS_GROUP_CONFLICTS         20
#define WINSCTRS_TOTAL_CONFLICTS         22
#define WINSCTRS_SUCC_RELEASES           24 
#define WINSCTRS_FAIL_RELEASES           26
#define WINSCTRS_SUCC_QUERIES            28 
#define WINSCTRS_FAIL_QUERIES            30 


#endif  // _WINSCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\rpc\makefile.inc ===
$(O)\winscl.res: winscl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\winsdata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    winsdata.c

    Constant data structures for the FTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#include "debug.h"
#include <windows.h>
#include <winperf.h>
#include "winsctrs.h"
#include "winsdata.h"


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

WINSDATA_DATA_DEFINITION WinsDataDataDefinition =
{
    {   // WinsDataObjectType
        sizeof(WINSDATA_DATA_DEFINITION) + WINSDATA_SIZE_OF_PERFORMANCE_DATA,
        sizeof(WINSDATA_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        WINSCTRS_COUNTER_OBJECT,
        0,
        WINSCTRS_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_WINSDATA_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // UniqueReg 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_UNIQUE_REGISTRATIONS,
        0,
        WINSCTRS_UNIQUE_REGISTRATIONS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_UNIQUE_REGISTRATIONS_OFFSET,
    },

    {   // GroupReg 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_GROUP_REGISTRATIONS,
        0,
        WINSCTRS_GROUP_REGISTRATIONS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_GROUP_REGISTRATIONS_OFFSET,
    },

    {   // TotalReg 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_TOTAL_REGISTRATIONS,
        0,
        WINSCTRS_TOTAL_REGISTRATIONS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_TOTAL_REGISTRATIONS_OFFSET,
    },

    {   // UniqueRef 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_UNIQUE_REFRESHES,
        0,
        WINSCTRS_UNIQUE_REFRESHES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_UNIQUE_REFRESHES_OFFSET,
    },

    {   // GroupRef 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_GROUP_REFRESHES,
        0,
        WINSCTRS_GROUP_REFRESHES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_GROUP_REFRESHES_OFFSET,
    },

    {   // TotalRef 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_TOTAL_REFRESHES,
        0,
        WINSCTRS_TOTAL_REFRESHES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_TOTAL_REFRESHES_OFFSET,
    },

    {   // Releases 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_RELEASES,
        0,
        WINSCTRS_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_RELEASES_OFFSET,
    },

    {   // Queries 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_QUERIES,
        0,
        WINSCTRS_QUERIES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_QUERIES_OFFSET,
    },

    {   // UniqueCnf 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_UNIQUE_CONFLICTS,
        0,
        WINSCTRS_UNIQUE_CONFLICTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_UNIQUE_CONFLICTS_OFFSET,
    },

    {   // GroupCnf 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_GROUP_CONFLICTS,
        0,
        WINSCTRS_GROUP_CONFLICTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_GROUP_CONFLICTS_OFFSET,
    },

    {   // TotalCnf 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_TOTAL_CONFLICTS,
        0,
        WINSCTRS_TOTAL_CONFLICTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_TOTAL_CONFLICTS_OFFSET
    },

    {   // Sucessful releases 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_SUCC_RELEASES,
        0,
        WINSCTRS_SUCC_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_SUCC_RELEASES_OFFSET
    },

    {   // Failed releases 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_FAIL_RELEASES,
        0,
        WINSCTRS_FAIL_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_FAIL_RELEASES_OFFSET
    },

    {   // Sucessful queries 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_SUCC_QUERIES,
        0,
        WINSCTRS_SUCC_QUERIES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_SUCC_QUERIES_OFFSET
    },

    {   // Failed queries 
        sizeof(PERF_COUNTER_DEFINITION),
        WINSCTRS_FAIL_QUERIES,
        0,
        WINSCTRS_FAIL_QUERIES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WINSDATA_FAIL_QUERIES_OFFSET
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\winsdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpdata.h

    Extensible object definitions for the WINS Server's counter
    objects & counters.


    FILE HISTORY:
        Pradeepb     20-July-1993 Created.

*/


#ifndef _WINSDATA_H_
#define _WINSDATA_H_


//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any LARGE_INTEGERs that immediately
//  follow will not be aligned properly.
//
// In our case, the counters that follow are of type DWORD, so we do not 
// need to pad.  The total number of bytes in the buffer returned to perflib 
// *has* to be a multiple of 8 otherwise perflib is going to log an 
// event in the application log indicating that the dll needs to be fixed.  
// Perflib requires buffer data returned to be 8 byte aligned because it
// concatenates the data from multiple dlls.  *Ideally, perflib should be 
// doing the padding before concatenating*. Since WINS
// has an odd number of counters (there are 15 counters) and
// PerfCounterBlock is DWORD, we should not pad the WINS_DATA_COUNTER_BLOCK.
// if we do, the length will become 732 and so it will not be a multiple of
// 8
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//
typedef struct _WINSDATA_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
//    DWORD       DummyEntryForAlignmentPurposesOnly;

} WINSDATA_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//

#define WINSDATA_UNIQUE_REGISTRATIONS_OFFSET     sizeof(WINSDATA_COUNTER_BLOCK)

#define WINSDATA_GROUP_REGISTRATIONS_OFFSET    \
	(WINSDATA_UNIQUE_REGISTRATIONS_OFFSET + sizeof(DWORD))

#define WINSDATA_TOTAL_REGISTRATIONS_OFFSET    \
	(WINSDATA_GROUP_REGISTRATIONS_OFFSET +   sizeof(DWORD))

#define WINSDATA_UNIQUE_REFRESHES_OFFSET       \
	(WINSDATA_TOTAL_REGISTRATIONS_OFFSET + sizeof(DWORD))

#define WINSDATA_GROUP_REFRESHES_OFFSET        \
	(WINSDATA_UNIQUE_REFRESHES_OFFSET + sizeof(DWORD))

#define WINSDATA_TOTAL_REFRESHES_OFFSET        \
	(WINSDATA_GROUP_REFRESHES_OFFSET +   sizeof(DWORD))

#define WINSDATA_RELEASES_OFFSET     		\
	(WINSDATA_TOTAL_REFRESHES_OFFSET + sizeof(DWORD))

#define WINSDATA_QUERIES_OFFSET     		\
	(WINSDATA_RELEASES_OFFSET + sizeof(DWORD))

#define WINSDATA_UNIQUE_CONFLICTS_OFFSET       \
	(WINSDATA_QUERIES_OFFSET + sizeof(DWORD))

#define WINSDATA_GROUP_CONFLICTS_OFFSET        \
	(WINSDATA_UNIQUE_CONFLICTS_OFFSET + sizeof(DWORD))

#define WINSDATA_TOTAL_CONFLICTS_OFFSET        \
	(WINSDATA_GROUP_CONFLICTS_OFFSET +   sizeof(DWORD))

#define WINSDATA_SUCC_RELEASES_OFFSET     		\
	(WINSDATA_TOTAL_CONFLICTS_OFFSET + sizeof(DWORD))

#define WINSDATA_FAIL_RELEASES_OFFSET     		\
	(WINSDATA_SUCC_RELEASES_OFFSET + sizeof(DWORD))

#define WINSDATA_SUCC_QUERIES_OFFSET     		\
	(WINSDATA_FAIL_RELEASES_OFFSET + sizeof(DWORD))

#define WINSDATA_FAIL_QUERIES_OFFSET     		\
	(WINSDATA_SUCC_QUERIES_OFFSET + sizeof(DWORD))

#define WINSDATA_SIZE_OF_PERFORMANCE_DATA 	\
	(WINSDATA_FAIL_QUERIES_OFFSET +   sizeof(DWORD))

//
//  The counter structure returned.
//
//
// If the number of counters is odd, do not use DWORD alignment in
// WINSDATA_COUNTER_BLOCK, otherwise, use it.  See comment near the 
// definition of the above structure to get more info. 
//

typedef struct _WINSDATA_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            ObjectType;
    PERF_COUNTER_DEFINITION     UniqueReg;
    PERF_COUNTER_DEFINITION     GroupReg;
    PERF_COUNTER_DEFINITION     TotalReg;
    PERF_COUNTER_DEFINITION     UniqueRef;
    PERF_COUNTER_DEFINITION     GroupRef;
    PERF_COUNTER_DEFINITION     TotalRef;
    PERF_COUNTER_DEFINITION     Releases;
    PERF_COUNTER_DEFINITION     Queries;
    PERF_COUNTER_DEFINITION     UniqueCnf;
    PERF_COUNTER_DEFINITION     GroupCnf;
    PERF_COUNTER_DEFINITION     TotalCnf;
    PERF_COUNTER_DEFINITION     SuccReleases;
    PERF_COUNTER_DEFINITION     FailReleases;
    PERF_COUNTER_DEFINITION     SuccQueries;
    PERF_COUNTER_DEFINITION     FailQueries;
} WINSDATA_DATA_DEFINITION;


extern  WINSDATA_DATA_DEFINITION    WinsDataDataDefinition;


#define NUMBER_OF_WINSDATA_COUNTERS ((sizeof(WINSDATA_DATA_DEFINITION) -      \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


#define WINSDATA_PERFORMANCE_KEY	\
	TEXT("System\\CurrentControlSet\\Services\\Wins\\Performance")
//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _WINSDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\rpc\rpcbind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dhcbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the
    WINS server service.

Author:

    Pradeep Bahl (pradeepb) April-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "wins.h"
#include "winsif.h"

handle_t
WinsCommonBind(
    PWINSINTF_BIND_DATA_T pBindData
    )

/*++

Routine Description:

    This routine is called from the WINS server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS rpcStatus;
    LPTSTR binding;
    LPTSTR pProtSeq;
    LPTSTR pOptions = (TCHAR *)NULL;
    LPTSTR pServerAdd = (LPTSTR)pBindData->pServerAdd;
    handle_t bhandle;

    if (pBindData->fTcpIp)
    {
        if (lstrcmp((LPCTSTR)pBindData->pServerAdd, TEXT("127.0.0.1")) == 0)
        {
                pProtSeq   = TEXT("ncalrpc");
                pOptions   = TEXT("Security=Impersonation Dynamic False");
                pServerAdd = (TCHAR *)NULL;
        }
        else
        {
                pProtSeq   = TEXT("ncacn_ip_tcp");
                pServerAdd = (LPTSTR)pBindData->pServerAdd;
        }
        pBindData->pPipeName  = NULL;
    }
    else
    {
         pProtSeq = TEXT("ncacn_np");
    }

    //
    // Enter the critical section.  This will be freed  WINSIF_HANDLE_unbind().
    //
    //EnterCriticalSection(&WinsRpcCrtSec);
    rpcStatus = RpcStringBindingCompose(
                    0,
                    pProtSeq,
                    pServerAdd,
                    pBindData->fTcpIp ? TEXT("") : (LPWSTR)pBindData->pPipeName,
                    pOptions,
                    &binding);

    if ( rpcStatus != RPC_S_OK )
    {
        return( NULL );
    }

    rpcStatus = RpcBindingFromStringBinding( binding, &bhandle );
    RpcStringFree(&binding);

    if ( rpcStatus != RPC_S_OK )
    {
        return( NULL );
    }
#if SECURITY > 0
    rpcStatus = RpcBindingSetAuthInfo(
			bhandle,
			WINS_SERVER,
			RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_AUTHN_WINNT,
			NULL,
			RPC_C_AUTHZ_NAME
				     );	
    if ( rpcStatus != RPC_S_OK )
    {
        return( NULL );
    }
#endif
    return bhandle;
}


handle_t
WinsABind(
    PWINSINTF_BIND_DATA_T pBindData
    )
{

	WCHAR  WcharString1[WINSINTF_MAX_NAME_SIZE];
	WCHAR  WcharString2[WINSINTF_MAX_NAME_SIZE];
	DWORD  NoOfChars;
	WINSINTF_BIND_DATA_T	BindData;
	if (pBindData->pServerAdd != NULL)
	{
	   NoOfChars = MultiByteToWideChar(CP_ACP, 0, pBindData->pServerAdd, -1,
				WcharString1, WINSINTF_MAX_NAME_SIZE); 	
	  if (NoOfChars > 0)
	  {
		BindData.pServerAdd = (LPSTR)WcharString1;
	  }
	}
	else
	{
		BindData.pServerAdd = (LPSTR)((TCHAR *)NULL);
	}
	if (!pBindData->fTcpIp)
	{
	   BindData.fTcpIp = 0;
	   NoOfChars = MultiByteToWideChar(CP_ACP, 0,
				pBindData->pPipeName, -1,
				WcharString2, WINSINTF_MAX_NAME_SIZE); 	
	   if (NoOfChars > 0)
	   {
		BindData.pPipeName = (LPSTR)WcharString2;
	   }
	}
	else
	{
		BindData.fTcpIp = 1;
	}
        return(WinsCommonBind(&BindData));

}
	
handle_t
WinsUBind(
    PWINSINTF_BIND_DATA_T pBindData
    )
{
        return(WinsCommonBind(pBindData));
}

VOID
WinsUnbind(
    PWINSINTF_BIND_DATA_T pBindData,
    handle_t BindHandle
    )
{

    (VOID)RpcBindingFree(&BindHandle);
	return;
}

handle_t
WINSIF_HANDLE_bind(
    WINSIF_HANDLE ServerHdl
    )

/*++

Routine Description:

    This routine is called from the WINS server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    return WinsCommonBind( ServerHdl );
}




void
WINSIF_HANDLE_unbind(
    WINSIF_HANDLE ServerHdl,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerIpAddress - This is the IP address of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    WinsUnbind( ServerHdl, BindHandle );
}

handle_t
WINSIF2_HANDLE_bind(
    WINSIF2_HANDLE ServerHdl
    )

/*++

Routine Description:

    This routine is called from the WINS server service client stubs when
    it is necessary create an RPC binding to the server end.

Arguments:

    ServerIpAddress - The IP address of the server to bind to.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    return ((handle_t)ServerHdl);
}




void
WINSIF2_HANDLE_unbind(
    WINSIF2_HANDLE ServerHdl,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine is called from the DHCP server service client stubs
    when it is necessary to unbind from the server end.

Arguments:

    ServerIpAddress - This is the IP address of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( ServerHdl );
    UNREFERENCED_PARAMETER( BindHandle );
    return;
}



//void __RPC_FAR * __RPC_API
LPVOID
midl_user_allocate(size_t cBytes)
{
	LPVOID pMem;
	pMem = (LPVOID)LocalAlloc(LMEM_FIXED, cBytes);
	return(pMem);
}

//void __RPC_API
VOID
//midl_user_free(void __RPC_FAR *pMem)
midl_user_free(void  *pMem)
{
	if (pMem != NULL)
	{
		LocalFree((HLOCAL)pMem);
	}
	return;
}

LPVOID
WinsAllocMem(size_t cBytes)
{
	return(midl_user_allocate(cBytes));

}

VOID
WinsFreeMem(LPVOID pMem)
{
	midl_user_free(pMem);

}


DWORD
WinsGetBrowserNames_Old(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_BROWSER_NAMES_T	pNames
	)
{

    DWORD status;

    RpcTryExcept {

        status = R_WinsGetBrowserNames_Old(
            ServerHdl,
			pNames
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsGetBrowserNames(
    WINSIF_HANDLE               ServerHdl,
    PWINSINTF_BROWSER_NAMES_T	pNames
	)
{

    DWORD status;

    RpcTryExcept {

        status = R_WinsGetBrowserNames(
            ServerHdl,
			pNames
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\rpc\rpcstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winsstub.c

Abstract:

    Client stubs of the WINS server service APIs.

Author:

    Pradeep Bahl (pradeepb) Apr-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "windows.h"
#include "rpc.h"
#include "winsif.h"
#include "esent.h"
#include "winscnst.h"
//#include "winsintf.h"

//
// prototypes
//
DWORD
WinsRestoreC(
 LPBYTE pBackupPath,
 DbVersion Version
);


DWORD
WinsRecordAction(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_RECORD_ACTION_T *ppRecAction
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsRecordAction(
            ServerHdl,
			ppRecAction
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}


DWORD
WinsStatus(
    WINSIF2_HANDLE               ServerHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_T pResults
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsStatus(
			//pWinsAddStr,
            ServerHdl,
			Cmd_e,
			pResults
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsStatusNew(
    WINSIF2_HANDLE               ServerHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsStatusNew(
            ServerHdl,
			Cmd_e,
			pResults
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsStatusWHdl(
    WINSIF_HANDLE               ServerHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
	)	
{
    DWORD status;

    RpcTryExcept {

        status = R_WinsStatusWHdl(
            ServerHdl,
			Cmd_e,
			pResults
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}


DWORD
WinsTrigger(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T 	pWinsAdd,
	WINSINTF_TRIG_TYPE_E	TrigType_e
	)	
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsTrigger(
            ServerHdl,
			pWinsAdd,
			TrigType_e
                     );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
DWORD
WinsDoStaticInit(
    WINSIF2_HANDLE               ServerHdl,
	LPWSTR pDataFilePath,
    DWORD  fDel
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDoStaticInit(
            ServerHdl,
            pDataFilePath, fDel);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}

DWORD
WinsDoScavenging(
    WINSIF2_HANDLE               ServerHdl
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDoScavenging(
                    ServerHdl
                 );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}
DWORD
WinsDoScavengingNew(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_SCV_REQ_T pScvReq
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDoScavengingNew(
                    ServerHdl,
                    pScvReq);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}

DWORD
WinsGetDbRecs(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo,
	PWINSINTF_RECS_T pRecs	
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsGetDbRecs(
                    ServerHdl,
                    pWinsAdd, MinVersNo, MaxVersNo, pRecs);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;

}
DWORD
WinsTerm(
    handle_t               ServerHdl,
	short	fAbruptTerm
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsTerm(
                    ServerHdl,
                    fAbruptTerm);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsBackup(
    WINSIF2_HANDLE               ServerHdl,
	LPBYTE		pBackupPath,
	short		fIncremental
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsBackup(
                    ServerHdl,
                    pBackupPath, fIncremental);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsDelDbRecs(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDelDbRecs(
                    ServerHdl,
                    pWinsAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsPullRange(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	PWINSINTF_ADD_T		pOwnAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsPullRange(
                    ServerHdl,
                    pWinsAdd, pOwnAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
DWORD
WinsSetPriorityClass(
    WINSIF2_HANDLE               ServerHdl,
	WINSINTF_PRIORITY_CLASS_E	PrCls_e
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsSetPriorityClass(
                    ServerHdl,
                    PrCls_e);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}


DWORD
WinsResetCounters(
    WINSIF2_HANDLE               ServerHdl
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsResetCounters(
                    ServerHdl
                   );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsRestoreEx(
 LPBYTE pBackupPath,
 DbVersion  Version
)
{
   return(WinsRestoreC(pBackupPath, Version));
}

DWORD
WinsRestore(
 LPBYTE pBackupPath
)
{
   return(WinsRestoreC(pBackupPath, DbVersion5 ));
}

DWORD
ConvertUnicodeStringToAscii(
        LPWSTR pUnicodeString,
        LPBYTE pAsciiString,
        DWORD  MaxSz
        )
{
    DWORD RetVal;
    RetVal = WideCharToMultiByte(
                CP_ACP,
                0,
                pUnicodeString,
                -1,
                pAsciiString,
                MaxSz,
                NULL,
                NULL
                );
    if (0 == RetVal ) {
        return GetLastError();
    } else {
        return ERROR_SUCCESS;
    }
}

DWORD
WinsReadLogPath(
    PCHAR   *pLogPath
    )
{
    DWORD   Error;
    static  TCHAR    Buf[WINSINTF_MAX_NAME_SIZE];
    static  TCHAR    ExpandBuf[WINSINTF_MAX_NAME_SIZE];
    static  char     AsciiBuf[WINSINTF_MAX_NAME_SIZE];
    WCHAR   *pTempPath,*pExpandTempPath;
    HKEY    sParamKey;
    DWORD   ValTyp;
    DWORD   Sz;
#define WINS_PARAM_KEY  TEXT("System\\CurrentControlSet\\Services\\Wins\\Parameters")
#define DEFAULT_LOG_FILE_PATH TEXT("%SystemRoot%\\System32\\wins")

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WINS_PARAM_KEY,
                0 ,
                KEY_READ,
                &sParamKey
                );

    if (ERROR_SUCCESS != Error) {
        return Error;
    }

    pTempPath = Buf;
    Error = RegQueryValueEx(
                 sParamKey,
                 WINSCNF_LOG_FILE_PATH_NM,
                 NULL,                //reserved; must be NULL
                 &ValTyp,
                 (LPBYTE)pTempPath,
                 &Sz
                 );

    if (ERROR_SUCCESS != Error || pTempPath[0] == L'\0') {
        pTempPath = DEFAULT_LOG_FILE_PATH;
    }
    pExpandTempPath = ExpandBuf;
    Error = ExpandEnvironmentStrings(
                    pTempPath,
                    pExpandTempPath,
                    WINSINTF_MAX_NAME_SIZE);
    if (0 == Error || Error > WINSINTF_MAX_NAME_SIZE) {
        RegCloseKey(sParamKey);
        return GetLastError();
    }
    *pLogPath = AsciiBuf;
    Error = ConvertUnicodeStringToAscii(
                pExpandTempPath,
                *pLogPath,
                WINSINTF_MAX_NAME_SIZE
                );
    RegCloseKey(sParamKey);
    return Error;
}

DWORD
WinsDelLogFiles(LPCSTR pFilePattern, LPSTR  pFilePath)
{
    DWORD               dwErr = ERROR_SUCCESS;
    WIN32_FIND_DATAA    FileInfo;
    HANDLE              SearchHandle;
    CHAR                FullFilePath[MAX_PATH + WINSINTF_MAX_NAME_SIZE + 2];

    // Construct the full file pattern
    strcpy(FullFilePath, pFilePath);
    strcat(FullFilePath, "\\");
    strcat(FullFilePath, pFilePattern);

    SearchHandle = FindFirstFileA(FullFilePath, &FileInfo);
    if (SearchHandle == INVALID_HANDLE_VALUE)
        dwErr = GetLastError();

    while(dwErr == ERROR_SUCCESS)
    {
        // construct the full file path
        strcpy(FullFilePath, pFilePath);
        strcat(FullFilePath, "\\");
        strcat(FullFilePath, FileInfo.cFileName);

        if (!DeleteFileA(FullFilePath) ||
            !FindNextFileA(SearchHandle, &FileInfo))
        {
            dwErr = GetLastError();
        }
    }
    if (dwErr == ERROR_NO_MORE_FILES)
        dwErr = ERROR_SUCCESS;

    if (SearchHandle != INVALID_HANDLE_VALUE)
        FindClose(SearchHandle);

    return dwErr;
}

DWORD
WinsRestoreC(
 LPBYTE pBackupPath,
 DbVersion Version
)

/*++

Routine Description:

	This is not an RPC function.  It is provided to do a restore of
	the database.
Arguments:
	pBackupPath - Path to the backup directory

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{
	JET_ERR JetRetStat;
        HMODULE hExtension;
        FARPROC fRestoreFn;
        FARPROC fSetSystemParamFn;
        DWORD   RetStat = WINSINTF_SUCCESS;
        DWORD   ProcId = 0x9C;  //ordinal value of JetRestore
        LPCSTR  RestoreProcName;
        LPCSTR  SetSystemParamProcName;
        BYTE  BackupPath[WINSINTF_MAX_NAME_SIZE + sizeof(WINS_BACKUP_DIR_ASCII)];
        CHAR    *pLogFilePath;
        DWORD Error;
        BOOL  fDirCr;
        LPTSTR pDllName;

 //       static BOOL sLoaded = FALSE;

try {
//      if (!sLoaded)
      {

        switch ( Version ) {
        case DbVersion351:
            pDllName = TEXT("jet.dll");
            RestoreProcName = (LPCSTR)0x9C;
            SetSystemParamProcName=(LPCSTR)165;
            break;
        case DbVersion4:
            pDllName = TEXT("jet500.dll");
            RestoreProcName = "JetRestore";
            SetSystemParamProcName="JetSetSystemParameter";
            break;
        case DbVersion5:
            pDllName = TEXT("esent.dll");
            RestoreProcName = "JetRestore";
            SetSystemParamProcName="JetSetSystemParameter";
            break;
        default:
            return WINSINTF_FAILURE;
        }

        // load the extension agent dll and resolve the entry points...
        if ((hExtension = GetModuleHandle(pDllName)) == NULL)
        {
                if ((hExtension = LoadLibrary(pDllName)) == NULL)
                {
                        return(GetLastError());
                }
                else
	        {
	                if ((fRestoreFn = GetProcAddress(hExtension,RestoreProcName)) == (FARPROC)NULL)
                        {
                                RetStat = GetLastError();
                        }

                    if ((RetStat == ERROR_SUCCESS) && (Version != DbVersion351) )
                    {
	                  if ((fSetSystemParamFn = GetProcAddress(hExtension,
                              SetSystemParamProcName)) == (FARPROC)NULL)
                        {
                                RetStat = GetLastError();
                        }
                   }
                }
        }
    }
//    sLoaded = TRUE;
//FUTURES("Change to lstrcpy and lstrcat when Jet starts supporting unicode")
  if (RetStat == WINSINTF_SUCCESS)
  {
    strcpy(BackupPath, pBackupPath);
    strcat(BackupPath, WINS_BACKUP_DIR_ASCII);
    fDirCr = CreateDirectoryA(BackupPath, NULL);

    if (!fDirCr && ((Error = GetLastError()) == ERROR_ALREADY_EXISTS))
    {
       if (Version != DbVersion351)
       {
         JET_INSTANCE JetInstance=0;
#define BASENAME        "j50"
#define LOG_FILE_SUFFIX "*.log"
         //
         // first set the system parameter for basename
         //

         //
         // Basename to use for jet*.log and jet.chk
         //
         // We should also specify the logfile path by checking WINS registry
         // but it is not essential.

         //
         // When WINS comes up, if it gets an error indicating that there
         // was a bad log signature or log version, it will delete all log
         // files and restart again.
         //
         do {
             JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                    &JetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramBaseName,
                                    0,
                                    BASENAME
                                       );
             if (JetRetStat != JET_errSuccess) break;
             JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                    &JetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFileSize,
                                    1024,
                                    NULL
                                       );

             JetRetStat = WinsReadLogPath( &pLogFilePath );
             if (JetRetStat != JET_errSuccess) break;

             JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                    &JetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath,
                                    0,
                                    pLogFilePath
                                       );
             if (JetRetStat != JET_errSuccess) break;

             if (Version == DbVersion5)
             {
                 // only for esent, request to delete old logs to avoid
                 // having them played back upon restore (bug #277816)
                 JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                        &JetInstance,
                                        (JET_SESID)0,
                                        JET_paramDeleteOutOfRangeLogs,
                                        1,
                                        NULL);
                 if (JetRetStat != JET_errSuccess) break;

                 // make sure Circular logging is enabled
                 JetRetStat = (JET_ERR)(*fSetSystemParamFn)(
                                        &JetInstance,
                                        (JET_SESID)0,
                                        JET_paramCircularLog,
                                        1,
                                        NULL);
             }
         } while (FALSE);
         if (JetRetStat == JET_errSuccess) {
             JetRetStat = (JET_ERR)(*fRestoreFn)((const char *)BackupPath, NULL);
             if (JetRetStat == JET_errBadLogVersion ||
                 JetRetStat == JET_errBadLogSignature ||
                 JetRetStat == JET_errInvalidLogSequence ||
                 JetRetStat == JET_errExistingLogFileHasBadSignature)
             {
                WinsDelLogFiles(LOG_FILE_SUFFIX, pLogFilePath);
                JetRetStat = (JET_ERR)(*fRestoreFn)((const char *)BackupPath, NULL);
             }
         }
       }
       else
       {
	      JetRetStat = (JET_ERR)(*fRestoreFn)((const char *)BackupPath, 0, NULL, (JET_PFNSTATUS)NULL);
       }
	   if (JetRetStat != JET_errSuccess)
	   {
		  RetStat = WINSINTF_FAILURE;
	   }
    }
    else
    {
        //
        // If CreateDirectoryA was successful, renove the directory
        //
        if (fDirCr)
        {
             RemoveDirectoryA(BackupPath);
             RetStat = WINSINTF_FAILURE;
        }
        else
        {
              RetStat = Error;
        }
    }
  }
}
except(EXCEPTION_EXECUTE_HANDLER) {
       RetStat = WINSINTF_FAILURE;
 }
    if (!FreeLibrary(hExtension))
    {
           RetStat = GetLastError();
    }
	return(RetStat);
}

DWORD
WinsWorkerThdUpd(
    WINSIF2_HANDLE               ServerHdl,
	DWORD NewNoOfNbtThds
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsWorkerThdUpd(
                    ServerHdl,
                    NewNoOfNbtThds);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsSyncUp(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T		pWinsAdd,
	PWINSINTF_ADD_T		pOwnerAdd
	)
{
    DWORD status;
    WINSINTF_VERS_NO_T MinVersNo, MaxVersNo;

    //
    // Set both version numbers to zero
    //
    MinVersNo.LowPart = 0;
    MinVersNo.HighPart = 0;
    MaxVersNo = MinVersNo;
    RpcTryExcept {

        status = R_WinsPullRange(
                    ServerHdl,
                    pWinsAdd, pOwnerAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsGetNameAndAdd(
    WINSIF2_HANDLE               ServerHdl,
	PWINSINTF_ADD_T	pWinsAdd,
	LPBYTE		pUncName
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsGetNameAndAdd(
                    ServerHdl,
                    pWinsAdd, pUncName);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsDeleteWins(
    WINSIF2_HANDLE               ServerHdl,
    PWINSINTF_ADD_T pWinsAdd)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsDeleteWins(
                    ServerHdl,
                    pWinsAdd);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsSetFlags(
    WINSIF2_HANDLE               ServerHdl,
    DWORD fFlags)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsSetFlags(
                    ServerHdl,
                    fFlags);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
DWORD
WinsGetDbRecsByName(
       WINSIF2_HANDLE               ServerHdl,
       PWINSINTF_ADD_T pWinsAdd,
       DWORD           Location,
       LPBYTE          pName,
       DWORD           NameLen,
       DWORD           NoOfRecsDesired,
       DWORD           fOnlyStatic,
       PWINSINTF_RECS_T pRecs
                   )
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsGetDbRecsByName(
                     ServerHdl,
                     pWinsAdd,
                      Location,
                      pName,
                      NameLen,
                      NoOfRecsDesired,
                      fOnlyStatic,
                      pRecs);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsTombstoneDbRecs(
    WINSIF2_HANDLE      ServerHdl,
    PWINSINTF_ADD_T     pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsTombstoneDbRecs(ServerHdl, pWinsAdd, MinVersNo, MaxVersNo);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}

DWORD
WinsCheckAccess(
    WINSIF2_HANDLE      ServerHdl,
    DWORD               *Access
    	)
{
    DWORD status;
    RpcTryExcept {

        status = R_WinsCheckAccess(ServerHdl, Access);

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        status = RpcExceptionCode();

    } RpcEndExcept

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\com\commapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        commapi.c

Abstract:
        This module contains the interface functions to interface with
        the comm. subsystem. These functions are used by the Replicator and
        the Name Space Manager.

Functions:


Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/


/*
 *       Includes
*/
#include <string.h>
#include <stdio.h>
#include "wins.h"
#include <winsock2.h>
#include "nms.h"
#include "winscnf.h"
#include "comm.h"
#include "assoc.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "rpl.h"

/*
 *        Local Macro Declarations
 */


/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */

COMM_HDL_T        QservDlgList;        //list of Q server dialogues.
HANDLE            CommUdpBuffHeapHdl;  //handle to heap used for allocating
                                       //buffers for storing datagrams
HANDLE            CommUdpDlgHeapHdl;   //handle to heap used for allocating
                                       //dlgs for udp buffers


HANDLE             sThdEvtArr[2];      //used by the Push thread in
                                       //ECommProcessDlg

SOCKET CommPnPNotificationSocket = INVALID_SOCKET; //to receive addr change notification
SOCKET CommTcpPortHandle = INVALID_SOCKET; //stores TCP port (socket) #
SOCKET CommUdpPortHandle = INVALID_SOCKET; //stores UDP port (socket) #
SOCKET CommNtfSockHandle = INVALID_SOCKET; //stores socket # of socket used
                                           //for listening for connection
                                           //notification messages from another
                                           //thread in the local WINS)
struct sockaddr_in  CommNtfSockAdd;        //stores address bound to
                                           //connection notification socket


#if SPX > 0
SOCKET CommSpxPortHandle = INVALID_SOCKET; //stores SPX port (socket) #
SOCKET CommIpxPortHandle = INVALID_SOCKET; //stores IPX port (socket) #
SOCKET CommIpxNtfSockHandle = INVALID_SOCKET; //stores socket # of socket used
                                           //for listening for connection
                                           //notification messages from another
                                           //thread in the local WINS)

struct sockaddr_ipx  CommIpxNtfSockAdd;        //stores address bound to
                                           //connection notification socket

#endif
COMM_HDL_T        CommExNbtDlgHdl;  /*explicit dialogue (used for
                                   *sending UDP requests to  nbt nodes */

//
// get rid of it when support for rpc function WinsGetNameAndAdd is
// removed.
//
#if USENETBT == 0
FUTURES("Remove this when support for WinsGetNameOrIpAdd is removed")
FUTURES("Check out ECommGetMyAdd")
BYTE                HostName[NMSDB_MAX_NAM_LEN];
#endif

/*
 *        Local Variable Definitions
 */






/*
  Externals
*/



/*
 *        Local Function Prototype Declarations
 */
VOID
InitOwnAddTbl(
        VOID
        );

//
// function definitions
//
DWORD
CommCreatePnPNotificationSocket(
    )
/*++

Routine Description:

Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;

    //
    // Create a socket
    //
    //--ft 06/01/2000: make multiple calls to CommCreatePnPNotificationSocket safe
    //CommCreatePnPNotificationSocket is called from both ECommInit and ECommGetMyAdd
    if (CommPnPNotificationSocket == INVALID_SOCKET)
    {
        CommPnPNotificationSocket = socket(
                                            PF_INET,
                                            SOCK_DGRAM,
                                            IPPROTO_UDP );

        if ( CommPnPNotificationSocket == INVALID_SOCKET ) {
            Error =  WSAGetLastError();
            DBGPRINT1( ERR,"could not create PnP notification socket, %ld.\n", Error );
        }
    }

    return Error;
}

VOID
CommInterfaceChangeNotification(
    DWORD   Error,
    DWORD   cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD   dwFlags
)
/*++

Routine Description:

Arguments:

    none.

Return Value:

    Registry Error.

--*/

{
    DBGPRINT1(FLOW, "CommInterfaceChangeNotification with Error value = (%x)\n", Error);
    if ( Error == ERROR_SUCCESS ) {

        //
        // reregister intrface change notification before we process
        // the current list change. This is required to avoid misssing
        // any interface changes that occur while we are processing
        // the current list.
        ECommRegisterAddrChange();

        if (ECommGetMyAdd(&NmsLocalAdd) == WINS_SUCCESS)
        {

           WinsEvtLogDetEvt(
                 TRUE,
                 WINS_PNP_ADDR_CHANGED,
                 NULL,
                 __LINE__,
                 "dd",
                 pNmsDbOwnAddTbl->WinsAdd.Add.IPAdd,
                 NmsLocalAdd.Add.IPAdd);

           if (pNmsDbOwnAddTbl->WinsAdd.Add.IPAdd != NmsLocalAdd.Add.IPAdd)
           {

            //
            // Send the reconfig message to the Pull thread
            //
            // Note: The PULL thread will deallocate memory pointed
            // to be pWinsCnf when it gets done
            //
            ERplInsertQue(
                    WINS_E_WINSCNF,
                    QUE_E_CMD_ADDR_CHANGE,
                    NULL,                        //no dlg handle
                    NULL,                        //no msg
                    0,                        //msg len
                    NULL,                //client ctx
                    0
                        );
            }

        }


    } else {

        WINSEVT_LOG_M(Error, WINS_EVT_SFT_ERR);
    }

    DBGLEAVE("CommInterfaceChangeNotification\n");
}

VOID
ECommRegisterAddrChange()
{
    //--ft: bug 86768; 'overlap' shouldn't be allocated on the stack
    //since it is passed down to WSAIoctl on an overlapped socket.
    static WSAOVERLAPPED overlap;
    DWORD                Error;
    DWORD                byteRet;

    RtlZeroMemory( &overlap, sizeof(WSAOVERLAPPED));

    Error = WSAIoctl(
                CommPnPNotificationSocket,
                SIO_ADDRESS_LIST_CHANGE,
                NULL,
                0,
                NULL,
                0,
                &byteRet,
                &overlap,
                CommInterfaceChangeNotification
                );

    if ( Error != ERROR_SUCCESS && Error == SOCKET_ERROR) {

        Error = WSAGetLastError();
        if (Error == WSA_IO_PENDING) {
            Error = ERROR_SUCCESS;
        } else {
            DBGPRINT1( ERR,"SIO_INTERFACE_LIST_CHANGE ioctl failed, %ld.\n", Error );
        }
    }
    if (Error != ERROR_SUCCESS ) {

        WINSEVT_LOG_M(Error, WINS_EVT_SFT_ERR);

    }
    return ;

}

VOID
ECommInit(
        VOID
        )
/*++
Routine Description:
         This function is called by the main thread of the process at
        process invocation time.  It initializes the communication subsystem.
        This comprises of

          1)create the TCP and UDP ports
          2)create the TCP and UDP listener threads


        None
Externals Used:
        None

Called by:
        Init() in nms.c
Comments:
        None

Return Value:
        None

--*/

{

        //
        //  Initialize lists, Tables and Memory
        //
        CommInit();

        //
        // Initialize the owner address table with own address
        //
        InitOwnAddTbl();

        // Now register for address change notification
        CommCreatePnPNotificationSocket();
        ECommRegisterAddrChange();

        //
        //  Create the TCP and UDP ports
        //
        CommCreatePorts( );


DBGIF(fWinsCnfRplEnabled)
        //
        // Signal Rpl PULL Thd so that it can go on
        //
        WinsMscSignalHdl(
                        RplSyncWTcpThdEvtHdl
                        );

        //
        // Init the event array used by ECommProcessDlg (in Push thread)
        //
        sThdEvtArr[0] =   RplSyncWTcpThdEvtHdl;
        sThdEvtArr[1] =   NmsTermEvt;

        /*
        * Create the TCP listener thread to monitor the TCP port
        */
        CommCreateTcpThd();

        //
        // if Wins is not coming up in the initially paused state, create
        // the udp thread.
        //
#if INIT_TIME_PAUSE_TEST > 0
//        if (!fWinsCnfInitStatePaused)
        {
           /*
            *  Create the UDP listener thread to monitor the TCP port
            */
            CommCreateUdpThd();
        }
#else
            CommCreateUdpThd();
#endif

        return;
}


#if PRSCONN
__inline
ECommIsBlockValid
 (
        PCOMM_HDL_T        pDlgHdl
 )
{
    return(CommIsBlockValid(pDlgHdl));
}

__inline
BOOL
ECommIsDlgActive
      (
        PCOMM_HDL_T        pDlgHdl
     )
/*++

Routine Description:


Arguments:
        pDlgHdl   --  check if dlg is active

Externals Used:
        None

Called by:
        Replicator

Comments:
        None

Return Value:


--*/
{

#if 0
    //
    // Check if block is valid.  It won't be if the dlg was terminated earlier
    //
    if (!CommIsBlockValid(pDlgHdl))
    {
          return(FALSE);
    }
#endif

    //
    //
    // Check whether the dlg is still active (i.e. the association is still
    // valid.
    // CommIsDlgActive is an inline function.
    //
    return(CommIsDlgActive(pDlgHdl));

}
#endif

STATUS
ECommStartDlg(
        PCOMM_ADD_T         pAdd,  // Address
        COMM_TYP_E         CommTyp_e,
        PCOMM_HDL_T        pDlgHdl
        )

/*++

Routine Description:


Arguments:
        pAdd          -- Address of the WINS server with which to start a dlg
        CommTyp_e -- Type of dialogue (Pull, Push, Notifier, etc)
        pDlgHdl   -- Will contain handle to dlg on successful completion of
                     the function

Externals Used:
        None

Called by:
        Replicator

Comments:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  One of the STATUS codes (see wins.h)

--*/

{

        PCOMMASSOC_ASSOC_CTX_T  pAssocCtx;
        PCOMMASSOC_DLG_CTX_T    pDlgCtx;
        STATUS                  RetStat = WINS_SUCCESS;
#ifdef WINSDBG
        struct in_addr        InAddr;
        LPBYTE  pstrAdd;
#endif

        DBGENTER("ECommStartDlg\n");

        /*
          Allocate a  dlg ctx block
        */
        pDlgHdl->pEnt = CommAssocAllocDlg();
try {
        pDlgCtx         = pDlgHdl->pEnt;
        pDlgCtx->Role_e = COMMASSOC_DLG_E_EXPLICIT;
        pDlgCtx->Typ_e  = CommTyp_e;
        pDlgHdl->SeqNo  = pDlgCtx->Top.SeqNo; //no need actually. (explicit dlg)

        //
        // Set up an association if we are not simulating an NBT node
        //
        if (CommTyp_e != COMM_E_NBT)
        {
                /*
                 * set up an association
                */
                CommAssocSetUpAssoc(
                                pDlgHdl,
                                pAdd,
                                CommTyp_e,
                                &pAssocCtx
                                                   );
                pDlgCtx->State_e          = COMMASSOC_DLG_E_ACTIVE;

                //
                // No need to store sequence no. since there will never
                // be a danger of the assoc. block being reused by some
                // some other dialogue (this is an explicit dialogue)
                //
                pDlgCtx->AssocHdl.pEnt    = pAssocCtx;
                pDlgCtx->Typ_e            = CommTyp_e;
       }
       else  //simulate an NBT node
       {
         //
         // Create a connection to the remote WINS
         //
         CommConnect(
                pAdd,
#if SPX > 0
                pAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP ? CommWinsTcpPortNo :
                          CommWinsSpxPortNo,
#else
                CommWinsTcpPortNo,
#endif
                &pDlgCtx->SockNo
                    );
       }

  }  // end of try { }
except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // Cleanup and reraise the exception
        //
        CommAssocDeallocDlg(pDlgHdl->pEnt);
        pDlgHdl->pEnt = NULL;                //let us cover all bases. See SndPushNtf                                        //in rplpull.c
        WINS_RERAISE_EXC_M();
        }

#ifdef WINSDBG
#if SPX == 0
        InAddr.s_addr = htonl(pAdd->Add.IPAdd);
        pstrAdd = inet_ntoa(InAddr);
#else
        if (pAdd->Add.AddTyp_e == COMM_E_ADD_TCPUDPIP)
        {
          InAddr.s_addr = htonl(pAdd->Add.IPAdd);
          pstrAdd = inet_ntoa(InAddr);
        }
        else
        {
           pstrAdd = pAdd->Add.nodenum;
        }
#endif

        DBGPRINT1(FLOW, "Leaving ECommStartDlg. Dlg started with Host at address -- (%s)\n", pstrAdd);

#endif
        DBGLEAVE("ECommStartDlg\n");
        return(RetStat);
}





VOID
ECommSndCmd(
        IN  PCOMM_HDL_T  pDlgHdl,
        IN  MSG_T        pMsg,
        IN  MSG_LEN_T    MsgLen,
        OUT PMSG_T       ppRspMsg,
        OUT PMSG_LEN_T   pRspMsgLen
        )

/*++

Routine Description:
        This function is used by the Replicator to send commands to Replicators         on remote WINSs.  It is also used by the Name Space Manager of a Q
        server to send name queriies to the Name Space Manager of an RQ server.


Arguments:
        pDlgHdl -- handle to dialogue to use for sending command
        pMsg        -- Msg (Cmd) to send
        MsgLen  -- Length of Message
        ppRspMsg -- Buffer containing response to command
        pRspLen         -- Length of response buffer


Externals Used:
        None

Called by:
        RplPull functions

Comments:
        None

Return Value:
        None
--*/
{

        PCOMMASSOC_ASSOC_CTX_T        pAssocCtx;
        PCOMMASSOC_DLG_CTX_T        pDlgCtx = pDlgHdl->pEnt;
        DWORD                        MsgTyp;
        DWORD                        Opc;
        ULONG                        uTmp;
        STATUS                         RetStat = WINS_SUCCESS;


        /*
          No need to lock the dialogue since:

                currently, only the thread (excluding the COMSYS threads) that
                creates a dialogue (explicit dialogue) sends messages on it.


                In the future, when multiple threads share the same
                dialogue, I will need to lock it or build an elaborate
                asynch notification mechanism (for responses)


          Also, there is no need to lock the associaation since only this
          thread would ever look at it
        */

        /*
         * Send the command
        */
        CommSend(
                pDlgCtx->Typ_e,
                &pDlgCtx->AssocHdl,
                pMsg,
                MsgLen
                );

        pAssocCtx = pDlgCtx->AssocHdl.pEnt;

        /*
          Wait for a response
        */
        RetStat = CommReadStream(
                        pAssocCtx->SockNo,
                        TRUE,                //do timed recv
                        ppRspMsg,
                        pRspMsgLen
                      );

        /*
          if bytes read are 0, there was a disconnect.  If RetStat is not
          success, maybe the recv. timed out or the most severe of
          all conditions, maybe the SOCKET_ERROR got returned by
          the first RecvData() call in CommReadStream. As far as the
          client is concerned, all of these conditions indicate
          COMM failure to it. Let us raise that exception.
        */
        if (( *pRspMsgLen == 0) || (RetStat != WINS_SUCCESS))
        {
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }
        COMM_GET_HEADER_M(*ppRspMsg, Opc, uTmp, MsgTyp);

        /*
          Let us check that this is not the stop assoc message
        */
        if (MsgTyp == COMM_STOP_REQ_ASSOC_MSG)
        {
            //
            // We do not disconnect the socket.  It will be disconnected as
            // a result of an end dialogue on this explicit association
            //
            //  CommDisc(pAssocCtx->SockNo);

            //
            // Free the buffer
            //
            ECommFreeBuff(*ppRspMsg);
            WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }
        /*
         *  Strip off the header before returning to the client
         * (Replicator)
        */
        *ppRspMsg   = *ppRspMsg   + COMM_HEADER_SIZE;
        *pRspMsgLen = *pRspMsgLen - COMM_HEADER_SIZE;

        return;
} // ECommSndCmd





STATUS
ECommSndRsp(
        PCOMM_HDL_T  pDlgHdl,
        MSG_T            pMsg,
        MSG_LEN_T   MsgLen
        )

/*++

Routine Description:

        This function is called by the Comm. clients to send messages to
        destinations identified by the dialogue.  No responses are expected to
        these messages.

        The function is used for sending responses.

Arguments:

        pDlgHdl - handle to dlg to use for sending response
        pMsg        - message (response) to send
        MsgLen  - length of message

Externals Used:
        None

Called by:
        NmsNmh functions, RplPush functions

Comments:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes  --

--*/
{

        BOOL                         fLocked = FALSE;
        STATUS                        RetStat = WINS_SUCCESS;
        PCOMMASSOC_DLG_CTX_T        pDlgCtx   = pDlgHdl->pEnt;

        DBGENTER("ECommSndRsp\n");
FUTURES("Since we do not want the overhead of an if test for responding")
FUTURES("to nbt requests, split up this function into one callable by")
FUTURES("replicator and the other one by NBT threads.  Do note that ")
FUTURES("this will take away some cleanliness of interfacing with COMM")

try {

        /*
          Check if the dialogue is for UDP communication.  If it is, there
          is no need for any synchronization.

          There is no need to lock the dialogue prior to checking it because

            if it is a UDP dialogue, it has to be the one that was allocated
            for this request (i.e. there is no possibility that we are now
            looking at another UDP dialogue).

        */
        if (pDlgCtx->Typ_e != COMM_E_UDP)
        {
                /*
                  * Lock the dialogue block so that it is not deleted from
                * under us. Actually, as things stand currently, an explicit
                * dialogue is never used by more than one thread. So, we don't
                * have to lock a dialogue if it is an explicit dialogue.  Let
                * us do it anyway since in the forseeable future, we could have
                * multiple threads using the same dialogue (Replicator threads -
                * Pull and Notifier). This is small insurance to save us
                * from later headaches.
                */

                fLocked = CommLockBlock(pDlgHdl);
                if (fLocked)
                {
                        CommSend(
                                pDlgCtx->Typ_e,
                                &pDlgCtx->AssocHdl,
                                pMsg,
                                MsgLen
                                );
                    }
                    else  //dialogue could not be locked
                {
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_LOCK_ERR);
                        DBGPRINT0(ERR, "ECommSndRsp: Could not lock the dialogue\n");
                        /*
                          *If Dialogue block could not be locked, it means
                         *that it was freed by the TCP listener thread (Check
                         *DelAssoc() in comm.c).  This would happen only
                         *if the connection terminated or if a stop assoc
                         *message was received on it.

                          *Return a COMM_FAIL error.  This will return in
                         *a search for a termination handler.  It is *ok*
                         * to take this overhead since this is a
                         * rare error case
                        */

                        return(WINS_COMM_FAIL);
                }

                if (CommUnlockBlock(pDlgHdl) == WINS_FAILURE)
                {
                        RetStat = WINS_FAILURE;
                }
                else  //successfully unlocked the dialogue
                {

                        fLocked = FALSE;
                }
        }
        else // it is dialogue for UDP communication with an NBT node
        {
                CommSendUdp(
                        0,
                        &(pDlgCtx->FromAdd),
                        pMsg,
                        MsgLen
                           );
                /*
                  We have sent the response.  We should now get rid of
                  the dialogue from the dialogue table.  This will
                  free the heap memory
                */
                CommAssocDeleteUdpDlgInTbl( pDlgCtx );
        }
    }

finally {

        if (fLocked)
        {
                  CommUnlockBlock(pDlgHdl);
        }
     }

     DBGLEAVE("ECommSndRsp\n");
     return(RetStat);

}

STATUS
ECommSendMsg(
        PCOMM_HDL_T          pDlgHdl,
        PCOMM_ADD_T        pAdd,
        MSG_T                  pMsg,
        MSG_LEN_T          MsgLen
        )

/*++

Routine Description:

        This function is used by the name challenge manager to send queries
        and release request to nbt nodes.

        It is also used by the replicator to send a Push notification to
        a WINS (pull pnr)

Arguments:
        pDlgHdl - handle to dlg to use for sending message
        pAdd        - Address of node to send message to
        pMsg    - Message to send
        MsgLen  - Length of message to send

Externals Used:
        None

Called by:
        NmsChl functions

Comments:

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --

--*/

{

        PCOMMASSOC_DLG_CTX_T        pDlgCtx = pDlgHdl->pEnt;
         struct sockaddr_in         TgtAdd;

        //
        // if the dialogue is mapped to the UDP port, send a UDP packet
        //
        if (pDlgCtx->Typ_e == COMM_E_UDP)
        {
                //
                // Don't change from host to net order. CommSendUdp does
                // that
                //
                 TgtAdd.sin_addr.s_addr = pAdd->Add.IPAdd;
                 if(TgtAdd.sin_addr.s_addr == INADDR_NONE)
                 {
                        return(WINS_FAILURE);
                 }
                 TgtAdd.sin_family = PF_INET;
                 TgtAdd.sin_port   = htons(WINS_NBT_PORT);

                 //
                 // Send the message via netbt
                 //
                 CommSendUdp( 0,  &TgtAdd, pMsg, MsgLen );
        }
        else  // it is a dialogue mapped to a TCP connection
        {
                //
                // Send the message
                //
                CommSend(
                          pDlgCtx->Typ_e,
                          &pDlgCtx->AssocHdl,
                          pMsg,
                          MsgLen
                        );
        }
         return(WINS_SUCCESS);
}




STATUS
ECommEndDlg(
        PCOMM_HDL_T         pDlgHdl
        )

/*++

Routine Description:


        This function is used to end a dialogue.


        The processing depends upon the type of dialogue

        1)if the dlg is an implicit UDP dialogue. it is deleted from
        the dlg table and the memory is freed.

        2)if the dlg is an implicit dlg, a stop assoc.
          message is sent on the association

        3)if the dlg is an explicit dlg, a stop assoc. message is
          message is sent on the association and the association is
          terminated


Arguments:
        pDlgHdl - Handle to dlg to end

Externals Used:
        None

Called by:
        RplPull functions, HandleUpdNtf in rplpush.c (by the Push thread)

Comments:
        Currently, there is no need to lock an explicit dialogue since only
        one thread accesses it any time (currently).  In the future, if we
        have multiple threads accessing the same dialogue, we will do locking


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --

--*/

{
        BYTE                        Msg[COMMASSOC_ASSOC_MSG_SIZE];
        DWORD                        MsgLen = COMMASSOC_ASSOC_MSG_SIZE;
        PCOMMASSOC_ASSOC_CTX_T   pAssocCtx;
        PCOMMASSOC_DLG_CTX_T        pDlgCtx = pDlgHdl->pEnt;
        BOOL                        fLocked;

        DBGENTER("ECommEndDlg\n");
        //
        // If there is no dialogue to be ended, return WINS_INVALID_HDL
        // Note: There can be cases in failure recovery where ECommEndDlg
        // may be called to end a dialogue that was never got started or
        // got ended prematurely.  Though an error status is returned, the
        // caller, when doing failure recovery, may ignore the return status
        // of this function.  In case of fatal error conditions, an exception
        // will be raised which the caller can not ignore.
        //
        if (pDlgCtx == NULL)
        {
                DBGLEAVE("ECommEndDlg\n");
                return(WINS_INVALID_HDL);
        }

        //
        //  In case it is an implicit UDP dialogue, there is no danger
        //  of it being freed from under us, so there is no need to lock.
        //  In case it is an implicit TCP dialogue, it could get freed
        //  and even reallocated from under us, but reallocation will only
        //  be for TCP, so there is no danger since we do lock the dlg
        //  block if it is a TCP dlg block (if there has been a reallocation,
        //  the lock attempt  will fail.)
        //
        if (pDlgCtx->Role_e == COMMASSOC_DLG_E_IMPLICIT)
        {
             if (pDlgCtx->Typ_e == COMM_E_UDP)
             {
                   //
                   // Delete the dialogue from the table and free the
                   // heap memory
                   //
                   CommAssocDeleteUdpDlgInTbl( pDlgCtx );
             }
             else  // it is a TCP dialogue.
             {

                fLocked = CommLockBlock(pDlgHdl);

                //
                // If we could lock it, the dlg is ok.  If we could not
                // lock it, it means that the dlg was freed due to the
                // the assoc. going down. We have nothing more to do.
                //
                if (fLocked)
                {
                        pAssocCtx = pDlgCtx->AssocHdl.pEnt;

                        //
                        // The stop assoc. message will result in the
                        // the other WINS terminating the connection which
                        // result in all cleanup at our end
                        //
                            CommAssocFrmStopAssocReq(
                                pAssocCtx,
                                Msg,
                                MsgLen,
                                COMMASSOC_E_MSG_ERR
                                         );
                       try {

                        CommSendAssoc(
                                        pAssocCtx->SockNo,
                                        Msg,
                                        MsgLen
                                   );
                          }
                        except(EXCEPTION_EXECUTE_HANDLER) {
                            //
                            // No need to do any cleanup.  This is an
                            // implicit dlg.  The tcp listener thread will
                            // do the cleanup. Currently, it never calls
                            // ECommEndDlg for an implicit dlg so the client
                            // has got to be rpl
                            //
                            DBGPRINTEXC("CommEndDlg");
                         }

                         CommUnlockBlock(pDlgHdl);
                }
             }
        }
        else  // it is an explicit dialogue
        {
                if (pDlgCtx->Typ_e != COMM_E_NBT)
                {
                        CommEndAssoc(&pDlgCtx->AssocHdl);
                }

                /*
                   *  Dealloc the dialogue in order to put it in the free list
                */
                CommAssocDeallocDlg( pDlgCtx );
#if PRSCONN
FUTURES("Init the dlg hdl in the caller - good software engineering practice")
                //
                // The dlg is ended.  Let us init the dlg hdl to null so that
                // it is not used again.  Strictly speaking, we should do let
                // the caller do this.  For now, we will do it here
                //
                ECOMM_INIT_DLG_HDL_M(pDlgHdl);
#endif
        }

        DBGLEAVE("ECommEndDlg\n");
        return(WINS_SUCCESS);
}




#if 0
ECommSendtoAllQ(
        MSG_T           pMsg,
        MSG_LEN_T MsgLen
        )

/*++

Routine Description:
 This function is called to send a message to all Q servers.


Arguments:


Externals Used:
        None

Called by:

Comments:
        May use it in the future.  Needs work.

Return Value:

   Success status codes --
   Error status codes  --

--*/

{

        /*
          if there is no dialogue pertaining to a Q server, return failure
        */

        if (IsListEmpty(&QservDlgList))
        {
                return(WINS_FAILURE);
        }


        /*
                find all the dialogues pertaining to Q servers
        */

        while ((pQservDlg = GetNext(&QservDlgList)) != &QservDlgList)
        {
                CommSendAssoc(pQservDlg->pAssocCtx->SockNo, pMsg, MsgLen);
        }

        return(WINS_SUCCESS);
}

#endif

STATUS
ECommAlloc(
  OUT LPVOID                 *ppBuff,
  IN  DWORD                 BuffSize
        )

/*++

Routine Description:

        This function is called by by the replicator to allocate a buffer for
        sending to another WINS (over a TCP connection)


Arguments:
        ppBuff   - Buffer allocated by function
        BuffSize - Size of buffer to be allocated

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:

        Challenge manager should not call this function.  When it is coded,
        it will call AllocUdpBuff which will be made an external for this
        purpose (CommAllocUdpBuff)
--*/

{

        DWORD                Size =   COMM_HEADER_SIZE +
                                   sizeof(COMM_BUFF_HEADER_T) + sizeof(LONG);
        PCOMM_BUFF_HEADER_T pCommHdr;

        WinsMscAlloc( Size + BuffSize, ppBuff);
#if 0
        *ppBuff = CommAlloc(
                        NULL,         //no table
                        Size + BuffSize
                            );
#endif
        pCommHdr = (PCOMM_BUFF_HEADER_T)((LPBYTE)(*ppBuff) + sizeof(LONG));
        pCommHdr->Typ_e = COMM_E_TCP; //until we know better
        *ppBuff = (LPBYTE)(*ppBuff) + Size;

        return(WINS_SUCCESS);
}

#if 0

VOID
ECommDealloc(
  LPVOID pBuff
        )

/*++

Routine Description:
        This is a wrapper around CommDealloc. It conforms to the
        prototype required by RtlInitializeGenericTbl func.

Arguments:

        pBuf -- Buffer to deallocate

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        Not being used currently
--*/
{
        LPVOID pTmp = (LPBYTE)pBuff - COMM_HEADER_SIZE;

        WinsMscDealloc(pTmp);
#if 0
        CommDealloc(NULL, pTmp);
#endif
        return;
}
#endif

DWORD
ECommCompAdd(
        PCOMM_ADD_T        pFirstAdd,
        PCOMM_ADD_T        pSecAdd
        )

/*++

Routine Description:
        the function compares two host addresses

Arguments:

        pFirstAdd  - Address of a node
        pSecondAdd - Address of a node

Externals Used:
        None


Return Value:

        COMM_SAME_ADD
        COMM_DIFF_ADD

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
#if 0
        if ((pFirstAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP) &&
            (pSecAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP))
#endif
        {
          if (pFirstAdd->Add.IPAdd == pSecAdd->Add.IPAdd)
          {
                return(COMM_SAME_ADD);
          }
        }
        return(COMM_DIFF_ADD);
}

int
__cdecl
ECommCompareAdd(
        const void       *pKey1,
        const void       *pKey2
        )

/*++

Routine Description:
        the function compares two host addresses

Arguments:

        pFirstAdd  - Address of a node
        pSecondAdd - Address of a node

Externals Used:
        None


Return Value:


Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        const COMM_ADD_T *pFirstAdd = pKey1;
        const COMM_ADD_T *pSecAdd = pKey2;

        return (pFirstAdd->Add.IPAdd > pSecAdd->Add.IPAdd) ?
                    1 :
                    (pFirstAdd->Add.IPAdd < pSecAdd->Add.IPAdd) ?
                        -1:
                        0;
}

VOID
ECommFreeBuff(
        IN MSG_T    pMsg
        )

/*++

Routine Description:

        This function is called to free a buffer allocated earlier by
        COMSYS.  The function checks the buffer header to determine which
        deallocation function to call

        The usefulness of this function stems from the fact that a buffer
        can be made independent of the dialogue (or association) it came from
        in the sense that we don't need to pass information about such a
        dlg or assoc when freeing the buffer.  This saves us from locking
        and unlocking.

Arguments:

        pMsg -- Buffer to free

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:
        SndNamRegRsp, SndNamRelRsp, SndNamQueryRsp in nmsnmh.c

Comments:
        None
--*/

{

#if USENETBT > 0
        PCOMM_BUFF_HEADER_T  pHdr = (PCOMM_BUFF_HEADER_T)
                                      (pMsg - COMM_NETBT_REM_ADD_SIZE -
                                                sizeof(COMM_BUFF_HEADER_T));
#else
        PCOMM_BUFF_HEADER_T  pHdr = (PCOMM_BUFF_HEADER_T)
                                      (pMsg - sizeof(COMM_BUFF_HEADER_T));
#endif

        if (pHdr->Typ_e == COMM_E_UDP)
        {

                WinsMscHeapFree(
                                   CommUdpBuffHeapHdl,
                                   pHdr
                                  );
        }
        else
        {
                WinsMscHeapFree(CommAssocTcpMsgHeapHdl, (LPBYTE)pHdr - sizeof(LONG));
          //      WinsMscDealloc((LPBYTE)pHdr - sizeof(LONG));
        }
        return;
}


VOID
InitOwnAddTbl(
        VOID
        )

/*++

Routine Description:
        This function uses the local address of the WINS (i.e. the host
        address) to overwrite the NmsDbOwnAddTbl array entry
        pertaining to the local WINS if different

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        CommInit  (in the main thread)

Side Effects:

Comments:
        There is no need to synchronize over the NmsDbOwnAddTbl since
        the PULL thread will not touch it until it initiates the pull protocol
--*/

{
        COMM_IP_ADD_T        IPAddInDbTbl;

        // Since NmsDbWriteOwnAddTbl might change NmsDbNoOfOwners,
        // insure exclusive access to this data. We need to do so 
        // since this comm init call competes with the initial
        // pull replication activity, stack below:
        //     wins!GetReplicasNew
        //     wins!InitRplProcess
        //     wins!RplPullInit
        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);

        // with WINS is safer to make sure no exception would cause us to leave
        // the critical section locked
        try
        {
            // if the address of the owner with  owner id = NMSDB_LOCAL_OWNER_ID
            // is different from mine (i.e. local WINS)
            // change it to mine.  I always own all entries tagged with
            // owner id of 0.  The fact that the address is different
            // means that the database was earlier used by a WINS at
            // a different address.
            //
            IPAddInDbTbl =  pNmsDbOwnAddTbl->WinsAdd.Add.IPAdd;
            if (
                    IPAddInDbTbl != NmsLocalAdd.Add.IPAdd
               )
            {


                   //
                   // IPAddInDbTbl will be zero if there is no entry in the
                   // local db having NMSDB_LOCAL_OWNER_ID as the owner field
                   // value
                   //
                   NmsDbWriteOwnAddTbl (
                            IPAddInDbTbl == 0 ?
                                    NMSDB_E_INSERT_REC : NMSDB_E_MODIFY_REC,
                            NMSDB_LOCAL_OWNER_ID,
                            &NmsLocalAdd,
                            NMSDB_E_WINS_ACTIVE,
                            &NmsDbStartVersNo,
                            &NmsDbUid
                                    );

                   pNmsDbOwnAddTbl->WinsAdd     =  NmsLocalAdd;
                   pNmsDbOwnAddTbl->WinsState_e =  NMSDB_E_WINS_ACTIVE;
                   pNmsDbOwnAddTbl->MemberPrec  =  WINSCNF_HIGH_PREC;
                   pNmsDbOwnAddTbl->StartVersNo =  NmsDbStartVersNo;
                   pNmsDbOwnAddTbl->Uid         =  NmsDbUid;

            }
        }
        finally 
        {
            LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
        }

        return;
}


BOOL
ECommProcessDlg(
        PCOMM_HDL_T        pDlgHdl,
        COMM_NTF_CMD_E     Cmd_e
        )

/*++

Routine Description:

        This function is called to either start or stop  monitoring a
        dialogue.  It  sends a message to the TCP listener thread  (a UDP
        datagram) on the notification socket.

Arguments:
        pDlgHdl - Dialogue handle
        Cmd_e   - Cmd (COMM_E_NTF_START_MON or COMM_E_NTF_STOP_MON)

Externals Used:
        RplSyncWTcpThdEvtHdl

Return Value:
        None

Error Handling:

Called by:
        SndUpdNtf in rplpull.c, HdlUpdNtf in rplpush.c

Side Effects:

Comments:
        The client should not expect to use the dailogue after calling
        this functions

        Only the Push thread calls this function

--*/

{
        COMM_NTF_MSG_T                NtfMsg;
        BOOL  fRetStat = TRUE;
        DWORD ArrInd;


        DBGENTER("ECommProcessDlg\n");

        //
        //Format the message to send in the UDP datagram
        //
        if (CommLockBlock(pDlgHdl))
        {
          PCOMMASSOC_DLG_CTX_T    pDlgCtx    = pDlgHdl->pEnt;
          PCOMMASSOC_ASSOC_CTX_T  pAssocCtx  = pDlgCtx->AssocHdl.pEnt;

          NtfMsg.SockNo    = pAssocCtx->SockNo;
          NtfMsg.Cmd_e     = Cmd_e;
          NtfMsg.AssocHdl  = pDlgCtx->AssocHdl;
          NtfMsg.DlgHdl    = *pDlgHdl;

CHECK("If TCP protocol is installed.  If not, use the Spx notification socket")

          CommUnlockBlock(pDlgHdl);

          CommSendUdp(
                        CommNtfSockHandle,
                        //CommUdpPortHandle,                   //sending port
                        &CommNtfSockAdd,                    //Address to send to
                        (LPBYTE)&NtfMsg,                //socket no to send
                        COMM_NTF_MSG_SZ
                   );

        DBGPRINT2(DET,
                "ECommProcessDlg: Sent %s monitoring message to TCP listener thread for socket no (%d)\n",
                Cmd_e == COMM_E_NTF_START_MON ? "start" : "stop",
                NtfMsg.SockNo
                 );

        //
        // if the command is to "stop monitoring the dlg" we have to wait
        // until the TCP listener thread has receive this message and
        // taken the socket out of its array of sockets
        //
        if (Cmd_e == COMM_E_NTF_STOP_MON)
        {
                //
                //Wait to be signaled by the TCP listener thread indicating that
                // it has removed the socket from the list of sockets that it
                // is monitoring. We also want to check the term. event since
                // the tcp thread may have terminated as a result of
                // a termination of WINS.
                //
                //WinsMscWaitInfinite(RplSyncWTcpThdEvtHdl);
                WinsMscWaitUntilSignaled(
                                   sThdEvtArr,
                                   sizeof(sThdEvtArr)/sizeof(HANDLE),
                                   &ArrInd,
                                   FALSE
                                        );

                if (ArrInd == 0)
                {
                   if (fCommDlgError)
                   {
                       DBGPRINT0(ERR, "ECommProcessDlg: The tcp listener thread indicated that the IMPLICIT assoc has been deallocated.  TIMING WINDOW\n");
                       fRetStat = FALSE;
                       fCommDlgError = FALSE;

                   }
                }
                else
                {
                     //
                     //Signaled for termination
                     //
                     WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                }
        }
       }
       else
       {
             DBGPRINT1(ERR, "ECommProcessDlg: Could not lock the (%s) dlg block. Maybe the assocication and dialogue got deallocated\n", Cmd_e == COMM_E_NTF_STOP_MON ? "IMPLICIT" : "EXPLICIT");
              fRetStat = FALSE;
       }
        //
        // All done. Return
        //
        DBGLEAVE("ECommProcessDlg\n");
        return(fRetStat);
}

//--ft: 11/30/99
STATUS
CommRaiseMyDnsAdd(
        IN OUT LPSOCKET_ADDRESS_LIST   pAddrList
        )
//++
//Routine Description:
//
//        This function is called to find out the address returned by DNS when
//        the server address is queried through gethostbyname().
//
//Arguments:
//        pAddrList - the list of local interfaces as returned by WSAIoctl(SIO_ADDRESS_LIST_QUERY)
//--
{
    DWORD           Error = ERROR_SUCCESS;
    struct hostent  *pHostEnt;
    BYTE            HostName[NMSDB_MAX_NAM_LEN];
    CHAR            **pHostIter;

    // Get host's name
    if (gethostname(HostName, NMSDB_MAX_NAM_LEN) == SOCKET_ERROR)
    {
         return WSAGetLastError();
    }

    // Get host's HOSTENT structure
    pHostEnt = gethostbyname(HostName);

    if (pHostEnt == NULL)
    {
        return WSAGetLastError();
    }

    // For each address returned by DNS
    for (pHostIter = pHostEnt->h_addr_list; (*pHostIter) != NULL; pHostIter++)
    {
        INT i;

        // For each address in the interfaces list
        for (i = 0; i < pAddrList->iAddressCount; i++)
        {
            LPSOCKADDR_IN pSockIf = (LPSOCKADDR_IN)(pAddrList->Address[i].lpSockaddr);

            // it is assumed the address is IP (DWORD size)
            if (WINSMSC_COMPARE_MEMORY_M(
                    (*pHostIter),
                    &(pSockIf->sin_addr),
                    pHostEnt->h_length) == (UINT)pHostEnt->h_length)
            {
                // bring the DNS address in front of the interfaces list if needed
                // this is where the address to be used will be picked up from
                if (i != 0)
                {
                    LPSOCKADDR_IN pSockIfAtZero = (LPSOCKADDR_IN)(pAddrList->Address[0].lpSockaddr);
                    WINSMSC_COPY_MEMORY_M(
                        pSockIfAtZero,
                        pSockIf,
                        sizeof(SOCKADDR_IN)
                        );
                }
                // return success
                return Error;
            } // end_if success in matching dns address with if address
        } // end_for each interface address
    } // end_for each dns address

    // at this point is kind'a weird: either no DNS address could be found in the interfaces list
    // or the interfaces list is just empty (no interfaces?)
    // in either cases, this will be handled by the caller - the interfaces list is untouched
    return Error;
}

STATUS
ECommGetMyAdd(
        IN OUT PCOMM_ADD_T        pAdd
        )

/*++

Routine Description:

        This function is called to find out the name and address of the
        local machine and store it for later use.

Arguments:
        pAdd - pointer to buffer to contain the address

Externals Used:
        NmsLocalAdd

Return Value:
        None

Error Handling:

Called by:
        Init() in nms.c

Side Effects:

Comments:
        THIS MUST BE THE FIRST COMM FUNCTION TO BE CALLED IN WINS. This
        is so that WSAStartup is called prior to calling any winsock functions
--*/

{

        DWORD              Error;
        int                RetVal;
        DWORD              RetStat = WINS_SUCCESS;
        NTSTATUS           RetStatus;
        static BOOL        bWSAStarted = FALSE;
        WSADATA            wskData;
        DBGENTER("ECommGetMyAdd\n");
        /*
        * Let us call the WSAStartup function.  This function needs
        * to be called before any other wins socket function can be
        * called.
        */

        // added the bWSAStarted variable to avoid making several subsequent
        // calls to WSAStartup. Also it looks like there is no matching
        // WSACleanup call at this time.
        if (!bWSAStarted)
        {
            if (WSAStartup(0x101, &wskData) || (wskData.wVersion != 0x101))
            {
                   WinsEvtLogDetEvt(
                         FALSE,
                         WINS_PNP_FAILURE,
                         NULL,
                         __LINE__,
                         "d",
                         WINS_EXC_FATAL_ERR);

                   WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
            }

            bWSAStarted = TRUE;
        }

        //
        // If this is a cluster machine, always use cluster Ip resource address
        //
        if (WinsClusterIpAddress)
        {
            pAdd->Add.IPAdd = WinsClusterIpAddress;
        }
        else
        {
            DWORD                   dwAddrListSz = 0;   // size of the ioctl out buffer
            LPSOCKET_ADDRESS_LIST   pAddrList = NULL;   // pointer to the ioctl out buffer

            Error = CommCreatePnPNotificationSocket();

            if (Error == ERROR_SUCCESS)
            {
                // make one Ioctl call to get the required size of the output buffer
                // this should fail with SOCKET_ERROR and with LastError = WSAEFAULT
                Error = WSAIoctl(
                              CommPnPNotificationSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL,
                              0,
                              NULL,
                              0,
                              &dwAddrListSz,
                              NULL,
                              NULL
                              );
            }

            // if CommCreatePnPNotificationSocket failed, Error is supposed to be a WSAError
            // and not SOCKET_ERROR. This avoids calling WSAIoctl a second time and the error
            // will be captured in the next if()
            // we should get an error with the LastError = WSAEFAULT
            if (Error == SOCKET_ERROR && WSAGetLastError() == WSAEFAULT)
            {
                WinsMscAlloc(dwAddrListSz, &pAddrList);
                // make a second IoctlCall in order to get the list of addresses in
                // the newly allocated buffer. This is expected to succeed
                Error = WSAIoctl(
                              CommPnPNotificationSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL,
                              0,
                              pAddrList,
                              dwAddrListSz,
                              &dwAddrListSz,
                              NULL,
                              NULL
                              );                
            }

            // on success, go raise the first address known by DNS
            // this hack is needed in order to get the first adaptor from the binding list.
            // It seems like gethostbyname returns the adaptors in binding order while WSAIoctl does not.
            if (Error == 0)
            {
                // this is another hack: it looks like DNS is not refreshing the addresses instantly. For instance,
                // plugging out the cable for the first ip from the DNS list triggers CommInterfaceChangeNotification
                // but while in this function gethostbyname() still shows the address that went away as the first
                // one in the list. Add 1/2 sec delay here to let DNS update its addresses and after that attempt
                // to raise in the list returned by SIO_ADDRESS_LIST_QUERY the first address known by DNS.
                Sleep(500);
                Error = CommRaiseMyDnsAdd(pAddrList);
            }

            if (Error != 0)
            {
                Error = WSAGetLastError();

                WinsEvtLogDetEvt(
                     FALSE,
                     WINS_PNP_FAILURE,
                     NULL,
                     __LINE__,
                     "d",
                     Error);

                DBGPRINT1(ERR,
                 "ECommGetMyAdd:WSAIoctl(SIO_ADDRESS_LIST_QUERY) failed with error %d\n", Error);

                if (pAddrList != NULL)
                {
                    WinsMscDealloc(pAddrList);
                    pAddrList = NULL;
                }

                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
            }

            if (pAddrList->iAddressCount > 0)
            {
                // why fooling around - pAdd->Add.IPAdd is a DWORD anyhow.
                pAdd->Add.IPAdd =
                    ((LPSOCKADDR_IN)(pAddrList->Address[0].lpSockaddr))->sin_addr.s_addr;
            }
            else
            {
                // just in case no addresses were passed up by the Ioctl, set the address
                // to 0. It will be seen as such a couple lines down.
                pAdd->Add.IPAdd = 0;
            }

            if (pAddrList != NULL)
            {
                WinsMscDealloc(pAddrList);
                pAddrList = NULL;
            }

            //
            //  Initialize the structure
            //
            pAdd->Add.IPAdd = ntohl(pAdd->Add.IPAdd);
        }

        //
        // This prints the address in reverse order, that's ok
        //
        DBGPRINT1(DET, "ECommGetMyAdd: Binding to Nbt interface %s\n",
                  inet_ntoa(*(struct in_addr *)&pAdd->Add.IPAdd));


        //
        // If we have a 0 address or a loopback address, it means that the
        // address went away.  Wait for one to come back.
        //
        if ((WinsCnf.State_e != WINSCNF_E_TERMINATING) &&
            ((pAdd->Add.IPAdd & 0xff000000) != (INADDR_LOOPBACK & 0xff000000)) && 
            (pAdd->Add.IPAdd != 0))
        {
           try
           {
               if (WinsCnfNbtHandle)
               {
                    NTSTATUS         status;
                    IO_STATUS_BLOCK  iosb;
                    tWINS_SET_INFO   setInfo;

                    // if there is already a Nbt handle, just rebind it
                    setInfo.IpAddress = pAdd->Add.IPAdd;

                    // this ioctl is just notifying NetBt on the address change.
                    // it should succeed with STATUS_SUCCESS - no reason for 'pending'
                    // hence no reason for passing down an Apc or an event handle.
                    status = NtDeviceIoControlFile(
                                      WinsCnfNbtHandle,             // Handle
                                      NULL,                         // Event
                                      NULL,                         // ApcRoutine
                                      NULL,                         // ApcContext
                                      &iosb,                        // IoStatusBlock
                                      IOCTL_NETBT_WINS_SET_INFO,    // IoControlCode
                                      &setInfo,                     // InputBuffer
                                      sizeof(tWINS_SET_INFO),       // Buffer Length
                                      NULL,                         // Output Buffer
                                      0                             // Output BufferSize
                             );

                    ASSERT(status == STATUS_SUCCESS);
               }
               else
               {
                   // open netbt handle with interface having this address
                   CommOpenNbt(pAdd->Add.IPAdd);
               }

               // We need to get all netbt interfaces' Ip addresses. They are sent
               // via multicast packet to other wins servers to support find self
               // partner feature.
               CommGetNetworkAdd();

               pAdd->AddTyp_e   = COMM_ADD_E_TCPUDPIP;
               pAdd->AddLen     = sizeof(COMM_IP_ADD_T);
           }
           except(EXCEPTION_EXECUTE_HANDLER)
           {
                WinsEvtLogDetEvt(
                     FALSE,
                     WINS_PNP_FAILURE,
                     NULL,
                     __LINE__,
                     "d",
                     GetExceptionCode());

                WINS_RERAISE_EXC_M();
           }
        }
        else
        {
           RetStat = WINS_FAILURE;
        }

        DBGLEAVE("ECommGetMyAdd\n");
        return(RetStat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\rpc\winscl.c ===
//============================================================================
// Copyright(c) 1998, Microsoft Corporation
//
// File:    winscl.c
//
// Modification History:
//
//  1/14/1998   Ram Cherala (ramc)
//      Added this header and made the following changes to make winscl a more
//      intuitive and easy tool to use.
//      Expanded abbreviations like vers. to the full form words.
//      Made all string comparisions case insensitive.
//      Made the input choices more obvious - very specifically state what the
//      user should be entering as input to commands.
//      Printed version IDs in hexadecimal like the WINS snap-in does.
//
// Implementation of winscl command line utility
//============================================================================

#include <stdio.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <windef.h>
#include <winsock.h>
#include "windows.h"
//#include "jet.h"
//#include "winsif.h"
#include "winsintf.h"

//
// This includes wins.h which includes windbg.h
//
// winsdbg.h defines STATIC to nothing now
//
#include "winsthd.h"


#define FILEU   "winsu"
#define FILEO   "winso"

STATIC
VOID
GetNameInfo(
        PWINSINTF_RECORD_ACTION_T pRecAction,
        WINSINTF_ACT_E                  Cmd_e
         );
STATIC
VOID
GetFilterName(
        LPBYTE  pStr,
        LPDWORD pLen
         );

STATIC
DWORD
GetStatus(
        BOOL                          fPrint,
        LPVOID                       pResults,
        BOOL                         fNew,
        BOOL                         fShort
        );
VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        FILE                          *pFile,
        DWORD                          Add,
        LPBOOL                          pfMatch
      );
STATIC
VOID
WantFile(
        FILE **ppFile
);

STATIC
DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T     pWinsAdd,
   LPBYTE              pTgtAdd,
   BOOL                      fSetFilter,
   LPBYTE              pFilterName,
   DWORD              Len,
   BOOL                      fAddFilter,
   DWORD              AddFilter,
   FILE                      *pFile,
   BOOL                      fCountRec
  );

STATIC
DWORD
GetDbRecsByName(
  PWINSINTF_ADD_T pWinsAdd,
  DWORD           Location,
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           NoOfRecsDesired,
  DWORD           TypeOfRecs,
  BOOL            fFilter,
  DWORD           AddFilter
 ) ;

WINSINTF_VERS_NO_T        sTmpVersNo;


STATIC
DWORD
CreateFiles(
    PWINSINTF_RECS_T pRecs,
    PWINSINTF_ADD_T      pWinsAdd,
    FILE *pFileU,
    FILE  *pFileO
    );

STATIC
DWORD
InitFromFile(
        VOID
    );

VOID
Usage(
  VOID
 );

typedef enum _CMD_E *PCMD_E;

VOID
GetCmdCode(
  LPBYTE pCmd,
  PCMD_E pCmd_e
 );

typedef enum _CMD_E {
   REG_NAME = 0,
   QUERY_NAME,
   DEL_NAME,
   GET_VERS_CTR_VAL,
   GET_MAPS,
   GET_MAPS_OLD,
   GET_STATS,
   GET_STATS_OLD,
   PUSH_TRIGGER,
   PULL_TRIGGER,
   STATIC_INIT,
   DO_CC,
   DO_SCV,
   DEL_RANGE_RECS,
   TOMBSTONE_RANGE_RECS,
   PULL_RANGE_RECS,
   GET_RECS_BY_NAME,
   GET_RECS_BY_VERS,
   BACKUP_DB,
   RESTORE_DB,
//   RESTORE_DB_OLD,
   RESET_COUNTERS,
   COUNT_DB_RECS,
   GET_WINS_INFO,
   SEARCH_DB,
   GET_DOMAIN_NAMES,
   DEL_WINS,
   CONNECT_WINS,
   WINS_ADD,
   MENU,
   NOMENU,
   EXIT,
   LAST_PSS_ENTRY,
   GET_MAPS_VERBOSE,
   REL_NAME,
   MOD_NAME,
   SYNC_DB,
   CHANGE_THDS,
   SET_PRIORITY_CLASS,
   MEM_DUMP,
   BS,
   SS,
   TERM_WINS,
   LAST_ENTRY,
   INVALID_VALUE,
   CREATE_LMHOSTS,
   INIT_FROM_FILE
 } CMD_E, *PCMD_E;

static char ProgramName[MAX_PATH+1] ;

struct {
    LPSTR SwitchName;
    LPSTR ShortName;
    ULONG SwitchValue;
    LPSTR SwitchInformation;

} CommandSwitchList[] = {
    { "REGNAME", "RN", REG_NAME,
          "Register a name" },
    { "QUERYNAME", "QN", QUERY_NAME,
          "Query a name"  },
    { "DELNAME", "DN", DEL_NAME,
          "Delete a name" },
    { "GETVERSCTRVAL", "GV", GET_VERS_CTR_VAL,
          "Get the current version counter value" },
    { "GETMAPS", "GM", GET_MAPS,
          "Get the Owner Id to Maximum Version Number mappings" },
    { "GETMAPSWINS3.5", "GMO", GET_MAPS_OLD,
          "Get the Owner Id to Maximum Version Number mappings (for 3.5 WINS server)" },
    { "GETSTATS", "GST", GET_STATS,
          "Get WINS statistics" },
    { "GETSTATSWINS3.5", "GSTO", GET_STATS_OLD,
          "Get WINS statistics (for 3.5 WINS server)" },
    { "PUSHTRIGGER", "PUSHT", PUSH_TRIGGER,
          "Send a push trigger to another WINS" },
    { "PULLTRIGGER", "PULLT", PULL_TRIGGER,
          "Send a pull trigger to another WINS" },
    { "STATICINIT", "SI", STATIC_INIT,
          "Statically initialize the WINS" },
    { "CONSISTENCY_CHECK", "CC", DO_CC,
          "Initiate consistency check on the WINS - HIGH OVERHEAD OPERATION" },
    { "SCAVENGING", "SC", DO_SCV,
          "Initiate scavenging on the WINS" },
    { "DELRANGEOFRECS", "DRR", DEL_RANGE_RECS,
          "Delete all or a range of records" },
    { "TOMBSTONERANGEOFRECS", "TRR", TOMBSTONE_RANGE_RECS,
          "Tombstone all or a range of records(max 50 at a time)" },
    { "PULLRANGERECS", "PRR", PULL_RANGE_RECS,
          "Pull all or a range of records from another WINS" },
    { "GETRECSBYNAME", "GRBN", GET_RECS_BY_NAME,
          "Get records by name" },
    { "GETRECSBYVERS", "GRBV", GET_RECS_BY_VERS,
          "Get Records by version numbers" },
    { "BACKUP", "BK", BACKUP_DB,
          "Backup the database" },
    { "RESTORE", "RS", RESTORE_DB,
          "Restore the database" },
//    { "RESTORE_OLD", "RSO", RESTORE_DB_OLD,
//          "Restore the db (created by a pre-SUR WINS" },
    { "RESETCOUNTERS", "RC", RESET_COUNTERS,
          "Reset WINS counters" },
    { "COUNTRECS", "CR", COUNT_DB_RECS,
          "Count the number of records in the database" },
    { "GETWINSINFO", "GI", GET_WINS_INFO,
          "Get Inforomation about WINS" },
    { "SEARCHDB", "SDB", SEARCH_DB,
          "Search the database" },
    { "GETDOMAINNAMES", "GD", GET_DOMAIN_NAMES,
          "Get domain names" },
    { "DELWINS", "DW", DEL_WINS,
          "Delete WINS records and info." },
    { "CONWINS", "CW", CONNECT_WINS,
          "Connect Wins" },
    { "WINSADD", "WA", WINS_ADD,
          "Get Address of current Wins" },
    { "MENU", "ME", MENU,
          "SHOW MENU" },
    { "NOMENU", "NOME", NOMENU,
          "DO NOT SHOW MENU" },
//
// NOTE: Any Option below and including "BREAK" will not be displayed
// with _PSS_RELEASE Defined
//
    { "EXIT", "EX", EXIT,
          "Terminate winscl" },
    { NULL, NULL, LAST_PSS_ENTRY,
          "PSS End Marker" },
    { "GETMAPS_VERB", "GM_V", GET_MAPS_VERBOSE,
          "Get the Owner Id to Max. Vers. No. mappings" },
    { "RELEASENAME", "RLN", REL_NAME,
          "Release a name" },
    { "MODIFYNAME", "MN", MOD_NAME,
          "Modify Name" },
    { "SYNCDB", "SDB", SYNC_DB,
          "Sync. up the db of WINS" },
    { "CHANGETHDS", "CT", CHANGE_THDS,
          "Change the no. of worker threads (query threads)" },
    { "SETPRIORITYCLASS", "SPC", SET_PRIORITY_CLASS,
          "Set the priority class of WINS" },
    { "MEMDUMP", "MD", MEM_DUMP,
          "DUMP MEMORY TO FILE ON WINS MACHINE" },
    { "BS", "BS", BS,
          "MAY DISRUPT OPERATION OF WINS" },
    { "SS", "SS", SS,
          "NOOP" },
    { "TERMWINS", "TW", TERM_WINS,
          "TERMINATE WINS" },

    { NULL, NULL, LAST_ENTRY,
          "End Marker" }
   };

#define WINSCLENH  TEXT("winsclenh")
BOOL    fEnhMode = FALSE;
handle_t                BindHdl;
/////////////
#include <sys\types.h>
#include <sys\stat.h>
FILE *spDbgFile;
FILE *spDbgFile2;
FILE *spServers;
typedef struct {
     DWORD NoOfOwners;
     struct {
       DWORD OwnId;
       DWORD IpAdd;
       CHAR  asIpAdd[20];
       WINSINTF_VERS_NO_T VersNo;
       BOOL  fNameNotFound;
       BOOL  fCommFail;
       } Maps[30];
         } WINS_INFO, *PWINS_INFO;

typedef  struct {
     char Name[18];
     BOOL fProb;
  } NAME_INFO, *PNAME_INFO;

STATUS
GetWinsInfo(
     PWINS_INFO  pWinsInfo
    );

VOID
sync(
  VOID
  );

VOID
GetFullName(
        LPBYTE pName,
        DWORD  SChar,
        PWINSINTF_RECORD_ACTION_T pRecAction
         );
BOOL
ReadNameFile(
  PNAME_INFO  *ppFileInfo,
  LPDWORD pNoOfNames,
  LPBYTE pNameOfFile
);

BOOL
BindToWins(
  LPBYTE asIpAdd,
  PWINSINTF_BIND_DATA_T    pBindData,
  handle_t                *pBindHdl
 );

#define SUCCESS 0
#define NAME_NOT_FOUND 1
#define FAILURE 2

DWORD
QueryWins (
 LPBYTE pName,
 PWINSINTF_RECORD_ACTION_T pRecAction,
 PWINSINTF_RECORD_ACTION_T *ppRecAction
 );

VOID
StoreName(
 PWINSINTF_RECORD_ACTION_T pRecAction,
 LPBYTE   pName
 );

/////////////////

_cdecl
main(int argc, char **argv)
{


        DWORD Status;
        WINSINTF_RECORD_ACTION_T RecAction;
        DWORD Choice;
        BYTE  String[80];
        SYSTEMTIME SystemTime;
        BYTE tgtadd[50];
        TCHAR NmsAdd[50];
        WINSINTF_ADD_T        WinsAdd;
        WINSINTF_ADD_T        OwnAdd; //address of WINS owning records in the db
        WINSINTF_RESULTS_T Results;
        WINSINTF_RESULTS_NEW_T ResultsN;
        BOOL                fExit = FALSE;
        DWORD                 i;
        WINSINTF_RECTYPE_E        TypOfRec_e;
        WINSINTF_STATE_E        State_e;
        DWORD                        Dynamic;
        struct in_addr                InAddr;
        WINSINTF_VERS_NO_T        MinVersNo, MaxVersNo;
        DWORD                        TotalCnt = 0;
        BOOL                        fCountRec = FALSE;
        WINSINTF_BIND_DATA_T        BindData;
        BOOL                        fIncremental;
        PWINSINTF_RECORD_ACTION_T pRecAction;
        FILE  *pFileU = NULL;
        FILE  *pFileO = NULL;
        WINSINTF_RECS_T Recs;
        BOOL    fFileInited = FALSE;
        LPBYTE  *ppStr = argv;
        DWORD   NoOfChars;
        CMD_E Cmd_e = GET_MAPS;
        BOOL  fInteractive = TRUE;
        DWORD   Access;

try
{

        NoOfChars = GetEnvironmentVariable(WINSCLENH, (LPTSTR)String, sizeof(String)/sizeof(TCHAR));
        //wprintf(L"Environmental string is %s\n", String);
        if ((NoOfChars == 1) && !lstrcmpi((LPTSTR)String, TEXT("1")))
        {
          fEnhMode = TRUE;
        }

        sTmpVersNo.LowPart = 1;
        sTmpVersNo.HighPart = 0;


LABEL:
        if ((argc >= 2) && (!_strcmpi(*(ppStr + 1), "-?")))
        {
           Usage();
           return(1);
        }

        if (argc == 1)
        {
        printf("TCP/IP or named pipe. Enter 1 for TCP/IP or 0 for named pipe -- ");
        scanf("%d", &Choice);
        }
        else
        {
          if (!_strcmpi (*(ppStr + 1), "T"))
          {
             Choice = 1;
          }
          else
          {
            if (!_strcmpi (*(ppStr + 1), "N"))
            {
               Choice = 2;
            }
            else
            {
              BOOL fUsage = FALSE;
              TCHAR UserName[100];
              DWORD UserNameSize = sizeof(UserName)/sizeof(TCHAR);
              if (!GetUserName(UserName, &UserNameSize))
              {
                   fUsage = TRUE;
              }
              else
              {
                if (!lstrcmpi(UserName, TEXT("pradeepb")))
                {

                  if (!_strcmpi (*(ppStr + 1), "SYNC") || !_strcmpi(*(ppStr + 1), "SYNCB"))
                  {
                      if (!_strcmpi(*(ppStr + 1), "SYNCB"))
                      {
                        if ((spDbgFile = fopen("nmfl.dbg", "w")) == NULL)
                        {
                          return 1;
                        }
                        if ((spDbgFile2 = fopen("nmfls.dbg", "w")) == NULL)
                        {
                          return 1;
                        }
                      }
                      else
                      {
                       spDbgFile = stdout;
                       spDbgFile2 = stdout;
                      }
                     sync();
                     return 1;
                 }
                 else
                 {
                     fUsage = TRUE;
                 }
                }
                else
                {
                    fUsage = TRUE;
                }
              }
              if (fUsage)
              {
                Usage();
                return(1);
              }
            }
          }
        }
          if (Choice == 1)
          {
           printf("Address of Nameserver to contact-- ");
           //scanf("%s", NmsAdd);
           wscanf(L"%s", NmsAdd);
           BindData.fTcpIp = TRUE;
          }
          else
          {
                  printf("UNC name of machine-- ");
                  wscanf(L"%s", NmsAdd);
                  BindData.fTcpIp = FALSE;
                BindData.pPipeName =  (LPBYTE)TEXT("\\pipe\\WinsPipe");
          }
          BindData.pServerAdd = (LPBYTE)NmsAdd;

          BindHdl = WinsBind(&BindData);
          if (BindHdl == NULL)
          {
                printf("Unable to bind to %s\n", NmsAdd);
                //wprintf(L"Unable to bind to %s\n", NmsAdd);
                goto LABEL;
          }
          //find out what type of access do we have
          Access = WINS_NO_ACCESS;
          Status = WinsCheckAccess(BindHdl, &Access);
          if (WINSINTF_SUCCESS == Status) {
              printf("*** You have %s access to this server ***\n",
                      (Access ? (Access == WINS_CONTROL_ACCESS ? "Read and Write":"Read Only")
                             : "No"));

          }

    while(!fExit)
    {
        BYTE  Cmd[40];
        if ((argc == 3) && (Cmd_e != INVALID_VALUE))
        {
             GetCmdCode(*(ppStr + 2), &Cmd_e);
             argc = 0;
             fInteractive = FALSE;
        }
        else
        {
         DWORD LastEntry;
         if (fInteractive)
         {
           LastEntry = (fEnhMode ? LAST_ENTRY : LAST_PSS_ENTRY);
           for (Cmd_e = 0; Cmd_e < (CMD_E)LastEntry; Cmd_e++)
           {
             if (CommandSwitchList[Cmd_e].ShortName != NULL)
             {
               printf("%s-%s\n", CommandSwitchList[Cmd_e].ShortName,
                        CommandSwitchList[Cmd_e].SwitchInformation);
             }
           }
         }
         printf("Command -- ");
         scanf("%s", Cmd);
         GetCmdCode(Cmd, &Cmd_e);
        }
        if (Cmd_e == COUNT_DB_RECS)
        {
                Cmd_e = GET_RECS_BY_VERS;
                fCountRec = TRUE;
        }

        switch(Cmd_e)
        {
                case(REG_NAME):

                        GetNameInfo(&RecAction, WINSINTF_E_INSERT);
                        RecAction.Cmd_e      = WINSINTF_E_INSERT;
                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl,&pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                WinsFreeMem(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                WinsFreeMem(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;
                case(QUERY_NAME):
                    GetNameInfo(&RecAction, WINSINTF_E_QUERY);
                    RecAction.Cmd_e      = WINSINTF_E_QUERY;
                    pRecAction = &RecAction;
                    Status = WinsRecordAction(BindHdl, &pRecAction);
                    printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                    if (Status == WINSINTF_SUCCESS)
                    {
                       printf("Name=(%s)\nNodeType=(%d)\nState=(%s)\nTimeStamp=(%.19s)\nOwnerId=(%d)\nType Of Rec=(%s)\nVersion No (%x %x)\nRecord is (%s)\n",
                            pRecAction->pName,
                            pRecAction->NodeTyp,
                            pRecAction->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRecAction->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE",
                            asctime(localtime(&(pRecAction->TimeStamp))),
                            pRecAction->OwnerId,
                            (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE) ? "UNIQUE" : (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" :
(pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",

                            pRecAction->VersNo.HighPart,
                            pRecAction->VersNo.LowPart,
                            pRecAction->fStatic ? "STATIC" : "DYNAMIC"
                                    );
                            if (
                            (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE)
                                            ||
                            (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                              )
                            {

                               InAddr.s_addr = htonl(pRecAction->Add.IPAdd);
                               printf("Address is (%s)\n", inet_ntoa(InAddr));
                            }
                            else
                            {
                               for (i=0; i<pRecAction->NoOfAdds; )
                               {
                                  InAddr.s_addr = htonl((pRecAction->pAdd +i++)->IPAdd);
                                  printf("Owner is (%s); ", inet_ntoa(InAddr));
                                  InAddr.s_addr = htonl((pRecAction->pAdd + i++)->IPAdd);
                                  printf("Member is (%s)\n", inet_ntoa(InAddr));
                               }
                            }

                    }
                    else
                    {
                            if (Status == WINSINTF_FAILURE)
                            {
                                    printf("No such name in the database\n");
                            }
                    }
                    if (RecAction.pName != NULL)
                    {
                            LocalFree(RecAction.pName);
                    }
                    if (RecAction.pAdd != NULL)
                    {
                            LocalFree(RecAction.pAdd);
                    }
                    WinsFreeMem(pRecAction);
                    break;

                case(REL_NAME):
                        GetNameInfo(&RecAction, WINSINTF_E_RELEASE);
                        RecAction.Cmd_e      = WINSINTF_E_RELEASE;
                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl, &pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                LocalFree(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                LocalFree(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;

                //
                // Modify a record (timestamp, flag byte)
                //
                case(MOD_NAME):
                        GetNameInfo(&RecAction, WINSINTF_E_MODIFY);
                        RecAction.Cmd_e      = WINSINTF_E_MODIFY;

#if 0
                        //
                        // Get the input values
                        //
                        time((time_t *)&RecAction.TimeStamp);
#endif


                        printf("Unique/Normal Group record to a Special/Multihomed record or vice-versa DISALLOWED\n");
                        printf("Type(1-Norm. Grp;2-Spec. Grp.;3-Multihomed; Any other-Unique -> ");
                        scanf("%d", &TypOfRec_e);

                        if (TypOfRec_e > 3 || TypOfRec_e < 1)
                        {
                                TypOfRec_e = 0;
                        }
                        RecAction.TypOfRec_e = TypOfRec_e;

                        if ((TypOfRec_e != 1) && (TypOfRec_e != 2))
                        {
                            printf("Node Type -- P-node (0), H-node (1), B-node (2),default - P node -- ");
                           scanf("%d", &Choice);
                           switch(Choice)
                           {
                                default:
                                case(0):
                                        RecAction.NodeTyp = WINSINTF_E_PNODE;
                                        break;
                                case(1):
                                        RecAction.NodeTyp = WINSINTF_E_HNODE;
                                        break;
                                case(2):
                                        RecAction.NodeTyp = WINSINTF_E_BNODE;
                                        break;
                            }
                        }
                        else
                        {
                                RecAction.NodeTyp = 0;
                        }
                        printf("State-(1-RELEASED;2-TOMBSTONE;3-DELETE;Any other-ACTIVE -> ");
                        scanf("%d", &State_e);

                        if (State_e != 1 && State_e != 2 && State_e != 3)
                        {
                                State_e = 0;
                        }

                        RecAction.State_e = State_e;

                        printf("Do you want it to be dynamic? 1 - yes. ");
                        scanf("%d", &Dynamic);
                        if (Dynamic == 1)
                        {
                                RecAction.fStatic = 0;
                        }
                        else
                        {
                                RecAction.fStatic = 1;
                        }

                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl, &pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                LocalFree(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                LocalFree(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;

                //
                // Delete a record
                //
                case(DEL_NAME):
                        GetNameInfo(&RecAction, WINSINTF_E_DELETE);
                        RecAction.Cmd_e      = WINSINTF_E_DELETE;
                        RecAction.State_e      = WINSINTF_E_DELETED;
                        pRecAction = &RecAction;
                        Status = WinsRecordAction(BindHdl, &pRecAction);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (RecAction.pName != NULL)
                        {
                                LocalFree(RecAction.pName);
                        }
                        if (RecAction.pAdd != NULL)
                        {
                                LocalFree(RecAction.pAdd);
                        }
                        WinsFreeMem(pRecAction);
                        break;

                //
                // Get Status
                //
                case(GET_VERS_CTR_VAL):


                        {
                                BYTE NmAdd[30];
                                Results.AddVersMaps[0].Add.Len   = 4;
                                Results.AddVersMaps[0].Add.Type  = 0;
                                printf("Address of Nameserver (for max. version no)--");
                                scanf("%s", NmAdd);
                                Results.AddVersMaps[0].Add.IPAdd =
                                        ntohl(inet_addr(NmAdd));

                                Results.WinsStat.NoOfPnrs = 0;
                                Results.WinsStat.pRplPnrs = NULL;
                                Status = WinsStatus(BindHdl, WINSINTF_E_ADDVERSMAP,
                                                        &Results);
                                printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                                if (Status == WINSINTF_SUCCESS)
                                {
                                        printf("IP Address - (%s) - Max. Vers. No - (%x %x)\n",
                                         NmAdd,
                                         Results.AddVersMaps[0].VersNo.HighPart,
                                         Results.AddVersMaps[0].VersNo.LowPart
                                              );
                                }

                        }
                        break;
                case(GET_MAPS_OLD):
                        Results.WinsStat.NoOfPnrs = 0;
                        Results.WinsStat.pRplPnrs = 0;
                        (VOID)GetStatus(TRUE, &Results, FALSE, FALSE);
                        break;
                //
                // Get Statistics
                //
                case(GET_STATS_OLD):
#define        TMST  Results.WinsStat.TimeStamps
#define TIME_ARGS(x)        \
 TMST.x.wMonth, TMST.x.wDay, TMST.x.wYear, TMST.x.wHour, TMST.x.wMinute, TMST.x.wSecond

                        Results.WinsStat.NoOfPnrs = 0;
                        Results.WinsStat.pRplPnrs = 0;

                        Status = WinsStatus(BindHdl, WINSINTF_E_STAT, &Results);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status == WINSINTF_SUCCESS)
                        {
                                printf("TIMESTAMPS\n");

                                printf("WINS STARTED ON %d/%d/%d at %d hrs %d mts %d secs\n",

                                TMST.WinsStartTime.wMonth,
                                TMST.WinsStartTime.wDay,
                                TMST.WinsStartTime.wYear,
                                TMST.WinsStartTime.wHour,
                                TMST.WinsStartTime.wMinute,
                                TMST.WinsStartTime.wSecond
                                        );

                                printf("LAST INIT OF DB on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastInitDbTime)
                                );
                                printf("LAST PLANNED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastPScvTime)
                                );

                                printf("LAST ADMIN TRIGGERED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastATScvTime)
                                );

                                printf("LAST REPLICAS TOMBSTONES SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastTombScvTime)
                                );

                                printf("LAST OLD REPLICAS VERIFICATION (SCV) on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(LastVerifyScvTime)
                                );

                                printf("LAST PLANNED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMST.LastPRplTime.wMonth,
                                TMST.LastPRplTime.wDay,
                                TMST.LastPRplTime.wYear,
                                TMST.LastPRplTime.wHour,
                                TMST.LastPRplTime.wMinute,
                                TMST.LastPRplTime.wSecond
                                        );

                                printf("LAST ADMIN TRIGGERED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMST.LastATRplTime.wMonth,
                                TMST.LastATRplTime.wDay,
                                TMST.LastATRplTime.wYear,
                                TMST.LastATRplTime.wHour,
                                TMST.LastATRplTime.wMinute,
                                TMST.LastATRplTime.wSecond
                                        );

                                printf("LAST RESET OF COUNTERS on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGS(CounterResetTime)
                                );


                                printf("COUNTERS\n");
                                printf("\n# of U and G Registration requests = (%d %d)\n# Of Successful/Failed Queries = (%d/%d)\n# Of U and G Refreshes = (%d %d)\n# Of Successful/Failed Releases = (%d/%d)\n# Of U. and G. Conflicts = (%d %d)\n",
                                Results.WinsStat.Counters.NoOfUniqueReg,
                                Results.WinsStat.Counters.NoOfGroupReg,
                                Results.WinsStat.Counters.NoOfSuccQueries,
                                Results.WinsStat.Counters.NoOfFailQueries,
                                Results.WinsStat.Counters.NoOfUniqueRef,
                                Results.WinsStat.Counters.NoOfGroupRef,
                                Results.WinsStat.Counters.NoOfSuccRel,
                                Results.WinsStat.Counters.NoOfFailRel,
                                Results.WinsStat.Counters.NoOfUniqueCnf,
                                Results.WinsStat.Counters.NoOfGroupCnf
                                      );
                        }

                        if (Results.WinsStat.NoOfPnrs)
                        {
                          printf("WINS partner --\t# of Succ. Repl--\t # of Comm Fails\n");
                          for (i =0; i < Results.WinsStat.NoOfPnrs; i++)
                          {
                                InAddr.s_addr = htonl(
                                  (Results.WinsStat.pRplPnrs + i)->Add.IPAdd);
                                printf("%s\t\t%d\t\t%d\n",
                                  inet_ntoa(InAddr),
                                  (Results.WinsStat.pRplPnrs + i)->NoOfRpls,
                                  (Results.WinsStat.pRplPnrs + i)->NoOfCommFails
                                                 );
                         }

                         WinsFreeMem(Results.WinsStat.pRplPnrs);


                        }
                        break;


                case(GET_STATS):

#define        TMSTN  ResultsN.WinsStat.TimeStamps
#define TIME_ARGSN(x)        \
 TMSTN.x.wMonth, TMSTN.x.wDay, TMSTN.x.wYear, TMSTN.x.wHour, TMSTN.x.wMinute, TMSTN.x.wSecond

                        ResultsN.WinsStat.NoOfPnrs = 0;
                        ResultsN.WinsStat.pRplPnrs = NULL;
                        ResultsN.pAddVersMaps = NULL;
                        Status = WinsStatusNew(BindHdl, WINSINTF_E_STAT, &ResultsN);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status == WINSINTF_SUCCESS)
                        {
                                printf("TIMESTAMPS\n");
                                printf("WINS STARTED ON %d/%d/%d at %d hrs %d mts %d secs\n",

                                TMSTN.WinsStartTime.wMonth,
                                TMSTN.WinsStartTime.wDay,
                                TMSTN.WinsStartTime.wYear,
                                TMSTN.WinsStartTime.wHour,
                                TMSTN.WinsStartTime.wMinute,
                                TMSTN.WinsStartTime.wSecond
                                        );

                                printf("LAST INIT OF DB on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastInitDbTime)
                                );
                                printf("LAST PLANNED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastPScvTime)
                                );

                                printf("LAST ADMIN TRIGGERED SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastATScvTime)
                                );

                                printf("LAST REPLICAS TOMBSTONES SCV on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastTombScvTime)
                                );

                                printf("LAST OLD REPLICAS VERIFICATION (SCV) on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(LastVerifyScvTime)
                                );

                                printf("LAST PLANNED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMSTN.LastPRplTime.wMonth,
                                TMSTN.LastPRplTime.wDay,
                                TMSTN.LastPRplTime.wYear,
                                TMSTN.LastPRplTime.wHour,
                                TMSTN.LastPRplTime.wMinute,
                                TMSTN.LastPRplTime.wSecond
                                        );

                                printf("LAST ADMIN TRIGGERED REPLICATION on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TMSTN.LastATRplTime.wMonth,
                                TMSTN.LastATRplTime.wDay,
                                TMSTN.LastATRplTime.wYear,
                                TMSTN.LastATRplTime.wHour,
                                TMSTN.LastATRplTime.wMinute,
                                TMSTN.LastATRplTime.wSecond
                                        );

                                printf("LAST RESET OF COUNTERS on %d/%d/%d at %d hrs %d mts %d secs\n",
                                TIME_ARGSN(CounterResetTime)
                                );


                                printf("COUNTERS\n");
                                printf("\n# of U and G Registration requests = (%d %d)\n# Of Successful/Failed Queries = (%d/%d)\n# Of U and G Refreshes = (%d %d)\n# Of Successful/Failed Releases = (%d/%d)\n# Of U. and G. Conflicts = (%d %d)\n",
                                ResultsN.WinsStat.Counters.NoOfUniqueReg,
                                ResultsN.WinsStat.Counters.NoOfGroupReg,
                                ResultsN.WinsStat.Counters.NoOfSuccQueries,
                                ResultsN.WinsStat.Counters.NoOfFailQueries,
                                ResultsN.WinsStat.Counters.NoOfUniqueRef,
                                ResultsN.WinsStat.Counters.NoOfGroupRef,
                                ResultsN.WinsStat.Counters.NoOfSuccRel,
                                ResultsN.WinsStat.Counters.NoOfFailRel,
                                ResultsN.WinsStat.Counters.NoOfUniqueCnf,
                                ResultsN.WinsStat.Counters.NoOfGroupCnf
                                      );
                        }

                        if (ResultsN.WinsStat.NoOfPnrs)
                        {
                          printf("WINS partner --\t# of Repl  --\t # of Comm Fails\n");
                          for (i =0; i < ResultsN.WinsStat.NoOfPnrs; i++)
                          {
                                InAddr.s_addr = htonl(
                                  (ResultsN.WinsStat.pRplPnrs + i)->Add.IPAdd);
                                printf("%s\t\t%d\t\t%d\n",
                                  inet_ntoa(InAddr),
                                  (ResultsN.WinsStat.pRplPnrs + i)->NoOfRpls,
                                  (ResultsN.WinsStat.pRplPnrs + i)->NoOfCommFails
                                                 );
                         }

                         WinsFreeMem(ResultsN.pAddVersMaps);
                         WinsFreeMem(ResultsN.WinsStat.pRplPnrs);
                        }
                        break;


                case(PUSH_TRIGGER):
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address ? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        printf("Want propagation (default - none) Input 1 for yes? ");
                        scanf("%d", &Choice);
                        Status = WinsTrigger(BindHdl, &WinsAdd, Choice == 1 ?
                                        WINSINTF_E_PUSH_PROP : WINSINTF_E_PUSH);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(PULL_TRIGGER):
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address ? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        Status = WinsTrigger(BindHdl, &WinsAdd, WINSINTF_E_PULL);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(STATIC_INIT):
                        printf("Do you wish to specify a data file (1 - yes) -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                                WCHAR        String[80];
                BOOL    fDel;
                                printf("Enter full file path -- ");
                                wscanf(L"%s", String);
                printf("Delete file after use. Input 1 for yes 0 for no -- ");
                scanf("%d", &Choice);
                fDel = Choice == 1 ? TRUE : FALSE;
                                Status = WinsDoStaticInit(BindHdl, String, fDel);
                        }
                        else
                        {
                                Status = WinsDoStaticInit(BindHdl, (WCHAR *)NULL, FALSE);
                        }

                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(DO_CC):
                        {
                          WINSINTF_SCV_REQ_T ScvReq;
#if 0
                          printf("Scavenging/consistency check\nInput 0 for General; 1 for Consistency Chk -- ");
                          scanf("%d", &Choice);
                          ScvReq.Opcode_e = (Choice == 0) ? WINSINTF_E_SCV_GENERAL : WINSINTF_E_SCV_VERIFY;
#endif
                          ScvReq.Opcode_e = WINSINTF_E_SCV_VERIFY;
#if 0
                          if (Choice != 0)
#endif
                          {
                            printf("Consistency Check all or those older than verify interval\nCAUTION: CONSISTENCY CHECKING ALL REPLICAS IS A NETWORK AND RESOURCE INTENSIVE OPERATION\nInput 1 for consistency checking all.\nAny other for those older than verify interval -- ");
                            scanf("%d", &Choice);
                            ScvReq.Age      = (Choice == 1) ? 0 : Choice;
                          }

#if 0
                          if (ScvReq.Opcode_e != WINSINTF_E_SCV_GENERAL)
#endif
                          {
                             printf("Do you want to override WINS checking for overload condition ?\nOverload condition is  Consistency Check command being repeated within a duration of 1 hour.\nInput 1 for yes. Any other no. will not affect WINS checking  -- ");
                          scanf("%d", &Choice);
                          }
#if 0
                          else
                          {
                             Choice = 0;
                             printf("Do you want to override WINS safety checks as regards tombstone deletion.\nWINS normally does not delete tombstones until it has been up and running\nfor a certain duration of time\nInput 1 for overriding the safety checks. Otherwise, input any other no. -- ");

                          }
                          ScvReq.fForce   = (Choice == 1) ? TRUE : FALSE;
#endif
                          ScvReq.fForce   = (Choice == 1) ? TRUE : FALSE;
                          Status = WinsDoScavengingNew(BindHdl, &ScvReq);
                          printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        }
                        break;
                case(DO_SCV):
                        Status = WinsDoScavenging(BindHdl );
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(DEL_RANGE_RECS):
                        printf("Address of Owner Wins -- ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd = ntohl(inet_addr(tgtadd));
                        WinsAdd.Len   = 4;
                        WinsAdd.Type  = 0;

                        printf("Min. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MinVersNo.HighPart, &MinVersNo.LowPart);
                        printf("Max. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                        Status = WinsDelDbRecs(BindHdl, &WinsAdd, MinVersNo, MaxVersNo);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(TOMBSTONE_RANGE_RECS):
                      printf("Address of Owner Wins -- ");
                      scanf("%s", tgtadd);
                      WinsAdd.IPAdd = ntohl(inet_addr(tgtadd));
                      WinsAdd.Len   = 4;
                      WinsAdd.Type  = 0;

                      printf("Min. Vers. No (<high part> <low part> or <0 0> for all -- ");
                      scanf("%lx %lx", &MinVersNo.HighPart, &MinVersNo.LowPart);
                      printf("Max. Vers. No (<high part> <low part> or <0 0> for all -- ");
                      scanf("%lx %lx", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                      Status = WinsTombstoneDbRecs(BindHdl,&WinsAdd, MinVersNo, MaxVersNo);
                      printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                      break;

                case(PULL_RANGE_RECS):
                        printf("Address of Wins to pull from -- ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd = ntohl(inet_addr(tgtadd));
                        WinsAdd.Len   = 4;

                        printf("Address of Wins whose recs are to be pulled -- ");
                        scanf("%s", tgtadd);
                        OwnAdd.IPAdd = ntohl(inet_addr(tgtadd));
                        OwnAdd.Len   = 4;
                        OwnAdd.Type  = 0;

                        printf("Min. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MinVersNo.HighPart, &MinVersNo.LowPart);
                        printf("Max. Vers. No (<high part> <low part> -- ");
                        scanf("%d %d", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                        printf("NOTE: If the local WINS contains any record with a VERS. No. > Min. Vers. and < Max. Vers. No, it will be deleted prior to pulling \n");
                        printf("it will be deleted prior to pulling the range\n");
                        printf("Process 1 for yes, any other to quit -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                          Status = WinsPullRange(BindHdl, &WinsAdd, &OwnAdd, MinVersNo,
                                                        MaxVersNo);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        }
                        break;

                case(GET_RECS_BY_VERS):
                  {
                    FILE        *pFile;
                    DWORD        Len;
                    BOOL        fSetFilter;

                        pFile = NULL;
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address of owner WINS? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));


                        if (!fCountRec)
                        {
                            printf("Want to specify range -- (input 1) or all (default) -- ");
                        }
                        else
                        {
                            printf("Want to specify range -- (input 1) or count all (default) -- ");
                        }
                        scanf("%d", &Choice);
                        if (Choice != 1)
                        {
                                MinVersNo.LowPart = MinVersNo.HighPart = 0;
                                MaxVersNo.LowPart = MaxVersNo.HighPart = 0;
                        }
                        else
                        {
                                printf("Min. Vers. No (<high part> <low part> -- ");
                                scanf("%d %d", &MinVersNo.HighPart, &MinVersNo.LowPart);
                                printf("Max. Vers. No (<high part> <low part> -- ");
                                scanf("%d %d", &MaxVersNo.HighPart, &MaxVersNo.LowPart);

                        }

                        if (!fCountRec)
                        {
                           printf("Use filter (1 for yes, 0 for no) -- ");
                           scanf("%d", &Choice);
                           if (Choice == 1)
                           {
                                GetFilterName(String, &Len);
                                fSetFilter = TRUE;
                           }
                           else
                           {
                                fSetFilter = FALSE;
                           }
                           WantFile(&pFile);
                           if (pFile != NULL)
                           {
                                GetSystemTime(&SystemTime);
                                fprintf(pFile, "\n*******************************\n\n");
                                fprintf(pFile, "OWNER WINS = (%s); LOCAL DB OF WINS = (%s)\n", tgtadd, NmsAdd);
                                fprintf(pFile, "Time is %d:%d:%d on %d/%d/%d\n",
                                        SystemTime.wHour, SystemTime.wMinute,
                                        SystemTime.wSecond, SystemTime.wMonth,
                                        SystemTime.wDay, SystemTime.wYear);
                                fprintf(pFile, "*******************************\n\n");
                            }
                        }
                        Status = GetDbRecs(
                                        MinVersNo,
                                        MaxVersNo,
                                        &WinsAdd,
                                        tgtadd,
                                        fSetFilter,
                                        String,
                                        Len,
                                        FALSE,        //fAddFilter
                                        0,        //Address
                                        pFile,
                                        fCountRec
                                  );

                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);

                        if (pFile != NULL)
                        {
                                fclose(pFile);
                        }
                        break;

                 }
                case(BACKUP_DB):
                        printf(" Full (1) or Incremental (any other) -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                                fIncremental = FALSE;
                        }
                        else
                        {
                                fIncremental = TRUE;
                        }
                        printf("Backup file path -- ");
                        scanf("%s", String);

                        Status = WinsBackup(BindHdl, String, (short)fIncremental );

                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status != WINSINTF_SUCCESS)
                        {
                           printf("Check if the backup directory is empty. If not, cleanup and retry\n");
                        }
                        break;
                case(RESTORE_DB): {
                        DbVersion   Version;

                        printf("Which version of Databse do you want to restore?\n");
                        printf("Type 1 for NT3.51, 2 for NT4.0 and 3 for NT5.0 : ");
                        scanf("%d", &Version);
                        if ( Version <= DbVersionMin || Version >= DbVersionMax ) {
                            printf("Invalid choice..\n");
                            break;
                        }
                        printf("Backup file path -- ");
                        scanf("%s", String);
                        Status = WinsRestoreEx(String, Version);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                }
                case(CONNECT_WINS):
                        WinsUnbind(&BindData, BindHdl);
                        goto LABEL;
                        break;
                case(TERM_WINS):
                        printf("You sure ??? (yes - 1) ");
                        scanf("%d", &Choice);
                        if (Choice ==  1)
                        {
                                printf("Abrupt Termination ? (yes - 1) ");
                                scanf("%d", &Choice);
                                if (Choice == 1)
                                {
                                        Status = WinsTerm(BindHdl, TRUE);
                                }
                                else
                                {
                                        Status = WinsTerm(BindHdl, FALSE);
                                }
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        }
                        break;
                case(SET_PRIORITY_CLASS):
                        printf("Input Priority Class (1-High, any other-Normal) -- ");
                        scanf("%d", &Choice);
                        if (Choice == 1)
                        {
                                Choice = WINSINTF_E_HIGH;
                        }
                        else
                        {
                                Choice = WINSINTF_E_NORMAL;
                        }
                        Status = WinsSetPriorityClass(BindHdl, Choice);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(RESET_COUNTERS):
                        Status = WinsResetCounters(BindHdl);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(CHANGE_THDS):
                        printf("Print the new count of Nbt Threads (1 to %d) -- ", WINSTHD_MAX_NO_NBT_THDS);
                        scanf("%d", &Choice);
                        if ((Choice < 1) || (Choice > WINSTHD_MAX_NO_NBT_THDS))
                        {
                                printf("Wrong number \n");
                                break;
                        }
                        Status = WinsWorkerThdUpd(BindHdl, Choice);
                        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;
                case(WINS_ADD):
                        wprintf(L"%s\n", NmsAdd);
                        break;
                case(MENU):
                        fInteractive = TRUE;
                        break;
                case(NOMENU):
                        fInteractive = FALSE;
                        break;
                case(SYNC_DB):
                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address of WINS to sync up with? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        printf("Address of WINS whose records are to be retrieved ? ");
                        scanf("%s", tgtadd);
                        OwnAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        WinsSyncUp(BindHdl, &WinsAdd, &OwnAdd);
                        break;
                case(GET_WINS_INFO):

                        Status = WinsGetNameAndAdd(BindHdl, &WinsAdd, String);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        if (Status == WINSINTF_SUCCESS)
                        {
                                InAddr.s_addr = htonl(WinsAdd.IPAdd);
                                printf("Address is (%s)\nName is (%s)\n",
                                        inet_ntoa(InAddr), String);
                        }

                        break;
                case(SEARCH_DB):
                        {
                          DWORD Len;
                          BYTE  Add[30];
                          BOOL  fAddFilter;
                          DWORD AddFilter;
                          FILE  *pFile;

                          printf("Search by Address or Name (1 for Address, 0 for Name) --" );
                          scanf("%d", &Choice);
                          if (Choice == 1)
                          {
                                printf("Address (dotted decimal) -- ");
                                scanf("%s", Add);
                                AddFilter = ntohl(inet_addr(Add));
                                fAddFilter = TRUE;
                          }
                          else
                          {
                            GetFilterName(String, &Len);
                            fAddFilter = FALSE;
                          }

                          WantFile(&pFile);
                          if (pFile != NULL)
                          {
                                GetSystemTime(&SystemTime);
                                fprintf(pFile, "\n*******************************\n\n");
                                fprintf(pFile, "Searching Database of WINS with address = (%s)\n", NmsAdd);
                                fprintf(pFile, "Time is %d:%d:%d on %d/%d/%d\n",
                                        SystemTime.wHour, SystemTime.wMinute,
                                        SystemTime.wSecond, SystemTime.wMonth,
                                        SystemTime.wDay, SystemTime.wYear);
                                fprintf(pFile, "*******************************\n\n");
                          }
                          Results.WinsStat.NoOfPnrs = 0;
                          Results.WinsStat.pRplPnrs = 0;
                          if (GetStatus(FALSE, &Results, FALSE, TRUE) == WINSINTF_SUCCESS)
                          {
                                if (Results.NoOfOwners != 0)
                                {
                                         for ( i= 0; i < Results.NoOfOwners; i++)
                                         {
                                          InAddr.s_addr = htonl(
                                             Results.AddVersMaps[i].Add.IPAdd);

                                           printf("Searching records owned by %s\n",
                                               inet_ntoa(InAddr) );

                                           WinsAdd.Len   = 4;
                                           WinsAdd.Type  = 0;
                                           WinsAdd.IPAdd =
                                             Results.AddVersMaps[i].Add.IPAdd;

                                               MaxVersNo =
                                             Results.AddVersMaps[i].VersNo;

                                               MinVersNo.LowPart = 0;
                                               MinVersNo.HighPart = 0;

                                            Status = GetDbRecs(
                                                        MinVersNo,
                                                        MaxVersNo,
                                                        &WinsAdd,
                                                        inet_ntoa(InAddr),
                                                        TRUE,        //fSetFilter
                                                        String,
                                                        Len,
                                                        fAddFilter,
                                                        AddFilter,
                                                        pFile,  //pFile
                                                        FALSE  //fCountRec
                                                  );
                                           if (Status != WINSINTF_SUCCESS)
                                           {
                                                   break;
                                           }

                                        }
                                }
                          }
                         }
                        break;

                case(GET_DOMAIN_NAMES):
                        {
                          WINSINTF_BROWSER_NAMES_T Names;
                          PWINSINTF_BROWSER_INFO_T  pInfo;
                          PWINSINTF_BROWSER_INFO_T  pInfoSv;

                          DWORD i;

                          Names.pInfo = NULL;
                          Status = WinsGetBrowserNames(&BindData, &Names);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                          if (Status == WINSINTF_SUCCESS)
                          {
                                printf("No Of records returned are %d\n",
                                                Names.EntriesRead);
                                pInfoSv = pInfo = Names.pInfo;
                                for(i=0;  i < Names.EntriesRead; i++)
                                {
                                        printf("Name[%d] = %s\n",
                                                        i,
                                                        pInfo->pName
                                                );
                                        pInfo++;
                                }
                                WinsFreeMem(pInfoSv);
                          }
                        }
                        break;

                case(DEL_WINS):

                        WinsAdd.Len  = 4;
                        WinsAdd.Type = 0;
                        printf("Address of Wins to delete? ");
                        scanf("%s", tgtadd);
                        WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                        Status = WinsDeleteWins(BindHdl, &WinsAdd);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(CREATE_LMHOSTS):
                           if (GetStatus(FALSE, &Results, FALSE, TRUE) == WINSINTF_SUCCESS)
                           {
                                if (Results.NoOfOwners != 0)
                                {
                                         for ( i= 0; i < Results.NoOfOwners; i++)
                                         {
                                          Recs.pRow = NULL;

                                          InAddr.s_addr = htonl(
                                             Results.AddVersMaps[i].Add.IPAdd);

                                           printf(" Will get records owned by %s\n",
                                               inet_ntoa(InAddr) );

                                           WinsAdd.Len   = 4;
                                           WinsAdd.Type  = 0;
                                           WinsAdd.IPAdd =
                                             Results.AddVersMaps[i].Add.IPAdd;

                                               MaxVersNo =
                                             Results.AddVersMaps[i].VersNo;

                                               MinVersNo.LowPart = 0;
                                               MinVersNo.HighPart = 0;

                                           Status = WinsGetDbRecs(BindHdl, &WinsAdd,
                                                MinVersNo, MaxVersNo, &Recs);

                                           if (Status != WINSINTF_SUCCESS)
                                           {
                                                   break;
                                           }
                                           else
                                           {
                                             if ((pFileU == NULL) || (pFileO == NULL))
                                             {

                                                 pFileU = fopen(FILEU, "a");
                                                 if (pFileU == NULL)
                                                 {
                                                   printf("Could not open file %s for appending\n", FILEU);
                                                    break;
                                                 }

                                                 pFileO = fopen(FILEO, "a");
                                                 if (pFileO == NULL)
                                                 {
                                                  printf("Could not open file %s for appending\n", FILEO);
                                                  break;
                                                 }
                                              }
                                              else
                                              {
                                                 break;
                                              }
                                             }
                                             if(CreateFiles(&Recs, &WinsAdd, pFileU, pFileO)  == WINSINTF_SUCCESS)
                                              {
                                                fclose(pFileU);
                                                fclose(pFileO);
                                                pFileU = NULL;
                                                pFileO = NULL;
                                                fFileInited = TRUE;
                                              }

                                        }
                               }
                           }
                           else
                           {
                                printf("GetStatus failed\n");
                           }

                         break;
                case(INIT_FROM_FILE):
                           if (fFileInited)
                           {
                               if (InitFromFile() != WINSINTF_SUCCESS)
                               {
                                     printf("Init failed\n");
                               }
                           }
                           else
                           {
                                 printf("Use old files (0 for yes) -- ");
                                 scanf("%d", &Choice);
                                 if (Choice  == 0)
                                 {
                                   if (InitFromFile() != WINSINTF_SUCCESS)
                                   {
                                       printf("Init failed\n");
                                   }
                                 }
                                 else
                                 {
                                      printf("First create file\n");
                                 }
                            }
                        break;
                case(GET_RECS_BY_NAME):
                        {
                         PWINSINTF_ADD_T pWinsAdd = NULL;
                         BOOL    fAlloc = TRUE;
                         BYTE    Name[5];
                         BYTE    strAdd[20];
                         DWORD NoOfRecsDesired;
                         DWORD TypeOfRec;
                         DWORD Location = WINSINTF_BEGINNING;
                         printf ("Want to input Name (0 for yes, 1 for no) -- ");
                         scanf("%d", &Choice);
                         if (Choice == 0)
                         {
                           printf("First char non-printable 0 for no, 1 for yes -- ");
                           scanf("%d", &Choice);
                           if (Choice != 0)
                           {
                              printf("Input 1st char in hex -- ");
                              scanf("%x", &Name[0]);
                              Name[1] = (BYTE)NULL;
                              printf("Name is %s\n", Name);
                              RecAction.pName = Name;
                              RecAction.NameLen = 1;
                              fAlloc = FALSE;
                           }
                           else
                           {
                              GetNameInfo(&RecAction, WINSINTF_E_QUERY);
                           }
                         }
                         else
                         {
                             RecAction.pName = NULL;
                             RecAction.NameLen = 0;
                         }
                         printf("Start from beginning or end of db -- 0 for beginning, 1 for end -");
                         scanf("%d", &Choice);
                         if (Choice != 0)
                         {
                               Location = WINSINTF_END;
                         }

                         printf("Recs of all or of a particular owner (0 for all, or 1 for particular owner) -- ");
                         scanf("%d", &Choice);
                         if (Choice != 0)
                         {
                          WinsAdd.Len  = 4;
                          WinsAdd.Type = 0;
                          printf("Address of Wins whose records are to be retrieved? ");
                          scanf("%s", tgtadd);
                          WinsAdd.IPAdd  = ntohl(inet_addr(tgtadd));
                          pWinsAdd = &WinsAdd;
                         }
                         printf("Input - No Of Recs desired (Max is 5000 - for max input 0)  -- ");
                         scanf("%d", &NoOfRecsDesired);
                         printf("Only static (1), only dynamic (2) or both (4) -- ");
                         scanf("%d", &TypeOfRec);
                         if((TypeOfRec == 1) || (TypeOfRec == 2) || (TypeOfRec == 4))
                         {
                            BOOL fFilter = FALSE;
                            DWORD  AddFilter;
                            printf("Search for records based on IP Address (0 for no, 1 for yes) -- ");
                            scanf("%d", &Choice);

                            if ( Choice != 0)
                            {

                               fFilter = TRUE;
                               printf("Input IP address in dotted notation -- ");
                                printf("Address (dotted decimal) -- ");
                                scanf("%s", strAdd);
                                AddFilter = ntohl(inet_addr(strAdd));
                            }
                            Status = GetDbRecsByName(pWinsAdd, Location, RecAction.pName, RecAction.NameLen, NoOfRecsDesired, TypeOfRec, fFilter, AddFilter);
                            if (fAlloc && (RecAction.pName != NULL))
                            {
                                WinsFreeMem(RecAction.pName);
                            }
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                         }
                         else
                         {
                             printf("Wrong choice\n");

                         }
                        }
                        break;
                case(GET_MAPS):
                case(GET_MAPS_VERBOSE):
                        {
                        WINSINTF_RESULTS_NEW_T ResultsN;
                        Results.WinsStat.NoOfPnrs = 0;
                        Results.WinsStat.pRplPnrs = NULL;
                        (VOID)GetStatus(TRUE, (LPVOID)&ResultsN, TRUE,
                             Cmd_e == GET_MAPS ? TRUE : FALSE );
                        }
                        break;
                case(EXIT):
                        fExit = TRUE;
                        break;

                 case(MEM_DUMP):
                        printf("Mem. Dump - 2; Heap Dump -4; Que Items dump - 8; or combo  -- ");
                        scanf("%d", &Choice);
                        Status = WinsSetFlags(BindHdl, Choice);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        break;

                case(BS):
                        Status = WinsSetFlags(BindHdl, 1);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        printf("Status returned is (%d)\n", Status);
                        break;
                case(SS):
                        Status = WinsSetFlags(BindHdl, 0);
                        printf("Status returned (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
                        printf("Status returned is (%d)\n", Status);
                        break;


                case(INVALID_VALUE):
                        printf("Wrong cmd\n");
                        break;
          }
     }

        WinsUnbind(&BindData, BindHdl);
}
except(EXCEPTION_EXECUTE_HANDLER)
{
    printf("Execution exception encountered..\n");
}
        return(0);

}

VOID
GetNameInfo(
        PWINSINTF_RECORD_ACTION_T pRecAction,
        WINSINTF_ACT_E                  Cmd_e
         )
{
      BYTE tgtadd[30];
      BYTE Name[255];
      int Choice;
      int Choice2;
      DWORD LastChar;
      size_t Len;

      pRecAction->pAdd = NULL;
      pRecAction->NoOfAdds = 0;
      pRecAction->fStatic      = TRUE;

        printf("Name ? ");
        scanf("%s", Name);
        _strupr(Name);

        if ((Len = strlen(Name)) < 16)
        {
                printf("Do you want to input a 16th char (1 for yes, 0 for no) -- ");
                scanf("%d", &Choice);
                if (Choice)
                {
                        printf("16th char in hex -- ");
                        scanf("%x", &LastChar);
                        memset(&Name[Len], (int)' ',16-Len);
                        Name[15] = (BYTE)(LastChar & 0xff);
                        Name[16] = (CHAR)NULL;
                        Len = 16;
                }
                else {
                    memset(&Name[Len], (int)' ',16-Len);
                    Name[16] = (CHAR)NULL;
                    Len = 16;
                }
        }
        else
        {
            Name[16] = (CHAR)NULL;
            Len = 16;
        }

    printf("Scope - 1 for yes, 0 for no --");
    scanf("%d", &Choice);
    if (Choice == 1)
    {
        Name[Len] = '.';
        printf("Enter scope -- ");
        scanf("%s", &Name[Len + 1]);
        Len = strlen(Name);
    }

        if (Cmd_e == WINSINTF_E_INSERT)
        {

                Choice = 0;
                printf("TypeOfRec - Static(0), Dynamic(1) - Default Static -- ");
                scanf("%d", &Choice);
                if (1 == Choice) {
                    pRecAction->fStatic = FALSE;
                }
                Choice = 0;
                printf("TypeOfNode - U(0), Norm Grp (1), Spec Grp (2), Multihomed (3) default Unique -- ");
                scanf("%d", &Choice);
                switch (Choice)
                {
                         case(0):
                        default:
                                pRecAction->TypOfRec_e = WINSINTF_E_UNIQUE;
                                break;
                        case(1):
                                pRecAction->TypOfRec_e = WINSINTF_E_NORM_GROUP;
                                break;
                        case(2):
                                pRecAction->TypOfRec_e = WINSINTF_E_SPEC_GROUP;
                                break;
                        case(3):
                                pRecAction->TypOfRec_e = WINSINTF_E_MULTIHOMED;
                                break;
                }
                if ((Choice == 2) || (Choice == 3))
                {
                   int i;
                   printf("How many addresses do you wish to input (Max %d) -- ",
                                WINSINTF_MAX_MEM);
                   scanf("%d", &Choice2);
                   pRecAction->pAdd = WinsAllocMem(
                                sizeof(WINSINTF_ADD_T) * Choice2);
                   for(i = 0; i < Choice2 && i < WINSINTF_MAX_MEM; i++)
                   {
                           printf("IP Address no (%d) ? ", i);
                           scanf("%s", tgtadd);

                        (pRecAction->pAdd + i)->IPAdd    =
                                        ntohl(inet_addr(tgtadd));
                        (pRecAction->pAdd + i)->Type     = 0;
                        (pRecAction->pAdd + i)->Len      = 4;

                   }
                   pRecAction->NoOfAdds = i;
                }
                else
                {
                   printf("IP Address ? ");
                   scanf("%s", tgtadd);
                   pRecAction->Add.IPAdd    = ntohl(inet_addr(tgtadd));
                   pRecAction->Add.Type     = 0;
                   pRecAction->Add.Len      = 4;
//                   pRecAction->NoOfAdds = 1;
                }
                if ((Choice != 1) && (Choice != 2))
                {
                        Choice = 0;
                        printf("Node Type -- P-node (0), H-node (1), B-node (2),default - P node -- ");
                        scanf("%d", &Choice);
                        switch(Choice)
                        {
                                default:
                                case(0):
                                        pRecAction->NodeTyp = WINSINTF_E_PNODE;
                                        break;
                                case(1):
                                        pRecAction->NodeTyp = WINSINTF_E_HNODE;
                                        break;
                                case(2):
                                        pRecAction->NodeTyp = WINSINTF_E_BNODE;
                                        break;
                        }
                }

        }

#if 0
        if (Cmd_e == WINSINTF_E_RELEASE)
        {
                printf("Want to specify address (pkt add) 1 for yes, 0 for no -- ");
                scanf("%d", &Choice);
                if (Choice == 1)
                {
                  if(
                        ( pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP)
                                        ||
                        ( pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                    )
                  {
                        pRecAction->pAdd = WinsAllocMem(sizeof(WINSINTF_ADD_T));
                        printf("IP Address ? --  ");
                        scanf("%s", tgtadd);
                        pRecAction->pAdd->IPAdd    = ntohl(inet_addr(tgtadd));
                        pRecAction->pAdd->Type     = 0;
                        pRecAction->pAdd->Len      = 4;

                  }
                   printf("IP Address ? --  ");
                   scanf("%s", tgtadd);
                   pRecAction->Add.IPAdd    = ntohl(inet_addr(tgtadd));
                   pRecAction->Add.Type     = 0;
                   pRecAction->Add.Len      = 4;
                }
        }
#endif
        pRecAction->pName = WinsAllocMem(Len);
        (void)memcpy(pRecAction->pName, Name, Len);
        pRecAction->NameLen    = Len;
      return;
}
VOID
GetFilterName(
        LPBYTE  pStr,
        LPDWORD pLen
         )
{

        DWORD LastChar;
        DWORD Choice;

        printf("Name ? ");
        scanf("%s", pStr);
        if ((*pLen = strlen(pStr)) < 16)
        {
                printf("Do you want to input a 16th char (1 for yes, 0 for no) -- ");
                scanf("%d", &Choice);
                if (Choice)
                {
                        printf("16th char in hex -- ");
                        scanf("%x", &LastChar);
                        memset(&pStr[*pLen], (int)' ',16-*pLen);
                        pStr[15] = (BYTE)LastChar && 0xff;
                        pStr[16] = (TCHAR)NULL;
                        *pLen = 16;
                }
        }
        return;
}


DWORD
GetStatus(
        BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort
        )
{
        DWORD                     Status, i;
        struct in_addr            InAddr;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
        PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
        DWORD                     NoOfOwners;


        if (!fNew)
        {
          Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, pResultsA);
        }
        else
        {
          pResultsN->pAddVersMaps = NULL;
          Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG_ALL_MAPS, pResultsN);
        }
        printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
        if (Status == WINSINTF_SUCCESS)
        {
             if (fPrint)
             {
                printf("Refresh Interval = (%d)\n",
                                  fNew ? pResultsN->RefreshInterval :
                                  pResults->RefreshInterval
                                       );
                printf("Tombstone Interval = (%d)\n",
                                  fNew ? pResultsN->TombstoneInterval :
                                  pResults->TombstoneInterval);
                printf("Tombstone Timeout = (%d)\n",
                                  fNew ? pResultsN->TombstoneTimeout :
                                  pResults->TombstoneTimeout);
                printf("Verify Interval = (%d)\n",
                                  fNew ? pResultsN->VerifyInterval :
                                  pResults->VerifyInterval);
                if (!fNew)
                {
                   printf("WINS Priority Class = (%s)\n",
                          pResults->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? "NORMAL" : "HIGH");
                   printf("No of Worker Thds in WINS = (%d)\n",
                                  pResults->NoOfWorkerThds);
                     pAddVersMaps = pResults->AddVersMaps;
                     NoOfOwners = pResults->NoOfOwners;
                }
                else
                {
                   printf("WINS Priority Class = (%s)\n",
                          pResultsN->WinsPriorityClass == NORMAL_PRIORITY_CLASS ? "NORMAL" : "HIGH");
                   printf("No of Worker Thds in WINS = (%d)\n",
                                  pResultsN->NoOfWorkerThds);
                     pAddVersMaps = pResultsN->pAddVersMaps;
                     NoOfOwners = pResultsN->NoOfOwners;
                }

                if (NoOfOwners != 0)
                {
                         printf("OWNER ID\t\tADDRESS\t\tVERS.NO\n");
                         printf("--------\t\t-------\t\t-------\n");
                         for ( i= 0; i < NoOfOwners; i++, pAddVersMaps++)
                         {
                                InAddr.s_addr = htonl(
                                           pAddVersMaps->Add.IPAdd);

                                if (fNew)
                                {
                                   if (
                                       (pAddVersMaps->VersNo.HighPart
                                                             == MAXLONG)
                                                     &&
                                      (pAddVersMaps->VersNo.LowPart ==
                                                                MAXULONG)
                                     )
                                   {
                                     if (!fShort)
                                     {
                                      printf("%d\t\t%s\t\t", i, inet_ntoa(InAddr));
                                      printf("DELETED. SLOT WILL BE REUSED LATER\n");
                                     }
                                     continue;
                                   }
                                }
                                if (fShort &&
                                    pAddVersMaps->VersNo.QuadPart == 0)
                                {
                                    continue;
                                }
                                printf("%d\t\t%s\t\t", i, inet_ntoa(InAddr));

                                printf("%lx %lx\n",
                                       pAddVersMaps->VersNo.HighPart,
                                       pAddVersMaps->VersNo.LowPart
                                              );
                         }
                         if (fNew)
                         {
                            WinsFreeMem(pResultsN->pAddVersMaps);
                         }
                }
                else
                {
                          printf("The Db is empty\n");
                          Status = WINSINTF_FAILURE;
                }
           }
        }
        return(Status);
}



DWORD
GetDbRecs(
   WINSINTF_VERS_NO_T LowVersNo,
   WINSINTF_VERS_NO_T HighVersNo,
   PWINSINTF_ADD_T     pWinsAdd,
   LPBYTE              pTgtAdd,
   BOOL                      fSetFilter,
   LPBYTE              pFilterName,
   DWORD              Len,
   BOOL                      fAddFilter,
   DWORD              AddFilter,
   FILE                      *pFile,
   BOOL                      fCountRec
  )
{

   WINSINTF_RECS_T                Recs;
   DWORD                        Choice;
   DWORD                              Status = WINSINTF_SUCCESS;
   DWORD                              TotalCnt = 0;
   BOOL                                fMatch;


   while (TRUE)
   {
           Recs.pRow = NULL;
           Status = WinsGetDbRecs(BindHdl, pWinsAdd, LowVersNo, HighVersNo, &Recs);
           if (!fSetFilter)
           {
             printf("Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
           }

           if (fCountRec)
           {
                printf("Total number of records are (%d)\n",  Recs.TotalNoOfRecs);
                break;
           }
           if (Status == WINSINTF_SUCCESS)
           {
                if (Recs.NoOfRecs > 0)
                {
                        DWORD i;
                        PWINSINTF_RECORD_ACTION_T pRow =  Recs.pRow;
                        TotalCnt += Recs.NoOfRecs;


                        if (!fSetFilter)
                        {
                                if (pFile == NULL)
                                {
                                  printf("Retrieved %d records of WINS\n", Recs.NoOfRecs);
                                }
                                else
                                {
                                          fprintf(pFile, "RETRIEVED %d RECORDS OF WINS = (%s) \n", Recs.NoOfRecs, pTgtAdd);
                                }

                        }
                        for (i=0; i<Recs.NoOfRecs; i++)
                        {

                                 if (fAddFilter)
                                 {
                                        //
                                        // The address filter was specfied
                                        // If the address matches, then
                                        // fMatch will be TRUE after the
                                        // function returns.
                                        //
                                        fMatch = TRUE;
                                        ChkAdd(
                                                pRow,
                                                pFile,
                                                AddFilter,
                                                &fMatch
                                                );
                                }
                                else
                                {
                                        fMatch = FALSE;
                                }


                                 //
                                 // If the address matched or if no filter
                                 // was specified or if there was a name
                                 // filter and the names matched, print
                                 // out the details
                                 //
                                 if (fMatch || !fSetFilter ||
                                        (
                                          !fAddFilter &&
                                          !memcmp(pRow->pName, pFilterName, Len)
                                        )
                                            )
                                 {
                                          if (pFile == NULL)
                                          {
                                          printf("-----------------------\n");
                                          printf("Name is (%s). 16th char is (%x)\nNameLen is (%d)\nType is (%s)\nState is (%s)\nVersion No is (%x %x)\nStatic flag is (%d)\nTimestamp is (%.19s)\n", pRow->pName, *(pRow->pName+15),
pRow->NameLen, pRow->TypOfRec_e == WINSINTF_E_UNIQUE ? "UNIQUE" : (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" : (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",
        pRow->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRow->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE", pRow->VersNo.HighPart, pRow->VersNo.LowPart, pRow->fStatic, asctime(localtime(&(pRow->TimeStamp))));
                                         }
                                         else
                                         {

                                          fprintf(pFile, "-----------------------\n");
                                          fprintf(pFile, "Name is (%s). 16th char is (%x)\nNameLen is (%d)\nType is (%s)\nState is (%s)\nVersion No is (%x %x)\nStatic flag is (%d)\nTimestamp is (%.19s)\n", pRow->pName, *(pRow->pName+15),
pRow->NameLen, pRow->TypOfRec_e == WINSINTF_E_UNIQUE ? "UNIQUE" : (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" : (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",
        pRow->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRow->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE", pRow->VersNo.HighPart, pRow->VersNo.LowPart, pRow->fStatic, asctime(localtime(&(pRow->TimeStamp))));

                                         }
                                        fMatch = FALSE;

                                        ChkAdd(
                                                pRow,
                                                pFile,
                                                AddFilter,
                                                &fMatch
                                                );

                                          if (pFile == NULL)
                                          {
                                            printf("-----------------------\n");
                                          }
                                          else
                                          {
                                            fprintf(pFile, "-----------------------\n");
                                           }
                                    }
                                    pRow++;

                        } // end of for (all recs)

                        //
                        // If a range was chosen and records
                        // retrieved are == the limit of 100
                        // and if the Max vers no retrieved
                        // is less than that specified, ask
                        // user if he wishes to continue
                        //
                        if (!fSetFilter)
                        {
                                printf("Got %d records in this round\n",
                                                        Recs.NoOfRecs);
                        }
                        if (
                                (Recs.NoOfRecs < Recs.TotalNoOfRecs)
                                           &&
                                LiLtr((--pRow)->VersNo,
                                                HighVersNo )
                           )
                        {
                                if ((pFile == NULL) && (!fSetFilter))
                                {
                                          printf("There may be more. Get them ?? Input 1 for yes, 0 for no -- ");
                                          scanf("%d", &Choice);
                                }
                                else
                                {
                                                Choice = 1;
                                }
                                if (Choice == 1)
                                {
                                           LowVersNo.QuadPart = LiAdd(pRow->VersNo,sTmpVersNo);
                                           //Recs.NoOfRecs = 0;
                                           continue;
                                }

                        }

                        printf("Total No Of records %s = (%d)\n",
        fSetFilter ? "searched" : "retrieved", TotalCnt);
                        if (pFile != NULL)
                        {
                                fprintf(pFile, "TOTAL NO OF RECORDS %s = (%d) for WINS (%s)\n",
        fSetFilter ? "searched" : "retrieved",  TotalCnt, pTgtAdd);
                                fprintf(pFile, "++++++++++++++++++++++++++++++\n");

                        }
                }
                else
                {
                        printf("No records of WINS (%s) in the range requested are there in the local db\n", pTgtAdd);

                }
        }
                break;
    } // while (TRUE)

    if (Recs.pRow != NULL)
    {
        WinsFreeMem(Recs.pRow);
    }
    return(Status);
} // GetDbRecs


VOID
ChkAdd(
        PWINSINTF_RECORD_ACTION_T pRow,
        FILE                          *pFile,
        DWORD                          Add,
        LPBOOL                          pfMatch
      )
{

        struct in_addr InAddr;

        if (
            (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
                        ||
            (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
            )
        {
                InAddr.s_addr = htonl( pRow->Add.IPAdd);

                if (*pfMatch)
                {
                        if (Add == pRow->Add.IPAdd)
                        {
                                return;
                        }
                        else
                        {
                                  *pfMatch = FALSE;
                                return;
                        }
                }


                if (pFile == NULL)
                {
                          printf("IP Address is (%s)\n", inet_ntoa(InAddr) );
                }
                else
                {
                          fprintf(pFile, "IP Address is (%s)\n",
                                                        inet_ntoa(InAddr)
                                                        );
                }
          }
          else //spec. grp or multihomed
          {
                DWORD ind;
                if (!*pfMatch)
                {
                        if (pFile == NULL)
                        {
                          printf("No. Of Members (%d)\n\n", pRow->NoOfAdds/2);
                        }
                        else
                        {
                          fprintf(pFile, "No. Of Members (%d)\n\n", pRow->NoOfAdds/2);
                        }
                }

                for ( ind=0;  ind < pRow->NoOfAdds ;  /*no third expr*/ )
                {
                         InAddr.s_addr = htonl( (pRow->pAdd + ind++)->IPAdd);
                         if (!*pfMatch)
                         {
                            if (pFile == NULL)
                            {
                                printf("Owner is (%s); ", inet_ntoa(InAddr) );
                             }
                            else
                            {
                                    fprintf(pFile, "Owner is (%s); ",
                                                        inet_ntoa(InAddr) );
                            }
                         }
                         InAddr.s_addr = htonl(
                                                  (pRow->pAdd + ind++)->IPAdd);

                         if (!*pfMatch)
                         {
                                 if (pFile == NULL)
                                 {
                                  printf("Node is (%s)\n", inet_ntoa(InAddr) );
                                 }
                                 else
                                 {
                                  fprintf(pFile, "Node is (%s)\n",
                                                        inet_ntoa(InAddr)
                                                                );
                                   }
                         }
                         if (*pfMatch)
                         {
                                if (Add == (pRow->pAdd + ind - 1)->IPAdd)
                                {
                                        return;
                                }
                                else
                                {
                                          *pfMatch = FALSE;
                                        return;
                                }
                         }
                 }

                 //
                 // If there were no members to compare with, then
                 // let us set *pfMatch to FALSE.
                 //
                 if (ind == 0)
                 {
                        if (*pfMatch)
                        {
                                *pfMatch = FALSE;
                        }
                 }

          }
}


VOID
WantFile(
        FILE **ppFile
)
{
        DWORD Choice;
        printf("Put records in wins.rec file (1 for yes, 0 for no) -- ");
        scanf("%d", &Choice);
        if (Choice != 1)
        {
                *ppFile = NULL;
        }
        else
        {
                *ppFile = fopen("wins.rec", "a");
                if (*ppFile == NULL)
                {
                        printf("Could not open file wins.rec for appending\n");
                }
        }
        return;
}

DWORD
CreateFiles(
    PWINSINTF_RECS_T pRecs,
    PWINSINTF_ADD_T      pWinsAdd,
    FILE *pFileU,
    FILE  *pFileO
    )
{
        DWORD           no;
        PWINSINTF_RECORD_ACTION_T pRow;
        DWORD           i;
        struct in_addr InAddr;

        pRow = pRecs->pRow;
        InAddr.s_addr = htonl(pWinsAdd->IPAdd);
        fprintf(pFileU, "##UNIQUE records of WINS with address %s\n\n", inet_ntoa(InAddr));
        fprintf(pFileO, "##NON-UNIQUE records of WINS with address %s\n", inet_ntoa(InAddr));

        for(no = 0; no < pRecs->NoOfRecs; no++)
        {


            if (pRow->TypOfRec_e == WINSINTF_E_UNIQUE)
            {
                InAddr.s_addr = htonl(pRow->Add.IPAdd);

                fprintf(pFileU, "%s\t", inet_ntoa(InAddr));
                for (i=0; i<pRow->NameLen; i++)
                {
                  fprintf(pFileU, "%c", *(pRow->pName + i));
                }
                fprintf(pFileU, "\n");
            }
            else
            {
                fprintf(pFileO, "%d\t", pRow->NameLen);
                for (i=0; i<pRow->NameLen; i++)
                {
                    fprintf(pFileO, "%c", (BYTE)(*(pRow->pName + i)));
                }

                fprintf(pFileO, "\t%d", pRow->TypOfRec_e);
                if (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                {
                    InAddr.s_addr = htonl(pRow->Add.IPAdd);
                    fprintf(pFileO, "\t%s", inet_ntoa(InAddr));

                }
                else
                {
                     fprintf(pFileO, "\t%d\t", pRow->NoOfAdds);
                     for (i=0; i<pRow->NoOfAdds; i)
                     {
                           InAddr.s_addr = htonl((pRow->pAdd +i++)->IPAdd);
                           fprintf(pFileO, "%s\t", inet_ntoa(InAddr));
                           InAddr.s_addr = htonl((pRow->pAdd + i++)->IPAdd);
                           fprintf(pFileO, "%s\t", inet_ntoa(InAddr));
                     }
                }
                fprintf(pFileO, "\n");
            }
            pRow++;
        }
       fprintf(pFileO, "\n\n\n");

       return(WINSINTF_SUCCESS);
}


DWORD
InitFromFile(
        VOID
    )
{
        FILE *pFileO;
        WINSINTF_RECORD_ACTION_T RecAction;
        DWORD NoOfRecs = 0;
        DWORD i;
        DWORD RetStat = WINSINTF_SUCCESS;
        BYTE  Add[20];

        pFileO = fopen(FILEO, "r");
        if (pFileO == NULL)
        {
                printf("Could not open file %s\n", FILEO);
                return(WINSINTF_FAILURE);
        }
        while(TRUE)
        {
          printf("Record no %d\n", ++NoOfRecs);

          if (fscanf(pFileO, "%d\t", &RecAction.NameLen) == EOF)
          {
                printf("ERROR reading NameLen\n");
                break;

          }
          RecAction.pName = WinsAllocMem(RecAction.NameLen);
          for(i=0;i<RecAction.NameLen;i++)
          {
            if (fscanf(pFileO, "%c", (RecAction.pName + i)) == EOF)
            {
                printf("ERROR reading Name. i is %d", i);
                break;
            }
          }
          if (fscanf(pFileO, "\t%d", &RecAction.TypOfRec_e) == EOF)
          {
                printf("ERROR reading TypeOfRec\n");
                break;
          }
          if (RecAction.TypOfRec_e == WINSINTF_E_NORM_GROUP)
          {
           fscanf(pFileO, "%s", Add);
                   RecAction.Add.IPAdd    = 0xFFFFFFFF;
                   RecAction.Add.Type     = 0;
                   RecAction.Add.Len      = 4;
                   RecAction.NoOfAdds = 0;
          }
          else
          {
            if (fscanf(pFileO, "\t%d\t", &RecAction.NoOfAdds) == EOF)
            {
                printf("ERROR reading NoOfAdds");
                break;
            }
            for (i=0; i<RecAction.NoOfAdds;i++)
            {
                   BYTE Add[20];
                   RecAction.pAdd = WinsAllocMem(
                                sizeof(WINSINTF_ADD_T) * RecAction.NoOfAdds);

                   for(i = 0; i < RecAction.NoOfAdds; i++)
                   {
                       if (fscanf(pFileO, "%s\t", Add) == EOF)
                       {
                         printf("ERROR reading Address");
                         break;
                       }
                       (RecAction.pAdd + i)->IPAdd = ntohl(inet_addr(Add));
                       (RecAction.pAdd + i)->Type     = 0;
                       (RecAction.pAdd + i)->Len      = 4;
                   }
            }
         }
         fscanf(pFileO, "\n");
        }  // end of while

        printf("Name = (%s), TypeOfRec (%s)\n", RecAction.pName, RecAction.TypOfRec_e == WINSINTF_E_NORM_GROUP ? "NORMAL GROUP" : (RecAction.TypOfRec_e ==
WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED");
        if (RecAction.TypOfRec_e == WINSINTF_E_NORM_GROUP)
        {
                printf("NORM GRP: Address is %x\n", RecAction.Add.IPAdd);
        }
        else
        {
                for (i=0; i < RecAction.NoOfAdds; i++)
                {
                        printf("%d -- Owner (%d) is (%p)\t", i,
                                        (RecAction.pAdd + i)->IPAdd);
                        printf("%d -- Address (%d) is (%p)\n", ++i,
                                        (RecAction.pAdd + i)->IPAdd);
                }

        }
        return(RetStat);
}

DWORD
GetDbRecsByName(
  PWINSINTF_ADD_T pWinsAdd,
  DWORD           Location,
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           NoOfRecsDesired,
  DWORD           TypeOfRecs,
  BOOL            fFilter,
  DWORD           AddFilter
 )
{
         DWORD Status;
         WINSINTF_RECS_T Recs;
         DWORD      TotalCnt = 0;

          Recs.pRow = NULL;
          Status = WinsGetDbRecsByName(BindHdl, pWinsAdd, Location, pName, NameLen,
                                   NoOfRecsDesired, TypeOfRecs, &Recs);
          printf("Total number of records are (%d)\n",  Recs.TotalNoOfRecs);
           if (Status == WINSINTF_SUCCESS)
           {
                if (Recs.NoOfRecs > 0)
                {
                        DWORD i;
                        PWINSINTF_RECORD_ACTION_T pRow =  Recs.pRow;
                        TotalCnt += Recs.NoOfRecs;


                        printf("Retrieved %d records\n", Recs.NoOfRecs);
                        for (i=0; i<Recs.NoOfRecs; i++)
                        {

                               printf("-----------------------\n");
                               printf("Name is (%s). 16th char is (%x)\nNameLen is (%d)\nType is (%s)\nState is (%s)\nVersion No is (%x %x)\nStatic flag is (%d)\nTimestamp is (%.19s)\n", pRow->pName, *(pRow->pName+15),
pRow->NameLen, pRow->TypOfRec_e == WINSINTF_E_UNIQUE ? "UNIQUE" : (pRow->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" : (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",
        pRow->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRow->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE", pRow->VersNo.HighPart, pRow->VersNo.LowPart, pRow->fStatic, asctime(localtime(&(pRow->TimeStamp))));

                                        ChkAdd(
                                                pRow,
                                                NULL,
                                                AddFilter,
                                                &fFilter
                                                );

                                printf("-----------------------\n");
                                pRow++;

                        } // end of for (all recs)

                }
                else
                {
                        printf("No records were retrieved\n");

                }
           }
           if (Recs.pRow != NULL)
           {
              WinsFreeMem(Recs.pRow);
           }
    return(Status);
}

VOID
Usage(
  VOID
 )
{
    CMD_E i;
    DWORD LastEntry = (fEnhMode ? LAST_ENTRY : LAST_PSS_ENTRY);
    printf("winscl {T or N} {CMD}\n");
    printf("where\nT -- TCP/IP\nN -- Named Pipe\n");
    printf("\n\nCMD is one of the following\n");

    for (i = 0; i < (CMD_E)LastEntry; i++)
    {
       if (CommandSwitchList[i].SwitchName != NULL)
       {
         printf("%s or %s\n", CommandSwitchList[i].SwitchName,
                        CommandSwitchList[i].ShortName);
       }
    }
    return;
}

VOID
GetCmdCode(
  LPBYTE pCmd,
  PCMD_E pCmd_e
 )
{
   CMD_E Cmd_e;
   *pCmd_e = INVALID_VALUE;

   for (Cmd_e = 0; Cmd_e < (fEnhMode ? LAST_ENTRY : LAST_PSS_ENTRY); Cmd_e++)
   {
     if (CommandSwitchList[Cmd_e].ShortName != NULL)
     {
     if (!_strcmpi(CommandSwitchList[Cmd_e].ShortName, pCmd)
                    ||
           !_strcmpi(CommandSwitchList[Cmd_e].SwitchName, pCmd)
        )
     {
           *pCmd_e = CommandSwitchList[Cmd_e].SwitchValue;
           return;

     }
    }
  }
  return;

}

#define PRADEEPB_PTM "157.55.80.183"
#define PRADEEPB_486 "157.55.80.182"

//#define RHINO1 PRADEEPB_PTM
//#define RHINO2 PRADEEPB_486
#define RHINO1 "157.55.80.151"
#define RHINO2  "157.55.80.152"
#define RED03NS  "157.54.16.159"

VOID
sync(VOID)
{
  handle_t                BindHdl;
  WINSINTF_BIND_DATA_T        BindData;
  PNAME_INFO  pNameInfo, pSrvInfo;
  WINS_INFO  WinsInfo;
  DWORD i, n, t, s;
  LPBYTE pWinsAdd = RHINO1;
  DWORD Status;
  PWINSINTF_RECORD_ACTION_T pSvRecAction = NULL;
  WINSINTF_RECORD_ACTION_T RecAction;
  PWINSINTF_RECORD_ACTION_T pRecAction;
  PWINSINTF_RECORD_ACTION_T pOutRecAction;
  BOOL fAtLeastOneFound;
  DWORD NoOfNames, NoOfSrvNames;


  if(!ReadNameFile( &pNameInfo, &NoOfNames, "nmfl.txt"))
  {
     return;
  }
  if(!ReadNameFile( &pSrvInfo, &NoOfSrvNames, "winss.txt"))
  {
     return;
  }
  WinsInfo.NoOfOwners = NoOfSrvNames;
  for (i = 0; i < NoOfSrvNames; i++)
  {
    strcpy(WinsInfo.Maps[i].asIpAdd, pSrvInfo->Name);
    WinsInfo.Maps[i].fCommFail = FALSE;
    WinsInfo.Maps[i].fNameNotFound = FALSE;
    fprintf(spDbgFile, "WINS server (%d) is  (%s)\n", i, WinsInfo.Maps[i].asIpAdd);
    pSrvInfo++;

  }

 i = 0;
#if 0
 do
 {
  if (!BindToWins(pWinsAdd, &BindData, &BindHdl))
  {
       fprintf(spDbgFile, "Unable to bind to %s\n", pWinsAdd);
       return;
  }
  fprintf(spDbgFile, "Connected to WINS = (%s)\n", pWinsAdd);
  //
  // Get WINS server info
  //
  WinsInfo.NoOfOwners = 0;

  i++;
  if (GetWinsInfo(&WinsInfo) != WINSINTF_SUCCESS)
  {
       fprintf(spDbgFile, "Comm. Failure with %s\n", pWinsAdd);
       if (i < 2)
       {
         pWinsAdd = RHINO2;
       }
  }
  else
  {
     i = 2;
  }
  WinsUnbind(&BindData, BindHdl);
  } while (i < 2);
#endif

  //
  // Loop over all names read in.  Query the name from all WINSs that
  // we have in our list of WINS owners that we got from RHINO1
  //
  for (i = 0; (pNameInfo->Name[0] != 0) && (i < NoOfNames); i++, pNameInfo++)
  {

   DWORD LChar;
   CHAR Name[50];
   BOOL  fStored;
   for (s=0; s<2;s++)
   {
     LChar = (s==0) ? 0x20 : 0x0;

     RecAction.Cmd_e      = WINSINTF_E_QUERY;

     strcpy(Name, pNameInfo->Name);
     GetFullName(Name, LChar, &RecAction);

     pRecAction = &RecAction;

     //
     // For a name, loop over all WINS owners
     //
     fStored = FALSE;
     fAtLeastOneFound = FALSE;
     for (n = 0; n < NoOfSrvNames; n++)
     {
             DWORD OwnIdOfName;

#if 0
             if (
                     !_strcmpi(WinsInfo.Maps[n].asIpAdd, RHINO1) ||
                     !_strcmpi(WinsInfo.Maps[n].asIpAdd, RHINO2) ||
                     !_strcmpi(WinsInfo.Maps[n].asIpAdd, RED03NS)
                )
#endif
            fprintf(spDbgFile, "BINDING TO WINS = (%s)\n", WinsInfo.Maps[n].asIpAdd);
             {

             //
             // Bind to the WINS
             //
             if (!BindToWins(WinsInfo.Maps[n].asIpAdd, &BindData, &BindHdl))
             {
                    fprintf(spDbgFile, "FAILED BINDING\n");
                    continue;  // go on to the next one
             }

             //
             // Query Wins for the name
             //
             pRecAction = &RecAction;
             if ((Status = QueryWins(Name, pRecAction, &pOutRecAction)) == NAME_NOT_FOUND)
             {
                  fprintf(spDbgFile2, "DID NOT FIND NAME = (%s[%x]) in Wins = (%s) db\n",
                           Name, Name[15], WinsInfo.Maps[n].asIpAdd);
                  WinsInfo.Maps[n].fNameNotFound = TRUE;
                  WinsInfo.Maps[n].fCommFail = FALSE;
             }
             else
             {
                if ( Status == SUCCESS)
                {
                  fprintf(spDbgFile, "FOUND name = (%s[%x]) in Wins = (%s) db\n",
                           Name, Name[15], WinsInfo.Maps[n].asIpAdd);
                 fAtLeastOneFound = TRUE;
                 if (!fStored)
                 {
                   fStored = TRUE;
                   pSvRecAction = pOutRecAction;
                 }
                 else
                 {
                     WinsFreeMem(pOutRecAction);
                 }
                  WinsInfo.Maps[n].fCommFail = FALSE;
                  WinsInfo.Maps[n].fNameNotFound = FALSE;
                }
                else
                {
                     WinsInfo.Maps[n].fCommFail = TRUE;
                }
             }
             WinsUnbind(&BindData, BindHdl);
             }
#if 0
             else
             {
                     WinsInfo.Maps[n].fCommFail = TRUE;
             }
#endif
       }

//#if 0
       for (t = 0; t < WinsInfo.NoOfOwners && fAtLeastOneFound; t++)
       {
                if (!WinsInfo.Maps[t].fCommFail && WinsInfo.Maps[t].fNameNotFound)
                {
                   if(BindToWins(WinsInfo.Maps[t].asIpAdd, &BindData, &BindHdl))
                   {
                     StoreName(pSvRecAction, RecAction.pName);
                     WinsUnbind(&BindData, BindHdl);
                   }
                }
                else
                {
                     continue;
                }
        }
//#endif
        if (RecAction.pName != NULL)
        {
                WinsFreeMem(RecAction.pName);
                RecAction.pName = NULL;
        }
        if (pSvRecAction)
        {
            WinsFreeMem(pSvRecAction);
            pSvRecAction = NULL;
        }
    }
  }

       fclose(spDbgFile);
       fclose(spDbgFile2);
       return;
}

VOID
StoreName(
 PWINSINTF_RECORD_ACTION_T pRecAction,
 LPBYTE pName
 )
{

      DWORD Status;
      DWORD i;

      (void)strncpy(pRecAction->pName, pName, 16);
      pRecAction->NameLen    = 16;
      pRecAction->Cmd_e      = WINSINTF_E_INSERT;
      if ((pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ||
          (pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED))
      {
          for (i = 0; i < pRecAction->NoOfAdds; i++)
          {
            *(pRecAction->pAdd + i) = *(pRecAction->pAdd + i + 1);
            i++;
          }
          pRecAction->NoOfAdds = pRecAction->NoOfAdds/2;
      }

      fprintf(spDbgFile2, "StoreName:STORING name %s[%x]\n", pRecAction->pName, pRecAction->pName[15]);
      Status = WinsRecordAction(BindHdl, &pRecAction);
      fprintf(spDbgFile2, "StoreName:Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
       WinsFreeMem(pRecAction);
       return;
}


DWORD
QueryWins (
 LPBYTE pName,
 PWINSINTF_RECORD_ACTION_T pRecAction,
 PWINSINTF_RECORD_ACTION_T *ppRecAct
)
{
       DWORD RetStat;
       struct in_addr InAddr;
       DWORD i;
       DWORD Status;

       Status = WinsRecordAction(BindHdl, &pRecAction);
       fprintf(spDbgFile, "Status returned is (%s - %d)\n", Status == 0 ? "SUCCESS" : "FAILURE", Status);
       if (Status == WINSINTF_SUCCESS)
       {
            *ppRecAct = pRecAction;
                          fprintf(spDbgFile, "Name=(%s)\nNodeType=(%d)\nState=(%s)\nTimeStamp=(%.19s)\nOwnerId=(%d)\nType Of Rec=(%s)\nVersion No (%x %x)\nRecord is (%s)\n",
                                pRecAction->pName,
                                pRecAction->NodeTyp,
                                pRecAction->State_e == WINSINTF_E_ACTIVE ? "ACTIVE" : (pRecAction->State_e == WINSINTF_E_RELEASED) ? "RELEASED" : "TOMBSTONE",
                                asctime(localtime(&(pRecAction->TimeStamp))),
                                pRecAction->OwnerId,
                                (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE) ? "UNIQUE" : (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? "NORMAL GROUP" :
(pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ? "SPECIAL GROUP" : "MULTIHOMED",

                                pRecAction->VersNo.HighPart,
                                pRecAction->VersNo.LowPart,
                                pRecAction->fStatic ? "STATIC" : "DYNAMIC"
                                        );
                                if (
                                (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE)
                                                ||
                                (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP)
                                  )
                                {

                                   InAddr.s_addr = htonl(pRecAction->Add.IPAdd);
                                   fprintf(spDbgFile, "Address is (%s)\n", inet_ntoa(InAddr));
                                }
                                else
                                {
                                   for (i=0; i<pRecAction->NoOfAdds; )
                                   {
                                      InAddr.s_addr = htonl((pRecAction->pAdd +i++)->IPAdd);
                                      fprintf(spDbgFile, "Owner is (%s); ", inet_ntoa(InAddr));
                                      InAddr.s_addr = htonl((pRecAction->pAdd + i++)->IPAdd);
                                      fprintf(spDbgFile, "Member is (%s)\n", inet_ntoa(InAddr));
                                   }
                                }


               RetStat = SUCCESS;
      }
      else
      {
              if (Status == ERROR_REC_NON_EXISTENT)
              {
                    fprintf(spDbgFile, "No such name in the db\n");
                    RetStat = NAME_NOT_FOUND;
              }
              else
              {
                    fprintf(spDbgFile, "Status is (%x)\n", Status);
                    RetStat = FAILURE;
              }
      }
      return RetStat;
}

handle_t
WinsABind(
    PWINSINTF_BIND_DATA_T pBindData
    );
BOOL
BindToWins(
  LPBYTE asIpAdd,
  PWINSINTF_BIND_DATA_T    pBindData,
  handle_t                *pBindHdl
 )
{

  pBindData->pServerAdd = asIpAdd;
  pBindData->fTcpIp = TRUE;

  *pBindHdl = WinsABind(pBindData);
  if (pBindHdl == NULL)
  {
          fprintf(spDbgFile, "Unable to bind to %s \n", asIpAdd);
          return (FALSE);
  }
  return(TRUE);
}

BOOL
ReadNameFile(
 PNAME_INFO *ppFileInfo,
 LPDWORD pNoOfNames,
 LPBYTE  pNameOfFile
)
{
  FILE *pFile;
  struct _stat  Stat;
  PNAME_INFO   pFileInfo;
  DWORD    SizeAlloc;
  *pNoOfNames = 0;
  if((pFile = fopen(pNameOfFile, "r")) == NULL)
  {
                  return FALSE;
  }

  if (_stat(pNameOfFile, &Stat) == -1)
  {
                  return FALSE;
  }
  SizeAlloc =  Stat.st_size + Stat.st_size/15 * sizeof(NAME_INFO);
  if (!(pFileInfo = malloc(SizeAlloc)))
  {
                  return FALSE;
  }
  else
  {
    fprintf(spDbgFile, "Allocated %d bytes\n", SizeAlloc);
  }
  *ppFileInfo = pFileInfo;

  memset(pFileInfo, 0, SizeAlloc);
  //
  // Read in names
  //
  while(fscanf(pFile, "%s\n", pFileInfo->Name) != EOF)
  {
             fprintf(spDbgFile, "Name is %s\n", pFileInfo->Name);
             (*pNoOfNames)++;
             pFileInfo++;
  }
  return(TRUE);
}

STATUS
GetWinsInfo(
     PWINS_INFO  pWinsInfo
)
{
      DWORD Status;
      WINSINTF_RESULTS_NEW_T Results;
      PWINSINTF_RESULTS_NEW_T pResultsN = &Results;
      DWORD  NoOfOwners;
      struct in_addr                InAddr;
      DWORD i, n;
      PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;

      Results.WinsStat.NoOfPnrs = 0;
      Results.WinsStat.pRplPnrs = NULL;

      Results.pAddVersMaps = NULL;
      Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG_ALL_MAPS, pResultsN);
      if (Status == WINSINTF_SUCCESS)
      {
                pAddVersMaps = pResultsN->pAddVersMaps;

                if (pResultsN->NoOfOwners != 0)
                {
                         for (n=0, i= 0; i < pResultsN->NoOfOwners;  i++, pAddVersMaps++)
                         {
                                InAddr.s_addr = htonl(
                                           pAddVersMaps->Add.IPAdd);

                                if (
                                       (pAddVersMaps->VersNo.HighPart
                                                             == MAXLONG)
                                                     &&
                                      (pAddVersMaps->VersNo.LowPart ==
                                                                MAXULONG)
                                     )
                                {
                                     continue;
                                }
                                if (pAddVersMaps->VersNo.QuadPart == 0)
                                {
                                    continue;
                                }
                                fprintf(spDbgFile,"%d\t\t%s\t\t", i, inet_ntoa(InAddr));

                                fprintf(spDbgFile, "%lu %lu\n",
                                       pAddVersMaps->VersNo.HighPart,
                                       pAddVersMaps->VersNo.LowPart
                                              );

                                pWinsInfo->Maps[n].OwnId = i;
                                strcpy(pWinsInfo->Maps[n].asIpAdd,inet_ntoa(InAddr));
                                pWinsInfo->Maps[n].VersNo = pAddVersMaps->VersNo;
                                n++;
                         }
                         pWinsInfo->NoOfOwners = n; //pResultsN->NoOfOwners;
                         WinsFreeMem(pResultsN->pAddVersMaps);
                }
                else
                {
                          fprintf(spDbgFile, "The Db is empty\n");
                }
       }
       else
       {
                pWinsInfo->NoOfOwners = 0;
       }
       return Status;
}

VOID
GetFullName(
        LPBYTE pName,
        DWORD  SChar,
        PWINSINTF_RECORD_ACTION_T pRecAction
         )
{
      size_t Len;

      pRecAction->pAdd = NULL;
      pRecAction->NoOfAdds = 0;

        if ((Len = strlen(pName)) < 16)
        {
                  memset(pName + Len, (int)' ',16-Len);
                  *(pName + 15) = (BYTE)(SChar & 0xff);
                  *(pName + 16) = (CHAR)NULL;
                   Len = 16;
        }
        else
        {
            *(pName + Len) = (CHAR)NULL;
        }

        pRecAction->pName = WinsAllocMem(Len);
        (void)memcpy(pRecAction->pName, pName, Len);
        pRecAction->NameLen    = Len;
      return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\com\comm.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

   Comm.c

Abstract:

        This module contains COMSYS's internal functions.  These functions
        are called by commapi functions.

Functions:
        CommCreatePorts
        CommInit
        MonTcp
        MonUdp
        HandleMsg
        CommReadStream
        ProcTcpMsg
        CommCreateTcpThd
        CommCreateUdpThd
        CreateThd
        CommConnect
        CommSend
        CommSendAssoc
        CommDisc
        CommSendUdp
        ParseMsg
        CommAlloc
        CommDealloc
        CompareNbtReq
        CommEndAssoc
        DelAssoc
        CommLockBlock
        CommUnlockBlock
        InitMem
        ChkNtfSock
        RecvData


Portability:
        This module is portable
Author:

   Pradeep  Bahl (pradeepb) 18-Nov-1992

Revision History:

--*/


/*
  Includes
*/
//
// The max. number of connections that can be there to/from WINS.
//
// NOTE NOTE NOTE
//
// We specify a RCVBUF size, based on this value, for the notification socket.
//
#define FD_SETSIZE        300

#include <sys/types.h>
#include <string.h>
#include <stdio.h>
#include "wins.h"

//
// pragma to disable duplicate definition message
//
#pragma warning (disable : 4005)
#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#pragma warning (default : 4005)

#include <nb30.h>
#include <nbtioctl.h>
#include <tdi.h>
#include "nms.h"
#include "rpl.h"
#include "comm.h"
#include "assoc.h"
#include "winsthd.h"
#include "winsque.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#if MCAST > 0
#include "rnraddrs.h"
#endif


/*
 defines
*/

#define TCP_QUE_LEN        5    /*Max # of backlog connections that can be
                                 *existent at any time. NOTE: WinsSock
                                 *api can keep a max. of 5 connection req
                                 *in the queue.  So, even if we specified
                                 * a higher number, that wouldn't help.
                                 *For our purposes 5 is enough.
                                 */

#define SPX_QUE_LEN        5     /*Max # of backlog connections that can be*/

//
// These specify the timeout value for select call that is made when
// message/data is expected on a connection
//

//
// We keep the timeout 5 mts for now to give the WINS server we are
// communicating enough time to respond (in case it has been asked to send
// a huge number of records.
//
#define   SECS_TO_WAIT                        300 //5 mts
#define   MICRO_SECS_TO_WAIT                0

#define  TWENTY_MTS                         1200 //20 mts
#define  FIVE_MTS                         TWENTY_MTS/4  //5 mts

//
// The max. number of bytes we can expect in a message from another WINS over
// a tcp connection
//
#define MAX_BYTES_IN_MSG        (RPL_MAX_LIMIT_FOR_RPL * (sizeof(RPL_REC_ENTRY_T) + NMSDB_MAX_NAM_LEN + (RPL_MAX_GRP_MEMBERS * sizeof(COMM_ADD_T))) + 10000 /*pad*/)

#define MCAST_PKT_LEN_M(NoOfIpAdd)  (FIELD_OFFSET(COMM_MCAST_MSG_T, Body[0]) + (COMM_IP_ADD_SIZE * (NoOfIpAdd)))
//
// This is the string used for getting the port pertaining to a nameserver
// from the etc\services file (via getserverbyname)
//
#define  NAMESERVER                "nameserver"

/*
 Globals
*/

RTL_GENERIC_TABLE CommUdpNbtDlgTable;  /*table for dialogue blocks created as
                                         *a result of nbt requests received
                                         *over the UDP port
                                         */

BOOL              fCommDlgError = FALSE;  //set to TRUE in ChkNtfSock() fn.
DWORD             CommWinsTcpPortNo = COMM_DEFAULT_IP_PORT;
DWORD             WinsClusterIpAddress = 0;
#if SPX > 0
#define           WINS_IPX_PORT           100
DWORD             CommWinsSpxPortNo;
#endif

/*
 Static variables
*/
#ifdef WINSDBG
#define SOCKET_TRACK_BUFFER_SIZE        20000

DWORD CommNoOfDgrms;        //for testing purposes only.  It counts the
                                //number of datagrams received
DWORD CommNoOfRepeatDgrms;

PUINT_PTR pTmpW;
BOOL   sfMemoryOverrun = FALSE;
LPLONG pEndPtr;
#endif

DWORD   CommConnCount = 0;  //no of tcp connection from/to this WINS
struct timeval  sTimeToWait = {SECS_TO_WAIT, MICRO_SECS_TO_WAIT};

STATIC HANDLE  sNetbtSndEvtHdl;
STATIC HANDLE  sNetbtRcvEvtHdl;
STATIC HANDLE  sNetbtGetAddrEvtHdl;

#if MCAST > 0
#define COMM_MCAST_ADDR  IP_S_MEMBERSHIP  //just pick one in the allowed range
struct sockaddr_in  McastAdd;

#endif

//
// Structures used to store information about partners discovered via
// Multicasting
//
typedef struct _ADD_T {
            DWORD NoOfAdds;
            COMM_IP_ADD_T IpAdd[1];
                  } ADD_T, *PADD_T;

typedef struct _MCAST_PNR_STATUS_T {
                    DWORD   NoOfPnrs;  //no of pnrs in pPnrStatus buffer
                    DWORD   NoOfPnrSlots; //no of pnr slots in pPnrStatus buffer
                    BYTE    Pnrs[1];
                } MCAST_PNR_STATUS_T, *PMCAST_PNR_STATUS_T;

typedef struct _PNR_STATUS_T {
                    COMM_IP_ADD_T  IPAdd;
                    DWORD          State;
                 } PNR_STATUS_T, *PPNR_STATUS_T;

#define MCAST_PNR_STATUS_SIZE_M(_NoOfPnrs) sizeof(MCAST_PNR_STATUS_T) +\
                                           ((_NoOfPnrs) * sizeof(PNR_STATUS_T))

PMCAST_PNR_STATUS_T  pPnrStatus;

//
// To store WINS Addresses
//
PADD_T pWinsAddresses=NULL;  //stores all the IP addresses returned by netbt

/* local function prototypes */
STATIC
DWORD
MonTcp(
        LPVOID
      );
STATIC
DWORD
MonUdp(
        LPVOID
      );
STATIC
VOID
HandleMsg(
        SOCKET         SockNo,
        LPLONG        pBytesRead,
        LPBOOL  pfSockCl
        );


STATIC
VOID
ProcTcpMsg(
        SOCKET   SockNo,
        MSG_T    pMsg,
        MSG_LEN_T MsgLen,
        LPBOOL   pfSockCl
        );

STATIC
VOID
CreateThd(
        DWORD              (*pStartFunc)(LPVOID),
        WINSTHD_TYP_E ThdTyp_e
        );




STATIC
VOID
ParseMsg(
        MSG_T                        pMsg,
        MSG_LEN_T                MsgLen,
        COMM_TYP_E                MsgType,
        struct sockaddr_in         *pFromAdd,
        PCOMMASSOC_ASSOC_CTX_T        pAssocCtx
        );


STATIC
VOID
DelAssoc(
        SOCKET                        SockNo,
        PCOMMASSOC_ASSOC_CTX_T pAssocCtx
        );


STATIC
VOID
InitMem(
        VOID
        );

STATIC
BOOL
ChkNtfSock(
        IN fd_set  *pActSocks,
        IN fd_set  *pRdSocks
        );

STATIC
STATUS
RecvData(
        SOCKET                SockNo,
        LPBYTE                pBuff,
        DWORD                BytesToRead,
        INT                Flags,
        DWORD                SecsToWait,
        LPDWORD                pBytesRead
           );

STATUS
CommTcp(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
        );

#if SPX > 0
STATUS
CommSpx(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
       );
#endif


STATIC
LPVOID
CommHeapAlloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN CLONG                BuffSize
);

STATIC
VOID
CommHeapDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID                pBuff
);

STATIC
NTSTATUS
DeviceIoCtrl(
    IN LPHANDLE         pEvtHdl,
    IN PVOID                pDataBuffer,
    IN DWORD                DataBufferSize,
    IN ULONG            Ioctl
    );

STATIC
VOID
SendNetbt (
  struct sockaddr_in        *pDest,
  MSG_T                   pMsg,
  MSG_LEN_T             MsgLen
 );

#if MCAST > 0
VOID
JoinMcastGrp(
 VOID
);

BOOL
CheckMcastSock(
   IN fd_set  *pActSocks,
   IN fd_set  *pRdSocks
 );

#endif

VOID
CreateTcpIpPorts(
 VOID
);

VOID
CreateSpxIpxPorts(
 VOID
);

BOOL
ChkMyAdd(
 COMM_IP_ADD_T IpAdd
 );


/*
  function definitions start here
*/

VOID
CommCreatePorts(
          VOID
           )

/*++

Routine Description:

 This function creates a TCP and UDP port for the WINS server
 It uses the standard WINS server port # to bind to both the TCP and the UDP
 sockets.

Arguments:

      Qlen           - Length of queue for incoming connects on the TCP port
      pTcpPortHandle - Ptr to SOCKET for the TCP port
      pUdpPortHandle - Ptr to SOCKET for the UDP port
      pNtfSockHandle - Ptr to SOCKET for receiving messages carrying socket
                       handles
      pNtfAdd        - Address bound to Notification socket

Externals Used:
        None

Called by:
        ECommInit

Comments:

        I might want to create a PassiveSock function that would create
        a TCP/UDP port based on its arguments.  This function would then
        be called from MOnTCP and MonUDP.
Return Value:
        None

--*/

{

    CreateTcpIpPorts();
#if SPX > 0
    CreateSpxIpxPorts();
#endif
}

VOID
CreateTcpIpPorts(
 VOID
)
{
    int      Error;
    DWORD    AddLen = sizeof(struct sockaddr_in);
    struct   servent *pServEnt;
    struct   sockaddr_in sin;
    int      SockBuffSize;


    WINSMSC_FILL_MEMORY_M(&sin, sizeof(sin), 0);
    WINSMSC_FILL_MEMORY_M(&CommNtfSockAdd, sizeof(sin), 0);

#if MCAST > 0
    /*
        Allocate a socket for UDP
    */

    if (  (CommUdpPortHandle = socket(
                        PF_INET,
                        SOCK_DGRAM,
                        IPPROTO_UDP
                                 )
          )  == INVALID_SOCKET
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_UDP_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
    DBGPRINT1(MTCAST, "Udp socket # is (%d)\n", CommUdpPortHandle);
#endif

    sin.sin_family      = PF_INET;               //We are using the Internet
                                                 //family
    if (WinsClusterIpAddress) {
        sin.sin_addr.s_addr = htonl(WinsClusterIpAddress);            //Any network
    } else {
        sin.sin_addr.s_addr = 0; //any network
    }


    if (CommWinsTcpPortNo == COMM_DEFAULT_IP_PORT)
    {
     pServEnt = getservbyname( NAMESERVER,  NULL);
     if (!pServEnt)
     {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_UDP_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
     }
     sin.sin_port         = pServEnt->s_port;
     CommWinsTcpPortNo    = ntohs(sin.sin_port);
    }
    else
    {
        sin.sin_port      = htons((USHORT)CommWinsTcpPortNo);
    }
    DBGPRINT1(DET, "UDP/TCP port used is (%d)\n", CommWinsTcpPortNo);

#if MCAST > 0

    //
    // Initialize global with mcast address of WINS. Used by SendMcastMsg
    //
    // Do this here as against later since sin gets changed later on
    //
    McastAdd.sin_family      = PF_INET;        //We are using the Internet
                                               //family
    McastAdd.sin_addr.s_addr = ntohl(inet_addr(COMM_MCAST_ADDR));
    McastAdd.sin_port        = sin.sin_port;

    /*
        Bind the  address to the socket
    */
    if ( bind(
          CommUdpPortHandle,
          (struct sockaddr *)&sin,
          sizeof(sin))  == SOCKET_ERROR
       )
    {

        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }

#endif

    /*
    *        Allocate a socket for receiving TCP connections
    */
    if ( (CommTcpPortHandle = socket(
                PF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                                )
          )  == INVALID_SOCKET
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_LISTENING);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    /*
     *        Bind the address to the socket
    */
#if 0
     sin.sin_port      = pServEnt->s_port;
     CommWinsTcpPortNo   = ntohs(pServEnt->s_port);
     DBGPRINT1(DET, "TCP port used is (%d)\n", CommWinsTcpPortNo);
#endif
     DBGPRINT1(DET, "TCP port used is (%d)\n", ntohs(sin.sin_port));


    if ( bind(
                CommTcpPortHandle,
                (struct sockaddr *)&sin,
                sizeof(sin)
             ) == SOCKET_ERROR
       )
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    // Inform the TCP/IP driver of the queue length for connections
    if ( listen(CommTcpPortHandle, TCP_QUE_LEN) == SOCKET_ERROR)
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_LISTEN_ERR);
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    //
    // Create another socket for receiving socket #s of connections
    // to be added/removed from the list of sockets monitored by the
    // TCP listener thread.  An example of a connection added to the
    // above list is the one initiated by the PULL thread to push update
    // notifications to other WINSs (PULL partners of this thread).  An
    // example of a connection removed is the one on which a PUSH
    // notification (trigger) is received.
    //
    if (  (CommNtfSockHandle = socket(
                                PF_INET,
#if 0
                                SOCK_STREAM,
                                IPPROTO_TCP,
#endif
                                SOCK_DGRAM,
                                IPPROTO_UDP
                                 )
          )  == INVALID_SOCKET
       )
   {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_NTF_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
   }

    sin.sin_port        = 0;  //Use any available port in the range 1024-5000
    /*
        Bind the  address to the socket
    */
    if ( bind(
          CommNtfSockHandle,
          (struct sockaddr *)&sin,
          sizeof(sin))  == SOCKET_ERROR
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    //
    // Let us get the address that we have bound the notification socket to
    //
    if (getsockname(
                        CommNtfSockHandle,
                        (struct sockaddr *)&CommNtfSockAdd,
                        &AddLen
                   ) == SOCKET_ERROR
       )
    {

        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_GETSOCKNAME_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }

    //
    // Set the RCVBUF to FD_SETSIZE * 128.  128 is the # of bytes used up
    // per msg by Afd. We can have a max of FD_SETSIZE  connections initiated
    // to and from WINS. So, making the recv buf this size ensures that msgs
    // sent by push thread to the tcp thread will never get dropped.
    //
    // The above size comes out to be 38.4K for an FD_SETSIZE of 300. This
    // is > 8k which the default used by Afd.  Note:  Specifying this does
    // not use up memory.  It is just used to set a threshold.  pmon will
    // show a higher non-paged pool since the number it shows for the same
    // indicates the amount of memory charged to the process (not necessarily
    // allocated
    //
    SockBuffSize = FD_SETSIZE * 128;
    if (setsockopt(
                       CommNtfSockHandle,
                       SOL_SOCKET,
                       SO_RCVBUF,
                       (char *)&SockBuffSize,
                       sizeof(SockBuffSize)) == SOCKET_ERROR)
    {

          Error = WSAGetLastError();
          DBGPRINT1(ERR,  "CommCreatePorts: SetSockOpt failed", Error);
    }

    //
    // Initialize the address structure for this notification socket.
    // We can't use the address returned by getsockname() if the
    // machine we are running on is a multi-homed host.
    //
    // The IP address is in host byte order since we store all addresses in
    // host order.  CommNtfSockAdd will be passed to CommSendUdp which expects
    // the IP address in it to be in host byte order.
    //
    // Note: the Port should be in net byte order
    //

    //
    // The statement within #if 0 and #endif does not work.
    //
    CommNtfSockAdd.sin_addr.s_addr = NmsLocalAdd.Add.IPAdd;

#if 0
    CommNtfSockAdd.sin_addr.s_addr = ntohl(INADDR_LOOPBACK);
#endif

#if MCAST > 0

    JoinMcastGrp();
    CommSendMcastMsg(COMM_MCAST_WINS_UP);
#endif

    return;
}

#if SPX > 0
VOID
CreateSpxIpxPorts(
 VOID
)
{
    int      Error;
    DWORD    AddLen = sizeof(struct sockaddr_ipx);
    struct   servent *pServEnt;
    struct   sockaddr_ipx sipx;
    struct   hostent *pHostEnt;
    BYTE     HostName[80];

    WINSMSC_FILL_MEMORY_M(&sipx, sizeof(sipx), 0);
    WINSMSC_FILL_MEMORY_M(CommNtfAdd, sizeof(sipx), 0);



    /*
     *        Allocate a socket for receiving TCP connections
    */
    if ( (CommSpxPortHandle = socket(
                PF_IPX,
                SOCK_STREAM,
                NSPROTO_SPX
                                )
          )  == INVALID_SOCKET
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_LISTENING);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    /*
     *        Bind the address to the socket
    */
    sipx.sa_family    = PF_IPX;
    sipx.sa_port      = ntohs(WINS_IPX_PORT);
CHECK("How do I specify that I want the connection from any interface")

    DBGPRINT1(DET, "SPX port used is (%d)\n", WINS_IPX_PORT);
    CommWinsSpxPortNo   = WINS_IPX_PORT;

    if ( bind(
                CommSpxPortHandle,
                (struct sockaddr *)&sipx,
                sizeof(sipx)
             ) == SOCKET_ERROR
       )
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    // Inform the TCP/IP driver of the queue length for connections
    if ( listen(CommSpxPortHandle, SPX_QUE_LEN) == SOCKET_ERROR)
    {
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WINSOCK_LISTEN_ERR);
        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
    }

    //
    // Create another socket for receiving socket #s of connections
    // to be added/removed from the list of sockets monitored by the
    // TCP listener thread.  An example of a connection added to the
    // above list is the one initiated by the PULL thread to push update
    // notifications to other WINSs (PULL partners of this thread).  An
    // example of a connection removed is the one on which a PUSH
    // notification (trigger) is received.
    //
    if (  (CommIpxNtfSockHandle = socket(
                                PF_IPX,
                                SOCK_DGRAM,
                                NSPROTO_IPX
                                 )
          )  == INVALID_SOCKET
       )
   {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_NTF_SOCK);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
   }

    sipx.sa_port        = 0;  //Use any available port in the range 1024-5000
    /*
        Bind the  address to the socket
    */
    if ( bind(
          CommIpxNtfSockHandle,
          (struct sockaddr *)&sipx,
          sizeof(sipx))  == SOCKET_ERROR
       )
    {
        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_BIND_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    //
    // Let us get the address that we have bound the notification socket to
    //
    if (getsockname(
                        CommIpxNtfSockHandle,
                        (struct sockaddr *)&CommIpxNtfSockAdd,
                        &AddLen
                   ) == SOCKET_ERROR
       )
    {

        Error = WSAGetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_GETSOCKNAME_ERR);  //log an event
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }


    //
    // Initialize the address structure for this notification socket.
    // We can't use the address returned by getsockname() if the
    // machine we are running on is a multi-homed host.
    //
    // The IP address is in host byte order since we store all addresses in
    // host order.  *pNtfAdd will be passed to CommSendUdp which expects
    // the IP address in it to be in host byte order.
    //
    // Note: the Port should be in net byte order
    //
#if 0
    if (gethostname(HostName, sizeof(HostName) == SOCKET_ERROR)
    {
        Error = WSAGetLastError();
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
    if (gethostbyname(HostName, sizeof(HostName) == NULL)
    {
        Error = WSAGetLastError();
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
#endif

    //
    // The statement within #if 0 and #endif does not work.
    //
    CommIpxNtfSockAdd->sin_addr.s_addr = 0;

#if 0
    pNtfAdd->sin_addr.s_addr = ntohl(INADDR_LOOPBACK);
#endif

    return;
}
#endif


VOID
CommInit(
         VOID
        )

/*++

Routine Description:

        This function initializes all the lists, tables and memory
        used by COMSYS.

Arguments:
        None

Externals Used:
        CommAssocTable
        CommUdpNbtDlgTable
        CommExNbtDlgHdl
        CommUdpBuffHeapHdl


Return Value:
        None

Error Handling:

Called by:
        ECommInit

Side Effects:

Comments:
        None
--*/
{


        PCOMMASSOC_DLG_CTX_T        pDlgCtx = NULL;

        //
        // Do all memory initialization
        //
        InitMem();

        /*
         * Initialize the table that will store the dialogue context blocks
         * for nbt requests received over the UDP port.
        */
        WINSMSC_INIT_TBL_M(
                        &CommUdpNbtDlgTable,
                        CommCompareNbtReq,
                        CommHeapAlloc,
                        CommHeapDealloc,
                        NULL /* table context*/
                         );

        /*
         * Initialize the  critical sections and queue heads
         *
         * The initialization is done in a CommAssoc function instead of here
         * to avoid recursive includes
        */
        CommAssocInit();

        CommExNbtDlgHdl.pEnt = CommAssocAllocDlg();
        pDlgCtx              = CommExNbtDlgHdl.pEnt;

        /*
         * Initialize the explicit nbt dialogue handle
        */
        pDlgCtx->Typ_e          = COMM_E_UDP;
        pDlgCtx->AssocHdl.pEnt  = NULL;
        pDlgCtx->Role_e         = COMMASSOC_DLG_E_EXPLICIT;

#if USENETBT > 0
        //
        // Create two events (one for send and one for rcv to/from netbt)
        //
        WinsMscCreateEvt(NULL, FALSE, &sNetbtSndEvtHdl);
        WinsMscCreateEvt(NULL, FALSE, &sNetbtRcvEvtHdl);
        WinsMscCreateEvt(NULL, FALSE, &sNetbtGetAddrEvtHdl);
#endif

        return;
}  // CommInit()





DWORD
MonTcp(
        LPVOID pArg
      )

/*++

Routine Description:

        This function is the thread startup function for the TCP listener
        thread.  It monitors the TCP port and the connections that have
        been made and received by this process.

        If a connection is received, it is accepted.  If there is data on
        a TCP connection, a function is called to process it.

Arguments:

        pArg - Argument (Not used)

Externals Used:
        CommTCPPortHandle -- TCP port for the process
        CommAssocTable

Called by:
        ECommInit

Comments:
        None

Return Value:

   Sucess status codes --  WINS_SUCCESS
   Error status codes  --  WINS_FAILURE

--*/


{
        struct          sockaddr_in  fsin;      //address of connector
#if SPX > 0
        struct          sockaddr_ipx  fsipx;      //address of connector
#endif
        SOCKET          Port;
        LPVOID          pRemAdd;
        fd_set          RdSocks;         //The read socket set
        fd_set          ActSocks;        //the active socket set
        int             AddLen = sizeof(fsin);  //length of from address
        u_short         No;              //Counter for iterating over the sock
                                         //array
        BOOL            fSockCl = FALSE;         //Was the socket closed ?
        SOCKET          NewSock = INVALID_SOCKET;
        BOOL            fNewAssoc = FALSE;
        DWORD           BytesRead = 0;
        DWORD           Error;
           int          i = 0;                        //for testing purpose only
        SOCKET          SockNo;
        LONG            NoOfSockReady = 0;
        PCOMMASSOC_ASSOC_CTX_T pAssocCtx = NULL;
        STATUS          RetStat = WINS_SUCCESS;
        BOOL            fLimitReached = FALSE;
#ifdef WINSDBG
        PUINT_PTR pTmpSv;
        DWORD  Index = 0;
#endif


        EnterCriticalSection(&NmsTermCrtSec);
        NmsTotalTrmThdCnt++;
        LeaveCriticalSection(&NmsTermCrtSec);


        FD_ZERO(&ActSocks);             //init the Active socket array
        FD_ZERO(&RdSocks);              //init the Read socket array

        FD_SET(CommTcpPortHandle, &ActSocks); /*set the TCP listening socket
                                                handle in the  Active array */
        FD_SET(CommNtfSockHandle, &ActSocks); /*set the Notification socket
                                               *handle in the Active array */
#if MCAST > 0

        if (CommUdpPortHandle != INVALID_SOCKET)
        {
           //
           // We want to monitor multicast packets also
           //
           FD_SET(CommUdpPortHandle, &ActSocks);
           WinsMscAlloc(MCAST_PNR_STATUS_SIZE_M(RPL_MAX_OWNERS_INITIALLY),
                        (LPVOID *)&pPnrStatus
                       );
           pPnrStatus->NoOfPnrs     = 0;
           pPnrStatus->NoOfPnrSlots = RPL_MAX_OWNERS_INITIALLY;
        }
#endif
#if  SPX > 0

        FD_SET(CommSpxPortHandle, &ActSocks); /*set the TCP listening socket
                                                handle in the  Active array */
        FD_SET(CommIpxNtfSockHandle, &ActSocks); /*set the Notification socket
                                               *handle in the Active array */
#endif
#ifdef WINSDBG
        WinsMscAlloc(SOCKET_TRACK_BUFFER_SIZE, &pTmpSv);
        pTmpW = pTmpSv;
        pEndPtr = (LPLONG)((LPBYTE)pTmpSv + SOCKET_TRACK_BUFFER_SIZE);
#endif

LOOPTCP:
try {

        /*
          Loop forever
        */
        while(TRUE)
        {
          BOOL fConnTcp;
          BOOL fConnSpx;

          fConnTcp = FALSE;
          fConnSpx = FALSE;
          /*
              Copy the the active socket array into the
              read socket array.  This is done every time before calling
              select.  This is because select changes the contents of
              the read socket array.
          */
          WINSMSC_COPY_MEMORY_M(&RdSocks, &ActSocks, sizeof(fd_set));

          /*
            Do a blocking select on all sockets in the array (for connections
            and data)
          */
          DBGPRINT1(FLOW, "Rd array count is %d \n", RdSocks.fd_count);
#ifdef WINSDBG
        if (!sfMemoryOverrun)
        {
          if ((ULONG_PTR)(pTmpW + (10 + RdSocks.fd_count)) > (ULONG_PTR)pEndPtr)
          {
               WinsDbg |= 0x3;
               DBGPRINT0(ERR, "MonTcp: Stopping socket tracking to prevent Memory overrun\n")
               sfMemoryOverrun = TRUE;
          }
          else
          {
            *pTmpW++ = RdSocks.fd_count;
            *pTmpW++ = 0xFFFFFFFF;
            for(i = 0; i< (int)RdSocks.fd_count; i++)
            {
                *pTmpW++ = RdSocks.fd_array[i];
                DBGPRINT1(FLOW, "Sock no is (%d)\n", RdSocks.fd_array[i]);
            }
            *pTmpW++ = 0xFFFFFFFF;
          }
        }
#endif
       if (
                (
                        NoOfSockReady = select(
                                            FD_SETSIZE /*ignored arg*/,
                                            &RdSocks,
                                            (fd_set *)0,
                                            (fd_set *)0,
                                            (struct timeval *)0 //Infinite
                                                                //timeout
                                                  )
                ) == SOCKET_ERROR
             )
          {

                Error = WSAGetLastError();
#ifdef WINSDBG
                if (Error == WSAENOTSOCK)
                {
                        DWORD i;
                        PUINT_PTR pW;
                        WinsDbg |= 0x3;
                        DBGPRINT0(ERR, "MonTcp: Memory dump is\n\n");

                        for (i=0, pW = pTmpSv; pW < pTmpW; pW++,i++)
                        {
                          DBGPRINT1(ERR, "|%x|", *pW);
                          if (*pW == 0xEFFFFFFE)
                          {
                              DBGPRINT1(ERR, "Socket closed = (%x)\n",  *++pW);
                          }
                          if ((i == 16) || (*pW == 0xFFFFFFFF))
                          {
                            DBGPRINT0(ERR, "\n");
                          }

                        }
                        DBGPRINT0(ERR, "Memory Dump End\n");
                }
#endif

                //
                // If state is not terminating, we have an error.  If
                // it is terminating, then the reason we got an error
                // from select is because the main thread closed the
                // TCP socket. In the latter case, we pass WINS_SUCCESS
                // to WinsMscTermThd so that we don't end up signaling
                // the main thread prematurely.
                //
                if (
                          (WinsCnf.State_e == WINSCNF_E_RUNNING)
                                       ||
                          (WinsCnf.State_e == WINSCNF_E_PAUSED)
                   )
                {
                        ASSERT(Error != WSAENOTSOCK);
                        WINSEVT_LOG_D_M( Error, WINS_EVT_WINSOCK_SELECT_ERR );
                        RetStat = WINS_FAILURE;
                }
                else
                {
                  //
                  // State is terminating.  Error should
                  // be WSENOTSOCK
                  //
                  //ASSERT(Error == WSAENOTSOCK);
                }

                WinsThdPool.CommThds[0].fTaken = FALSE;
                WinsMscTermThd(RetStat, WINS_NO_DB_SESSION_EXISTS);
          }
          else
          {


             DBGPRINT1(FLOW, "Select returned with success. No of Sockets ready - (%d) \n", NoOfSockReady);
             /*
                if a connection has been received on the TCP port, accept it
                and change the active socket array
             */
             if (FD_ISSET(CommTcpPortHandle, &RdSocks))
             {
                    fConnTcp = TRUE;
                    Port = CommTcpPortHandle;
                    pRemAdd = &fsin;
             }
#if SPX > 0
             else
             {
                 if (FD_ISSET(CommSpxPortHandle, &RdSocks))
                 {
                    fConnSpx = TRUE;
                    Port = CommSpxPortHandle;
                    pRemAdd = &fsipx;
                 }

             }
#endif
             if (fConnTcp || fConnSpx)
             {
                DWORD  ConnCount;
                //
                // Note: FD_SET can fail silently if the fd_set array is
                // full. Therefore we should check this. Do it here instead
                // of after the accept to save on network traffic.
                //
                ConnCount = InterlockedExchange(&CommConnCount, CommConnCount);
                //if (ActSocks.fd_count >= FD_SETSIZE)

#ifdef WINSDBG
                if (ConnCount >= 200)
                {
                        DBGPRINT0(ERR,
                                "MonTcp: Connection limit of 200 reached. \n");
                }
#endif

#if 0
                if (ConnCount >= FD_SETSIZE)
                {
                        DBGPRINT1(ERR,
                                "MonTcp: Connection limit of %d reached. No accept being done\n",
                                                FD_SETSIZE);
                        WINSEVT_LOG_D_M(ConnCount,
                                        WINS_EVT_CONN_LIMIT_REACHED);
                        fLimitReached = TRUE;
                }
#endif

                DBGPRINT0(FLOW, "Going to do an accept now\n");
                if ( (NewSock = accept(
                                Port,
                                (struct sockaddr *)pRemAdd,
                                &AddLen
                                      )
                     ) == INVALID_SOCKET
                   )
                {
                    Error = WSAGetLastError();
                   if (WinsCnf.State_e !=  WINSCNF_E_TERMINATING)
                   {
                    WINSEVT_LOG_M(
                                Error,
                                WINS_EVT_WINSOCK_ACCEPT_ERR
                                       );
                   }
                   WinsThdPool.CommThds[0].fTaken = FALSE;
                   WinsMscTermThd(
                      (((Error == WSAEINTR) || (Error == WSAENOTSOCK)) ?
                                WINS_SUCCESS : WINS_FAILURE),
                                WINS_NO_DB_SESSION_EXISTS);
                }

                DBGPRINT1(FLOW, "New Sock value is (%d)\n", NewSock);
                if (fLimitReached)
                {
FUTURES("Move this into CommDisc -- add a flag to it to indicate abrupt stop")
                      struct linger Linger;
                      Linger.l_onoff = 0;
                      if (setsockopt(
                               NewSock,
                               SOL_SOCKET,
                               SO_DONTLINGER,
                               (char *)&Linger,
                               sizeof(Linger)) == SOCKET_ERROR)
                      {

                        Error = WSAGetLastError();
                        DBGPRINT1(ERR,
                                "MonTcp: SetSockOpt failed", Error);
                      }
                      fLimitReached = FALSE;
                      CommDisc(NewSock, FALSE);  //close the socket
                      continue;
                }

                FD_SET(NewSock, &ActSocks);
                InterlockedIncrement(&CommConnCount);
#ifdef WINSDBG
                /*
                 * Let us see if the assoc. is there or not.  It shouldn't be
                 * but let us check anyway (robust programming).
                */
                pAssocCtx = CommAssocLookupAssoc( NewSock );

                if (!pAssocCtx)
                {
#endif
                        pAssocCtx = CommAssocCreateAssocInTbl(NewSock);

                        if (!pAssocCtx)
                        {
                           WINSEVT_LOG_D_M(
                                               WINS_OUT_OF_MEM,
                                               WINS_EVT_CANT_ALLOC_RSP_ASSOC
                                              );
                           WinsMscTermThd(WINS_FAILURE, WINS_NO_DB_SESSION_EXISTS);
                        }

#ifdef WINSDBG
                }
                else
                {
                        DBGPRINT0(ERR, "MonTcp: Not a new assoc. Weird\n");

                        //
                        // log an error (Cleanup was not done properly)
                        //
                        return(WINS_FAILURE);

                }
#endif
                pAssocCtx->State_e     = COMMASSOC_ASSOC_E_NON_EXISTENT;
                pAssocCtx->Role_e      = COMMASSOC_ASSOC_E_RESPONDER;
                pAssocCtx->DlgHdl.pEnt = NULL;

                if (fConnTcp)
                {
                   pAssocCtx->RemoteAdd.sin_addr.s_addr =
                                        ntohl(fsin.sin_addr.s_addr);
                   pAssocCtx->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                }
#if SPX > 0
                else
                {
                   RtlCopyMemory(
                         pAssocCtx->RemoteAddSpx.sa_netnum,
                         fsipx.netnum,
                         sizeof(fsipx.netnum);
                   RtlCopyMemory(
                         pAssocCtx->RemoteAddSpx.sa_nodenum,
                         fsipx.nodenum,
                         sizeof(fsipx.nodenum);
                   pAssocCtx->AddTyp_e = COMM_ADD_E_SPXIPX;
                }
#endif
             }
             else  /* one or more sockets has received data or a disconnect*/
             {

#if MCAST > 0

                if (CheckMcastSock(&ActSocks, &RdSocks) == TRUE)
                {
                     continue;
                }
#endif
                //
                // Check if the notification socket has data in it
                // If yes, continue.
                //
                if (ChkNtfSock(&ActSocks, &RdSocks))
                {
                        DBGPRINT0(FLOW,
                           "MonTcp: Notification socket had data in it\n");
                        continue;
                }

                /*
                 * Handle sockets that have been set.  These could have
                 * been set either because there is data on them or
                 * due to disconnects.
                */
                for(No = 0; No < RdSocks.fd_count; ++No)
                {

                  SockNo = RdSocks.fd_array[No];
                  if (FD_ISSET(SockNo, &RdSocks))
                  {
                        BytesRead = 0;
                        fSockCl   = FALSE;

                        DBGPRINT1(FLOW, "MonTcp: Socket (%d) was signaled. It has either data or a disconnect on it\n",
                                SockNo);

                        /*
                         * Socket has data on it or a disconnect.  Call
                         * HandleMsg to handle either case
                        */
                        (VOID)HandleMsg(SockNo, &BytesRead, &fSockCl);

                        /*
                         * if the socket was closed due to a stop message
                         * having been received, let us clean up the
                         * socket array
                        */
                        if (fSockCl)
                        {
                           DBGPRINT1(FLOW, "MonTcp: Sock (%d) was closed\n",
                                        SockNo);
                           FD_CLR(SockNo, &ActSocks);
                        }
                        else
                        {

                          /*
                           * if bytes read are 0, we have a disconnect
                           * All the processing for the disconnect should
                           * have been handled by HandleMsg.  We just need
                           * to close the socket and update the socket
                           * array appropriately.
                           */

                           if (BytesRead == 0)
                           {
                               DBGPRINT0(FLOW,
                                   "MonTcp: Received a disconnect\n");
                               //CommDisc(SockNo, TRUE);
                               FD_CLR(SockNo, &ActSocks);
                            }
                        }
                  }

              } //for (loop over all sockets)

             } //else (one or more sockets has received data or a disconnect
           } //else clause (if select () < 0)
        } // while (TRUE) loop end

  }  // end of try {}
except (EXCEPTION_EXECUTE_HANDLER)  {

        DBGPRINTEXC("MONTCP");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_TCP_LISTENER_EXC);

#if 0
        //
        // Don't use WinsMscTermThd here
        //
        ExitThread(WINS_FAILURE);
#endif
  }
        goto LOOPTCP;  //ugly but useful

        UNREFERENCED_PARAMETER(NoOfSockReady);

        // we should never hit this return
        ASSERT(0);
        return(WINS_FAILURE);
}

DWORD
MonUdp(
        LPVOID pArg
        )

/*++

Routine Description:
        This function is the thread startup function for the UDP listener
        thread.  It monitors the UDP port for UDP messages.

Arguments:
        pArg - Argument (not used)

Externals Used:
        CommUDPPortHandle -- UDP port for the process

Called by:
        ECommInit

Comments:
        None

Return Value:

   Success status codes --
   Error status codes  --

--*/

{


        register LPBYTE               pBuffer;
        struct sockaddr_in            FromAdd;
        int                           AddLen   = sizeof(FromAdd);
        register PCOMM_BUFF_HEADER_T  pBuffHdr = NULL;


        DWORD   DataBuffLen;
        tREM_ADDRESS *pRemAdd;
        NTSTATUS   NTStatus;

LOOP:
try {
        while(TRUE)
        {

          //
          // Allocate a buffer to get the datagram.  This buffer is prefixed
          // by the COMM_BUFF_HEADER_T and tREM_ADDRESS structure.
          //
          pBuffHdr = WinsMscHeapAlloc (
                            CommUdpBuffHeapHdl,
                            COMM_DATAGRAM_SIZE + sizeof(COMM_BUFF_HEADER_T)
                                + COMM_NETBT_REM_ADD_SIZE
                                        );
          DBGPRINT2(HEAP, "MonUdp: HeapHdl = (%p), pBuffHdr=(%p)\n",
                                        CommUdpBuffHeapHdl, pRemAdd);




          pBuffHdr->Typ_e = COMM_E_UDP;

          //
          // Adjust pointer to point to the Remote address header
          //
          pRemAdd = (tREM_ADDRESS *)
                        ((LPBYTE)pBuffHdr + sizeof(COMM_BUFF_HEADER_T));

          DataBuffLen =  COMM_DATAGRAM_SIZE + COMM_NETBT_REM_ADD_SIZE;
          //
          // Point to the data portion (passed to ParseMsg)
          //
          pBuffer         = (LPBYTE)pRemAdd + COMM_NETBT_REM_ADD_SIZE;

          //
          // read a datagram prefixed with the address of the sender from
          // nbt
          //
          NTStatus = DeviceIoCtrl(
                                    &sNetbtRcvEvtHdl,
                                    pRemAdd,
                                    DataBuffLen,
                                    IOCTL_NETBT_WINS_RCV
                                    );

         if (!NT_SUCCESS(NTStatus))
         {

                //
                // log the message only if WINS is not terminating
                //
                if (WinsCnf.State_e != WINSCNF_E_TERMINATING)

                {
                   //
                   // We do not log the message if the Netbt handle is NULL
                   // We can have a small window when the handle may be NULL
                   // This happens when we get an address/device change
                   // notification.  WINS closes the old handle and opens
                   // a new one after such an event if the machine has a
                   // a valid address that WINS can bind with. The address
                   // notification can occur due to ipconfig /release and
                   // /renew or due to psched being installed/removed.
                   //
                   if (WinsCnfNbtHandle != NULL)
                   {
                      WINSEVT_LOG_D_M(
                                NTStatus,
                                WINS_EVT_NETBT_RECV_ERR
                                   );
                   }
                   DBGPRINT1(ERR, "MonUdp:  Status = (%x)\n", NTStatus);
                   WinsMscHeapFree( CommUdpBuffHeapHdl, pBuffHdr);
                   Sleep(0);      //relinquish the processor
                   continue;
                }
                else
                {

                   DBGPRINT0(ERR, "MonUdp, Exiting Thread\n");


                   WinsThdPool.CommThds[1].fTaken = FALSE;
#if TEST_HEAP > 0
                   WinsMscHeapDestroy(CommUdpBuffHeapHdl);
                   DBGPRINT0(ERR, "MonUdp: Destroyed udp buff heap\n");
                   WinsMscHeapDestroy(CommUdpDlgHeapHdl);
                   DBGPRINT0(ERR, "MonUdp: Destroyed udp dlg buff heap\n");
#endif
                   return(WINS_FAILURE);
                }
           }
#ifdef WINSDBG
          ++CommNoOfDgrms;
          DBGPRINT1(FLOW, "UDP listener thread: Got  datagram (from NETBT) no = (%d)\n", CommNoOfDgrms);

//          DBGPRINT1(SPEC, "UDP listener thread: Got  datagram (from NETBT) no = (%d)\n", CommNoOfDgrms);
#endif



           //
           // NETBT returns the same code as is in winsock.h for the
           // internet family.  Also, port and IpAddress returned are
           // in network order
           //
           FromAdd.sin_family            = pRemAdd->Family;
           FromAdd.sin_port              = pRemAdd->Port;
           FromAdd.sin_addr.s_addr = ntohl(pRemAdd->IpAddress);

           // from now on the memory allocated for pBuffHdr is passed down the way so consider it handled there
           // There is basically no chance to hit an exception (unless everything is really messed up - like no mem)
           // in ParseMsg before having this buffer passed down to a different thread for processing.
           pBuffHdr = NULL;
          /*
           * process message
          */
            (void)ParseMsg(
                        pBuffer,
                        COMM_DATAGRAM_SIZE,
                        COMM_E_UDP,
                        &FromAdd,
                        NULL
                        );

        } //end of while(TRUE)

  } // end of try {..}
 except(EXCEPTION_EXECUTE_HANDLER) {

        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "MonUdp: Got Exception (%X)\n", ExcCode);
        if (ExcCode == STATUS_NO_MEMORY)
        {
                //
                //If the exception is due to insufficient resources, it could
                // mean that WINS is not able to keep up with the fast arrivel
                // rate of the datagrams. In such a case drop the datagram.
                //
                WINSEVT_LOG_M( WINS_OUT_OF_HEAP, WINS_EVT_CANT_ALLOC_UDP_BUFF);
        }
        else
        {
                WINSEVT_LOG_M(ExcCode, WINS_EVT_UDP_LISTENER_EXC);
        }
PERF("Check how many cycles try consumes. If negligeble, move try inside the")
PERF("the while loop")
#if 0
        //Don't use WinsMscTermThd here
        ExitThread(WINS_FAILURE);
#endif
        } // end of exception

        if (pBuffHdr != NULL)
            WinsMscHeapFree(CommUdpBuffHeapHdl, pBuffHdr);

        goto LOOP;        //ugly but useful

        //
        // we should never hit this return
        //
        ASSERT(0);
        return(WINS_FAILURE);
}


VOID
HandleMsg(
        IN  SOCKET         SockNo,
        OUT LPLONG        pBytesRead,
        OUT LPBOOL          pfSockCl
        )

/*++

Routine Description:

        This function is called to read in a message or a disconnect from
        a socket and handle either appropriately.
        If there were no bytes received on the socket, tt
        does the cleanup

        The bytes read are handed to ProcTcpMsg function.

Arguments:

        SockNo     - Socket to read data from
        pBytesRead - # of bytes that were read
        fSockCl    - whether the socket is in closed condition

Externals Used:
        None

Called by:

        MonTcp

Comments:
        None

Return Value:
        None
--*/
{

        MSG_T    pMsg;
        STATUS   RetStat;

        /*
        *  Read in the message from the socket
        */
        // ---ft: 06/16/2000---
        // The second parameter to the call below has to be TRUE (timed receive).
        // If it is not so (it was FALSE before this moment) the following scenario
        // could happen.
        // An attacher creates a TCP socket and connects it to port 42 to any
        // WINS server and then sends 4 or less bytes on that socket. He leaves the
        // connection open (doesn't close the socket) and simply unplug his net cable.
        // Then he kills his app. Although his end of the connection terminates, WINS
        // will have no idea about that (since the cable is disconnected) and will
        // remain blocked in the call below (CommReadStrea->RecvData->recv) indefinitely
        //
        // Consequences:
        // - WINS will never be able again to listen on the TCP port 42: push/pull replication
        // is brought down along with the consistency checking.
        // - WINS will not be able to terminate gracefully (in case the administrator attempts
        // to shut down the service and restart it) because the MonTcp thread is in a hung state
        //
        // The same could happen in more usual cases (not necesarily on an intenional attack):
        // While sending Push notification (which happens quite often):
        // 1) the pusher is powered down (power outage)
        // 2) the pusher hits a PnP event like media disconnect or adapter disabled
        // 3) some router is down between the pusher and the receiving WINS.
        //
        // With this fix the best we can do for now is to have MonTcp thread recover in 20mts.
        // Even better would be to log an event.
        RetStat = CommReadStream(
                                  SockNo,
                                  TRUE,  //don't do timed recv
                                  &pMsg,
                                  pBytesRead
                                );

        //
        // if either RetStat is not WINS_SUCCESS or the number of bytes
        // read are 0, we need to delete the association and close the
        // socket.  Further, we need to set *pfSockCl to TRUE to indicate
        // to the caller (MonTcp) that it should get rid of the socket
        // from its array of sockets.
        //
        if ((RetStat != WINS_SUCCESS) || (*pBytesRead == 0))
        {
                /*
                 * No bytes received.  This means that it is a disconnect
                * Let us get rid of the context associated with  the socket
                */
                DelAssoc(
                           SockNo,
                           NULL /* we don't have the ptr to assoc block*/
                        );

                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
        }
        else   // means (RetStat == WINS_SUCCESS) and (*pBytesRead > 0)
        {
                ASSERT(*pBytesRead > 0);

                /*
                 *                process the message
                */
                ProcTcpMsg(
                           SockNo,
                           pMsg,
                           *pBytesRead,
                           pfSockCl
                          );
        }
        return;
}  // HandleMsg()


STATUS
CommReadStream(
        IN         SOCKET  SockNo,
        IN         BOOL        fDoTimedRecv,
        OUT         PMSG_T         ppMsg,
        OUT        LPLONG        pBytesRead
        )

/*++

Routine Description:

        This function reads from a TCP socket.  If there are no bytes
        there, it means a disconnect was received on that socket.

Arguments:
        SockNo     - Socket to read data from
        fDoTimedRecv - Whether timed receive should be done (set to TRUE only
                     if we are not sure whether data has arrived or not yet)
        ppMsg      - Buffer containing data that was read in
        pBytesRead - Size of buffer


Return Value:

    TBS

--*/

{
        u_long          MsgLen;
        LONG          BytesToRead;
        INT          Flags        = 0; /*flags for recv call (PEEK and/or OOB).
                                     * we want neither
                                    */
        WINS_MEM_T               WinsMem[2];
        PWINS_MEM_T              pWinsMem = WinsMem;
        STATUS                         RetStat;
        PCOMM_BUFF_HEADER_T  pBuffHdr;

        DBGENTER("CommReadStream\n");
        pWinsMem->pMem = NULL;

#ifdef WINSDBG
try {
#endif

        /*
         * All TCP messages are preceded by a length word (4 bytes) that
         * gives the length of the message that follows.   Read the length
         * bytes.
        */
        RetStat  = RecvData(
                                SockNo,
                                 (LPBYTE)&MsgLen,
                                  sizeof(u_long),
                                  Flags,
                                fDoTimedRecv ? TWENTY_MTS : fDoTimedRecv,
                                pBytesRead
                                );


        /*
         * Check if there was an error in reading.  We will have a RetStat
         * of WINS_SUCCESS even if 0 bytes (meaning a disconnect) were read
         * in
        */
        if (RetStat == WINS_SUCCESS)
        {
            if (*pBytesRead != 0)
            {
               COMM_NET_TO_HOST_L_M(MsgLen, MsgLen);

               //
               // Just making sure that the message length did not get
               // corrupted on the way. Also, this is a good guard against
               // a process that is trying to bring us down.
               //
               if (MsgLen <= MAX_BYTES_IN_MSG)
               {
                    /*
                     * Allocate memory for the buffer. Allocate extra space
                     * at the top to store the Header for the buffer.  This
                     * header is used to store information about the buffer.
                     * (See ECommFreeBuff also)
                    */
                    *ppMsg = WinsMscHeapAlloc(
                                CommAssocTcpMsgHeapHdl,
                                MsgLen +
#if USENETBT > 0
                                   COMM_NETBT_REM_ADD_SIZE +
#endif
                                  sizeof(COMM_BUFF_HEADER_T) + sizeof(LONG)
                            );
                    //
                    // if *ppMsg is NULL, it means that we received garabage
                    // in the first 4 bytes.  It should have been the length
                    // of the message.
                    //
                    if (*ppMsg == NULL)
                    {
                        //
                        // return with *pBytesRead = 0
                        //
                        *pBytesRead = 0;
                        return(WINS_FAILURE);
                    }

                    pWinsMem->pMem = *ppMsg;
                    (++pWinsMem)->pMem   = NULL;

                    /*
                     * Increment pointer past the buffer header and field
                     *  storing  the length of the message.
                    */
                    pBuffHdr =  (PCOMM_BUFF_HEADER_T)(*ppMsg + sizeof(LONG));
                    *ppMsg   = *ppMsg +
#if USENETBT > 0
                          COMM_NETBT_REM_ADD_SIZE +
#endif
                          sizeof(COMM_BUFF_HEADER_T) + sizeof(LONG);
#if 0
                    pBuffHdr =
                     (PCOMM_BUFF_HEADER_T)(*ppMsg - sizeof(COMM_BUFF_HEADER_T));
#endif

                    pBuffHdr->Typ_e = COMM_E_TCP;  //store type of buffer info
                    BytesToRead     = MsgLen;

                    /*
                      *  Read the whole message into the allocated buffer
                    */
                    RetStat = RecvData(
                                        SockNo,
                                        *ppMsg,
                                        BytesToRead,
                                        Flags,
                                        fDoTimedRecv ? FIVE_MTS : fDoTimedRecv,
                                        pBytesRead
                                    );
                    //
                    // If no bytes were read, deallocate memory
                    //
                    if ((*pBytesRead == 0) || (RetStat != WINS_SUCCESS))
                    {
                        ECommFreeBuff(*ppMsg);
                    }
              }
              else
              {
                  DBGPRINT1(ERR, "CommReadStream: Message size (%x) is TOO BIG\n", MsgLen);
                  WINSEVT_LOG_M(MsgLen, WINS_EVT_MSG_TOO_BIG);
                  *pBytesRead = 0;
              }
           }
        } // if (RetStat == WINS_SUCCESS)
#ifdef WINSDBG
        else
        {
                //
                // *pBytesRead = 0 is a valid condition.  It indicates a
                // disconnect from the remote WINS
                //
        }
#endif
#ifdef WINSDBG
  } // end of try { .. }
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("CommReadStream");
                WINS_HDL_EXC_M(WinsMem);
                WINS_RERAISE_EXC_M();
        }
#endif
        DBGLEAVE("CommReadStream\n");
        return(RetStat);
} //CommReadStream()


VOID
ProcTcpMsg(
        IN  SOCKET   SockNo,
        IN  MSG_T    pMsg,
        IN  MSG_LEN_T MsgLen,
        OUT LPBOOL   pfSockCl
        )

/*++

Routine Description:

        This function processes a TCP message after it has been read in
Arguments:
        SockNo - Socket on which data was received
        pMsg   - Buffer containing data
        MsgLen - Size of buffer
        pfSockCl - Flag indicating whether the socket was closed

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        HandleMsg

Side Effects:

Comments:
        None
--*/

{
#if SUPPORT612WINS > 0
   BYTE                                        AssocMsg[COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE];
#else
   BYTE                                        AssocMsg[COMMASSOC_ASSOC_MSG_SIZE];
#endif

   DWORD                          Opc;
   DWORD                          MsgTyp;
   DWORD                             MsgSz = sizeof(AssocMsg);
   PCOMMASSOC_ASSOC_CTX_T   pAssocCtx;
   PCOMMASSOC_DLG_CTX_T     pDlgCtx;
   BOOL                     fAssocAV = FALSE;

   DBGENTER("ProcTcpMsg\n");

//#ifdef WINSDBG
try {
//#endif

   /*
        Get the opcode and check whether it is an NBT message or a
        message from a WINSS.
   */
   if (NMSISNBT_M(pMsg))
   {
           /*
        * Get the assoc. ctx block associated with the socket
           */
           if ( (pAssocCtx = CommAssocLookupAssoc(SockNo) ) == NULL )
           {
                ECommFreeBuff(pMsg);
                WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_CANT_LOOKUP_ASSOC);
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
           }


        if (pAssocCtx->DlgHdl.pEnt == NULL)
        {
                pDlgCtx = CommAssocAllocDlg();

                //
                // The following will initialize the dlg and assoc ctx
                // blocks.  The association will be marked ACTIVE.
                //
                COMMASSOC_SETUP_COMM_DS_M(
                        pDlgCtx,
                        pAssocCtx,
                        COMM_E_NBT,
                        COMMASSOC_DLG_E_IMPLICIT
                                  );
        }

           /*
             * Parse the message
           */
           ParseMsg(
                  pMsg,
                  MsgLen,
                  pAssocCtx->Typ_e,
                  &pAssocCtx->RemoteAdd,
                  pAssocCtx
                );
   }
   else /*message from WINS */
   {
        ULONG uLocalAssocCtx;

        COMM_GET_HEADER_M(pMsg, Opc, uLocalAssocCtx, MsgTyp);

        DBGPRINT1(REPL,"ProcTcpMsg: Got Wins msg with tag %08x.\n", uLocalAssocCtx);

        pAssocCtx = (PCOMMASSOC_ASSOC_CTX_T)CommAssocTagMap(&sTagAssoc, uLocalAssocCtx);

        /*
          If the ptr to my assoc. ctx block is NULL, it means that
          this is the "start asssoc req" message from the remote WINS.

          We don't need to check MsgTyp but are doing it anyway for more
          robust error checking
        */
        if ((pAssocCtx == NULL) && (MsgTyp == COMM_START_REQ_ASSOC_MSG))
        {

            /*
             Get the assoc. ctx block associated with the socket
                */

                if ( (pAssocCtx = CommAssocLookupAssoc(SockNo)) == NULL )
                {
                        ECommFreeBuff(pMsg);
                        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_CANT_LOOKUP_ASSOC);
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                }

            /*
                       Unformat the assoc. message.  This function will return
                       with an error status if the message received is not
                 a start assoc. message.
            */
            CommAssocUfmStartAssocReq(
                        pMsg,
                        &pAssocCtx->Typ_e,
                        &pAssocCtx->MajVersNo,
                        &pAssocCtx->MinVersNo,
                        &pAssocCtx->uRemAssocCtx
                                     );

#if SUPPORT612WINS > 0
            if (MsgLen >= (COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE - sizeof(LONG)))
            {
               pAssocCtx->MajVersNo = WINS_BETA2_MAJOR_VERS_NO;
            }
#endif
            //
            // Free the buffer read in.
            //
            ECommFreeBuff(pMsg);

            /*
                check if association set up params specified in the
                message are acceptable.
             */
            //
            // if the version numbers do not match, terminate the association
            // and log a message
            //
#if SUPPORT612WINS > 0
            if (pAssocCtx->MajVersNo != WINS_BETA2_MAJOR_VERS_NO)
            {
#endif
             if (pAssocCtx->MajVersNo != WINS_MAJOR_VERS)
             {

                DelAssoc(0, pAssocCtx);
                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
                //CommDecConnCount();
                WINSEVT_LOG_M(pAssocCtx->MajVersNo, WINS_EVT_VERS_MISMATCH);
                   DBGLEAVE("ProcTcpMsg\n");
                return;
             }
#if SUPPORT612WINS > 0
            }
#endif

FUTURES("When we support more sophisticated association set up protocol")
FUTURES("we will check the params.  A more sophisticated set up protocol")
FUTURES("is one where there is some negotiation going one. Backward")
FUTURES("compatibility is another item which would require it")

             /*
              *        Format a start assoc. response message.
              *
              *        The address passed to the formatting function is offset
              *        from the address of the buffer by a LONG so that
              *        CommSendAssoc can store the length of the message in it.
             */
             CommAssocFrmStartAssocRsp(
                                       pAssocCtx,
                                       AssocMsg + sizeof(LONG),
                                       MsgSz - sizeof(LONG)
                                      );


             CommSendAssoc(
                        pAssocCtx->SockNo,
                        AssocMsg + sizeof(LONG),
                        MsgSz - sizeof(LONG)
                        );


             //
             // Allocate the dlg and initialize the assoc and dlg ctx blocks.
             // The association is marked ACTIVE
             //
             pDlgCtx = CommAssocAllocDlg();
             COMMASSOC_SETUP_COMM_DS_M(
                        pDlgCtx,
                        pAssocCtx,
                        pAssocCtx->Typ_e,
                        COMMASSOC_DLG_E_IMPLICIT
                                  );

        }
        else /*the assoc has to be in the ACTIVE state        */
        {

           /*
            Let us check that this is not the stop assoc message
           */
           if (MsgTyp == COMM_STOP_REQ_ASSOC_MSG)
           {

                fAssocAV = TRUE;
                DelAssoc(0, pAssocCtx);
                fAssocAV = FALSE;
                ECommFreeBuff(pMsg);
                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
                //CommDecConnCount();
           }
           else
           {
PERF("Remove this test")
CHECK("Is there any need for this test")
              fAssocAV = TRUE;
              if (pAssocCtx->State_e == COMMASSOC_ASSOC_E_NON_EXISTENT)
              {
                fAssocAV = FALSE;
                ECommFreeBuff(pMsg);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_BAD_STATE_ASSOC);
                DelAssoc(0, pAssocCtx);
                CommDisc(SockNo, TRUE);
                *pfSockCl = TRUE;
//                CommDecConnCount();
                WINS_RAISE_EXC_M(WINS_EXC_BAD_STATE_ASSOC);
              }
              else
              {
                fAssocAV = FALSE;
              }

                 /*
                   *  Parse the message header to determine what message it is.
                 */
                 ParseMsg(
                        pMsg,
                        MsgLen,
                        pAssocCtx->Typ_e,
                          &pAssocCtx->RemoteAdd,  //not used
                        pAssocCtx
                       );
          } //else (msg is not stop assoc msg)
       } //else (assoc is active)
    } // else (message is from a remote wins
//#ifdef WINSDBG
  } // end of try block
 except(EXCEPTION_EXECUTE_HANDLER) {
                DWORD ExcCode = GetExceptionCode();
FUTURES("Distinguish between different exceptions. Handle some. Reraise others")
                DBGPRINT1(EXC, "ProcTcpMsg: Got Exception (%x)\n", ExcCode);
                WINSEVT_LOG_D_M(ExcCode, WINS_EVT_SFT_ERR);
                if (ExcCode == WINS_EXC_COMM_FAIL)
                {
                     DelAssoc(0, pAssocCtx);
                     CommDisc(SockNo, TRUE);
                     *pfSockCl = TRUE;
//                     CommDecConnCount();
                }
                if (fAssocAV)
                {
                      ECommFreeBuff(pMsg);
                      // Without the following the assoc and the tcp connection
                      // will stay until either the tcp connection gets a valid
                      // message (one with the correct pAssocCtx) or it gets
                      // terminated
#if 0
                      DelAssoc(SockNo, NULL);
                      CommDisc(SockNo, TRUE);
                      *pfSockCl = TRUE;
    //                  CommDecConnCount();
#endif
                }

        //        WINS_RERAISE_EXC_M();
        }
//#endif


           DBGLEAVE("ProcTcpMsg\n");
        return;
} //ProcTcpMsg()

VOID
CommCreateTcpThd(
        VOID
        )

/*++

Routine Description:
        This function creates the TCP listener thread

Arguments:
        None


Externals Used:
        None

Called by:
        CommInit

Comments:

Return Value:
        None
--*/

{
        CreateThd(MonTcp, WINSTHD_E_TCP);
        return;
}

VOID
CommCreateUdpThd(VOID)

/*++

Routine Description:
        This function creates the UDP listener thread

Arguments:
        None


Externals Used:
        None

Called by:
        CommInit

Comments:

Return Value:
        None

--*/

{
        CreateThd(MonUdp, WINSTHD_E_UDP);
        return;
}


VOID
CreateThd(
        DWORD              (*pStartFunc)(LPVOID),
        WINSTHD_TYP_E ThdTyp_e
        )
/*++

Routine Description:

        This function creates a  COMSYS thread and initializes the
        context for it.

Arguments:
        pStartFunc -- address of startup function for the thread
        ThdTyp_e -- Type of thread (TCP listener or UDP listener)


Externals Used:
        WinsThdPool

Called by:
        CommCreateTCPThd, CommCreateUDPThd

Comments:
        None

Return Value:
        None
--*/

{

        HANDLE        ThdHandle;
        DWORD ThdId;
        INT        No;

        /*
          Create a thread with no sec attributes (i.e. it will take the
          security attributes of the process), and default stack size
        */

        ThdHandle = WinsMscCreateThd(
                                   pStartFunc,
                                 NULL,                 /*no arg*/
                                 &ThdId
                                );


FUTURES("Improve the following to remove knowledge of # of threads in commsys")
        /*
          Grab the first slot for comm threads (2 slots in total) if available.
          Else, use the second one.  Initialize the thread context block
        */
        No = (WinsThdPool.CommThds[0].fTaken == FALSE) ? 0 : 1;
        {

           WinsThdPool.CommThds[No].fTaken    = TRUE;
           WinsThdPool.CommThds[No].ThdId     = ThdId;
           WinsThdPool.CommThds[No].ThdHdl    = ThdHandle;
           WinsThdPool.CommThds[No].ThdTyp_e  = ThdTyp_e;
        }

        WinsThdPool.ThdCount++;

        return;
}



STATUS
CommConnect(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
           )
/*++
Routine Description:
        This function creates a TCP connection to a destination host

Arguments:
        pHostAdd  --pointer to Host's address
        Port     -- Port number to connect to
        pSockNo  -- ptr to a Socket variable


Called by:

Externals Used:

Return Value:

    TBS

--*/

{

        //struct sockaddr_in        sin; //*Internet endpoint address
        DWORD  ConnCount;

        ConnCount = InterlockedExchange(&CommConnCount, CommConnCount);
#ifdef WINSDBG
        if (ConnCount >= 200)
        {
                        DBGPRINT0(ERR,
                                "MonTcp: Connection limit of 200 reached. \n");
        }
#endif
#if 0
        if (ConnCount >= FD_SETSIZE)
        {
             DBGPRINT2(EXC, "CommConnect: Socket Limit reached. Current no = (%d). Connection not being made to WINS. Address faimly of WINS is  (%s)\n",
            ConnCount,
            pHostAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP ? "TCPIP" : "SPXIPX"
                      );
                WINSEVT_LOG_D_M(ConnCount, WINS_EVT_CONN_LIMIT_REACHED);
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }
#endif

#if SPX == 0
       if (CommTcp(pHostAdd, Port, pSockNo) != WINS_SUCCESS)
       {
                return(WINS_FAILURE);
       }
#else
       if (pHostAdd->AddTyp_e == COMM_ADD_E_TCPUDPIP)
       {
               if (CommTcp(pHostAdd, Port, pSockNo) != WINS_SUCCESS)
               {
                  return(WINS_FAILURE);
               }
       }
       else
       {
               if (CommSpx(pHostAdd, Port, pSockNo) != WINS_SUCCESS)
               {
                  return(WINS_FAILURE);
               }
       }
       //
#endif
       // Connection has been made.  Let us increment the connection count
       //
       InterlockedIncrement(&CommConnCount);
       return(WINS_SUCCESS);
}

STATUS
CommTcp(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
       )
{

        struct sockaddr_in        destsin; //*Internet endpoint address
        struct sockaddr_in        srcsin;
//        DWORD  ConnCount;

        if (pHostAdd->Add.IPAdd == INADDR_NONE)
        {
           return(WINS_FAILURE);
        }





        //
        //  Create a TCP socket and connect it to the target host
        //
        if ((*pSockNo = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        {
                WINSEVT_LOG_M(
                               WSAGetLastError(),
                               WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_CONN
                             );
                return(WINS_FAILURE);

        }

        if (WinsClusterIpAddress) {
            WINSMSC_FILL_MEMORY_M(&srcsin, sizeof(srcsin), 0);
            srcsin.sin_addr.s_addr = htonl(WinsClusterIpAddress);
            srcsin.sin_family      = PF_INET;
            srcsin.sin_port        = 0;

            if ( bind(*pSockNo,(struct sockaddr *)&srcsin,sizeof(srcsin))  == SOCKET_ERROR)
            {

                WINSEVT_LOG_M(WSAGetLastError(), WINS_EVT_WINSOCK_BIND_ERR);  //log an event
                return(WINS_FAILURE);
            }

        }


FUTURES("May want to call setsockopt() on it to enable graceful close")
        WINSMSC_FILL_MEMORY_M(&destsin, sizeof(destsin), 0);
        destsin.sin_addr.s_addr = htonl(pHostAdd->Add.IPAdd);
        destsin.sin_family      = PF_INET;
        destsin.sin_port        = (u_short)htons((u_short)Port);

        if (
                connect(*pSockNo, (struct sockaddr *)&destsin, sizeof(destsin))
                                        == SOCKET_ERROR
           )
        {
                struct in_addr InAddr;
                InAddr.s_addr = destsin.sin_addr.s_addr;

                WinsEvtLogDetEvt(FALSE, WINS_EVT_WINSOCK_CONNECT_ERR,
                                NULL, __LINE__, "sd",
                                COMM_NETFORM_TO_ASCII_M(&InAddr),
                                WSAGetLastError());
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }

        return(WINS_SUCCESS);
}

#if SPX > 0
STATUS
CommSpx(
        IN  PCOMM_ADD_T pHostAdd,
        IN  SOCKET Port,
        OUT SOCKET *pSockNo
 )
{
        struct sockaddr_ipx        sipx; //*SPX/IPX endpoint address
        LPVOID pRemAdd;
        DWORD  SizeOfRemAdd;

        //
        //  Create an SPX socket and connect it to the target host
        //
        if ((*pSockNo = socket(PF_IPX, SOCK_STREAM, NSPROTO_SPX)) ==
                                       INVALID_SOCKET)
        {
              WINSEVT_LOG_M(WSAGetLastError(),
                          WINS_EVT_CANT_CREATE_TCP_SOCK_FOR_CONN);
              return(WINS_FAILURE);

        }
        WINSMSC_FILL_MEMORY_M(&sipx, sizeof(sipx), 0);
        sipx.sa_socket = htons(Port);
        sipx.sa_family      = PF_IPX;
        RtlCopyMemory(sipx.sa_netnum, pHostAdd->Add.netnum,
                                     sizeof(pHostAdd->Add.netnum);
        RtlCopyMemory(sipx.sa_nodenum, pHostAdd->Add.nodenum,
                                      sizeof(pHostAdd->Add.nodenum);


FUTURES("May want to call setsockopt() on it to enable graceful close")
        if (
                connect(*pSockNo, (struct sockaddr *)&sipx, sizeof(sipx))
                                        == SOCKET_ERROR
           )
        {
PERF("Pass address as binary data. Also log WSAGetLastError()")

                WinsEvtLogDetEvt(FALSE, WINS_EVT_WINSOCK_CONNECT_ERR,
                                NULL, __LINE__, "sd",
                                sipx.sa_nodenum,
                                WSAGetLastError());
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
        }

       return(WINS_SUCCESS);
}
#endif

VOID
CommSend(
        COMM_TYP_E         CommTyp_e,
        PCOMM_HDL_T      pAssocHdl,
        MSG_T                 pMsg,
        MSG_LEN_T        MsgLen
)
/*++

Routine Description:

        This function is called to send a TCP message to a WINS server or to
        an nbt client

Arguments:
        CommTyp_e - Type of communication
        pAssocHdl - Handle to association to send message on
        pMSg          - Message to send
        MsgLen          - Length of above message

Externals Used:
        None

Called by:
        Replicator code

Comments:
        This function should not be called for sending assoc messages.

Return Value:

        None
--*/
{


     PCOMM_HEADER_T  pCommHdr         = NULL;
     PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pAssocHdl->pEnt;
     LPLONG             pLong;

    if (!CommLockBlock(pAssocHdl))
    {
        WINS_RAISE_EXC_M(WINS_EXC_LOCK_ASSOC_ERR);
    }

try {
         /*
         *  If it is not an NBT message (i.e. it is a WINS message), we
         *  need to set the header appropriately
         */
         if (CommTyp_e != COMM_E_NBT)
         {

             pCommHdr = (PCOMM_HEADER_T)(pMsg - COMM_HEADER_SIZE);
             pLong    = (LPLONG) pCommHdr;

                   COMM_SET_HEADER_M(
                        pLong,
                        WINS_IS_NOT_NBT,
                        pAssocCtx->uRemAssocCtx,
                        COMM_RPL_MSG
                       );

             pMsg   = (LPBYTE)pCommHdr;
             MsgLen = MsgLen + COMM_HEADER_SIZE;
          }

        /*
          send the message
        */
        CommSendAssoc(
                        pAssocCtx->SockNo,
                        pMsg,
                        MsgLen
                   );

   }
finally {

        CommUnlockBlock(pAssocHdl);
    }

    return;
}



VOID
CommSendAssoc(
          SOCKET    SockNo,
          MSG_T     pMsg,
          MSG_LEN_T MsgLen
  )
/*++

Routine Description:

        This function is called to interface with the TCP/IP code for
        sending a message on a TCP link
Arguments:

        SockNo - Socket to send message on
        pMsg   - Message to send
        MsgLen - Length of message to send
Externals Used:
        None

Called by:
          CommAssocSetUpAssoc
Comments:
        None

Return Value:

        None

--*/
{

        int    Flags     = 0;        //flags to indicate OOB or DONTROUTE
        INT    Error;
        int    BytesSent;
        LONG   Len       = MsgLen;
        LPLONG pLong =  (LPLONG)(pMsg - sizeof(LONG));
        int        NoOfBytesToSend;



        //initialize the last four bytes with the length of
        //the message

        COMM_HOST_TO_NET_L_M(Len, Len);
        *pLong  = Len;

        MsgLen  = MsgLen + 4;


       while(MsgLen > 0)
       {

        //
        // Since send(...) takes an int for the size of the message, let us
        // be conservative (since int could be different on different
        // machines) and not specify anything larger than MAXUSHORT.
        //
        // This strategy is also prudent since winsock may not work
        // properly for sizes > 64K
        //
        if ( MsgLen > MAXUSHORT)
        {
            NoOfBytesToSend = MAXUSHORT;
        }
        else
        {
            NoOfBytesToSend = MsgLen;
        }

        BytesSent = send(
                          SockNo,
                          (LPBYTE)pLong,
                          NoOfBytesToSend,
                          Flags
                         );

        if (BytesSent == SOCKET_ERROR)
        {
                Error = WSAGetLastError();

                if (
                    (Error == WSAENOTCONN)    ||
                    (Error == WSAECONNRESET)  ||
                    (Error == WSAECONNABORTED) ||
                    (Error == WSAEDISCON)

                   )
                {
                        DBGPRINT1(ERR, "CommSendAssoc: send returned SOCKET_ERROR due to connection abortion or reset. Error = (%d) \n", Error);

                        WINSEVT_LOG_D_M(
                                Error,
                                WINS_EVT_WINSOCK_SEND_MSG_ERR
                                    );
                        WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
                //        break;

                }
                else
                {

                        DBGPRINT1(ERR, "CommSendAssoc: send returned SOCKET_ERROR due to severe error = (%d) \n", Error);
                        //
                        // Some severe error.  Raise an exception.  We
                        // don't want the caller to ignore this.
                        //
                        WINSEVT_LOG_M(Error, WINS_EVT_WINSOCK_SEND_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
                }

        }
        else
        {
           if (BytesSent < NoOfBytesToSend)
           {

                DBGPRINT2(ERR, "CommSendAssoc: Bytes Sent (%d) are < Specified (%d)\n", BytesSent, NoOfBytesToSend);
                WINSEVT_LOG_D_M(BytesSent, WINS_EVT_WINSOCK_SEND_MSG_ERR);


                /*
                 * The connection could have gone down because of the
                 * other side aborting in the middle
                 *
                 * We should log an error but not raise an exception.
                */
                //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
               // break;

           }
           else  //BytesSent == NoOfBytesToSend
           {
                //
                // Let us update the length left and the pointer into the
                // buffer to send.
                //
                MsgLen -= BytesSent;
                pLong  = (LPLONG)((LPBYTE)pLong + BytesSent);
           }

        }
    }
        return;
}  // CommSendAssoc()


VOID
CommDisc(
        SOCKET SockNo,
        BOOL   fDecCnt
        )

/*++

Routine Description:

        This function closes the connection (socket)

Arguments:
        SockNo - Socket that needs to be disconnected

Externals Used:

        None

Called by:
        MonTcp, HandleMsg, ProcTcpMsg, CommEndAssoc
Comments:
        None

Return Value:

        None
--*/
{

        DBGPRINT1(FLOW, "CommDisc: Closing socket = (%d)\n", SockNo);

        if (closesocket(SockNo) == SOCKET_ERROR)
        {
                WINSEVT_LOG_M(WSAGetLastError(),
                                WINS_EVT_WINSOCK_CLOSESOCKET_ERR);
                //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }
#ifdef WINSDBG
         if (!sfMemoryOverrun)
         {
          if ((UINT_PTR)(pTmpW + 2) < (UINT_PTR)pEndPtr)
          {
              *pTmpW++ = 0xEFFFFFFE;
              *pTmpW++ = SockNo;
          }
          else
          {
               WinsDbg |= 0x3;
               DBGPRINT0(ERR, "CommDisc: Stopping socket close tracking to prevent Memory overrun\n")
               sfMemoryOverrun = TRUE;
          }
        }
#endif

        if (fDecCnt)
        {
            CommDecConnCount();
        }
        return;
}



VOID
CommSendUdp (
  SOCKET                 SockNo,
  struct sockaddr_in        *pDest,
  MSG_T                   pMsg,
  MSG_LEN_T             MsgLen
  )
/*++

Routine Description:


        This function is called to send a message to an NBT node using the
        datagram port

Arguments:

        SockNo - Socket to send message on (UDP port)
        pDest  - Address of node to send message to
        pMsg   - Message to send
        MsgLen - Length of message to send

Externals Used:
        None

Called by:

            NmsNmh functions
Comments:
        None

Return Value:

        None
--*/


{

        DWORD  BytesSent;
        DWORD  Error;
        int    Flags = 0;
        struct sockaddr_in  CopyOfDest;

#if USENETBT > 0
        //
        // When the address to send the datagram to is CommNtfSockAdd, we
        // use sockets, else we send it over NETBT.
        //
#if MCAST > 0
        if ((pDest != &CommNtfSockAdd) && (SockNo !=  CommUdpPortHandle))
#else
        if (pDest != &CommNtfSockAdd)
#endif
        {
                SendNetbt(pDest, pMsg, MsgLen);
                return;
        }
#endif
        //
        // use copy of the destination so that when we change the byte
        // order in it, we don't disturb the source.  This is important
        // because CommSendUdp can be called multiple times by HdlPushNtf
        // in the Push thread with pDest pointing to the address of the
        // UDP socket used by the TCP listener thread.  This address is
        // in host byte order and should not be changed
        //
        CopyOfDest = *pDest;

        CopyOfDest.sin_addr.s_addr          = htonl(pDest->sin_addr.s_addr);
        BytesSent = (DWORD)sendto(
                                SockNo,
                                pMsg,
                                MsgLen,
                                Flags,
                                (struct sockaddr *)&CopyOfDest,
                                sizeof(struct sockaddr)
                                 );

        if ((BytesSent != MsgLen) || (BytesSent == SOCKET_ERROR))
        {
                Error = WSAGetLastError();
#ifdef WINSDBG
                if (BytesSent == SOCKET_ERROR)
                {
                        DBGPRINT1(ERR, "CommSendUdp:SendTo returned socket error. Error = (%d)\n", Error);
                }
                else
                {
                        DBGPRINT0(ERR, "CommSendUdp:SendTo did not send all the bytes");

                }
#endif
                if (WinsCnf.State_e != WINSCNF_E_TERMINATING)
                {
                        WINSEVT_LOG_D_M(Error, WINS_EVT_WINSOCK_SENDTO_ERR);
                }

                //
                // Don't raise exception since sendto might have failed as
                // a result of wrong address in the RFC name request packet.
                //
                // For sending responses to name requests, there is no
                // possibility of WINS using a wrong address since the
                // address it uses is the one that it got from recvfrom
                // (stored In FromAdd field of the dlg ctx block.
                //
                // The possibility of a wrong address being there is
                // only there when a WACK/name query/name release is sent
                // by WINS.  In this case, it takes the address that is
                // stored in the database for the conflicting entry (this
                // address is ofcourse the one that was passed in the
                // RFC packet
                //
                // WSAEINVAL error is returned by GetLastError if the
                // address is invalid (winsock document doesn't list this --
                // inform Dave Treadwell about this).
                //

FUTURES("At name registration, should WINS make sure that the address in ")
FUTURES("the packet is the same as the address it got from recvfrom")
FUTURES("probably yes")

                //WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

        }
        return;
}

#if USENETBT > 0
VOID
SendNetbt (
  struct sockaddr_in        *pDest,
  MSG_T                   pMsg,
  MSG_LEN_T             MsgLen
 )

/*++

Routine Description:
        This function is called to send a datagram through NETBT

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
       //
       // Point to the address structure prefix
       //
       tREM_ADDRESS *pRemAdd = (tREM_ADDRESS *)(pMsg -
                                        COMM_NETBT_REM_ADD_SIZE);

#ifdef JIM
        {
         BYTE        TransId = *pMsg;
         ASSERT(TransId == 0x80);
        }
#endif

       pRemAdd->Family               = pDest->sin_family;
       pRemAdd->Port               = pDest->sin_port;
       pRemAdd->IpAddress      = htonl(pDest->sin_addr.s_addr);
#ifdef JIM
ASSERT(MsgLen > 0x20);
#endif
       pRemAdd->LengthOfBuffer = MsgLen;
       DeviceIoCtrl(
                    &sNetbtSndEvtHdl,
                    pRemAdd,
                    MsgLen + COMM_NETBT_REM_ADD_SIZE,
                    IOCTL_NETBT_WINS_SEND
                    );
        return;
}
#endif
VOID
ParseMsg(
        MSG_T                        pMsg,
        MSG_LEN_T                MsgLen,
        COMM_TYP_E                MsgTyp_e,
        struct sockaddr_in         *pFromAdd,
        PCOMMASSOC_ASSOC_CTX_T        pAssocCtx
        )

/*++

Routine Description:

        This function is called to process a message received on the
        UDP port or a TCP connection.

Arguments:
        pMsg        - ptr to message received
        MsgLen  - length of message received
        MsgType - type of message
        pFromAdd - ptr to who it is from
        pAssocHdl - Assoc Handle if it came on an association

Externals Used:
        CommUdpNbtDlgTable

Called by:
        ProcTcpMsg, MonUdp

Comments:
        None

Return Value:

        None
--*/
{

        COMM_HDL_T                    DlgHdl;
        COMMASSOC_DLG_CTX_T        DlgCtx;
        register PCOMMASSOC_DLG_CTX_T        pDlgCtx;
        BOOL                       fNewElem = FALSE;


try {
        /*
        *  If the assoc handle is NULL, this is a UDP message
        */
        if (pAssocCtx == NULL)
        {

            /*
             * Check if this message is a response.  If it is, the explicit
             * dialogue is used
            */
            if (*(pMsg + 2) & NMS_RESPONSE_MASK)
            {
                ENmsHandleMsg(
                                &CommExNbtDlgHdl,
                                pMsg,
                                MsgLen
                             );
                return;
            }

            /*
             * Initialize the STATIC dlg ctx block with the fields that the
             * compare function will use to check if this is a duplicate
            */
            WINSMSC_COPY_MEMORY_M(
                                &DlgCtx.FromAdd,
                                pFromAdd,
                                sizeof(struct sockaddr_in)
                                 );

            //
            // Copy the first four bytes of the message into the FirstWrdOfMsg
            // field of the Dlg Ctx block.  The first 4 bytes contain the
            // transaction id and the opcode.  These values along with the
            // address of the sender are used by CompareNbtReq to determine
            // whether a request is a repeat request or a new one.
            //
            //  Note: The message buffer and the dlg ctx block are deleted
            //  in different functions, the message buffer getting deleted
            //  first.  We can not use  the pointer to the message
            //  buffer for the purposes of getting at the first word at
            //  comparison time since then we open ourselves to the possibility
            //  of two dialogues pointing to the same block for a finite
            //  window (true, when requests are coming rapidly)
            //

FUTURES("Directly assign the value instead of copying it")
            WINSMSC_COPY_MEMORY_M(
                          &DlgCtx.FirstWrdOfMsg,
                          pMsg,
                          sizeof(DWORD)
                        );


            /*
                create and insert a  dlg ctx block into the table of
                NBT type Implicit dialogues.  The key to searching for
                a duplicate inside the table comprises of the Transaction Id
                of the message, and the FromAdd of the nbt node that sent the
                datagram.
                (refer : CheckDlgDuplicate function).

            */
            pDlgCtx = CommAssocInsertUdpDlgInTbl(&DlgCtx, &fNewElem);

            if (pDlgCtx == NULL)
            {
                WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_MEM);
            }

            /*
             *         If the dialogue for the particular command from the nbt node is
             *        already there, we will ignore this request, deallocate the
             *        UDP buffer and  return.
            */
            if (!fNewElem)
            {
                DBGPRINT0(FLOW, "Not a new element\n");
                ECommFreeBuff(pMsg);
#ifdef WINSDBG
                CommNoOfRepeatDgrms++;
#endif
                return;
            }

            /*
             * Initialize the dlg ctx block that got inserted
            */
            pDlgCtx->Role_e  = COMMASSOC_DLG_E_IMPLICIT;
            pDlgCtx->Typ_e   = COMM_E_UDP;

            DlgHdl.pEnt      = pDlgCtx;

            /*
             *        Call name space manager to handle the request
            */
            ENmsHandleMsg(&DlgHdl, pMsg, MsgLen);
        }
        else   // the request came over an association
        {

                pDlgCtx = pAssocCtx->DlgHdl.pEnt;

                //
                // required by the PULL thread (HandlePushNtf).
                // and the PUSH thread to print out the address of the WINS
                // that sent the push trigger or the Pull request
                //
                WINSMSC_COPY_MEMORY_M(
                                &pDlgCtx->FromAdd,
                                pFromAdd,
                                sizeof(struct sockaddr_in)
                                     );

                /*
                 * The request came over a TCP connection.  Examine the Dlg type
                 * and then call the appropriate component
                */
                if (pAssocCtx->Typ_e == COMM_E_NBT)
                {

                            /*
                             * It is an nbt request over a TCP connection.  Call
                              * the Name Space Manager
                            */
                            ENmsHandleMsg(
                                        &pAssocCtx->DlgHdl,
                                        pMsg,
                                        MsgLen
                                     );
                }
                else
                {
                            /*
                         * Call the replicator component
                         *
                         * Note: pMsg points to COMM_HEADER_T on top of the
                         *        data. We strip it off
                            */
DBGIF(fWinsCnfRplEnabled)
                            ERplInsertQue(
                                        WINS_E_COMSYS,
                                        QUE_E_CMD_REPLICATE_MSG,
                                        &pAssocCtx->DlgHdl,
                                        pMsg + COMM_HEADER_SIZE,
                                        MsgLen - COMM_HEADER_SIZE,
                                        NULL,   // no context
                    0       // no magic no.
                                     );
                   }
        }
   }
except(EXCEPTION_EXECUTE_HANDLER)        {

                DBGPRINTEXC("ParseMsg");
                /*
                * If this dialogue was allocated as a result of an Insert
                * get rid of it.
                */
                if (fNewElem)
                {
                        CommAssocDeleteUdpDlgInTbl( pDlgCtx );
                }
                WINS_RERAISE_EXC_M();
        }
        return;
}


LPVOID
CommAlloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN CLONG                BuffSize
)

/*++

Routine Description:
        This function is called to allocate a buffer

Arguments:
        pTable   - Table where the buffer will be stored
        BuffSize - Size of buffer to allocate

Externals Used:
        None


Return Value:

   Success status codes -- ptr to buffer allocated
   Error status codes  --

Error Handling:

Called by:
        RtlInsertElementGeneric()

Side Effects:

Comments:
        This function exists just because the RtlTbl functions require
        this prototype for the user specified alloc function.
--*/

{
        LPVOID pTmp;

          UNREFERENCED_PARAMETER(pTable);

        WinsMscAlloc( (DWORD) BuffSize,  &pTmp );

        return(pTmp);

}


VOID
CommDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID                pBuff
)

/*++

Routine Description:

  This function is called to deallocate memory allocated via CommAlloc.


Arguments:
        pTable - Table where buffer was stored
        pBuff  - Buffer to deallocate


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        The pTable argument is required since the address of this function
        is passed as an argument to RtlTbl functions
--*/

{


          UNREFERENCED_PARAMETER(pTable);
        WinsMscDealloc(
                        pBuff
                      );
        return;

}

#if 0
RTL_GENERIC_COMPARE_RESULTS
CompareAssoc(
        IN  PRTL_GENERIC_TABLE  pTable,
        IN  PVOID                pFirstAssoc,
        IN  PVOID                pSecondAssoc
        )

/*++

Routine Description:

        The function compares the first and the second assoc. structures
Arguments:
        pTable       - table where buffer (assoc. ctx block) is to be stored
        pFirstAssoc  - First assoc ctx block
        pSecondAssoc - Second assoc ctx block

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        RtlInsertElementGenericTable (called by MonTcp)

Side Effects:

Comments:
        The pTable argument is ignored.
        This function was once being used.  Due to change in code, it is
        no longer being used.  It is kept here for potential future use
--*/
{

  PCOMMASSOC_ASSOC_CTX_T         pFirst  = pFirstAssoc;
  PCOMMASSOC_ASSOC_CTX_T         pSecond = pSecondAssoc;

  if (pFirst->SockNo == pSecond->SockNo)
  {
        return(GenericEqual);
  }

  if (pFirst->SockNo > pSecond->SockNo)
  {
        return(GenericGreaterThan);
  }
  else
  {
        return(GenericLessThan);
  }

}

#endif

RTL_GENERIC_COMPARE_RESULTS
CommCompareNbtReq(
        IN  PRTL_GENERIC_TABLE  pTable,
        IN  PVOID                pFirstDlg,
        IN  PVOID                pSecondDlg
        )

/*++

Routine Description:

        This function compares two dialogue context blocks.  The fields
        used for comparison are:
                the address of the sender
                the first long word of the message (contains transaction id
                        and opcode)

Arguments:
        pTable     - Table where the Dialogue for the NBT request will be stored
        pFirstDlg  - Dlg. ctx. block
        pSecondDlg - Dlg. ctx. block

Externals Used:
        None


Return Value:

   Success status codes --  GenericLessThan or GenericGreaterThan
   Error status codes  -- GenericEqual

Error Handling:

Called by:
        RtlInsertElementGenericTable (called by ParseMsg)

Side Effects:

Comments:
        The pTable argument is ignored.
--*/
{

        PCOMMASSOC_DLG_CTX_T pFirst  = pFirstDlg;
        PCOMMASSOC_DLG_CTX_T pSecond = pSecondDlg;
        LONG                     Val     = 0;
        LONG           FirstMsgLong  = pFirst->FirstWrdOfMsg;
        LONG           SecondMsgLong = pSecond->FirstWrdOfMsg;

        //
        //  There seems to be no Rtl function with the functionality of memcmp
        //  RtlCompareMemory does not tell you which of the comparators is
        //  smaller/larger
        //
CHECK("Is there an Rtl function faster than memcmp in the nt arsenal\n");
        if (  (Val = (long)memcmp(
                        &pFirst->FromAdd,
                        &pSecond->FromAdd,
                        sizeof(struct sockaddr_in)
                                 )
              ) > 0
           )
        {
                return(GenericGreaterThan);
        }
        else
        {
           if (Val < 0)
           {
                return(GenericLessThan);
           }
        }

        /*
         if the addresses are the same, compare the first long word of
         the message
        */

        Val = FirstMsgLong -  SecondMsgLong;

        if (Val > 0)
        {
                return(GenericGreaterThan);
        }
        else
        {
           if (Val < 0)
           {
                return(GenericLessThan);
           }
        }

        return(GenericEqual);

}  // CommCompareNbtReq()

VOID
CommEndAssoc(
        IN  PCOMM_HDL_T        pAssocHdl
        )
/*++

Routine Description:

  This function is called to terminate an explicit association.  It sends a stop
  association response message to the WINS identified by the Address
  in the assoc ctx block. It then closes the socket and deallocates the
  association

Arguments:
        pAssocHdl - Handle to the Association to be terminated

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        ECommEndDlg (only for an explicit assoc)

Side Effects:

Comments:

--*/
{

    BYTE                            Msg[COMMASSOC_ASSOC_MSG_SIZE];
    DWORD                            MsgLen   = COMMASSOC_ASSOC_MSG_SIZE;
    PCOMMASSOC_ASSOC_CTX_T        pAssocCtx = pAssocHdl->pEnt;
    SOCKET                         SockNo;


    // no need to lock the association
    //
try {
    /*
        Format the Stop Assoc. Message

        The address passed to the formatting function is offset
        from the address of the buffer by a LONG so that CommSendAssoc
        can store the length of the message in it.
    */
    CommAssocFrmStopAssocReq(
                        pAssocCtx,
                        Msg + sizeof(LONG),
                        MsgLen - sizeof(LONG),
                        COMMASSOC_E_USER_INITIATED
                        );
    CommSendAssoc(
                pAssocCtx->SockNo,
                Msg + sizeof(LONG),
                MsgLen - sizeof(LONG)
                    );

    CommAssocTagFree(&sTagAssoc, pAssocCtx->nTag);
}
except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("CommEndAssoc");
 }
    //
    // The above call might have failed (It will fail if the connection
    // is down.  This can happen for instance in the case where GetReplicas()
    // in rplpull gets a comm. failure due to the connection going down).
    //
    SockNo = pAssocCtx->SockNo;

    CommAssocDeallocAssoc(pAssocCtx);
    CommDisc(SockNo, TRUE);
    //
    // decrement the conn. count
    //
    //CommDecConnCount();
    return;

}

VOID
DelAssoc(
        IN  SOCKET                     SockNo,
        IN  PCOMMASSOC_ASSOC_CTX_T  pAssocCtxPassed
        )

/*++

Routine Description:

        This function is called only by the TCP listener thread.  The
        socket no. therefore maps to a RESPONDER association. The function
        is called when the TCP listener thread gets an error or 0 bytes
        on doing a 'recv'.


Arguments:

        SockNo    -   Socket of association that has to be removed
        pAssocCtx - Assoc. ctx block to be removed


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        ProcTcpMsg, HandleMsg

Side Effects:

Comments:
        This function is called from HandleMsg() which is called
        only by the TCP listener thread.
--*/

{

    COMM_HDL_T                   DlgHdl;
    PCOMMASSOC_ASSOC_CTX_T pAssocCtx;

    DBGPRINT1(FLOW, "ENTER: DelAssoc. Sock No is (%d)\n", SockNo);
    if (pAssocCtxPassed == NULL)
    {

            /*
           Lookup the assoc. ctx block associated with the socket
            */

            pAssocCtx = CommAssocLookupAssoc(SockNo);

            /*
             * There is no reason why the assoc. ctx block should not
             * be there (a responder association is deleted only via this
        * function).
            */
            if(!pAssocCtx)
            {
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
            }
    }
    else
    {
        pAssocCtx = pAssocCtxPassed;
    }

    /*
     *        Only, if the association is not in the non-existent state,
     *  look for a dialogue handle
    */
    if (pAssocCtx->State_e != COMMASSOC_ASSOC_E_NON_EXISTENT)
    {
            /*
        *  get the dialogue handle
            */
            DlgHdl = pAssocCtx->DlgHdl;

            /*
         *        Lock the dialogue
         *
         *      We have to synchronize with thread calling CommSndRsp
            */
            CommLockBlock(&pAssocCtx->DlgHdl);

            /*
                Remove the assoc. from the table.  This will also put
                the assoc. in the free list.
            */
            CommAssocDeleteAssocInTbl(  pAssocCtx        );

            /*
                dealloc the dialogue (i.e. put it in the free list)

                Note: An implicit dialogue is deleted when the association(s)
                it is mapped to terminates.  If this dialogue was earlier
                 passed on to a client, the client will  find out that it
                has been deleted (via a communications failure exception)
                when it tries to use it (which may be never) -- see ECommSndRsp
            */
            CommAssocDeallocDlg( DlgHdl.pEnt );

            /*
                Unlock the dialogue so that other threads can use it
            */
            CommUnlockBlock(&DlgHdl);
   }
   else
   {
            /*
                Remove the assoc. from the table.  This will also put
                the assoc. in the free list
            */
            CommAssocDeleteAssocInTbl(pAssocCtx);

   }

   DBGLEAVE("DelAssoc\n");
   return;
}

#if PRSCONN
BOOL
CommIsBlockValid (
       IN   PCOMM_HDL_T       pEntHdl
      )
/*++

Routine Description:
        This function is called to check if the hdl is valid

Arguments:
        pEntHdl - Handle to entity to lock

Externals Used:
        None

Return Value:

   Success status codes -- TRUE
   Error status codes   --  FALSE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

  //
  // pEnt will be NULL for a persistent dlg that was never created during
  // the lifetime of this WINS instance or one that was ended.
  //
  if (pEntHdl->pEnt == NULL)
  {
      ASSERT(pEntHdl->SeqNo == 0);
      return (FALSE);
  }
  //
  // If we can lock the block, the dlg hdl is still valid. If not, it means
  // that the dlg was terminated earlier.
  //
  if (CommLockBlock(pEntHdl))
  {
     (VOID)CommUnlockBlock(pEntHdl);
     return(TRUE);
  }
  return(FALSE);
}
#endif

BOOL
CommLockBlock(
        IN  PCOMM_HDL_T        pEntHdl
        )

/*++

Routine Description:
        This function is called to lock the COMSYS entity identified by the
        handle.

Arguments:
        pEntHdl - Handle to entity to lock

Externals Used:
        None

Return Value:

   Success status codes -- TRUE
   Error status codes   --  FALSE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        PCOMM_TOP_T        pTop = pEntHdl->pEnt;

        //lock before checking

#if 0
        WinsMscWaitInfinite(pTop->MutexHdl);
#endif
        EnterCriticalSection(&pTop->CrtSec);
        if (pEntHdl->SeqNo == pTop->SeqNo)
        {
                return(TRUE);
        }
        else
        {
                CommUnlockBlock(pEntHdl);
                return(FALSE);
        }
}

__inline
STATUS
CommUnlockBlock(
        PCOMM_HDL_T        pEntHdl
        )

/*++

Routine Description:
        This function is called to unlock the COMSYS entity identified by the
        handle.

Arguments:
        pEntHdl - Handle to entity to unlock

Externals Used:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
FUTURES("Change to a macro")
#if 0
        BOOL RetVal = TRUE;
        BOOL RetStat = WINS_SUCCESS;
#endif
        PCOMM_TOP_T        pTop = pEntHdl->pEnt;

        LeaveCriticalSection(&pTop->CrtSec);
#if 0
        RetVal = ReleaseMutex(pTop->MutexHdl);

        if (RetVal == FALSE)
        {
                RetStat = WINS_FAILURE;
        }
#endif
        return(WINS_SUCCESS);

}

VOID
InitMem(
        VOID
        )

/*++

Routine Description:
        This function is called to do all memory initialization required
        by COMSYS.

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        CommInit
Side Effects:

Comments:
        None
--*/
{


        /*
        * Create Memory heap for UDP buffers
        * We want mutual exclusion and generation of exceptions
        */
        DBGPRINT0(HEAP_CRDL,"InitMem: Udp. Buff heap\n");
        CommUdpBuffHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_UDP_BUFFER_HEAP_SIZE
                                              );

    DBGPRINT0(HEAP_CRDL,"InitMem: Udp. Buff heap\n");
        CommUdpDlgHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_UDP_DLG_HEAP_SIZE
                                              );

        /*
        * Create Memory heap for Assoc Ctx blocks.
        * We want mutual exclusion and generation of exceptions
        */
        DBGPRINT0(HEAP_CRDL,"InitMem: Assoc. blocks heap\n");
        CommAssocAssocHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_ASSOC_BLKS_HEAP_SIZE
                                              );
        /*
        * Create Memory heap for dlg blocks
        * We want mutual exclusion and generation of exceptions
        */
        DBGPRINT0(HEAP_CRDL,"InitMem: Dlgs. blocks heap\n");
        CommAssocDlgHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_DLG_BLKS_HEAP_SIZE
                            );
        /*
        * Create Memory heap for messages on tcp connections
        */
    DBGPRINT0(HEAP_CRDL,"InitMem: tcp connection message heap\n");
        CommAssocTcpMsgHeapHdl = WinsMscHeapCreate(
                                         HEAP_GENERATE_EXCEPTIONS,
                                        COMMASSOC_TCP_MSG_HEAP_SIZE
                                              );

        return;

}


BOOL
ChkNtfSock(
        IN fd_set  *pActSocks,
        IN fd_set  *pRdSocks
        )

/*++

Routine Description:
        This function is called to check if there is a notification message
        on the Notification socket.  If there is one, it reads the message.
        The message contains a socket # and a command to add or remove the
        socket to/from the list of sockets being monitored by the TCP
        listener thread.


Arguments:

        pActSocks - Array of active sockets
        pRdSocks  - Array of sockets  returned by select

Externals Used:
        CommNtfSockHandle

Return Value:
        TRUE  - Yes, there was a message.  The Active sockets array has been
                changed.
        FALSE - No.  There was no message

Error Handling:
        In case of an error, an exception is raised

Called by:
        MonTcp

Side Effects:

Comments:
        None
--*/

{
        DWORD  Error;
        int    RetVal;
        COMM_NTF_MSG_T        NtfMsg;
        PCOMMASSOC_DLG_CTX_T    pDlgCtx;
        PCOMMASSOC_ASSOC_CTX_T  pAssocCtx;
        SOCKET    Sock;
        BOOL      fNtfSockSet = TRUE;

        if (FD_ISSET(CommNtfSockHandle, pRdSocks))
        {
             Sock = CommNtfSockHandle;
        }
        else
        {
#if SPX > 0
           if (FD_ISSET(CommIpxNtfSockHandle, pRdSocks))
           {
             Sock = CommIpxNtfSockHandle;
           }
#endif
           fNtfSockSet = FALSE;
        }

        if (fNtfSockSet)
        {
                //do a recvfrom to read in the data.
                  RetVal = recvfrom(
                                Sock,
                                (char *)&NtfMsg,
                                COMM_NTF_MSG_SZ,
                                0,  //default flags (i.e. no peeking
                                    //or reading OOB message
                                NULL, //don't want address of sender
                                0     //length of above arg
                                    );

                  // if the message is larger than the buffer, we do get SOCKET_ERROR
                  // here - we should just drop the packet and get out - not raise exception!
                  if (RetVal == SOCKET_ERROR)
                  {
                        Error = WSAGetLastError();
                        if (WinsCnf.State_e != WINSCNF_E_TERMINATING)
                        {
                          WINSEVT_LOG_M(
                                        Error,
                                        WINS_EVT_WINSOCK_RECVFROM_ERR
                                     );
                        }
                        if (Error != WSAEMSGSIZE)
                            WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                        else
                            return TRUE;
                  }

                  // if the message is smaller than expected then read it and drop
                  // it as it doesn't come from where we expect it (SndPushNtf/HandleUpdNtf)
                  if (RetVal != sizeof(COMM_NTF_MSG_T))
                  {

                      DBGPRINT1(ERR, "ChkNtfSock: Malformed packet: TOO SMALL (%d)!\n", RetVal);
                      return TRUE;
                  }
                  pDlgCtx   = NtfMsg.DlgHdl.pEnt;
                  if (IsBadWritePtr(pDlgCtx,sizeof(COMMASSOC_DLG_CTX_T)))
                  {
                      DBGPRINT1(ERR, "ChkNtfSock: Malformed packet: Invalid Dialog Ctxt (%p)!\n", pDlgCtx);
                      return TRUE;
                  }
                  pAssocCtx = pDlgCtx->AssocHdl.pEnt;
                  if (IsBadWritePtr(pAssocCtx, sizeof(COMMASSOC_ASSOC_CTX_T)))
                  {
                      DBGPRINT1(ERR, "ChkNtfSock: Malformed packet: Invalid Embedded Assoc Ctxt (%p)!", pAssocCtx);
                      return TRUE;
                  }

                if (NtfMsg.Cmd_e == COMM_E_NTF_START_MON)
                {
                        DBGPRINT1(FLOW, "ChkNtfSock: Adding Socket (%d) to monitor list\n", NtfMsg.SockNo);

                        //
                        // We do this since FD_SETSIZE can fail silently
                        //
                        if (pActSocks->fd_count < FD_SETSIZE)
                        {
                                FD_SET(NtfMsg.SockNo, pActSocks);
                        }
                        else
                        {
                                DBGPRINT1(ERR,
                                 "ChkNtfSock: Connection limit of %d reached\n",
                                       FD_SETSIZE);
                                WINSEVT_LOG_M(WINS_FAILURE,
                                        WINS_EVT_CONN_LIMIT_REACHED);

                                //
                                //This will cleanup the dlg and assoc. ctx. blk
                                //
                                ECommEndDlg(&NtfMsg.DlgHdl);

                                return(TRUE);
                        }

                        //
                        // Add the association to the table of associations.
                        // Since this association will be monitored, we change
                        // the role of the association to RESPONDER.  Also,
                        // change the dialogue role to IMPLICIT. These are
                        // sleight of hand tactics. The client  who
                        // established the association  (Replicator)
                        // does not care whet we do with the comm data
                        // structures as long as we monitor the dialogue that
                        // it initiated with a remote WINS
                        //
                        pAssocCtx->Role_e  =  COMMASSOC_ASSOC_E_RESPONDER;
                        pDlgCtx->Role_e    =  COMMASSOC_DLG_E_IMPLICIT;
                        pDlgCtx->FromAdd   =  pAssocCtx->RemoteAdd;
                        CommAssocInsertAssocInTbl(pAssocCtx);
                }
                else  //COMM_NTF_STOP_MON
                {

                        DBGPRINT1(FLOW, "ChkNtfSock: Removing Socket (%d) from monitor list\n", NtfMsg.SockNo);
                        FD_CLR(NtfMsg.SockNo, pActSocks);

                        //
                        //Remove the association from the table of
                        //associations.  Since this association will not be
                        //monitored by the TCP thread, we change the role of
                        //the association to INITIATOR.  Also, change the
                        //dialogue role to EXPLICIT.  These are sleight of
                        //hand tactics.
                        //
                        if (CommLockBlock(&NtfMsg.DlgHdl))
                        {
                          pAssocCtx->Role_e  =  COMMASSOC_ASSOC_E_INITIATOR;
                          pDlgCtx->Role_e    =  COMMASSOC_DLG_E_EXPLICIT;
                          COMMASSOC_UNLINK_RSP_ASSOC_M(pAssocCtx);
                          pAssocCtx->RemoteAdd =  pDlgCtx->FromAdd;
                          CommUnlockBlock(&NtfMsg.DlgHdl);

                           //
                           // Let us signal the PUSH thread so that it can
                           // hand over the connection to the PULL thread (See
                           // HandleUpdNtf in rplpush.c)
                           //
                           WinsMscSignalHdl(RplSyncWTcpThdEvtHdl);
                        }
                        else
                        {
                          //
                          //The dlg could not be locked.  It means that before
                          //the tcp listener thread started processing this
                          //message, it had already processed a disconnect.
                          //
                          fCommDlgError = TRUE;
                          WinsMscSignalHdl(RplSyncWTcpThdEvtHdl);
                        }

                }
                return(TRUE);
        }
        return(FALSE);
} // ChkNtfSock()


STATUS
RecvData(
        IN  SOCKET                SockNo,
        IN  LPBYTE                pBuff,
        IN  DWORD                BytesToRead,
        IN  INT                        Flags,
        IN  DWORD                SecsToWait,
        OUT LPDWORD                pBytesRead
           )

/*++

Routine Description:
        This function is called to do a timed recv on a socket.

Arguments:
        SockNo        - Socket No.
        pBuff         - Buffer to read the data into
        BytesToRead   - The number of bytes to read
        Flags              - flag arguments for recv
        SecsToWait  -  No of secs to wait for the first read.
        pBytesRead    - No of Bytes that are read

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE or WINS_RECV_TIMED_OUT

Error Handling:

Called by:
        CommReadStream

Side Effects:

Comments:
        None
--*/

{
        fd_set RdSocks;
        int    NoOfSockReady;
        INT    BytesRead = 0;
        INT    BytesLeft = BytesToRead;
        DWORD  InChars;
        DWORD  Error;
        BOOL   fFirst = TRUE;
        STATUS RetStat;

        FD_ZERO(&RdSocks);
        FD_SET(SockNo, &RdSocks);

        /*
         *  Read the whole message into the allocated buffer
        */
        for (
                InChars = 0;
                BytesLeft > 0;
                InChars += BytesRead
            )
        {
          //
          // Check if we were told to do a timed receive.  This will
          // never happen in the TCP listener thread
          //
          if (SecsToWait)
          {
           //
           // Block on a timed select. The first time around we want to
           // wait the time specified by caller. The caller expects the other
           // side to send something within this much time.  For subsequent
           // reads we wait a pre-defined interval since the sender has already
           // accumulated all that it wants to send and has started sending it
           // obviating the need for us to wait long.
           //
           if (fFirst)
           {
              sTimeToWait.tv_sec = (long)SecsToWait;
              fFirst = FALSE;
           }
           else
           {
              sTimeToWait.tv_sec = SECS_TO_WAIT;
           }
           if (
                (
                        NoOfSockReady = select(
                                            FD_SETSIZE /*ignored arg*/,
                                            &RdSocks,
                                            (fd_set *)0,
                                            (fd_set *)0,
                                            &sTimeToWait
                                                  )
                ) == SOCKET_ERROR
             )
           {
                Error = WSAGetLastError();
                DBGPRINT1(ERR,
                "RecvData: Timed Select returned SOCKET ERROR. Error = (%d)\n",
                                Error);
//                CommDecConnCount();
                return(WINS_FAILURE);
          }
          else
          {
                DBGPRINT1(FLOW, "ReceiveData: Timed Select returned with success. No of Sockets ready - (%d) \n", NoOfSockReady);

               if (NoOfSockReady == 0)
               {
                        //
                        // Timing out of RecvData indicates some problem at
                        // the remote WINS (either it is very slow
                        // (overloaded) or the TCP listener thread is out of
                        // commission).
                        WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_WINSOCK_SELECT_TIMED_OUT
                                          );
                        DBGPRINT0(ERR, "ReceiveData: Select TIMED OUT\n");
                        *pBytesRead = 0;
                               *pBytesRead = BytesRead;
//                        CommDecConnCount();
                        return(WINS_RECV_TIMED_OUT);
             }
          }
       }


        //
        // Do a blocking recv
        //
        BytesRead = recv(
                                SockNo,
                                (char *)(pBuff + InChars),
                                BytesLeft,
                                Flags
                                );

        if (BytesRead == SOCKET_ERROR)
        {
                           Error = WSAGetLastError();

                           DBGPRINT1(ERR,
                        "RecvData: recv returned SOCKET_ERROR. Error = (%d)\n",
                                                Error);


                           /*
                         * If the connection was aborted or reset from the
                         *  other end, we close the socket and return an error
                           */
                           if (
                                (Error == WSAECONNABORTED)
                                        ||
                                (Error == WSAECONNRESET)
                                        ||
                                (Error == WSAEDISCON)
                            )
                           {
                                DBGPRINT0(ERR,
                                        "RecvData: Connection aborted\n");
                                WINSEVT_LOG_INFO_D_M(
                                        WINS_SUCCESS,
                                        WINS_EVT_CONN_ABORTED
                                                 );
                           }
                               *pBytesRead = BytesRead;
//                        CommDecConnCount();
                               return(WINS_FAILURE);
        }
        if (BytesRead == 0)
        {
                         /*recv returns 0 (normal graceful shutdown from
                        * either side)
                        * Note:
                         * recv returns 0 if the connection terminated with no
                        * loss of data from either end point of the connection
                        */

                        //
                        // If we were told to do a non timed receive,
                        // we must be executing in the TCP listener thread
                        //
                        // We don't return an error status here since
                        // a disconnect is a valid condition (the other
                        // WINS is terminating its connection normally)
                        //
                        if (SecsToWait == 0)
                        {
                                RetStat = WINS_SUCCESS;
                        }
                        else
                        {
                                //
                                // The fact that we were told to do a
                                // timed select means that we are in
                                // a thread of one of the clients of
                                // COMSYS.  We were expecting data but
                                // got a disconnect instead.  Let us
                                // return an error
                                //
                                RetStat = WINS_FAILURE;
                        }

                        //
                        // We are done. Break out of the loop
                        //
                               *pBytesRead = BytesRead;
//                        CommDecConnCount();
                               return(RetStat);
         }

         BytesLeft -=  BytesRead;

         //
         //We are here means that BytesRead > 0
         //

      } // end of for { ... }

      *pBytesRead = InChars;
      return(WINS_SUCCESS);
} // RecvData()

#if USENETBT > 0
VOID
CommOpenNbt(
        DWORD FirstBindingIpAddr
    )

/*++

Routine Description:

    This function opens the NetBt device for the interface specified by
    FirstBindingIpAddr.

Arguments:

    path        - path to the NETBT driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
//    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    PFILE_FULL_EA_INFORMATION   pEaBuffer;
    ULONG               EaBufferSize;

    //
    // Convert the path into UNICODE_STRING form
    //
#ifdef _PNP_POWER_
    RtlInitUnicodeString(&uc_name_string, L"\\Device\\NetBt_Wins_Export");
#else
#ifdef UNICODE
    RtlInitUnicodeString(&uc_name_string, pWinsCnfNbtPath);
#else
    RtlInitString(&name_string, pWinsCnfNbtPath);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);
#endif
#endif // _PNP_POWER_
    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    EaBufferSize =  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    strlen(WINS_INTERFACE_NAME) + 1 +
                    sizeof(FirstBindingIpAddr); // EA length


    WinsMscAlloc(EaBufferSize, &pEaBuffer);

    if (pEaBuffer == NULL)
    {
        WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_MEM);
    }

    pEaBuffer->NextEntryOffset = 0;
    pEaBuffer->Flags = 0;
    pEaBuffer->EaNameLength = (UCHAR)strlen(WINS_INTERFACE_NAME);


    //
    // put "WinsInterface" into the name
    //
    RtlMoveMemory(
        pEaBuffer->EaName,
        WINS_INTERFACE_NAME,
        pEaBuffer->EaNameLength + 1);

    pEaBuffer->EaValueLength = sizeof(FirstBindingIpAddr);
    *(DWORD UNALIGNED *)(pEaBuffer->EaName + pEaBuffer->EaNameLength + 1) = FirstBindingIpAddr;

    status =
     NtCreateFile(
        &WinsCnfNbtHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        pEaBuffer,
        EaBufferSize
        );

#ifndef UNICODE
    RtlFreeUnicodeString(&uc_name_string);
#endif

    WinsMscDealloc(pEaBuffer);
    if(!NT_SUCCESS(status))
    {
        WinsEvtLogDetEvt(
             FALSE,
             WINS_PNP_FAILURE,
             NULL,
             __LINE__,
             "d",
             status);

        DBGPRINT1(EXC, "CommOpenNbt: Status from NtCreateFile is (%x)\n",
                     status);
        WINS_RAISE_EXC_M(WINS_EXC_NBT_ERR);
    }
    return;

} // CommOpenNbt

//------------------------------------------------------------------------
#if NEWNETBTIF == 0
//#include "nbtioctl.sav"

STATUS
CommGetNetworkAdd(
        IN OUT PCOMM_ADD_T        pAdd
    )

/*++

Routine Description:

    This procedure does an adapter status query to get the local name table.
    It either prints out the local name table or the remote (cache) table
    depending on whether WhichNames is NAMES or CACHE .

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=sizeof(tADAPTERSTATUS);
    NTSTATUS                    Status;
    tADAPTERSTATUS              *pAdapterStatus;
    ULONG                       QueryType;
    PUCHAR                      pAddr;
    ULONG                       Ioctl;

    //
    // Get the local name table
    //
    Ioctl = IOCTL_TDI_QUERY_INFORMATION;

    Status = STATUS_BUFFER_OVERFLOW;

    while (Status == STATUS_BUFFER_OVERFLOW)
    {
        WinsMscAlloc(BufferSize, &pBuffer);
        Status = DeviceIoCtrl(
                              &sNetbtGetAddrEvtHdl,
                              pBuffer,
                              BufferSize,
                              Ioctl
                             );

        if (Status == STATUS_BUFFER_OVERFLOW)
        {
            WinsMscDealloc(pBuffer);

            BufferSize *=2;
            if (BufferSize == 0xFFFF)
            {
                WINSEVT_LOG_D_M(BufferSize, WINS_EVT_UNABLE_TO_ALLOCATE_PACKET);
                DBGPRINT1(ERR, "CommGetNetworkAdd: Unable to get address from NBT\n", BufferSize);
                return(WINS_FAILURE);
            }
        }
    }


    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if (pAdapterStatus->AdapterInfo.name_count == 0)
    {
        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_ADAPTER_STATUS_ERR);
        DBGPRINT0(ERR, "CommGetNetworkAdd: No names in NBT cache\n");
        return(WINS_FAILURE);
    }


    //
    // print out the Ip Address of this node
    //
    pAddr = &pAdapterStatus->AdapterInfo.adapter_address[2];
    NMSMSGF_RETRIEVE_IPADD_M(pAddr, pAdd->Add.IPAdd);

    WinsMscDealloc(pBuffer);
    return(WINS_SUCCESS);
}
#else
STATUS
CommGetNetworkAdd(
    )

/*++

Routine Description:

    This routine gets all the Ip Addresses of Netbt interfaces.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    ULONG                       Buffer[NBT_MAXIMUM_BINDINGS + 1];
    ULONG                       BufferSize=sizeof(Buffer);
    NTSTATUS                    Status;
    ULONG                       Ioctl;
    PULONG                      pBuffer;
    PULONG                      pBufferSv;
    DWORD                       i, Count;
    BOOL                        fAlloc = FALSE;

    //
    // Get the local addresses
    //
    Ioctl = IOCTL_NETBT_GET_IP_ADDRS;


    //
    // NETBT does not support more than 64 adapters and not more than
    // one ip address per adapter.  So, there can be a max of 64 ip addresses
    // which means we don't require more than 65 * 4 = 280 bytes (256 for the
    // addresses  followed by a delimiter address of 0.
    //
    Status = DeviceIoCtrl(
                              &sNetbtGetAddrEvtHdl,
                              (LPBYTE)Buffer,
                              BufferSize,
                              Ioctl
                             );

    if (Status != STATUS_SUCCESS)
    {
        BufferSize *= 10;  //alocate a buffer that is 10 times bigger.
                           //surely, netbt can not be supporting so many
                           //addresses.  If it is, then the netbt developer
                           //goofed in that (s)he did not update
                           //NBT_MAXIMUM_BINDINGS in nbtioctl.h
        WinsMscAlloc(BufferSize, &pBuffer);

        DBGPRINT1(ERR, "CommGetNetworkAdd: Ioctl - GET_IP_ADDRS failed. Return code = (%x)\n", Status);
        Status = DeviceIoCtrl(
                              &sNetbtGetAddrEvtHdl,
                              (LPBYTE)pBuffer,
                              BufferSize,
                              Ioctl
                             );
        if (Status != STATUS_SUCCESS)
        {
            DBGPRINT1(ERR, "CommGetNetworkAdd: Ioctl - GET_IP_ADDRS failed AGAIN. Return code = (%x)\n", Status);
            WINSEVT_LOG_M(Status, WINS_EVT_UNABLE_TO_GET_ADDRESSES);
            WinsMscDealloc(pBuffer);  //dealloc the buffer
            return(WINS_FAILURE);
        }
        fAlloc = TRUE;

    }
    else
    {
        pBuffer = Buffer;
    }

    //
    // Count the number of addresses returned
    // The end of the address table contains -1 and any null addresses
    // contain 0
    //
    pBufferSv = pBuffer;
    for(Count=0; *pBuffer != -1; pBuffer++)
    {
        // Increment Count only if it is a valid address.
        if ( *pBuffer ) {
            Count++;
        }
    }

    if ( !Count ) {
        DBGPRINT0(ERR, "CommGetNetworkAdd: Netbt did not give any valid address\n");
        WINSEVT_LOG_M(Status, WINS_EVT_UNABLE_TO_GET_ADDRESSES);
        if (fAlloc)
        {
           WinsMscDealloc(pBufferSv);
        }

        return(WINS_FAILURE);
    }

    if (pWinsAddresses)
    {
         WinsMscDealloc(pWinsAddresses);
    }
    //
    // Allocate space for the addresses
    //
    WinsMscAlloc(sizeof(ADD_T) + ((Count - 1) * COMM_IP_ADD_SIZE), &pWinsAddresses);
    pWinsAddresses->NoOfAdds = Count;
    pBuffer = pBufferSv;
    // Copy all valid addresses
    for (i=0; i<Count; pBuffer++)
    {
        if ( *pBuffer ) {

            pWinsAddresses->IpAdd[i] = *pBuffer;
            i++;
        }
    }
    if (fAlloc)
    {
       WinsMscDealloc(pBufferSv);
    }

    return(WINS_SUCCESS);
}
#endif

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN LPHANDLE         pEvtHdl,
    IN PVOID                pDataBuffer,
    IN DWORD                DataBufferSize,
    IN ULONG            Ioctl
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 iosb;
#if NEWNETBTIF == 0
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
#endif
    PVOID                           pInput = NULL;
    ULONG                           SizeInput = 0;


#if NEWNETBTIF == 0
PERF("TDI_QUERY_INFORMATION is used only at WINS initialization")
    if (Ioctl == IOCTL_TDI_QUERY_INFORMATION)
    {
        pInput = &QueryInfo;
        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status
        SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
    }
#endif

   while (TRUE)
   {
     if (WinsCnfNbtHandle == NULL)
         status = STATUS_INVALID_HANDLE;
     else
         status = NtDeviceIoControlFile(
                        WinsCnfNbtHandle,                      // Handle
                        *pEvtHdl,                    // Event
                        NULL,                    // ApcRoutine
                        NULL,                    // ApcContext
                        &iosb,                   // IoStatusBlock
                        Ioctl,                   // IoControlCode
                        pInput,                         // InputBuffer
                        SizeInput,               // Buffer Length
                        pDataBuffer,             // Output Buffer
                        DataBufferSize           // Output BufferSize
                            );


     if (status == STATUS_SUCCESS)
     {
        return(status);
     }
     else
     {
        //
        // If status is PENDING, do a wait on the event
        //
        if (status == STATUS_PENDING)
        {
            status = NtWaitForSingleObject(
                          *pEvtHdl,                   // Handle
                          TRUE,                       // Alertable
                          NULL);                      // Timeout

            if (status == STATUS_SUCCESS)
            {
                 return(status);
            }
        }
     }

     //
     // status returned by NtDeviceIoCtrl or NtWaitForSingleObject is
     // a failure code
     //
     DBGPRINT1(ERR, "DeviceIoCtrl, Status returned is (%x)\n", status);
     if (status != STATUS_CANCELLED)
     {
        //
        // If it is insufficient resources, we drop this datagram and
        // try again (only for recv)
        //
        if (Ioctl == IOCTL_NETBT_WINS_RCV)
        {
                if (status == STATUS_INSUFFICIENT_RESOURCES)
                {
                        continue;
                }
        }
        //
        // in case of a send, it can be invalid handle, invalid
        // parameter or insufficient resourcesi.  If it is INVALID_PARAMETER,
        // it means that we passed 0 in the Address field on top of the buffer.
        //
        // Drop this datagram and return to the caller
        //
        if (Ioctl == IOCTL_NETBT_WINS_SEND)
        {
                if (
                        (status == STATUS_INSUFFICIENT_RESOURCES)
                                        ||
                        (status == STATUS_INVALID_PARAMETER)
                   )
                {
                        return(STATUS_SUCCESS);
                }
                else
                {
                        DBGPRINT1(EXC, "NtDeviceIoCtrl returned error = (%x)\n",
                                        status);
                        WINSEVT_LOG_D_M(status, WINS_EVT_NETBT_SEND_ERR);


                         //
                         // If the machine's address has gone away due to some
                         // reason, WinsCnfNbtHandle will have been changed
                         // to NULL.  In this case, we will get
                         // STATUS_INVALID_HANDLE error.  We do not check for
                         // handle being NULL prior to making the Nbt call
                         // to avoid an if check which is of no value for
                         // 99% of the time.
                         //
                         // An error will be logged up above.  We should not see
                         // too many of these since the window where
                         // WinsCnfNbtHandle is NULL is very small unless WINS
                         // is terminating in which case this thread will
                         // just terminate as a result of the exception being
                         // raised below.
                         //
                         // The address can go away due to the following reasons
                         //
                         //  1) psched installation (unbind followed by bind)
                         //  2) Changing from dhcp/static or static/dhcp
                         //  3) ipconfig release/renew
                         //

                         //
                         // When the main thread has to terminate WINS, it
                         // closes WinsCnfNetbtHandle. A worker thread or a
                         // challenge thread might be busy dealing with its
                         // queue of work items (potentially long on a busy
                         // WINS) and may not see a termination
                         // signal from the main thread.  This exception will
                         // terminate it
                         //

                         //
                         // Raise an exception if the wins is terminating
                         //
                         if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
                         {
                               WINS_RAISE_EXC_M(WINS_EXC_NBT_ERR);
                         }
                }
         }
        break;
      }
      break;
    } // end of while (TRUE)
    return(status);
}
#endif

LPVOID
CommHeapAlloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN CLONG                BuffSize
)

/*++

Routine Description:
        This function is called to allocate a buffer

Arguments:
        pTable   - Table where the buffer will be stored
        BuffSize - Size of buffer to allocate

Externals Used:
        None


Return Value:

   Success status codes -- ptr to buffer allocated
   Error status codes  --

Error Handling:

Called by:
        RtlInsertElementGeneric()

Side Effects:

Comments:
        This function exists just because the RtlTbl functions require
        this prototype for the user specified alloc function.
--*/

{
        LPVOID pTmp;

          UNREFERENCED_PARAMETER(pTable);

        pTmp = WinsMscHeapAlloc( CommUdpDlgHeapHdl, (DWORD) BuffSize );

        return(pTmp);

}


VOID
CommHeapDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID                pBuff
)

/*++

Routine Description:

  This function is called to deallocate memory allocated via CommAlloc.


Arguments:
        pTable - Table where buffer was stored
        pBuff  - Buffer to deallocate


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        The pTable argument is required since the address of this function
        is passed as an argument to RtlTbl functions
--*/

{


          UNREFERENCED_PARAMETER(pTable);
        WinsMscHeapFree(
                        CommUdpDlgHeapHdl,
                        pBuff
                      );
        return;

}

VOID
CommDecConnCount(
   VOID
 )

/*++

Routine Description:
  This function decrements the conn. count

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
         DWORD ConnCount;
         ConnCount = InterlockedExchange(&CommConnCount, CommConnCount);
         if (ConnCount != 0)
         {
               InterlockedDecrement(&CommConnCount);
         }
         else
         {
               DBGPRINT0(ERR, "CommDecConnCount: WEIRD: ConnCount should not have been zero\n");
         }
         return;
}

#if PRSCONN
__inline
BOOL
CommIsDlgActive (
  PCOMM_HDL_T   pDlgHdl
)
{

     fd_set RdSocks;
     int NoOfSockReady;
     BOOL  fRetStat = TRUE;
     DWORD  Error;

     PCOMMASSOC_DLG_CTX_T pDlgCtx = pDlgHdl->pEnt;
     PCOMM_HDL_T pAssocHdl = &pDlgCtx->AssocHdl;
     PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pAssocHdl->pEnt;

     if (!CommLockBlock(pAssocHdl))
     {
        return(FALSE);
     }
try  {

     FD_ZERO(&RdSocks);
     FD_SET(pAssocCtx->SockNo, &RdSocks);
     sTimeToWait.tv_sec = 0;

//
// Pass socket and a win32 event with flag of FD_CLOSE to WSAEventSelect.
// if the socket is disconnected, the event will be set.  NOTE, only one
// event select can be active on the socket at any time - vadime 9/2/98
//
FUTURES("Use WSAEventSelect for marginally better performance")

     if (NoOfSockReady = select(
                                            FD_SETSIZE /*ignored arg*/,
                                            &RdSocks,
                                            (fd_set *)0,
                                            (fd_set *)0,
                                            &sTimeToWait
                                                  ) == SOCKET_ERROR)
    {
                Error = WSAGetLastError();
                DBGPRINT1(ERR,
                "RecvData: Timed Select returned SOCKET ERROR. Error = (%d)\n",
                                Error);
//                CommDecConnCount();
                return(FALSE);
    }
    else
    {
                DBGPRINT1(FLOW, "ReceiveData: Timed Select returned with success. No of Sockets ready - (%d) \n", NoOfSockReady);

             //
             // Either there is data or the socket is disconnected.  There
             // should never be any data.  We will just assume a disconnect
             // is there and return FALSE.  The client (RPL) will end the dlg.
             //
             if (NoOfSockReady == 1)
             {
                      fRetStat = FALSE;
             }
             ASSERT(NoOfSockReady == 0);
     }
 }
finally {
    CommUnlockBlock(pAssocHdl);
   }

   return(fRetStat);

}

#endif

#if MCAST > 0


VOID
JoinMcastGrp(
 VOID
)

/*++

Routine Description:
    This function is called by the comm. subsystem to make WINS join
    a multicast group

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
       CommCreatePorts
Side Effects:

Comments:
	None
--*/

{
    int Loop = 0;  //to disable loopback of multicast messages on the
                     //same interface
    DWORD  Error;
    struct ip_mreq mreq;
    DBGENTER("JoinMcastGrp\n");
#if 0
    //
    // Open a socket for sending/receiving multicast packets.  We open
    // a seperate socket instead of using the one for udp datagrams since
    // we don't want to impact the client name packet processing with any
    // sort of overhead.  Also, having a seperate socket keeps things nice
    // and clean.
    //
    if (  (CommMcastPortHandle = socket(
                                PF_INET,
                                SOCK_DGRAM,
                                IPPROTO_UDP
                                 )
          )  == INVALID_SOCKET
       )
   {
        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not create MCAST socket\n", Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }
#endif
   //
   // Set TTL
   //
   if (setsockopt(
                 CommUdpPortHandle,
                 IPPROTO_IP,
                 IP_MULTICAST_TTL,
                 (char *)&WinsCnf.McastTtl,
                 sizeof((int)WinsCnf.McastTtl)) == SOCKET_ERROR)
   {

        closesocket(CommUdpPortHandle);
        CommUdpPortHandle = INVALID_SOCKET;
        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not set TTL option. Error = (%d)\n", Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }

#if 0
   //
   // Disable loopback of messages
   //
   if (setsockopt(CommUdpPortHandle, IPPROTO_IP, IP_MULTICAST_LOOP,
                      (char *)&Loop, sizeof(Loop)) == SOCKET_ERROR)
   {

        closesocket(CommUdpPortHandle);
        CommUdpPortHandle = INVALID_SOCKET;
        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not set DISABLE LOOPBACK option. Error = (%d)\n",
                         Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }
#endif
   //
   // Join a multicast grp
   //
   mreq.imr_multiaddr.s_addr = htonl(McastAdd.sin_addr.s_addr);
   mreq.imr_interface.s_addr  = INADDR_ANY;    //use the default mcast i/f

   if (setsockopt(CommUdpPortHandle, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                    (char *)&mreq, sizeof(mreq)) == SOCKET_ERROR)
   {

        Error = WSAGetLastError();
        closesocket(CommUdpPortHandle);
        CommUdpPortHandle = INVALID_SOCKET;
        DBGPRINT1(MTCAST, "JoinMcastGrp: Can not ADD SELF TO MCAST GRP. Error = (%d)\n", Error);
//      WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_MCAST_SOCK);  //log an event
        return;
   }

    DBGLEAVE("JoinMcastGrp\n");

    return;
}
VOID
CommLeaveMcastGrp(
 VOID
)

/*++

Routine Description:
    This function is called by the comm. subsystem to make WINS join
    a multicast group

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
       CommCreatePorts
Side Effects:

Comments:
	None
--*/

{
    DWORD  Error;
    struct ip_mreq mreq;

   //
   // Leave a multicast grp
   //
   mreq.imr_multiaddr.s_addr = htonl(McastAdd.sin_addr.s_addr);
   mreq.imr_interface.s_addr  = INADDR_ANY;    //use the default mcast i/f

   if (setsockopt(CommUdpPortHandle, IPPROTO_IP, IP_DROP_MEMBERSHIP,
                    (char *)&mreq, sizeof(mreq)) == SOCKET_ERROR)
   {

        Error = WSAGetLastError();
        DBGPRINT1(MTCAST, "CommLeaveMcastGrp: Can not DROP MEMBERSHIP TO MCAST GRP. Error = (%d)\n", Error);
        return;
   }

    return;
}

//
// Pointer to WSARecvMsg
//
LPFN_WSARECVMSG WSARecvMsgFuncPtr = NULL;

DWORD
GetWSARecvFunc( SOCKET sock )
{

    DWORD cbReturned = 0;
    DWORD Error = ERROR_SUCCESS;
    GUID WSARecvGuid = WSAID_WSARECVMSG;

    if (WSARecvMsgFuncPtr == NULL)
    {
        Error = WSAIoctl( sock, SIO_GET_EXTENSION_FUNCTION_POINTER,
                          ( void * ) &WSARecvGuid, sizeof( GUID ),
                          ( void * ) &WSARecvMsgFuncPtr,
                          sizeof( LPFN_WSARECVMSG ),
                          &cbReturned, NULL, NULL );
    }

    if ( ERROR_SUCCESS != Error ) {
        Error = WSAGetLastError();
    }

    return Error;
}

BOOL
CheckMcastSock(
   IN fd_set  *pActSocks,
   IN fd_set  *pRdSocks
 )
{
        DWORD                   Error;
        int                     RetVal;
        BYTE                    Buff[COMM_DATAGRAM_SIZE];
        PCOMM_MCAST_MSG_T       pMcastMsg = (PCOMM_MCAST_MSG_T)Buff;
        struct sockaddr_in      RemWinsAdd;
        int                     RemWinsAddLen = sizeof(RemWinsAdd);

        LPBYTE                  pBody;
        COMM_IP_ADD_T           IPAdd;
        BOOL                    fFound;
        DWORD                   i, j;
        DWORD                   NoOfAddsInPkt;
        struct  in_addr         InAdd;
        LPBYTE                  pAdd;
        DWORD                   FirstDelEntryIndex;
        PPNR_STATUS_T           pPnrStatusTmp;

        DBGENTER("CheckMcastSock\n");
        if (FD_ISSET(CommUdpPortHandle, pRdSocks))
        {
                  WSAMSG wsaMsg = {0};
                  WSABUF wsaBuf = {0};

                  Error = GetWSARecvFunc(CommUdpPortHandle);
                  if ( Error != ERROR_SUCCESS)
                  {
                        DBGPRINT1(MTCAST, "GetWSARecvFunc: failed. Error = (%d)\n", Error);
                        return (TRUE);
                  }

                  wsaBuf.buf = (LPBYTE)pMcastMsg;
                  wsaBuf.len = COMM_DATAGRAM_SIZE;
                  wsaMsg.dwBufferCount = 1;
                  wsaMsg.lpBuffers = &wsaBuf;
                  wsaMsg.name = (struct sockaddr *)&RemWinsAdd;
                  wsaMsg.namelen = sizeof(RemWinsAdd);
    
                  Error = WSARecvMsgFuncPtr(
                                CommUdpPortHandle,
                                &wsaMsg,
                                &RetVal,
                                NULL,
                                NULL);
                  if (Error == SOCKET_ERROR)
                  {
                        Error = WSAGetLastError();
                        DBGPRINT1(MTCAST, "CheckMcastSock: recvfrom failed. Error = (%d)\n", Error);
                        if (WinsCnf.State_e != WINSCNF_E_TERMINATING)
                        {
                          WINSEVT_LOG_M(
                                        Error,
                                        WINS_EVT_WINSOCK_RECVFROM_ERR
                                     );
                        }
                        return(TRUE);
                  }

                 //
                 // If we were told not to use self found pnrs, return
                 //
                 if (!WinsCnf.fUseSelfFndPnrs)
                 {
                    DBGLEAVE("ChkMcastSock - 99\n");
                    return (TRUE);
                 }

                 // if we received a packet which is not sent to multicast, drop it.
                 if (!(wsaMsg.dwFlags & MSG_MCAST))
                 {
                     DBGLEAVE("ChkMcastSock - non mcast pkt\n");
                     return (TRUE);
                 }

                 //
                 // If the sign is not in the valid range, return
                 //
                 if ((pMcastMsg->Sign < COMM_MCAST_SIGN_START) || (pMcastMsg->Sign > COMM_MCAST_SIGN_END) ||
                     RetVal < FIELD_OFFSET(COMM_MCAST_MSG_T, Body[0]))
                 {
                      DBGPRINT1(MTCAST, "Signature in received message = %d\n", pMcastMsg->Sign);
                      DBGLEAVE("CheckMcastSock - 1\n");
                      return(TRUE);
                 }

                 //
                 // Compute the number of addresses in the packet.
                 //
                 NoOfAddsInPkt = (RetVal - FIELD_OFFSET(COMM_MCAST_MSG_T, Body[0]))/COMM_IP_ADD_SIZE;
                 DBGPRINT2(MTCAST, "ChkMcastSock: RetVal = (%d);NoOfAddsInPkt = (%d)\n", RetVal, NoOfAddsInPkt);

                 FirstDelEntryIndex = pPnrStatus->NoOfPnrs;
                 pBody = pMcastMsg->Body;

                 if (NoOfAddsInPkt > 0)
                 {
                     IPAdd = *(PCOMM_IP_ADD_T)pBody;
                     pBody += COMM_IP_ADD_SIZE;
                 }

                 //
                 // Loop until either all ip addresses in packets are
                 // exhausted or we get an ip. address of 0.  If somebody
                 // sent a 0 address, then it is ok to ignore the rest.
                 //
                 for(
                            ;
                      (IPAdd != 0) && NoOfAddsInPkt;
                      IPAdd = *(PCOMM_IP_ADD_T)pBody, pBody += COMM_IP_ADD_SIZE,
                                             NoOfAddsInPkt--
                    )
                 {

                     DBGPRINT1(MTCAST, "CheckMcastSock: Processing WINS address = %lx\n", ntohl(IPAdd));
                     fFound = FALSE;
                     pPnrStatusTmp = (PPNR_STATUS_T)(pPnrStatus->Pnrs);
                     if (pMcastMsg->Code == COMM_MCAST_WINS_UP)
                     {
                         for (i=0; i < pPnrStatus->NoOfPnrs; i++, pPnrStatusTmp++)
                         {
                              if ((FirstDelEntryIndex == pPnrStatus->NoOfPnrs)
                                              &&
                                  (pPnrStatusTmp->State == COMM_MCAST_WINS_DOWN))
                              {
                                  FirstDelEntryIndex = i;
                              }

                              if (IPAdd == pPnrStatusTmp->IPAdd)
                              {
                                  if (pPnrStatusTmp->State == COMM_MCAST_WINS_DOWN)
                                  {
                                     pPnrStatusTmp->State = COMM_MCAST_WINS_UP;
                                     InAdd.s_addr      = IPAdd;
                                     pAdd              = inet_ntoa(InAdd);
                                     WinsCnfAddPnr(RPL_E_PULL, pAdd);
                                     WinsCnfAddPnr(RPL_E_PUSH, pAdd);
                                  }
                                  fFound = TRUE;
                                  break;
                              }
                         }
                         if (!fFound  && (i <= pPnrStatus->NoOfPnrs))
                         {
                             DWORD FirstFreeIndex;
                             PPNR_STATUS_T pPnr;
                             //
                             // since disable loopback is not working we
                             // have to check for message sent by self
                             //
FUTURES("Remove the if when winsock is enhanced to allow loopback to be")
FUTURES("disabled")
                             if (!ChkMyAdd(ntohl(IPAdd)))
                             {
                               InAdd.s_addr = IPAdd;
                               pAdd         = inet_ntoa(InAdd);

                               if (FirstDelEntryIndex < pPnrStatus->NoOfPnrs)
                               {
                                     FirstFreeIndex = FirstDelEntryIndex;
                               }
                               else
                               {
                                     FirstFreeIndex = pPnrStatus->NoOfPnrs++;
                                     if (pPnrStatus->NoOfPnrs == pPnrStatus->NoOfPnrSlots)
                                      {

                                        WINSMSC_REALLOC_M(MCAST_PNR_STATUS_SIZE_M(pPnrStatus->NoOfPnrSlots * 2), (LPVOID *)&pPnrStatus);
                                        pPnrStatus->NoOfPnrSlots *= 2;
                                        DBGPRINT1(DET, "CheckMcastSock: NO OF PNR SLOTS INCREASED TO (%d)\n", pPnrStatus->NoOfPnrSlots);

                                      }
                               }
                               pPnr = (PPNR_STATUS_T)(pPnrStatus->Pnrs);
                               (pPnr + FirstFreeIndex)->State = COMM_MCAST_WINS_UP;
                               (pPnr + FirstFreeIndex)->IPAdd = IPAdd;

                               WinsCnfAddPnr(RPL_E_PULL, pAdd);
                               WinsCnfAddPnr(RPL_E_PUSH, pAdd);

                               DBGPRINT1(MTCAST, "CheckMcastSock: ADDED WINS partner with address = %s\n", pAdd);
                             }
                         }
                   }
                   else  //has to be COMM_MCAST_WINS_DOWN
                   {
                         for (i=0; i < pPnrStatus->NoOfPnrs; i++, pPnrStatusTmp++)
                         {
                              if (IPAdd == pPnrStatusTmp->IPAdd)
                              {
                                  if (pPnrStatusTmp->State == COMM_MCAST_WINS_DOWN)
                                  {
                                    fFound = TRUE;
                                  }
                                  else
                                  {
                                      pPnrStatusTmp->State = COMM_MCAST_WINS_DOWN;
                                  }
                                  break;
                              }
                         }
                         if (!fFound)
                         {
                           InAdd.s_addr = IPAdd;
                           pAdd = inet_ntoa(InAdd);
                           DBGPRINT1(MTCAST, "CheckMcastSock: Will REMOVE WINS partner with address = %s IFF Untouched by admin\n", pAdd);
                           WinsCnfDelPnr(RPL_E_PULL, pAdd);
                           WinsCnfDelPnr(RPL_E_PUSH, pAdd);
                         }
                 }
               } // end of for loop
               DBGLEAVE("ChkMcastSock - 2\n");
               return(TRUE);
       }

       DBGLEAVE("ChkMcastSock - 3\n");
       return(FALSE);
}

BOOL
ChkMyAdd(
 COMM_IP_ADD_T IpAdd
 )
{
  DWORD i;
  PCOMM_IP_ADD_T pIpAdd = pWinsAddresses->IpAdd;
  for (i=0; i<pWinsAddresses->NoOfAdds; i++)
  {
      if (IpAdd == *pIpAdd++)
      {
          return(TRUE);
      }
  }
  return(FALSE);
}

VOID
CommSendMcastMsg(
      DWORD Code
 )
{

  PCOMM_MCAST_MSG_T  pMcastMsg;
  DWORD             McastMsgLen;
  LPBYTE            pBody;
  DWORD             i;
  COMM_IP_ADD_T     Add = 0;

  // --ft bug #103361: no need to send CommSendMcastMsg if there
  // is no nic card here
  if (pWinsAddresses == NULL)
      return;

  McastMsgLen = MCAST_PKT_LEN_M(pWinsAddresses->NoOfAdds + 1);

  WinsMscAlloc(McastMsgLen, &pMcastMsg);

  pMcastMsg->Code = Code;
  pMcastMsg->Sign = COMM_MCAST_SIGN_START;
  pBody = pMcastMsg->Body;

  //
  // Insert the count in net order.
  //
//  NMSMSGF_INSERT_ULONG_M(pBody, pWinsAddresses->NoOfAddresses);

  //
  // Insert the addresses in net order
  //
  for (i=0; i<pWinsAddresses->NoOfAdds; i++)
  {
    DBGPRINT1(MTCAST, "CommSendMcastMsg: Inserting Address = (%lx)\n",
                        pWinsAddresses->IpAdd[i]);
    NMSMSGF_INSERT_IPADD_M(pBody, pWinsAddresses->IpAdd[i]);
  }
  NMSMSGF_INSERT_IPADD_M(pBody, Add);


  DBGPRINT1(MTCAST, "CommSendMcastMsg: Sending MCAST msg of length = (%d)\n",
                                               McastMsgLen);
  CommSendUdp (CommUdpPortHandle, &McastAdd, (MSG_T)pMcastMsg, McastMsgLen);

  WinsMscDealloc(pMcastMsg);
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\assoc.h ===
#ifndef _COMMASSOC_
#define _COMMASSOC_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	assoc.c

Abstract:


	This is the header file to be included for calling assoc.c functions


Author:

	Pradeep Bahl	(PradeepB)	Dec-1992

Revision History:

--*/

/*
	includes
*/
#include <wins.h>
#include "winsock2.h"
#include "comm.h"

/*

 defines
*/

#define COMMASSOC_UDP_BUFFER_HEAP_SIZE	10000
#define COMMASSOC_UDP_DLG_HEAP_SIZE	    5000
#define COMMASSOC_DLG_DS_SZ		sizeof(COMMASSOC_DLG_CTX_T)
#define COMMASSOC_ASSOC_DS_SZ		sizeof(COMMASSOC_ASSOC_CTX_T)


/*
 *
 *  size of header put by RtlInsertElementGenericTable.
 */
FUTURES("Gary Kimura (2/13) said that he would provide a macro for the size")
FUTURES("Use that when it is available")

#define  COMMASSOC_TBL_HDR_SIZE   (sizeof(RTL_SPLAY_LINKS) + sizeof(LIST_ENTRY))

/*
  Size of memory block to allocate for sending any of association set up
  messages.  We use the largest of the sizes of the various assoc. set up
  messages so that we can reuse a buffer.  The buffer size is kept a multiple
  of 16.
*/

#define COMMASSOC_START_REQ_ASSOC_MSG_SIZE	(32 + sizeof(COMM_HEADER_T))
#define COMMASSOC_START_RSP_ASSOC_MSG_SIZE      (16 + sizeof(COMM_HEADER_T))
#define COMMASSOC_STOP_REQ_ASSOC_MSG_SIZE	(16 + sizeof(COMM_HEADER_T))

#define COMMASSOC_ASSOC_MSG_SIZE	COMMASSOC_START_REQ_ASSOC_MSG_SIZE

#if SUPPORT612WINS > 0
#define  COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE  (COMMASSOC_ASSOC_MSG_SIZE + 1)
#endif

/*
 Initial memory sizes for heaps used for allocating assoc. and dlg ctx blocks
*/

#define COMMASSOC_ASSOC_BLKS_HEAP_SIZE		1000
#define COMMASSOC_DLG_BLKS_HEAP_SIZE		4000
#define COMMASSOC_TCP_MSG_HEAP_SIZE		    10000



//
// defines to access the next and prev assoc. in the list
//
#define NEXT_ASSOC_M(pAssocCtx)	((PCOMMASSOC_ASSOC_CTX_T)		\
					((pAssocCtx)->Top.Head.Flink))	
#define PREV_ASSOC_M(pAssocCtx)	((PCOMMASSOC_ASSOC_CTX_T)		\
					((pAssocCtx)->Top.Head.Blink))

//
// Macro to unlink an association from the table of responder associations
// Called by CommStopMonDlg in commapi.c and by CommAssocDeleteAssocInTbl
//
#define  COMMASSOC_UNLINK_RSP_ASSOC_M(pAssocCtx) 		{	\
	NEXT_ASSOC_M(PREV_ASSOC_M((pAssocCtx)))  = NEXT_ASSOC_M((pAssocCtx)); \
	PREV_ASSOC_M(NEXT_ASSOC_M((pAssocCtx)))  = PREV_ASSOC_M((pAssocCtx)); \
				}
/*
 Macros
*/
//
//  Sets up Communication data structures (assoc and dlg ctx blocks)
//
#define COMMASSOC_SETUP_COMM_DS_M(mpDlgCtx, mpAssocCtx, mType_e, mRole_e) \
	{								\
		(mpAssocCtx)->DlgHdl.SeqNo   = (mpDlgCtx)->Top.SeqNo;	\
		(mpAssocCtx)->DlgHdl.pEnt    = (mpDlgCtx);		\
		(mpAssocCtx)->State_e        = COMMASSOC_ASSOC_E_ACTIVE; \
		(mpAssocCtx)->Typ_e          = (mType_e);		\
									\
		(mpDlgCtx)->AssocHdl.SeqNo   = (mpAssocCtx)->Top.SeqNo;	\
		(mpDlgCtx)->AssocHdl.pEnt    = (mpAssocCtx);		\
		(mpDlgCtx)->Role_e           = (mRole_e);		\
		(mpDlgCtx)->Typ_e            = (mType_e);		\
	}

/*
 externs
*/

/*
 Handles to the heaps created for allocating assoc. ctx blocks and
 Dlg Ctx blocks
*/
extern HANDLE			CommAssocAssocHeapHdl;
extern HANDLE			CommAssocDlgHeapHdl;
extern HANDLE			CommAssocTcpMsgHeapHdl;

/*
  typedefs
*/

typedef		DWORD		IP_ADDRESS;
typedef 	IP_ADDRESS	HOST_ADDRESS;


	


typedef enum _COMMASSOC_ASSOC_STOP_RSN_E {
	COMMASSOC_E_USER_INITIATED = 0,
	COMMASSOC_E_AUTH_FAILURE,
	COMMASSOC_E_INCOMP_VERS,
	COMMASSOC_E_BUG_CHECK,
	COMMASSOC_E_MSG_ERR		//some error in message format
	} COMMASSOC_STP_RSN_E, *PCOMMASSOC_STP_RSN_E;

/*
   ASSOC_ROLE_E -- Enumerator for the different roles
*/

typedef enum _COMMASSOC_ASSOC_ROLE_E {
	COMMASSOC_ASSOC_E_INITIATOR = 0,
	COMMASSOC_ASSOC_E_RESPONDER
	} COMMASSOC_ASSOC_ROLE_E, *PCOMMASSOC_ASSOC_ROLE_E;

/*
   COMMASSOC_DLG_ROLE_E -- Enumerator for the different roles
*/

typedef enum _COMMASSOC_DLG_ROLE_E {
	COMMASSOC_DLG_E_IMPLICIT = 0,
	COMMASSOC_DLG_E_EXPLICIT
	} COMMASSOC_DLG_ROLE_E, *PCOMMASSOC_PDLG_ROLE_E;
	




/*
  ASSOC_MSG_TYP_E - different assoc. messages
*/

typedef enum _COMMASSOC_ASSOC_MSG_TYP_E{
	COMMASSOC_ASSOC_E_START_REQ = 0,
	COMMASSOC_ASSOC_E_STOP_REQ,
	COMMASSOC_ASSOC_E_START_RESP
	} COMMASSOC_MSG_TYP_E, *PCOMMASSOC_MSG_TYP_E;
	
/*
  DLG_STATE_E - states of a dialogue
*/

typedef enum _COMMASSOC_DLG_STATE_E {
	COMMASSOC_DLG_E_INACTIVE = 0,
	COMMASSOC_DLG_E_ACTIVE,
	COMMASSOC_DLG_E_DYING
	} COMMASSOC_DLG_STATE_E, *PCOMMASSOC_DLG_STATE_E;


/*

  DLG_HDL_T - Dialogue Context Block

 The ctx block must have COMM_TOP_T structure at the top (used by DeallocEnt in
 assoc.c)
*/

typedef struct _COMMASSOC_DLG_CTX_T {
	COMM_TOP_T	      Top;
	COMM_HDL_T 	      AssocHdl;        	//ptr to the Assoc ctx block
	COMMASSOC_DLG_STATE_E State_e;          // state of the dialogue
	COMM_TYP_E	      Typ_e;           // type of the dialogue
	COMMASSOC_DLG_ROLE_E  Role_e;           //Role - IMPLICIT/EXPLICIT
FUTURES("There is no need to store pMsg and MsgLen in dlg ctx block")
FUTURES("since now I am storing FirstWrdOfMsg in it. Make sure that this")
FUTURES("assertion is indeed true")
	MSG_T		      pMsg;             //ptr to datagram received on
					        //UDP port
	MSG_LEN_T	      MsgLen;           //msg Length of datagram
	DWORD		      FirstWrdOfMsg;	//first word of message received
	struct sockaddr_in    FromAdd;          //address of sender of datagram
CHECK("Is this needed")
	DWORD		      QuesNameSecLen;   //Length of question section
						//in name req
        DWORD		      RspLen;	        //length of the response packet
	SOCKET		      SockNo;		//sock. # of connection
					        //created when simulating an
						//nbt node (to send a name
						//reg request to a remote WINS)
						//see ClastAtReplUniqueR
	} COMMASSOC_DLG_CTX_T, *PCOMMASSOC_DLG_CTX_T;
	
	

/*
   ASSOC_STATE_E -- Enumerator for the different states of an Association
*/
typedef enum _COMMASSOC_ASSOC_STATE_E {
	COMMASSOC_ASSOC_E_NON_EXISTENT = 0,
	COMMASSOC_ASSOC_E_STARTING,
	COMMASSOC_ASSOC_E_ACTIVE,
	COMMASSOC_ASSOC_E_STOPPING,
	COMMASSOC_ASSOC_E_DISCONNECTED
	} COMMASSOC_ASSOC_STATE_E, *PCOMMASSOC_ASSOC_STATE_E;


typedef COMMASSOC_DLG_CTX_T	DLG_CTX_T;
typedef COMM_HDL_T	COMMASSOC_DLG_HDL_T;
typedef COMM_HDL_T	COMMASSOC_ASSOC_HDL_T;





/*
  ASSOC_CTX - Association Context Block

 The ctx block must have COMM_TOP_T structure at the top (used by DeallocEnt in
 assoc.c)

*/
typedef struct _COMMASSOC_ASSOC_CTX_T {
	COMM_TOP_T	            Top;
	COMM_HDL_T 	            DlgHdl;        //ptr to the Assoc ctx block
	SOCKET		            SockNo;	       /*handle to TCP/UDP socket*/
	ULONG		            uRemAssocCtx;  /*remote assoc ctx block*/
	DWORD		            MajVersNo;
	DWORD		            MinVersNo;
	COMMASSOC_ASSOC_STATE_E	State_e;	/* state	*/
	COMM_TYP_E	        Typ_e;    	/* type	*/
	COMMASSOC_ASSOC_ROLE_E	Role_e;         /*Role -- Initiator/responder*/
    COMM_ADD_TYP_E          AddTyp_e;
    union {
	struct sockaddr_in      RemoteAdd;	//Address of remote node
	struct sockaddr_in      RemoteAddIpx;	//Address of remote node
      };
    ULONG                   nTag; // 32bit tag to be used in replication protocol
	} COMMASSOC_ASSOC_CTX_T, *PCOMMASSOC_ASSOC_CTX_T;


/*
  ASSOC_TAG - Mapping between (64bit) pointers and 32bit values.
  This has to be used in order to locate the local COMMASSOC_ASSOC_CTX_T structure from the
  32bit value handed by the partner through the replication protocol.
*/

#define COMMASSOC_TAG_CHUNK     64

typedef struct _COMMASSOC_TAG_POOL_T {
    CRITICAL_SECTION crtSection;    // mutual exclusion guard
    LPVOID           *ppStorage;    // array of (64bit) pointer values
    ULONG            *pTagPool;     // array of 32bit tags
    ULONG            nIdxLimit;     // number of entries available in both arrays above
    ULONG           nMaxIdx;        // maximum number of free tags
} COMMASSOC_TAG_POOL_T, *PCOMMASSOC_TAG_POOL_T;

extern COMMASSOC_TAG_POOL_T sTagAssoc;  //32bit ULONG -> LPVOID mapping

/*
function prototypes
*/

extern
VOID
CommAssocSetUpAssoc(
	PCOMM_HDL_T	pDlgHdl,
	PCOMM_ADD_T	pAdd,
	COMM_TYP_E	CommTyp_e,
	PCOMMASSOC_ASSOC_CTX_T	*ppAssocCtx		
	);

extern
VOID
CommAssocFrmStartAssocReq(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	MSG_T			pMsg,	
	MSG_LEN_T		MsgLen
	);

extern
VOID
CommAssocUfmStartAssocReq(
	IN  MSG_T			pMsg,
	OUT PCOMM_TYP_E			pAssocTyp_e,
	OUT LPDWORD   			pMajorVer,
	OUT LPDWORD			pMinorVer,	
	OUT ULONG           *puRemAssocCtx
	);


extern
VOID
CommAssocFrmStartAssocRsp(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	MSG_T			pMsg,	
	MSG_LEN_T		MsgLen
	);

extern
VOID
CommAssocUfmStartAssocRsp(
	IN  MSG_T		pMsg,
	OUT LPDWORD   	pMajorVer,
	OUT LPDWORD		pMinorVer,	
	IN  ULONG	    *puRemAssocCtx
	);



extern
VOID
CommAssocFrmStopAssocReq(
	PCOMMASSOC_ASSOC_CTX_T   pAssocCtx,
	MSG_T			 pMsg,
	MSG_LEN_T		 MsgLen,
	COMMASSOC_STP_RSN_E	StopRsn_e
	);

extern
VOID
CommAssocUfmStopAssocReq(
	MSG_T			pMsg,
	PCOMMASSOC_STP_RSN_E	pStopRsn_e
	);


extern
VOID
CommAssocDeallocAssoc(
	LPVOID		   pAssocCtx	
	);

extern
VOID
CommAssocDeallocDlg(
	LPVOID		   pDlgCtx	
	);	

extern
LPVOID
CommAssocAllocAssoc(
		VOID
		  );

extern
LPVOID
CommAssocAllocDlg(
	VOID
	);

extern
VOID
CommAssocInit(
	VOID
	);



extern
PCOMMASSOC_DLG_CTX_T
CommAssocInsertUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pCtx,
	OUT LPBOOL			pfNewElem
	);
	
extern
VOID
CommAssocDeleteUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pDlgCtx
	);
	

extern
LPVOID
CommAssocCreateAssocInTbl(
	SOCKET SockNo
	);

extern
VOID
CommAssocDeleteAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx	
	);
extern
LPVOID
CommAssocLookupAssoc(
	SOCKET SockNo
	);

extern
VOID
CommAssocInsertAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T pAssocCtx
	);

extern
ULONG
CommAssocTagAlloc(
    PCOMMASSOC_TAG_POOL_T pTag,
    LPVOID pPtrValue
    );

extern
VOID
CommAssocTagFree(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    );

extern
LPVOID
CommAssocTagMap(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    );

#ifdef __cplusplus
}
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\com\assoc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	assoc.c

Abstract:
	THis module contains the functions that deal with associations and
	dialogues

Functions:
	CommAssocSetUpAssoc
	CommAssocFrmStartAssocReq
	CommAssocUfmStartAssocReq
	CommAssocFrmStopAssocReq
	CommAssocUfmStopAssocReq
	CommAssocFrmStartAssocRsp
	CommAssocUfmStartAssocRsp
	CommAssocAllocAssoc
	CommAssocAllocDlg
	AllocEnt
	DeallocEnt
	CommAssocDeallocAssoc	
	CommAssocDeallocDlg
	CommAssocInit
	CommAssocInsertUdpDlgInTbl
	CommAssocDeleteUdpDlgInTbl
	CommAssocCreateAssocInTbl
	CommAssocDeleteAssocInTbl
	CommAssocLookupAssoc
	CommAssocInsertAssocInTbl
	

Portability:

	This module is portable

Author:

	Pradeep Bahl (PradeepB)  	7-Dec-1992

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include "nms.h"
#include "comm.h"
#include "assoc.h"
#include "winsque.h"
#include "winsmsc.h"
#include "winsevt.h"

/*
 *	Local Macro Declarations
 */


/*
 *	Local Typedef Declarations
*/

#if PRSCONN
STATIC DWORD		sAssocSeqNo = 0;
#else
STATIC DWORD		sAssocSeqNo = 1;
#endif

STATIC QUE_HD_T		sAssocQueHd;
STATIC CRITICAL_SECTION sAssocListCrtSec;

#if PRSCONN
STATIC DWORD		sDlgSeqNo = 0;
#else
STATIC DWORD		sDlgSeqNo = 1;
#endif

STATIC QUE_HD_T		sDlgQueHd;
STATIC DWORD        sNoOfDlgCrtSec;     //no of crt. secs in dlgs
STATIC DWORD        sNoOfAssocCrtSec;   //no of crt. secs in assocs.
STATIC CRITICAL_SECTION sDlgListCrtSec;

STATIC LIST_ENTRY sUdpDlgHead;

COMMASSOC_TAG_POOL_T sTagAssoc;  //32bit ULONG -> LPVOID mapping

/*
 *	Global Variable Definitions
 */


/*
  Handles to the heaps to be used for assoc. and dlg. allocation
*/
HANDLE			CommAssocAssocHeapHdl;
HANDLE			CommAssocDlgHeapHdl;
HANDLE			CommAssocTcpMsgHeapHdl;

/*
  Size of the memory for one assoc.
*/
DWORD			CommAssocAssocSize = 0;

/*
  Size of
DWORD			CommAssocMaxAssoc  = 0;


/*
 *	Local Variable Definitions
 */

STATIC CRITICAL_SECTION       sUdpDlgTblCrtSec;

//
// This is the start of the Responder Assoc Table.  This table holds the list of
// active Responder associations.  Currently, the table is implemented
// as a linked list using the Rtl Linked list functions.
//
QUE_HD_T	     sRspAssocQueHd;

/*
 *	Local Function Prototype Declarations
*/

/* prototypes for functions local to this module go here */
STATIC
LPVOID
AllocEnt(
	HANDLE		   HeapHdl,
	PQUE_HD_T	   pQueHd,
	LPCRITICAL_SECTION pCrtSec,
	LPDWORD		   pSeqNoCntr,
	DWORD		   Size,
    LPDWORD        pCntCrtSec
	);

STATIC
VOID
DeallocEnt(
	HANDLE		   HeapHdl,
	PQUE_HD_T	   pQueHd,
	LPCRITICAL_SECTION pCrtSec,
	LPDWORD		   pSeqNoCntr,
	LPVOID		   pHdl,
    LPDWORD        pCntCrtSec
	);


//
// Function definitions start here
//

VOID
CommAssocSetUpAssoc(
	IN  PCOMM_HDL_T			pDlgHdl,
	IN  PCOMM_ADD_T			pAdd,
	IN  COMM_TYP_E			CommTyp_e,
	OUT PCOMMASSOC_ASSOC_CTX_T	*ppAssocCtx		
	)

/*++

Routine Description:

	This function sets up an association
Arguments:
	pDlghdl   - Handle to dlg under which an association has to be set up
	pAdd      - Address of node with which the association has to be set up
	CommTyp_e - TYpe of association
	ppAssocCtx - Association Context block allocated by the function


Externals Used:
	None

Called by:
	ECommStartDlg
Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --

--*/

{

	SOCKET 		        SockNo = INVALID_SOCKET;
	PCOMMASSOC_ASSOC_CTX_T 	pAssocCtx = NULL; //v. imp to init this to NULL
	INT		 	BytesRead = -1;
	MSG_T		 	pTcpMsg;
	STATUS			RetStat;
	WINS_MEM_T	 	WinsMem[2];
	PWINS_MEM_T	 	pWinsMem = WinsMem;
#if SUPPORT612WINS > 0
	BYTE		 	AssocMsg[COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE];
	DWORD		 	MsgLen = COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE;
#else
	BYTE		 	AssocMsg[COMMASSOC_ASSOC_MSG_SIZE];
	DWORD		 	MsgLen = COMMASSOC_ASSOC_MSG_SIZE;
#endif
	PCOMMASSOC_DLG_CTX_T 	pDlgCtx = pDlgHdl->pEnt;
	pWinsMem->pMem = NULL;
	
try {

	/*
	*  Create a TCP connection to the WINS at the other node
	*/
	CommConnect(
         pAdd,
		CommWinsTcpPortNo,          // WINS_TCP_PORT,
		&SockNo
		   );

	/*
	*  Allocate the assoc context block
	*/
	pAssocCtx = CommAssocAllocAssoc();
	
	pAssocCtx->SockNo  	= SockNo;
	pAssocCtx->uRemAssocCtx = 0;
	pAssocCtx->State_e 	= COMMASSOC_ASSOC_E_NON_EXISTENT;
	pAssocCtx->Role_e  	= COMMASSOC_ASSOC_E_INITIATOR;
	pAssocCtx->Typ_e   	= CommTyp_e;
	pAssocCtx->DlgHdl  	= *pDlgHdl;
	pAssocCtx->RemoteAdd.sin_addr.s_addr  	= pAdd->Add.IPAdd;
    pAssocCtx->nTag     = CommAssocTagAlloc(&sTagAssoc,pAssocCtx);


	/*
		Format the start association message.

		The address passed to the formatting function is offset
		from the address of the buffer by a LONG so that CommSendAssoc
		can store the length of the message in it.
	*/
	CommAssocFrmStartAssocReq(
				pAssocCtx,
				AssocMsg + sizeof(LONG),
				MsgLen - sizeof(LONG)
				);


	pDlgCtx->AssocHdl.pEnt  = pAssocCtx;
	pDlgCtx->AssocHdl.SeqNo = pAssocCtx->Top.SeqNo;

	/*
	*  send the message on the TCP connection
	*/
	CommSendAssoc(
			pAssocCtx->SockNo,
			AssocMsg + sizeof(LONG),
			MsgLen - sizeof(LONG)
		   );

	/*
		Read in the response message
	*/
	RetStat =  CommReadStream(
			pAssocCtx->SockNo,
			TRUE,		// do timed wait
			&pTcpMsg,
			&BytesRead
		      		 );

	
	/*
	  If the return status is not WINS_SUCCESS or bytes read are 0, then
	  either it is a disconnect or the read timed out.  Raise an exception.
	  (We should have gotten either a start or a stop assoc.  message.
	*/
	if ((BytesRead != 0) && (RetStat == WINS_SUCCESS))
	{

		DWORD  Opc;
		DWORD  MsgTyp;
		ULONG  uNoNeed;

		pWinsMem->pMem = pTcpMsg - sizeof(LONG) - COMM_BUFF_HEADER_SIZE;
		(++pWinsMem)->pMem   = NULL;

		/*
		 * unformat the response
		*/
		COMM_GET_HEADER_M(pTcpMsg, Opc, uNoNeed, MsgTyp);
	

		/*
		* if MsgTyp indicates that it is a start assoc. response
		* message, change state of association to Active; return
		* success
		*/
		if (MsgTyp == COMM_START_RSP_ASSOC_MSG)
		{
			CommAssocUfmStartAssocRsp(
			    pTcpMsg,
                            &pAssocCtx->MajVersNo,
                            &pAssocCtx->MinVersNo,
			                &pAssocCtx->uRemAssocCtx
						 );

			pAssocCtx->State_e   = COMMASSOC_ASSOC_E_ACTIVE;
#if SUPPORT612WINS > 0
                        //
                        // If bytes read are less than what a post-beta1
                        // WINS sends us, it means that it must be a beta1 WINS.
                        //
                        if (BytesRead >= (COMMASSOC_POST_BETA1_ASSOC_MSG_SIZE - sizeof(LONG)))
                        {
#if 0
                            pAssocCtx->MajVersNo = WINS_BETA2_MAJOR_VERS_NO;
                            pAssocCtx->MinVersNo = 1; //not used currently
#endif
                        }
                        else
                        {
                            pAssocCtx->MajVersNo = WINS_BETA1_MAJOR_VERS_NO;
                            pAssocCtx->MinVersNo = 1; //not used currently

                        }
#endif
		}	

                //
                // Let us free the message that we received
                //
                ECommFreeBuff(pTcpMsg);

		/*
		 * if opcode indicates that it is a stop assoc. message, do
		 * cleanup; return failure
		*/
		if (MsgTyp == COMM_STOP_REQ_ASSOC_MSG)
		{
                  //
                  // Decrement conn. count
                  //
                  CommDecConnCount();
		  WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);	
	        }
	}
	else // Either Bytes Read are 0 or select timed out or some other error
	     // occurred
	{
		WINS_RAISE_EXC_M(WINS_EXC_COMM_FAIL);
	}
}
except (EXCEPTION_EXECUTE_HANDLER)  {

	DWORD	ExcCode = GetExceptionCode();
	DBGPRINTEXC("CommAssocSetUpAssoc");


	//
	// If the exception occurred after the socket was opened, close it
	//	
        if (SockNo != INVALID_SOCKET)
        {
		CommDisc(SockNo, TRUE);     // close the socket
	}

	//
	// if an assoc. ctx block was allocated, free it now
	//
	if (pAssocCtx != NULL)
	{
        CommAssocTagFree(&sTagAssoc, pAssocCtx->nTag);
		CommAssocDeallocAssoc(pAssocCtx);
	}
	
	//
	// reraise the exception
	//
	WINS_HDL_EXC_N_RERAISE_M(WinsMem);
   }  //end of except {..}

	*ppAssocCtx = pAssocCtx;
	return;
} //CommAssocSetUpAssoc()


VOID
CommAssocFrmStartAssocReq(
	IN  PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	IN  MSG_T			pMsg,	
	IN  MSG_LEN_T		        MsgLen
	)


/*++

Routine Description:

	This function is called to format a start association message

Arguments:
	pAssocCtx - Association Context block
	pMsg     - Buffer containing the formatted start assoc. req. msg.
	MsgLen   - Size of the above buffer


Externals Used:
	None

Return Value:
	None

Error Handling:

Called by:
	CommAssocSetUpAssoc

Side Effects:

Comments:
	None
--*/
	
{

	ULONG		*pLong = NULL;

	/*

	 The start assoc. message  contains the following fields
	
		the assoc handle (ptr field)
		Version Number (major and minor) both are 16 bits
		Authentication Info (currently nothing)
		Association Type (an integer)

	*/
	pLong      	  =  (LPLONG)pMsg;

	COMM_SET_HEADER_M(
		pLong,
		WINS_IS_NOT_NBT,	//opcode
		0,	/*We don't have the remote guy's assoc. ptr yet*/
		COMM_START_REQ_ASSOC_MSG  //msg type
			      );

	*pLong++   = htonl(pAssocCtx->nTag);
	*pLong++   = htonl((WINS_MAJOR_VERS << 16 ) | WINS_MINOR_VERS);
	*pLong     = htonl(pAssocCtx->Typ_e);   //assoc type

	return;

}
	
	
        	

VOID
CommAssocUfmStartAssocReq(
	IN  MSG_T		        pMsg,
	OUT PCOMM_TYP_E        		pAssocTyp_e,
	OUT LPDWORD   		        pMajorVer,
	OUT LPDWORD		        pMinorVer,	
	OUT ULONG               *puRemAssocCtx
	)


/*++

Routine Description:

	This function parses the start association message that arrives on
	a TCP connection and returns with the relevant information

Arguments:
	pMsg	     -- Message to be unformatted
	pAssocTyp_e  -- Type of assoc  (i.e from who -- replicator, COMSYS, etc)
	pMajorVer    -- Major version no.
	pMinorVer    -- Minor version no.
	puRemAssocCtx -- ptr to assoc. ctx block of remote WINS


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ProcTcpMsg

Side Effects:

Comments:
	None
--*/

{



	/*
	  Increment pLong past the comm header
	*/
	LPLONG  pLong = (LPLONG)(pMsg + COMM_HEADER_SIZE);
	LONG    lTmp;

    *puRemAssocCtx = ntohl(*pLong++);
					//ptr to assoc. ctx at remote WINS
	/*
	 * Get the long that contains the major and minor version numbers
	*/
	lTmp = ntohl(*pLong++); 		

	*pMajorVer   = lTmp >> 16; 		//Major vers. no.
	*pMinorVer   = lTmp & 0x0ff;        	//Minor vers. no.

	*pAssocTyp_e = ntohl(*pLong);		/*Msg type (from who -- COMSYS,
						  Replicator
						*/
	return;

}	

VOID
CommAssocFrmStopAssocReq(
	IN  PCOMMASSOC_ASSOC_CTX_T   pAssocCtx,
	IN  MSG_T		     pMsg,
	IN  MSG_LEN_T		     MsgLen,
	IN  COMMASSOC_STP_RSN_E	     StopRsn_e
	)


/*++

Routine Description:
 This function formats a stop association message


Arguments:
	pAssocCtx -- Assoc. Ctx block.
	pMsg     -- Buffer containing the formatted stop assoc. req. msg.
	MsgLen   -- Length of above buffer
	StopRsn_e -- Reason why the association is being stopped

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommAssocSetUpAssoc

Side Effects:

Comments:
	None
--*/
{



	unsigned long	*pLong = NULL;


	/*
	 The stop assoc. message  contains the following fields
	
		the reason for the stop/abort.

	*/


	pLong      =  (LPLONG)pMsg;

	
	COMM_SET_HEADER_M(
		pLong,
		WINS_IS_NOT_NBT,
		pAssocCtx->uRemAssocCtx,
		COMM_STOP_REQ_ASSOC_MSG
			      );
	
	*pLong   = htonl(StopRsn_e);

	return;
}

VOID
CommUfmStopAssocReq(
	IN  MSG_T			pMsg,
	OUT PCOMMASSOC_STP_RSN_E	pStopRsn_e
	)


/*++

Routine Description:
 This function formats a stop association message


Arguments:
	pMsg       - Message containing the stop assoc. req.
	pStopRsn_e - reason why the association was stopped


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ProcTcpMsg

Side Effects:

Comments:
	None
--*/
{
	
	/*
	  Increment pLong past the comm header
	*/
	LPLONG pLong = (LPLONG)(pMsg + COMM_HEADER_SIZE);
	
	*pStopRsn_e = ntohl(*pLong);
 	
	return;

}




VOID
CommAssocFrmStartAssocRsp(
	IN  PCOMMASSOC_ASSOC_CTX_T	pAssocCtx,
	IN  MSG_T			pMsg,	
	IN  MSG_LEN_T			MsgLen
	)


/*++

Routine Description:

	This function is called to format a start association response message

Arguments:
	pAssocCtx -- Assoc. ctx block
	pMsg     -- Buffer containing the formatted start assoc. rsp. msg.
	MsgLen   -- Length of above buffer

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ProcTcpMsg

Side Effects:

Comments:
	None
--*/
	
{
	LPLONG		pLong = NULL;


	/*

	 The start assoc. message  contains the following fields
	
		the assoc handle (ptr field)
		Authentication Info (currently nothing)

	*/


	pLong      =  (unsigned long *)pMsg;

	COMM_SET_HEADER_M(
		pLong,
		WINS_IS_NOT_NBT,
		pAssocCtx->uRemAssocCtx,
		COMM_START_RSP_ASSOC_MSG
			      );

    *pLong++   = htonl(pAssocCtx->nTag);
	*pLong   = htonl((WINS_MAJOR_VERS << 16 ) | WINS_MINOR_VERS);

	return;

}
	
	
        	


VOID
CommAssocUfmStartAssocRsp(
	IN  MSG_T		        pMsg,
	OUT LPDWORD   		        pMajorVer,
	OUT LPDWORD		        pMinorVer,	
	OUT ULONG               *puRemAssocCtx
	)


/*++

Routine Description:
 This function formats a stop association message


Arguments:
	pMsg          - Buffer containing the Start Assoc. rsp. message
	puRemAssocCtx - ptr to remote assoc. ctx block.

Externals Used:
	None

Return Value:
	None

Error Handling:

Called by:
	CommAssocSetUpAssoc

Side Effects:

Comments:
	None
--*/
{
	/*
	  Increment pLong past the comm header
	*/
	LPLONG pLong = (LPLONG)(pMsg + COMM_HEADER_SIZE);
        LONG   lTmp;
	
	*puRemAssocCtx = ntohl(*pLong++);
 	
	/*
	 * Get the long that contains the major and minor version numbers
	*/
	lTmp = ntohl(*pLong); 		

	*pMajorVer   = lTmp >> 16; 		//Major vers. no.
	*pMinorVer   = lTmp & 0xff;        	//Minor vers. no.

	return;

}



LPVOID
CommAssocAllocAssoc(
		VOID
)

/*++

Routine Description:
	This function allocates an association


Arguments:
	None

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
	ECommAssocAllocAssoc

Side Effects:

Comments:
	None
--*/

{

	return(
	   AllocEnt(
		CommAssocAssocHeapHdl,
		&sAssocQueHd,
		&sAssocListCrtSec,
		&sAssocSeqNo,
		COMMASSOC_ASSOC_DS_SZ,	
        &sNoOfAssocCrtSec	
	        )
	     );

}		

LPVOID
CommAssocAllocDlg( 	
	VOID
	)

/*++

Routine Description:
	This function allocates a dialogue context block

Arguments:
	None

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	ECommStartDlg, ProcTcpMsg

Side Effects:

Comments:
	None
--*/

{

	return(
	  AllocEnt(
		CommAssocDlgHeapHdl,
		&sDlgQueHd,
		&sDlgListCrtSec,
		&sDlgSeqNo,
		COMMASSOC_DLG_DS_SZ,
        &sNoOfDlgCrtSec	
		    )
	     );

}		

LPVOID
AllocEnt(
	IN   HANDLE		  HeapHdl,
	IN   PQUE_HD_T	  	  pQueHd,
	IN   LPCRITICAL_SECTION   pCrtSec,
	IN   LPDWORD		  pSeqNoCntr,
	IN   DWORD		  Size,
    IN   LPDWORD      pCntOfCrtSec
	)

/*++

Routine Description:
	This function is used to allocate a ctx. block (association or dlg).

Arguments:
	HeapHdl   - Heap from where the alloc. muxt be done
	pQueHd	  - Head of free list queue
	pCrtSec   - Critical section protecting the above queue
	pSeqNoCtr - Counter value used to stamp the buffer if it is allocated
		    as versus when it is taken from the free list
	Size      - Size of buffer to allocate

Externals Used:
	None

	
Return Value:
	Ptr to the block allocated	

Error Handling:

Called by:
	CommAssocAllocAssoc, CommAssocAllocDlg	

Side Effects:

Comments:
--*/

{
	PCOMM_TOP_T	pTop;
//	DWORD		Error;
	PLIST_ENTRY	pHead = &pQueHd->Head;


	EnterCriticalSection(pCrtSec);
try {

	if (IsListEmpty(pHead))
	{	

		  pTop =   WinsMscHeapAlloc(
					   HeapHdl,
					   Size
					 );
#ifdef WINSDBG
          IF_DBG(HEAP_CNTRS)
          {
            EnterCriticalSection(&NmsHeapCrtSec);
            NmsHeapAllocForList++;
            LeaveCriticalSection(&NmsHeapCrtSec);
          }
#endif
        //
        // Init the critical section in the block we just allocated.
        //
        InitializeCriticalSection(&pTop->CrtSec);
        pTop->fCrtSecInited = TRUE;
        (*pCntOfCrtSec)++;
		pTop->SeqNo =  (*pSeqNoCntr)++;
	}
	else
	{
		pTop   = (PCOMM_TOP_T)RemoveTailList(pHead);

        //
        // Just took a free entry. Decrement count
        //
        if (!pTop->fCrtSecInited)
        {
           InitializeCriticalSection(&pTop->CrtSec);
           pTop->fCrtSecInited = TRUE;
           (*pCntOfCrtSec)++;
        }
	}

   }
finally	{
	LeaveCriticalSection(pCrtSec);
	}
	return(pTop);	
}


VOID
DeallocEnt(
	IN  HANDLE		   HeapHdl,
	IN  PQUE_HD_T	   	   pQueHd,
	IN  LPCRITICAL_SECTION     pCrtSec,
	IN  LPDWORD		   pSeqNoCntr,
	IN  LPVOID		   pEnt,
    IN  LPDWORD        pCntOfCrtSec
	)

/*++

Routine Description:
	The function deallocates a context block


Arguments:
	pQueHd	  - Head of free list queue
	pCrtSec   - Critical section protecting the above queue
	pSeqNoCtr - Counter value used to stamp the buffer before putting
		    it in the queue.
		    heap
	pEnt      - entity to be deallocated

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommAssocDeallocDlg, CommAssocDeallocAssoc

Side Effects:

Comments:
	None
--*/

{
	PCOMM_TOP_T	pTop;
	PLIST_ENTRY	pHead = &pQueHd->Head;

	UNREFERENCED_PARAMETER(HeapHdl);
	pTop = pEnt;	
	EnterCriticalSection(pCrtSec);
try {
	(*pSeqNoCntr)++;
	pTop->SeqNo = *pSeqNoCntr;
	InsertTailList(pHead, &pTop->Head);
    //
    // Delete critical section if necessary to save on non-paged pool
    //
    if (*pCntOfCrtSec > COMM_FREE_COMM_HDL_THRESHOLD)
    {
       //
       //
       // We want to keep the non-paged pool within a limit.
       // Deallocate this block. This ensures that we will never
       // have more than COMM_FREE_COMM_HDL_THRESHOLD no of dlgs and
       // assocs in the free list.
       //
       DeleteCriticalSection(&pTop->CrtSec);
       (*pCntOfCrtSec)--;
       pTop->fCrtSecInited = FALSE;
    }
   } //end of try
finally {
	LeaveCriticalSection(pCrtSec);
	}
	return;	
}	

VOID
CommAssocDeallocAssoc(
	IN  LPVOID		   pAssocCtx	
	)

/*++

Routine Description:
	The function deallocates an association context block


Arguments:
	pAssocCtx - Buffer (assoc. ctx block) to deallocate


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommAssocDeleteAssocInTbl, CommAssocSetUpAssoc, CommEndAssoc	

Side Effects:

Comments:
	None
--*/

{
	DeallocEnt(
		  CommAssocAssocHeapHdl,
		  &sAssocQueHd,
		  &sAssocListCrtSec,
		  &sAssocSeqNo,
		  pAssocCtx,
          &sNoOfAssocCrtSec
		  );
	return;
}	
	
VOID
CommAssocDeallocDlg(
	IN  LPVOID		   pDlgCtx	
	)

/*++

Routine Description:
	The function deallocates a dialogue context block


Arguments:
	pDlgCtx   - Buffer (dlg. ctx block) to deallocate


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	RtlDeleteElementGenericTable

Side Effects:

Comments:
	None
--*/

{
	DeallocEnt(
		   CommAssocDlgHeapHdl,
		   &sDlgQueHd,
		   &sDlgListCrtSec,
		   &sDlgSeqNo,
		   pDlgCtx,
           &sNoOfDlgCrtSec
		  );
	return;
}	


VOID
CommAssocInit(
	VOID
	)

/*++

Routine Description:
	The function is called at init time to initialize the critical sections
	and queues for RESPONDER associations and dialogues pertaining to
	incoming request datagrams.


Arguments:

	None

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	CommInit

Side Effects:

Comments:
	None
--*/

{

	//
	// Initialize the critical sections that guard the lists of
	// associations and non-udp dialogues
	//
	InitializeCriticalSection(&sAssocListCrtSec);
	InitializeCriticalSection(&sDlgListCrtSec);

	//	
	// Initialize the critical section for the UDP table
	//
	InitializeCriticalSection(&sUdpDlgTblCrtSec);

	
	//
	// Initialize the list heads for the lists of associations
	// and non-udp dialogues
	//
	InitializeListHead(&sAssocQueHd.Head);
	InitializeListHead(&sDlgQueHd.Head);

	//
	// Initialize the list head for the list of active responder
	// associations
	//
	InitializeListHead(&sRspAssocQueHd.Head);

	InitializeListHead(&sUdpDlgHead);

    // Initialize the tag variable
    InitializeCriticalSection(&sTagAssoc.crtSection);
    sTagAssoc.nIdxLimit = 0;
    sTagAssoc.nMaxIdx = 0;
    sTagAssoc.ppStorage = NULL;
    sTagAssoc.pTagPool = NULL;

	return;
}



PCOMMASSOC_DLG_CTX_T
CommAssocInsertUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pCtx,
	OUT LPBOOL			pfNewElem
	)
	
/*++

Routine Description:
	This function is called to insert a UDP dlg into the CommUdpNbtDlgTable.


Arguments:

	pDlgCtx	   - Dlg Ctx Block
	pfNewElem  - flag indicating whether it is a new element


Externals Used:
	None

	
Return Value:
	Ptr to the dlg ctx block

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{

	PCOMMASSOC_DLG_CTX_T	pDlgCtx;


	EnterCriticalSection(&sUdpDlgTblCrtSec);
try {
        pDlgCtx = WINSMSC_INSERT_IN_TBL_M(
					&CommUdpNbtDlgTable,
					pCtx,
					sizeof(COMMASSOC_DLG_CTX_T),
					(PBOOLEAN)pfNewElem
					  ); 	
	}
finally {
	LeaveCriticalSection(&sUdpDlgTblCrtSec);
 }
	return(pDlgCtx);	
}

VOID
CommAssocDeleteUdpDlgInTbl(
	IN  PCOMMASSOC_DLG_CTX_T	pDlgCtx
	)
	
/*++

Routine Description:
	This function is called to insert a UDP dlg into the CommUdpNbtDlgTable.


Arguments:
	pDlgCtx	   - Dlg Ctx Block

Externals Used:
	None
	
Return Value:

	Ptr to the dlg ctx block
Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{


	BOOLEAN   fRetVal;

	EnterCriticalSection(&sUdpDlgTblCrtSec);
try {
	DBGPRINT0(FLOW, "CommAssocDeleteUdpDlgInTbl:Deleting dlg from table\n");
        fRetVal = WINSMSC_DELETE_FRM_TBL_M(
					&CommUdpNbtDlgTable,
					pDlgCtx
				    ); 	

	if (fRetVal == (BOOLEAN)FALSE)
	{
		DBGPRINT0(ERR, "CommAssocDeleteUdpDlgInTbl:Could not delete dlg in table\n");
	}
  }
finally  {

	LeaveCriticalSection(&sUdpDlgTblCrtSec);
 }	

	return;	
}

				
		
LPVOID
CommAssocCreateAssocInTbl(
	SOCKET	SockNo
	)

/*++

Routine Description:
	This function is called to create an association ctx block for
	a tcp connection

Arguments:
	SockNo - Socket # of socket mapped to the TCP connection

Externals Used:
	sRspAssocQueHd	

	
Return Value:
	ptr to the associaton context block created for the TCP connection

Error Handling:

Called by:
	MonTcp (TCP listener thread)

Side Effects:

Comments:
	None
--*/

{
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx;

	//
	// Allocate/(grab from free list) an association
	//
	pAssocCtx 	  = CommAssocAllocAssoc();
	pAssocCtx->SockNo = SockNo;
    pAssocCtx->nTag   = CommAssocTagAlloc(&sTagAssoc,pAssocCtx);

	CommAssocInsertAssocInTbl(pAssocCtx);
	return(pAssocCtx);
}


VOID
CommAssocDeleteAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T	pAssocCtx
	)

/*++

Routine Description:
	This function is called to delete an association context block from
	the table of active responder associations.  The association ctx.
	block is deleted from the table and also deallocated (i.e. put
	in the free list)

Arguments:
	pAssocCtx - Association context block to delete from a table

Externals Used:
	sRspAssocQueHd	
	
Return Value:
	None

Error Handling:

Called by:
	DelAssoc

Side Effects:

Comments:
	None
--*/

{

	//
	// Unlink the association
	//
	COMMASSOC_UNLINK_RSP_ASSOC_M(pAssocCtx);

	//
	// Dealloc the assoc. so that it can be reused for some other
	// TCP connection
	//
    CommAssocTagFree(&sTagAssoc, pAssocCtx->nTag);
	CommAssocDeallocAssoc(pAssocCtx);
	return;
}

LPVOID
CommAssocLookupAssoc(
	SOCKET SockNo
	)

/*++

Routine Description:
	This function is called to lookup an association context block
	corresponding to a socket.

Arguments:
	SockNo - Socket # of socket whose association context block is
		 desired

Externals Used:
	sRspAssocQueHd
	
Return Value:

	ptr to assoc ctx block or NULL if there is no assoc. mapped to the
	socket

Error Handling:

Called by:
	DelAssoc

Side Effects:

Comments:
	None
--*/

{
	PCOMMASSOC_ASSOC_CTX_T	pTmp =
			(PCOMMASSOC_ASSOC_CTX_T)sRspAssocQueHd.Head.Flink;

	//
	// If list is empty, return NULL
	//
	if (IsListEmpty(&sRspAssocQueHd.Head))
	{
		return(NULL);
	}
	//
	// Search for the assoc. mapped to socket
	//
	for(
			;
		pTmp != (PCOMMASSOC_ASSOC_CTX_T)&sRspAssocQueHd ;
		pTmp = NEXT_ASSOC_M(pTmp)
	   )
	{
		if (pTmp->SockNo == SockNo)
		{
			return(pTmp);
		}
	}

	//
	// There is no assoc. mapped to socket SockNo.  Return NULL
	//
	return(NULL);
}


VOID
CommAssocInsertAssocInTbl(
	PCOMMASSOC_ASSOC_CTX_T pAssocCtx
	)

/*++

Routine Description:
	This function is called to insert an association at the head
	of the list of associations currently being monitored

Arguments:
	pAssocCtx - Assoc. Ctx. Block

Externals Used:
	None

	
Return Value:
	None
Error Handling:

Called by:
	CommAssocCreateAssocInTbl, ECommMonDlg
Side Effects:

Comments:
	Change to a macro
--*/

{

	//
	// Insert at the head of the list of active responder associations
	//
	// Insertion is done at the head of the list in order to optimize
	// the lookup of the association when the first message comes on
	// it from a remote WINS.  Since the first message follows on the
	// heels of the connection set up, the search for the association
	// which starts from the head is optimized.
	//
	InsertHeadList(&sRspAssocQueHd.Head, &pAssocCtx->Top.Head);
	return;
}

ULONG
CommAssocTagAlloc(
    PCOMMASSOC_TAG_POOL_T pTag,
    LPVOID pPtrValue
    )
/*++
Routine Description:
	This function is used to create a mapping between a generic pointer (32bit/64bit)
    and a 32bit tag.
Arguments:
    pPtrValue - generic pointer value
Externals Used:
    TBD
Return Value:
	None
--*/
{
    // a try..finally block is needed just in case the memory reallocation would raise. 
    // an exception. In this case, before leaving the try block and the function, the finally
    // block gets executed and leaves cleanly the tag critical section. If this happens
    // the exception will still be passed up the chain (since there is no except block present).
    try
    {
        ULONG newTag;

        DBGPRINT0(FLOW, "Entering CommAssocTagAlloc.\n");

        EnterCriticalSection(&(pTag->crtSection));

        // if nMaxIdx is 0 this means there is no entry available in the Tag pool
        if (pTag->nMaxIdx == 0)
        {
            UINT i;

            // tag pool needs to be enlarged. We might want to check if the buffers have not reached 
            // 2^32 entries (highly unlikely)
            ULONG nNewLimit = pTag->nIdxLimit + COMMASSOC_TAG_CHUNK;
            // realloc failures raise exceptions.
            if (pTag->nIdxLimit == 0)
            {
                pTag->ppStorage = (LPVOID*)WinsMscHeapAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(LPVOID));
                pTag->pTagPool = (ULONG*)WinsMscHeapAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(ULONG));
            }
            else
            {
                WinsMscHeapReAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(LPVOID), (LPVOID)&(pTag->ppStorage));
                WinsMscHeapReAlloc(CommAssocAssocHeapHdl, nNewLimit*sizeof(ULONG), &(pTag->pTagPool));
            }

            // mark the newly allocated entries as being free for use
            pTag->nMaxIdx = COMMASSOC_TAG_CHUNK;
            for (i = 0; i < pTag->nMaxIdx; i++)
            {
                // tags should be in the range 1... hence the pre-increment op here.
                pTag->pTagPool[i] = ++pTag->nIdxLimit;
            }
        }
        // at this point pTag->nMaxIdx entries are free for use and pTag->nMaxIdx is guaranteed
        // to be greater than 0. The entries free for use have the indices in pTag->pTagPool[0..pTag->nMaxIdx-1]

       // get the newly allocated tag
        newTag = pTag->pTagPool[--pTag->nMaxIdx];
        // map the pointer to this tag into the pointer storage
        pTag->ppStorage[newTag-1] = pPtrValue;

#ifdef WINSDBG
        // robust programming
        pTag->pTagPool[pTag->nMaxIdx] = 0;
#endif
        DBGPRINT2(REPL, "TagAlloc: tag for %p is %08x.\n", pPtrValue, newTag);

        // return the newly allocated tag
        return newTag;
    }
    finally
    {
        LeaveCriticalSection(&(pTag->crtSection));
        DBGPRINT0(FLOW, "Leaving CommAssocTagAlloc.\n");
    }
}

VOID
CommAssocTagFree(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    )
/*++
Routine Description:
	This function is used to free a mapping between a generic pointer (32bit/64bit)
    and a 32bit tag.
Arguments:
    nTag - tag value to be freed.
Externals Used:
    TBD
Return Value:
	None
--*/
{
    DBGPRINT0(FLOW, "Entering CommAssocTagFree.\n");
    EnterCriticalSection(&(pTag->crtSection));

#ifdef WINSDBG
    // robust programming - just set the corresponding pointer from the storage to NULL
    pTag->ppStorage[nTag-1] = NULL;
#endif

    // just mark the nTag index as being free for use
    pTag->pTagPool[pTag->nMaxIdx++] = nTag;

    DBGPRINT1(REPL, "TagFree for tag %08x.\n", nTag);

    // 'Free' has to match with 'Alloc' so nMaxIdx can't exceed under no circumstances nIdxLimit
    ASSERT (pTag->nMaxIdx <= pTag->nIdxLimit);

    LeaveCriticalSection(&(pTag->crtSection));
    DBGPRINT0(FLOW, "Leaving CommAssocTagFree.\n");
}

LPVOID
CommAssocTagMap(
    PCOMMASSOC_TAG_POOL_T pTag,
    ULONG nTag
    )
/*++
Routine Description:
	This function is used to retrieve a generic pointer (32bit/64bit) that
    is uniquely identified through a 32bit tag.
Arguments:
    nTag - tag value that identifies the generic pointer.
Externals Used:
    TBD
Return Value:
	None
--*/
{
    DBGPRINT0(FLOW, "Entering CommAssocTagMap.\n");

    DBGPRINT2(REPL, "TagMap for tag %08x is %p.\n", 
           nTag, 
           nTag == 0 ? NULL : pTag->ppStorage[nTag-1]);

    // the indices that were given have to fall in the range 0..pTag->nIdxLimit
    ASSERT (nTag <= pTag->nIdxLimit);

    DBGPRINT0(FLOW, "Leaving CommAssocTagMap.\n");
    // return the (64bit) value from pStorage, associated with the nTag provided
    return nTag == 0 ? NULL : pTag->ppStorage[nTag-1];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nmfilter.h ===
#ifndef _NMFILTER_H
#define _NMFILTER_H

// the node having this flag is a terminal node for some name
#define NMFILTER_FLAG_TERMINAL          0x00000001

// The filter is designed as a tree in which each node stands for one char from the NETBIOS name.
// The char (Key) associated with each node is contained in the parent's node, next to the reference
// (pointer) this the node. Given that we are filtering 1B names, the root of the tree stands for the
// 1B character (1B names are stored differently in the database: the 16th byte (1B) is swaped with
// the first char of the name.

typedef struct _NMFILTER_TREE   NMFILTER_TREE, *PNMFILTER_TREE;

struct _NMFILTER_TREE
{
    LIST_ENTRY   Link;          // list of NMFILTER_TREE structures linking all nodes having the 
                                // same parent node.
    CHAR         chKey;         // node key: each name in the filter is composed by the sequence of
                                // keys from the root to one of the leafs.
    UINT         nRef;          // number of references for this char in different filters having
                                // the same prefix. This ranks higher this node making the search faster
    BYTE         FollowMap[32]; // bitmask: one bit for each of the 256 possible byte values
                                // byte values (265/8=>32). The search engine will determine
                                // as fast as possible if a follower exists (and need to be
                                // searched in LstFollow) or not.
    DWORD        Flags;         // flags associated with this node.
    LIST_ENTRY   Follow;        // lisf of NMFILTER_TREE structures for all the followers (successors)
                                // of this node. These are chars that follow chKey in all filters.
};

extern CRITICAL_SECTION g_cs1BFilter;   // critical section protecting the filter tree
extern PNMFILTER_TREE   g_p1BFilter;    // filter to use for 1B names

// init the filter passed as parameter
PNMFILTER_TREE
InitNmFilter(PNMFILTER_TREE pFilter);

// clears the whole subtree from the node given as parameter, 
// the node itself being also deleted
PNMFILTER_TREE
DestroyNmFilter(PNMFILTER_TREE pNode);

// inserts a name in the filter
VOID
InsertNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen);

// checks whether a name is present in the filter or not
BOOL
IsNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nms.h ===
#ifndef _NMS_
#define _NMS_
#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	nms.h

Abstract:

  This is the header file for the name space manager component of the
  Name Server.



Author:

	Pradeep Bahl	(PradeepB)	Dec-1992

Revision History:

--*/

/*
 includes
*/


#include "wins.h"
#include "comm.h"

/*
  defines
*/

#ifdef WINSDBG

FUTURES("Put all in a structure")
extern DWORD   NmsGenHeapAlloc;
extern DWORD   NmsDlgHeapAlloc;
extern DWORD   NmsUdpDlgHeapAlloc;
extern DWORD   NmsTcpMsgHeapAlloc;
extern DWORD   NmsUdpHeapAlloc;
extern DWORD   NmsQueHeapAlloc;
extern DWORD   NmsAssocHeapAlloc;
extern DWORD   NmsRpcHeapAlloc;
extern DWORD   NmsRplWrkItmHeapAlloc;
extern DWORD   NmsChlHeapAlloc;
extern DWORD   NmsTmmHeapAlloc;
extern DWORD   NmsCatchAllHeapAlloc;

extern DWORD   NmsHeapAllocForList;

extern DWORD   NmsGenHeapFree;
extern DWORD   NmsDlgHeapFree;
extern DWORD   NmsUdpDlgHeapFree;
extern DWORD   NmsTcpMsgHeapFree;
extern DWORD   NmsUdpHeapFree;
extern DWORD   NmsQueHeapFree;
extern DWORD   NmsAssocHeapFree;
extern DWORD   NmsRpcHeapFree;
extern DWORD   NmsRplWrkItmHeapFree;
extern DWORD   NmsChlHeapFree;
extern DWORD   NmsTmmHeapFree;
extern DWORD   NmsCatchAllHeapFree;

extern DWORD   NmsHeapCreate;
extern DWORD   NmsHeapDestroy;

//
// Count of updates (to version number) made by WINS.
//
extern DWORD   NmsRplUpd; 
extern DWORD   NmsRplGUpd; 
extern DWORD   NmsNmhUpd; 
extern DWORD   NmsNmhGUpd; 
extern DWORD   NmsNmhRelUpd; 
extern DWORD   NmsNmhRelGUpd; 
extern DWORD   NmsScvUpd; 
extern DWORD   NmsScvGUpd; 
extern DWORD   NmsChlUpd; 
extern DWORD   NmsChlGUpd; 
extern DWORD   NmsRpcUpd; 
extern DWORD   NmsRpcGUpd; 
extern DWORD   NmsOthUpd; 
extern DWORD   NmsOthGUpd; 


#if DBG
//
// No of reg/ref/rel requests dropped because of WINS hitting the threshold
// of max. requets on its queue.  Used by InsertOtherNbtWorkItem
//
extern volatile DWORD  NmsRegReqQDropped;
#endif

//
// NmsUpdCtrs[Client][TypeOfUpd][TypeOfRec][StateOfNewRec][VersNoInc]
//
extern DWORD NmsUpdCtrs[WINS_NO_OF_CLIENTS][2][4][3][2];
extern CRITICAL_SECTION NmsHeapCrtSec;
#endif

#define NMS_OPCODE_MASK	  0x78	     /*to weed out the 4 bits of the 3rd byte
				     * of the name packet	
				     */
#define NMS_RESPONSE_MASK 0x80	     /*to weed out the bit that indicates
				      * whether the datagram is a request or 
				      * a response
				      */
/*
  macros
*/

/*
 * NMSISNBT_M -- Is this an nbt request message
 *
 * Examines the third byte of the message to determine this
*/
#define NMSISNBT_M(pMsg) \
	(((*(pMsg + 2) & NMS_OPCODE_MASK) >> 3) != WINS_IS_NOT_NBT)  

/*
* NMSISRPL_M -- Is this a replicator message
*
* Examines the third byte of the message to determine this
*/
#define NMSISRPL_MSG_M(pMsg ) \
	(((*(pMsg + 2) & NMS_OPCODE_MASK) >> 3) == WINS_IS_NOT_NBT)  



/*
  GEN_INIT_BUFF_HEAP_SIZE -- This is the initial size of the heap 
			     for allocating queue items for the various
			     queues, TLS storage,  for reading in a file,etc.  
			     Keep it 1000 
*/
#define GEN_INIT_BUFF_HEAP_SIZE		1000


//
// RPC_INIT_BUFF_HEAP_SIZE -- This is the initial size of the heap for
//			      use by rpc
//
#define RPC_INIT_BUFF_HEAP_SIZE		1000


#define RPL_WRKITM_BUFF_HEAP_SIZE	1000    	//1000 bytes


//
// Initial heap size for timer work items
//
#define   TMM_INIT_HEAP_SIZE	1000

//
// The maximum number of concurrent RPC calls allowed
//
FUTURES("Move these defines to winsthd.h")
#define   NMS_MAX_RPC_CALLS	 15 
#define   NMS_MAX_BROWSER_RPC_CALLS   (NMS_MAX_RPC_CALLS - 4)

//
// Minimum number of RPC call threads
//
#define   NMS_MIN_RPC_CALL_THDS 2

//
// This is the amount of time the service controller is asked to wait
//
#define MSECS_WAIT_WHEN_DEL_WINS          120000   //from ReadOwnAddTbl

/* 
 structure definitions
*/

/*
 QUERY_RSP -- structure used to hold the information that needs to be sent
	      in a positive name query response message
*/

typedef struct
 	{
	DWORD	CountOfIPAdd;   //it is a DWORD for alignment
        DWORD   IPAdd[1];    	//one or more IP addresses start here.
	} QUERY_RSP;

#ifdef WINSDBG
typedef struct _PUSH_CTRS_T {
          DWORD NoUpdNtfAcc;
          DWORD NoUpdNtfRej;
          DWORD NoSndEntReq;
          DWORD NoAddVersReq;
          DWORD NoUpdNtfReq;
          DWORD NoUpdVersReq;
          DWORD NoInvReq;
         } PUSH_CTRS_T, *PPUSH_CTRS_T;

typedef struct _PULL_CTRS_T {
         DWORD  PH;
         } PULL_CTRS_T, *PPULL_CTRS_T; 
         
typedef struct _NMS_CTRS_T {
       PUSH_CTRS_T  RplPushCtrs;     
       PULL_CTRS_T  RplPullCtrs;     
       } NMS_CTRS_T, *PNMS_CTRS_T;
#endif
 
/*
 externs
*/
#ifdef WINSDBG
extern  NMS_CTRS_T  NmsCtrs;
#endif

extern HANDLE 		NmsMainTermEvt;
extern HANDLE 		NmsTermEvt;
extern CRITICAL_SECTION NmsTermCrtSec;
extern HANDLE		NmsCrDelNbtThdEvt;
extern DWORD		NmsNoOfNbtThds;
extern DWORD		NmsTotalTrmThdCnt;

extern BOOL         fNmsThdOutOfReck;


extern VERS_NO_T         NmsRangeSize;
extern VERS_NO_T         NmsHalfRangeSize;
extern VERS_NO_T         NmsVersNoToStartFromNextTime;
extern VERS_NO_T         NmsHighWaterMarkVersNo;

extern DWORD             NmsNoOfRpcCallsToDb;
//
// required for security checking.  The types are defined in ntseapi.h
//
extern GENERIC_MAPPING	   NmsInfoMapping;
extern PSECURITY_DESCRIPTOR pNmsSecurityDescriptor;


FUTURES("move to winsque.h")
extern HANDLE	  GenBuffHeapHdl;  //handle to heap for use for general 
				   //allocation
extern HANDLE	  NmsRpcHeapHdl;  //handle to heap for use for allocation 
				      //by rpc


extern COMM_ADD_T	NmsLocalAdd;  //WINS's Address
extern BOOL		fNmsAbruptTerm;
extern BOOL		fNmsMainSessionActive;

#ifdef TEST_DATA
extern HANDLE NmsFileHdl;
#endif
#ifdef DBGSVC
extern HANDLE NmsDbgFileHdl;
//extern FILE *pNmsDbgFile;
#endif

extern CRITICAL_SECTION WinsIntfNoOfUsersCrtSec;
/* 
 function definitions
*/

//
// Handler used for interfacing with the service controller
//
extern
VOID
NmsServiceControlHandler(
    IN DWORD Opcode
    );

extern
VOID
ENmsHandleMsg(
	PCOMM_HDL_T pDlgHdl, 
	MSG_T 	 	     pMsg,  
	MSG_LEN_T            MsgLen 
	); 

extern
VOID
ENmsWinsUpdateStatus(
    DWORD MSecsToWait
	); 

#ifdef WINSDBG
extern
VOID
NmsPrintCtrs(
 VOID
);
#endif

#ifndef WINS_INTERACTIVE
extern
VOID
NmsChkDbgFileSz(
    VOID
    );
#endif
#ifdef __cplusplus
}
#endif

#endif //_NMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\comm.h ===
#ifndef _COMM_
#define _COMM_


#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	comm.h

Abstract:
	header file for interfacing with comm.c

Functions:


Portability:

	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/

#include "wins.h"
#include <winsock2.h>
#if SPX > 0
#include <wsipx.h>
#endif
#include <nb30.h>
#include <nbtioctl.h>

//Don't include winsque.h here since winsque.h includes comm.h
#if 0
#include "winsque.h"
#endif

/*
   simple defines (simple macros)
*/


#define COMM_DATAGRAM_SIZE		576 /*rfc 1002*/

#define COMM_NETBT_REM_ADD_SIZE		sizeof(tREM_ADDRESS)
/*

  The following two defines are for the TCP and UDP port numbers used
  by the WINS server.

  Normally the same port number is used for both TCP and UDP.


*/
FUTURES("Use a port registered with IANA - 1512.  IPPORT_NAMESERVER is used by")
FUTURES("BIND and NAMED -- Unix internet name servers")

#define 	WINS_TCP_PORT	IPPORT_NAMESERVER
#define 	WINS_UDP_PORT	IPPORT_NAMESERVER
#define 	WINS_NBT_PORT	137		//NBT nameserver port	
//#define 	WINS_NBT_PORT	5000		//for testing

//
// Hardcoded Server port for RPC calls.
//
// Note: This is not used since we let RPC pick a port.  Check out
// InitializeRpc() in nms.c  We will use this define olnly if AUTO_BIND is
// not defined
//
#define         WINS_SERVER_PORT 	5001


#define         COMM_DEFAULT_IP_PORT   IPPROTO_IP   //used to init CommPortNo
/*
 COMM_HEADER_SIZE -- size of the comm header on every message sent on a TCP
   		     connection.  This is used in RPL code
*/
#define 	COMM_HEADER_SIZE 	(sizeof(COMM_HEADER_T))

//
// Total header size of header used by COMSYS
//
#define 	COMM_N_TCP_HDR_SZ	sizeof(COMM_TCP_HDR_T)

/*
  Values returned by CommCompAdd function
*/
#define COMM_SAME_ADD		0x0     // addresses are same
#define COMM_DIFF_ADD		0x1	//addresses are different


#define COMM_START_REQ_ASSOC_MSG	0
#define COMM_START_RSP_ASSOC_MSG	1
#define COMM_STOP_REQ_ASSOC_MSG		2
#define COMM_RPL_MSG			3	


#define COMM_IP_ADD_SIZE		sizeof(COMM_IP_ADD_T)
//
// Size of the header on top of a buffer
//
#define COMM_BUFF_HEADER_SIZE		(sizeof(COMM_BUFF_HEADER_T))
/*
  macros
*/
//
// This macro gets the network address from an IP Address in binary form
// Used by AppendNetAdd in nmsnmh.c. It assumes a CLASS B network address
//
//
FUTURES("Use the subnet mask specified via registry")
#define  COMM_NET_ADDRESS_M(Add)	(Add >> 16)

#define COMM_SET_HEADER_M(pLong, Opc, uAssocCtx, MsgTyp)	 \
		{						 \
			LPBYTE _pTmpB = (LPBYTE)pLong++;	 \
			*(_pTmpB + 2)  = Opc << 3; 		 \
			*pLong++      = htonl(uAssocCtx); \
			*pLong++      = htonl(MsgTyp);		 \
		}


#define COMM_GET_HEADER_M(pMsg,  Opc, uAssocCtx, MsgTyp)  \
		{				         	\
			LPLONG	_pLong  = (LPLONG)pMsg;	\
			Opc             = ((*(pMsg + 2) & NMS_OPCODE_MASK) >> 3);\
			uAssocCtx       = ntohl(*++_pLong); \
			MsgTyp          = ntohl(*++_pLong); 	\
		}


//
// Is this my address
//
#define COMM_MY_IP_ADD_M(IpAddress)   ((IpAddress) == NmsLocalAdd.Add.IPAdd)

//
// Gets the address of the remote client
//
#define  COMM_GET_IPADD_M(pDlgHdl, pIPAdd)	{		  	  \
			PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;  \
			*(pIPAdd) = _pEnt->FromAdd.sin_addr.s_addr; 	  \
					}

#define  COMM_GET_FAMILY_M(pDlgHdl, Family)	{		  	  \
			PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;  \
			Family = _pEnt->FromAdd.sin_family; 	          \
					}

#define  COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fBeta1)	{(fBeta1) = FALSE;}
#if 0
#define  COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fBeta1)	{	  	  \
	PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;                  \
        PCOMMASSOC_ASSOC_CTX_T  _pAssocEnt = _pEnt->AssocHdl.pEnt;       \
        fBeta1 = (_pAssocEnt->MajVersNo == WINS_BETA1_MAJOR_VERS_NO) ? TRUE : \
          FALSE;                                                            \
					}
#endif
#if PRSCONN
#define  COMM_GET_WINS_VERS_NO_M(pDlgHdl, MajVers, MinVers)	{	  	  \
	PCOMMASSOC_DLG_CTX_T	_pEnt = (pDlgHdl)->pEnt;                  \
        PCOMMASSOC_ASSOC_CTX_T  _pAssocEnt = _pEnt->AssocHdl.pEnt;       \
        MajVers = _pAssocEnt->MajVersNo; \
        MinVers = _pAssocEnt->MinVersNo; \
					}

#define ECOMM_INIT_DLG_HDL_M(pDlgHdl)  {(pDlgHdl)->pEnt = NULL; (pDlgHdl)->SeqNo=0;}
#define ECOMM_IS_PNR_POSTNT4_WINS_M(pDlgHdl, fNT5) {  \
              DWORD _MajVers, _MinVers; \
              COMM_GET_WINS_VERS_NO_M((pDlgHdl), _MajVers, _MinVers); \
              fNT5 = (_MinVers >= WINS_MINOR_VERS_NT5) ? TRUE : FALSE; \
            }
#endif


//
// This macro checks if the name is local or not. Used in NmsNmhNamRegInd
// and NmsNmhNamRegGrp functions
//
#define  COMM_IS_IT_LOCAL_M(pDlgHdl)  \
        (((PCOMMASSOC_DLG_CTX_T)(pDlgHdl->pEnt))->FromAdd.sin_family == NBT_UNIX)

//
// On querying a name, if WINS finds it to be a local name, it sets the
// the family in the DlgHdl to NBT_UNIX so that NETBT can respond to the
// query
//

#if USENETBT > 0
#define  COMM_SET_LOCAL_M(pDlgHdl)  \
        (((PCOMMASSOC_DLG_CTX_T)(pDlgHdl->pEnt))->FromAdd.sin_family = NBT_UNIX)

#else
#define  COMM_SET_LOCAL_M(pDlgHdl)
#endif

//
// Initialize a COMM_ADD_T structure given an IP address
//
#define COMM_INIT_ADD_M(pWinsAdd, IPAddress)	{			\
			(pWinsAdd)->AddLen   = sizeof(PCOMM_IP_ADD_T); 	\
			(pWinsAdd)->AddTyp_e  = COMM_ADD_E_TCPUDPIP; 	\
			(pWinsAdd)->Add.IPAdd = (IPAddress);			\
						}	
//
// Initialize a COMM_ADD_T structure given a dlg handle.
//
#define COMM_INIT_ADD_FR_DLG_HDL_M(pWinsAdd, pDlgHdl)	{		\
			COMM_IP_ADD_T	IPAdd;				\
			COMM_GET_IPADD_M((pDlgHdl), &IPAdd);		\
			COMM_INIT_ADD_M((pWinsAdd), IPAdd);		\
						}	
//
// COMM_ADDRESS_SAME_M -- checks if the addresses are the same.  Expects
// pointers to COMM_ADD_T structues for its parameters
//

#define COMM_ADDRESS_SAME_M(pAdd1,pAdd2)     ((pAdd1)->Add.IPAdd == (pAdd2)->Add.IPAdd)
/*
 COMM_IS_TCP_MSG_M

 This macro is called by FrmNamQueryRsp to determine if the request
 message came over a TCP connection.

 FrmNamQueryRsp checks this in order to determine whether to allocate a
 buffer or use the request buffer for the response.
*/

#define COMM_IS_TCP_MSG_M(pDlgHdl) (((PCOMASSOC_DLG_CTX_T)pDlgHdl->pEnt)->Typ_e != COMM_E_UDP)

NONPORT("Port to different address families")
#define COMM_NETFORM_TO_ASCII_M(pAdd)	inet_ntoa(*(pAdd))

/*

 The macros below are used to host to network and network to host byte
 order coversion.  The macros are used by message formatting functions
 in the name space manager and replicator components of the WINS server
*/

#define COMM_HOST_TO_NET_L_M(HostLongVal_m, NetLongVal_m)	\
	{							\
		NetLongVal_m = htonl((HostLongVal_m));		\
	}

#define COMM_HOST_TO_NET_S_M(HostShortVal_m, NetShortVal_m)	\
	{							\
		NetShortVal_m = htons((HostShortVal_m));	\
	}
	
#define COMM_NET_TO_HOST_L_M(NetLongVal_m, HostLongVal_m)	\
	{							\
		HostLongVal_m = ntohl((NetLongVal_m));		\
	}

#define COMM_NET_TO_HOST_S_M(NetShortVal_m, HostShortVal_m)	\
	{							\
		HostShortVal_m = ntohs((NetShortVal_m));	\
	}

//
// Size of the message sent to the TCP listener thread by the PULL/PUSH
// thread
//
#define  COMM_NTF_MSG_SZ 	sizeof(COMM_NTF_MSG_T)

#if MCAST > 0
#define   COMM_MCAST_WINS_UP     0
#define   COMM_MCAST_WINS_DOWN   1
#define   COMM_MCAST_SIGN_START        0xABCD
#define   COMM_MCAST_SIGN_END          0xABCF
#define   COMM_MCAST_MSG_SZ 	 sizeof(COMM_MCAST_MSG_T)

#endif

//
// No of critical sections for assocs/dlgs that can be there at any one time.
// Want to save on non-paged pool
//
#define COMM_FREE_COMM_HDL_THRESHOLD     100
/*
 externs
*/
struct _COMM_HDL_T;	//forward reference

#if MCAST > 0
extern SOCKET CommMcastPortHandle;
#endif

extern HANDLE CommUdpBuffHeapHdl;
extern HANDLE CommUdpDlgHeapHdl;
extern SOCKET CommTcpPortHandle;
extern SOCKET CommUdpPortHandle;
extern SOCKET CommNtfSockHandle;
extern struct sockaddr_in CommNtfSockAdd;
extern struct _COMM_HDL_T CommExNbtDlgHdl;

extern DWORD  CommConnCount;   //total # of tcp connections from/to local WINS

extern DWORD CommWinsTcpPortNo;
extern DWORD WinsClusterIpAddress;
#if SPX > 0
extern DWORD CommWinsSpxPortNo
#endif

//
// Set to TRUE by the tcp listener thread when it discovers that the assoc.
// it was asked to stop monitoring is no longer in its list.
//
extern BOOL   fCommDlgError;

#ifdef WINSDBG
extern  DWORD CommNoOfDgrms;
extern  DWORD CommNoOfRepeatDgrms;
#endif

FUTURES("Remove this when WinsGetNameAndAdd is removed")

#if USENETBT == 0
extern BYTE	HostName[];
#endif

/*
 typedef  definitions
*/

#if USENETBT > 0
//
// The format of Adapter Status responses
//

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;
#endif
/*
 COMM_IP_ADD_T
	typedef for IP address
*/
typedef ULONG	COMM_IP_ADD_T, *PCOMM_IP_ADD_T;

/*
  COMM_TYP_E  - Enumerator for the different types of dlgs and associations
*/
typedef enum _COMM_TYP_E {
	COMM_E_RPL = 0,	  /* Used for pull replication*/
	COMM_E_NOT,  	  /* Used for notification	*/
	COMM_E_QUERY,	  /*used for querying an RQ server */
	COMM_E_UPD,	  /*used for sending name query responses and
			   * updates to a Q server	*/
	COMM_E_NBT,	  /*  set up by an NBT node*/
	COMM_E_UDP,	  /*set up for UDP communication	*/
	COMM_E_TCP	  /*until we know which TCP msg this is	*/
	} COMM_TYP_E, *PCOMM_TYP_E;

/*
 This is the comm header prefixed on every message sent by a WINS to another
 WINS (on a TCP connection)
*/
typedef struct _COMM_HEADER_T {
	LONG	Opcode;     //NBT or RPL connection opcode
    DWORD   uAssocCtx;  //tag to assoc context block sent by remote WINS 
                        //legacy (32bit) WINS send here pointer to memory.
                        //new (64bit) WINS send here 32bit tag value
	DWORD   MsgTyp;	    //Type of message  (START_ASSOC, STOP_ASSOC, etc)
	} COMM_HEADER_T, *PCOMM_HEADER_T;

/*
 This is the Tcp header prefixed on every message sent by a WINS to another
 WINS (on a TCP connection)
*/
typedef struct _COMM_TCP_HDR_T {
	LONG	      LenOfMsg;     //NBT or RPL connection opcode
        COMM_HEADER_T CommHdr;
	} COMM_TCP_HDR_T, *PCOMM_TCP_HDR_T;

/*
 * COMM_ADD_TYP_E -- enumerator for the different address families.
*/
typedef enum _COMM_ADD_TYP_E {
	COMM_ADD_E_TCPUDPIP = 0,
    COMM_ADD_E_SPXIPX
	} COMM_ADD_TYP_E, *PCOMM_ADD_TYP_E;


/*
 COMM_ADD_T --
	address of a node.  This is in TLV form.  Currently, the union has
	an entry just for IP address.  In the future, it will have
	entries for addresses pertaining to other address families.
	such as XNS, OSI, etc


	NOTE NOTE NOTE
		Put the enumerator at the end so that the alignment of
		the various fields in COMM_ADD_T is on their natural
		boundaries.

		This structure is written as is into the address field of
		the database record (in both the name - address table and the
		owner id - address table).  Therefore it is important
		that we have the alignment set right (in order to save
		on database storage) and also to read the stuff from the
		database record back into the correct fields of an in-memory
		COMM_ADD_T structure
*/
ALIGN("Alignment very important here")
FUTURES("Use a union of SOCKADDR_IP and SOCXADDR_IPX")
typedef struct _COMM_ADD_T {
	DWORD		 AddLen;
	union _Add{
	  DWORD  IPAdd;
	  //		
	  // we may add other fields later on
	  //
#if SPX > 0
      char  netnum[4];
      char  nodenum[6];
#endif

	      } Add;
	COMM_ADD_TYP_E  AddTyp_e;  /*this should be the last field for
				    *alignment puposes
				    */
	} COMM_ADD_T, *PCOMM_ADD_T;	

/*
COMM_HDL_T -- this is the handle to a comm sys. entity such as a dialogue
 or an association.  The handle to a dialogue is passed to COMSYS clients
 for future use by them
*/
typedef struct _COMM_HDL_T {
	DWORD	SeqNo;  //sequence no. of ctx block created for entity
	LPVOID  pEnt;   //pointer to ctx block
	} COMM_HDL_T, *PCOMM_HDL_T;

/*
 COMM_TOP_T  -- This is the structure which is at the top of the assoc and
  dlg ctx structures.   It must have LIST_ENTRY at its top.

*/
typedef struct _COMM_TOP_T {
	LIST_ENTRY	      Head; 	//for linking free blocks
	DWORD		      SeqNo;    //seq. no of block
    CRITICAL_SECTION  CrtSec;
    BOOLEAN           fCrtSecInited;
#if 0
	HANDLE		      MutexHdl; //mutex for locking block
#endif
	} COMM_TOP_T, *PCOMM_TOP_T;


/*
  COMM_BUFF_HEADER_T --

	This is the header for all buffers allocated for requests/responses.
	received over the wire

	Note: This buffer is added on top of COMM_HEADER_T buffer allocated
	for requests/responses sent by a WINS to another WINS	
	
*/
typedef struct _COMM_BUFF_HEADER_T {
	COMM_TYP_E  Typ_e;
	} COMM_BUFF_HEADER_T, *PCOMM_BUFF_HEADER_T;


//
// Command sent to the TCP listener thread by the PUSH thread or the PULL
// thread.   The PULL thread sends the START_MON command when it sends
// a Push trigger to another WINS. The PUSH thread sends the STOP_MON
// command when it receives a PUSH notification (trigger) from a remote WINS
//
typedef enum _COMM_NTF_CMD_E {
		COMM_E_NTF_START_MON = 0,   //sent by PULL thread
		COMM_E_NTF_STOP_MON	    //sent by PUSH thread
		} COMM_NTF_CMD_E, *PCOMM_NTF_CMD_E;

//
// structure of the message sent to the TCP listener thread
//
// There is no need to send the pointer to the Dlg ctx in the message since
// ChkNtfSock() in comm.c can get it from pAssocCtx.  We however send it
// anyway.
//
typedef struct _COMM_NTF_MSG_T {
		COMM_NTF_CMD_E  Cmd_e;
		SOCKET 		SockNo;	 //socket no to stop/start monitoring
		COMM_HDL_T  AssocHdl;
		COMM_HDL_T  DlgHdl;
		} COMM_NTF_MSG_T, *PCOMM_NTF_MSG_T;
		

#if MCAST > 0


typedef struct _COMM_MCAST_MSG_T {
		DWORD  Sign;                    //always 0xABCD
        DWORD  Code;
        BYTE   Body[1];
		} COMM_MCAST_MSG_T, *PCOMM_MCAST_MSG_T;
#endif

/*
	Externals
*/

extern RTL_GENERIC_TABLE	CommAssocTable;     //assoc table
extern RTL_GENERIC_TABLE	CommUdpNbtDlgTable; //tbl for nbt requests (UDP)
extern HANDLE			CommUdpBuffHeapHdl;

/*
 function declarations
*/

#if USENETBT > 0
extern
VOID
CommOpenNbt(
	DWORD FirstBindingIpAddress
    );

extern
STATUS
CommGetNetworkAdd(
	);

#endif

VOID
ECommRegisterAddrChange();

VOID
InitOwnAddTbl(
        VOID
        );

VOID
ECommInit(
	VOID
	);

extern
STATUS
ECommStartDlg(
	PCOMM_ADD_T 	pAdd,  // Address
	COMM_TYP_E 	CommTyp_e,
	PCOMM_HDL_T	pDlgHdl
	);
extern
VOID
ECommSndCmd(
	PCOMM_HDL_T	pDlgHdl,
	MSG_T		pMsg,
	MSG_LEN_T	MsgLen,
	PMSG_T		ppRspMsg,
	PMSG_LEN_T	pRspMsgLen	
	);
extern
STATUS
ECommSndRsp(
	PCOMM_HDL_T  pDlgHdl,
	MSG_T	    pMsg,
	MSG_LEN_T   MsgLen
	);
extern
STATUS
ECommSendMsg(
	PCOMM_HDL_T  	pDlgHdl,
	PCOMM_ADD_T	pAdd,
	MSG_T	  	pMsg,
	MSG_LEN_T  	MsgLen
	);

extern
STATUS
ECommEndDlg(
	PCOMM_HDL_T 	pDlgHdl
	);

extern
VOID
CommEndAssoc(
	PCOMM_HDL_T	pAssocHdl		
	);

extern
LPVOID
CommAlloc(
  PRTL_GENERIC_TABLE	pTable,
  DWORD                 BuffSize
	);

extern
STATUS
ECommAlloc(
  LPVOID *ppBuff,
  DWORD  BuffSize
	);
extern
VOID
ECommDealloc(
  LPVOID pBuff
	);


extern
VOID
CommCreatePorts(
        VOID
           );

extern
VOID
CommInit(
 	VOID
	);


extern
STATUS
CommReadStream(
	IN 	SOCKET  SockNo,
	IN      BOOL	fDoTimedRecv,
	OUT 	PMSG_T 	ppMsg,
	OUT	LPLONG	pBytesRead
	);


extern
VOID
CommCreateTcpThd(VOID);

extern
VOID
CommCreateUdpThd(VOID);




extern
DWORD
ECommCompAdd(PCOMM_ADD_T, PCOMM_ADD_T);

extern
int
__cdecl
ECommCompareAdd(const void *pKey1, const void *pKey2);

extern
STATUS
CommConnect(
    IN  PCOMM_ADD_T pHostAdd,
	IN  SOCKET Port,
	OUT SOCKET *pSockNo
	   );


#if 0
extern
VOID
CommDeallocUdpBuff(
   MSG_T  pMsg
	);
#endif

extern
STATUS
CommReadStream(
	IN 	SOCKET  SockNo,
	IN	BOOL	fDoTimedRecv,
	OUT 	PMSG_T 	ppMsg,
	OUT	LPLONG	pBytesRead
	);

extern
VOID
CommDealloc(
  IN PRTL_GENERIC_TABLE pTable,
  IN PVOID		pBuff
);

#if PRSCONN
extern
__inline
BOOL
CommIsDlgActive(
	PCOMM_HDL_T	pEntHdl
	);

extern
BOOL
CommIsBlockValid(
	PCOMM_HDL_T	pEntHdl
	);
#endif

extern
__inline
STATUS
CommUnlockBlock(
	PCOMM_HDL_T	pEntHdl
	);


extern
BOOL
CommLockBlock(
	PCOMM_HDL_T	pEntHdl
	);

extern
VOID
CommDisc(
	SOCKET SockNo,
    BOOL   fDecCnt
	);
extern
VOID
CommSendUdp (
  SOCKET 	SockNo,
  struct sockaddr_in	*pDest,
  MSG_T   	pMsg,
  MSG_LEN_T     MsgLen
  );

extern
STATUS
CommNbtTcpSnd(
	PCOMM_HDL_T   pAssocHdl,
	MSG_T	  pMsg,
	MSG_LEN_T	  MsgLen
	);

extern
VOID
CommSend(
	COMM_TYP_E	 CommTyp_e,
	PCOMM_HDL_T      pAssocHdl,
	MSG_T	         pMsg,
	MSG_LEN_T	 MsgLen
	);


extern
VOID
CommSendAssoc(
  SOCKET   SockNo,
  MSG_T    pMsg,
  MSG_LEN_T MsgLen
  );


#if PRSCONN
extern
__inline
BOOL
ECommIsDlgActive(
	PCOMM_HDL_T	pEntHdl
	);
extern
__inline
BOOL
ECommIsBlockValid(
	PCOMM_HDL_T	pEntHdl
	);
#endif

extern
VOID
ECommFreeBuff(
	MSG_T		pBuff
	);

extern
BOOL
//VOID
ECommProcessDlg(
	PCOMM_HDL_T	pDlgHdl,
	COMM_NTF_CMD_E  Cmd_e
	);

extern
RTL_GENERIC_COMPARE_RESULTS
CommCompareNbtReq(
 	PRTL_GENERIC_TABLE pTbl,
	PVOID pUdpDlg1,
	PVOID pUdpDlg2
	);

extern
STATUS
ECommGetMyAdd(
	IN OUT PCOMM_ADD_T	pAdd
	);

extern
VOID
CommDecConnCount(
 VOID
 );

#if MCAST > 0
extern
VOID
CommSendMcastMsg(
  DWORD Code
);

extern
VOID
CommLeaveMcastGrp(
  VOID
);

#endif
#ifdef __cplusplus
}
#endif

#endif //_COMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nmschl.h ===
#ifndef _NMSCHL_
#define _NMSCHL_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	Nmschl.h
	

Abstract:
	This is the header file for interfacing with the Name Challenge
	component of WINS

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "comm.h"
#include "nmsdb.h"
/*
  defines
*/

#define NMSCHL_INIT_BUFF_HEAP_SIZE	1000	//1000 bytes

/*
  macros
*/

//
//  The maximum number of challenges that can be initiated at any one time
//  500 is a very genrous number.  We might want to make it smaller.
//
//  used by QueRemoveChlReqWrkItm function in queue.c
//
#define NMSCHL_MAX_CHL_REQ_AT_ONE_TIME 	500 

/*
 externs
*/

extern HANDLE 		  NmsChlHeapHdl;   //Heap for name challenge work items

extern HANDLE		  NmsChlReqQueEvtHdl;
extern HANDLE		  NmsChlRspQueEvtHdl;
extern CRITICAL_SECTION   NmsChlReqCrtSec;
extern CRITICAL_SECTION   NmsChlRspCrtSec;

#ifdef WINSDBG
extern DWORD   NmsChlNoOfReqNbt;
extern DWORD   NmsChlNoOfReqRpl;
extern DWORD   NmsChlNoNoRsp;
extern DWORD   NmsChlNoInvRsp;
extern DWORD   NmsChlNoRspDropped;
extern DWORD   NmsChlNoReqDequeued;
extern DWORD   NmsChlNoRspDequeued;
extern DWORD   NmsChlNoReqAtHdOfList;
#endif

/* 
 typedef  definitions
*/
//
// NMSCHL_CMD_TYP_E -- Enumerator for indicating to the challenge manager
//		       what action it needs to take.
//
typedef enum _NMSCHL_CMD_TYP_E {
		NMSCHL_E_CHL = 0,	//challenge the node.  If the
					//challenge fails, send a negative
					//name reg. response to the registrant,
					//else send a positive response
		NMSCHL_E_CHL_N_REL,
		NMSCHL_E_CHL_N_REL_N_INF,
		NMSCHL_E_REL,		//ask the node to release the
					//name and then update db.  Used by 
                                        //the RPL PULL thread
		NMSCHL_E_REL_N_INF,	//ask the node to release the name. Tell					//remote WINS to update the version number
                NMSCHL_E_REL_ONLY      //ask node to release name, no update db

		}  NMSCHL_CMD_TYP_E, *PNMSCHL_CMD_TYP_E;

/* 
* function declarations
*/
STATUS
NmsChlInit(
	VOID
	);

extern
STATUS
NmsChlHdlNamReg(
	NMSCHL_CMD_TYP_E   CmdTyp_e,
	WINS_CLIENT_E	   Client_e, 
	PCOMM_HDL_T        pDlgHdl,
	MSG_T		   pMsg,
	MSG_LEN_T	   MsgLen,
	DWORD		   QuesNamSecLen,
	PNMSDB_ROW_INFO_T  pNodeToReg,
	PNMSDB_STAT_INFO_T pNodeInCnf,
//	PCOMM_ADD_T	   pAddOfNodeInCnf,
	PCOMM_ADD_T	   pAddOfRemWins
	);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nmsdb.h ===
#ifndef _NMSDB_
#define _NMSDB_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

        nmsdb.h

Abstract:
        This header file is for interfacing with the database manager component
        of the name space manager. The database manager component is a front-end        to the database engine used for WINS server.

        The database engine used for the WINS server currently is JetBlue.


Functions:



Portability:

        This header file is portable.

Author:

        Pradeep Bahl        (PradeepB)        Jan-1993


Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/

/*
  Includes
*/

#include "wins.h"
#include "comm.h"
#include "nmsscv.h"

#include "esent.h"

#include "winsthd.h"
#include "winsintf.h"

/*
  defines
*/

//
// The size of of an array required to hold the IP Address in ascii form.
//
// Used by NmsNmhNamRegInd, NmsNmhQueryRow, and NmsNmhReplRegInd
//
#define NMSDB_MAX_NET_ADD_ARR_SZ                10

#define        NMSDB_LOCAL_OWNER_ID         0  //local WINS always uses 0 for owner id.

//
// NOTE NOTE NOTE
//
//
#define NMSDB_MAX_OWNERS_INITIALLY        100 //max. number of owners in db
#define NMSDB_MAX_MEMS_IN_GRP        25 //max. # of members in group
/*
 Mask for retrieving different fields in the flag byte of a database entry
*/
#define NMSDB_BIT_ENT_TYP        0x03  //bit 0  and 1
#define NMSDB_BIT_STATE                0x0C  //bits 2 and 3
#define NMSDB_BIT_LOCAL                0x10  //bit 4
#define NMSDB_BIT_NODE_TYP        0x60  //bit 5 and 6
#define NMSDB_BIT_STATIC        0x80  // bit 7


/*
  Values to be stored in the flag byte for certain entry types

  NOTE: Don't change the values unless you change the WINSINTF_TYPE_E too.
  The values are same for the enum types in the above enumerator (kept same
  for performance reasons -- check out winsintf.c)
*/
#define NMSDB_UNIQUE_ENTRY        0
#define NMSDB_NORM_GRP_ENTRY        1
#define NMSDB_SPEC_GRP_ENTRY    2
#define NMSDB_MULTIHOMED_ENTRY  3

//
// is not stored in the db.  Used by winsprs functions only
//
#define NMSDB_USER_SPEC_GRP_ENTRY    4

/*
 The shift to the left to be given to values of various items to be stored
 in the flag byte
*/
#define NMSDB_SHIFT_ENT_TYP        0  //bit 0 and 1
#define NMSDB_SHIFT_STATE        2  //bit 2 and 3
#define NMSDB_SHIFT_LOCAL        4  //bit 4
#define NMSDB_SHIFT_NODE_TYP        5  //bit 5
#define NMSDB_SHIFT_STATIC        7  //bit 7


#define   NMSDB_ENTRY_IS_STATIC                        1
#define   NMSDB_ENTRY_IS_NOT_STATIC                0

/*
 NMSDB_MAX_NAM_LEN
  RFC 1002 states
        To simplify implementationss, the total length of label octets
        and label length octets that make up a domain name is restricted to
        255 or less.

        Note: the number is a multiple of 8 (fortunately)
*/
//
// If we are running some internal tests, we will be writing names that
// did not resolve on a query to a file.  We add a \n to the name.  Therefore
// the max size is being increased by 1 (so that when we get a name that
// is 255 bytes long, we do not go past the name array) -- see NmsNmhNamQuery
//
#ifdef TEST_DATA
#define NMSDB_MAX_NAM_LEN                257
#else
#define NMSDB_MAX_NAM_LEN                256 //maximum length of name-- RFC 1002
#endif

/*
  Error status codes returned by NmsDb functions
*/

FUTURES("Get rid of these. Use WINS status codes")

#define        NMSDB_SUCCESS        0x0
#define        NMSDB_CONFLICT   (NMSDB_SUCCESS + 0x1)  //conflict with an existing rec
/*
        limit of addresses in group reached
*/
#define        NMSDB_ADD_LMT_IN_GRP_REACHED   (NMSDB_SUCCESS + 0x2)
#define        NMSDB_NO_SUCH_ROW                  (NMSDB_SUCCESS + 0x3)


#define NMSDB_NAM_ADD_TBL_NM        "NamAddTbl"
#define NMSDB_OWN_ADD_TBL_NM        "OwnAddTbl"


/*
        names for the indices used on the Name to Address mapping table
*/
#define NMSDB_NAM_ADD_CLUST_INDEX_NAME        "NETBIOSNAME"
#define NMSDB_NAM_ADD_PRIM_INDEX_NAME        "OWNERVERSION"


//
// Name of index used on the Owner to Address mapping table
//
#define NMSDB_OWN_ADD_CLUST_INDEX_NAME        "OWNERID"


/*
*        no of pages to allocate initially for the Name to address mapping table
*/

//
// 250 pages means 1 MB of space.  This should be good enough
// If more are needed, the table will be extended by an extent amount
//
#define NMSDB_NAM_ADD_TBL_PGS        250
#define NMSDB_OWN_ADD_TBL_PGS        1

/*
 The density values specified when creating Name to address mapping table
  and the indices on the same
*/
#define NMSDB_NAM_ADD_TBL_DENSITY          80 //density when creating nam-ip tbl
#define NMSDB_NAM_ADD_CLUST_INDEX_DENSITY  80 //density when creating cl. index
#define NMSDB_NAM_ADD_PRIM_INDEX_DENSITY  80 //density when creating pr. index

/*
 The density values specified when creating Owner to address mapping table
  and the indices on the same
*/
#define NMSDB_OWN_ADD_TBL_DENSITY   80 //density when creating nam-ip tbl
#define NMSDB_OWN_ADD_CLUST_INDEX_DENSITY   80 //density when creating cl. index

/*
  macros
*/

//
// This macro gets the pointer to the Thread specific storage
//
FUTURES("Get rid of the return")
#define GET_TLS_M(pTls)        {                                              \
                                DWORD _Error;                           \
                                pTls  = TlsGetValue(WinsTlsIndex); \
                                if (pTls == NULL)                   \
                                {                                   \
                                        _Error = GetLastError();   \
                                        return(WINS_FAILURE);           \
                                }                                   \
                        }

//
// macros to get/set the various attributes of an entry from the flags byte
//
#define NMSDB_ENTRY_STATE_M(Flag)  (((Flag) & NMSDB_BIT_STATE) >> NMSDB_SHIFT_STATE)
#define NMSDB_ENTRY_TYPE_M(Flag)  (((Flag) & NMSDB_BIT_ENT_TYP) >> NMSDB_SHIFT_ENT_TYP)
#define NMSDB_NODE_TYPE_M(Flag)    (((Flag) & NMSDB_BIT_NODE_TYP) >> NMSDB_SHIFT_NODE_TYP)

//
// These macros evaluate to TRUE or FALSE
//
#define NMSDB_IS_ENTRY_LOCAL_M(Flag)  ((Flag) & NMSDB_BIT_LOCAL ? TRUE : FALSE)

#define NMSDB_SET_ENTRY_LOCAL_M(Flag)  (Flag) |= NMSDB_BIT_LOCAL
#define NMSDB_CLR_ENTRY_LOCAL_M(Flag)  (Flag) &= ~NMSDB_BIT_LOCAL

#define NMSDB_IS_ENTRY_STATIC_M(Flag)   ((Flag) & NMSDB_BIT_STATIC ? TRUE : FALSE)


#define NMSDB_CLR_ENTRY_TYPE_M(Flag)  (Flag) &= ~NMSDB_BIT_ENT_TYP
#define NMSDB_SET_ENTRY_TYPE_M(Flag, EntType)   {                        \
                                NMSDB_CLR_ENTRY_TYPE_M((Flag));                \
                                (Flag) |= ((EntType) << NMSDB_SHIFT_ENT_TYP);  \
                                        }

#define NMSDB_CLR_STATE_M(Flag)   (Flag) &= ~NMSDB_BIT_STATE
#define NMSDB_SET_STATE_M(Flag, state)   {                                \
                                NMSDB_CLR_STATE_M((Flag));                \
                                (Flag) |= ((state) << NMSDB_SHIFT_STATE);   \
                                        }

#define NMSDB_CLR_NODE_TYPE_M(Flag)  (Flag) &= ~NMSDB_BIT_NODE_TYP
#define NMSDB_SET_NODE_TYPE_M(Flag, NodeType)  {                        \
                        NMSDB_CLR_NODE_TYPE_M((Flag));                \
                        (Flag) |= ((NodeType) << NMSDB_SHIFT_NODE_TYP);   \
                                        }

#define NMSDB_CLR_STDYN_M(Flag)    (Flag) &= ~NMSDB_BIT_STATIC
#define NMSDB_SET_STDYN_M(Flag, StDynTyp)    {        \
                        NMSDB_CLR_STDYN_M(Flag);        \
                        (Flag) |= ((StDynTyp) << NMSDB_SHIFT_STATIC); \
                                             }

#define NMSDB_SET_STATIC_M(Flag)   (Flag) |= NMSDB_BIT_STATIC
#define NMSDB_SET_DYNAMIC_M(Flag)  (Flag) &= ~NMSDB_BIT_STATIC

#define NMSDB_ENTRY_ACT_M(Flag)         (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_ACTIVE)
#define NMSDB_ENTRY_REL_M(Flag)         (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_RELEASED)
#define NMSDB_ENTRY_TOMB_M(Flag) (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_TOMBSTONE)
#define NMSDB_ENTRY_DEL_M(Flag) (NMSDB_ENTRY_STATE_M(Flag) == NMSDB_E_DELETED)



//
// Remember NameLen includes the EOS
//
FUTURES("Remove the following when support for spec. grp masks is put in")
#define  NMSDB_IS_IT_SPEC_GRP_NM_M(pName) (*((pName) + 15) == 0x1C)

//
// Used in NmsDbGetDataRecs()
//
#define  NMSDB_IS_IT_PDC_NM_M(pName) (*(pName) == 0x1B)


#define  NMSDB_IS_IT_DOMAIN_NM_M(pName) (*((pName) + 15) == 0x1C)
#define  NMSDB_IS_IT_BROWSER_NM_M(pName)  (*((pName) + 15) == 0x1D)


#define NMSDB_ENTRY_UNIQUE_M(EntTyp)   ((EntTyp) == NMSDB_UNIQUE_ENTRY)
#define NMSDB_ENTRY_NORM_GRP_M(EntTyp) ((EntTyp) == NMSDB_NORM_GRP_ENTRY)
#define NMSDB_ENTRY_SPEC_GRP_M(EntTyp) ((EntTyp) == NMSDB_SPEC_GRP_ENTRY)
#define NMSDB_ENTRY_MULTIHOMED_M(EntTyp) ((EntTyp) == NMSDB_MULTIHOMED_ENTRY)
#define NMSDB_ENTRY_GRP_M(EntTyp)      ((EntTyp) == NMSDB_NORM_GRP_ENTRY || \
                                         (EntTyp) == NMSDB_SPEC_GRP_ENTRY)

#define NMSDB_ENTRY_USER_SPEC_GRP_M(pName, EntTyp)  ((NMSDB_ENTRY_SPEC_GRP_M((EntTyp))) && !(NMSDB_IS_IT_SPEC_GRP_NM_M((pName))))

//
// Backup stuff
//
#if NEW_JET || DYNLOADJET
#define NMSDB_FULL_BACKUP          (JET_bitBackupAtomic)
#define NMSDB_INCREMENTAL_BACKUP   ((JET_bitBackupIncremental) | (JET_bitBackupAtomic))
typedef enum {
    DYN_LOAD_JET_200,
    DYN_LOAD_JET_500,
    DYN_LOAD_JET_600,
} DYN_LOAD_JET_VERSION ;

extern DYN_LOAD_JET_VERSION  DynLoadJetVersion;

//extern BOOL fDynLoadJet500;
//extern BOOL fDynLoadJet600;
#else
#define NMSDB_FULL_BACKUP          (JET_bitOverwriteExisting)
#define NMSDB_INCREMENTAL_BACKUP   (JET_bitBackupIncremental)
#endif


//
// Store the name in allocated memory if the name length is > 16.
//
// If the name is less than 17 bytes (can only happen if a small name is
// read in from a file -name within quotes is inserted in exactly the same
// form - or when an admin. inserts a smaller name via winscl), we allocate
// 17 bytes.  This is to protect against an access violation that may happen
// if the record that we have retrieved is a static - In GetGrpMem (called
// from StoreGrpMem), we access the 16th byte of the name field to see if it
// is 1C.
// We are not bothered that the 16th byte will always be 0 (allocated memory
// is initialized to 0) since we want the test in GetGrpMem to fail - see
// GetGrpMem
//
#define NMSDB_STORE_NAME_M(pTls, pRec, pLclName, NameLen)                \
        {                                                                \
                pRec->pName = WinsMscHeapAlloc(pTls->HeapHdl, NameLen < WINS_MAX_NS_NETBIOS_NAME_LEN ? WINS_MAX_NS_NETBIOS_NAME_LEN : NameLen);\
                WINSMSC_MOVE_MEMORY_M(pRec->pName, pLclName, NameLen); \
        }

#if 0
//
// Free all memory that may have been allocated for this record
//
#define NMSDB_FREE_REC_MEM_M(pRec)                        \
        {                                                \
                if (pRec->NameLen > WINS_MAX_NS_NETBIOS_NAME_LEN)        \
                {                                                        \
                        WinsMscHeapFree(RplRecHeapHdl, pRec->pName);        \
                }                                                        \
        }

#endif
/*
 externs
*/
struct _NMSDB_ADD_STATE_T;        //forward declaration

//
// Used during replication (response to get max vers # request)
//
extern VERS_NO_T    NmsDbStartVersNo;
extern WINS_UID_T   NmsDbUid;

//
// In memory table that stores the state of each WINS server we know about
// (as a PULL/PUSH pnr).  The index of the array is the owner id for that
//  WINS server (used to tag records in the name-address mapping table)
//
extern struct _NMSDB_ADD_STATE_T        *pNmsDbOwnAddTbl;
extern DWORD        NmsDbTotNoOfSlots;

//
// No of owners found in the Nam-Add mapping table
//
extern        DWORD                                NmsDbNoOfOwners;

//
// No of owners found in the Own-Add mapping table
//
extern        DWORD                                NmsDbNoOfPushPnrs;


//
// Stores the name of the database file
//
extern BYTE        NmsDbDatabaseFileName[WINS_MAX_FILENAME_SZ];

//
// critical section to protect the NmsDbOwnAddTbl (in-memory table)
//
extern CRITICAL_SECTION   NmsDbOwnAddTblCrtSec;

#ifdef WINSDBG
extern DWORD NmsDbDelDelDataRecs;
extern DWORD NmsDbDelQueryNUpdRecs;
#endif

/*
  enumerations
*/
/*
        NMSDB_TBL_ACTION_E

        Enumerates the actions that can be taken on a table
        Used by the Replicator when it calls NmsDbWriteOwnAddTbl at
        replication time

*/

typedef enum _NMSDB_TBL_ACTION_E {
        NMSDB_E_INSERT_REC = 0,         //Insert the record
        NMSDB_E_MODIFY_REC,                //modify the record
        NMSDB_E_DELETE_REC                //delete the record
        } NMSDB_TBL_ACTION_E, *PNMSDB_TBL_ACTION_E;






/*
        NMSDB_WINS_STATE_E

        states of a WINS server.

*/
typedef enum _NMSDB_WINS_STATE_E {

                NMSDB_E_WINS_ACTIVE = 0,      /*WINS is active */
                NMSDB_E_WINS_DOWN,  /*WINS is temporarily down (it may/may not        have entries in the name-add table*/
                NMSDB_E_WINS_DELETED,  //WINS is permanently down
                NMSDB_E_WINS_INCONSISTENT  //WINS is permanently down

                } NMSDB_WINS_STATE_E, *PNMSDB_WINS_STATE_E;


/*
 NMSDB_TBL_NAM_E - Enumerator for the different table names
*/
typedef enum _TBL_NAM_E {
        NMSDB_E_NAM_ADD_TBL_NM = 0,
        NMSDB_E_OWN_ADD_TBL_NM
        } NMSDB_TBL_NAM_E, *PNMSDB_TBL_NAM_E;


/*
 NMSDB_ADD_STATE_T
        Structure used to store the state of a WINS server
*/

typedef struct _NMSDB_ADD_STATE_T {
                COMM_ADD_T           WinsAdd;
                NMSDB_WINS_STATE_E   WinsState_e;
                DWORD                MemberPrec;
                VERS_NO_T            StartVersNo;
                WINS_UID_T           Uid;
                } NMSDB_ADD_STATE_T, *PNMSDB_ADD_STATE_T;


/*
 states of a database entry.
        There are three states
                ACTIVE,
                RELEASED,
                TOMBSTONE.

        These states are stored in two bits of the flags byte.  The values
        of these states should therefore be in the range 0-3 in the
        enumeration below.

        Enumeration is used to facilitate debugging since enumerated values
        are shown symbolically on many debuggers

        4th state of NMSDB_E_DELETED is not stored in the database.  It is
        used to mark an in-memory copy of the record as deleted for later
        removal from the db (see DoScavenging() in nmsscv.c)
*/
typedef enum _NMSDB_ENTRY_STATE_E {
        NMSDB_E_ACTIVE    = 0,
        NMSDB_E_RELEASED  = 1,
        NMSDB_E_TOMBSTONE = 2,
        NMSDB_E_DELETED   = 3
        } NMSDB_ENTRY_STATE_E, *PNMSDB_ENTRY_STATE_E;


/*
 typedef definitions
*/

/*
  NMSDB_TABLE_ID_T -- This is visible to DBM's clients making them
                      oblivious of the database engine's structure name
*/

typedef  JET_TABLEID        NMSDB_TABLE_ID_T, *PNMSDB_TABLE_ID_T;

/*
 NMSDB_GRP_MEM_ENTRY -- entry for a special group member in the database
*/
typedef struct _NMSDB_GRP_MEM_ENTRY_T {
                DWORD                  OwnerId;
                DWORD_PTR              TimeStamp;
                COMM_ADD_T         Add;
                } NMSDB_GRP_MEM_ENTRY_T, *PNMSDB_GRP_MEM_ENTRY_T;

/*
 Structure to store addres(es) of a conlficting record
*/
typedef struct _NMSDB_NODE_ADDS_T {
        DWORD                   NoOfMems;              /*no. of addresses*/
        NMSDB_GRP_MEM_ENTRY_T   Mem[NMSDB_MAX_MEMS_IN_GRP];   /*addresses */
        } NMSDB_NODE_ADDS_T, *PNMSDB_NODE_ADDS_T;


/*
 NMSDB_ROW_INFO_T -- Contains fields that go into a row of the Name -address
                   mapping table
*/
typedef struct _NMSDB_ROW_INFO_T {
        BYTE                 Name[NMSDB_MAX_NAM_LEN];    //name to reg or query
                                                         //or release. For
                                                         //browsers, it has
                                                          //the net add appended
                                                         //to it
        LPBYTE               pName;
        DWORD                NameLen;
        PCOMM_ADD_T          pNodeAdd;      // Address of Node
        DWORD_PTR            TimeStamp;     // Time since Jan 1, 1970
        NMSDB_NODE_ADDS_T    NodeAdds;      // addresses (spec. group)
        VERS_NO_T            VersNo;        // Version No.
        DWORD                StatCode;      // Status
        NMSDB_ENTRY_STATE_E  EntryState_e;  // State of entry
        DWORD                OwnerId;       // Owner of the record
        BYTE                 NodeTyp;       // Type of Node (B, M  or P)
        BYTE                 EntTyp;        // Group or Unique flag
        BOOL                 fUpdVersNo;    // Update version number
        BOOL                 fUpdTimeStamp; // Update Time Stamp  ?
                                            // field has IP Address appended
        BOOL                 fStatic;       // indicates whether the record
                                            // is static (statically intialized)
        BOOL                 fAdmin;        //administrative action (used only)
                                            //for releases
        BOOL                 fLocal;        //Is it a local name
//        DWORD                CommitGrBit;    //kind of log flush
        } NMSDB_ROW_INFO_T, *PNMSDB_ROW_INFO_T;

/*
  NMSDB_STAT_INFO_T -- Contains the status of a NmsDb call.  If an error
      occurred, it also contains information pertaining to the error status.
      Currently, the  error status is NMDB_CONFLICI and information returned is
      unique/group status  and  IP address(es)  of the conflicting record in
      the  database.
*/
typedef NMSDB_ROW_INFO_T        NMSDB_STAT_INFO_T, *PNMSDB_STAT_INFO_T;

//////////////////////////////////////////////////////////////////////

#if DYNLOADJET

typedef JET_ERR (FAR JET_API *JETPROC)();
typedef struct _NMSDB_JETFTBL_T {
         BYTE   Index;  //index into array
         LPCSTR pFName; //function name for jet 500
         DWORD  FIndex; //function index for jet 200
         JETPROC pFAdd;
        } NMSDB_JETFTBL_T;

#define NMSDB_SIZEOFJETFTBL  sizeof(NmsDbJetFTbl)/sizeof(NMSDB_JETFTBL_T)
typedef enum {
Init,
Term,
Term2,
SetSystemParameter,
BeginSession,
EndSession,
CreateDatabase,
AttachDatabase,
DetachDatabase,
CreateTable,
DeleteTable,
GetTableColumnInfo,
GetColumnInfo,
AddColumn,
CreateIndex,
BeginTransaction,
CommitTransaction,
Rollback,
CloseDatabase,
CloseTable,
OpenDatabase,
OpenTable,
Delete,
Update,
RetrieveColumn,
SetColumn,
PrepareUpdate,
GetCurrentIndex,
SetCurrentIndex,
Move,
MakeKey,
Seek,
Backup,
Restore
} NMDB_JETFTBL_E;


#define JetInit (*(NmsDbJetFTbl[Init].pFAdd))
#define JetTerm (*(NmsDbJetFTbl[Term].pFAdd))
#define JetTerm2 (*(NmsDbJetFTbl[Term2].pFAdd))
#define JetSetSystemParameter (*(NmsDbJetFTbl[SetSystemParameter].pFAdd))
#define JetBeginSession (*(NmsDbJetFTbl[BeginSession].pFAdd))

#define JetEndSession  (*(NmsDbJetFTbl[EndSession].pFAdd))

#define JetCreateDatabase (*(NmsDbJetFTbl[CreateDatabase].pFAdd))

#define JetAttachDatabase (*(NmsDbJetFTbl[AttachDatabase].pFAdd))

#define JetDetachDatabase (*(NmsDbJetFTbl[DetachDatabase].pFAdd))

#define JetCreateTable (*(NmsDbJetFTbl[CreateTable].pFAdd))


#define JetDeleteTable (*(NmsDbJetFTbl[DeleteTable].pFAdd))

#define JetGetTableColumnInfo (*(NmsDbJetFTbl[GetTableColumnInfo].pFAdd))

#define JetGetColumnInfo (*(NmsDbJetFTbl[GetColumnInfo].pFAdd))

#define JetAddColumn (*(NmsDbJetFTbl[AddColumn].pFAdd))


#define JetCreateIndex (*(NmsDbJetFTbl[CreateIndex].pFAdd))

#define JetBeginTransaction (*(NmsDbJetFTbl[BeginTransaction].pFAdd))

#define JetCommitTransaction (*(NmsDbJetFTbl[CommitTransaction].pFAdd))

#define JetRollback (*(NmsDbJetFTbl[Rollback].pFAdd))

#define JetCloseDatabase (*(NmsDbJetFTbl[CloseDatabase].pFAdd))

#define JetCloseTable (*(NmsDbJetFTbl[CloseTable].pFAdd))

#define JetOpenDatabase (*(NmsDbJetFTbl[OpenDatabase].pFAdd))

#define JetOpenTable (*(NmsDbJetFTbl[OpenTable].pFAdd))

#define JetDelete (*(NmsDbJetFTbl[Delete].pFAdd))

#define JetUpdate (*(NmsDbJetFTbl[Update].pFAdd))

#define JetRetrieveColumn (*(NmsDbJetFTbl[RetrieveColumn].pFAdd))

#define JetSetColumn (*(NmsDbJetFTbl[SetColumn].pFAdd))

#define JetPrepareUpdate (*(NmsDbJetFTbl[PrepareUpdate].pFAdd))

#define JetGetCurrentIndex (*(NmsDbJetFTbl[GetCurrentIndex].pFAdd))

#define JetSetCurrentIndex (*(NmsDbJetFTbl[SetCurrentIndex].pFAdd))

#define JetMove (*(NmsDbJetFTbl[Move].pFAdd))

#define JetMakeKey (*(NmsDbJetFTbl[MakeKey].pFAdd))

#define JetSeek (*(NmsDbJetFTbl[Seek].pFAdd))

#define JetRestore (*(NmsDbJetFTbl[Restore].pFAdd))

#define JetBackup (*(NmsDbJetFTbl[Backup].pFAdd))
#endif

//////////////////////////////////////////////////////////////////////
/*
 function definitions
*/
extern
STATUS
NmsDbInit(
        VOID
        );

extern
STATUS
NmsDbInsertRowInd(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
STATUS
NmsDbInsertRowGrp(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
STATUS
NmsDbRelRow(
        IN  PNMSDB_ROW_INFO_T        pNmsDbRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);

extern
STATUS
NmsDbQueryRow(
        IN  PNMSDB_ROW_INFO_T        pNmsDbRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
STATUS
NmsDbUpdateRow(
        IN  PNMSDB_ROW_INFO_T        pNmsDbRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


STATUS
NmsDbSeekNUpdateRow(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
VOID
NmsDbThdInit(
         IN         WINS_CLIENT_E        Client_e
        );


STATUS
NmsDbEndSession (
        VOID
        );

extern
VOID
NmsDbRelRes(
        VOID
        );



extern
STATUS
NmsDbGetDataRecs(
        IN  WINS_CLIENT_E   Client_e,
        IN  OPTIONAL INT    ThdPrLvl,
        IN  VERS_NO_T            MinVersNo,
        IN  VERS_NO_T            MaxVersNo,
        IN  DWORD            MaxNoOfRecsReqd,
        IN  BOOL            fUpToLimit,
        IN  BOOL            fOnlyReplicaTomb,
        IN  PNMSSCV_CLUT_T  pClutter,
        IN  PCOMM_ADD_T            pWinsAdd,
        IN  BOOL            fOnlyDynRecs,
    IN  DWORD           RplType,
        OUT LPVOID                *ppRspBuf,
        OUT LPDWORD            pRspBufLen,
        OUT LPDWORD            pNoOfRecs
);


extern
STATUS
NmsDbWriteOwnAddTbl (
        IN  NMSDB_TBL_ACTION_E   TblAct_e,
        IN  DWORD                OwnerId,
        IN  PCOMM_ADD_T          pWinsAdd,
        IN  NMSDB_WINS_STATE_E   WinsState_e,
        IN  PVERS_NO_T           pStartVersNo,
        IN  PWINS_UID_T          pUid
        );


extern
STATUS
NmsDbUpdateVersNo (
        IN  BOOL                fAfterClash,
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        IN  PNMSDB_STAT_INFO_T  pStatusInfo
       );

extern
STATUS
NmsDbSetCurrentIndex(
        IN  NMSDB_TBL_NAM_E        TblNm_e,
        IN  LPBYTE                pIndexNam
        );

extern
STATUS
NmsDbQueryNUpdIfMatch(
        IN  LPVOID        pRecord,
        IN  int                ThdPrLvl,
        IN  BOOL        fChgPrLvl,
        IN  WINS_CLIENT_E Client_e
        );
extern
STATUS
NmsDbUpdHighestVersNoRec(
        IN PWINSTHD_TLS_T        pTls,
        IN VERS_NO_T                MyMaxVersNo,
        IN BOOL                        fEnterCrtSec
        );


extern
STATUS
NmsDbDelDataRecs(
#if 0
        PCOMM_ADD_T        pWinsAdd,
#endif
        DWORD                dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo,
        BOOL                fEnterCrtSec,
    BOOL        fFragmentedDel
        );

extern
STATUS
NmsDbTombstoneDataRecs(
        DWORD            dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo
        );


extern
STATUS
NmsDbSetFlushTime(
        DWORD WaitTime
        );

extern
STATUS
NmsDbOpenTables(
        WINS_CLIENT_E        Client_e
        );

extern
STATUS
NmsDbCloseTables(
        VOID
        );


extern
STATUS
NmsDbGetNamesWPrefixChar(
        BYTE                         PrefixChar,
        PWINSINTF_BROWSER_INFO_T *ppInfo,
        LPDWORD                         pEntriesRead
        );


extern
STATUS
NmsDbCleanupOwnAddTbl(
        LPDWORD pNoOfOwners
        );


extern
STATUS
NmsDbBackup(
    LPBYTE  pBackupPath,
    DWORD   TypeOfBackup
    );

extern
STATUS
NmsDbGetDataRecsByName(
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           Location,
  DWORD           NoOfRecsDesired,
  PCOMM_ADD_T     pWinsAdd,
  DWORD           TypeOfRecs,
  LPVOID          *ppBuff,
  LPDWORD         pBuffLen,
  LPDWORD         pNoOfRecsRet
 );

extern
STATUS
NmsDbEndTransaction(
  VOID
 );

#ifdef __cplusplus
}
#endif
#endif //_NMSDB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nmsnmh.h ===
#ifndef _NMSNMH_
#define _NMSNMH_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	nmsnmh.h
	

Abstract:





Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "nmsdb.h"
#include "comm.h"
#include "nmsmsgf.h"
#include "nms.h"

/*
  defines
*/

extern BOOL  NmsNmhRegThdExists;

/*
  macros
*/


#define NMSNMH_VERS_NO_EQ_ZERO_M(VersNo) ((VersNo).QuadPart == 0)

#define NMSNMH_INC_VERS_NO_M(VersNoToInc, TgtVersNo)	{		\
			(TgtVersNo).QuadPart = LiAdd((VersNoToInc), NmsNmhIncNo);	\
					}
#define NMSNMH_DEC_VERS_NO_M(VersNoToDec, TgtVersNo)	{		\
			(TgtVersNo).QuadPart = LiSub((VersNoToDec), NmsNmhIncNo);	\
					}
				
#define NMSNMH_INC_VERS_COUNTER_M2(VersNoToInc, TgtVersNo) {  \
        if (LiGtr((VersNoToInc), NmsHighWaterMarkVersNo))         \
        {                                                       \
                DWORD ThdId;\
                HANDLE ThdHdl;\
              if(!WinsCnfRegUpdThdExists) { \
                WinsCnfRegUpdThdExists = TRUE; \
                ThdHdl = WinsMscCreateThd(WinsCnfWriteReg, NULL, &ThdId);    \
                CloseHandle(ThdHdl);                           \
                } \
        }                                                       \
        NMSNMH_INC_VERS_NO_M((VersNoToInc), (TgtVersNo));           \
    }

#define NMSNMH_INC_VERS_COUNTER_M(VersNoToInc, TgtVersNo)      \
                NMSNMH_INC_VERS_COUNTER_M2(VersNoToInc, TgtVersNo)

#ifdef WINSDBG
#if 0
#define NMSNMH_UPD_UPD_CTRS_M(pRowInfo)      {     \
      IF_DBG(UPD_CNTRS)                   \
      {                                   \
        PWINSTHD_TLS_T       _pTls;  \
        _pTls = TlsGetValue(WinsTlsIndex);     /*GET_TLS_M(_pTls); */\
        switch(_pTls->Client_e)    \
        {                         \
             case(WINS_E_RPLPULL): NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsRplUpd++ : NmsRplGUpd++; break; \
             case(WINS_E_NMSNMH):   NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsNmhUpd++ : NmsNmhGUpd++; break; \
             case(WINS_E_NMSCHL):   NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsChlUpd++ : NmsChlGUpd++; break;\
             case(WINS_E_NMSSCV):   NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsScvUpd++ : NmsScvGUpd++; break; \
             case(WINS_E_WINSRPC):  NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsRpcUpd++ : NmsRpcGUpd++; break; \
             default:               NMSDB_ENTRY_UNIQUE_M(pRowInfo->EntTyp) ? NmsOthUpd++ : NmsOthGUpd++; break; \
        } \
       } \
      }
#endif
#define NMSNMH_UPD_UPD_CTRS_M(fIndexUpd, fUpd, pRowInfo)      {     \
      IF_DBG(UPD_CNTRS)                   \
      {                                   \
        PWINSTHD_TLS_T       _pTls;  \
        _pTls = TlsGetValue(WinsTlsIndex);     /*GET_TLS_M(_pTls); */\
        NmsUpdCtrs[_pTls->Client_e][fUpd][pRowInfo->EntTyp][pRowInfo->EntryState_e][fIndexUpd]++; \
      } \
    }
#else
#define NMSNMH_UPD_UPD_CTRS_M(fIndexUpd, fUpd, pRowInfo)
#endif


				
					

/*
 externs
*/
/*
	NmsNmhMyMaxVersNo -- Stores highest version no. for
			   entries owned by the local WINS
			   in its local db
*/
extern	VERS_NO_T	NmsNmhMyMaxVersNo;
extern  VERS_NO_T	NmsNmhIncNo;

/*
	NmsNmhNamRegCrtSect -- Variable for the critical section entered
	when name registrations or refreshes need to be done
*/
extern CRITICAL_SECTION	NmsNmhNamRegCrtSec;


/*
 typedef  definitions
*/

/*
  NMSNMH_QUERY_RSP_T -- this contains the addresses found in a
	group entry. -- not being used currently
*/
typedef struct _NMSNMH_QUERY_RSP_T {
	BOOL	 fGrp;				 //is it rsp. for a group
	WORD	 NoOfAdd;   			 //no of addresses in the group
	COMM_ADD_T NodeAdd[NMSDB_MAX_MEMS_IN_GRP];  //addresses
	} NMSNMH_QUERY_RSP_T, *PNMSNMH_QUERY_RSP_T;

/*
 function prototypes
*/

extern
STATUS
NmsNmhNamRegInd(
	IN PCOMM_HDL_T		pDlgHdl,
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN PCOMM_ADD_T		pNodeAdd,
	IN BYTE	        	NodeTyp, //change to take Flag byte
	IN MSG_T		pMsg,
	IN MSG_LEN_T		MsgLen,
	IN DWORD		QuesNamSecLen,
	IN BOOL			fRefresh,
	IN BOOL			fStatic,
	IN BOOL			fAdmin
	);

extern
STATUS
NmsNmhNamRegGrp(
	IN PCOMM_HDL_T		pDlgHdl,
	IN PBYTE		pName,
	IN DWORD		NameLen,
	IN PNMSMSGF_CNT_ADD_T	pCntAdd,
	IN BYTE			NodeTyp,
	IN MSG_T		pMsg,
	IN MSG_LEN_T		MsgLen,
	IN DWORD		QuesNamSecLen,
	IN DWORD		TypeOfRec,
	IN BOOL			fRefresh,
	IN BOOL			fStatic,
	IN BOOL			fAdmin
	);

extern
STATUS
NmsNmhNamRel(
	IN PCOMM_HDL_T		pDlgHdl,
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN PCOMM_ADD_T		pNodeAdd,
	IN BOOL			fGrp,
	IN MSG_T		pMsg,
	IN MSG_LEN_T		MsgLen,
	IN DWORD		QuesNamSecLen,
	IN BOOL			fAdmin
	);

extern
STATUS
NmsNmhNamQuery(
	IN PCOMM_HDL_T		pDlgHdl,  //dlg handle
	IN LPBYTE		pName,	  //Name to release
	IN DWORD		NameLen, //length of name to release
	IN MSG_T		pMsg,	  //message received
	IN MSG_LEN_T		MsgLen,	  //length of message
	IN DWORD		QuesNamSecLen, //length of ques. name sec in msg
	IN BOOL			fAdmin,
        OUT PNMSDB_STAT_INFO_T  pStatInfo
	);


extern
VOID
NmsNmhSndNamRegRsp(
	PCOMM_HDL_T            pDlgHdl,
	PNMSMSGF_RSP_INFO_T    pRspInfo
	);



extern
STATUS
NmsNmhReplRegInd(
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN PCOMM_ADD_T          pNodeAdd,
	IN DWORD	       	Flag, //change to take Flag byte
	IN DWORD			OwnerId,
	IN VERS_NO_T 		VersNo,
	IN PCOMM_ADD_T		pOwnerWinsAdd
	);

extern
STATUS
NmsNmhReplGrpMems(
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN BYTE			EntTyp,
	IN PNMSDB_NODE_ADDS_T	pGrpMem,
	IN DWORD        	Flag, 		//change to take Flag byte
	IN DWORD		OwnerId,
	IN VERS_NO_T 		VersNo,
	IN PCOMM_ADD_T		pOwnerWinsAdd
	);
	

extern
VOID
NmsNmhUpdVersNo(
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	//IN BYTE			NodeTyp,
	//IN BOOL			fBrowserName,
	//IN BOOL			fStatic,
	//IN PCOMM_ADD_T		pNodeAdd,
	OUT LPBYTE		pRcode,
        IN  PCOMM_ADD_T		pWinsAdd
	);
	
#ifdef __cplusplus
}
#endif
#endif //_NMSNMH_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\rpl.h ===
#ifndef _RPL_
#define _RPL_
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:



Abstract:





Functions:



Portability:


        This header is portable.

Author:

        Pradeep Bahl        (PradeepB)        Jan-1993



Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "comm.h"
#include "nmsdb.h"
#include "winsque.h"

/*
  defines
*/
/*
  RPL_OPCODE_SIZE -- size of opcode in message sent between two replicators.
        This define is used by rplmsgf
*/
#define RPL_OPCODE_SIZE                4        //sizeof the Opcode in an RPL message


/*
 The maximum numbers of RQ WINS on a network.
*/
#define RPL_MAX_OWNERS_INITIALLY                NMSDB_MAX_OWNERS_INITIALLY


/*
  RPL_MAX_GRP_MEMBERS --
  Maximum members allowed in a group
*/
#define RPL_MAX_GRP_MEMBERS                 25


//
// We don't send more than 5000 records at a time.  Note: This value is
// used to define MAX_BYTES_IN_MSG in comm.c
//
// By not having a very bug number we have a better chance for being serviced
// within our timeout period for a request.  This is because of queuing that
// results when there are a lot of replication requests
//
//
#define RPL_MAX_LIMIT_FOR_RPL           5000

/*
 This define is used by ReadPartnerInfo and by RplPull functions.  The size
 is made a multiple of  8.  I could have used sizeof(LARGE_INTEGER) instead of
 8 but I am not sure whether that will remain a multiple of 8 in the future.

 The size is made a multiple of 8 to avoid alignment exceptions on MIPS (
 check out ReadPartnerInfo in winscnf.c or GetReplicas in rplpull.c for
 more details)
*/

#define  RPL_CONFIG_REC_SIZE        (sizeof(RPL_CONFIG_REC_T) + \
                                   (8 - sizeof(RPL_CONFIG_REC_T)%8))
//
// check out GetDataRecs in nmsdb.c
//
#define  RPL_REC_ENTRY_SIZE        (sizeof(RPL_REC_ENTRY_T) + \
                                   (8 - sizeof(RPL_REC_ENTRY_T)%8))

//
// check out GetDataRecs in nmsdb.c
//
#define  RPL_REC_ENTRY2_SIZE        (sizeof(RPL_REC_ENTRY2_T) + \
                                   (8 - sizeof(RPL_REC_ENTRY2_T)%8))

//
// The following define is used to initialize the TimeInterval/UpdateCount
// field of a RPL_REC_ENTRY_T structure to indicate that it is invalid
//
#define RPL_INVALID_METRIC        -1


//
// defines to indicate whether the trigger needs to be propagated to all WINS
// in the PUSH chain
//
#define RPL_PUSH_PROP                TRUE        //must remain TRUE since in
                                        //NmsNmhNamRegInd, at one place
                                        //we use fAddDiff value in place of
                                        //this symbol. fAddDiff when TRUE
                                        //indicates that the address has
                                        //changed, thus initiating propagation
#define RPL_PUSH_NO_PROP        FALSE



/*
  macros
*/

//
// Macro called in an NBT thread after it increments the version number
// counter.  This macro is supposed to be called from within the
// NmsNmhNamRegCrtSec.
//
#define RPL_PUSH_NTF_M(fAddDiff, pCtx, pNoPushWins1, pNoPushWins2) {                \
                             if ((WinsCnf.PushInfo.NoPushRecsWValUpdCnt \
                                                              != 0) ||  \
                                        fAddDiff)                        \
                             {                                                \
                                ERplPushProc(fAddDiff, pCtx, pNoPushWins1,    \
                                                pNoPushWins2);          \
                             }                                                \
               }

/*
        FIND_ADD_BY_OWNER_ID_M - This macro is called by the PUSH thread
        when sending data records to its Pull Partner.  It calls this function
        to determine the Address of the WINS owning the database record

        The caller of this macro, if not executing in the PULL thread, must
        synchronize using NmsDbOwnAddTblCrtSec (Only PULL thread updates
        the NmsDbOwnAddTbl array during steady state).

        I am not putting the critical section entry and exit inside this
        macro for performance reasons (refer StoreGrpMems in nmsdb.c where
        this macro may be called many times -once for each member of a
        special group).  Also refer RplMsgfFrmAddVersMapRsp()  and
        WinsRecordAction (in winsintf.c)
*/

#define   RPL_FIND_ADD_BY_OWNER_ID_M(OwnerId, pWinsAdd, pWinsState_e, pStartVersNo)                                                                          \
                {                                                        \
                        PNMSDB_ADD_STATE_T pWinsRec;                     \
                        if (OwnerId < NmsDbTotNoOfSlots)                 \
                        {                                                \
                            pWinsRec       = pNmsDbOwnAddTbl+OwnerId;    \
                            (pWinsAdd)     = &(pWinsRec->WinsAdd);       \
                            (pWinsState_e) = &pWinsRec->WinsState_e;     \
                            (pStartVersNo) = &pWinsRec->StartVersNo;     \
                        }                                                \
                        else                                             \
                        {                                                \
                            (pWinsAdd)     = NULL;                       \
                            (pWinsState_e) = NULL;                       \
                            (pStartVersNo) = NULL;                       \
                        }                                                \
                }


//
//  Names of event variables signaled when Pull and/or Push configuration
//  changes
//
#define  RPL_PULL_CNF_EVT_NM                TEXT("RplPullCnfEvt")
#define  RPL_PUSH_CNF_EVT_NM                TEXT("RplPushCnfEvt")
/*
 externs
*/


/*
  Handle of heap used for allocating/deallocating work items for the RPL
  queues
*/

extern  HANDLE                RplWrkItmHeapHdl;
#if 0
extern  HANDLE                RplRecHeapHdl;
#endif

/*
  OwnerIdAddressTbl

  This table stores the Addresses corresponding to different WINS servers.

  In the local database, the local WINS's owner id is always 0.  The owner ids
  of other WINS servers are 1, 2, 3 ....  The owner ids form a sequential list,
  without any gap.  This is because, the first time the database is created
  at a WINS, it assigns sequential numbers to the other WINS.


  Note: The table is static for now.  We might change it to be a dynamic one
        later.

*/



/*
 PushPnrVersNoTbl

  This table stores the Max. version number pertaining to each WINS server
  owning entries in the database of Push Partners

  Note: The table is static for now.  We might change it to be a dynamic one
        later.
*/

#if 0
extern VERS_NO_T   pPushPnrVersNoTbl;
#endif

/*
 OwnerVersNo -- this array stores the maximum version number for each
         owner in the local database

        This is used by HandleAddVersMapReq() in RplPush.c

*/
extern VERS_NO_T   pRplOwnerVersNo;


extern HANDLE                RplSyncWTcpThdEvtHdl; //Sync up with the TCP thread

//
// critical section to guard the RplPullOwnerVersNo array
//
extern CRITICAL_SECTION  RplVersNoStoreCrtSec;

/*
 typedef  definitions
*/

/*
        The different types of records that can be read from the registry
*/
typedef enum _RPL_RR_TYPE_E {
        RPL_E_PULL = 0,   // pull record
        RPL_E_PUSH,          //push record
        RPL_E_QUERY          //query record
        } RPL_RR_TYPE_E, *PRPL_RR_TYPE_E;

typedef struct _RPL_VERS_NOS_T {
        VERS_NO_T                VersNo;
        VERS_NO_T                StartVersNo;
        } RPL_VERS_NOS_T, *PRPL_VERS_NOS_T;

/*
  RPL_CONFIG_REC_T -- Configuration record for the WINS replicator.  It
                specifies the Pull/Push/Query partner and associated
                parameters


  NOTE NOTE NOTE:  Keep the datatype of UpdateCount and TimeInterval the same
  (see LnkWSameMetricRecs)
*/
typedef  struct _RPL_CONFIG_REC_T {
    DWORD       MagicNo;    //Same as that in WinsCnf
        COMM_ADD_T        WinsAdd;        /*address of partner        */
        LPVOID                pWinsCnf;        //back pointer to the old WINS struct
        LONG                TimeInterval;   /*time interval in secs for pulling or
                                         * pushing        */
        BOOL                fSpTime;        //indicates whether pull/push
                                        //replication should be done at
                                        // a specific time
        LONG                SpTimeIntvl;        //Number of secs to specific time
        LONG                UpdateCount;        /*Count of updates after which
                                         *notification will be sent (applies
                                         *only to Push RR types*/
        DWORD                RetryCount;        //No of retries done
        DWORD                RetryAfterThisManyRpl; //Retry after this many rpl
                                               //time intervals have elapsed
                                               //from the time we stopped
                                               //replicating due to RetryCount
                                               //hitting the limit
        time_t                LastCommFailTime;   //time of last comm. failure
        time_t                LastRplTime;        //time of last replication
#if PRSCONN
        time_t                LastCommTime;   //time of last comm. 
#endif
        DWORD                PushNtfTries;       //No of tries for establishing
                                            //comm. in the past few minutes
        //
        // The two counters below have to 32 bit aligned otherwise
        // the Interlock instructions will fail on x86 MP machines
        //
        DWORD                NoOfRpls;           //no of times replication
                                           //happened with this partner
        DWORD                NoOfCommFails;           //no of times replication
                                           //failed due to comm failure
        DWORD                MemberPrec;        //precedence of members of special grp
                                        //relative to other WINS servers

        struct _RPL_CONFIG_REC_T        *pNext; //ptr to next rec. with same
                                                //time interval (in case of
                                                //of PULL record) or update
                                                //count (in case of PUSH record)
        VERS_NO_T        LastVersNo;     //Only valid for Push records.
                                        //Indicates what the value of the
                                        //local version number counter at the
                                        //time a push notification is sent
        DWORD           RplType;       //type of replication with this guy
        BOOL                fTemp;                //Indicates whether it is a temp
                                        //record that should be deallocated
                                        //after use.
        BOOL                fLinked;        //indicates whether the record is
                                        //is linked to a record before it in
                                        //the buffer of records of the same type                                        //as this record
        BOOL            fOnlyDynRecs; //indicates whether only dynamic
                                          //records should be pulled/pushed
        RPL_RR_TYPE_E    RRTyp_e;        /*Type of record PULL/PUSH/QUERY*/
#if MCAST > 0
    BOOL         fSelfFnd;    //indicates whether this record was self found
#endif
#if PRSCONN
        BOOL           fPrsConn;
        COMM_HDL_T     PrsDlgHdl;
#endif

        
        } RPL_CONFIG_REC_T, *PRPL_CONFIG_REC_T;




/*
 RPL_ADD_VERS_NO_T - stores the highest version No. pertaining to an owner
                 in the directory.

                 Used by GetVersNo and RplMsgUfrmAddVersMapRsp
*/
typedef struct _RPL_ADD_VERS_NO_T {
        COMM_ADD_T                OwnerWinsAdd;
        VERS_NO_T                 VersNo;
        VERS_NO_T                 StartVersNo;
        } RPL_ADD_VERS_NO_T, *PRPL_ADD_VERS_NO_T;

/*

 RPL_PUSHPNR_VERS_NO_T -- stores the Push Pnr Id, the id. of the owner whose
                         records  should be pulled, and the max version
                         number  of these records


        This structure is initializes at replication time.  The PULL thread
        looks at this structure and sends requests to its Push partners to
        pull records.

        This structure is used by functions in the rplpull.c and rplmsgf.c
        modules.

*/
typedef struct _RPL_PUSHPNR_VERS_NO_T {
        DWORD                PushPnrId;
        DWORD           OwnerId;
        VERS_NO_T        MaxVersNo;
        } RPL_PUSHPNR_VERS_NO_T, *PRPL_PUSHPNR_VERS_NO_T;


FUTURES("Use NmsDbRowInfo struture")
/*
  RPL_REC_ENTRY_T -- structure that holds a record in the range
                Min version no - Max version no for an owner WINS

                Used by RplPushHandleSndEntriesReq
  Size of this structure is 68 bytes
*/
typedef struct _RPL_REC_ENTRY_T {
        DWORD           NameLen;
        DWORD           NoOfAdds;
        union {
          PCOMM_ADD_T pNodeAdd;
          COMM_ADD_T  NodeAdd[2];
        };
        VERS_NO_T  VersNo;
        DWORD           TimeStamp;          //used only when doing scavenging
        DWORD           NewTimeStamp;          //used only when doing scavenging
        BOOL           fScv;        //used only when doing scavenging
        BOOL           fGrp;
        LPBYTE     pName;
        DWORD           Flag;
        } RPL_REC_ENTRY_T, *PRPL_REC_ENTRY_T;

// this struct is same as above plus has the ownerid.
// winsgetdatarecsbyname routine needs to know the ownerid of each
// record and so this new structure is created.
typedef struct _RPL_REC_ENTRY2_T {
        DWORD           NameLen;
        DWORD           NoOfAdds;
        union {
          PCOMM_ADD_T pNodeAdd;
          COMM_ADD_T  NodeAdd[2];
        };
        VERS_NO_T  VersNo;
        DWORD           TimeStamp;          //used only when doing scavenging
        DWORD           NewTimeStamp;          //used only when doing scavenging
        BOOL           fScv;        //used only when doing scavenging
        BOOL           fGrp;
        LPBYTE     pName;
        DWORD           Flag;
        DWORD       OwnerId;
        } RPL_REC_ENTRY2_T, *PRPL_REC_ENTRY2_T;

//
// Argument to GetReplicas, EstablishComm (both in rplpull.c), and
// WinsCnfGetNextCnfRec to  indicate to it how it should traverse
// the buffer of Configuration records
//
typedef enum _RPL_REC_TRAVERSAL_E {
                RPL_E_VIA_LINK = 0,
                RPL_E_IN_SEQ,
                RPL_E_NO_TRAVERSAL
                } RPL_REC_TRAVERSAL_E, *PRPL_REC_TRAVERSAL_E;



/*
 function declarations
*/

extern
STATUS
ERplInit(
        VOID
);

extern
STATUS
ERplInsertQue(
        WINS_CLIENT_E        Client_e,
        QUE_CMD_TYP_E   CmdTyp_e,
        PCOMM_HDL_T        pDlgHdl,
        MSG_T                pMsg,
        MSG_LEN_T        MsgLen,
        LPVOID                pClientCtx,
    DWORD       MagicNo
        );

extern
STATUS
RplFindOwnerId (
        IN  PCOMM_ADD_T                        pWinsAdd,
        IN  OUT LPBOOL                        pfAllocNew,
        OUT DWORD UNALIGNED         *pOwnerId,
        IN  DWORD                            InitpAction_e,
        IN  DWORD                            MemberPrec
        );

extern
VOID
ERplPushProc(
        BOOL                fAddDiff,
    LPVOID      pCtx,
        PCOMM_ADD_T     pNoPushWins1,
        PCOMM_ADD_T     pNoPushWins2
        );


extern
PRPL_CONFIG_REC_T
RplGetConfigRec(
    RPL_RR_TYPE_E   TypeOfRec_e,
    PCOMM_HDL_T     pDlgHdl,
    PCOMM_ADD_T     pAdd
    );

#if 0
extern
VOID
ERplPushCompl(
        PCOMM_ADD_T     pNoPushWins
        );
#endif

#endif //_RPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nmsscv.h ===
#ifndef _NMSSCV_
#define _NMSSCV_

#ifdef __cplusplus
extern "C" {
#endif

/*++
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	nmsscv.h
	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include <time.h>
#include "wins.h"
//#include "winscnf.h"
/*
  defines
*/


/*
  macros
*/

/*
 externs
*/

//
// The min. version number to start scavenging from (for local records)
//
extern VERS_NO_T  	NmsScvMinScvVersNo;

extern HANDLE	NmsScvDoScvEvtHdl;//event signaled to initiate scavenging
volatile extern BOOL	    fNmsScvThdOutOfReck;//To indicate that the scav. thd has
                                   //db session but is not in the count
                                   //of thds to wait for.

/* 
 typedef  definitions
*/
typedef struct _NMSSCV_CC_T {
               DWORD TimeInt;
               BOOL  fSpTime;
               DWORD SpTimeInt;
               DWORD MaxRecsAAT;
               BOOL  fUseRplPnrs;
} NMSSCV_CC_T, *PNMSSCV_CC_T;

typedef struct _NMSSCV_PARAM_T {
	DWORD  RefreshInterval;
	DWORD  TombstoneInterval;
	DWORD  TombstoneTimeout;
	DWORD  VerifyInterval;
    NMSSCV_CC_T  CC;
	LONG   PrLvl;
	DWORD  ScvChunk;
        CHAR   BackupDirPath[WINS_MAX_FILENAME_SZ];
	} NMSSCV_PARAM_T, *PNMSSCV_PARAM_T;

//
// Used to pass information to NmsDbGetDataRecs
//
typedef struct _NMSSCV_CLUT_T {
	DWORD	Interval;
	time_t  CurrentTime;
	DWORD   OwnerId;
    DWORD   Age;
    BOOL    fAll;
	} NMSSCV_CLUT_T, *PNMSSCV_CLUT_T;	

//
// Used by ChkConfNUpd() to determine whether a record pulled during 
// verification/consistency check should be inserted into the db
//
typedef enum _NMSSCV_REC_ACTION_E {
          NMSSCV_E_INSERT,
          NMSSCV_E_DONT_INSERT
       } NMSSCV_REC_ACTION_E, *PNMSSCV_REC_ACTION_E;
/* 
 function declarations
*/
extern 
VOID
NmsScvInit(
	VOID
	);
#ifdef __cplusplus
}
#endif
#endif //_NMSSCV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\nmsmsgf.h ===
#ifndef _NMSMSGF_
#define _NMSMSGF_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	nmsmsgf.h

	

Abstract:


	This is the header file to be used for calling nmsmsgf.c functions


Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "comm.h"
#include "assoc.h"
#include "nmsdb.h"

/*
  defines
*/

//
// Max. length of name in an RFC packet
//
#define  NMSMSGF_RFC_MAX_NAM_LEN	NMSDB_MAX_NAM_LEN

/*
  macros
*/

//
// Inserts an IP address in an RFC pkt
//
#define NMSMSGF_INSERT_IPADD_M(pTmpB, IPAdd)				   \
			{						   \
				*(pTmpB)++ = (BYTE)((IPAdd) >> 24);	   \
				*(pTmpB)++ = (BYTE)(((IPAdd) >> 16) % 256);\
				*(pTmpB)++ = (BYTE)(((IPAdd) >> 8) % 256); \
				*(pTmpB)++ = (BYTE)((IPAdd) % 256);	   \
			}	

//
// Currently IP addresses are same length as ULONG. When that changes
// change this macro
//
FUTURES("Change when sizeof(COMM_IP_ADD_T) != sizeof(ULONG)")
#define NMSMSGF_INSERT_ULONG_M(pTmpB, x)    NMSMSGF_INSERT_IPADD_M(pTmpB, x)
//
// Retrieves an IP address from an RFC pkt
//
#define NMSMSGF_RETRIEVE_IPADD_M(pTmpB, IPAdd)				\
			{						\
				(IPAdd)  = *(pTmpB)++ << 24;		\
				(IPAdd) |= *(pTmpB)++ << 16;		\
				(IPAdd) |= *(pTmpB)++ << 8;		\
				(IPAdd) |= *(pTmpB)++;			\
			}	

//
// Currently IP addresses are same length as ULONG. When that changes
// change this macro
//
FUTURES("Change when sizeof(COMM_IP_ADD_T) != sizeof(ULONG)")
#define NMSMSGF_RETRIEVE_ULONG_M(pTmpB, x)    NMSMSGF_RETRIEVE_IPADD_M(pTmpB, x)

//
// Max number of multihomed addresses
//
#define NMSMSGF_MAX_NO_MULTIH_ADDS		NMSDB_MAX_MEMS_IN_GRP	

//
// Used for swapping bytes (to support the browser)
//
#define NMSMSGF_MODIFY_NAME_IF_REQD_M(pName)			\
		{						\
			if (*((pName) + 15) == 0x1B)		\
			{					\
				WINS_SWAP_BYTES_M((pName), (pName) + 15);\
			}						\
		}
		
/*
 externs
*/

/*
 typedef  definitions
*/
/*
 NMSMSGF_ERR_CODE_E - The various Rcode values returned in responses to
	the various name requests received.

	Note:  CFT_ERR is never returned in a negative name release response.
	ACT_ERR code in a negative name release response means that the
	WINS server will not allow a node to release the name owned by another
	node.o
*/

typedef enum _NMSMSGF_ERR_CODE_E {
	NMSMSGF_E_SUCCESS  = 0,    //Success
	NMSMSGF_E_FMT_ERR  = 1,   //Format error. Req. was invalidly formatted
	NMSMSGF_E_SRV_ERR  = 2,   //Server failure. Problem with WINS. Can not
				  //service name
CHECK("Check this one out.  Would WINS ever return this ?")
	NMSMSGF_E_NAM_ERR  = 3,   //Name does not exist in the directory
	NMSMSGF_E_IMP_ERR  = 4,   //Unsupported req. error. Allowable only for
				  //challenging NBNS when gets an Update type
				  //registration request
	NMSMSGF_E_RFS_ERR  = 5,   //Refused error. For policy reasons WINS
				  //will not register this namei from this host
	NMSMSGF_E_ACT_ERR  = 6,   //Active error. Name is owned by another node
	NMSMSGF_E_CFT_ERR  = 7    //Name in conflict error. A unique name is
				  //owned by more than one node
	} NMSMSGF_ERR_CODE_E, *PNMSMSGF_ERR_CODE_E;
/*
 NMSMSGF_NODE_TYP_E -- Node type of node that sent the name registration
		message
	Values assigned to the enumrators are those specified in RFC 1002

	Bnode value will be set by Proxy

	NOTE NOTE NOTE
	WINS will never get a registration from a B node since we decided
	that B node registrations will not be passed to WINS by the
	proxy.
*/

typedef enum _NMSMSGF_NODE_TYP_E {
	NMSMSGF_E_BNODE  = 0,    //RFC 1002 specified value
	NMSMSGF_E_PNODE  = 1,   // RFC 1002 specified value
	NMSMSGF_E_MODE   = 2    //RFC 1002 specified value
	} NMSMSGF_NODE_TYP_E, *PNMSMSGF_NODE_TYP_E;

//
// Information required to send a response to an NBT node
//
typedef struct _NMSMSGF_RSP_INFO_T {
	NMSMSGF_ERR_CODE_E 	Rcode_e;
	MSG_T			pMsg;
	MSG_LEN_T		MsgLen;
	PNMSDB_NODE_ADDS_T	pNodeAdds;
	DWORD			QuesNamSecLen;
	NMSMSGF_NODE_TYP_E	NodeTyp_e;
	BYTE			EntTyp;
        DWORD			RefreshInterval;
	} NMSMSGF_RSP_INFO_T, *PNMSMSGF_RSP_INFO_T;	
/*
 NMSMSGF_NAM_REQ_TYP_E
 	Type of name request that the WINS deals with
	Values assigned to the enumrators are those specified in RFC 1002

  	Used by NmsProcNbtReq and NmsNmhNamRegRsp.
*/

CHECK("RFC 1002 is inconsistent in its specification of the opcode for ")
CHECK("Name Refresh.  AT one place it specifies 8 and at another 9")
CHECK("8 seems more likely since it follows in sequeence to the value")
CHECK("for WACK")

typedef enum _NMSMSGF_NAM_REQ_TYP_E {
	NMSMSGF_E_NAM_QUERY = 0,
	NMSMSGF_E_NAM_REG   = 5,
	NMSMSGF_E_NAM_REL   = 6,
	NMSMSGF_E_NAM_WACK  = 7,
	NMSMSGF_E_NAM_REF   = 8, /*RFC 1002 specifies 8 and 9.Which one is
				 *correct (page 9 and page 15)?
				 */
	NMSMSGF_E_NAM_REF_UB  = 9, //Netbt in Daytona release will use 9 for
                               //compatibility with UB NBNS.  So, I
                               //need to support this too
	NMSMSGF_E_MULTIH_REG = 0xF, //not in RFC.  For supporting multi-homed
				    //hosts
	NMSMSGF_E_INV_REQ   = 10  // invalid name request
	} NMSMSGF_NAM_REQ_TYP_E, *PNMSMSGF_NAM_REQ_TYP_E;	

//
// Counted array of addresses.  The array size is big enough to hold the
// max. number of addresses that can be sent in a UDP packet.
//
//  We need to get all the addresses when a query response is received
// by WINS (to a challenge).  This is so that it can handle mh nodes
// with > 25 addresses.
//
// Since a UDP packet can not be > 512, assuming a name size of 16 (32 bytes
// encoded), the packet size apart from Ip address is around 60.  So the
// max. number of addresses there can be is (512-60 - 2)/4 = around 112.
//
//#define NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT  100



//
// We will never take more than 25 addresses from a packet.  Netbt will also
// never send more than 25.  Even if it does, we will stop at the 26th address
// The count is being kept at 25 so as to avoid a buffer overflow problem
// in NmsMsgfUfmNamRsp.
//
// If the max name size is used - 255 and using 60 bytes for the other contents\// of the packet, we have (512-315 -2 = 195 bytes for the ip address). This  
// will accept 195/4 = around 48 addresses.  No chance for overflow when we
// use a limit of 25.
//
#define NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT 25 
 





FUTURES("when we start supportng tcp connections. this array size may not")
FUTURES("be sufficient")
typedef struct _NMSMSGF_CNT_ADD_T {
	DWORD		NoOfAdds;
	COMM_ADD_T	Add[NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT];	
	} NMSMSGF_CNT_ADD_T, *PNMSMSGF_CNT_ADD_T;
/*
 function definitions
*/

extern
STATUS
NmsMsgfProcNbtReq(
	PCOMM_HDL_T	pDlgHdl,
        MSG_T		pMsg,
	MSG_LEN_T	MsgLen
	);
extern
STATUS
NmsMsgfFrmNamRspMsg(
   PCOMM_HDL_T			pDlgHdl,
   NMSMSGF_NAM_REQ_TYP_E   	NamRspTyp_e,
   PNMSMSGF_RSP_INFO_T		pRspInfo
  	);



extern
VOID
NmsMsgfFrmNamQueryReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen
	);

extern
VOID
NmsMsgfFrmNamRelReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	);

extern
STATUS
NmsMsgfFrmNamRegReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	);
extern
VOID
NmsMsgfFrmWACK(
  IN  LPBYTE			Buff,
  OUT LPDWORD			pBuffLen,
  IN  MSG_T	   		pMsg,
  IN  DWORD			QuesSecNamLen,
  IN  DWORD			TTL
	);




extern
STATUS
NmsMsgfUfmNamRsp(
	IN  LPBYTE		       pMsg,
	OUT PNMSMSGF_NAM_REQ_TYP_E     pOpcode_e,
	OUT LPDWORD		       pTransId,
	OUT LPBYTE		       pName,
	OUT LPDWORD 		       pNameLen,
	OUT PNMSMSGF_CNT_ADD_T	       pCntAdd,
	OUT PNMSMSGF_ERR_CODE_E	       pRcode_e,
    OUT PBOOL                      fGroup
	);

extern
VOID
NmsMsgfSndNamRsp(
  PCOMM_HDL_T pDlgHdl,
  LPBYTE      pMsg,
  DWORD       MsgLen,
  DWORD       BlockOfReq
 );

#ifdef __cplusplus
}
#endif
#endif //_NMSMSGF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\rplmsgf.h ===
#ifndef _RPLMSGF_
#define _RPLMSGF_ 
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	rplmsgf.h

	

Abstract:

 
	header file for interfacing with the rplmsgf.c module


Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/

#include "wins.h"
#include "comm.h"
#include "rpl.h"

/*
  defines
*/
/*
  Sizes for the different messages to be sent between replicators

*/

#define RPLMSGF_ADDVERSMAP_REQ_SIZE	 (sizeof(LONG) +  COMM_N_TCP_HDR_SZ)	
#define RPLMSGF_SNDENTRIES_REQ_SIZE  (COMM_N_TCP_HDR_SZ + sizeof(RPLMSGF_SENDENTRIES_REQ_T))


#define RPLMSGF_ADDVERSMAP_RSP_SIZE_M(_NoOfOwners) \
                       (COMM_N_TCP_HDR_SZ +  \
                       sizeof(RPLMSGF_ADDVERSMAP_RSP_T) + \
                       (sizeof(RPLMSGF_OWNER_MAP_INFO_T) * (_NoOfOwners)));
		

//
// RPLMSGF_UPD_VERS_NO_REQ_T includes COMM_N_TCP_HDR 
//
#define RPLMSGF_UPDVERSNO_REQ_SIZE	 sizeof(RPLMSGF_UPD_VERS_NO_REQ_T)

#define RPLMSGF_UPDVERSNO_RSP_SIZE	 (sizeof(RPLMSGF_UPD_VERS_NO_RSP_T) +  \
					  COMM_N_TCP_HDR_SZ)	

/*
  macros
*/

#define RPLMSGF_SET_OPC_M(pTmpB, Opc_e)			\
			{				\
				*(pTmpB)++ = 0;		\
				*(pTmpB)++ = 0;		\
				*(pTmpB)++ = 0;		\
				*(pTmpB)++ = (BYTE)(Opc_e);	\
			}
				
//
// Opcode is stored in the 4th byte of the message (in keeping with the
// convention of passing the MSB first).
//
#define RPLMSGF_GET_OPC_FROM_MSG_M(pBuff, Opc_e)	\
		{					\
			Opc_e = *(pBuff + 3);		\
		} 

/*
* externs
*/

/* 
* typedef  definitions
*/

//
//  Message structures
//

// 
//  Some of these structures are used just for determining the sizes of the
//  buffers used for formatting the messages corresponding to them
//

typedef struct _RPLMSGF_ADD_VERS_MAP_REQ_T {
		DWORD	Opcode;
		} RPLMSGF_ADD_VERS_MAP_REQ_T, *PRPLMSGF_ADD_VERS_MAP_REQ_T;


typedef struct _RPLMSGF_OWNER_MAP_INFO_T {
           COMM_ADD_T    Add;
           VERS_NO_T     MaxVersNo;
           VERS_NO_T     StartVersNo;
           DWORD         Uid;
           } RPLMSGF_OWNER_MAP_INFO_T, *PRPLMSGF_OWNER_MAP_INFO_T;

        
typedef struct _RPLMSGF_ADDVERSMAP_RSP_T {
           DWORD  LengthOfMsg;
           DWORD Opcode;
           DWORD NoOfOwners;
           PRPLMSGF_OWNER_MAP_INFO_T pOwnerInfo;
           DWORD  RplTimeInterval;
        } RPLMSGF_ADDVERSMAP_RSP_T, *PRPLMSGF_ADDVERSMAP_RSP_T;

typedef struct _RPLMSGF_SENDENTRIES_REQ_T {
           DWORD          LengthOfMsg;
           DWORD          Opcode;
           COMM_ADD_T     Add;
           VERS_NO_T      MaxVersNo;
           VERS_NO_T      MinVersNo;
           DWORD          TypOfRec;
           } RPLMSGF_SENDENTRIES_REQ_T, PRPLMSGF_SENDENTRIES_REQ_T; 
            
    

typedef struct _RPLMSGF_UPD_VERS_NO_REQ_T {
        COMM_TCP_HDR_T  TcpHdr; 
		DWORD  		Opcode;
		BYTE  	    Name[NMSDB_MAX_NAM_LEN];
		DWORD   	NameLen;
		} RPLMSGF_UPD_VERS_NO_REQ_T,  *PRPLMSGF_UPD_VERS_NO_REQ_T; 

typedef struct _RPLMSGF_UPD_VERS_NO_RSP_T {
		DWORD	Opcode;
		BYTE	Rcode;
		} RPLMSGF_UPD_VERS_NO_RSP_T, *PRPLMSGF_UPD_VERS_NO_RSP_T;


/*
 RPLMSGF_MSG_OPCODE_E -- lists the various opcodes used in messages sent
		     between replicators of different WINS servers.

		  These opcodes are used by the formatting and unformatting
		  functions of module rplmsgf.c 
*/

typedef enum _RPLMSGF_MSG_OPCODE_E {
	RPLMSGF_E_ADDVERSNO_MAP_REQ = 0,
	RPLMSGF_E_ADDVERSNO_MAP_RSP, 
	RPLMSGF_E_SNDENTRIES_REQ,
	RPLMSGF_E_SNDENTRIES_RSP,
	RPLMSGF_E_UPDATE_NTF,			//update notification
	RPLMSGF_E_UPDATE_NTF_PROP,		//update notification (to be
						//propagated
	RPLMSGF_E_UPDVERSNO_REQ,		//update vers. no request 
	RPLMSGF_E_UPDVERSNO_RSP,			//update vers. no response 
                                //adding the following two at the end
                                //so as to not mess up the parser's notion
                                //of the above ones
	RPLMSGF_E_UPDATE_NTF_PRS,	//update notification on a pers. conn
	RPLMSGF_E_UPDATE_NTF_PROP_PRS	//update notification (to be propagated
	} RPLMSGF_MSG_OPCODE_E, *PRPLMSGF_MSG_OPCODE_E;

/* 
 function declarations
*/

extern
VOID
RplMsgfFrmAddVersMapReq(
	IN  LPBYTE	pBuff,
	OUT LPDWORD	pMsgLen
	);

extern
VOID
RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN  RPLMSGF_MSG_OPCODE_E   Opcode_e,
	IN  LPBYTE		  pBuff,
	IN  DWORD		  BuffLen,		  
	IN  PRPL_ADD_VERS_NO_T	  pOwnerAddVersNoMap, 
	IN  DWORD		  MaxNoOfOwners, 
    IN  DWORD         RplTimeInterval,
	OUT LPDWORD		  pMsgLen 
	);

extern
VOID
RplMsgfFrmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN  LPBYTE	pBuff,
	IN  PCOMM_ADD_T pWinsAdd,
	IN  VERS_NO_T	MaxversNo,
	IN  VERS_NO_T	MinVersNo,
    IN  DWORD       RplType,
	OUT LPDWORD	pMsgLen 
	);

extern
VOID
RplMsgfFrmSndEntriesRsp (
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN LPBYTE		pBuff,
	IN DWORD		NoOfRecs,
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN BOOL			fGrp,
	IN DWORD		NoOfAdd,
	IN PCOMM_ADD_T		pNodeAdd,
	IN DWORD		Flag,
	IN VERS_NO_T		VersNo,
	IN BOOL			fFirstTime,
	OUT LPBYTE		*ppNewPos 
	);

extern
VOID
RplMsgfFrmUpdVersNoReq(
	IN  LPBYTE	pBuff,
	IN  LPBYTE	pName,
	IN  DWORD	NameLen,
#if 0
	IN  BOOL	fBrowserName,
	IN  BOOL	fStatic,
	IN  BYTE	NodeTyp,
	IN  PCOMM_ADD_T	pNodeAdd,
#endif
	OUT LPDWORD     pMsgLen
		);
extern
VOID
RplMsgfFrmUpdVersNoRsp(
	IN  LPBYTE	pBuff,
	IN  BYTE	Rcode,
	OUT LPDWORD     pMsgLen
		);
extern
VOID
RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN 	LPBYTE 		    pBuff,
	OUT	LPDWORD		    pNoOfMaps,
    OUT LPDWORD         pRplTimeInterval,
	IN OUT	PRPL_ADD_VERS_NO_T  *ppAddVers
	);

extern
VOID
RplMsgfUfmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN 	LPBYTE 		    pBuff,
	OUT	PCOMM_ADD_T	    pWinsAdd,
	OUT	PVERS_NO_T	    pMaxVersNo,
	OUT	PVERS_NO_T	    pMinVersNo,
        OUT     LPDWORD             pRplType
	);


extern
VOID
RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN OUT	LPBYTE 		*ppBuff,
	OUT     LPDWORD		pNoOfRecs,
	OUT     IN LPBYTE	pName,
	OUT     LPDWORD		pNameLen,
	OUT     LPBOOL		pfGrp,
	OUT     LPDWORD		pNoOfAdd,
	OUT	PCOMM_ADD_T	pNodeAdd,
	OUT     LPDWORD		pFlag,
	OUT     PVERS_NO_T	pVersNo,
	IN      BOOL		fFirstTime 
	);

extern
VOID
RplMsgfUfmUpdVersNoReq(
	IN  LPBYTE	pBuff,
	IN  LPBYTE	pName,
	IN  LPDWORD	pNameLen
#if 0
	IN  LPBOOL	pfBrowserName,
	IN  LPBOOL	pfStatic,
	IN  LPBYTE	pNodeTyp,
	IN  PCOMM_ADD_T	pNodeAdd
#endif
		);

extern
VOID
RplMsgfUfmUpdVersNoRsp(
	IN  LPBYTE	pBuff,
	IN  LPBYTE	pRcode
		);

extern
VOID
RplMsgfUfmPullPnrReq(
	LPBYTE 			pMsg,
	DWORD  			MsgLen,
	PRPLMSGF_MSG_OPCODE_E   pPullReqType_e
	);

#endif //_RPLMSGF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\rplpull.h ===
#ifndef _RPLPULL_
#define _RPLPULL_


#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	rplpull.h
	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "rpl.h"
/*
  defines
*/



/*
  macros
*/

/*
 externs
*/


extern HANDLE		RplPullCnfEvtHdl; //handle to event signaled by main
					  //thread when a configuration change
					  //has to be given to the Pull handler
					  //thread



#if 0
extern  BOOL		fRplPullAddDiffInCurrRplCycle;

extern  BOOL		fRplPullTriggeredWins; //indicates that during the current
					 //replication cycle, one or more 
					 //WINS's were triggered.  This
					 //when TRUE, then if the above
					 //"AddDiff.." flag is TRUE, it means
					 //that the PULL thread should trigger
					//all PULL Pnrs that have an INVALID
					//metric in their UpdateCount field
					//(of the RPL_CONFIG_T struct)

extern BOOL		fRplPullTrigger;//Indication to the PULL thread to
					//trigger Pull pnrs since one or more
					//address changed.  fRplPullTriggerWins
					//has got be FALSE when this is true
#endif

//
// indicates whether the pull thread sent a continue signal to the SC
//
extern   BOOL   fRplPullContinueSent;

//
//  This array is indexed by the id. of an RQ server that has entries in
//  our database.  Each owner's max. version number is stored in this array
//
extern  PRPL_VERS_NOS_T	pRplPullOwnerVersNo;

extern  DWORD  RplPullCnfMagicNo;

extern  DWORD RplPullMaxNoOfWins;   //slots in the RplPullOwnerVersNo

/* 
 typedef  definitions
*/

typedef struct _PUSHPNR_DATA_T {
        DWORD                  PushPnrId;    //id of the Push Pnr
        COMM_ADD_T             WinsAdd;      //address of the Push Pnr
        PRPL_CONFIG_REC_T      pPullCnfRec;  //configuration record.
        COMM_HDL_T             DlgHdl;       //Hdl of dlg with Push Pnr
        BOOL                   fPrsConn;     //indicates whether dlg is persistent
        DWORD                  NoOfMaps;     //no of IP address to Version No.
                                             //Maps sent by the Push Pnr
        PRPL_ADD_VERS_NO_T     pAddVers;     //maps

        DWORD                  RplType;      //type of replication
        BYTE                   fDlgStarted;  //indicates whether the dlg has
                                             //been started
        BOOL                   fToUse;
        VERS_NO_T              MaxVersNoToGet;
        } PUSHPNR_DATA_T, *PPUSHPNR_DATA_T;

typedef struct _PUSHPNR_TO_PULL_FROM_T {
        PPUSHPNR_DATA_T   pPushPnrData;
        VERS_NO_T         VersNo;          //max version number for an owner
        } PUSHPNR_TO_PULL_FROM_T, *PPUSHPNR_TO_PULL_FROM_T;

/* 
 function declarations
*/

extern DWORD	RplPullInit(LPVOID);

extern
VOID
RplPullPullEntries(
	PCOMM_HDL_T 		pDlgHdl,	
	DWORD			OwnerId,
	VERS_NO_T		MaxVersNo,	
	VERS_NO_T		MinVersNo,
	WINS_CLIENT_E		Client_e,
	LPBYTE			*ppRspBuff,
	BOOL			fUpdCntrs,
    DWORD            RplType
	);


extern
STATUS
RplPullRegRepl(
	LPBYTE		pName,
	DWORD		NameLen,
	DWORD		Flag,
	DWORD		OwnerId,
	VERS_NO_T	VersNo,
	DWORD		NoOfAdds,
	PCOMM_ADD_T	pNodeAdd,
	PCOMM_ADD_T	pOwnerWinsAdd,
    DWORD        RplType
	);

VOID
RplPullAllocVersNoArray(
      PRPL_VERS_NOS_T *ppRplOwnerVersNo,
      DWORD          CurrentNo
     );

#ifdef __cplusplus
}
#endif

#endif //_RPLPULL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\wins.h ===
#ifndef _WINS_
#define _WINS_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	wins.h

Abstract:

	This is the main header file for WINS.


Author:
	Pradeep Bahl				Dec-1992



Revision History:

--*/

/*
  Includes
*/
/*
 For now include all header files here since wins.h is included in every
 C file.  In future, include only those headers whose stuff is being referenced
*/
#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntseapi.h>
#include <rpc.h>
#include "winsdbg.h"
#include "winsevnt.h"
#include "winscnst.h"

/*
 defines
*/

#pragma warning (disable: 4005)
#define LiGtr(a, b)           ((a).QuadPart > (b).QuadPart)
#define LiGeq(a, b)           ((a).QuadPart >= (b).QuadPart)
#define LiLtr(a, b)           ((a).QuadPart < (b).QuadPart)
#define LiLeq(a, b)           ((a).QuadPart <= (b).QuadPart)
#define LiGtrZero(a)          ((a).QuadPart > 0)
#define LiGeqZero(a)          ((a).QuadPart >= 0)
#define LiLtrZero(a)          ((a).QuadPart < 0)
#define LiLeqZero(a)          ((a).QuadPart <= 0)
#define LiNeqZero(a)          ((a).QuadPart != 0)
#define LiAdd(a,b)            ((a).QuadPart + (b).QuadPart)
#define LiSub(a,b)            ((a).QuadPart - (b).QuadPart)
#define LiXDiv(a,b)           ((a).Quadpart/(b).QuadPart)
#define LiEql(a,b)            ((a).QuadPart == (b).QuadPart)
#define LiEqlZero(a)          ((a).QuadPart == 0)
#define LiNeq(a,b)            ((a).QuadPart != (b).QuadPart)
#pragma warning (default: 4005)

#if 0
#define HIGH_WORD(a)          (DWORD)Int64ShraMod32(a,32)
#define LOW_WORD(a)           (DWORD)(a & 0xffffffff)
#define WINS_LI_TO_INT64_M(Li, b)  b = Int64ShllMod32(Li.HighPart, 32) | Li.LowPart
#endif



//
// Major and minor version numbers for WINS.
//
// Used in start assoc. req message.
//
#define WINS_MAJOR_VERS	    2

#if PRSCONN
#define WINS_MINOR_VERS_NT5		5
#define WINS_MINOR_VERS		WINS_MINOR_VERS_NT5  //for NT 5
#else
#define WINS_MINOR_VERS		1
#endif

#if SUPPORT612WINS > 0
#define WINS_BETA2_MAJOR_VERS_NO  2
#define WINS_BETA1_MAJOR_VERS_NO  1
#endif


#define   WINS_SERVER 		TEXT("Wins")
#define   WINS_SERVER_FULL_NAME 		TEXT("WINDOWS INTERNET NAME SERVICE")
#define   WINS_NAMED_PIPE 	TEXT("\\pipe\\WinsPipe")
#define   WINS_NAMED_PIPE_ASCII "\\pipe\\WinsPipe"

/*
The following macros are used to flag places in the code that need to be
examined for enhancements (FUTURES), or verification of something to make
the code better (CHECK) or for porting to another transport (NON_PORT)
or performance improvement (PERF) or for alignment considerations (ALIGN)
or for just FYI (NOTE)


These macros provide a convenient mechanism to quickly determine all that
needs to be enhanced, verified, or ported.

*/



#ifdef FUTURES
#define FUTURES(x)	FUTURES: ## x
#else
#define FUTURES(x)
#endif

#ifdef CHECK
#define CHECK(x)	CHECK: ## x
#else
#define CHECK(x)
#endif

#ifdef NONPORT
#define NONPORT(x)	NON_PORT: ## x
#else
#define NONPORT(x)	
#endif

#ifdef PERF
#define PERF(x)		PERF: ## x
#else
#define PERF(x)	
#endif

#ifdef NOTE
#define NOTE(x)		NOTE: ## x
#else
#define NOTE(x)	
#endif


//
// NOTE NOTE NOTE:
//  The sequence of entering critical sections when more than one is
//  entered is given below
//

//
// WinsCnfCnfCrtSec, NmsNmhNamRegCrtSec
//
//  Entered in winsintf.c,winscnf.c,nmsscv.c, rplpull.c
//


//
// Various critical sections and how they are entered
//
// ******************************
//  NmsNmhNamRegCrtSec
//*******************************
//
// Entered by the main thread on a reconfig if vers. counter value is
// specified in the registry. Enetered by nbt threads, nmschl thread
//

//
// ******************************
// NmsDbOwnAddTblCrtSec
// ******************************
//
// Entered by Pull, Push, Rpc threads.
//


/*
 ALIGN - macro to flag places where alignment is very important
*/
#ifdef ALIGN
#define ALIGN(x)	ALIGNMENT: ## x
#else
#define ALIGN(x)	
#endif


/*
  EOS is not defined in windef.h.
*/
#define EOS     (TCHAR)0


/*
  The opcodes in the first long word of a message sent on an association.

  When a message comes in on a TCP connection, the receiving COMSYS,
  checks the opcode in the first long word of the message ( lcation:
  bit 11 to bit 15) to determine if it is a message from an nbt node or
  a WINS server.  NBT message formats use bit 11- bit 15 for the opcode and
  Req/Response bit.  Since out of a posssible 32 opcode combintations, only
  5 are used by NBT, WINS uses one so that the COMSYS receiving the first
  message on a connection can determine whether the connection was
  established by an NBT node or a WINS server.

  if we do not go with the above scheme, we would have had to compare the
  address of the node making the connection with all the addresses of the
  WINS partners that we were configured with to determine whether the
  connection came from a WINS partner or an NBT node. This search is not
  only expensive but also constraints a WINS to know of all its partners
  apriori.

  All messages sent by a WINS have WINS_IS_NOT_NBT opcode in the first byte.
  This is to  enable the receiving COMSYS to look up the assoc. ctx block
  quickly without a search.  This is because if the message is from a WINS
  and is not the first one, then it has the ptr to the local assoc. ctx (this
  was sent to that WINS in the start assoc. response message).

*/

/*
 The value put in the first long word by rplmsgf functions
*/
#define WINS_RPL_NOT_FIRST_MSG	(0xF800)

//
//  Defines to indicate to WinsMscTermThd whether a database session is
//  existent or not
//
#define WINS_DB_SESSION_EXISTS		0	
#define WINS_NO_DB_SESSION_EXISTS	1	

//
// Swap bytes (used in NmsMsgfProcNbtReq) and in nmschl.c)
//
#define WINS_SWAP_BYTES_M(pFirstByte, pSecondByte)			\
			{						\
				BYTE SecondByte = *(pSecondByte);	\
				*(pSecondByte) = *(pFirstByte);		\
				*(pFirstByte) = (SecondByte);		\
			}	
		

//
// Max size of a non-scoped null name (along with NULL character)
//
#define WINS_MAX_NS_NETBIOS_NAME_LEN	17

//
// Max. size of a name in the name - address mapping table.
//
#define WINS_MAX_NAME_SZ           255

FUTURES("Make this a value in the enumerator for Opcodes")
/*
 The actual value put in bit 11-bit 14.  Use 0xE (0xF is used for multihomed
 registration)
*/
#define WINS_IS_NOT_NBT			(0xF)

/*
  defines for the different status values returned by the various
  functions withing WINS


|
| SeverityNames=(Success=0x0:STATUS_SEVERITY_SUCCESS
|                Informational=0x1:STATUS_SEVERITY_INFORMATIONAL
|                Warning=0x2:STATUS_SEVERITY_WARNING
|                Error=0x3:STATUS_SEVERITY_ERROR
|               )
|
| FacilityNames=(System=0x0
|                RpcRuntime=0x2:FACILITY_RPC_RUNTIME
|                RpcStubs=0x3:FACILITY_RPC_STUBS
|                Io=0x4:FACILITY_IO_ERROR_CODE
|               )
|
| Status codes are laid out as:
|
| //
| //  Values are 32 bit values layed out as follows:
| //
| //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
| //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
| //  +---+-+-+-----------------------+-------------------------------+
| //  |Sev|C|R|     Facility          |               Code            |
| //  +---+-+-+-----------------------+-------------------------------+
| //
| //  where
| //
| //      Sev - is the severity code
| //
| //          00 - Success
| //          01 - Informational
| //          10 - Warning
| //          11 - Error
| //
| //      C - is the Customer code flag
| //
| //      R - is a reserved bit
| //
| //      Facility - is the facility code
| //
| //      Code - is the facility's status code
| //
| //
| // Define the facility codes
| //
|
| MS will never set the C bit. This is reserved for
| applications. If exceptions stay within the app, setting
| the C bit means you will never get a collision.
|
*/


#define  WINS_FIRST_NON_ERR_STATUS  ((DWORD )0x00000000L)
#define  WINS_SUCCESS		    (WINS_FIRST_NON_ERR_STATUS + 0x0)
#define  WINS_NO_REQ		    (WINS_FIRST_NON_ERR_STATUS + 0x1)
#define  WINS_NO_SP_TIME	    (WINS_FIRST_NON_ERR_STATUS + 0x2)
#define  WINS_LAST_NON_ERR_STATUS   (WINS_NO_SP_TIME)

#define  WINS_FIRST_ERR_STATUS	   ((DWORD )0xE0000000L)
#define  WINS_FAILURE		   (WINS_FIRST_ERR_STATUS + 0x1)
#define  WINS_FATAL_ERR 	   (WINS_FIRST_ERR_STATUS + 0x2)
#define  WINS_BAD_STATE_ASSOC 	   (WINS_FIRST_ERR_STATUS + 0x3)
#define  WINS_OUT_OF_MEM	   (WINS_FIRST_ERR_STATUS + 0x4)
#define  WINS_OUT_OF_HEAP	   (WINS_FIRST_ERR_STATUS + 0x5)
#define  WINS_BAD_PTR	   	   (WINS_FIRST_ERR_STATUS + 0x6)
#define  WINS_COULD_NOT_FREE_MEM   (WINS_FIRST_ERR_STATUS + 0x7)
#define  WINS_COMM_FAIL   	   (WINS_FIRST_ERR_STATUS + 0x8)
#define  WINS_ABNORMAL_TERM   	   (WINS_FIRST_ERR_STATUS + 0x9)
#define  WINS_PKT_FORMAT_ERR   	   (WINS_FIRST_ERR_STATUS + 0xA)
#define  WINS_HEAP_FREE_ERR	   (WINS_FIRST_ERR_STATUS + 0xB)
#define  WINS_HEAP_CREATE_ERR	   (WINS_FIRST_ERR_STATUS + 0xC)
#define  WINS_SIGNAL_TMM_ERR	   (WINS_FIRST_ERR_STATUS + 0xD)
#define  WINS_SIGNAL_CLIENT_ERR	   (WINS_FIRST_ERR_STATUS + 0xE)
#define  WINS_DB_INCONSISTENT	   (WINS_FIRST_ERR_STATUS + 0xF)
#define  WINS_OUT_OF_RSRCS	   (WINS_FIRST_ERR_STATUS + 0x10)
#define  WINS_INVALID_HDL	   (WINS_FIRST_ERR_STATUS + 0x11)
#define  WINS_CANT_OPEN_KEY	   (WINS_FIRST_ERR_STATUS + 0x12)
#define  WINS_CANT_CLOSE_KEY	   (WINS_FIRST_ERR_STATUS + 0x13)
#define  WINS_CANT_QUERY_KEY	   (WINS_FIRST_ERR_STATUS + 0x14)
#define  WINS_RPL_STATE_ERR	   (WINS_FIRST_ERR_STATUS + 0x15)
#define  WINS_RECORD_NOT_OWNED	   (WINS_FIRST_ERR_STATUS + 0x16)
#define  WINS_RECV_TIMED_OUT	   (WINS_FIRST_ERR_STATUS + 0x17)
#define  WINS_LOCK_ASSOC_ERR	   (WINS_FIRST_ERR_STATUS + 0x18)
#define  WINS_LOCK_DLG_ERR 	   (WINS_FIRST_ERR_STATUS + 0x19)
#define  WINS_OWNER_LIMIT_REACHED  (WINS_FIRST_ERR_STATUS + 0x20)
#define  WINS_NBT_ERR  		   (WINS_FIRST_ERR_STATUS + 0x21)
#define  WINS_QUEUE_FULL  		   (WINS_FIRST_ERR_STATUS + 0x22)
#define  WINS_BAD_RECORD  		   (WINS_FIRST_ERR_STATUS + 0x23)
#define  WINS_LAST_ERR_STATUS	   (WINS_QUEUE_FULL)


/*

 The various exceptions used within WINS
*/

#define  WINS_EXC_INIT         WINS_SUCCESS
#define  WINS_EXC_FAILURE	   WINS_FAILURE
#define  WINS_EXC_FATAL_ERR	   WINS_FATAL_ERR
#define  WINS_EXC_BAD_STATE_ASSOC  WINS_BAD_STATE_ASSOC
#define  WINS_EXC_OUT_OF_MEM	   WINS_OUT_OF_MEM

/*
 Could not allocate heap memory
*/
#define  WINS_EXC_OUT_OF_HEAP	   WINS_OUT_OF_HEAP

/*
 a bad pointer was passed Possibley to LocalFree
	Check WInsMscDealloc
*/
#define  WINS_EXC_BAD_PTR	   WINS_BAD_PTR

/*
 Memory could not be freed through LocalFree
	Check WInsMscDealloc
*/
#define  WINS_EXC_COULD_NOT_FREE_MEM	   WINS_COULD_NOT_FREE_MEM

#define  WINS_EXC_COMM_FAIL	   WINS_COMM_FAIL

/*
 The wait was terminated abnormally
*/
#define  WINS_EXC_ABNORMAL_TERM	   WINS_ABNORMAL_TERM

/*
 The name packet received is not formatted properly
*/
#define  WINS_EXC_PKT_FORMAT_ERR  WINS_PKT_FORMAT_ERR

/*
 Heap memory could not be freed
*/
#define  WINS_EXC_HEAP_FREE_ERR   WINS_HEAP_FREE_ERR

/*
 Heap could not be created
*/
#define  WINS_EXC_HEAP_CREATE_ERR   WINS_HEAP_CREATE_ERR

/*
 Could not signal Tmm thread
*/
#define  WINS_EXC_SIGNAL_TMM_ERR   WINS_SIGNAL_TMM_ERR

/*
 TMM Could not signal Client thread
*/
#define  WINS_EXC_SIGNAL_CLIENT_ERR   WINS_SIGNAL_CLIENT_ERR

/*
 Database is inconsistent.
*/
#define  WINS_EXC_DB_INCONSISTENT   WINS_DB_INCONSISTENT

/*
 Out of resources (for example: a thread could not be created)
*/
#define  WINS_EXC_OUT_OF_RSRCS   WINS_OUT_OF_RSRCS

/*
 An invalid handle is being used
*/
#define  WINS_EXC_INVALID_HDL  WINS_INVALID_HDL

/*
 The registry key is there but could not be opened
*/
#define  WINS_EXC_CANT_OPEN_KEY  WINS_CANT_OPEN_KEY

/*
 The registry key could not be closed
*/
#define  WINS_EXC_CANT_CLOSE_KEY  WINS_CANT_CLOSE_KEY

/*
 The registry key was opened but could not be queried
*/
#define  WINS_EXC_CANT_QUERY_KEY  WINS_CANT_QUERY_KEY

/*
 WINS received a replica that does not have the correct state.  For example,
 it may have received the replica of a special group (Internet) group that
 has all members timed out but the state is not TOMBSTONE

 Another example is when a replica with state RELEASED is received
*/
#define  WINS_EXC_RPL_STATE_ERR	  WINS_RPL_STATE_ERR

/*
  WINS received an update version number notification (from another WINS)
  for a record that it does not own

  There can be two reasons why this happened

  1) There is a bug in WINS (highly unlikely)
  2) The system administrator just deleted the record that was replicated
     to the remote WINS resulting in the clash and consequent update
     notification.

    Check the event logger to confirm/reject the second reason
*/
#define  WINS_EXC_RECORD_NOT_OWNED	WINS_RECORD_NOT_OWNED


//
// Could not lock an assoc block
//
#define  WINS_EXC_LOCK_ASSOC_ERR	WINS_LOCK_ASSOC_ERR

//
// Could not lock a dialogue block
//
#define  WINS_EXC_LOCK_DLG_ERR		WINS_LOCK_DLG_ERR

//
// NmsDbOwnAddTbl limit reached.  All owners of the array are taken
// by ACTIVE WINS owners
//
#define  WINS_EXC_OWNER_LIMIT_REACHED 	WINS_OWNER_LIMIT_REACHED

//
// Some fatal error concerning NBT was encountered
//
#define WINS_EXC_NBT_ERR		WINS_NBT_ERR

// bad database record encountered.
#define WINS_EXC_BAD_RECORD     WINS_BAD_RECORD
/*
 Macros
*/
//
// Control codes that can be used by the service controller (128-255)
//
#define WINS_MIN_SERVICE_CONTROL_CODE	128
#define WINS_ABRUPT_TERM	(WINS_MIN_SERVICE_CONTROL_CODE + 0)


#define WINS_RAISE_EXC_M(x)		RaiseException(x, 0, 0, NULL)


#define WINS_HDL_EXC_M(MemPtrs)	\
		{				\
		WinsMscFreeMem(MemPtrs);	\
		}	
#define WINS_HDL_EXC_N_EXIT_M(MemPtrs)	\
		{				\
		WinsMscFreeMem(MemPtrs);	\
		ExitProcess(0);			\
		}	
#define WINS_RERAISE_EXC_M()			\
		{				\
		DWORD ExcCode;			\
		ExcCode = GetExceptionCode(); 	\
		WINS_RAISE_EXC_M(ExcCode);	\
		}	

#define WINS_HDL_EXC_N_RERAISE_M(MemPtrs)	\
		{				\
		DWORD ExcCode;			\
		WinsMscFreeMem(MemPtrs);	\
		ExcCode = GetExceptionCode(); 	\
		WINS_RAISE_EXC_M(ExcCode);	\
		}

#if 0
#define WINS_RPL_OPCODE_M(pTmp)		\
		{			\
			*pTmp = WINS_RPL_NOT_FIRST_MSG; \
		}
#endif
			
#define WINS_EXIT_IF_ERR_M(func, ExpectedStatus)   	\
		{					\
		  STATUS  Status_mv ;   \
		  Status_mv = (func);	\
		  if (Status_mv != ExpectedStatus)   \
		  {				     \
			DBGPRINT0(ERR, "Major Error"); \
			ExitProcess(1); 	     \
		  }	\
		}

#define WINS_RET_IF_ERR_M(func, ExpectedStatus)   	\
		{				\
		  STATUS  Status_mv ;   \
		  Status_mv = (func);	\
		  if (Status_mv != ExpectedStatus)   \
		  {				     \
			DBGPRINT0(ERR, "Error returned by called func."); \
			return(WINS_FAILURE); 	     \
		  }		\
		}

//
// Vers. No. operations
//
#if 0
#define  WINS_ASSIGN_INT_TO_LI_M(Li, no)	{			\
				  (Li).LowPart  = (no);			\
				  (Li).HighPart = 0;			\
					}
#endif
#define  WINS_ASSIGN_INT_TO_LI_M(Li, no)  (Li).QuadPart  = (no)

#define  WINS_ASSIGN_INT_TO_VERS_NO_M(Li, no)  WINS_ASSIGN_INT_TO_LI_M(Li, no)

#define WINS_PUT_VERS_NO_IN_STREAM_M(pVersNo, pStr)			     \
						{		             \
			LPLONG	_pTmpL = (LPLONG)(pStr);	   	     \
			COMM_HOST_TO_NET_L_M((pVersNo)->HighPart, *_pTmpL);    \
			_pTmpL++;					     \
			COMM_HOST_TO_NET_L_M((pVersNo)->LowPart, *_pTmpL);     \
						}

#define WINS_GET_VERS_NO_FR_STREAM_M(pStr, pVersNo)			     \
							{		     \
			LPLONG	_pTmpL = (LPLONG)(pStr);	   	     \
			COMM_NET_TO_HOST_L_M(*_pTmpL, (pVersNo)->HighPart);    \
			_pTmpL++;					     \
			COMM_NET_TO_HOST_L_M(*_pTmpL, (pVersNo)->LowPart );    \
							}	
				
#define WINS_VERS_NO_SIZE		sizeof(LARGE_INTEGER)





/*
externs
*/
extern	DWORD	WinsTlsIndex;		/*TLS index for Nbt threads to
					 *store database info*/



/*
 Typedefs
*/
typedef  DWORD	STATUS;		// status returned by all NBNS funcs


/*
 *  VERS_NO_T -- datatype of variable storing version number.  The sizeof
 *	of this datatype is used when adding version number column in the
 *	name - address mapping table and when setting a value in this column.
 *      So, if you change the datatype, make sure you make appropriate changes
 *      in nmsdb.c (CreateTbl, InsertRow, etc)
 */

typedef  LARGE_INTEGER	VERS_NO_T, *PVERS_NO_T;      // version no.

typedef	 LPBYTE	MSG_T;		//ptr to a message
typedef	 LPBYTE	*PMSG_T;		//ptr to a message
typedef  DWORD	MSG_LEN_T;	//length of message
typedef  LPDWORD PMSG_LEN_T;	//length of message

typedef MSG_LEN_T	MSG_LEN;
typedef PMSG_LEN_T	PMSG_LEN;

typedef DWORD       WINS_UID_T, *PWINS_UID_T;



/*
    WINS_CLIENT_E -- specifies the different components and their parts
	inside the WINS server.
*/

typedef enum _WINS_CLIENT_E  {
	WINS_E_REPLICATOR = 0, 	/*replicator */
	WINS_E_RPLPULL, 	/*replicator - PULL*/
	WINS_E_RPLPUSH, 	/*replicator - PUSH*/
	WINS_E_NMS,		/* Name Space Manager		*/
	WINS_E_NMSNMH,		/* Name Space Manager - Name Handler	*/
	WINS_E_NMSCHL,		/* Name Space Manager - Challenge Manager*/
	WINS_E_NMSSCV,		/* Name Space Manager - Savenger	*/
	WINS_E_COMSYS,		/* Communication Subsystem Manager*/
	WINS_E_WINSCNF,		/* WINS - Configuration	*/
	WINS_E_WINSTMM,		/* WINS - Timer Manager*/
	WINS_E_WINSRPC		/* WINS - RPC thread*/
	} WINS_CLIENT_E, *PWINS_CLIENT_E;

#define WINS_NO_OF_CLIENTS  (WINS_E_WINSRPC + 1)
	
		
/*
 WINS_MEM_T -- This structure is used in any function that allocates memory
	      or has memory allocated for it by a called function and passed
	      back via an OUT argument

	      The ptrs to the memory blocks are linked together.  The memory
	      is freed in the exception handler.
	
	      This mechanism of keeping track of memory in a structure and
	      getting rid of it in the exception handler will alleviate memory
	      leak problems

*/
	
typedef struct _WINS_MEM_T {
	LPVOID	pMem;	     //non-heap allocated memory
	LPVOID	pMemHeap;   //memory allocated from a heap
	} WINS_MEM_T, *PWINS_MEM_T;



#ifdef __cplusplus
}
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winscnf.h ===
#ifndef _WINSCNF_
#define _WINSCNF_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

        nmscnf.c

Abstract:

        This is the header file to be included for calling functions defined
        in nmscnf.c file.


Functions:



Portability:

        This header is portable.

Author:

        Pradeep Bahl        (PradeepB)        Jan-1993



Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "rpl.h"
#include "winscnst.h"

#if MCAST > 0
#include "rnraddrs.h"
#endif

/*
  defines
*/

/*
  macros
*/

/*
* externs
*/
struct _WINSCNF_CNF_T;                  //forward declaration

extern  DWORD   WinsCnfCnfMagicNo;
extern  struct _WINSCNF_CNF_T        WinsCnf;
extern  BOOL    fWinsCnfRplEnabled;     //replication is enabled/disabled
extern  BOOL    fWinsCnfScvEnabled;     //scavenging is enabled/disabled
extern  BOOL    fWinsCnfReadNextTimeVersNo; //set if vers. no. to use next time
                                            //is read in

FUTURES("use #ifdef PERF around the following three perf. mon. vars")
extern        BOOL        fWinsCnfPerfMonEnabled; //Perf Mon is enabled/disabled


extern  BOOL        fWinsCnfHighResPerfCntr;     //indicates whether the hardware
                                             //supports a high resolution
                                             //perf. counter
extern  LARGE_INTEGER  LiWinsCnfPerfCntrFreq; //Performance Counter's Frequency

extern CRITICAL_SECTION WinsCnfCnfCrtSec;

extern TCHAR        WinsCnfDb[WINS_MAX_FILENAME_SZ];   //db file to hold tables
extern TCHAR    WinsCnfStaticDataFile[WINS_MAX_FILENAME_SZ]; //file containing
                                                         //static data used
                                                         //to initialize WINS

extern BOOL     WinsCnfRegUpdThdExists;
extern HANDLE        WinsCnfNbtHandle;
extern PTCHAR        pWinsCnfNbtPath;
extern BOOL     fWinsCnfInitStatePaused;
extern BOOL   sfNoLimitChk;   //to override the limit checks

//
// magic number of the Wins Cnf structure used at process invocation.  This
// WinsCnf structure is a global structure.  When there is a reconfiguration
// of WINS, we allocate a new WinsCnf structure and copy its contents to
// the global WinsCnf structure.  The magic number in the global WinsCnf is
// incremented.
//
#define  WINSCNF_INITIAL_CNF_MAGIC_NO        0

#define  WINSCNF_FILE_INFO_SZ         sizeof(WINSCNF_DATAFILE_INFO_T)

#define WINSCNF_SPEC_GRP_MASK_SZ  32
/*
 typedef  definitions
*/


//
// Action to take regarding whether the MemberPrec field of NMSDB_ADD_STATE_T
// table should be set. Used in RplFindOwnerId (called by Pull Thread).
//
typedef enum _WINSCNF_INITP_ACTION_E {
        WINSCNF_E_INITP = 0,
        WINSCNF_E_INITP_IF_NON_EXISTENT,
        WINSCNF_E_IGNORE_PREC
        } WINSCNF_INITP_ACTION_E, *PWINSCNF_INITP_ACTION_E;

//
// This structure holds information about the file (name and type as
// found in the registry (REG_SZ, REG_EXPAND_SZ) to be used for static
// initialization of WINS
//
typedef struct _WINSCNF_DATAFILE_INFO_T{
                TCHAR        FileNm[WINS_MAX_FILENAME_SZ];
                DWORD   StrType;
                } WINSCNF_DATAFILE_INFO_T, *PWINSCNF_DATAFILE_INFO_T;
//
// used to index the array of handles specified to WinsMscWaitUntilSignaled
// in nms.c
//
typedef enum _WINSCNF_HDL_SIGNALED_E {
                WINSCNF_E_TERM_HDL = 0,
                WINSCNF_E_WINS_HDL,
                WINSCNF_E_PARAMETERS_HDL,
                WINSCNF_E_PARTNERS_HDL,
                WINSCNF_E_NO_OF_HDLS_TO_MONITOR
        } WINSCNF_HDL_SIGNALED_E, *PWINSCNF_HDL_SIGNALED_E;
//
// The various keys in the WINS configuration (in registry)
//

//
// Don't modify the following enum without looking at TypOfMon[] in winscnf.c
// first
//
typedef enum _WINSCNF_KEY_E {
                WINSCNF_E_WINS_KEY = 0,
                WINSCNF_E_PARAMETERS_KEY,
                WINSCNF_E_SPEC_GRP_MASKS_KEY,
                WINSCNF_E_DATAFILES_KEY,
                WINSCNF_E_PARTNERS_KEY,
                WINSCNF_E_PULL_KEY,
                WINSCNF_E_PUSH_KEY,
                WINSCNF_E_ALL_KEYS
        } WINSCNF_KEY_E, *PWINSCNF_KEY_E;


//
// The states of a WINS
//
typedef enum _WINSCNF_STATE_E {
        WINSCNF_E_INITING = 0,
        WINSCNF_E_STEADY_STATE,         //not used currently
        WINSCNF_E_STEADY_STATE_INITING, //not used currently
    WINSCNF_E_RUNNING,
    WINSCNF_E_INIT_TIME_PAUSE,  //paused at initialization time as directed
                                //via registry
    WINSCNF_E_PAUSED,
    WINSCNF_E_TERMINATING
        } WINSCNF_STATE_E, *PWINSCNF_STATE_E;

//
// Stores the special groups
//
typedef struct _WINSCNF_SPEC_GRP_MASKS_T {
        DWORD         NoOfSpecGrpMasks;
        LPSTR        pSpecGrpMasks;
        } WINSCNF_SPEC_GRP_MASKS_T, *PWINSCNF_SPEC_GRP_MASKS_T;

typedef struct _WINSCNF_CC_T {
               DWORD TimeInt;
               BOOL  fSpTime;
               DWORD SpTimeInt;
               DWORD MaxRecsAAT;
               BOOL  fUseRplPnrs;
             } WINSCNF_CC_T, *PWINSCNF_CC_T;


//
// Stores the 1B names cache used in R_WinsGetBrowserNames
//
typedef struct _DOM_CACHE_T {
            DWORD   NoOfUsers;
            HANDLE  EvtHdl;
            DWORD   EntriesRead;
            DWORD   SzOfBlock;
            LPVOID  pInfo;
            BOOL    bRefresh;
} DOM_CACHE_T;

//
//  WINSCNF_CNF_T --
//         Holds all the configuration information about the WINS
//
typedef struct _WINSCNF_CNF_T {
        DWORD        MagicNo;            //Id.
        DWORD        LogDetailedEvts;    //log detailed events
        DWORD        NoOfProcessors;     // No of processors on the WINS machine
        DWORD        NoOfDbBuffers;      //No of buffers to specify to Jet
        WINSCNF_SPEC_GRP_MASKS_T    SpecGrpMasks;
        WINSCNF_STATE_E             State_e;   //State
        DWORD        RefreshInterval;      //Refresh time interval
        DWORD        TombstoneInterval;    //Tombstone time interval
        DWORD        TombstoneTimeout;     //Tombstone timeout
        DWORD        VerifyInterval;       //Verify time interval
        DWORD        ScvChunk;             //# of records to handle at one
                                           //time by the scavenger thread
        DWORD        MaxNoOfRetries;       //Max # of retries for challenges
        DWORD        RetryInterval;        //Retry time interval
        LPBYTE       pWinsDb;              //db file name
        DWORD        NoOfDataFiles;        //no of files to use for static init
        PWINSCNF_DATAFILE_INFO_T pStaticDataFile;
        BOOL         fStaticInit;           //Do static initialization of WINS
        HANDLE       WinsKChgEvtHdl;            /*event to specify to
                                           *RegNotifyChangeKeyValue
                                           */
        HANDLE       ParametersKChgEvtHdl;  /*event to specify to
                                            *RegNotifyChangeKeyValue
                                            */
        HANDLE       PartnersKChgEvtHdl;   /*event to specify to
                                             *RegNotifyChangeKeyValue
                                             */
        HANDLE       CnfChgEvtHdl;          //Manual reset event to signal on
                                            //to notify other threads of config
                                            //change
        HANDLE       LogHdl;                /*
                                            * Handle to the WINS event log
                                            * Used by ReportEvent
                                            */
        DWORD        WinsPriorityClass;     //Priority class of the process
        DWORD        MaxNoOfWrkThds;        //Max. no. of worker thds.
        int          ScvThdPriorityLvl;
        DWORD        MaxRplTimeInterval;    //max. rpl time interval
        BOOL         fRplOnlyWCnfPnrs;      //Rpl only with Pull/Push Pnrs
        BOOL         fAdd1Bto1CQueries;     //1B name should prepend responses to queries for 1C names
#if MCAST > 0
        BOOL         fUseSelfFndPnrs;       //Rpl with Pnrs found by self
        DWORD        McastTtl;              // TTL for Mcast packets
        DWORD        McastIntvl;            // Time interval for mcast packets
#endif
        BOOL         fLoggingOn;            //Turn on logging flag
        LPBYTE       pLogFilePath;          //Path to log file
        LPBYTE       pBackupDirPath;        //Path to backup directory
        BOOL         fDoBackupOnTerm;       //To turn on backup on termination
        BOOL         fPStatic;              //Set it TRUE to make static
                                            //records p-static

        BOOL         fPersonaGrata;         // TRUE/FALSE if pPersonaList is persona grata/non-grata
        DWORD        NoOfPersona;           // number of personas in the pPersonas
        PCOMM_ADD_T  pPersonaList;          // list of Personas

        DWORD         RplType;               //Rpl types (defined in winscnf.h)
        BOOL         fNoRplOnErr;            //stop rpl on error
#if PRSCONN
        BOOL         fPrsConn;               //Prs Conn
#endif
        WINSCNF_CC_T  CC;                     //Consistency Chk
        BOOL         fDoSpoofing;
        BOOL         fRandomize1CList;         // whether or not to randomize 1C list
                                                // list members.
        struct _PULL_T {
                DWORD          MaxNoOfRetries;  //no of retries to do in case
                                                //of comm. failure
                DWORD          NoOfPushPnrs;    //No of Push Pnrs
                PRPL_CONFIG_REC_T pPullCnfRecs; //ptr. to buff holding
                                                //cnf records for PULL
                                                //thd
                DWORD          InitTimeRpl;     // indicates whether
                                                // Replication
                                                //should be done at invocation
                DWORD         RplType;          //replication type
#if PRSCONN
                BOOL          fPrsConn;
#endif
                BOOL          fOnlyDynRecs;     // when pulling from non-partners, pull only DynRecs
                        } PullInfo;
        struct _PUSH_T {

                BOOL     fAddChgTrigger;         //trigger repl. on address chg
                                                 //of entry owned by us
                DWORD    NoOfPullPnrs;           //No of Pull Pnrs
                DWORD    NoPushRecsWValUpdCnt;
                PRPL_CONFIG_REC_T pPushCnfRecs; //ptr to buffer holding
                                                //cnf records for PUSH
                                                //thd
                DWORD   InitTimePush;          //indicates whether Push
                                               // notifications should
                                               //be sent at invocation
                BOOL    PropNetUpdNtf;         //set to TRUE if we want
                                               //net triggers to be
                                               //propagated
                DWORD         RplType;         //replication type
#if PRSCONN
                BOOL          fPrsConn;
#endif
                BOOL          fOnlyDynRecs;     // when pushing records out to non-partners, push only DynRecs
                        } PushInfo;
        } WINSCNF_CNF_T, *PWINSCNF_CNF_T;
/*
 function declarations
*/

#if USENETBT > 0
extern
STATUS
WinsCnfReadNbtDeviceName(
        VOID
        );
#endif

extern
STATUS
WinsCnfInitConfig(
        VOID
        );


extern
VOID
WinsCnfSetLastUpdCnt(
        PWINSCNF_CNF_T        pWinsCnf
        );
extern
VOID
WinsCnfReadRegInfo(
        PWINSCNF_CNF_T        pWinsCnf
        );

extern
VOID
WinsCnfCopyWinsCnf(
                WINS_CLIENT_E        Client_e,
                PWINSCNF_CNF_T  pSrc
                );

extern
LPVOID
WinsCnfGetNextRplCnfRec(
         PRPL_CONFIG_REC_T        pCnfRec,
        RPL_REC_TRAVERSAL_E        RecTrv_e
        );


extern
VOID
WinsCnfAskToBeNotified(
        WINSCNF_KEY_E         Key_e
 );

extern
VOID
WinsCnfDeallocCnfMem(
  PWINSCNF_CNF_T        pWinsCnf
        );


extern
VOID
WinsCnfReadWinsInfo(
        PWINSCNF_CNF_T  pWinsCnf
        );


extern
VOID
WinsCnfReadPartnerInfo(
        PWINSCNF_CNF_T pWinsCnf
        );


extern
VOID
WinsCnfOpenSubKeys(
        VOID
        );
extern
VOID
WinsCnfCloseKeys(
        VOID
        );

extern
VOID
WinsCnfCloseSubKeys(
        VOID
        );

extern
STATUS
WinsCnfGetNamesOfDataFiles(
        IN  PWINSCNF_CNF_T        pWinsCnf
        );


extern
DWORD
WinsCnfWriteReg(
    LPVOID  pTmp
    );


extern
STATUS
WinsCnfInitLog(
        VOID
        );


#if MCAST > 0
extern
STATUS
WinsCnfAddPnr(
  RPL_RR_TYPE_E  PnrType_e,
  LPBYTE         pPnrAdd
);

extern
STATUS
WinsCnfDelPnr(
  RPL_RR_TYPE_E  PnrType_e,
  LPBYTE         pPnrAdd
);

#endif

#ifdef DBGSVC
extern
VOID
WinsCnfReadWinsDbgFlagValue(
        VOID
        );
#endif

#ifdef __cplusplus
}
#endif

#endif //_WINSCNF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\rplpush.h ===
#ifndef _RPLPUSH_
#define _RPLPUSH_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	rplpush.h
	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
/*
  defines
*/



/*
  macros
*/
	//
	// If NmsNmhMyMaxVersNo counter is > 0, check if we need to
	// send Push notifications at init time.  If no, initialize 
	// all push records such that their LastVersNo field (the version
	// number sent last to Pull Pnrs) is set to the counter value
	// Note: default value of WinsCnf.InitTimePush is 0.  It will 
	// therefore be set to 1 only if there are PUSH records in the
	// registry with valid UpdateCount field values.
    //
    //  
	//	
FUTURES("Init time push should also be to addresses with invalid or no upd cnt")
FUTURES("Modify ERplPushProc")
#define RPLPUSH_INIT_PUSH_RECS_M(pWinsCnf)				\
   {									\
	if (LiGtrZero(NmsNmhMyMaxVersNo))			        \
	{								\
		if (							\
			((pWinsCnf)->PushInfo.InitTimePush == 0) && 	\
			((pWinsCnf)->PushInfo.NoPushRecsWValUpdCnt != 0)\
		   )							\
		{							\
			WinsCnfSetLastUpdCnt((pWinsCnf));		\
		}							\
	}								\
  }
/*
 externs
*/

extern   HANDLE		RplPushCnfEvtHdl;
extern   BOOL           fRplPushThdExists;

/* 
 typedef  definitions
*/

/* 
 function declarations
*/




extern DWORD	RplPushInit(LPVOID);


#ifdef __cplusplus
}
#endif

#endif //_RPLPUSH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winsdbg.h ===
#ifndef _WINSDBG_
#define _WINSDBG_
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winsdbg.h

Abstract:

	This file contains debug related macros and functions for the 
	WINS server

Functions:


Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/

/*
  defines
*/

#ifdef CPLUSPLUS
extern "C" {
#endif

#if DBG
#ifndef WINSDBG
#define WINSDBG
#endif
#define DBGSVC  1
#endif


#ifdef WINSDBG
#define STATIC  

#ifdef WINS_INTERACTIVE
#define PRINTF(pstr)	{printf ## pstr; }
#else
//#define PRINTF(pstr)	WINSEVT_LOG_PRINT_M(pstr)
#ifdef DBGSVC
//#define PRINTF(pstr)	{if (pNmsDbgFile != NULL) fprintf(pNmsDbgFile, pstr);}		


//
// files for storing debugs.
//
extern VOID NmsChkDbgFileSz(VOID);
extern HANDLE NmsDbgFileHdl;

#define PRINTF(pstr)	{ \
                          int DbgBytesWritten; \
                          NmsChkDbgFileSz();  \
                         if (NmsDbgFileHdl != INVALID_HANDLE_VALUE) WriteFile(NmsDbgFileHdl, pstr, strlen(pstr), (LPDWORD)&DbgBytesWritten, NULL);}
#endif
#endif
				
#define	DBGIF(flag)		if(flag)
//
// NOTE:  Use RtlQueryEnvironmental function instead of getenv in the macro
//        below
//
//  FUTURES: Use GetEnvironmentVariable here to be consistent with the general
//           usage of WIN32 API
//
#define DBGINIT	     {					           \
			        LPBYTE  _pStr;				   \
				_pStr = getenv("DBGFLAGS");		   \
				WinsDbg = _pStr == NULL ? 0 : atoi(_pStr); \
		     }
//
// check if replication should be disabled
//
#define DBGCHK_IF_RPL_DISABLED	     {			            \
			LPBYTE  _pStr;				    \
			_pStr = getenv("RPLDISABLED");		    \
			fWinsCnfRplEnabled = _pStr == NULL ? TRUE : FALSE;\
			     }
//
// check if scavenging should be disabled
//
#define DBGCHK_IF_SCV_DISABLED     {				   \
		        LPBYTE  _pStr;				   \
			_pStr = getenv("SCVDISABLED");		   \
			fWinsCnfScvEnabled = _pStr == NULL ? TRUE : FALSE;\
			     }
//
//FUTURES -- "Make this macro independent of DBG or WINSDBG")

//
// check if Perforamance Monitoring should be disabled
//
#define DBGCHK_IF_PERFMON_ENABLED     {				   \
		        LPBYTE  _pStr;				   \
			_pStr = getenv("PERFMON_ENABLED");		   \
			fWinsCnfPerfMonEnabled = _pStr == NULL ? FALSE : TRUE;\
			     }

#define IF_DBG(flag)		      if (WinsDbg & (DBG_ ## flag)) 

#ifdef WINS_INTERACTIVE

#define DBGPRINT0(flag, str) 	      {IF_DBG(flag) PRINTF((str));}  
#define DBGPRINT1(flag,str, v1)       {IF_DBG(flag) PRINTF((str,v1));} 	
#define DBGPRINT2(flag,str, v1,v2)    {IF_DBG(flag) PRINTF((str,v1,v2));} 	
#define DBGPRINT3(flag,str, v1,v2,v3) {IF_DBG(flag) PRINTF((str,v1,v2,v3));}  
#define DBGPRINT4(flag,str, v1,v2,v3,v4) {IF_DBG(flag) PRINTF((str,v1,v2,v3,v4));}  
#define DBGPRINT5(flag,str, v1,v2,v3,v4,v5) {IF_DBG(flag) PRINTF((str,v1,v2,v3,v4,v5));}  

#else

#ifdef DBGSVC 

#define DBGPRINT0(flag, str)	      {IF_DBG(flag) {char cstr[500]; sprintf(cstr, str);PRINTF(cstr);}}   
#define DBGPRINT1(flag,str, v1)       {IF_DBG(flag) {char cstr[500]; sprintf(cstr,str,v1);PRINTF(cstr);}} 	
#define DBGPRINT2(flag,str, v1,v2)    {IF_DBG(flag) {char cstr[500]; sprintf(cstr,str,v1,v2);PRINTF(cstr);}} 	
#define DBGPRINT3(flag,str, v1,v2,v3) {IF_DBG(flag) {char cstr[500]; sprintf(cstr,str,v1,v2,v3);PRINTF(cstr);}}  
#define DBGPRINT4(flag,str, v1,v2,v3,v4) {IF_DBG(flag) {char cstr[500]; sprintf(cstr, str,v1,v2,v3,v4);PRINTF(cstr);}}  
#define DBGPRINT5(flag,str, v1,v2,v3,v4,v5) {IF_DBG(flag) {char cstr[500]; sprintf(cstr, str,v1,v2,v3,v4,v5);PRINTF(cstr);}}  
#endif
#endif

#define DBGMYNAME(x)	{			\
	PWINSTHD_TLS_T  _pTls;			\
	_pTls  = TlsGetValue(WinsTlsIndex);	\
	if (_pTls == NULL)			\
	{					\
	  printf("Couldn't get ptr to TLS storage for storing thd name. Error is (%d)\n", GetLastError());\
	}								\
	else								\
	{								\
	   RtlCopyMemory(_pTls->ThdName, x, strlen(x));			\
	   _pTls->ThdName[strlen(x)] = EOS;				\
	}								\
 }
#define DBGPRINTNAME	{			\
	PWINSTHD_TLS_T  _pTls;			\
	_pTls  = TlsGetValue(WinsTlsIndex);	\
	if (_pTls == NULL)			\
	{					\
		DBGPRINT1(ERR, 			\
		"Couldn't get ptr to TLS storage for reading thd name. Error = (%X)\n", GetLastError()); \
	}							  	   \
	else								   \
	{								   \
	     DBGPRINT1(FLOW, "%s\n",_pTls->ThdName);			   \
	}								   \
  }

#define DBGPRINTEXC(str)	{					\
				    DBGPRINT0(EXC, str);		\
				    DBGPRINT1(EXC, ": Got Exception (%x)\n",\
					(DWORD)GetExceptionCode() );     \
				}
							
			
#define DBGENTER(str)		{					\
					DBGPRINT0(FLOW, "ENTER:") 	\
					DBGPRINT0(FLOW, str);	 	\
				}	
#define DBGLEAVE(str)		{					\
					DBGPRINT0(FLOW, "LEAVE:") 	\
					DBGPRINT0(FLOW, str);	 	\
				}	
#define  DBGSTART_PERFMON	if(fWinsCnfPerfMonEnabled) {

#define  DBGEND_PERFMON		}

//
// Use this macro in the var. declaration section of the function in which
// performance monitoring needs to be done
//
//
#define  DBG_PERFMON_VAR 			        \
	LARGE_INTEGER	LiStartCnt, LiEndCnt;	\

//
// Use this macro at the point from where you wish to start doing performance
// monitoring.  Make sure that the macro DBG_PERFMON_VAR is used in the
// variable declaration section of the function
//
#define DBG_START_PERF_MONITORING				     \
DBGSTART_PERFMON						     \
		if (fWinsCnfHighResPerfCntr)			     \
		{						     \
			printf("MONITOR START\n");		     \
			QueryPerformanceCounter(&LiStartCnt); 	     \
			printf("Current Count = (%x %x)\n", 	     \
				LiStartCnt.HighPart,		     \
				LiStartCnt.LowPart		     \
			      );				     \
		}						     \
DBGEND_PERFMON


//
// Use this macro at the point at which you wich to stop doing the monitoring
// The macro prints out the time spent in the section delimited by 
// DBG_START_PERF_MONITORING and this macro
//
//
#define DBG_PRINT_PERF_DATA						\
DBGSTART_PERFMON						        \
		LARGE_INTEGER   	TimeElapsed;			\
		if (fWinsCnfHighResPerfCntr)				\
		{							\
			QueryPerformanceCounter(&LiEndCnt);		\
		        TimeElapsed = LiDiv(				\
			    LiSub(LiEndCnt, LiStartCnt), LiWinsCnfPerfCntrFreq \
			   	);				          \
			printf("MONITOR END.\nEnd Count = (%x %x)\n", 	     \
				LiEndCnt.HighPart,		     \
				LiEndCnt.LowPart		     \
			      );				     \
		        printf("Time Elapsed (%d %d)\n", TimeElapsed.HighPart, TimeElapsed.LowPart);	\
	        }						        \
DBGEND_PERFMON

#define	DBGPRINTTIME(Type,Str, Time)	\
	{  \
      TIME_ZONE_INFORMATION tzInfo; \
      SYSTEMTIME     LocalTime; \
      GetTimeZoneInformation(&tzInfo);  \
      SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.Time), &LocalTime);  \
	  DBGPRINT5(Type, Str ## "on %d/%d at %d.%d.%d\n", \
		LocalTime.wMonth,	\
		LocalTime.wDay,	\
		LocalTime.wHour,	\
		LocalTime.wMinute,	\
		LocalTime.wSecond	\
		);					\
	}

#define WINSDBG_INC_SEC_COUNT_M(SecCount)   (SecCount)++


#else
#define STATIC  
//#define STATIC  static
#define PRINTF(str)
#define	DBGIF(flag)
#define	IF_DBG(flag)
#define DBGINIT
#define DBGCHK_IF_RPL_DISABLED
#define DBGCHK_IF_SCV_DISABLED
#define DBGCHK_IF_SCV_ENABLED
#define DBGCHK_IF_PERFMON_ENABLED
#define DBGPRINT0(flag,str) 
#define DBGPRINT1(flag,str, v1) 
#define DBGPRINT2(flag,str, v1,v2)
#define DBGPRINT3(flag,str, v1,v2,v3)
#define DBGPRINT4(flag,str, v1,v2,v3,v4)
#define DBGPRINT5(flag,str, v1,v2,v3,v4,v5)
#define DBGMYNAME(x)
#define DBGPRINTEXC(x)
#define DBGENTER(x)
#define DBGLEAVE(x)
#define DBGSTART_PERFMON
#define DBGEND_PERFMON
#define DBG_PERFMON_VAR
#define DBG_START_PERF_MONITORING
#define DBG_PRINT_PERF_DATA
#define DBGPRINTTIME(Type, Str, Time)
#define DBGPRINTNAME
#define WINSDBG_INC_SEC_COUNT_M(SecCount)
#endif

#define	WINSDBG_FILE	                TEXT("wins.dbg")
#define	WINSDBG_FILE_BK	                TEXT("wins.bak")


#define DBG_EXC          	  0x00000001   //exceptions
#define DBG_ERR                   0x00000002   //errors that do not result in 
					       //exceptions
#define DBG_FLOW                  0x00000004   //Control flow
#define DBG_HEAP             	  0x00000008   //heap related debugs 
#define DBG_SPEC             	  0x00000010   //for special debugs 
#define DBG_DS             	  0x00000020   //Data structures
#define DBG_DET			  0x00000040   //detailed stuff
#define DBG_INIT           0x00000080  //Initialization stuff

#define DBG_REPL		  0x00000100	//replication debugs
#define DBG_SCV			  0x00000200	//scavenging debugs

#define DBG_HEAP_CRDL             0x00000400    //heap creation/deletion
#define DBG_HEAP_CNTRS            0x00000800    //heap creation/deletion

#define DBG_TM                    0x00001000    //time related debugs
#define DBG_CHL                   0x00002000    //challenge mgr. related debugs
#define DBG_RPL                   0x00004000    //challenge mgr. related debugs
#define DBG_RPLPULL               0x00008000    //challenge mgr. related debugs
#define DBG_RPLPUSH               0x00010000    //challenge mgr. related debugs
#define DBG_UPD_CNTRS             0x01000000    //update counters
#define DBG_TMP                   0x02000000    //for temporary debugs 

#define DBG_INIT_BRKPNT           0x10000000    //breakpoint at the begining
#define DBG_MTCAST                0x20000000    //mcast debugs

/*
  macros
*/

/*
 externs
*/
extern ULONG WinsDbg;

/* 
 typedef  definitions
*/


/* 
 function declarations
*/
#ifdef CPLUSPLUS
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winsevt.h ===
#ifndef _winsevT_
#define _WINSEVT_
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	winsevt.h

Abstract:




Functions:



Portability:


	This module is portable.

Author:

	Pradeep Bahl	(PradeepB)	Dec-1992



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

#include "wins.h"

/*
  defines
*/



/*
  macros
*/

#define  WINSFILE	TEXT(__FILE__)
#define  WINSLINE	__LINE__

/*
  WINSEVT_LOG_N_RET_IF_ERR_M --  Logs and Returns with indicated status if
	the  return from the function is not as expected.
*/
#if 0
#define WINSEVT_LOG_N_RET_IF_ERR_M(Func_add, Success_Stat, Status_To_Ret, error_str_mo)  \
		{					  	  \
		    LONG	Status_m;			  \
		    if ((Status_m = (Func_add)) != (Success_Stat))\
		    {					  	  \
		       WinsEvtLogEvt(Status, EVENTLOG_ERROR_TYPE,  \
				error_str, WINSFILE, WINSLINE);   \
		       return((Status_To_Ret)); 		  \
		    }					  	  \
	        }
#endif


#define WINSEVT_LOG_PRINT_D_M(_pStr)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_PRINT_M((_pStr));	\
		}						\
	}						
#define WINSEVT_LOG_PRINT_M(_pStr) 	{			\
				WINSEVT_STRS_T EvtStrs;		\
				EvtStrs.NoOfStrs = 1;		\
				EvtStrs.pStr[0]  = _pStr;		\
				WinsEvtLogEvt(WINS_SUCCESS,		\
				     EVENTLOG_INFORMATION_TYPE,		\
				     WINS_EVT_PRINT,			\
				     WINSFILE, WINSLINE, &EvtStrs);	\
					}
				
#define WINSEVT_LOG_INFO_D_M(Status, EvtId)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_INFO_M((Status), (EvtId));	\
		}						\
	}						
#define WINSEVT_LOG_INFO_M(Status, EvtId)  			\
		{					  	\
		    LONG Status_m;				\
		    Status_m = (Status);		  	\
		    WinsEvtLogEvt(Status_m, EVENTLOG_INFORMATION_TYPE, \
				(EvtId), WINSFILE, WINSLINE, NULL);  \
	        }
/*
  WINSEVT_LOG_M --  Logs the indicated event
*/

#define WINSEVT_LOG_D_M(Status, EvtId)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_M((Status), (EvtId));	\
		}						\
	}						
#define WINSEVT_LOG_M(Status, EvtId)  				\
		{					  	\
		    LONG Status_m;				\
		    Status_m = (Status);		  	\
		    WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE, \
				(EvtId), WINSFILE, WINSLINE, NULL);  \
	        }

//
// log one or more strings specified by the EvtStr structure pointed
// to by pStr (Message is an error message)
//
#define WINSEVT_LOG_STR_D_M(EvtId, pStr)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_STR_M((EvtId), (pStr));	\
		}						\
	}
#define  WINSEVT_LOG_STR_M(EvtId, pStr) 			\
			WinsEvtLogEvt(WINS_FAILURE, EVENTLOG_ERROR_TYPE, \
				(EvtId), WINSFILE, WINSLINE, (pStr));

//
// log one or more strings specified by the EvtStr structure pointed
// to by pStr (Message is an informational message)
//
#define WINSEVT_LOG_INFO_STR_D_M(EvtId, pStr)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_INFO_STR_M((EvtId), (pStr));	\
		}						\
	}						
#define  WINSEVT_LOG_INFO_STR_M(EvtId, pStr) 			\
			WinsEvtLogEvt(WINS_SUCCESS, EVENTLOG_INFORMATION_TYPE, \
				(EvtId), WINSFILE, WINSLINE, (pStr));
/*
  WINSEVT_LOG_IF_ERR_M --  Logs the indicated event
*/

#define WINSEVT_LOG_IF_ERR_D_M(Status, EvtId)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_IF_ERR_M((Status), (EvtId));	\
		}						\
	}						
#define WINSEVT_LOG_IF_ERR_M(Status, Event_id)  		\
		{					  	\
		    LONG Status_m;				\
		    Status_m = (Status);		  	\
		    if (Status_m != WINS_SUCCESS)		\
		    {					        \
		      WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE, \
				(Event_id), WINSFILE, WINSLINE, NULL);  \
		    }						\
	        }

/*
  WINSEVT_LOG_N_RET_M --  Logs and Returns with indicated status if
	the  return from the function is not as expected.
*/

#define WINSEVT_LOG_N_RET_D_M(Func, EvtId, RetStat)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_N_RET_M((Func), (EvtId), (RetStat));\
		}						\
	}						
#define WINSEVT_LOG_N_RET_M(Func, Event_id, ret_stat)  		  \
		{					          \
		    LONG  Status_m;			          \
		    if ((Status_m = (Func)) != WINS_SUCCESS)   \
		    {					  	  \
		       WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE,  \
				(Event_id), WINSFILE, WINSLINE, NULL);    \
			return(ret_stat);			  \
		    }					          \
	        }

/*
  WINSEVT_LOG_N_EXIT_M --  Logs and exit
*/

#define WINSEVT_LOG_N_EXIT_D_M(Func, EvtId, RetStat)	\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_N_EXIT_M((Func), (EvtId), (RetStat));\
		}						\
	}						
#define WINSEVT_LOG_N_EXIT_M(Func, Event_id, ret_stat)  	\
		{					  	\
		    LONG	Status_m;			\
		    if ((Status_m = (Func)) != (WINS_SUCCESS))  \
		    {					  	\
		       WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE,\
				(Event_id), WINSFILE, WINSLINE, NULL); 	\
		       Exitprocess(1);				\
		     }					  	\
	        }


#define WINSEVT_LOG_DET_EVT_M1(_Type, _EvtId, _Fmt, _D1)        \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1));                                                    \
		}

#define WINSEVT_LOG_DET_EVT_M2(_Type, _EvtId, _Fmt, _D1, _D2)   \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1), (_D2));                                                 \
		}

#define WINSEVT_LOG_DET_EVT_M3(_Type, _EvtId, _Fmt, _D1, _D2, _D3)     \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1), (_D2), (_D3));                                                 \
		}
#define WINSEVT_LOG_DET_EVT_M3(_Type, _EvtId, _Fmt, _D1, _D2, _D3)     \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1), (_D2), (_D3));                                                 \
		}

//
// Max. number of strings that can be logged
//
#define MAX_NO_STRINGS	5

/*
 externs
*/

/*
 structure definitions
*/
typedef struct _WINSEVT_STRS_T	{
	DWORD	NoOfStrs;
	LPTSTR	pStr[MAX_NO_STRINGS];
	} WINSEVT_STRS_T, *PWINSEVT_STRS_T;

/*
 function definitions
*/


extern
VOID
WinsEvtLogEvt
	(
	LONG 		StatusCode,
	WORD		EvtTyp,
	DWORD		EvtId,
	LPTSTR		pFileStr,  //change to LPTSTR later
	DWORD 		LineNumber,
	PWINSEVT_STRS_T	pStr
	);


extern
VOID
WinsEvtLogDetEvt(
        BOOL            fInfo,
        DWORD           EvtId,
	LPTSTR		pFileStr,
	DWORD 		LineNumber,
        LPSTR           pFormat,
        ...
        );

VOID
WinsLogAdminEvent(
    IN      DWORD               EventId,
    IN      DWORD               StrArgs,
    IN      ...
    );

#endif //_WINSEVT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winsprs.h ===
#ifndef _WINSPRS_
#define _WINSPRS_

#ifdef _cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "winscnf.h"
/*
  defines
*/



/*
  macros
*/

/*
 externs
*/

/* 
 typedef  definitions
*/

//
// Stores information about the file
//
typedef struct _WINSPRS_FILE_INFO_T {
	HANDLE		FileHdl;		//handle to file
	DWORD		FileSize;		//size of file
	DWORD		FileOffset;		//offset into file
	LPBYTE		pFileBuff;		//Memory storing the file 
	LPBYTE		pCurrPos;		//Current position to read
	LPBYTE  	pStartOfBuff;		//Start of Buffer
	LPBYTE		pLimit;			//Last Byte + 1
	} WINSPRS_FILE_INFO_T, *PWINSPRS_FILE_INFO_T;

/* 
 function declarations
*/

extern
STATUS
WinsPrsDoStaticInit(
	PWINSCNF_DATAFILE_INFO_T	pDataFile,
	DWORD				NoOfFiles,
        BOOL                            fAsync
	);

#ifdef _cplusplus
 }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winsmsc.h ===
#ifndef _WINSMSC_
#define _WINSMSC_

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winsmsc.c

	

Abstract:

	This is the header file for interfacing with the winsevt.c module



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "winsque.h"
#include "winsprs.h"
/*
  defines
*/



/*
  macros
*/
//
// macros for hiding Rtl functions
//
#define WINSMSC_COPY_MEMORY_M(x,y,z)	{ RtlCopyMemory(x,y,z);  }
#define WINSMSC_MOVE_MEMORY_M(x,y,z)	{ RtlMoveMemory(x,y,z);	}
#define WINSMSC_FILL_MEMORY_M(x,y,z)	{ RtlFillMemory(x,y,z);	}
#define WINSMSC_COMPARE_MEMORY_M(x,y,z)	RtlCompareMemory(x,y,z)
#define WINSMSC_DELETE_FRM_TBL_M(x,y)	RtlDeleteElementGenericTable(x,y)
#define WINSMSC_INSERT_IN_TBL_M(u,w,x,y) RtlInsertElementGenericTable(u,w,x,y)
#if 0
#define WINSMSC_DELETE_FRM_TBL_M(x,y)	CommAssocDeleteUdpDlg(x,y)
#define WINSMSC_INSERT_IN_TBL_M(u,w,x,y) CommAssocInsertUdpDlg(u,w,x,y)
#endif

#define WINSMSC_INIT_TBL_M(u,w,x,y,z)	{RtlInitializeGenericTable(u,w,x,y,z);}


#define WINSMSC_REALLOC_M(_MemSize, _ppByte) WinsMscHeapReAlloc(GenBuffHeapHdl, (_MemSize), (_ppByte))

/*
 * externs
*/

/*
 typedef  definitions
*/


/*
 function declarations
*/


extern
VOID
WinsMscAlloc(
	IN  DWORD   Size,
	OUT LPVOID	*ppBuff
	);

extern
VOID
WinsMscDealloc(
	LPVOID	pBuff
	);

extern
VOID
WinsMscFreeMem(
	PWINS_MEM_T pWinsMem
	);
extern
VOID
WinsMscWaitInfinite(
	HANDLE Hdl
	);


extern
VOID
WinsMscWaitTimed(
	IN  HANDLE  Hdl,
	IN  DWORD   TimeOut,
        OUT LPBOOL  pfSignaled
);


extern
VOID
WinsMscCreateEvt(
	IN LPTSTR 	pName,
	IN BOOL		fManualReset,
	IN PHANDLE	pHdl
	);

extern
HANDLE
WinsMscCreateThd(
	IN  LPTHREAD_START_ROUTINE  pThdInitFn,
	IN  LPVOID		    pParam,
	OUT LPDWORD		    pThdId
	);

extern
STATUS
WinsMscSetUpThd(
	PQUE_HD_T		pQueHd,
	LPTHREAD_START_ROUTINE  pThdInitFn,
	LPVOID			pParam,
	LPHANDLE		pThdHdl,
	LPDWORD			pThdId
	);


extern
VOID
WinsMscWaitUntilSignaled(
	LPHANDLE	pHdlArray,
	DWORD		NoOfHdls,	
	LPDWORD		pIndexOfHdlSignaled,
    BOOL        fAlertable
	);


extern
VOID
WinsMscWaitTimedUntilSignaled(
	LPHANDLE	pHdlArray,
	DWORD		NoOfHdls,	
	LPDWORD		pIndexOfHdlSignaled,
	DWORD		TimeOut,
	LPBOOL		pfSignaled
	);


extern
LPVOID
WinsMscHeapAlloc(
  IN  HANDLE   HeapHdl,
  IN  DWORD      Size	
  );

extern
VOID
WinsMscHeapReAlloc(
    IN   HANDLE   HeapHdl,
	IN   DWORD    BuffSize,
	OUT  LPVOID  *ppRspBuff
	);


extern
VOID
WinsMscHeapFree(
   HANDLE HeapHdl,
   LPVOID pBuff
	);



extern
HANDLE
WinsMscHeapCreate(
	IN     DWORD  Options,
	IN     DWORD  InitSize
	);


extern
VOID
WinsMscHeapDestroy(
	HANDLE HeapHdl
	);

extern
VOID
WinsMscTermThd(
   STATUS ExitStatus,
   DWORD  DbSessionExists
	);

extern
VOID
WinsMscSignalHdl (
	HANDLE  Hdl
	);
extern
VOID
WinsMscResetHdl (
	HANDLE  Hdl
	);

extern
VOID
WinsMscCloseHdl (
	HANDLE  Hdl
	);

extern
VOID
WinsMscSetThreadPriority(
	HANDLE	ThdHdl,
	int	PrLvl
	);


extern
BOOL
WinsMscOpenFile(
	IN  LPTCH	 pFileName,
	IN  DWORD	 StrType,
	OUT LPHANDLE     pFileHandle
	);

extern
BOOL
WinsMscMapFile(
	PWINSPRS_FILE_INFO_T pFileInfo
	);


extern
VOID
WinsMscLogEvtStrs(
    LPBYTE          pAscii,
    DWORD           EvtNo,
    BOOL            fInfo
   );

extern
VOID
WinsMscConvertUnicodeStringToAscii(
	LPBYTE pUnicodeString,
	LPBYTE pAsciiString,
	DWORD	MaxSz
	);
extern
VOID
WinsMscConvertAsciiStringToUnicode(
	LPBYTE pAsciiString,
	LPBYTE pUnicodeString,
	DWORD	MaxSz
	);

extern
BOOL
WinsMscGetName(
   DWORD    StrType,
   LPTSTR   pFileName,
   LPTSTR   pExpandedFileName,
   DWORD    ExpandedFileNameBuffLen,
   LPTSTR   *ppHoldFileName
  );

extern
VOID
WinsMscSendControlToSc(
  DWORD ControlCode
);


extern
unsigned
WinsMscPutMsg(unsigned usMsgNum, ... );

LPTSTR
WinsMscGetString(
  DWORD StrId
  );

extern
VOID
WinsMscChkTermEvt(
#ifdef WINSDBG
 WINS_CLIENT_E  Client_e,
#endif
  BOOL     fTermTrans
 );

extern
VOID
WinsMscDelFiles(
 BOOL      fMultiple,
 LPCTSTR   pFilePattern,
 LPTSTR    pFilePath
 );


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winsque.h ===
#ifndef _WINSQUE_
#define _WINSQUE_

#ifdef __cplusplus
extern "C" {
#endif

/*
TODO --

  Maybe: Coalesce different queue structures into one.
*/
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

        queue.c

Abstract:

        This is the header file to be included for calling queue.c functions



Functions:



Portability:


        This module is portable.

Author:

        Pradeep Bahl        (PradeepB)        Dec-1992



Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/


/*
  defines
*/
#include <time.h>
#include "wins.h"
#include "comm.h"
#include "assoc.h"
#include "nmsdb.h"
#include "nmsmsgf.h"
#include "nmschl.h"

#define QUE_NBT_WRK_ITM_SZ        sizeof(NBT_REQ_WRK_ITM_T)

/*
  QUE_INIT_BUFF_HEAP_SIZE -- This is the initial size of the heap
                             for allocating queue items for the various
                             queues
*/
#define QUE_INIT_BUFF_HEAP_SIZE                10000


#define WINS_QUEUE_HWM        500
#define WINS_QUEUE_HWM_MAX      5000
#define WINS_QUEUE_HWM_MIN       50
/*
  macros
*/

/*
 externs
*/
//
// forward declarator
//
struct _QUE_HD_T;

extern struct _QUE_HD_T  *pWinsQueQueHd[];

/*
 forward declaration
*/
typedef struct _QUE_HD_T QUE_HD_T;

extern QUE_HD_T  QueNbtWrkQueHd;  //head for nbt req queue

#if REG_N_QUERY_SEP > 0
extern QUE_HD_T  QueOtherNbtWrkQueHd;  //head for nbt reg. req queue
extern DWORD     QueOtherNbtWrkQueMaxLen;
#endif
extern QUE_HD_T  QueRplPullQueHd; //head for rpl pull thread's queue
extern QUE_HD_T  QueRplPushQueHd; //head for rpl push thread's queue
extern QUE_HD_T  QueNmsNrcqQueHd; //head for challenge queue used by NBT thds
extern QUE_HD_T  QueNmsRrcqQueHd; //head for challenge queue used by Replicator
extern QUE_HD_T  QueNmsCrqQueHd;  //head for response queue for challenges sent
extern QUE_HD_T  QueWinsTmmQueHd; //head for timer manager queue
extern QUE_HD_T   QueWinsScvQueHd;  //head for scavenger queue
extern QUE_HD_T  QueInvalidQueHd; //head for an invalid queue. Never inited


extern HANDLE                  QueBuffHeapHdl;  //handle to heap for use for queue items

/*
 structure definitions
*/



/*
 QUE_TYP_E -- enumerator for the various queue types.

                Used by QueInsertWrkItm and its callers
                Used by QueRemoveWrkItm and its callers

This enumerator's value index the spQueHd (queue.c) array.  Do not change the
order of entries without changing QueHd's static initialization appropriately
*/
typedef enum  __QUE_TYP_E {
        QUE_E_NBT_REQ = 0,  //nbt req queue
#if REG_N_QUERY_SEP > 0
        QUE_E_OTHER_NBT_REQ,  //reg/rel nbt req queue
#endif
        QUE_E_RPLPULL,            //pull thread queue
        QUE_E_RPLPUSH,            //push thread queue
        QUE_E_NMSNRCQ,            //nbt request challenge queue
        QUE_E_NMSRRCQ,             //replicator request challenge queue
        QUE_E_NMSCRQ,            //challenge response queue
        QUE_E_WINSTMQ,            //timer queue
        QUE_E_WINSSCVQ,            //Scavenger queue
        QUE_E_UNKNOWN_TYPQ, //Unknown type of queue
        QUE_E_TOTAL_NO_QS   //Total no of queues
                } QUE_TYP_E, *PQUE_TYP_E;

//
// Work items for the different queues.
//
//  NOTE NOTE NOTE -- The work items must have LIST_ENTRY
//                 as the first field in them.
//
typedef struct _NBT_REQ_WRK_ITM_T {
        LIST_ENTRY                Head;
        QUE_TYP_E                QueTyp_e;
        COMM_HDL_T                 DlgHdl;
        MSG_T                        pMsg;
        MSG_LEN_T                MsgLen;
        } NBT_REQ_WRK_ITM_T,         *PNBT_REQ_WRK_ITM_T;
//
//  CHL_REQ_WRK_ITM_T        -- Name challenge queue work item.  This is a work item
//                  that can be used for any of the four name challenge
//                   queues NRCQ, RRCQ, and CRQ
//
typedef struct _CHL_REQ_WRK_ITM_T {
        LIST_ENTRY                Head;
        QUE_TYP_E                QueTyp_e;
        COMM_HDL_T                 DlgHdl;        //dlg handle
        MSG_T                        pMsg;          //NBT message recd
        MSG_LEN_T                MsgLen;        //msg len
        DWORD                        QuesNamSecLen; //Length of question name sec.
        NMSDB_ROW_INFO_T        NodeToReg;     //Info of node To Register
        NMSDB_NODE_ADDS_T        NodeAddsInCnf;
        BOOL                        fGroupInCnf; //whether the cnf record is group or unique
        DWORD                        OwnerIdInCnf;
//        BYTE                        NodeTypInCnf;
//        BYTE                        EntTypInCnf;

        COMM_ADD_T                AddToReg;

        //COMM_ADD_T                AddOfNodeInCnf;
        COMM_ADD_T                AddOfRemWins;        //address of remote WINS to
                                                //be sent the name reg request
                                                //so that the version number
                                                //of the record that caused
                                                //the conflict gets updated
        NMSCHL_CMD_TYP_E        CmdTyp_e;
        WINS_CLIENT_E                Client_e;
        NMSMSGF_NAM_REQ_TYP_E        ReqTyp_e;      //query or release
        DWORD                        NoOfAddsToUse;
        DWORD                        NoOfAddsToUseSv;
        } CHL_REQ_WRK_ITM_T, *PCHL_REQ_WRK_ITM_T;


//
// The response work item is the same as the challenge work item
//
typedef struct _CHL_REQ_WRK_ITM_T  CHL_RSP_WRK_ITM_T, *PCHL_RSP_WRK_ITM_T;


typedef struct _QUE_HD_T {
        LIST_ENTRY                        Head;
        CRITICAL_SECTION                 CrtSec;
        HANDLE                                EvtHdl;
        HANDLE                                HeapHdl;
        DWORD               NoOfEntries;
        } QUE_HD_T, *PQUE_HD_T;


/*
 QUE_CMD_TYP_E - Various Command Types that can be specified in the work item
        of one or more work queues
*/
typedef enum QUE_CMD_TYP_E {
        QUE_E_CMD_REPLICATE = 0,  //Replicate command directd to the Pull
                                  //thread as a result of administrative
                                  //action
        QUE_E_CMD_PULL_RANGE,     //Pull Range command directd to the Pull
                                  //thread as a result of administrative
                                  //action
        QUE_E_CMD_REPLICATE_MSG,  //Replicate message received by COMSYS TCP
                                  //thread
        QUE_E_CMD_SND_PUSH_NTF,   //push update count to remote WINS. This is
                                 //a cmd to the Pull thread at the local WINS
                                 //(by an NBT thread) and a request to the
                                 //Pull thread at the remote WINS.
        QUE_E_CMD_SND_PUSH_NTF_PROP,   //identical to the above except that
                                 //this one requests propagation along the
                                 //the chain of WINSs (Pull Partners)
        QUE_E_CMD_HDL_PUSH_NTF,  //handle Push notification from a remote WINS.
                                 //This is a command forwarded to the PULL
                                 //thread by the Push thread
        QUE_E_CMD_CONFIG,        //set configuration request
        QUE_E_CMD_DELETE_WINS,   //Delete WINS from add-vers map tables (records
                                 //are also deleted)
        QUE_E_CMD_SET_TIMER,     //set timer request to TMM
        QUE_E_CMD_CANCEL_TIMER,  //cancel timer request to TMM
        QUE_E_CMD_MODIFY_TIMER,  //modify timer reqyest to TMM
        QUE_E_CMD_TIMER_EXPIRED, //response to an earlier set timer request
        QUE_E_CMD_SCV_ADMIN,      // Admin initiated request
        QUE_E_CMD_ADDR_CHANGE     // Address of the local machine changed
        } QUE_CMD_TYP_E, *PQUE_CMD_TYP_E;

/*
 Work item for the Replicator's queue


        It is used in the work queue of both the PULL thread and the
        PUSH thread.

         CmdTyp_e                pClientCtx


        E_RPL                   NULL
        E_CONFIG                address of list of RPL_CONFIG_REC_T records
                                terminated by NULL
        E_REPLICATE                address of list of RPL_CONFIG_REC_T records
                                terminated by NULL
        E_TIMER_EXPIRE                address of list of RPL_CONFIG_REC_T records
                                terminated by NULL

*/

//
// The replicator, timer and Scavenger work items must have LIST_ENTRY,
// QUE_TYP_E, and QUE_CMD_TYP_E as the top 3 fields in this order.
//
// Refer RplPullInit and RplPushInit to discover why.
//
typedef struct _QUE_RPL_REQ_WRK_ITM_T {
        LIST_ENTRY               Head;
        QUE_TYP_E                QueTyp_e;
        QUE_CMD_TYP_E            CmdTyp_e;

        //
        // Don't change the order of the three fields above. Also,
        // they need to be at the top. See comment above
        //

        COMM_HDL_T               DlgHdl;
        MSG_T                    pMsg;
        MSG_LEN_T                MsgLen;
        LPVOID                   pClientCtx; /*client context.  For example,
                                             *it may point to config
                                             *records (RPL_CONFIG_REC_T
                                             *in case the cmd is E_CONFIG
                                             */
        DWORD                    MagicNo;   //used by IsTimeoutToBeIgnored()
                                           //in rplpull.c
        } QUE_RPL_REQ_WRK_ITM_T, *PQUE_RPL_REQ_WRK_ITM_T;

//
// SCV_REQ_WRK_ITM_E
//
typedef enum WINSINTF_SCV_OPC_E  QUE_SCV_OPC_E, *PQUE_SCV_OPC_E;


typedef struct _QUE_SCV_REQ_WRK_ITM_T {
        LIST_ENTRY         Head;
        QUE_TYP_E          QueTyp_e;
        QUE_CMD_TYP_E      CmdTyp_e;
        WINSINTF_SCV_OPC_E Opcode_e;
        DWORD              Age;
        BOOL               fForce;
        } QUE_SCV_REQ_WRK_ITM_T,         *PQUE_SCV_REQ_WRK_ITM_T;


/*
 Que of timer manager
*/
typedef struct _QUE_TMM_REQ_WRK_ITM_T {
        LIST_ENTRY                Head;
        QUE_TYP_E                QueTyp_e;
        QUE_CMD_TYP_E                CmdTyp_e;

        //
        // Don't change the order of the three fields above. Also,
        // they need to be at the top. They have to be in the same order
        // and position within this and the _QUE_RPL_REQ_WRK_ITM_T data
        // structure
        //

        DWORD                        ReqId;           //id of request
        WINS_CLIENT_E                Client_e;  //maybe not needed. Check ??
        time_t                        TimeInt;   //Time Interval
        time_t                        AbsTime;   //Absolute time
        DWORD                        DeltaTime; //Delta time
               HANDLE                        RspEvtHdl; //event to signal for response
        PQUE_HD_T                pRspQueHd;           //Que to put the response on
        LPVOID                        pClientCtx; /*client context.  For example,
                                             *it may point to config
                                             *records (RPL_CONFIG_REC_T
                                             *in case the cmd is E_CONFIG
                                             */
        DWORD                        MagicNo;   //used by IsTimeoutToBeIgnored()
                                           //in rplpull.c
        } QUE_TMM_REQ_WRK_ITM_T, *PQUE_TMM_REQ_WRK_ITM_T;


/*
 function prototypes
*/

extern
STATUS
QueInsertNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T        pMsg,
        IN MSG_LEN_T    MsgLen
        );

extern
STATUS
QueRemoveNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T                      ppMsg,
        OUT PMSG_LEN_T                  pMsgLen
        );
#if REG_N_QUERY_SEP > 0
extern
STATUS
QueInsertOtherNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T        pMsg,
        IN MSG_LEN_T    MsgLen
        );

extern
STATUS
QueRemoveOtherNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T                      ppMsg,
        OUT PMSG_LEN_T                  pMsgLen
        );
#endif



extern
STATUS
QueInsertChlReqWrkItm(
        IN NMSCHL_CMD_TYP_E        CmdTyp_e,
        IN WINS_CLIENT_E        Client_e,
        IN PCOMM_HDL_T           pDlgHdl,
        IN MSG_T                 pMsg,
        IN MSG_LEN_T             MsgLen,
        IN DWORD                 QuesNamSecLen,
        IN PNMSDB_ROW_INFO_T    pNodeToReg,
        IN PNMSDB_STAT_INFO_T   pNodeInCnf,
        //IN PCOMM_ADD_T           pAddOfNodeInCnf,
        IN PCOMM_ADD_T           pAddOfRemWins
        );

extern
STATUS
QueRemoveChlReqWrkItm(
        IN        HANDLE        EvtHdl,
        IN OUT  LPVOID        *ppaWrkItm,
        OUT        LPDWORD        pNoOfReqs
        );


extern
STATUS
QueInsertChlRspWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        );

extern
STATUS
QueRemoveChlRspWrkItm(
        OUT  LPVOID        *ppWrkItm
        );


extern
STATUS
QueInsertWrkItm (
        IN  PLIST_ENTRY                pWrkItm,
        IN  QUE_TYP_E                QueTyp_e,
        IN  PQUE_HD_T                pQueHdPassed
        );

extern
STATUS
QueGetWrkItm (
        IN  QUE_TYP_E                QueTyp_e,
        OUT LPVOID                *ppWrkItm
        );



extern
VOID
QueAllocWrkItm(
        IN   HANDLE        HeapHdl,
        IN   DWORD        Size,
        OUT  LPVOID        *ppBuf
        );

extern
VOID
QueDeallocWrkItm(
   IN  HANDLE HeapHdl,
   IN  LPVOID  pBuff
        );



extern
STATUS
QueInsertWrkItmAtHdOfList (
        IN  PLIST_ENTRY                pWrkItm,
        IN  QUE_TYP_E                QueTyp_e,
        IN  PQUE_HD_T                pQueHdPassed
        );


extern
STATUS
QueInsertRplPushWrkItm (
        IN               PLIST_ENTRY        pWrkItm,
        IN           BOOL                fAlreadyInCrtSec
        );

extern
STATUS
QueInsertNetNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        );

extern
STATUS
QueInsertSndNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        );



extern
VOID
QueChlWaitForRsp(
    VOID
    );
extern
VOID
QueChlNoWaitForRsp(
    VOID
    );

extern
__inline
STATUS
QueInsertScvWrkItm(
     PLIST_ENTRY  pWrkItm
        );

extern
__inline
STATUS
QueRemoveScvWrkItm(
     LPVOID  *ppWrkItm
        );


extern
VOID
WinsQueInit(
    LPTSTR     pName,
    PQUE_HD_T  pQueHd
    );

#ifdef __cplusplus
}
#endif

#endif //_WINSQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winsthd.h ===
#ifndef _WINSTHD_
#define _WINSTHD_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winsthd.h



Abstract:


Author:

    Pradeep Bahl      18-Nov-1992	

Revision History:

--*/

#include "wins.h"
#include "esent.h"




/*
  WINS_MAX_THD - Maximum number of threads in the WINS Server

	Main thd + Thd pool # + Name Challenger (1) + Replicator (3) +
		COMSYS (2) +  Timer Manager (1)
*/

#if REG_N_QUERY_SEP > 0
#define WINSTHD_MIN_NO_NBT_THDS 2
#define WINSTHD_DEF_NO_NBT_THDS	2	
#else
#define WINSTHD_MIN_NO_NBT_THDS 1
#define WINSTHD_DEF_NO_NBT_THDS	1	
#endif
#define WINSTHD_MAX_NO_NBT_THDS 20



#define WINSTHD_NO_RPL_THDS	2
#define WINSTHD_NO_COMM_THDS	2
#define WINSTHD_NO_TMM_THDS	1
#define WINSTHD_NO_CHL_THDS	1
#define WINSTHD_NO_SCV_THDS	1


/*
	Indices of the various Replicator threads in the RplThds array of
	WinsThdPool var.
*/
#define WINSTHD_RPL_PULL_INDEX  0
#define WINSTHD_RPL_PUSH_INDEX  1

/*
 WINSTHD_TLS_T -- Structure in the thread local storage of a thread
*/

typedef struct _WINSTHD_TLS_T {
#ifdef WINSDBG
	BYTE		ThdName[30];	//just for testing
    WINS_CLIENT_E   Client_e;   //client
#endif
	JET_SESID   	SesId;		//session id	
	JET_DBID    	DbId;		//database id
	JET_TABLEID 	NamAddTblId;    //name-address table id
	JET_TABLEID 	OwnAddTblId;	//Owner - address table id
	BOOL		fNamAddTblOpen; //indicates whether the name-add tbl
					//was opened by this thread
	BOOL		fOwnAddTblOpen; //indicates whether the owner-add tbl
					//was opened by this thread
	HANDLE		HeapHdl;	
	} WINSTHD_TLS_T, *PWINSTHD_TLS_T;
	


/*
  WINSTHD_TYP_E -- Enumerates the different types of threads in the WINS server
*/
typedef enum  _WINSTHD_TYP_E {
	WINSTHD_E_TCP = 0,   //COMSYS TCP listener thread
	WINSTHD_E_UDP,	     //COMSYS UDP listener thread
	WINSTHD_E_NBT_REQ,   //NMS NBT REQ Thread
	WINSTHD_E_RPL_REQ,   //Replicator PULL Thread
	WINSTHD_E_RPL_RSP    //Replicator PUSH Thread
	} WINSTHD_TYP_E, *PWINSTHD_TYP_E;


/*
 WINSTHD_INFO_T -- Info. pertaining to a thread
*/
typedef struct _WINSTHD_INFO_T {
	BOOL	fTaken;			/*indicates whether entry is empty*/
	DWORD	ThdId;			/*thread id	*/
	HANDLE  ThdHdl;			/*handle to the thread*/
	WINSTHD_TYP_E	ThdTyp_e;	/*Type of thread	*/
	} WINSTHD_INFO_T, *PWINSTHD_INFO_T;

/*
 WINSTHD_POOL_T - The thread pool for the WINS server
*/	
typedef struct _WINSTHD_POOL_T {	
	DWORD	 	 ThdCount;	
	WINSTHD_INFO_T	 CommThds[WINSTHD_NO_COMM_THDS];/*comm thds (TCP and
							 *UDP listener)
							*/
	WINSTHD_INFO_T   RplThds[WINSTHD_NO_RPL_THDS];	//replication threads
	WINSTHD_INFO_T   ChlThd[WINSTHD_NO_CHL_THDS];   //Challenge threads
	WINSTHD_INFO_T	 TimerThds[WINSTHD_NO_TMM_THDS];//Timer thread
	WINSTHD_INFO_T	 ScvThds[WINSTHD_NO_SCV_THDS];
	WINSTHD_INFO_T   NbtReqThds[WINSTHD_MAX_NO_NBT_THDS]; //nbt threads
	} WINSTHD_POOL_T, *PWINSTHD_POOL_T;


/*
 Externals
*/

extern WINSTHD_POOL_T	WinsThdPool;


#ifdef __cplusplus
}
#endif

#endif //_WINSTHD_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winswriter.hpp ===
#ifndef _WINSWRITER_HPP
#define _WINSWRITER_HPP

#ifdef CPLUSPLUS
extern "C" {
#endif //CPLUSPLUS

#define WINSWRITER_NAME  TEXT("WINS Jet Writer")

DWORD _cdecl WinsWriterInit();
DWORD _cdecl WinsWriterTerm();


#ifdef CPLUSPLUS
}
#endif //CPLUSPLUS

// this class could be refrerenced only from C++ code
#ifdef CPLUSPLUS

class CWinsVssJetWriter : public CVssJetWriter
{
public:
	HRESULT Initialize();
	HRESULT Terminate();
};

#endif //CPLUSPLUS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winscnf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        winscnf.c

Abstract:

        This module contains functions that deal with the configuration
        information for the WINS

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Dec-1992


Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/

#include "wins.h"
#include <winsock2.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <search.h>
#include "comm.h"
#include "winreg.h"
#include "winsevt.h"
#include "winsmsc.h"
#include "winscnf.h"
#include "nms.h"
#include "nmsnmh.h"
#include "rpl.h"
#include "rplpush.h"
#include "winsintf.h"
#include "nmfilter.h"
#include <resapi.h>


/*
 *        Local Macro Declarations
*/

//
// Size of max string that a user can input in a REG_SZ field
//
#define  MAX_SZ_SIZE        80

#define REG_M(fn, evt, exc)                                        \
                        {                                        \
                           if((fn) != ERROR_SUCCESS)                \
                           {                                        \
                                WINSEVT_LOG_M(                        \
                                        WINS_FATAL_ERR,                \
                                        (evt)                        \
                                                   );                \
                                WINS_RAISE_EXC_M((exc));        \
                           }                                        \
                        }

//
// pointer to default path for log file.  If you change this to a NON NULL
// value, make sure you don't try to free the memory in SetSystemParam
// in nmsdb.c
//
#define DEFAULT_LOG_PATH         NULL

#define  _WINS_CFG_KEY                \
                TEXT("System\\CurrentControlSet\\Services\\Wins")
#define  _WINS_CFG_PARAMETERS_KEY        TEXT("Parameters")
#define  _WINS_CFG_PARTNERS_KEY          TEXT("Partners")
#define  _WINS_CFG_CC_KEY                TEXT("Parameters\\ConsistencyCheck")
#define  _WINS_CFG_PULL_KEY              TEXT("Partners\\Pull")
#define  _WINS_CFG_PUSH_KEY              TEXT("Partners\\Push")
#define  _WINS_CFG_DATAFILES_KEY         TEXT("Parameters\\Datafiles")
#define  _WINS_CFG_SPEC_GRP_MASKS_KEY    TEXT("Parameters\\InternetGrpMasks")

#define  _WINS_LOG_KEY                \
                TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\WinsInt")
#define  _WINS_MSGFILE_SKEY  TEXT("EventMessageFile")


#define  _WINS_LOG_FILE_NAME TEXT("%SystemRoot%\\System32\\winsevnt.dll")


#define   _RPL_CLASS                TEXT("RplClass")//class for Rpl Pull and Push
                                                //keys


//
// The start version number should never be allowed to go above this number
// This will avoid a wrap around.
//

#define MAX_START_VERS_NO     0x0FFFFFFF

//
// Names of event variables used for notification purposes
//
#ifdef WINSDBG
#define        WINS_KEY_CHG_EVT_NM                TEXT("WinsKChgEvt")
#define        PARAMETERS_KEY_CHG_EVT_NM        TEXT("WinsParamatersKChgEvt")
#define        PARTNERS_KEY_CHG_EVT_NM                TEXT("WinsPartenersKChgEvt")
#define CNF_CHG_EVT_NM                        TEXT("WinsConfigChangeEvt")
#else
#define        WINS_KEY_CHG_EVT_NM                NULL
#define        PARAMETERS_KEY_CHG_EVT_NM        NULL
#define        PARTNERS_KEY_CHG_EVT_NM                NULL
#define CNF_CHG_EVT_NM                        NULL
#endif

//
// Values for the fStaticInit field of the configuration data structure
//
#define  DO_STATIC_INIT                        TRUE
#define  DONT_DO_STATIC_INIT                FALSE


//
// defines for the InitTimeRpl and InitTimePush fields of WinsCnf
//
#define DO_INIT_TIME_RPL                1
#define NO_INIT_TIME_RPL                0


//
//  NO_LIMIT_CHK_FLAG  - for easing the task of testers
//
//  If this flag is set in LogDetailedEvts DWORD, WINS skips all
//  checks for the min. values of the time intervals and Update Count.
//  This kind of operation of WINS is unsupported and is being provided
//  only to help out testers
//
#define  NO_LIMIT_CHK_FLAG   0x80000000    //MSB is set.


//
// If ErrEvt passed is 0, we don't log any message.  NOTE: a WINS event
// can never have 0 as its value (checkout winsevnt.mc)
//
#define QUERY_VALUE_M(Key, Str, ValTyp, Var, ErrEvt, DefVal)                \
        {                                                                \
                DWORD Sz = sizeof((Var));                                \
                if (RegQueryValueEx(                                        \
                                (Key),                                        \
                                (Str),                                        \
                                NULL,                                               \
                                &(ValTyp),                                \
                                (LPBYTE)&(Var),                                \
                                &Sz                                        \
                                ) != ERROR_SUCCESS                        \
                    )                                                        \
                {                                                        \
                        if ((ErrEvt) != 0)                                \
                        {                                                \
                                WINSEVT_LOG_INFO_M(                        \
                                        WINS_SUCCESS,                        \
                                        (ErrEvt)                        \
                                       );                                \
                        }                                                \
                        Var = DefVal;                                        \
                }                                                        \
           }
/*
 *        Local Typedef Declarations
 */

/*
 *        Global Variable Definitions
 */

CRITICAL_SECTION  WinsCnfCnfCrtSec;                //used for reinitialization
                                                //of certain fields of the
                                                //WinsCnf structure


BOOL        fWinsCnfRplEnabled = TRUE;                //replication is enabled
BOOL        fWinsCnfScvEnabled = TRUE;                //scavenging is enabled

FUTURES("use #ifdef PERF around the following three perf. mon. vars")
BOOL        fWinsCnfPerfMonEnabled   = FALSE;        //perf. mon is disabled
BOOL          fWinsCnfHighResPerfCntr = FALSE;    //indicates whether the
                                                  //hardware supports a high
                                                  //performance counter
LARGE_INTEGER LiWinsCnfPerfCntrFreq;                     //indicates the frequency of
                                                  //the counter

BOOL    fWinsCnfReadNextTimeVersNo = FALSE;
DWORD        WinsCnfCnfMagicNo          = WINSCNF_INITIAL_CNF_MAGIC_NO;
BOOL    fWinsCnfInitStatePaused;

//TCHAR        WinsCnfDb[WINS_MAX_FILENAME_SZ];   //db file to hold tables
BOOL    WinsCnfRegUpdThdExists = FALSE;
//#define MAX_PATH_SIZE        200
PTCHAR  pWinsCnfNbtPath;


BOOL   sfNoLimitChk = FALSE;   //to override the limit checks
//
// NetBt handle
//
HANDLE        WinsCnfNbtHandle = NULL;

//
//
// Init the configuration structure with default values
//
WINSCNF_CNF_T        WinsCnf = {
                                        WINSCNF_INITIAL_CNF_MAGIC_NO,        //id
NOTE("Change 1 to 0 before production")
                                        0,                //Log detailed evts
                    1,      //default number of processors
                    200,    //default no. of db buffers
                                        { 0, NULL},        //Spec.grp mask
                                        WINSCNF_E_INITING,        //state
                                        WINSCNF_DEF_REFRESH_INTERVAL,
                                        WINSCNF_MIN_TOMBSTONE_INTERVAL,
                                        WINSCNF_MIN_TOMBSTONE_TIMEOUT,
                                        WINSCNF_MIN_VERIFY_INTERVAL,
                                        WINSCNF_SCV_CHUNK,
                                        WINSCNF_DEF_CHL_MAX_RETRIES,
                                        WINSCNF_DEF_INIT_CHL_RETRY_INTVL,
                                        WINSCNF_DB_NAME_ASCII,  //db file name
                                        0,                //no of STATIC files
                                        NULL,                //ptr to file names
                                        DONT_DO_STATIC_INIT,
                                        (HANDLE)0,  //notify event handle (WINS)
                                        (HANDLE)0,  //not. evt hdl (PARAMETSRS)
                                        (HANDLE)0,  //not. evt hdl (PARTNERS)
                                        (HANDLE)0,  //Config change handle
                                        (HANDLE)0,  //log event handle
                                        (DWORD)WINSINTF_E_NORMAL,
                                        WINSTHD_DEF_NO_NBT_THDS,
                                        WINSCNF_SCV_PRIORITY_LVL,
                                        WINSCNF_MIN_VALID_RPL_INTVL,//max Rpl
                                                                    //Time Intvl
                                        TRUE,     //rpl. only with cnf partners
                                        TRUE,     //add 1B to responses to 1C name queries
#if MCAST > 0
                                        FALSE,    //no rpl. with self found pnrs
                                        WINSCNF_DEF_MCAST_TTL,
                                        WINSCNF_DEF_MCAST_INTVL,
#endif
                                        TRUE,     //logging is on
                                        NULL,     //current directory
                                        NULL,     //no backup directory
                                        FALSE,    //Do backup on term flg
                                        FALSE,    //PStatic flag
                                        0,        //type of persona list (0 = non-grata)
                                        0,        //number of addresses in persona list
                                        NULL,     //persona list
                                        WINSCNF_RPL_DEFAULT_TYPE, //def. rpl
                                        TRUE,    //No rpl on error
                                        TRUE,   //no persistent connections
                                //
                                // CC initialization
                                //
                                        MAXULONG, //CC Time Int
                                        FALSE,    //SpTime Set
                                        MAXULONG, //Sp Time
                                        WINSCNF_CC_DEF_RECS_AAT,
                                        WINSCNF_CC_DEF_USE_RPL_PNRS,

                                        FALSE,  //no spoofing
                                        FALSE,  // no randomization of 1C list.
                                //
                                //PullInfo initialization
                                //
                                          WINSCNF_MAX_COMM_RETRIES, //comm.
                                                                     //failure
                                                                     //retries
                                          0,   //no of Push Pnrs
                                          NULL,//ptr to Pull Pnrs records
                                          DO_INIT_TIME_RPL,  //do init time
                                                             //pulling
                                          WINSCNF_RPL_DEFAULT_TYPE,
                                          TRUE,  // persistent connections
                                          FALSE, // pull only DynRecs from non-partners
                                //
                                // PushInfo initialization
                                //
                                          TRUE, // trigger on address change
                                                 //of owned entry
                                          0,   //no of Pull Pnrs
                                          0,   //no of Push recs with valid
                                               //update count
                                          NULL,//ptr to Push Pnrs records
                                          DO_INIT_TIME_RPL, //init time
                                                            //pushing disabled
                                          DO_PROP_NET_UPD_NTF,  //prop net upd
                                                               //ntfs.
                                          WINSCNF_RPL_DEFAULT_TYPE,
                                          TRUE,  // persistent connections
                                          FALSE, // push only DynRecs to non-partners
                          };


/*
 *        Local Variable Definitions
*/
STATIC BOOL     sfVersNoUpdThdExists = FALSE;
STATIC BOOL     sfVersNoChanged = FALSE;

STATIC HKEY        sConfigRoot;              //HKEY for the WINS root
STATIC HKEY        sParametersKey;    //HKEY for the PARAMETERS subkey
STATIC HKEY        sCCKey;            //HKEY for the CC subkey
STATIC HKEY        sPartnersKey;      //HKEY for PARTNERS subkey
STATIC HKEY        sLogRoot;          //HKEY for the log root

FUTURES("Might want to change these to auto variables later")
STATIC TCHAR    sWinsCfgKey[]                 = _WINS_CFG_KEY;
STATIC TCHAR    sWinsLogKey[]                 = _WINS_LOG_KEY;
STATIC TCHAR    sWinsMsgFileSKey[]      = _WINS_MSGFILE_SKEY;

//
// flags that indicate to WinsCnfOpenSubKeys() whether the corresponding keys
// exist.
//
STATIC BOOL     sfParametersKeyExists = FALSE;
STATIC BOOL         sfPartnersKeyExists   = FALSE;

STATIC BOOL     sfParametersKeyOpen = FALSE;
STATIC BOOL         sfPartnersKeyOpen   = FALSE;

TCHAR        sLogFilePath[WINS_MAX_FILENAME_SZ];   //path to log file

/*
 *        Local Function Prototype Declarations
*/

/* prototypes for functions local to this module go here */




STATIC
VOID
LnkWSameMetricValRecs(
        PWINSCNF_CNF_T           pWinsCnf,
        PRPL_CONFIG_REC_T  pCnfRec
        );

STATIC
int
__cdecl
CompUpdCnt(
        CONST LPVOID  pElem1,
        CONST LPVOID  pElem2
        );

STATIC
VOID
GetPnrInfo(
        RPL_RR_TYPE_E   RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        );

STATIC
VOID
GetKeyInfo(
        IN  HKEY                   Key,
        IN  WINSCNF_KEY_E        KeyTyp_e,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        );

STATIC
BOOL
SanityChkParam(
        PWINSCNF_CNF_T  pWinsCnf
        );

STATIC
VOID
ChkWinsSubKeys(
        VOID
        );

STATIC
VOID
GetSpTimeData(
        HKEY              SubKey,
        LPSYSTEMTIME      pCurrTime,
        LPBOOL            pfSpTime,
        LPDWORD           pSpTimeIntvl
        );
STATIC
VOID
ReadSpecGrpMasks(
        PWINSCNF_CNF_T pWinsCnf
        );

VOID
GetOwnerList(
  PWINSCNF_CNF_T  pWinsCnf
 );

VOID
ReadCCInfo(
 PWINSCNF_CNF_T  pWinsCnf
);

#if MCAST > 0
STATIC
DWORD
SetVal(
       HKEY     RootKey,
       LPWSTR   pName,
       DWORD    ValType,
       LPWSTR   pVal,
       DWORD    ValSize
);
#endif

#ifdef WINSDBG
STATIC
VOID
PrintRecs(
        RPL_RR_TYPE_E  RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        );
#endif

/*function defs*/

STATUS
WinsCnfInitConfig(
        VOID
        )
/*++

Routine Description:

        This function opens the registry and reads in all the configuration
        information from it.


Arguments:
        None

Externals Used:
        WinsCnf

Called by:
        Init() in nms.c

Comments:
        None

Return Value:

   Success status codes --
   Error status codes  --

--*/

{
   DWORD  NewKeyInd;
   LONG          RetVal;

   /*
        First and foremost, open (or create if non-existent) the log file
   */
#if 0
   InitLog();
#endif

   RetVal = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                sWinsCfgKey,                //subkey for WINS
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &sConfigRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg)
                );



    if (RetVal != ERROR_SUCCESS)
    {
        WINSEVT_LOG_N_RET_M(
                        WINS_FATAL_ERR,
                        WINS_EVT_CANT_OPEN_WINS_KEY,
                        WINS_FATAL_ERR
                           );
    }

   //
   // Initialize the critical section that guards the fields used
   // by Scavenger thread
   //
   InitializeCriticalSection(&WinsCnfCnfCrtSec);
   InitializeCriticalSection(&g_cs1BFilter);

   /*
        First create the events that will be passed to the
        RegNotifyChangeKeyValue function
   */
try {
   WinsMscCreateEvt(
                        WINS_KEY_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.WinsKChgEvtHdl
                      );
   WinsMscCreateEvt(
                        PARAMETERS_KEY_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.ParametersKChgEvtHdl
                      );
   WinsMscCreateEvt(
                        PARTNERS_KEY_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.PartnersKChgEvtHdl
                      );

}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsCnfInitConfig");
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_CREATE_REG_EVT);
        return(WINS_FAILURE);
}

   //
   // Create the event that this main thread will set when configuration changes
   // The main thread sets this event to notify the scavenger thread (for now)
   // about the changes
   //
   WinsMscCreateEvt(
                        CNF_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.CnfChgEvtHdl
                      );
   //
   // Opens the Partners and Parameters keys
   //
   WinsCnfOpenSubKeys();

   //
   // Read in the registry information
   //
   WinsCnfReadRegInfo(&WinsCnf);


   /*
        Ask to be notified when the Configuration key or any of the subkeys
        change
   */
    WinsCnfAskToBeNotified(WINSCNF_E_WINS_KEY);
    return(WINS_SUCCESS);
}

VOID
WinsCnfReadPartnerInfo(
        PWINSCNF_CNF_T pWinsCnf
        )

/*++

Routine Description:

  This function gets all the information pertaining to the Partners of this
  WINS. Under the configuration key above, there are two Keys PULL and PUSH.
  Under each key, there can be one or more keys (IP addresses). The values
  for each IP address key are:
        Time Interval   (for both Pull and Push IP address keys)
        Update Count        (for Push IP address keys)


Arguments:
        pWinsCnf - Address of Wins Configuration structure

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
   Init function of the Replicator.

Side Effects:

Comments:

    Note: This function should never be called when inside the
    NmsNmhNamRegCrtSec, otherwise a deadlock can occur with the Pull
    thread (check out Reconfig in rplpull.c)
--*/

{

  DWORD                 ValTyp;
  //
  // Initialize the MaxRplTimeInterval field to 0. After we have read
  // both the PULL and PUSH key information from the registry, the above
  // field will contain the max. replication time interval specified for
  // pulling and pushing replicas
  //
  pWinsCnf->MaxRplTimeInterval = 0;

  pWinsCnf->PullInfo.NoOfPushPnrs   = 0;
  pWinsCnf->PullInfo.pPullCnfRecs   = NULL;
  pWinsCnf->PullInfo.RplType        = WINSCNF_RPL_DEFAULT_TYPE;
  pWinsCnf->PullInfo.fOnlyDynRecs   = FALSE;

  pWinsCnf->PushInfo.NoOfPullPnrs   = 0;
  pWinsCnf->PushInfo.pPushCnfRecs   = NULL;
  pWinsCnf->PushInfo.fAddChgTrigger = FALSE;
  pWinsCnf->PushInfo.RplType        = WINSCNF_RPL_DEFAULT_TYPE;
  pWinsCnf->PushInfo.fOnlyDynRecs   = FALSE;
  //
  // Since we are again reading the info about the Partners key, increment
  // the magic no.  No other thread increments this no. The thread that
  // looks at this no is the Pull thread.
  //
  EnterCriticalSection(&WinsCnfCnfCrtSec);
  // don't allow the magic no to be 0. This will be a special case for rpl_req_wrk_itm
  // that don't require a magic number.
  if (WinsCnfCnfMagicNo + 1 == 0)
      ++WinsCnfCnfMagicNo;
  pWinsCnf->MagicNo = ++WinsCnfCnfMagicNo;
  LeaveCriticalSection(&WinsCnfCnfCrtSec);

try {
  GetOwnerList(pWinsCnf);    // get list of persona (grata / non-grata)
  //
  // Read in the RplType DWORD.  Even if no partners are defined, we do this
  // in case this WINS is open to all partners (i.e. fOnlyWCnfPnrs is FALSE)
  //
  QUERY_VALUE_M(
                          sPartnersKey,
                          WINSCNF_RPL_TYPE_NM,
                          ValTyp,
                          pWinsCnf->RplType,
                          0,      // no logging
                          WINSCNF_RPL_DEFAULT_TYPE
                            );

  GetPnrInfo(RPL_E_PULL, pWinsCnf);
  GetPnrInfo(RPL_E_PUSH, pWinsCnf);
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        //
        // If there is some problem with the registry, we don't want
        // to bugcheck WINS.  It can proceed with default values.
        // Since we have already logged the errors, the administrator
        // can take corrective action if necessary
        //
        if (
                (ExcCode != WINS_EXC_CANT_OPEN_KEY)
                         &&
                (ExcCode != WINS_EXC_CANT_QUERY_KEY)
                        &&
                (ExcCode != WINS_EXC_CANT_CLOSE_KEY)
           )
        {
                WINS_RERAISE_EXC_M();
        }
}
  return;
}



STATUS
WinsCnfInitLog(
        VOID
        )

/*++

Routine Description:
        This function open (or creates) a log file for registering events

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        WinsCnfInitConfig

Side Effects:

Comments:
        None
--*/
{

   LONG            RetVal = ERROR_SUCCESS;
   STATUS   RetStat = WINS_SUCCESS;

#ifdef WINS_INTERACTIVE
   DWORD    NewKeyInd;
   TCHAR    Buff[160];
   DWORD    dwData;

   RetVal =  RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                sWinsLogKey,                //subkey for WINS
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &sLogRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg) -- not
                                        //looked at
                );


   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }


   /*
        Set the event id message file name
   */
   lstrcpy(Buff, _WINS_LOG_FILE_NAME);

   /*
       Add the Event-ID message-file name to the subkey
   */
   RetVal = RegSetValueEx(
                        sLogRoot,            //key handle
                        sWinsMsgFileSKey,   //value name
                        0,                    //must be zero
                        REG_EXPAND_SZ,            //value type
                        (LPBYTE)Buff,
                        (lstrlen(Buff) + 1) * sizeof(TCHAR)   //length of value data
                         );

   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }

   /*
     Set the supported data types flags
   */
   dwData = EVENTLOG_ERROR_TYPE       |
            EVENTLOG_WARNING_TYPE     |
            EVENTLOG_INFORMATION_TYPE;


   RetVal = RegSetValueEx (
                        sLogRoot,            //subkey handle
                        TEXT("TypesSupported"),  //value name
                        0,                    //must be zero
                        REG_DWORD,            //value type
                        (LPBYTE)&dwData,    //Address of value data
                        sizeof(DWORD)            //length of value data
                          );

   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }

   /*
    * Done with the key.  Close it
   */
   RetVal = RegCloseKey(sLogRoot);

   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }
#endif
   WinsCnf.LogHdl = RegisterEventSource(
                                (LPCTSTR)NULL,         //use local machine
                                TEXT("Wins")
                                      );
   if (WinsCnf.LogHdl == NULL)
   {
        DBGPRINT1(ERR, "InitLog: RegisterEventSource error = (%x)\n", GetLastError());
        return(WINS_FAILURE);
   }

   WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_LOG_INITED);
   return(RetStat);
}

VOID
LnkWSameMetricValRecs(
        PWINSCNF_CNF_T           pWinsCnf,
        PRPL_CONFIG_REC_T  pCnfRec
        )

/*++

Routine Description:
        This function is called to link a configuration record with all
        other configuration records with the same metric value.  The metric
        to use depends upon the type of the record.  If it is a PULL record,
        the metric is "Time Interval".  If the record is a PUSH record,
        the metric is "Update Count"


Arguments:
        pWinsCnf - Address of configuration block
        pCnfRec - Configuration Record to link.

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        WinsCnfReadPartnerInfo

Side Effects:

Comments:
        The record to be linked is the last record in the buffer of
        records of the same type.
--*/

{
        PRPL_CONFIG_REC_T        pTmp;
        DWORD                        OffMetricToComp;
        LONG                        MetricVal;

        //
        // Set the variables used later based on the record type
        //
        if (pCnfRec->RRTyp_e == RPL_E_PULL)
        {
                pTmp            = pWinsCnf->PullInfo.pPullCnfRecs;
                MetricVal       = pCnfRec->TimeInterval;
                OffMetricToComp = offsetof(RPL_CONFIG_REC_T, TimeInterval);
        }
        else  //it is a PUSH record
        {
                pTmp            = pWinsCnf->PushInfo.pPushCnfRecs;
                MetricVal       = pCnfRec->UpdateCount;
                OffMetricToComp = offsetof(RPL_CONFIG_REC_T, UpdateCount);
        }

        //
        // Link in this record at the end of the linked list of
        // records with the same metric value in the buffer pointed by
        // the starting value of pTmp (set above).
        //
        for (
                ;
                pTmp != pCnfRec;                //until we reach this record
                pTmp = (PRPL_CONFIG_REC_T)((LPBYTE)pTmp + RPL_CONFIG_REC_SIZE)
            )
         {
                //
                // If Metric Value is same, go to end of linked list and
                // link in the record
                //
                if (*((LONG *)((LPBYTE)pTmp + OffMetricToComp)) == MetricVal)
                {
                        //
                        // Note: if the metric is UpdateCount (Push records)
                        // then, the following if will fail.
                        //

                        //
                        // If both records have a specific time for replication,
                        // that time must agree too
                        //
                        if (pTmp->fSpTime &&  pCnfRec->fSpTime)
                        {
                                //
                                // If specific time is not the same, go to the
                                // next record in the array
                                //
                                if (pTmp->SpTimeIntvl != pCnfRec->SpTimeIntvl)
                                {
                                        continue;
                                }
                        }

                        for(
                                ;
                                pTmp->pNext != NULL;
                                pTmp = pTmp->pNext
                           )
                                ;        //NULL body

                        pTmp->pNext            = pCnfRec;

                        //
                        // Set flag to indicate that this record has
                        // been linked. Used in SubmitTimerReqs in rplpull.c
                        //
                        pCnfRec->fLinked = TRUE;
                        break;  //record is linked. break out of the loop
                }

        }  //end of for { .. } for looping over all records in the buffer

        //
        // Make pNext to NULL since this is the last record in the buffer
        // buffer of Config Records (also in the chain if records with
        // the same metric)
        //
        pCnfRec->pNext = NULL;
        return;
}





VOID
WinsCnfSetLastUpdCnt(
        PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:

        This function is called at initialization/reinitialization time if
        InitTimePush registry variable is set to 1) to set the LastVersNo
        field of all Push Configuration records to the value of the
        NmsNmhMyMAxVersNo counter.  This is done to avoid Push Notifications
        to be sent at Init time.

Arguments:
        pWinsCnf - Wins Configuration Info

Externals Used:
        NmsNmhMyMaxVersNo

Return Value:
        None

Error Handling:

Called by:
        NmsDbInit, Reinit (in nms.c)

Side Effects:

Comments:
        This function is called only after the local Database
        Name-Address mapping table has been read and NmsNmhMyMaxVersNo
        counter initialized (see GetMaxVersNos in nmsdb.c).  Also,
        this function is called only if the counter value is > 0
--*/

{
        PRPL_CONFIG_REC_T pCnfRec = pWinsCnf->PushInfo.pPushCnfRecs;

        for (
                ;   //null expr 1
                pCnfRec->WinsAdd.Add.IPAdd != INADDR_NONE;
                pCnfRec = (PRPL_CONFIG_REC_T)(
                               (LPBYTE) pCnfRec + RPL_CONFIG_REC_SIZE
                                             )
            )
        {
                //
                // If the Update count field is invalid, go to the next record
                //
                if (pCnfRec->UpdateCount == RPL_INVALID_METRIC)
                {
                        continue;
                }

                pCnfRec->LastVersNo = NmsNmhMyMaxVersNo;
        }

        return;
}

VOID
GetPnrInfo(
        RPL_RR_TYPE_E  RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        )

/*++

Routine Description:
        This function is called to read PULL/PUSH records

Arguments:
        RRType_e - Type of Information to read (PULL or PUSH records)
        pWinsCnf  - Configuration structure


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsCnfReadPartnerInfo

Side Effects:

Comments:
        None
--*/

{

  LONG                  RetVal;
  HKEY                  CnfKey;
  TCHAR                 KeyName[20]; // will hold name of subkey of
                                     // PULL/PUSH records. These keys are IP
                                     // addresses for which 20 is a
                                     // big enough size

  CHAR                  AscKeyName[20];
  DWORD                 KeyNameSz;
  FILETIME              LastWrite;
  DWORD                 BuffSize;
  HKEY                  SubKey;
  DWORD                 ValTyp;
  DWORD                 Sz;
  PRPL_CONFIG_REC_T     paCnfRecs;
  DWORD                 NoOfPnrs   = 0;    //# of valid PULL or PUSH pnrs
  DWORD                 NoOfPnrsSv;        //# of valid PULL or PUSH pnrs saved
  DWORD                 NoOfVals;
  DWORD                 InitTime;
  DWORD                 IndexOfPnr = 0;   //total # of pnrs
  DWORD                 RplType;
  SYSTEMTIME            CurrTime;

  //
  // Get the current time.  It may be needed if we have partners with SpTime
  // specified.
  //
  if (RRType_e == RPL_E_PULL)
  {
        GetLocalTime(&CurrTime);
  }

   /*
   *  Open the key (PULL/PUSH)
   */
   RetVal =   RegOpenKeyEx(
                sConfigRoot,                //predefined key value
                RRType_e == RPL_E_PULL ?
                        _WINS_CFG_PULL_KEY :
                        _WINS_CFG_PUSH_KEY,        //subkey for WINS
                0,                        //must be zero (reserved)
                KEY_READ,                //we desire read access to the keyo
                &CnfKey                        //handle to key
                );

   if (RetVal != ERROR_SUCCESS)
   {

CHECK("Is there any need to log this")
        WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_CANT_OPEN_PULL_KEY :
                                        WINS_EVT_CANT_OPEN_PUSH_KEY
                         );
   }
   else   //key was successfully opened
   {
        // regardless whether there are replication partners or not,
        // we need to read the OnlyDynRecs setting for each type of replication
        // This setting might get used when replicating with non-partners (i.e.
        // during consistency checking.
        if (RRType_e == RPL_E_PULL)
        {
            QUERY_VALUE_M(
                            CnfKey,
                            WINSCNF_ONLY_DYN_RECS_NM,
                            ValTyp,
                            pWinsCnf->PullInfo.fOnlyDynRecs,
                            0,
                            FALSE // by default, OnlyDynRecs is false for non-partners
                         );
        }
        else
        {
            QUERY_VALUE_M(
                            CnfKey,
                            WINSCNF_ONLY_DYN_RECS_NM,
                            ValTyp,
                            pWinsCnf->PushInfo.fOnlyDynRecs,
                            0,
                            FALSE // by default, OnlyDynRecs is false for non-partners
                         );
        }

        /*
        *        Query the key.  The subkeys are IP addresses of PULL
        *      partners.
        */
        GetKeyInfo(
                        CnfKey,
                        (RRType_e == RPL_E_PULL ? WINSCNF_E_PULL_KEY :
                                                WINSCNF_E_PUSH_KEY),
                        &NoOfPnrs,
                        &NoOfVals   //ignored
                      );

        if (NoOfPnrs == 0)
        {

             WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_NO_SUBKEYS_UNDER_PULL  :
                                        WINS_EVT_NO_SUBKEYS_UNDER_PUSH
                                );
        }
        else
        {

                //
                // Since we have one or more Partners to replicate with,
                // read in the value of the InitTimeReplication attribute
                // of all such Partners
                //
                QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_INIT_TIME_RPL_NM,
                                ValTyp,
                                InitTime,
                                0, //WINS_EVT_CANT_GET_INITRPL_VAL,
                                DO_INIT_TIME_RPL
                             );

                //
                // Since we have one or more Partners to replicate with,
                // read in the value of the RplType attribute
                //
                QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_RPL_TYPE_NM,
                                ValTyp,
                                RplType,
                                0,
                                pWinsCnf->RplType
                             );
#if PRSCONN
               QUERY_VALUE_M(
                                   CnfKey,
                                   WINSCNF_PRS_CONN_NM,
                                   ValTyp,
                                   pWinsCnf->fPrsConn,
                                   0,
                                   TRUE
                                );
#endif
                //
                // Allocate buffer big enough to hold data for
                // the number of subkeys found under the PULL key
                //
                BuffSize = RPL_CONFIG_REC_SIZE * (NoOfPnrs + 1);
                WinsMscAlloc( BuffSize, &paCnfRecs);

                if (RRType_e == RPL_E_PULL)
                {
                        pWinsCnf->PullInfo.pPullCnfRecs = paCnfRecs;
                        QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_RETRY_COUNT_NM,
                                ValTyp,
                                pWinsCnf->PullInfo.MaxNoOfRetries,
                                0, //WINS_EVT_CANT_GET_RETRY_COUNT,
                                WINSCNF_MAX_COMM_RETRIES
                             );
                }
                else
                {
                        //
                        // Get the value of the field that indicates
                        // whether we should send a trigger when the
                        // address of an owned entry changes.
                        //
                        Sz = sizeof(pWinsCnf->PushInfo.fAddChgTrigger);
                        RetVal = RegQueryValueEx(
                                     CnfKey,
                                     WINSCNF_ADDCHG_TRIGGER_NM,
                                     NULL,        //reserved; must be NULL
                                     &ValTyp,
                                     (LPBYTE)&pWinsCnf->PushInfo.fAddChgTrigger,
                                     &Sz
                                                );

                        if (RetVal != ERROR_SUCCESS)
                        {
                            pWinsCnf->PushInfo.fAddChgTrigger = FALSE;
                        }
                        else
                        {
                            pWinsCnf->PushInfo.fAddChgTrigger =
                                (pWinsCnf->PushInfo.fAddChgTrigger >= 1);

                        }

                        QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_PROP_NET_UPD_NTF,
                                ValTyp,
                                pWinsCnf->PushInfo.PropNetUpdNtf,
                                0,                    //no event
                                DO_PROP_NET_UPD_NTF
                             );

                        pWinsCnf->PushInfo.pPushCnfRecs = paCnfRecs;
                        pWinsCnf->PushInfo.NoPushRecsWValUpdCnt = 0;
                }

                /*
                *   For each key, get the values (Time Interval/UpdateCount,
                *   etc)
                */
                NoOfPnrsSv = NoOfPnrs;  //save the number that we got from the
                                        //GetkeyInfo function
                for(
                     IndexOfPnr = 0, NoOfPnrs = 0;
                     NoOfPnrs < NoOfPnrsSv;  //no of valid pnrs < the total #
                     IndexOfPnr++
                   )
                {
                        KeyNameSz = sizeof(KeyName)/sizeof(TCHAR);  //init before every call
                        RetVal = RegEnumKeyEx(
                                CnfKey,
                                IndexOfPnr,       //Index Of Pnr
                                KeyName,
                                &KeyNameSz,
                                NULL,           //reserved
                                NULL,           //don't need class name
                                NULL,           //ptr to var. to hold class name
                                &LastWrite      //not looked at by us
                                );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                //
                                // No more ip address keys to get
                                //
                                break;
                        }

                        //
                        // Store pointer to the Wins Config structure in
                        // the configuration record
                        //
                        paCnfRecs->pWinsCnf = pWinsCnf;

                        //
                        // pWinsCnf->MagicNo contains the value of
                        // WinsCnfCnfMagicNo
                        //
                        paCnfRecs->MagicNo  = pWinsCnf->MagicNo;
                        paCnfRecs->RRTyp_e  = RRType_e;

#ifdef UNICODE
                        if (wcstombs(AscKeyName, KeyName, KeyNameSz) == -1)
                        {
                                DBGPRINT0(ERR,
                           "Conversion not possible in the current locale\n");
                        }
                        AscKeyName[KeyNameSz] = EOS;

NONPORT("Call a comm function to do this")
                        paCnfRecs->WinsAdd.Add.IPAdd = inet_addr(AscKeyName);
#else
                        paCnfRecs->WinsAdd.Add.IPAdd = inet_addr(KeyName);
#endif

                        //
                        // inet_addr returns bytes in network byte order
                        // (Left to Right).  Let us convert this into host
                        // order.  This will avoid confusion later on. All
                        // formatting functions expect address to be in host
                        // order.
                        //
                        paCnfRecs->WinsAdd.AddLen = COMM_IP_ADD_SIZE;
                        paCnfRecs->WinsAdd.AddTyp_e = COMM_ADD_E_TCPUDPIP;
                        paCnfRecs->WinsAdd.Add.IPAdd = ntohl(
                                             paCnfRecs->WinsAdd.Add.IPAdd
                                                    );
                        if (COMM_ADDRESS_SAME_M(&NmsLocalAdd, &paCnfRecs->WinsAdd))
                        {
                                //
                                // Invalid partner. Ignore. NoOfPnrs will
                                // not be incremented.  Also, the buffer
                                // pointer stays the same
                                //
                                continue;
                        }
                        RetVal = RegOpenKeyEx(
                                                CnfKey,
                                                KeyName,
                                                0,        //reserved; must be 0
                                                KEY_READ,
                                                &SubKey
                                                    );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                WINSEVT_LOG_M(
                                        WINS_FATAL_ERR,
                                        RRType_e == RPL_E_PULL ?
                                                WINS_EVT_CANT_OPEN_PULL_SUBKEY :
                                                WINS_EVT_CANT_OPEN_PUSH_SUBKEY
                                             );
FUTURES("It is possible that the user deleted the key. Recover from this")
                               if (RRType_e == RPL_E_PULL)
                               {
                                pWinsCnf->PullInfo.NoOfPushPnrs = 0;
                                WinsMscDealloc(pWinsCnf->PullInfo.pPullCnfRecs);
                                pWinsCnf->PullInfo.pPullCnfRecs = NULL;
                               }
                               else
                               {
                                pWinsCnf->PushInfo.NoOfPullPnrs = 0;
                                WinsMscDealloc(pWinsCnf->PushInfo.pPushCnfRecs);
                                pWinsCnf->PushInfo.pPushCnfRecs = NULL;
                               }
                               WINS_RAISE_EXC_M(WINS_EXC_CANT_OPEN_KEY);
                        }

FUTURES("Maybe, we will support a time interval attribute for Push records")
FUTURES("when that is done, LnkRecsWSameMetric would need to be updated")

                        if (RRType_e == RPL_E_PULL)
                        {

                           //
                           // Read in specific time for replication if one
                           // has been specified
                           //
                           GetSpTimeData(SubKey, &CurrTime, &paCnfRecs->fSpTime, &paCnfRecs->SpTimeIntvl);

                           Sz = sizeof(paCnfRecs->TimeInterval);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_RPL_INTERVAL_NM,
                                               NULL,        //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&paCnfRecs->TimeInterval,
                                               &Sz
                                                );

                           if (RetVal != ERROR_SUCCESS)
                           {
                                WINSEVT_LOG_INFO_D_M(
                                        WINS_SUCCESS,
                                        WINS_EVT_CANT_GET_PULL_TIMEINT
                                                    );
                                paCnfRecs->TimeInterval = RPL_INVALID_METRIC;
                           }
                           else  // a value was read in
                           {
                                //
                                // If the time interval is less than or
                                // equal to the minimum allowed, use the
                                // default minimum
                                //
                                if (paCnfRecs->TimeInterval
                                        < WINSCNF_MIN_VALID_RPL_INTVL)
                                {
                                        paCnfRecs->TimeInterval =
                                                WINSCNF_MIN_VALID_RPL_INTVL;
                                }
                                if (
                                   (DWORD)paCnfRecs->TimeInterval >
                                                 pWinsCnf->MaxRplTimeInterval
                                   )
                                {
                                        pWinsCnf->MaxRplTimeInterval =
                                                       paCnfRecs->TimeInterval;
                                }
                           }

                           //
                           // Read in the precedence level.  This can currently
                           // be either HIGH (> 0) or LOW (0).
                           //
                           Sz = sizeof(paCnfRecs->MemberPrec);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_MEMBER_PREC_NM,
                                               NULL,   //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&paCnfRecs->MemberPrec,
                                               &Sz
                                                );
                           if (RetVal != ERROR_SUCCESS)
                           {
                                paCnfRecs->MemberPrec =  WINSCNF_LOW_PREC;
                           }
                           else
                           {
                                paCnfRecs->MemberPrec =
                                  (paCnfRecs->MemberPrec > 0) ?
                                         WINSCNF_HIGH_PREC : WINSCNF_LOW_PREC;
                           }

#if PRSCONN
                           QUERY_VALUE_M(
                                SubKey,
                                WINSCNF_PRS_CONN_NM,
                                ValTyp,
                                paCnfRecs->fPrsConn,
                                0,
                                pWinsCnf->fPrsConn
                             );
#endif
                        }
                        else  // it is a PUSH record
                        {

                                //
                                // Currently, we don't support periodic
                                // or specific time replication for Push
                                // records
                                //
                                paCnfRecs->fSpTime = FALSE;

#if PRSCONN
                                QUERY_VALUE_M(
                                   SubKey,
                                   WINSCNF_PRS_CONN_NM,
                                   ValTyp,
                                   paCnfRecs->fPrsConn,
                                   0,
                                   pWinsCnf->fPrsConn
                                );
#endif

                                Sz = sizeof(paCnfRecs->UpdateCount);
                                RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_UPDATE_COUNT_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&paCnfRecs->UpdateCount,
                                                &Sz
                                                        );

                                if (RetVal != ERROR_SUCCESS)
                                {
                                        paCnfRecs->UpdateCount =
                                                        RPL_INVALID_METRIC;
                                }
                                else
                                {
                                        paCnfRecs->LastVersNo.QuadPart = 0;
#if PRSCONN
                                        if (!paCnfRecs->fPrsConn && !sfNoLimitChk)
#else
                                        if (!sfNoLimitChk)
#endif
                                        {
                                          if (paCnfRecs->UpdateCount <
                                                 WINSCNF_MIN_VALID_UPDATE_CNT)
                                          {
                                                paCnfRecs->UpdateCount =
                                                   WINSCNF_MIN_VALID_UPDATE_CNT;
                                          }
                                        }
                                        else
                                        {
                                             if (paCnfRecs->UpdateCount == 0)
                                             {
                                                 paCnfRecs->UpdateCount = 1;
                                             }
                                        }
                                        pWinsCnf->PushInfo.NoPushRecsWValUpdCnt++;
                                }



                        }


#if MCAST > 0
                        Sz = sizeof(paCnfRecs->fSelfFnd);
                        RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_SELF_FND_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&paCnfRecs->fSelfFnd,
                                                &Sz
                                                        );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                paCnfRecs->fSelfFnd = FALSE;
                        }
#endif

                        Sz = sizeof(paCnfRecs->fOnlyDynRecs);
                        RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_ONLY_DYN_RECS_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&paCnfRecs->fOnlyDynRecs,
                                                &Sz
                                                        );

                        if (RetVal != ERROR_SUCCESS)
                        {
                            // if this key is not defined for this repl partner, take as default the
                            // general fOnlyDynRecs flag for the respective replication type
                            paCnfRecs->fOnlyDynRecs = RRType_e == RPL_E_PULL ?
                                                        pWinsCnf->PullInfo.fOnlyDynRecs :
                                                        pWinsCnf->PushInfo.fOnlyDynRecs;
                        }

                        QUERY_VALUE_M(
                                SubKey,
                                WINSCNF_RPL_TYPE_NM,
                                ValTyp,
                                paCnfRecs->RplType,
                                0,
                                pWinsCnf->RplType
                             );


                        if (paCnfRecs->RplType != 0)
                        {
                          WINSEVT_LOG_INFO_M(paCnfRecs->WinsAdd.Add.IPAdd, WINS_EVT_PARTIAL_RPL_TYPE);
                        }

#if PRSCONN
                        if (paCnfRecs->fPrsConn != 0)
                        {
                           paCnfRecs->fPrsConn = TRUE;
                        }
#endif

                        REG_M(
                                RegCloseKey(SubKey),
                                WINS_EVT_CANT_CLOSE_KEY,
                                WINS_EXC_CANT_CLOSE_KEY
                             );

                        //
                        // Initialize the retry count to 0 and the fLinked flag
                        // to FALSE
                        //
                        //used when pulling
                        //
                        paCnfRecs->RetryCount              = 0;

                        paCnfRecs->fLinked              = FALSE;

                        //
                        // Initialize the following to 0 so that once we stop
                        // communicating with a WINS we can start again when
                        // the following count reaches
                        // WINSCNF_RETRY_AFTER_THIS_MANY_RPL
                        //
                        paCnfRecs->RetryAfterThisManyRpl = 0;


#if PRSCONN
                        ECOMM_INIT_DLG_HDL_M(&paCnfRecs->PrsDlgHdl);
                        paCnfRecs->LastCommTime = 0;
#endif

                        //
                        // Initialize LastCommFailTime to 0. Used by
                        // SndPushNtf in rplpull.c
                        //

                        paCnfRecs->LastCommFailTime = 0;
                        paCnfRecs->PushNtfTries   = 0;

                        //
                        // Link the record with other PULL records with the same
                        // Time Interval
                        //
                        LnkWSameMetricValRecs(pWinsCnf, paCnfRecs);
                        //
                        // Mark the record as permanent (i.e. it will stay
                        // around until a reconfiguration or until the process
                        // terminates
                        //
                        paCnfRecs->fTemp = FALSE;

                        NoOfPnrs++;
                        paCnfRecs = (PRPL_CONFIG_REC_T)(
                                        (LPBYTE)paCnfRecs +
                                                RPL_CONFIG_REC_SIZE);
                } // end of for {..} for looping over subkeys of PULL

                //
                // GetReplicasNew expects the list to be terminated with a
                // record with INADDR_NONE as the address
                //
                paCnfRecs->WinsAdd.Add.IPAdd = INADDR_NONE;
                if (RRType_e == RPL_E_PULL)
                {
                      pWinsCnf->PullInfo.NoOfPushPnrs = NoOfPnrs;
                      pWinsCnf->PullInfo.InitTimeRpl  = InitTime;
                      pWinsCnf->PullInfo.RplType      = RplType;
                }
                else
                {
                      pWinsCnf->PushInfo.NoOfPullPnrs = NoOfPnrs;
                      pWinsCnf->PushInfo.InitTimePush = InitTime;
                      pWinsCnf->PushInfo.RplType      = RplType;

                      //
                      // Now that we are done with the Push record list,
                      //let us  sort it on the update count field
                      //
                      //
                      // Sort the array in increasing order of Update Counts
                      //

FUTURES("May use qsort to optimize the update notification process")
CHECK("Not sure yet whether sorting would optimize it")
#if 0
CHECK("this is resulting in compilation warnings.  haven't figured out")
CHECK("yet why.")
                      qsort(
                                pWinsCnf->pPushCnfRecs,        //start of array
                                (size_t)pWinsCnf->NoOfPullPnrs,//no of elements
                                RPL_CONFIG_REC_SIZE,        //size of each
                                                            //element
                                CompUpdCnt                    //compare func
                             );
#endif

                 } //end of else (It is PULL key)
            } // end of else (NoOfPnrs == 0)

            /*
             * Close the  key
            */
            REG_M(
                RegCloseKey(CnfKey),
                WINS_EVT_CANT_CLOSE_KEY,
                WINS_EXC_CANT_CLOSE_KEY
                      );
   } //end of else  (key could not be opened)
#if 0
#ifdef WINSDBG
     PrintRecs(RRType_e, pWinsCnf);
#endif
#endif

     return;
} // GetPnrInfo


VOID
GetOwnerList(
  PWINSCNF_CNF_T  pWinsCnf
 )

/*++

Routine Description:
  This function reads the list of owners whose records should be or should not be pulled
  from a partner WINS.


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
    LONG        RetVal;
    DWORD       dwValType;    // type of the reg value
    LPSTR       pValName;     // pointer to the reg 
    LPBYTE      pValData;     // pointer to the reg value's data
    DWORD       dwValDataLen; // length of the reg value's data

    DBGENTER("GetOwnerList\n");

    // query for the type of persona (grata (1) / non-grata (0))
    pWinsCnf->fPersonaGrata = 0;
    dwValDataLen = sizeof(DWORD);
    RetVal = RegQueryValueExA(
                sPartnersKey,                       // reg key [HKLM\System\CCS\Services\Wins\Partners]
                WINSCNF_PERSONA_MODE_NM,            // name of the value: "PersonaType"
                NULL,                               // reserved; must be NULL
                &dwValType,                         // type of the value: should get REG_DWORD
                (LPVOID)&(pWinsCnf->fPersonaGrata), // value data
                &dwValDataLen);                     // size of the value's data
    // if this call didn't succeed, we go on with the default which is 0, 'non-grata'

    // get the actual entry we're going to pick the list of addresses from
    pValName = pWinsCnf->fPersonaGrata ? 
                WINSCNF_PERSONA_GRATA_NM : 
                WINSCNF_PERSONA_NON_GRATA_NM;

    // get the size of the data from the registry
    // since Sz is 0, if there are any personas
    // grata/non-grata then we should get ERROR_MORE_DATA
    // if we get a different error than just remove the current list
    dwValDataLen = 0;
    RetVal = RegQueryValueExA(
                sPartnersKey,           // reg key [HKLM\System\CCS\Services\Wins\Partners]
                pValName,               // name of the value: "PersonaList"
                NULL,                   // reserved; must be NULL
                &dwValType,             // type of the value: should get REG_MULTI_SZ
                (LPVOID)&pValData,      // dummy address
                &dwValDataLen);         // initially 0 since we try to determine the actual size
    // this call should return ERROR_MORE_DATA for a REG_MULTI_SZ value

    // clear-up the old buffer
    if (pWinsCnf->pPersonaList != NULL)
    {
        WinsMscDealloc(pWinsCnf->pPersonaList);
    }
    pWinsCnf->NoOfPersona = 0;
    pWinsCnf->pPersonaList = NULL;

    // check if there is a valid value, with the expected type; return if not
    if (RetVal != ERROR_MORE_DATA || dwValType != REG_MULTI_SZ)
    {
        DBGLEAVE("GetOwnerList\n");
        return;
    }

    // allocate the needed buffer
    WinsMscAlloc(dwValDataLen, &pValData);

    // now query for the data value with a buffer large enough
    RetVal = RegQueryValueExA(
                sPartnersKey,
                pValName,
                NULL,                       // reserved; must be NULL
                &dwValType,
                (LPVOID)pValData,           // now this is the real address
                &dwValDataLen);

    // ERROR_SUCCESS is expected here
    if (RetVal == ERROR_SUCCESS)
    {
        LPBYTE pString = pValData;

        // count in nAddr the number of addresses in the string
        for( pWinsCnf->NoOfPersona=0; *pString; pWinsCnf->NoOfPersona++)
            pString+= strlen(pString)+1;

        // see if there are any addresses there
        if (pWinsCnf->NoOfPersona > 0)
        {
            COMM_IP_ADD_T IpAdd;

            // allocate an array of nAddr COMM_ADD_T structures
            WinsMscAlloc(
                (pWinsCnf->NoOfPersona) * sizeof(COMM_ADD_T),
                &(pWinsCnf->pPersonaList));

            // loop through the string of addresses and convert 
            // them to COMM_IP_ADD_T structures
            for (pString = pValData, pWinsCnf->NoOfPersona = 0;
                *pString;
                pString += strlen(pString) + 1)
            {
                if ((IpAdd = inet_addr(pString)) != -1)
                {
                    // initialize a COMM_ADD_T structure only if the string token is
                    // indeed an IP address
                    (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].AddTyp_e = COMM_ADD_E_TCPUDPIP;
                    (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].AddLen = COMM_IP_ADD_SIZE;
                    (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].Add.IPAdd = ntohl(IpAdd);

                    DBGPRINT2(
                        DET,
                        "GetOwnerList: Address[%d] = %x\n",
                        pWinsCnf->NoOfPersona,
                        (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].Add.IPAdd);

                    pWinsCnf->NoOfPersona++;
                } //end 'if valid ip address'
            } //end 'for each token in the string'

            // if there are at least two addresses in the list,
            // sort them in ascending order
            if (pWinsCnf->NoOfPersona > 1)
            {
                qsort(pWinsCnf->pPersonaList,
                      (size_t)pWinsCnf->NoOfPersona,
                      sizeof(COMM_ADD_T),
                      ECommCompareAdd);
            }
            else
            {
                DBGPRINT0(DET, "GetOwnerList: No valid address found\n");
            } //end 'if there are more than two addresses picked up'

        } //end 'if there are any tokens at all'
    } //end 'if string could be read successfully from the registry'

    // the string buffer is no longer needed here
    WinsMscDealloc(pValData);

#ifdef WINSDBG
    {
        DWORD tstNAddrs;
        PCOMM_ADD_T tstPAddrs;
        DWORD i;

        DBGPRINT1(
            DET,
            "GetOwnerList: Persona %sGrata List:\n",
            pWinsCnf->fPersonaGrata ? "" : "Non-");

        tstNAddrs = pWinsCnf->NoOfPersona;
        tstPAddrs = pWinsCnf->pPersonaList;
        for (i = 0; i < tstNAddrs; i++)
        {
            DBGPRINT2(
                DET,
                "GetOwnerList:PersonaList[%d] = %08x\n",
                i,
                tstPAddrs[i].Add.IPAdd);
        }
    }
#endif

    DBGLEAVE("GetOwnerList\n");
    return;
}

LONG
ReadClusterIp(
    HKEY    KeyHandle,
    DWORD   *IpAddress
    )
{
    DWORD           Sz;
    LONG            RetVal;
    DWORD           ValTyp;
    TCHAR            DirPath[WINS_MAX_FILENAME_SZ];

    *IpAddress = 0;
    // Read the wins cluster name
    Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
    RetVal = RegQueryValueEx(
                         KeyHandle,
                         WINSCNF_CLUSTER_RESOURCE_NM,
                         NULL,                //reserved; must be NULL
                         &ValTyp,
                         (LPBYTE)DirPath,
                         &Sz
                         );

    if ((RetVal == ERROR_SUCCESS) && (DirPath[0] != (TCHAR)EOS))
    {
         HCLUSTER     hCluster;
         HRESOURCE    hResource;
         CHAR         IpAddressStr[sizeof ("xxx.xxx.xxx.xxx")];
         WCHAR        IpAddressWStr[sizeof ("xxx.xxx.xxx.xxx")];
         DWORD        i;
         HMODULE      Dll1, Dll2;
         #define      FUNC_TBL_ENTRY( _Dll, _Name ) { _Dll, &(#_Name)[1], NULL }
         #define      CALL_FUNC( _Func)     (PVOID)( *FuncTbl[_Func].FuncHdl )
         enum {
             _OpenCluster,
             _OpenClusterResource,
             _CloseCluster,
             _CloseClusterResource,
             _ResUtilGetResourceDependentIPAddressProps
         };
         struct {
             HMODULE     *Dll;
             LPCSTR       FuncName;
             FARPROC      FuncHdl;
         } FuncTbl[] = {
             FUNC_TBL_ENTRY( &Dll1,_OpenCluster),
             FUNC_TBL_ENTRY( &Dll1,_OpenClusterResource),
             FUNC_TBL_ENTRY( &Dll1,_CloseCluster),
             FUNC_TBL_ENTRY( &Dll1,_CloseClusterResource),
             FUNC_TBL_ENTRY( &Dll2,_ResUtilGetResourceDependentIPAddressProps)
         };


         DBGPRINT1(DET, "WinsCnfReadWinsInfo: ClusterResourceName is (%ws)\n", DirPath);
         hCluster = NULL;
         hResource = NULL;
         Dll1 = Dll2 = NULL;
        do {
             Dll1 = LoadLibrary(TEXT("clusapi.dll"));
             if (!Dll1) {
                 RetVal = GetLastError();
                 break;
             }
             Dll2 = LoadLibrary(TEXT("resutils.dll"));
             if (!Dll2) {

                 RetVal = GetLastError();
                 break;
             }
             for (i=0; i<(sizeof(FuncTbl)/sizeof(FuncTbl[0])); i++) {
                 FuncTbl[i].FuncHdl = GetProcAddress(*FuncTbl[i].Dll, FuncTbl[i].FuncName);
                 if (!FuncTbl[i].FuncHdl) {
                     RetVal = GetLastError();
                     break;
                 }
             }
             if (i<(sizeof(FuncTbl)/sizeof(FuncTbl[0]))) {
                 break;
             }
             hCluster = CALL_FUNC(_OpenCluster)( NULL );
             if (!hCluster) {
                 RetVal = GetLastError();
                 break;
             }
             hResource = CALL_FUNC(_OpenClusterResource)(hCluster, DirPath);
             if (!hResource) {
                 RetVal = GetLastError();
                 break;
             }
             Sz = sizeof (IpAddressWStr);
             RetVal = PtrToLong(CALL_FUNC(_ResUtilGetResourceDependentIPAddressProps)(
                         hResource,
                         IpAddressWStr,
                         &Sz,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                         ));
             if (ERROR_SUCCESS != RetVal) {
                 break;
             }
             WinsMscConvertUnicodeStringToAscii((LPBYTE)IpAddressWStr, IpAddressStr, sizeof(IpAddressStr));
             *IpAddress = ntohl(inet_addr(IpAddressStr));
             DBGPRINT1(DET, "ReadClusterIp: Cluster IpAddress is (%lx)\n", *IpAddress);
        } while ( FALSE );
        if( hResource ) CALL_FUNC(_CloseClusterResource)(hResource);
        if( hCluster ) CALL_FUNC(_CloseCluster) (hCluster);
        if ( Dll1 ) FreeLibrary(Dll1);
        if ( Dll2 ) FreeLibrary(Dll2);
    }

    return RetVal;
}

extern DOM_CACHE_T sDomCache;

VOID
WinsCnfReadWinsInfo(
        PWINSCNF_CNF_T pWinsCnf
        )

/*++

Routine Description:
        This function reads information (excluding subkeys) about
        the local WINS

Arguments:
        None

Externals Used:
        sConfigRoot,

Return Value:
        None

Error Handling:

Called by:
        WinsCnfInitConfig

Side Effects:

Comments:
        None
--*/

{

        DWORD           Sz;
        LONG            RetVal;
        DWORD           ValTyp;
        VERS_NO_T       MaxVersNo;
        WINSEVT_STRS_T  EvtStr;
        TCHAR            DirPath[WINS_MAX_FILENAME_SZ];
        TCHAR            Path2[WINS_MAX_FILENAME_SZ];
        LPTSTR          pHoldFileName;
        DWORD           fUse351Db;
        DWORD           fUse4Db;
        EvtStr.NoOfStrs = 1;

try {

#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
        //
        // Read the value of WinsDbg. Though this value is
        // being used concurrently by multiple threads (at reinit time), we
        // don't enter any critical section here.  This value
        // is used only for debugging
        //
        WinsCnfReadWinsDbgFlagValue();
#endif

        Sz = sizeof(pWinsCnf->LogDetailedEvts);
        (VOID)RegQueryValueEx(
                             sParametersKey,
                             WINSCNF_LOG_DETAILED_EVTS_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             (LPBYTE)&pWinsCnf->LogDetailedEvts,
                             &Sz
                                );

        // Read in the 1B filter. If the "Filter1BRequests" is there and it is a REG_MULTI_SZ
        // then the filter is created for each of the names specified there. When R_WinsGetBrowserNames
        // is called, the database is filtered only for the name present in the filter.
        RetVal = RegQueryValueExW(
                    sParametersKey,
                    WINSCNF_FILTER1BREQUESTS_NM,
                    NULL,
                    &ValTyp,
                    NULL,
                    &Sz);

        if (RetVal == ERROR_SUCCESS && ValTyp == REG_MULTI_SZ)
        {
            LPWSTR str1BFilters = NULL;
            LPWSTR p1BFilter;

            WinsMscAlloc(Sz, &str1BFilters);

            if (RegQueryValueExW(
                    sParametersKey,
                    WINSCNF_FILTER1BREQUESTS_NM,
                    NULL,
                    &ValTyp,
                    (LPBYTE)str1BFilters,
                    &Sz) == ERROR_SUCCESS)
            {
                EnterCriticalSection(&g_cs1BFilter);

                try
                {
                    g_p1BFilter = InitNmFilter(g_p1BFilter);

                    p1BFilter = str1BFilters;
                    do
                    {
                        DWORD nLenFilter = wcslen(p1BFilter);
                        CHAR  strOemName[17];
                        OEM_STRING      oemString;
                        UNICODE_STRING  unicodeString;

                        if (nLenFilter == 0)
                            break;

                        memset(strOemName, ' ', 16);
                        strOemName[16]=0;
                        if (nLenFilter > 15)
                            p1BFilter[16]=L'\0';

                        RtlInitUnicodeString(&unicodeString, p1BFilter);
                        RtlInitString(&oemString, strOemName);
                        RtlUpcaseUnicodeStringToOemString(&oemString, &unicodeString, FALSE);

                        strOemName[strlen(strOemName)] = ' ';
                        strOemName[15] = strOemName[0];
                        strOemName[0]  = 0x1B;
                        InsertNmInFilter(g_p1BFilter, strOemName, 16);
                        p1BFilter += nLenFilter+1;
                    }
                    while(TRUE);
                }
                finally
                {
                    LeaveCriticalSection(&g_cs1BFilter);
                }
            }

            WinsMscDealloc(str1BFilters);
        }
        else
        {
            // if the reg key is not there, reset the filter - all names will be returned.
            EnterCriticalSection(&g_cs1BFilter);
            try
            {
                g_p1BFilter = DestroyNmFilter(g_p1BFilter);
            }
            finally
            {
                g_p1BFilter = NULL;
                LeaveCriticalSection(&g_cs1BFilter);
            }
        }

        sDomCache.bRefresh = TRUE;

        //
        // Read in the fAdd1Bto1CQueries parameter. Default is TRUE
        // meaning: when processing name queries for 1C names, prepend the
        // response with the 1B name (browser name).
        //
        pWinsCnf->fAdd1Bto1CQueries = TRUE;
        Sz = sizeof(pWinsCnf->fAdd1Bto1CQueries);
        (VOID)RegQueryValueEx(
                            sParametersKey,
                            WINSCNF_ADD1BTO1CQUERIES_NM,
                            NULL,
                            &ValTyp,
                            (LPBYTE)&pWinsCnf->fAdd1Bto1CQueries,
                            &Sz
                            );
        //
        // Read in the cap value on the number of worker threads.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_MAX_NO_WRK_THDS_NM,
                        ValTyp,
                        pWinsCnf->MaxNoOfWrkThds,
                        0,
                        0   //WINSTHD_DEF_NO_NBT_THDS
                      );

        //
        // Check if the user needs to override our checks.
        //
        sfNoLimitChk = pWinsCnf->MaxNoOfWrkThds & NO_LIMIT_CHK_FLAG;
        if (sfNoLimitChk)
        {
            WINSEVT_LOG_M(pWinsCnf->LogDetailedEvts, WINS_EVT_INTERNAL_FEATURE);
            pWinsCnf->MaxNoOfWrkThds &= ~NO_LIMIT_CHK_FLAG;
        }

        if (pWinsCnf->MaxNoOfWrkThds > WINSTHD_MAX_NO_NBT_THDS)
        {
             pWinsCnf->MaxNoOfWrkThds = WINSTHD_MAX_NO_NBT_THDS;
        }
        if (pWinsCnf->MaxNoOfWrkThds < WINSTHD_MIN_NO_NBT_THDS)
        {
             pWinsCnf->MaxNoOfWrkThds = WINSTHD_MIN_NO_NBT_THDS;
        }

#if 0
        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {
                ReadSpecGrpMasks(pWinsCnf);
        }
#endif

#if DYNLOADJET
        //
        // Read in the cap value on the number of worker threads.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_USE_351DB_NM,
                        ValTyp,
                        fUse351Db,
                        0,
                        0   //Use 500 db
                      );
        //
        // If set to a non-zero value, we need to load jet.dll
        //
        if (fUse351Db)
        {
            DynLoadJetVersion = DYN_LOAD_JET_200;
        } else {
            QUERY_VALUE_M(
                            sParametersKey,
                            WINSCNF_USE_4DB_NM,
                            ValTyp,
                            fUse4Db,
                            0,
                            0   //Use 500 db
                          );
            //
            // If set to a non-zero value, we need to load jet.dll
            //
            if (fUse4Db)
            {
                DynLoadJetVersion = DYN_LOAD_JET_500;
            }
        }

#endif
        //
        // Read in the refresh Interval
        //
        Sz = sizeof(pWinsCnf->RefreshInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_REFRESH_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->RefreshInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_REFRESH_INTERVAL_VAL
                               );
                pWinsCnf->RefreshInterval = WINSCNF_DEF_REFRESH_INTERVAL;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                    if (pWinsCnf->RefreshInterval  <
                                   WINSCNF_MIN_REFRESH_INTERVAL)
                    {
                       pWinsCnf->RefreshInterval = WINSCNF_MIN_REFRESH_INTERVAL;
                       WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_REFRESH_INTVL_NM,
                             pWinsCnf->RefreshInterval);
                    }
                }
                else
                {
                      if (pWinsCnf->RefreshInterval < 60)
                      {
                          pWinsCnf->RefreshInterval = 60;
                      }
                }
        }

        //
        // Read in the Initial Challenge Retry Interval
        //
        Sz = sizeof(pWinsCnf->RetryInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_INIT_CHL_RETRY_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->RetryInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_INIT_CHL_RETRY_INTVL_VAL
                               );
                pWinsCnf->RetryInterval = WINSCNF_DEF_INIT_CHL_RETRY_INTVL;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                    if (pWinsCnf->RetryInterval  <
                                   WINSCNF_MIN_INIT_CHL_RETRY_INTVL)
                    {
                       pWinsCnf->RetryInterval = WINSCNF_MIN_INIT_CHL_RETRY_INTVL;
                       WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_INIT_CHL_RETRY_INTVL_NM,
                             pWinsCnf->RetryInterval);
                    }
                }
                else
                {
                      if (pWinsCnf->RetryInterval < WINSCNF_MIN_INIT_CHL_RETRY_INTVL)
                      {
                          pWinsCnf->RetryInterval = WINSCNF_MIN_INIT_CHL_RETRY_INTVL;
                      }
                }
        }

        //
        // Read in the Initial Challenge Max. No. of Retries
        //
        Sz = sizeof(pWinsCnf->MaxNoOfRetries);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_CHL_MAX_RETRIES_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->MaxNoOfRetries,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CHL_MAX_RETRIES_VAL
                               );
                pWinsCnf->MaxNoOfRetries = WINSCNF_DEF_CHL_MAX_RETRIES;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                    if (pWinsCnf->MaxNoOfRetries  <
                                   WINSCNF_MIN_CHL_MAX_RETRIES)
                    {
                       pWinsCnf->MaxNoOfRetries = WINSCNF_MIN_CHL_MAX_RETRIES;
                       WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_CHL_MAX_RETRIES_NM,
                             pWinsCnf->MaxNoOfRetries);
                    }
                }
                else
                {
                      if (pWinsCnf->MaxNoOfRetries < WINSCNF_MIN_CHL_MAX_RETRIES)
                      {
                          pWinsCnf->MaxNoOfRetries = WINSCNF_MIN_CHL_MAX_RETRIES;
                      }
                }
        }

        //
        // Read in the tombstone Interval
        //
        Sz = sizeof(pWinsCnf->TombstoneInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_TOMBSTONE_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->TombstoneInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_TOMBSTONE_INTERVAL_VAL
                               );

                pWinsCnf->TombstoneInterval =
                        WINSCNF_MAKE_TOMB_INTVL_0_M(pWinsCnf->RefreshInterval);
        }
        else
        {

                if ( !sfNoLimitChk)
                {
                      if (pWinsCnf->TombstoneInterval <
                           WINSCNF_MAKE_TOMB_INTVL_0_M(pWinsCnf->RefreshInterval) )
                      {
                        pWinsCnf->TombstoneInterval =
                           WINSCNF_MAKE_TOMB_INTVL_0_M(pWinsCnf->RefreshInterval);

                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_INTVL_NM,
                             pWinsCnf->TombstoneInterval);
                     }
                }
                else
                {
                     if (pWinsCnf->TombstoneInterval < 60)
                     {
                        pWinsCnf->TombstoneInterval = 60;
                     }
                }

        }

        //
        // Read in the tombstone timeout
        //
        Sz = sizeof(pWinsCnf->TombstoneTimeout);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_TOMBSTONE_TMOUT_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->TombstoneTimeout,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_TOMBSTONE_TIMEOUT_VAL
                               );
                pWinsCnf->TombstoneTimeout = pWinsCnf->RefreshInterval;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                  if (pWinsCnf->TombstoneTimeout < pWinsCnf->RefreshInterval)
                  {
                    pWinsCnf->TombstoneTimeout = pWinsCnf->RefreshInterval;
                    WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_TMOUT_NM,
                             pWinsCnf->TombstoneTimeout);
                  }
               }
               else
               {
                   if (pWinsCnf->TombstoneTimeout < 60)
                   {
                      pWinsCnf->TombstoneTimeout = 60;
                   }
               }
        }

        //
        // Read in the Verify Interval
        //
        Sz = sizeof(pWinsCnf->VerifyInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_VERIFY_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->VerifyInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_VERIFY_INTERVAL_VAL
                               );

                pWinsCnf->VerifyInterval =
                   WINSCNF_MAKE_VERIFY_INTVL_M(pWinsCnf->TombstoneInterval);
        }
        else
        {

                if ( !sfNoLimitChk)
                {
                   if (pWinsCnf->VerifyInterval <
                       WINSCNF_MAKE_VERIFY_INTVL_M(pWinsCnf->TombstoneInterval))
                   {
                        pWinsCnf->VerifyInterval =
                           WINSCNF_MAKE_VERIFY_INTVL_M(pWinsCnf->TombstoneInterval);
                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_VERIFY_INTVL_NM,
                             pWinsCnf->VerifyInterval);

                  }
               }
               else
               {
                   if (pWinsCnf->VerifyInterval < 60)
                   {
                         pWinsCnf->VerifyInterval = 60;
                   }
               }

        }

        ReadCCInfo(pWinsCnf);

        //
        // Check if the admin. wants us to do pull/push replications with
        // pnrs found by self.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_BURST_HANDLING_NM,
                        ValTyp,
                        pWinsCnf->fDoSpoofing,
                        0,
                        TRUE
                      );
       if (pWinsCnf->fDoSpoofing)
       {
          pWinsCnf->fDoSpoofing = TRUE;  //for robustness
       }

#if MCAST > 0
        //
        // Check if the admin. wants us to do pull/push replications with
        // pnrs found by self.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_USE_SELF_FND_PNRS_NM,
                        ValTyp,
                        pWinsCnf->fUseSelfFndPnrs,
                        0,
                        FALSE
                      );

        if (pWinsCnf->fUseSelfFndPnrs)
        {
                 if (WinsCnf.State_e == WINSCNF_E_INITING)
                 {
                        Sz = sizeof(pWinsCnf->McastTtl);
                        RetVal = RegQueryValueEx(
                                            sParametersKey,
                                            WINSCNF_MCAST_TTL_NM,
                                            NULL,
                                            &ValTyp,
                                            (LPBYTE)&pWinsCnf->McastTtl,
                                             &Sz
                                         );

                        if (RetVal != ERROR_SUCCESS)
                        {
                            pWinsCnf->McastTtl = WINSCNF_DEF_MCAST_TTL;
                        }
                        else
                        {
                           if (
                             (pWinsCnf->McastTtl < WINSCNF_MIN_MCAST_TTL)
                                          ||
                             (pWinsCnf->McastTtl > WINSCNF_MAX_MCAST_TTL)
                               )
                           {
                             pWinsCnf->McastTtl = WINSCNF_DEF_MCAST_TTL;
                           }
                        }
                 }

                 Sz = sizeof(pWinsCnf->McastIntvl);
                 RetVal = RegQueryValueEx(
                                            sParametersKey,
                                            WINSCNF_MCAST_INTVL_NM,
                                            NULL,
                                            &ValTyp,
                                            (LPBYTE)&pWinsCnf->McastIntvl,
                                             &Sz
                                        );

                 if (RetVal != ERROR_SUCCESS)
                 {
                        pWinsCnf->McastIntvl = WINSCNF_DEF_MCAST_INTVL;
                 }
                 else
                 {
                        if ( pWinsCnf->McastIntvl < WINSCNF_MIN_MCAST_INTVL )
                        {
                               pWinsCnf->McastIntvl = WINSCNF_MIN_MCAST_INTVL;
                        }
                 }
         }
#endif
        //
        // Check if replication is to be done only with configured partners.
        // If set to TRUE, it means that an administrator will not be allowed
        // to trigger replication to/from a WINS that this WINS does not know
        // about.  Default value is FALSE
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                        ValTyp,
                        pWinsCnf->fRplOnlyWCnfPnrs,
                        0,
                        TRUE
                      );
        //
        // Robust programming (in case the registry has a value other than 1
        // and later on we compare the value with TRUE)
        //
        if (pWinsCnf->fRplOnlyWCnfPnrs != FALSE)
        {
                pWinsCnf->fRplOnlyWCnfPnrs = TRUE;
        }

        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {

           (VOID)WinsMscAlloc(WINS_MAX_FILENAME_SZ, &(pWinsCnf->pWinsDb));
           //
           // Read in the name of the database file
           //
FUTURES("when jet supports UNICODE in its api, change this")
           Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
           RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_DB_FILE_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)DirPath,
                                &Sz
                                );

           if ((RetVal != ERROR_SUCCESS) || (DirPath[0] == (TCHAR)EOS))
           {
               WinsMscDealloc(pWinsCnf->pWinsDb);
               pWinsCnf->pWinsDb = WINSCNF_DB_NAME_ASCII;
           }
           else
           {
                 if(!WinsMscGetName(ValTyp, DirPath, Path2, WINS_MAX_FILENAME_SZ, &pHoldFileName))
                 {
                      WinsMscDealloc(pWinsCnf->pWinsDb);
                      pWinsCnf->pWinsDb = WINSCNF_DB_NAME_ASCII;
                 }
                 else
                 {
                      WinsMscConvertUnicodeStringToAscii((LPBYTE)pHoldFileName, pWinsCnf->pWinsDb, WINS_MAX_FILENAME_SZ);
                      DBGPRINT1(DET, "WinsCnfReadWinsInfo: Db file path is (%s)\n", pWinsCnf->pWinsDb);
                 }
           }

           RetVal = ReadClusterIp(
                        sParametersKey,
                        &WinsClusterIpAddress
                        );
           if (ERROR_SUCCESS == RetVal) {
               NmsLocalAdd.Add.IPAdd = WinsClusterIpAddress;
           } else {
               DBGPRINT1(DET, "ReadClusterIp: Returned (%ld)\n", RetVal);
           }
        }

        //
        // Read in the PriorityClassHigh value.  Default is normal
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_PRIORITY_CLASS_HIGH_NM,
                        ValTyp,
                        pWinsCnf->WinsPriorityClass,
                        0,
                        WINSINTF_E_NORMAL
                      );

        if (pWinsCnf->WinsPriorityClass != WINSINTF_E_NORMAL)
        {
             if (WinsCnf.WinsPriorityClass != WINSINTF_E_HIGH)
             {
                  WinsSetPriorityClass(WINSINTF_E_HIGH);
             }
        }
        else
        {
             if (WinsCnf.WinsPriorityClass != WINSINTF_E_NORMAL)
             {
                  WinsSetPriorityClass(WINSINTF_E_NORMAL);
             }
        }

        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {
          BOOL bDefault;
          //
          // Read in the InitTimeState value.  Default is FALSE
          //
          QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_INIT_TIME_PAUSE_NM,
                        ValTyp,
                        fWinsCnfInitStatePaused,
                        0,
                        FALSE
                      );

        //
        // Read in the name of the recovery file
        //
        bDefault = FALSE;
        (VOID)WinsMscAlloc(WINS_MAX_FILENAME_SZ, &(pWinsCnf->pLogFilePath));
        Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
        RetVal = RegQueryValueEx(
                        sParametersKey,
                        WINSCNF_LOG_FILE_PATH_NM,
                        NULL,          //reserved; must be NULL
                        &ValTyp,
                        (LPBYTE)DirPath,
                        &Sz
                                );
        // at this point, pWinsCnf->pWinsDb is definitely a non-null value
        // If there are any problems getting the LogFilePath from the registry, default
        // this setting to the same directory the database is stored in.
        if ((RetVal != ERROR_SUCCESS) || (DirPath[0] == (TCHAR)EOS))
        {
                DBGPRINT1(ERR, "WinsCnfReadInfo: RetVal=(%x)\n", RetVal);
                bDefault = TRUE;
        }
        else
        {
                 if(!WinsMscGetName(ValTyp, DirPath, Path2, WINS_MAX_FILENAME_SZ, &pHoldFileName))
                 {
                DBGPRINT0(ERR, "WinsCnfReadInfo:WinsMscGetName returned FALSE\n");
                    bDefault = TRUE;
                 }
                 else
                 {
                DBGPRINT1(DET, "WinsCnfReadInfo:pHoldFileName=%s\n", pHoldFileName);
                      WinsMscConvertUnicodeStringToAscii((LPBYTE)pHoldFileName, pWinsCnf->pLogFilePath, WINS_MAX_FILENAME_SZ);

                 }
        }
        if (bDefault)
        {
            LPSTR pEnd;
            strcpy(pWinsCnf->pLogFilePath, pWinsCnf->pWinsDb);
            pEnd = strrchr(pWinsCnf->pLogFilePath, '\\'); 
            if (pEnd != NULL)
            {
                pEnd++;
                *pEnd = '\0';
            }
            else
            {
                WinsMscDealloc(pWinsCnf->pLogFilePath);
                pWinsCnf->pLogFilePath = DEFAULT_LOG_PATH;
            }
        }

        //
        // Check if user wants logging to be turned on.
        // In case of Q servers, the user would not wish the logging to be
        // turned on
        //
        Sz = sizeof(pWinsCnf->fLoggingOn);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_LOG_FLAG_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fLoggingOn,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                //
                // default is to turn on logging
                //
                pWinsCnf->fLoggingOn = TRUE;
        }
        else
        {
                //
                // If user has specified logging, get the path to the log
                // file if specified by user
                //
                if (pWinsCnf->fLoggingOn)
                {
                        pWinsCnf->fLoggingOn = TRUE;
                }
        }

       }
        //
        // Check to see if STATIC initialization of the WINS database needs
        // to be done
        //
        Sz = sizeof(pWinsCnf->fStaticInit);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_STATIC_INIT_FLAG_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fStaticInit,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                pWinsCnf->fStaticInit = FALSE;
        }
        else
        {
                //
                // Safe programming (just in case a maintainer of this code
                // assumes a BOOL field to have just TRUE and FALSE values
                //
                pWinsCnf->fStaticInit = pWinsCnf->fStaticInit > 0 ? TRUE : FALSE;
        }

        //
        // If Static Initialization needs to be done, read in the name of
        // the file that contains the data.
        //
        if(pWinsCnf->fStaticInit)
        {
                WinsCnfGetNamesOfDataFiles(pWinsCnf);
        }


        //
        // Assign MaxVersNo with the default value
        //
        WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);

        //
        // If the WINS server is just coming up (i.e. it is not a reinit),
        // then read in the starting value of the version number counter
        // if present in the registry
        //
        Sz = sizeof(DWORD);
        (VOID)RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_INIT_VERSNO_VAL_LW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.LowPart,
                                &Sz
                                );

        (VOID)RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_INIT_VERSNO_VAL_HW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.HighPart,
                                &Sz
                                );

        //
        // if we read in a value for the version counter
        //
        if (LiGtrZero(MaxVersNo) && (MaxVersNo.HighPart == 0) &&
                             (MaxVersNo.LowPart < MAX_START_VERS_NO))
        {
          //
          // Use WinsCnf, not pWinsCnf since at initialization time, we always
          // read into WinsCnf. At reinit, the State_e field in the WinsCnf
          // structure allocated may have garbage (actually will be 0 since we
          // initialize allocated memory to zero -- I might change in the
          // future to improve performance)
          //
          if (WinsCnf.State_e == WINSCNF_E_INITING)
          {
            //
            // Min. Vers. to start scavenging from.
            //
            //  NOTE: if we find local records or the special record then
            //  NmsScvMinScvVersNo will get changed (check out GetMaxVersNos
            //  in nmsdb.c
            //
            NmsNmhMyMaxVersNo  = MaxVersNo;
            NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;
            NmsVersNoToStartFromNextTime.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);

            NmsHighWaterMarkVersNo.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);
          }
          else  // this must be a reconfiguration
          {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // change the value of the version counter if
                // the new value is more than it.
                //
                if (LiGtr(MaxVersNo, NmsNmhMyMaxVersNo))
                {
                        NmsNmhMyMaxVersNo = MaxVersNo;
                        WINSEVT_LOG_INFO_M(MaxVersNo.LowPart,
                                WINS_EVT_VERS_COUNTER_CHANGED);
                }
                NmsVersNoToStartFromNextTime.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);
                NmsHighWaterMarkVersNo.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
          }
        }

        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {
           //
           // Check if a port has been assigned by the user.
           //
           QUERY_VALUE_M(
                                sParametersKey,
                                WINSCNF_WINS_PORT_NO_NM,
                                ValTyp,
                                CommWinsTcpPortNo,
                                0,
                                COMM_DEFAULT_IP_PORT
                             );
           DBGPRINT1(DET, "WinsCnfReadWinsInfo: Port No is (%d)\n", CommWinsTcpPortNo);

          //
          // Check if WINS should continue replication in case of an
          // error in replication.
          //
          QUERY_VALUE_M(
                                sParametersKey,
                                WINSCNF_NO_RPL_ON_ERR_NM,
                                ValTyp,
                                WinsCnf.fNoRplOnErr,
                                0,
                                TRUE
                             );


          //
          // Assign MaxVersNo with the default value
          //
          WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);

          //
          // Read in the value specified in the registry for the version
          // number that we should use when starting.
          //
          Sz = sizeof(DWORD);
          (VOID)RegQueryValueEx(
                                sConfigRoot,
                                WINSCNF_INT_VERSNO_NEXTTIME_LW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.LowPart,
                                &Sz
                                );

          (VOID)RegQueryValueEx(
                                sConfigRoot,
                                WINSCNF_INT_VERSNO_NEXTTIME_HW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.HighPart,
                                &Sz
                                );

          //
          // if we read in a value for the version counter and it is greater
          // than the high-water mark currently there
          //
          if (LiGtr(MaxVersNo, NmsHighWaterMarkVersNo))
          {
               fWinsCnfReadNextTimeVersNo = TRUE;

               //
               // Use WinsCnf, not pWinsCnf since at initialization time,
               // we always read into WinsCnf. At reinit, the State_e field
               // in the WinsCnf structure allocated may have garbage
               // (actually will be 0 since we initialize allocated memory
               // to zero -- I might change in the future to improve
               // performance)
               //

               //
               // Min. Vers. to start scavenging from.
               //
               //  NOTE: if we find local records or the special record then
               //  NmsScvMinScvVersNo will get changed (check out GetMaxVersNos
               //  in nmsdb.c
               //
               if (LiLtr(NmsNmhMyMaxVersNo, MaxVersNo))
               {
                   NmsNmhMyMaxVersNo  = MaxVersNo;
                   NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;
               }
               NmsVersNoToStartFromNextTime.QuadPart =
                       LiAdd(NmsNmhMyMaxVersNo,  NmsRangeSize);
               NmsHighWaterMarkVersNo.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);
         }
       }  //end of if state is INITING

        //
        // Check to see if a backup directory has been specified for the WINS
        // database
        //
        //
        // Read in the name of the recovery file
        //
        Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_BACKUP_DIR_PATH_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)DirPath,
                                &Sz
                                );

        if ((RetVal != ERROR_SUCCESS) || (DirPath[0] == (TCHAR)EOS))
        {
                pWinsCnf->pBackupDirPath = NULL;
        }
        else
        {
                 if(!WinsMscGetName(ValTyp, DirPath, Path2, WINS_MAX_FILENAME_SZ, &pHoldFileName))
                 {
                    pWinsCnf->pBackupDirPath = NULL;
                 }
                 else
                 {
                      WinsMscAlloc(Sz + sizeof(WINS_BACKUP_DIR_ASCII), &pWinsCnf->pBackupDirPath);
FUTURES("When Jet starts taking UNICODE input, get rid of this")
                      WinsMscConvertUnicodeStringToAscii((LPBYTE)pHoldFileName, pWinsCnf->pBackupDirPath, WINS_MAX_FILENAME_SZ);
                      strcat(pWinsCnf->pBackupDirPath, WINS_BACKUP_DIR_ASCII);

                      //
                      // No need to look at the return code.
                      //
                      CreateDirectoryA(pWinsCnf->pBackupDirPath, NULL);

                 }

        }

        //
        // Check to see if the admin. has told WINS to do a backup on
        // termination
        //
        Sz = sizeof(pWinsCnf->fDoBackupOnTerm);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_DO_BACKUP_ON_TERM_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fDoBackupOnTerm,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                pWinsCnf->fDoBackupOnTerm = FALSE;
        }

        //
        // Check to see if static records have to be treated as p-static
        //
        Sz = sizeof(pWinsCnf->fPStatic);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_MIGRATION_ON_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fPStatic,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                pWinsCnf->fPStatic = FALSE;
        }

        //
        // Read max wins registration que len.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_BURST_QUE_SIZE_NM,
                        ValTyp,
                        QueOtherNbtWrkQueMaxLen,
                        0,
                        WINS_QUEUE_HWM
                      );

        if (QueOtherNbtWrkQueMaxLen < WINS_QUEUE_HWM_MIN) {
            QueOtherNbtWrkQueMaxLen = WINS_QUEUE_HWM_MIN;
        } else if (QueOtherNbtWrkQueMaxLen > WINS_QUEUE_HWM_MAX) {
            QueOtherNbtWrkQueMaxLen = WINS_QUEUE_HWM_MAX;
        }

        // Read whether or not we randomize 1c list retrieval.
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_RANDOMIZE_1C_LIST_NM,
                        ValTyp,
                        WinsCnf.fRandomize1CList,
                        0,
                        FALSE
                      );

} // end of try ..
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsCnfReadWinsInfo");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_SFT_ERR);
        }
        return;
}

VOID
ReadCCInfo(
 PWINSCNF_CNF_T  pWinsCnf
)

/*++

Routine Description:
         Function to read in CC info

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

        SYSTEMTIME CurrTime;
        DWORD           Sz;
        LONG            RetVal;
        DWORD           ValTyp;
        VERS_NO_T       MaxVersNo;
        WINSEVT_STRS_T  EvtStr;

        DBGENTER("ReadCCInfo\n");

        //
        // Open the Consistency Chk Key
        //

        RetVal =   RegOpenKeyEx(
                        sConfigRoot,           //predefined key value
                        _WINS_CFG_CC_KEY,
                        0,                     //must be zero (reserved)
                        KEY_READ | KEY_WRITE,  //we desire read/write access
                                               // to the key
                        &sCCKey                //handle to key
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_CC_KEY
                                   );
                pWinsCnf->CC.TimeInt = MAXULONG;
                return;
        }

        Sz = sizeof(pWinsCnf->CC.TimeInt);
        RetVal = RegQueryValueEx(
                                sCCKey,
                                WINSCNF_CC_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->CC.TimeInt,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CC_INTERVAL_VAL
                               );

                pWinsCnf->CC.TimeInt = WINSCNF_CC_DEF_INTERVAL;
        }
        else
        {

                if ( !sfNoLimitChk)
                {
                   if (pWinsCnf->CC.TimeInt <  WINSCNF_CC_MIN_INTERVAL)
                   {
                        pWinsCnf->CC.TimeInt = WINSCNF_CC_MIN_INTERVAL;
                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_CC_INTVL_NM,
                             pWinsCnf->CC.TimeInt);

                  }
               }
               else
               {
                   if (pWinsCnf->CC.TimeInt < 60)
                   {
                         pWinsCnf->CC.TimeInt = 60;
                   }
               }

        }

        Sz = sizeof(pWinsCnf->CC.MaxRecsAAT);
        RetVal = RegQueryValueEx(
                                sCCKey,
                                WINSCNF_CC_MAX_RECS_AAT_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->CC.MaxRecsAAT,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CC_MAX_RECS_AAT_VAL
                               );

                pWinsCnf->CC.MaxRecsAAT = WINSCNF_CC_DEF_RECS_AAT;
        }
        else
        {
                if (pWinsCnf->CC.MaxRecsAAT <  WINSCNF_CC_MIN_RECS_AAT)
                {
                   if ( !sfNoLimitChk)
                   {
                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_MAX_RECS_AAT,
                             NULL, __LINE__, "udd",
                             WINSCNF_CC_MAX_RECS_AAT_NM,
                             WINSCNF_CC_MIN_RECS_AAT,
                             pWinsCnf->CC.MaxRecsAAT);
                        pWinsCnf->CC.MaxRecsAAT = WINSCNF_CC_MIN_RECS_AAT;
                   }
                   else
                   {
                      if (pWinsCnf->CC.MaxRecsAAT < 2)
                      {
                        pWinsCnf->CC.MaxRecsAAT = 2;
                      }

                   }

               }
        }

        Sz = sizeof(pWinsCnf->CC.fUseRplPnrs);
        RetVal = RegQueryValueEx(
                                sCCKey,
                                WINSCNF_CC_USE_RPL_PNRS_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->CC.fUseRplPnrs,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CC_USE_RPL_PNRS_VAL
                               );

                pWinsCnf->CC.fUseRplPnrs = WINSCNF_CC_DEF_USE_RPL_PNRS;
        }

        GetLocalTime(&CurrTime);
        GetSpTimeData(sCCKey, &CurrTime, &pWinsCnf->CC.fSpTime, &pWinsCnf->CC.SpTimeInt);
        REG_M(
                     RegCloseKey(sCCKey),
                     WINS_EVT_CANT_CLOSE_KEY,
                     WINS_EXC_CANT_CLOSE_KEY
                );
        DBGLEAVE("ReadCCInfo\n");
        return;
}
#if USENETBT > 0
//------------------------------------------------------------------------
STATUS
WinsCnfReadNbtDeviceName(
        VOID
    )

/*++

Routine Description:

    This procedure reads the registry to get the name of NBT to bind to.
    That name is stored in the Linkage section under the Netbt key.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    PTCHAR  SubKeyLinkage=NETBT_LINKAGE_KEY;
    HKEY    Key;
    PTCHAR  pLinkage=TEXT("Export");
    LONG    Type;
    LONG    Status;
    LONG    Status2;
    ULONG   Size;

    //
    // Open the NETBT key
    //
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 SubKeyLinkage,
                 0,
                 KEY_READ,
                 &Key);

    if (Status == ERROR_SUCCESS)
    {
        //
        // now read the linkage values
        //
        Status = RegQueryValueEx(Key,
                                 pLinkage,
                                 NULL,
                                 &Type,
                                 NULL,
                                 &Size);
        if (Status != ERROR_SUCCESS)
        {
            DBGPRINT0(ERR, "Error closing the Registry key\n");
            WINSEVT_LOG_M(Status, WINS_EVT_QUERY_NETBT_KEY_ERR);
            (VOID)RegCloseKey(Key);
            return(WINS_FAILURE);
        }
        else
        {
           //
           // Let us allocate a buffer that is big enough to hold all the
           // data
           //
           WinsMscAlloc(Size, (LPVOID *)&pWinsCnfNbtPath);

           //
           // now read the linkage values
           //
           Status = RegQueryValueEx(Key,
                                 pLinkage,
                                 NULL,
                                 &Type,
                                 (LPBYTE)pWinsCnfNbtPath,
                                 &Size);
           Status2 = RegCloseKey(Key);
           if ((Status != ERROR_SUCCESS) || (Status2 != ERROR_SUCCESS))
           {
              DBGPRINT0(ERR, "Error closing the Registry key\n");
              WINSEVT_LOG_M(Status, WINS_EVT_QUERY_NETBT_KEY_ERR);
              return(WINS_FAILURE);
           }
        }
    }
    else
    {
        WINSEVT_LOG_D_M(Status, WINS_EVT_OPEN_NETBT_KEY_ERR);
        return(WINS_FAILURE);
    }

    return(WINS_SUCCESS);
}
#endif

VOID
WinsCnfReadRegInfo(
  PWINSCNF_CNF_T        pWinsCnf
 )

/*++

Routine Description:
        This function is called to read the registry in order to populate the
        WinsCnf structure

Arguments:
        None

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        WinsCnfInitConfig
Side Effects:

Comments:
        None
--*/

{

try {
   if (sfParametersKeyExists)
   {
           /*
                Read in the  registry information pertaining to WINS
           */
           WinsCnfReadWinsInfo(pWinsCnf);
   }

   if (sfPartnersKeyExists)
   {
           //
           // Read the PUSH/PULL records and other global information used for
           // replication
           //
           WinsCnfReadPartnerInfo(pWinsCnf);
   }

   //
   // Do a sanity check on the params. We are not interested in the
   // return code
   //
   (VOID)SanityChkParam(pWinsCnf);
}
except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("WinsCnfReadRegInfo");

       //
       // If we encountered an exception at boot time, we do not want to
       // reraise the exception, since we want to come up and continue on
       // For the non-initing case, the exception that we raise will be caught
       // in Reinit(). For the boot time case, it is ok to come up with the
       // defaults (an event message is being logged) - in WinsCnf.
       // In the non-init case, the defaults are not in the memory used to
       // read in the parameters (WinsCnf is initialized with stuff in
       // this memory block later).
       //
       if (WinsCnf.State_e != WINSCNF_E_INITING)
       {
             WINS_RERAISE_EXC_M();
       }
       WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
     }

   return;
}


VOID
WinsCnfCopyWinsCnf(
                WINS_CLIENT_E        Client_e,
                PWINSCNF_CNF_T  pSrc
        )

/*++

Routine Description:
        This function is called to copy relevant information from a WINS
        Cnf structure to the master (external) Wins Cnf structure

Arguments:
        pSrc - WinsCnf stucture to copy from

Externals Used:
        WinsCnf


Return Value:

        None
Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        This function may be enhanced in the future

        Note: this function is called only by the main thread
--*/
{

        BOOL fScvParamChg = FALSE;

        if (Client_e == WINS_E_WINSCNF)
        {

FUTURES("Queue a message to the Scavenger thread passing it pSrc")
FUTURES("That will avoid this synchronization overhead")

                //
                // We need to synchronize with the scavenger thread and
                // RPC threads that might be looking at fRplOnlyWCnfPnrs
                //
                EnterCriticalSection(&WinsCnfCnfCrtSec);

                //
                // Also need to synchronize with the nbt threads doing
                // name registrations/refreshes
                //
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // Sanity check the parameters
                //
                fScvParamChg = SanityChkParam(pSrc);

                if (fScvParamChg)
                {
                  //
                  // Initialize the scavenging stuff.
                  //
                  WinsCnf.RefreshInterval   = pSrc->RefreshInterval;
                  WinsCnf.TombstoneInterval = pSrc->TombstoneInterval;
                  WinsCnf.TombstoneTimeout  = pSrc->TombstoneTimeout;
                  WinsCnf.CC                = pSrc->CC;
                  WinsCnf.ScvThdPriorityLvl = pSrc->ScvThdPriorityLvl;
                }

                //
                // Store the verify interval since SanityChkParam does
                // not set fScvParamChg if VerifyINterval has changed.
                //
                WinsCnf.VerifyInterval = pSrc->VerifyInterval;

                WinsCnf.fRplOnlyWCnfPnrs     = pSrc->fRplOnlyWCnfPnrs;
                WinsCnf.LogDetailedEvts      = pSrc->LogDetailedEvts;
                WinsCnf.fAdd1Bto1CQueries    = pSrc->fAdd1Bto1CQueries;
                WinsCnf.fPStatic             = pSrc->fPStatic;

                LeaveCriticalSection(&NmsNmhNamRegCrtSec);

                WinsCnf.fDoSpoofing           = pSrc->fDoSpoofing;
                WinsCnf.MaxNoOfWrkThds       = pSrc->MaxNoOfWrkThds;

                WinsCnf.fDoBackupOnTerm      = pSrc->fDoBackupOnTerm;
#if MCAST > 0
                WinsCnf.fUseSelfFndPnrs      = pSrc->fUseSelfFndPnrs;
                WinsCnf.McastIntvl           = pSrc->McastIntvl;
#endif

#if PRSCONN
                WinsCnf.fPrsConn             = pSrc->fPrsConn;
#endif
                if (WinsCnf.fDoBackupOnTerm && pSrc->pBackupDirPath != NULL)
                {
                        if (WinsCnf.pBackupDirPath != NULL)
                        {
                                WinsMscDealloc(WinsCnf.pBackupDirPath);
                        }
                        WinsCnf.pBackupDirPath = pSrc->pBackupDirPath;
                }

                LeaveCriticalSection(&WinsCnfCnfCrtSec);
        //        return;

        }
        else
        {
          if (Client_e == WINS_E_RPLPULL)
          {

                EnterCriticalSection(&WinsCnfCnfCrtSec);
                //
                // Copy the Scavenging parameters into the cnf structure
                // just allocated so that we can compare them for
                // compatibility with the new max. replication time interval
                // (since the Partners key was signaled, the replication
                 // stuff might have changed)
                //
                pSrc->RefreshInterval   = WinsCnf.RefreshInterval;
                pSrc->TombstoneInterval = WinsCnf.TombstoneInterval;
                pSrc->TombstoneTimeout  = WinsCnf.TombstoneTimeout;
                pSrc->VerifyInterval    = WinsCnf.VerifyInterval;

                //
                // Wasteful here and in SanityChkParam
                //
PERF("Pass an argument to SanityChk so that we don't have to do this")
PERF("See similar remark in SanityChk")
                pSrc->CC                = WinsCnf.CC;

                //
                // Sanity check the parameters.
                //
                // Sanity checking of the parameters is done here in
                // the main thread instead of in the PULL thread because
                // we don't want a situation where two different threads
                // (the main thread for changes to the PARAMETERS key)
                // and the PULL thread (for changes in the PARTNERS key)
                // updating the WinsCnf structure
                //
                // Also, as an aside, we don't copy the PullInfo information
                // into WinsCnf here to avoid unnecessary complication and
                // synchronization that would ensue by the fact that we
                // would then have two threads (main thread) and the PULL
                // thread accessing that field (check Reconfig() in
                // rplpull.c).
                //
FUTURES("When we start supporting time interval as an attribute of PUSHing")
FUTURES("move this check inside the NmsNmhNamRegCrtSec below")
                fScvParamChg = SanityChkParam(pSrc);

                //
                // If one or more scavenging parameters have  changed,
                // update WinsCnf and signal the Scavenger thread.
                //
                if (fScvParamChg)
                {
                        WinsCnf.RefreshInterval   = pSrc->RefreshInterval;
                        WinsCnf.TombstoneInterval = pSrc->TombstoneInterval;
                        WinsCnf.TombstoneTimeout  = pSrc->TombstoneTimeout;

                        //
                        // If SanityChkParam changed Tombstone interval, then
                        // verify interval has also changed.
                        //
                        WinsCnf.VerifyInterval = pSrc->VerifyInterval;

                }

                WinsCnf.MaxRplTimeInterval = pSrc->MaxRplTimeInterval;
                WinsCnf.RplType              = pSrc->RplType;
                LeaveCriticalSection(&WinsCnfCnfCrtSec);
          }
        }

        //
        // If the scavenging params have changed we need to signal
        // the scavenger thread
        //
        if (fScvParamChg)
        {
                WinsMscSignalHdl(WinsCnf.CnfChgEvtHdl);
        }
        return;
}


LPVOID
WinsCnfGetNextRplCnfRec(
         PRPL_CONFIG_REC_T        pCnfRec,
        RPL_REC_TRAVERSAL_E        RecTrv_e
        )

/*++

Routine Description:
        This function is called to get to the next configuration record

Arguments:
        pCnfRec - The current configuration record in a buffer of configuration
                  records
        RecTrv_e - indicates how the next one should be retrieved.  If set to
                  TRUE, it means that the next record to be retrieved is one
                  that follows the current record in the buffer.  If set to
                  FALSE, the next record is retrieved using the pNext field
                  of the current configuration record



Externals Used:
        None

Return Value:
        address of the next configuration record

Error Handling:

Called by:
        EstablishComm in rplpull.c, WinsPushTrigger() in wins.c

Side Effects:

Comments:
        None
--*/

{
        //
        // If no traversal is desired, return NULL as the next record
        //
        if (RecTrv_e == RPL_E_NO_TRAVERSAL)
        {
                return(NULL);
        }
        //
        //  Go to the next configuration record in a way specified
        //  by the  value of the RecTrv_e flag.
        //
        if(RecTrv_e == RPL_E_IN_SEQ)
        {
                pCnfRec = (PRPL_CONFIG_REC_T)(
                                 (LPBYTE)pCnfRec + RPL_CONFIG_REC_SIZE);
        }
        else  // RPL_E_VIA_LINK
        {
                return(pCnfRec->pNext);
        }
        return(pCnfRec);
}


VOID
WinsCnfAskToBeNotified(
         WINSCNF_KEY_E        KeyToMonitor_e
        )

/*++

Routine Description:
        This function is called to request that WINS be notified when
        the information pertaining to WINS and its subkeys in the registry
        changes

Arguments:

        KeyToMonitor_e

Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:
        Reinit() in nms.c
        WinsCnfOpenSubKeys()
        WinsCnfInitConfig()

Side Effects:

Comments:
        None
--*/

{
   DWORD  NotifyFilter = 0;
   LONG          RetVal;
   DWORD  Error;

#define  CHK_RET_VAL_M     {                                            \
                                if (RetVal != ERROR_SUCCESS)         \
                                   {                                     \
                                        DBGPRINT1(ERR, "WinsAskToBeNotified: Error = (%d)\n", RetVal);                                                \
                                        WINSEVT_LOG_M(                      \
                                                 WINS_FATAL_ERR,              \
                                                 WINS_EVT_REG_NTFY_FN_ERR \
                                                      );             \
                                   }                                    \
                           }

   /*
    *  Set the notify filter.  Ask to be notified for all changes.
    */
   NotifyFilter = REG_NOTIFY_CHANGE_NAME       |
                  REG_NOTIFY_CHANGE_ATTRIBUTES |
                  REG_NOTIFY_CHANGE_LAST_SET  |
                  REG_NOTIFY_CHANGE_SECURITY ;


   switch(KeyToMonitor_e)
   {
        case(WINSCNF_E_WINS_KEY):

//                DBGPRINT0(SPEC, "WinsCnfAskToBeNotified: WINS Key\n");
                   RetVal = RegNotifyChangeKeyValue(
                            sConfigRoot,
                            TRUE,        //report changes in key and all subkeys
                            REG_NOTIFY_CHANGE_NAME,
                            WinsCnf.WinsKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );
                CHK_RET_VAL_M;
                break;
        case(WINSCNF_E_PARAMETERS_KEY):

//                DBGPRINT0(SPEC, "WinsCnfAskToBeNotified: PARAMETERS Key\n");
                   RetVal = RegNotifyChangeKeyValue(
                            sParametersKey,
                            TRUE,        //report changes in key and all subkeys
                            NotifyFilter,
                            WinsCnf.ParametersKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );
                CHK_RET_VAL_M;
                break;

        case(WINSCNF_E_PARTNERS_KEY):

//                DBGPRINT0(SPEC, "WinsCnfAskToBeNotified: PARTNERS Key\n");
                   RetVal = RegNotifyChangeKeyValue(
                            sPartnersKey,
                            TRUE,        //report changes in key and all subkeys
                            NotifyFilter,
                            WinsCnf.PartnersKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );

                CHK_RET_VAL_M;
                break;

FUTURES("Remove the following case")
        //
        // The following case would never get exercised.
        //
        case(WINSCNF_E_ALL_KEYS):

                   RetVal = RegNotifyChangeKeyValue(
                            sConfigRoot,
                            TRUE,        //report changes in key and all subkeys
                            REG_NOTIFY_CHANGE_NAME,
                            WinsCnf.WinsKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );
                CHK_RET_VAL_M;
                if (sfParametersKeyExists)
                {
                           RetVal = RegNotifyChangeKeyValue(
                                            sParametersKey,
                                            TRUE,        //report changes in key and
                                                //all subkeys
                                            NotifyFilter,
                                            WinsCnf.ParametersKChgEvtHdl,
                                            TRUE         //Async signaling is what we
                                                 // want
                                                           );
                        if (RetVal != ERROR_SUCCESS)
                        {
                                Error = GetLastError();
                                if (Error == ERROR_BADKEY)
                                {
                                        //
                                        // Key must not be there
                                        //
                                        sfParametersKeyExists = FALSE;
                                }
                                else
                                {
                                        DBGPRINT1(ERR,
        "WinsCnfAskToBeNotified: RegNotifyChangeKeyValue error = (%d)\n",
                                                 Error);

                                }
                        }
                }
                if (sfPartnersKeyExists)
                {
                           RetVal = RegNotifyChangeKeyValue(
                                            sPartnersKey,
                                            TRUE,        //report changes in key and
                                                //all subkeys
                                            NotifyFilter,
                                            WinsCnf.PartnersKChgEvtHdl,
                                            TRUE         //Async signaling is what we
                                                 //want
                                                           );
                        if (RetVal != ERROR_SUCCESS)
                        {
                                Error = GetLastError();
                                if (Error == ERROR_BADKEY)
                                {
                                        //
                                        // Key must not be there
                                        //
                                        sfPartnersKeyExists =  FALSE;
                                }
                                else
                                {
                                        DBGPRINT1(ERR,
        "WinsCnfAskToBeNotified: RegNotifyChangeKeyValue error = (%d)\n",
                                                 Error);

                                }
                        }
                }
                        break;
        default:

                DBGPRINT1(ERR, "WinsCnfAskToBeNotified: Wrong Hdl (%d)\n",
                                KeyToMonitor_e);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                break;
        }


            return;
}

VOID
WinsCnfDeallocCnfMem(
  PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:
        This function is called to deallocate the Wins Cnf structure and
        memory associated with it

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        Reconfig in rplpull.c

Side Effects:

Comments:
        None
--*/

{
try {
        //
        // Deallocate the buffer holding one or more names of files used
        // for STATIC initialization of WINS
        //
        if (pWinsCnf->pStaticDataFile != NULL)
        {
                WinsMscDealloc(pWinsCnf->pStaticDataFile);
        }
        WinsMscDealloc(pWinsCnf);
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsCnfDeallocCnfMem");
        DBGPRINT0(EXC, "WinsCnfDeallocCnfMem: Got an exception\n");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
        }

        return;
}

VOID
GetKeyInfo(
        IN  HKEY                   Key,
        IN  WINSCNF_KEY_E        KeyType_e,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        )

/*++

Routine Description:
        This function is called to get the number of subkeys under a key

Arguments:
        Key         - Key whose subkey count has to be determined
        KeyType_e
        pNoOfSubKeys

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        GetPnrInfo()

Side Effects:

Comments:
        None
--*/

{
          TCHAR    ClsStr[40];
          DWORD    ClsStrSz = sizeof(ClsStr)/sizeof(TCHAR);
          DWORD    LongestKeyLen;
          DWORD    LongestKeyClassLen;
          DWORD    LongestValueNameLen;
          DWORD    LongestValueDataLen;
          DWORD    SecDesc;
        LONG         RetVal;

          FILETIME LastWrite;
          /*
                Query the key.  The subkeys are IP addresses of PULL
                partners.
          */
          RetVal = RegQueryInfoKey(
                        Key,
                        ClsStr,
                        &ClsStrSz,
                        NULL,                        //must be NULL, reserved
                        pNoOfSubKeys,
                        &LongestKeyLen,
                        &LongestKeyClassLen,
                        pNoOfVals,
                        &LongestValueNameLen,
                        &LongestValueDataLen,
                        &SecDesc,
                        &LastWrite
                                );

          if (RetVal != ERROR_SUCCESS)
          {
                WINSEVT_LOG_M(
                        WINS_FATAL_ERR,
                        KeyType_e == WINSCNF_E_DATAFILES_KEY ?
                                WINS_EVT_CANT_QUERY_DATAFILES_KEY :
                                ((KeyType_e == WINSCNF_E_PULL_KEY) ?
                                        WINS_EVT_CANT_QUERY_PULL_KEY :
                                        ((KeyType_e == WINSCNF_E_PUSH_KEY) ?
                                        WINS_EVT_CANT_QUERY_PUSH_KEY :
                                        WINS_EVT_CANT_QUERY_SPEC_GRP_MASKS_KEY))
                             );
                WINS_RAISE_EXC_M(WINS_EXC_CANT_QUERY_KEY);
        }
        return;
}
VOID
WinsCnfOpenSubKeys(
        VOID
        )

/*++

Routine Description:
        This function opens the subkeys of the WINS key.  The subkeys are
        the PARTNERS key and the PARAMETERS key.
Arguments:
        None

Externals Used:
        sfParamatersKeyExists
        sfPartnersKeyExists

Return Value:
        None

Error Handling:

Called by:

        WinsCnfInitConfig()

Side Effects:

Comments:
        None
--*/

{

   LONG  RetVal;

   //
   // Check if the Parameters and Partners Keys are present
   //
   ChkWinsSubKeys();

   //
   // Try to open the Parameters key if it exists
   //
   if ((sfParametersKeyExists) && (!sfParametersKeyOpen))
   {
           /*
           *  Open the Parameters key
           */
           RetVal =   RegOpenKeyEx(
                        sConfigRoot,                //predefined key value
                        _WINS_CFG_PARAMETERS_KEY,
                        0,                        //must be zero (reserved)
                        KEY_READ | KEY_WRITE,        //we desire read/write access
                                                // to the key
                        &sParametersKey                //handle to key
                                );

           if (RetVal != ERROR_SUCCESS)
           {
CHECK("Is there any need to log this")
                WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_PARAMETERS_KEY
                                   );
                sfParametersKeyExists = FALSE;
           }
           else
           {
                sfParametersKeyOpen = TRUE;
                WinsCnfAskToBeNotified(WINSCNF_E_PARAMETERS_KEY);
           }
   }

   //
   // Try to open the Partners key if it exists
   //
   if ((sfPartnersKeyExists) && (!sfPartnersKeyOpen))
   {
           /*
           *  Open the Partners key
           */
           RetVal =   RegOpenKeyEx(
                                sConfigRoot,                //predefined key value
                                _WINS_CFG_PARTNERS_KEY,
                                0,                        //must be zero(reserved)
                                KEY_READ,                //we desire read
                                                        //access to the key
                                &sPartnersKey                //handle to key
                                );

           if (RetVal != ERROR_SUCCESS)
           {

CHECK("Is there any need to log this")
                WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_KEY
                         );
                sfPartnersKeyExists = FALSE;
           }
           else
           {
                sfPartnersKeyOpen = TRUE;
                WinsCnfAskToBeNotified(WINSCNF_E_PARTNERS_KEY);
           }
   }

   return;

}  //WinsCnfOpenSubKeys()

BOOL
SanityChkParam(
        PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:
        This function  is called to ensure that the time intervals for
        scavenging specified in WinsCnf are compatible with the ones
        used for replication

Arguments:
        pWinsCnf - ptr to the WINS configuration

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsCnfCopyWinsCnf (during reinitialization of the WINS), by
        WinsCnfReadRegInfo() during initialization of the WINS
Side Effects:

        The scavenging intervals could be affected

Comments:
        This function must be called from inside the critical section
        guarded by WinsCnfCnfCrtSec except at process initialization.
--*/
{
        DWORD   MinTombInterval;
        BOOL        fScvParamChg = FALSE;
        WINSEVT_STRS_T  EvtStr;
        EvtStr.NoOfStrs = 1;

        DBGENTER("SanityChkParam\n");

        //
        // Get the minimum tombstone time interval
        //
        MinTombInterval = WINSCNF_MAKE_TOMB_INTVL_M(pWinsCnf->RefreshInterval,
                                           pWinsCnf->MaxRplTimeInterval);

        //
        // Make the actual equal to the min. if it is less
        //
        if (!sfNoLimitChk && (pWinsCnf->TombstoneInterval < MinTombInterval))
        {
                DBGPRINT2(FLOW, "SanityChkParam: Adjusting Tombstone Interval from (%d) to (%d)\n", pWinsCnf->TombstoneInterval, MinTombInterval);

FUTURES("This is actually a warning. Use a different macro or enhance it")
FUTURES("Currently, it will log this message as an informational")

                WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL_R,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_INTVL_NM,
                             MinTombInterval );

                pWinsCnf->TombstoneInterval = MinTombInterval;

                //
                // Verify Interval is dependent on the tombstone interval
                //
                pWinsCnf->VerifyInterval = WINSCNF_MAKE_VERIFY_INTVL_M(MinTombInterval);
                fScvParamChg = TRUE;
        }

        //
        // reusing the var. The time interval is for tombstone timeout
        //
        MinTombInterval =
                  WINSCNF_MAKE_TOMBTMOUT_INTVL_M(pWinsCnf->MaxRplTimeInterval);
        if (!sfNoLimitChk && (pWinsCnf->TombstoneTimeout <  MinTombInterval))
        {
                DBGPRINT2(FLOW, "SanityChkParam: Adjusting Tombstone Timeout from (%d) to (%d)\n", pWinsCnf->TombstoneInterval, MinTombInterval);

                pWinsCnf->TombstoneTimeout = MinTombInterval;
                WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL_R,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_TMOUT_NM,
                             MinTombInterval );
                if (!fScvParamChg)
                {
                        fScvParamChg = TRUE;
                }

        }
        if (!fScvParamChg)
        {
PERF("Pass an argument to SanityChk so that we don't have to do this")
PERF("for CC for the case where we just read the partner info. See")
PERF("WinsCnfCopyWinsCnf for the case where client_e is WINS_E_RPLPULL")
                if (
                     (WinsCnf.RefreshInterval != pWinsCnf->RefreshInterval)
                                        ||
                     (WinsCnf.TombstoneInterval != pWinsCnf->TombstoneInterval)
                                        ||
                     (WinsCnf.TombstoneTimeout != pWinsCnf->TombstoneTimeout)
                                        ||
                     (WinsCnf.CC.TimeInt  != pWinsCnf->CC.TimeInt)
                                        ||
                     (WinsCnf.CC.SpTimeInt  != pWinsCnf->CC.SpTimeInt)
                                        ||
                     (WinsCnf.CC.fUseRplPnrs  != pWinsCnf->CC.fUseRplPnrs)
                                        ||
                     (WinsCnf.CC.MaxRecsAAT  != pWinsCnf->CC.MaxRecsAAT)
                   )
                {
                        fScvParamChg = TRUE;
                }
        }

        DBGLEAVE("SanityChkParam\n");
        return(fScvParamChg);
}
STATUS
WinsCnfGetNamesOfDataFiles(
        PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:
        This function gets the names of all the datafiles that need to
        be used for initializing WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        LONG             RetVal;
        HKEY             DFKey;
        DWORD            BuffSize;
        STATUS          RetStat = WINS_SUCCESS;
        PWINSCNF_DATAFILE_INFO_T            pSaveDef;
        DWORD          NoOfSubKeys;

        DBGENTER("WinsCnfGetNamesOfDataFiles\n");

        //
        // Store timestamp of initialization in the statistics structure
        //
        WinsIntfSetTime(NULL, WINSINTF_E_INIT_DB);

        //
        // Set up the default name
        //

        //
        // First allocate the buffer that will hold the default file name
        //
        WinsMscAlloc(WINSCNF_FILE_INFO_SZ, &pWinsCnf->pStaticDataFile);

        lstrcpy(pWinsCnf->pStaticDataFile->FileNm, WINSCNF_STATIC_DATA_NAME);

        //
        // The default name contains a %<string>% in it.  Therefore, specify
        // the type as EXPAND_SZ
        //
        pWinsCnf->pStaticDataFile->StrType = REG_EXPAND_SZ;
        pWinsCnf->NoOfDataFiles            = 1;

        pSaveDef = pWinsCnf->pStaticDataFile;  //save the address

           /*
           *  Open the DATAFILES key
           */
           RetVal =   RegOpenKeyEx(
                        sConfigRoot,                //predefined key value
                        _WINS_CFG_DATAFILES_KEY,
                        0,                //must be zero (reserved)
                        KEY_READ,        //we desire read access to the keyo
                        &DFKey                //handle to key
                );

           if (RetVal != ERROR_SUCCESS)
           {

CHECK("Is there any need to log this")
                WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_DATAFILES_KEY
                                 );
                DBGLEAVE("WinsCnfGetNamesOfDataFiles\n");
                return(FALSE);
           }
        else
try {
        {
                //
                // Get the count of data files listed under the DATAFILES
                // key
                //
                GetKeyInfo(
                        DFKey,
                        WINSCNF_E_DATAFILES_KEY,
                        &NoOfSubKeys,                        //ignored
                        &pWinsCnf->NoOfDataFiles
                      );
        }
        if (pWinsCnf->NoOfDataFiles > 0)
        {

                DWORD                          Index;
                PWINSCNF_DATAFILE_INFO_T pTmp;
                TCHAR ValNmBuff[MAX_PATH];
                DWORD ValNmBuffSz = MAX_PATH;


                  //
                  // Allocate buffer big enough to hold data for
                // the number of subkeys found under the PULL key
                  //
                  BuffSize = WINSCNF_FILE_INFO_SZ * pWinsCnf->NoOfDataFiles;
                    WinsMscAlloc( BuffSize, &pWinsCnf->pStaticDataFile);

                   /*
                    *   Enumerate  the values
                     */
                     for(
                        Index = 0, pTmp = pWinsCnf->pStaticDataFile;
                        Index <  pWinsCnf->NoOfDataFiles;
                                // no third expression
                         )
                {
                        ValNmBuffSz = sizeof(ValNmBuff)/sizeof(TCHAR);  //init before
                                                          //every call
                        BuffSize  = sizeof(pWinsCnf->pStaticDataFile->FileNm);
                          RetVal = RegEnumValue(
                                    DFKey,
                                    Index,        //key
                                    ValNmBuff,
                                    &ValNmBuffSz,
                                    (LPDWORD)NULL,                //reserved
                                    &pTmp->StrType,
                                    (LPBYTE)(pTmp->FileNm),//ptr to var. to
                                                           //hold name of
                                                           //datafile
                                    &BuffSize        //not looked at by us
                                            );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                continue;
                        }
                        //
                        // if StrType is not REG_SZ or REG_EXPAND_SZ, go to
                        // the next  Value
                        //
                        if  (
                                (pTmp->StrType != REG_EXPAND_SZ)
                                        &&
                                   (pTmp->StrType != REG_SZ)
                                )
                        {
                                continue;
                        }

                        Index++;
                        pTmp = (PWINSCNF_DATAFILE_INFO_T)((LPBYTE)pTmp +
                                                WINSCNF_FILE_INFO_SZ);
                }

                //
                // If not even one valid name was retrieved, get rid of the
                // buffer
                //
                if (Index == 0)
                {
                        //
                        // Get rid of the buffer
                        //
                        WinsMscDealloc((LPBYTE)pWinsCnf->pStaticDataFile);

                        //
                        // We will use the default
                        //
                        pWinsCnf->pStaticDataFile = pSaveDef;
                }
                else
                {
                        //
                        // Get rid of the default name buffer
                        //
                        WinsMscDealloc((LPBYTE)pSaveDef);
                }

                pWinsCnf->NoOfDataFiles = Index;
        }
 } // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("WinsCnfGetNamesOfDataFiles");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                RetStat = WINS_FAILURE;
        }
         REG_M(
                RegCloseKey(DFKey),
                WINS_EVT_CANT_CLOSE_KEY,
                WINS_EXC_CANT_CLOSE_KEY
             );
        DBGLEAVE("WinsCnfGetNamesOfDataFiles\n");
        return(RetStat);
}



VOID
WinsCnfCloseKeys(
        VOID
        )

/*++

Routine Description:
        This function closes the the open keys.  The keys closed are
        the WINS key, the PARTNERS key, and the PARAMETERS key.
Arguments:
        None

Externals Used:
        sfParametersKeyExists
        sfPartnersKeyExists

Return Value:
        None

Error Handling:

Called by:
        Reinit()

Side Effects:

Comments:
        We don't look at the return code of RegCloseKey.  This is because
        we might call this function even with the key not being open (not
        the case currently).

--*/

{

   //
   // Close the PARAMETERS key if it  is open
   //
   if (sfParametersKeyOpen)
   {
           (VOID)RegCloseKey(sParametersKey);
   }

   //
   // Close the PARTNERS key if it is open
   //
   if (sfPartnersKeyOpen)
   {
           (VOID)RegCloseKey(sPartnersKey);
   }

#if 0
   //
   // NOTE NOTE NOTE: Build 436.  If we attempt to close a key that has been
   // deleted from the registry NT comes down
   //

   //
   // Close the WINS key
   //
   (VOID)RegCloseKey(sConfigRoot);
#endif

   return;
}  //WinsCnfCloseKeys()


VOID
ChkWinsSubKeys(
        VOID
        )

/*++

Routine Description:
        This function is called to check whether we have the PARTNERS
        and PARAMETERS sub-keys under the root subkey of WINS.

Arguments:
        None

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        Reinit() in nms.c

Side Effects:

Comments:
        None
--*/

{
        DWORD      NoOfSubKeys = 0;
          DWORD             KeyNameSz;
          TCHAR           KeyName[20];
          FILETIME   LastWrite;
        LONG           RetVal;
        BOOL           fParametersKey = FALSE;
        BOOL           fPartnersKey   = FALSE;

           /*
            *   Get each subkey's  name
           */
            RetVal = ERROR_SUCCESS;
            for(
                        ;
                RetVal == ERROR_SUCCESS;
                NoOfSubKeys++
            )
          {
                KeyNameSz = sizeof(KeyName)/sizeof(TCHAR);  //init before every call
                 RetVal = RegEnumKeyEx(
                                sConfigRoot,
                                NoOfSubKeys,        //key
                                KeyName,
                                &KeyNameSz,
                                NULL,                //reserved
                                NULL,                //don't need class name
                                NULL,                //ptr to var. to hold class name
                                &LastWrite        //not looked at by us
                                );

                if (RetVal != ERROR_SUCCESS)
                {
                        continue;
                }

                if (lstrcmp(KeyName, _WINS_CFG_PARAMETERS_KEY) == 0)
                {
                        fParametersKey = TRUE;
                }

                if (lstrcmp(KeyName, _WINS_CFG_PARTNERS_KEY) == 0)
                {
                        fPartnersKey = TRUE;
                }
        }

        //
        // if the Parameters key does not exist but it existed before,
        // close the key to get rid of the handle we have
        //
        if (!fParametersKey)
        {
                 if (sfParametersKeyExists)
                {
                        sfParametersKeyExists = FALSE;
                        sfParametersKeyOpen = FALSE;
                }
        }
        else
        {
                sfParametersKeyExists = TRUE;
        }

        //
        // if the Partners key does not exist but it existed before,
        // close the key to get rid of the handle we have
        //
        if (!fPartnersKey)
        {
                if (sfPartnersKeyExists)
                {
                        sfPartnersKeyExists = FALSE;
                        sfPartnersKeyOpen   = FALSE;
                }
        }
        else
        {
                sfPartnersKeyExists = TRUE;
        }

        return;
} //ChkWinsSubKeys()

VOID
GetSpTimeData(
        HKEY              SubKey,
        LPSYSTEMTIME      pCurrTime,
        LPBOOL            pfSpTime,
        LPDWORD           pSpTimeIntvl

/*++

Routine Description:
        This function is called to get the specific time and period information
        for a PULL/PUSH record.

Arguments:
        SubKey   - Key of a WINS under the Pull/Push key
        pCnfRFec - ptr to the Conf. record of the WINS

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_NO_SP_TIME

Error Handling:

Called by:
        GetPnrInfo

Side Effects:

Comments:
        None
--*/

        )
{
        DWORD    ValTyp;
        BYTE     tSpTime[MAX_SZ_SIZE];
        BYTE     SpTime[MAX_SZ_SIZE];
        LPBYTE   pSpTime = SpTime;
        DWORD    Sz = sizeof(tSpTime);
        LONG     RetVal;
        DWORD    Hr = 0;
        DWORD    Mt = 0;
        DWORD    Sec = 0;
        LONG     TimeInt;


   // DBGENTER("GetSpTimeData\n");
        *pfSpTime = FALSE;

try {

            Sz = sizeof(tSpTime);
            RetVal = RegQueryValueEx(
                             SubKey,
                             WINSCNF_SP_TIME_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             tSpTime,
                             &Sz
                                                );

            //
            // If the user has not specifed a specific time, then we use
            // the current time as the specific time.  For current time,
            // the interval is 0
            //
            if (RetVal == ERROR_SUCCESS)
            {

#ifdef UNICODE
                (VOID)WinsMscConvertUnicodeStringToAscii(tSpTime, SpTime, MAX_SZ_SIZE);
#else
                pSpTime = tSpTime;
#endif

                RetVal = (LONG)sscanf(pSpTime, "%d:%d:%d", &Hr, &Mt, &Sec);
                if ((RetVal == EOF) || (RetVal == 0))
                {
                        DBGPRINT1(ERR, "GetSpTime: Wrong time format (%s)\n",
                                                pSpTime);
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WRONG_TIME_FORMAT);
                }
                else
                {

                  *pSpTimeIntvl = 0;
                  if ((Hr <= 23)  && (Mt <= 59) && (Sec <= 59))
                  {
                     TimeInt =  ((Hr * 3600) + (Mt * 60) + Sec) -
                                       ((pCurrTime->wHour * 3600) +
                                        (pCurrTime->wMinute * 60) +
                                         pCurrTime->wSecond);
                     if (TimeInt < 0)
                     {
                        *pSpTimeIntvl =  (24 * 3600) + TimeInt;
                     }
                     else
                     {
                        *pSpTimeIntvl =  TimeInt;
                     }
                     *pfSpTime      = TRUE;
                     DBGPRINT1(DET, "GetSpTimeData: Sp. Time Interval is %d\n",
                            *pSpTimeIntvl);
                  }
                  else
                  {
                     DBGPRINT0(DET, "GetSpTimeData: WRONG TIME FORMAT\n");
                  }
                }
            }
 }
 except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("GetSpTime");
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CONFIG_ERR);
        }
//    DBGLEAVE("GetSpTimeData\n");
    return;
}
#if MCAST > 0
STATUS
WinsCnfAddPnr(
  RPL_RR_TYPE_E  RRType_e,
  LPBYTE         pPnrAdd
)
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

     LONG RetVal;
     HKEY  CnfKey;
     HKEY  PnrKey;
     DWORD NewKeyInd;

     DBGENTER("WinsCnfAddPnr\n");
     /*
     *  Open the key (PULL/PUSH)
     */
     RetVal =   RegOpenKeyEx(
                sConfigRoot,                //predefined key value
                RRType_e == RPL_E_PULL ?
                        _WINS_CFG_PULL_KEY :
                        _WINS_CFG_PUSH_KEY,        //subkey for WINS
                0,                          //must be zero (reserved)
                KEY_CREATE_SUB_KEY,    //we want "subkey create" priv
                &CnfKey                //handle to key
                );

     if (RetVal != ERROR_SUCCESS)
     {

CHECK("Is there any need to log this")
        WINSEVT_LOG_INFO_M(
                                RetVal,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_CANT_OPEN_PULL_KEY :
                                        WINS_EVT_CANT_OPEN_PUSH_KEY
                         );
        return (WINS_FAILURE);
   }
     //
     //  Add the pnr
     //
     RetVal = RegCreateKeyExA(
                CnfKey,        //predefined key value
                pPnrAdd,                //subkey for WINS
                0,                        //must be zero (reserved)
                "Class",                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &PnrKey,                //handle to key
                &NewKeyInd                //is it a new key (out arg)
                );



    if (RetVal != ERROR_SUCCESS)
    {
        WINSEVT_LOG_M(
                       RetVal,
                       RRType_e == RPL_E_PULL ? WINS_EVT_CANT_OPEN_PULL_SUBKEY
                                              : WINS_EVT_CANT_OPEN_PUSH_SUBKEY
                           );
         DBGPRINT3(ERR, "WinsCnfAddPnr: Could not create key with address = (%s) under the %s Key. RetVal = (%d)\n", pPnrAdd,
                       RRType_e == RPL_E_PULL ? "PULL" : "PUSH",
                       RetVal);
         return(WINS_FAILURE);
    }
    else
    {
         if (NewKeyInd != REG_CREATED_NEW_KEY)
         {
            DBGPRINT2(ERR, "WinsCnfAddPnr: key with address = (%s) under the %s Key already present\n", pPnrAdd, RRType_e == RPL_E_PULL ? "PULL" : "PUSH");
         }
         else
         {

             //
             // If Pull pnr, add the time interval
             //
             if (RRType_e == RPL_E_PULL)
             {
                 //
                 // Add the time interval
                 //
                 SetVal(PnrKey, WINSCNF_RPL_INTERVAL_NM, REG_DWORD,
                     (LPWSTR)WINSCNF_TIME_INT_W_SELF_FND_PNRS, sizeof(DWORD));

             }
             SetVal(PnrKey, WINSCNF_SELF_FND_NM, REG_DWORD,
                       (LPWSTR)TRUE, sizeof(DWORD));

         }
         RegCloseKey(PnrKey);
         RegCloseKey(CnfKey);

    }

    DBGLEAVE("WinsCnfAddPnr\n");
    return(WINS_SUCCESS);
}
STATUS
WinsCnfDelPnr(
  RPL_RR_TYPE_E  RRType_e,
  LPBYTE         pPnrAdd
)
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

     LONG RetVal;
     HKEY  TypeOfPnrKey;
     HKEY  PnrKey;
     //WCHAR Key[160];
     WCHAR String[160];
     BOOL  fSelfFnd;
     DWORD Sz;
     DWORD ValType;

     DBGENTER("WinsCnfDelPnr\n");

     WinsMscConvertAsciiStringToUnicode(pPnrAdd, (LPBYTE)String, sizeof(String)/sizeof(WCHAR));

     /*
     *  Open the key (PULL/PUSH)
     */
     RetVal =   RegOpenKeyEx(
                sConfigRoot,                //predefined key value
                RRType_e == RPL_E_PULL ?
                        _WINS_CFG_PULL_KEY :
                        _WINS_CFG_PUSH_KEY,
                0,                          //must be zero (reserved)
                KEY_ALL_ACCESS,
                &TypeOfPnrKey                //handle to key
                );

     if (RetVal != ERROR_SUCCESS)
     {

CHECK("Is there any need to log this")
        WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_CANT_OPEN_PULL_KEY :
                                        WINS_EVT_CANT_OPEN_PUSH_KEY
                         );
        //--ft: Prefix bug 444974 - this key has to exist. If absurdly is missing, we won't find
        // the partner anyhow.
        return (WINS_SUCCESS);
     }
     RetVal = RegOpenKeyEx(
                TypeOfPnrKey,        //predefined key value
                String,
                0,                          //must be zero (reserved)
                KEY_ALL_ACCESS,    //we want "subkey create" priv
                &PnrKey                //handle to key
                );



    if (RetVal != ERROR_SUCCESS)
    {
         DBGPRINT3(ERR, "WinsCnfDelPnr: %s Pnr with address = (%s) is Non-existent. RetVal = (%d)",
                       RRType_e == RPL_E_PULL ? "PULL" : "PUSH", pPnrAdd,
                       RetVal);
         return(WINS_SUCCESS);
    }
    else
    {
          Sz = sizeof(fSelfFnd);
          RetVal = RegQueryValueEx(
                                        PnrKey,
                                        WINSCNF_SELF_FND_NM,
                                        NULL,
                                        &ValType,
                                        (LPBYTE)&fSelfFnd,
                                        &Sz
                                  );

         //
         // If SelfFnd is there and it's value is 1, delete it
         //
         if ((RetVal == ERROR_SUCCESS) && (fSelfFnd == 1))
         {
            RetVal = RegDeleteKey(TypeOfPnrKey, String);
            if (RetVal != ERROR_SUCCESS)
            {
               DBGPRINT3(ERR, "WinsCnfDelPnr: Could not delete %s Pnr with address = (%s). RetVal = (%d)",
                       RRType_e == RPL_E_PULL ? "PULL" : "PUSH", pPnrAdd,
                       RetVal);
               RegCloseKey(PnrKey);
               return(WINS_FAILURE);

            }
         }
         RegCloseKey(TypeOfPnrKey);

    }

    DBGLEAVE("WinsCnfDelPnr\n");
    return(WINS_SUCCESS);
}

DWORD
SetVal(
       HKEY     RootKey,
       LPWSTR   pName,
       DWORD    ValType,
       LPWSTR   pVal,
       DWORD    ValSize
)
{
        UINT Status = WINS_SUCCESS;
        LONG  RetVal;
        DWORD Val;
        if (ValType == REG_DWORD)
        {
             Val = PtrToUlong (pVal);
        }
        RetVal = RegSetValueEx(
                          RootKey,
                          pName,
                          0,         //reserved -- must be 0
                          ValType,
                          ValType == REG_DWORD ? (LPBYTE)&Val : (LPBYTE)pVal,
                          ValType == REG_DWORD ?  ValSize : lstrlen(pVal)
                             );

        if (RetVal != ERROR_SUCCESS)
        {
                 printf("SetVal: Could not set value of %s\n", pName);
                 Status = WINS_FAILURE;
        }

        return(Status);
}
#endif

DWORD
WinsCnfWriteReg(
    LPVOID  pTmp
    )

/*++

Routine Description:
    This function write the value of the version counter to be used
    at the next invocation.

Arguments:
    pTmp - Will be NULL if WinsCnfNextTimeVersNo was found in the registry
           when WINS came up.

Externals Used:
    NmsHighWaterMarkVersNo
    NmsVersNoToStartFromNextTime
    NmsNmhNamRegCrtSec
    NmsRangeSize
    NmsHalfRangeSize
    sfVersNoChanged
    sfVersNoUpdThdExists

Return Value:

    VOID

Error Handling:

Called by:
    NMSNMH_INC_VERS_COUNTER_M

Side Effects:

Comments:
        None
--*/

{
    LONG  RetVal;
    LONG  RetVal2;
    VERS_NO_T VersNo;
    DBGENTER("WinsCnfWriteReg\n");
    EnterCriticalSection(&NmsNmhNamRegCrtSec);

    //
    // if pTmp is not NULL, it means that either WINS did not find
    // Next time's version number in the registry or that the max. version
    // number in the db is greater than the high water mark we set at
    // initialization.  In the former case, we already have the correct
    // value in NmsNmhToStartFromNextTime, so the if body is not executed.
    //
    if (!pTmp || LiLtr(NmsHighWaterMarkVersNo, NmsNmhMyMaxVersNo))
    {
         NmsHighWaterMarkVersNo.QuadPart   = LiAdd(NmsVersNoToStartFromNextTime,
                                                NmsHalfRangeSize);
         NmsVersNoToStartFromNextTime.QuadPart = LiAdd(NmsVersNoToStartFromNextTime,
                                                        NmsRangeSize);
    }
    VersNo = NmsVersNoToStartFromNextTime;
    LeaveCriticalSection(&NmsNmhNamRegCrtSec);

    RetVal = RegSetValueEx(
                        sConfigRoot,
                        WINSCNF_INT_VERSNO_NEXTTIME_LW_NM,
                        0,         //reserved -- must be 0
                        REG_DWORD,
                        (LPBYTE)&VersNo.LowPart,
                        sizeof(DWORD)
                                        );


    RetVal2 = RegSetValueEx(
                        sConfigRoot,
                        WINSCNF_INT_VERSNO_NEXTTIME_HW_NM,
                        0,         //reserved -- must be 0
                        REG_DWORD,
                        (LPBYTE)&VersNo.HighPart,
                        sizeof(DWORD)
                                        );
    if ((RetVal != ERROR_SUCCESS) || (RetVal2 != ERROR_SUCCESS))
    {
                DBGPRINT2(ERR, "WinsCnfWriteReg - Could not set Next time's start version counter value in the registry.  The new value is (%d %d)\n", VersNo.HighPart, VersNo.LowPart);
    }

    EnterCriticalSection(&NmsNmhNamRegCrtSec);
    WinsCnfRegUpdThdExists = FALSE;
    LeaveCriticalSection(&NmsNmhNamRegCrtSec);
    DBGLEAVE("WinsCnfWriteReg\n");
    return(WINS_SUCCESS);
}

#if defined (DBGSVC)  && !defined (WINS_INTERACTIVE)
VOID
WinsCnfReadWinsDbgFlagValue(
        VOID
        )
{
        DWORD Sz;
          DWORD ValTyp;

        WinsDbg = 0;   //set it to zero now.  It was set to a value by Init() in
                   //nms.c
        Sz = sizeof(WinsDbg);
        (VOID)RegQueryValueEx(
                             sParametersKey,
                             WINSCNF_DBGFLAGS_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             (LPBYTE)&WinsDbg,
                             &Sz
                                );

        return;
}
#endif


VOID
ReadSpecGrpMasks(
        PWINSCNF_CNF_T pWinsCnf
        )

/*++

Routine Description:
        This function is called to read in the special group masks specified
        under the SpecialGrpMasks key

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DWORD NoOfSubKeys;
        HKEY  SGMKey;
        BOOL  fKeyOpen = FALSE;
           LONG  RetVal;
        DBGENTER("ReadSpecGrpMasks\n");
try {
           /*
           *  Open the SPEC_GRP_MASKS key
           */
           RetVal =   RegOpenKeyEx(
                        sParametersKey,                //predefined key value
                        _WINS_CFG_SPEC_GRP_MASKS_KEY,
                        0,                //must be zero (reserved)
                        KEY_READ,        //we desire read access to the keyo
                        &SGMKey                //handle to key
                );
        if (RetVal == ERROR_SUCCESS)
        {
            fKeyOpen = TRUE;
           //
           // Get the count of data files listed under the DATAFILES
           // key
           //
           GetKeyInfo(
                        SGMKey,
                        WINSCNF_E_SPEC_GRP_MASKS_KEY,
                        &NoOfSubKeys,                        //ignored
                        &pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks
                      );
           if (pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks > 0)
           {

                DWORD                 Index;
                LPBYTE                 pTmp;
                TCHAR                 ValNmBuff[5];
                DWORD                 ValNmBuffSz;
                DWORD                 StrType;
                LPBYTE                 pByte;
                DWORD                 BuffSize;
                CHAR                 Tmp[WINS_MAX_FILENAME_SZ];
#ifdef UNICODE
                WCHAR                Str[WINSCNF_SPEC_GRP_MASK_SZ];
#endif

                  //
                  // Allocate buffer big enough to hold data for
                // the number of subkeys found under the PULL key
                  //
                  BuffSize = (WINSCNF_SPEC_GRP_MASK_SZ + 1) *
                                pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks;
                    WinsMscAlloc( BuffSize, &pWinsCnf->SpecGrpMasks.pSpecGrpMasks);

                   /*
                    *   Enumerate  the values
                     */
                     for(
                        Index = 0, pTmp = pWinsCnf->SpecGrpMasks.pSpecGrpMasks;
                        Index <  pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks;
                                // no third expression
                         )
                {
                        ValNmBuffSz = sizeof(ValNmBuff)/sizeof(TCHAR);  //init before
                                                          //every call
                        BuffSize  = WINSCNF_SPEC_GRP_MASK_SZ;
                          RetVal = RegEnumValue(
                                    SGMKey,
                                    Index,        //key
                                    ValNmBuff,
                                    &ValNmBuffSz,
                                    (LPDWORD)NULL,                //reserved
                                    &StrType,
#ifdef UNICODE
                                    (LPBYTE)Str,
#else
                                    pTmp,
#endif
                                    &BuffSize
                                            );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                continue;
                        }

                        //
                        // if StrType is not REG_SZ  go to the next  Value
                        //
                        if  (StrType != REG_SZ)
                        {
                                continue;
                        }
                        if (BuffSize != WINSCNF_SPEC_GRP_MASK_SZ)
                        {
                                DBGPRINT1(ERR, "ReadSpecGrpMasks: Wrong spec. grp mask (%s)\n", pTmp);

                                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WRONG_SPEC_GRP_MASK_M);
                                continue;
                        }
                        else
                        {
#ifdef UNICODE
                          WinsMscConvertUnicodeStringToAscii(
                                                (LPBYTE)Str,
                                                (LPBYTE)Tmp,
                                                WINSCNF_SPEC_GRP_MASK_SZ
                                                );
#endif
                          pByte = (LPBYTE)Tmp;
                          for (Index = 0; Index < WINSCNF_SPEC_GRP_MASK_SZ;
                                        Index++, pByte++)
                          {
                                *pByte = (BYTE)CharUpperA((LPSTR)*pByte);
                                if (
                                        ((*pByte >= '0') && (*pByte <= '9'))
                                                        ||
                                        ((*pByte >= 'A') && (*pByte <= 'F'))
                                   )
                                {
                                        continue;
                                }
                                else
                                {
                                        break;
                                }

                          }
                          if (Index > WINSCNF_SPEC_GRP_MASK_SZ)
                          {
                                DBGPRINT1(ERR, "ReadSpecGrpMasks: Wrong spec. grp mask (%s)\n", pTmp);
                                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WRONG_SPEC_GRP_MASK_M);
                                continue;
                          }
                         *(pTmp + WINSCNF_SPEC_GRP_MASK_SZ) = EOS;
                        }

                        Index++;
                        pTmp += WINSCNF_SPEC_GRP_MASK_SZ + 1;
                }

                //
                // If not even one valid name was retrieved, get rid of the
                // buffer
                //
                if (Index == 0)
                {
                        //
                        // Get rid of the buffer
                        //
                        WinsMscDealloc((LPBYTE)pWinsCnf->SpecGrpMasks.pSpecGrpMasks);
                }

                pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks = Index;
           }
        } // end of if
 } // end of try ..
 except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("ReadSpecGrpMasks");
                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_CANT_INIT);
        }

        if (fKeyOpen && RegCloseKey(SGMKey) != ERROR_SUCCESS)
        {
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_CLOSE_KEY);
                DBGPRINT0(ERR, "ReadSpecGrpMasks: Can not read the spec. grp. mask. key\n");
        }
        DBGLEAVE("ReadSpecGrpMasks\n");
        return;
}


#if 0
int
__cdecl
CompUpdCnt(
        CONST LPVOID  pElem1,
        CONST LPVOID  pElem2
        )

/*++

Routine Description:
        This function is called by qsort crtl function to compare two
        elements of the array that has to be sorted


Arguments:
        pElem1 - ptr to first element
        pElem1 - ptr to second element

Externals Used:
        None

Return Value:
        -1 if first element is < second element
        = 0 if first element is == second element
        1 if first element is > second element

Error Handling:

Called by:
        qsort (which is called by WinsCnfReadPartnerInfo

Side Effects:

Comments:
        Not used currently
--*/

{

        CONST PRPL_CONFIG_REC_T        pCnfRec1 = pElem1;
        CONST PRPL_CONFIG_REC_T        pCnfRec2 = pElem2;

        if (pCnfRec1->UpdateCount < pCnfRec2->UpdateCount)
        {
                return(-1);
        }
        else
        {
                if (pCnfRec1->UpdateCount == pCnfRec2->UpdateCount)
                {
                        return(0);
                }
        }

        //
        // The first record has a higher UpdateCount than the second one
        //
        return(1);
}

#endif

#ifdef WINSDBG
VOID
PrintRecs(
        RPL_RR_TYPE_E  RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        )
{
 return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\inc\winstmm.h ===
#ifndef _WINSTMM_
#define _WINSTMM_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winstmm.h

	

Abstract:
	This is the header file for calling winstmm.c functions
 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "winsque.h"
#include "nmsdb.h"
/*
  defines
*/

#define   PAD			        10
#define  WINSTMM_MAX_SET_TMM_REQS	NMSDB_MAX_OWNERS_INITIALLY + PAD //use a pad
#if (WINSTMM_MAX_SET_TMM_REQS < NMSDB_MAX_OWNERS_INITIALLY + PAD)
#error("Your WINSTMM_MAX_SET_TMM_REQS is not set properly:)
#endif
/*
  macros
*/

/*
 externs
*/
extern HANDLE	WinsTmmHeapHdl;

/* 
 typedef  definitions
*/
//
// structure used to keep track of handles to set timer requests made
// by a component  
//
//
FUTURES("Use this in the future")
typedef struct _WINSTMM_TIMER_REQ_ACCT_T {
		DWORD	NoOfSetTimeReqs;
		LPDWORD	pSetTimeReqHdl;
		} WINSTMM_TIMER_REQ_ACCT_T, *PWINSTMM_TIMER_REQ_ACCT_T;

/* 
 function declarations
*/

extern
VOID 
WinsTmmInsertEntry(
	PQUE_TMM_REQ_WRK_ITM_T  pPassedWrkItm,
	WINS_CLIENT_E		Client_e,
	QUE_CMD_TYP_E   	CmdTyp_e,
	BOOL			fResubmit,
	time_t			AbsTime,
	DWORD			TimeInt,
	PQUE_HD_T		pRspQueHd,
	LPVOID			pClientCtx,
	DWORD			MagicNo,
	PWINSTMM_TIMER_REQ_ACCT_T pSetTimerReqs  //not used currently
	);


extern
VOID
WinsTmmInit(
	VOID
	);


//
// called when reconfiguring WINS
//
extern
VOID
WinsTmmDeleteReqs(
	WINS_CLIENT_E	WinsClient_e
	);



extern
VOID
WinsTmmDeallocReq(
	PQUE_TMM_REQ_WRK_ITM_T pWrkItm
	);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winsintf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        winsintf.c

Abstract:
        This module contains the RPC interface to the WINS server

Functions:
        R_WinsRecordAction
        R_WinsStatus
        R_WinsTrigger
        R_WinsDoStaticInit
        R_WinsGetDbRecs
        R_WinsDelDbRecs
        R_WinsSetProcPriority
        WinsRecordAction
        GetWinsStatus
        WinsTrigger
        WinsDoStaticInit
        WinsDoScavenging
        WinsGetDbRecs
        WinsDelDbRecs
        WinsSetProcPriority
        sGetVersNo
        GetConfig
        GetStatistics


Portability:

        This module is portable


Author:

        Pradeep Bahl (PradeepB)          Mar-1993

Revision History:

        Modification date        Person          Description of modification
        -----------------        -------         ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include <lmerr.h>
#include <lmcons.h>                //defines NET_API_STATUS
#include <secobj.h>
#include <rpcutil.h>                //for NetpRevertToSelf
#include <rpcndr.h>
#include "winsif.h"
#include "winsi2.h"
#include "winsintf.h"
#include "comm.h"
#include "winsque.h"
#include "nms.h"
#include "nmsnmh.h"
#include "nmsmsgf.h"
#include "nmsdb.h"
#include "nmsscv.h"
#include "rpl.h"
#include "rplpull.h"
#include "winscnf.h"
#include "winsevt.h"
#include "winsmsc.h"
#include "winsprs.h"
#include "winstmm.h"
#ifdef WINSDBG
#include "winbasep.h"
#endif

/*
 *        Local Macro Declarations
 */

#if SECURITY > 0
#define  CHK_ACCESS_LEVEL_M(_access)        {                          \
                   if (!sfBS)                                   \
                   {                                            \
                        NET_API_STATUS NetStatus;               \
                        NetStatus = NetpAccessCheckAndAudit(    \
                                        WINS_SERVER,            \
                                        WINS_SERVER,            \
                                        pNmsSecurityDescriptor, \
                                        _access,    \
                                        &NmsInfoMapping         \
                                        );                      \
                        if (NetStatus != NERR_Success)          \
                        {                                       \
                                DBGPRINT1(ERR, "The Caller of the rpc function does not have the required permissions. NetSTatus is (%d)\n", NetStatus);   \
                                WINSEVT_LOG_M(NetStatus, WINS_EVT_NO_PERM);\
                                return(NetStatus);              \
                        }                                       \
                  }                                             \
        }

#else
#define  CHK_ACCESS_LEVEL_M()
#endif

#define INC_RPC_DB_COUNT_NCHK_M    {                         \
                     EnterCriticalSection(&NmsTermCrtSec);   \
                     NmsTotalTrmThdCnt++;                  \
                     LeaveCriticalSection(&NmsTermCrtSec);   \
           }
#define INC_RPC_DB_COUNT_M    {                              \
              if (WinsCnf.State_e != WINSCNF_E_TERMINATING)  \
              {                                              \
                     INC_RPC_DB_COUNT_NCHK_M;                \
              }                                              \
              else                                           \
              {                                              \
                     return(WINSINTF_FAILURE);               \
              }                                              \
           }
#define DEC_RPC_DB_COUNT_M    {                              \
              EnterCriticalSection(&NmsTermCrtSec);          \
              if (--NmsTotalTrmThdCnt == 1)                  \
              {                                              \
                   DBGPRINT0(FLOW, "RPC thread: Signaling the main thread\n");\
                   SetEvent(NmsMainTermEvt);                 \
              }                                              \
              LeaveCriticalSection(&NmsTermCrtSec);          \
           }
/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */
WINSINTF_STAT_T        WinsIntfStat = {0};

DWORD                WinsIntfNoOfNbtThds;
DWORD                WinsIntfNoCncrntStaticInits = 0;
//DWORD                WinsIntfNoOfRpcThds = 0;
CRITICAL_SECTION WinsIntfCrtSec;

CRITICAL_SECTION WinsIntfPotentiallyLongCrtSec;
CRITICAL_SECTION WinsIntfNoOfUsersCrtSec;  //extern in nms.h

/*
 *        Local Variable Definitions
*/
STATIC  BOOL    sfBS = FALSE;

//
// Time interval between reflushing of the 1B cache
//
#define THREE_MTS 180

//
// Used by WinsGetBrowserNames
//
DOM_CACHE_T sDomCache = { 0, NULL, 0, 0, NULL, FALSE};

/*
 *        Local Function Prototype Declarations
 */
DWORD
GetWinsStatus(
   IN  WINSINTF_CMD_E          Cmd_e,
   OUT LPVOID  pResults,
   BOOL fNew
        );

STATIC
DWORD
sGetVersNo(
        LPVOID  pResults
        );

STATIC
DWORD
GetStatistics(
        LPVOID  pResults,
        BOOL  fNew
        );

STATIC
DWORD
GetConfig(
        LPVOID   pResults,
        BOOL     fNew,
        BOOL     fAllMaps
        );

VOID
LogClientInfo(
        RPC_BINDING_HANDLE ClientHdl,
        BOOL               fAbruptTerm
  );


STATIC
STATUS
PackageRecs(
        PRPL_REC_ENTRY2_T     pBuff,
        DWORD                BuffLen,
        DWORD                NoOfRecs,
        PWINSINTF_RECS_T     pRecs
     );


//
// Function definitions start here
//

DWORD
R_WinsCheckAccess(
    WINSIF2_HANDLE        ServerHdl,
    DWORD                 *Access
    )
{
    NET_API_STATUS NetStatus;
    *Access = WINS_NO_ACCESS;
    NetStatus = NetpAccessCheckAndAudit(
                    WINS_SERVER,
                    WINS_SERVER,
                    pNmsSecurityDescriptor,
                    WINS_CONTROL_ACCESS,
                    &NmsInfoMapping
                    );
    if (NERR_Success == NetStatus) {
        *Access = WINS_CONTROL_ACCESS;
        return WINSINTF_SUCCESS;
    }
    NetStatus = NetpAccessCheckAndAudit(
                    WINS_SERVER,
                    WINS_SERVER,
                    pNmsSecurityDescriptor,
                    WINS_QUERY_ACCESS,
                    &NmsInfoMapping
                    );
    if (NERR_Success == NetStatus) {
        *Access = WINS_QUERY_ACCESS;
        return WINSINTF_SUCCESS;
    }
    return WINSINTF_SUCCESS;
}

DWORD
R_WinsRecordAction(
        PWINSINTF_RECORD_ACTION_T        *ppRecAction
        )

/*++

Routine Description:
        This function is called to insert/update/delete a record

Arguments:
        pRecAction - Record Information

Externals Used:
        None

Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

  DWORD                Status = WINSINTF_FAILURE;

PERF("Use & and || logic")

  if (*ppRecAction == NULL)
  {
       return(Status);
  }
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
          if (WINSINTF_E_QUERY == (*ppRecAction)->Cmd_e) {
              CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
          } else {
              CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
          }
          INC_RPC_DB_COUNT_NCHK_M;
try {
          Status = WinsRecordAction(ppRecAction);
}
finally {
          DEC_RPC_DB_COUNT_M;
}
  }

  return(Status);
}


DWORD
R_WinsStatusWHdl (
   WINSIF_HANDLE             pWinsHdl,
   WINSINTF_CMD_E          Cmd_e,
   PWINSINTF_RESULTS_NEW_T  pResults
        )
{
    return(R_WinsStatusNew(Cmd_e, pResults));

}

DWORD
R_WinsStatus (
  // LPTSTR                pWinsAddStr,
   WINSINTF_CMD_E          Cmd_e,
   PWINSINTF_RESULTS_T  pResults
        )
{

  DWORD                Status = WINSINTF_FAILURE;

  //
  // Make sure that the WINS is in steady state
  //
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
     CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
     Status = GetWinsStatus(/*pWinsAddStr,*/Cmd_e, pResults, FALSE);
  }
  return(Status);
}
DWORD
R_WinsStatusNew (
   WINSINTF_CMD_E          Cmd_e,
   PWINSINTF_RESULTS_NEW_T     pResults
        )
{

  DWORD                Status = WINSINTF_FAILURE;

  //
  // Make sure that the WINS is in steady state
  //
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
     CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
     Status = GetWinsStatus(Cmd_e, pResults, TRUE);
  }
  return(Status);
}

DWORD
R_WinsTrigger (
        PWINSINTF_ADD_T             pWinsAdd,
        WINSINTF_TRIG_TYPE_E          TrigType_e
        )
{
  DWORD                Status = WINSINTF_FAILURE;
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
        CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
          Status = WinsTrigger(pWinsAdd, TrigType_e);
  }
  return(Status);
}

DWORD
R_WinsDoStaticInit (
        LPWSTR         pDataFilePath,
        DWORD          fDel
        )
{
  DWORD                Status;

  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  EnterCriticalSection(&WinsIntfCrtSec);

  //
  // The admin tool can go haywire and create a lot of threads.  Limit it
  // to a certain max value. The value will be incremented and decremented
  // by the thread doing the STATIC initialization.
  //
  if (WinsIntfNoCncrntStaticInits > WINSCNF_MAX_CNCRNT_STATIC_INITS)
  {
          LeaveCriticalSection(&WinsIntfCrtSec);
    DBGPRINT1(ERR, "R_WinsDoStaticInit: Too many concurrent STATIC inits. No is (%d)\n", WinsIntfNoCncrntStaticInits);
    WINSEVT_LOG_D_M(WinsIntfNoCncrntStaticInits, WINS_EVT_TOO_MANY_STATIC_INITS);
        return(WINSINTF_TOO_MANY_STATIC_INITS);
  }
  LeaveCriticalSection(&WinsIntfCrtSec);
  Status = WinsDoStaticInit(pDataFilePath, fDel);
  return(Status);
}

DWORD
R_WinsDoScavenging (
        VOID
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDoScavenging();
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}

DWORD
R_WinsDoScavengingNew (
        PWINSINTF_SCV_REQ_T  pScvReq
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDoScavengingNew(pScvReq);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}

DWORD
R_WinsGetDbRecs (
        PWINSINTF_ADD_T             pWinsAdd,
        WINSINTF_VERS_NO_T          MinVersNo,
        WINSINTF_VERS_NO_T          MaxVersNo,
        PWINSINTF_RECS_T          pRecs
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
#if 0
#ifdef WINSDBG
   PVOID pCallersAdd, pCallersCaller;
   RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
   DbgPrint("Callers Address = (%x)\nCallersCaller = (%x)\n", pCallersAdd, pCallersCaller);

#endif
#endif
  Status = WinsGetDbRecs(pWinsAdd, MinVersNo, MaxVersNo, pRecs);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}
DWORD
R_WinsGetDbRecsByName (
        PWINSINTF_ADD_T             pWinsAdd,
        DWORD                       Location,
        LPBYTE                      pName,
        DWORD                       NameLen,
        DWORD                       NoOfRecsDesired,
        DWORD                       fStaticOnly,
        PWINSINTF_RECS_T            pRecs
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
#if 0
#ifdef WINSDBG
   PVOID pCallersAdd, pCallersCaller;
   RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
#endif
#endif
  Status = WinsGetDbRecsByName(pWinsAdd, Location, pName, NameLen, NoOfRecsDesired,
                   fStaticOnly, pRecs);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}



DWORD
R_WinsDeleteWins(
        PWINSINTF_ADD_T   pWinsAdd
        )
{
  DWORD                Status;
  //LogClientInfo();
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDeleteWins(pWinsAdd);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}

DWORD
R_WinsTerm (
        handle_t                ClientHdl,
        short                        fAbruptTerm
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsTerm(ClientHdl, fAbruptTerm);
  LogClientInfo(ClientHdl, fAbruptTerm);
  return(Status);
}


DWORD
R_WinsBackup (
   LPBYTE                pBackupPath,
   short                fIncremental
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  BYTE                BackupPath[WINS_MAX_FILENAME_SZ + sizeof(WINS_BACKUP_DIR_ASCII)];
#if 0
  (VOID)WinsMscConvertUnicodeStringToAscii(pBackupPath, BackupPath, WINS_MAX_FILENAME_SZ);
#endif
FUTURES("expensive.  Change idl prototype to pass length")
   if (strlen(pBackupPath) > WINS_MAX_FILENAME_SZ)
   {
         return(Status);
   }
  //
  // Make sure that the WINS is in steady state
  //
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
      CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
      INC_RPC_DB_COUNT_NCHK_M;
      WinsLogAdminEvent( WINS_EVT_ADMIN_BACKUP_INITIATED, 0 );
try {
      strcpy(BackupPath, pBackupPath);
      strcat(BackupPath, WINS_BACKUP_DIR_ASCII);
      if (CreateDirectoryA(BackupPath, NULL) || ((Status = GetLastError()) ==
                                                    ERROR_ALREADY_EXISTS))
      {
         Status = WinsBackup(BackupPath, fIncremental);
      }
}
finally {
      DEC_RPC_DB_COUNT_M;
}
  }
  return(Status);
}

DWORD
R_WinsDelDbRecs(
        IN PWINSINTF_ADD_T        pAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDelDbRecs(pAdd, MinVersNo, MaxVersNo);
}
finally {
   DEC_RPC_DB_COUNT_M;
   }
  return(Status);
}

DWORD
R_WinsTombstoneDbRecs(
        IN WINSIF2_HANDLE            ServerHdl,
        IN PWINSINTF_ADD_T           pWinsAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsTombstoneDbRecs(pWinsAdd, MinVersNo, MaxVersNo);
}
finally {
   DEC_RPC_DB_COUNT_M;
   }
  return(Status);
}

DWORD
R_WinsPullRange(
        IN PWINSINTF_ADD_T        pAdd,
        IN PWINSINTF_ADD_T        pOwnerAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsPullRange(pAdd, pOwnerAdd, MinVersNo, MaxVersNo);
  return(Status);
}

DWORD
R_WinsSetPriorityClass(
        IN WINSINTF_PRIORITY_CLASS_E        PriorityClass
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsSetPriorityClass(PriorityClass);
  return(Status);
}

DWORD
R_WinsResetCounters(
        VOID
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsResetCounters();
  return(Status);
}

DWORD
R_WinsWorkerThdUpd(
        DWORD NewNoOfNbtThds
        )
{
  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsWorkerThdUpd(NewNoOfNbtThds);
  return(Status);
}

DWORD
R_WinsGetNameAndAdd(
        PWINSINTF_ADD_T   pWinsAdd,
        LPBYTE                  pUncName
        )
{
  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
  Status = WinsGetNameAndAdd(pWinsAdd, pUncName);
  return(Status);
}

DWORD
R_WinsGetBrowserNames_Old(
        PWINSINTF_BROWSER_NAMES_T         pNames
        )
{
  return(WINSINTF_FAILURE);
}



DWORD
R_WinsGetBrowserNames(
        WINSIF_HANDLE             pWinsHdl,
        PWINSINTF_BROWSER_NAMES_T         pNames
        )
{
  DWORD                Status = WINSINTF_FAILURE;

  static DWORD    sNoOfReq = 0;

  //
  // Allow access to anybody.  We don't check access here since
  // browser running as a service has zero access when it goes
  // on the network (It goes under the null account -- CliffVDyke 4/15/94)
  //
  INC_RPC_DB_COUNT_M;
  EnterCriticalSection(&WinsIntfPotentiallyLongCrtSec);
try {
  if (sNoOfReq++ < NMS_MAX_BROWSER_RPC_CALLS)
  {
    Status = WinsGetBrowserNames((PWINSINTF_BIND_DATA_T)pWinsHdl,pNames);
  }
  else
  {
        pNames->EntriesRead = 0;
        pNames->pInfo = NULL;
        Status = WINSINTF_FAILURE;
  }
 } // end of try
finally {
  sNoOfReq--;

  //
  //  increment the user count.
  //
  EnterCriticalSection(&WinsIntfNoOfUsersCrtSec);
  sDomCache.NoOfUsers++;
  LeaveCriticalSection(&WinsIntfNoOfUsersCrtSec);

  LeaveCriticalSection(&WinsIntfPotentiallyLongCrtSec);
  DEC_RPC_DB_COUNT_M;

 }
  return(Status);
}


DWORD
R_WinsSetFlags (
        DWORD    fFlags
        )
{
  DWORD                Status = WINSINTF_SUCCESS;

  Status = WinsSetFlags(fFlags);
  return(Status);
}

DWORD
WinsSetFlags (
        DWORD    fFlags
        )
{
  DWORD                Status = WINSINTF_SUCCESS;
#ifdef WINSDBG
  DWORD                DbgFlagsStore = WinsDbg;
  SYSTEMTIME           SystemTime;
  BOOL                 sHaveProcessHeapHdl = FALSE;
  HANDLE               PrHeapHdl;

  typedef struct _HEAP_INFO_T {
     HANDLE HeapHdl;
     LPBYTE cstrHeapType;
     } HEAP_INFO_T, *PHEAP_INFO_T;

#define PRINT_TIME_OF_DUMP_M(SystemTime, Str)  {DBGPRINT5(SPEC, "Activity: %s done on %d/%d at %d.%d \n", Str, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute); }

#endif

  //sfBS = fFlags & WINSINTF_BS;

  DBGPRINT2(ERR, "WinsSetFlags: NmsDbDelDelDataRecs = (%d)\nNmsDbDelQueryNUpdRecs = (%d)\n", NmsDbDelDelDataRecs, NmsDbDelQueryNUpdRecs);

#ifdef WINSDBG
  if (!sHaveProcessHeapHdl)
  {
    PrHeapHdl = GetProcessHeap();
  }
  GetSystemTime(&SystemTime);
  WinsDbg |= DBG_SPEC;
  if (fFlags & WINSINTF_MEMORY_INFO_DUMP)
  {
     MEMORYSTATUS Mem;
     static SIZE_T  sLTVmUsed = 0;
     SIZE_T VmUsed;

     DBGPRINT0(SPEC, "\n\n------------------MEMORY USAGE INFO-----------------\n\n");
     GlobalMemoryStatus(&Mem);

     VmUsed = Mem.dwTotalVirtual - Mem.dwAvailVirtual;
     DBGPRINT2(SPEC, "VM used = (%d)\nDiff. from last time = (%d)\n", VmUsed,
         VmUsed - sLTVmUsed);
     sLTVmUsed = VmUsed;

  }
  EnterCriticalSection(&WinsCnfCnfCrtSec);
try {
  if (fFlags & WINSINTF_HEAP_INFO_DUMP)
  {
      HEAP_INFO_T HeapHdls[] = {
             CommUdpBuffHeapHdl,    "Udp Buff Heap",
             CommUdpDlgHeapHdl,      "Udp Dlg Heap",
             CommAssocDlgHeapHdl,    "Tcp Dlg Heap",
             CommAssocTcpMsgHeapHdl, "Tcp Msg Heap",
             GenBuffHeapHdl,         "General Heap",
             QueBuffHeapHdl,         "Que Wrk. Item Heap",
             NmsChlHeapHdl,           "Chl Req/Resp Heap",
             CommAssocAssocHeapHdl,   "Assoc. Msg Heap",
             RplWrkItmHeapHdl,        "Rpl Wrk Itm Heap",
             NmsRpcHeapHdl,           "Rpc Buff Heap",
             WinsTmmHeapHdl,          "Tmm Buff Heap",
             (LPHANDLE)NULL,                    NULL
                            };
     static SIZE_T sDiffLTHeapTotalANF[sizeof(HeapHdls)/sizeof(HEAP_INFO_T)] = {0};
     static SIZE_T sHeapTotalANF[sizeof(HeapHdls)/sizeof(HEAP_INFO_T)] = {0};
     SIZE_T  Size2;
     static SIZE_T  sTotalAllocNFree = 0;
     static SIZE_T  LastTimeTotalAllocNFree = 0;
//     NTSTATUS  Status;
     HANDLE  HeapHdl;
     DWORD  i, n;
     DWORD dwNumberOfHeaps;
     PHANDLE pPrHeaps;
     HEAP_SUMMARY heapSummary;

     PRINT_TIME_OF_DUMP_M(SystemTime, "HEAP DUMP");
     dwNumberOfHeaps = GetProcessHeaps(0, NULL);
     Size2 = sizeof(*pPrHeaps) * dwNumberOfHeaps;
     pPrHeaps = WinsMscHeapAlloc( NmsRpcHeapHdl, (ULONG)Size2);
     dwNumberOfHeaps = GetProcessHeaps(dwNumberOfHeaps, pPrHeaps);

     DBGPRINT1(SPEC, "No Of Heaps is (%d)\n",  dwNumberOfHeaps);
     DBGPRINT1(SPEC, "Process default heap handle is (%p)\n",  PrHeapHdl);
     LastTimeTotalAllocNFree = sTotalAllocNFree;
     sTotalAllocNFree = 0;
     heapSummary.cb = sizeof(HEAP_SUMMARY);
     for (i=0; i< dwNumberOfHeaps; i++)
     {
        DBGPRINT0(SPEC, "----------Heap Info--------------------------\n");
        DBGPRINT0(SPEC, "Heap -- ");

        HeapHdl = pPrHeaps[i];
        for (n = 0;  HeapHdls[n].HeapHdl != NULL; n++)
        {
            if (HeapHdl == HeapHdls[n].HeapHdl)
            {
              DBGPRINT1(SPEC, "%s\n", HeapHdls[n].cstrHeapType);
              break;
            }
        }
        if (HeapHdls[n].HeapHdl == NULL)
        {

            DBGPRINT0(SPEC, "Catch all Heap\n");
        }

        DBGPRINT1(SPEC, "Heap Hdl = (%p)\n", HeapHdl);
        if (HeapSummary(HeapHdl, 0, &heapSummary))
        {
           DBGPRINT2(SPEC,"Total Allocated = (%d)\nTotalFree = (%d)\n",
                        heapSummary.cbAllocated, heapSummary.cbCommitted - heapSummary.cbAllocated);
        }
        else
        {
           DBGPRINT0(SPEC,"COULD NOT GET HEAP INFO\n");
           continue;
        }



        sDiffLTHeapTotalANF[n] = heapSummary.cbCommitted - sHeapTotalANF[n];
        sHeapTotalANF[n] = heapSummary.cbCommitted;
        sTotalAllocNFree += sHeapTotalANF[n];
        DBGPRINT1(SPEC, "Size allocated from RpcHeap is  (%d)\n", Size2);
     } // end of for looping over process heaps

     DBGPRINT0(SPEC, "\n----------Heap Info End --------------------------\n");
     WinsMscHeapFree(NmsRpcHeapHdl, pPrHeaps);

     for (n = 0;  HeapHdls[n].HeapHdl != NULL; n++)
     {
              DBGPRINT3(SPEC, "%s -- Total AllocNFree = (%d); Diff from Last time = (%d)\n",
                      HeapHdls[n].cstrHeapType, sHeapTotalANF[n],
                      sDiffLTHeapTotalANF[n]
                      );
     }
     DBGPRINT2(SPEC, "\nTotal Process AllocNFree = (%d)\nDiff from last time = (%d)\n\n",  sTotalAllocNFree, sTotalAllocNFree - LastTimeTotalAllocNFree);

     if (WinsDbg & (DBG_HEAP_CNTRS | DBG_UPD_CNTRS))
     {
        NmsPrintCtrs();
     }
    }
    if (fFlags & WINSINTF_QUE_ITEMS_DUMP)
    {
       typedef struct _QUE_INFO_T {
          PQUE_HD_T  pQueHd;
          LPBYTE     cstrQueType;
         } QUE_INFO_T, *PQUE_INFO_T;

       QUE_INFO_T  Queues[] = {
            &QueNbtWrkQueHd,     "Nbt Query Que",
	    &QueOtherNbtWrkQueHd, "Nbt Reg. Que",
  	    &QueRplPullQueHd,   "Pull Thd Que",          //Pull requests
	    &QueRplPushQueHd,   "Push Thd Que",          //Push requests
	    &QueNmsNrcqQueHd,   "Chl Nbt Req. Msg Que",  //Chl req fr nbt thds
	    &QueNmsRrcqQueHd,   "Chl req. from Pull thd Que",
	    &QueNmsCrqQueHd,    "Chl rsp from UDP thd Que",
	    &QueWinsTmmQueHd,   "Timer Queue",
	    &QueInvalidQueHd,   "Invalid Que"
                        };
        PQUE_INFO_T pQueInfo = Queues;
        PRINT_TIME_OF_DUMP_M(SystemTime, "WORK ITEM DUMP");

        DBGPRINT0(SPEC, "----------Count of Wrk items-----------\n");
        for (; pQueInfo->pQueHd != &QueInvalidQueHd; pQueInfo++)
        {
             PLIST_ENTRY pTmp;
             DWORD NoOfWrkItms = 0;
             pTmp = &pQueInfo->pQueHd->Head;
             EnterCriticalSection(&pQueInfo->pQueHd->CrtSec);
//             NoOfWrkItms = pQueInfo->pQueHd->NoOfEntries;
//#if 0

             while (pTmp->Flink != &pQueInfo->pQueHd->Head)
             {

                     NoOfWrkItms++;
                     pTmp = pTmp->Flink;
             }
//#endif
             LeaveCriticalSection(&pQueInfo->pQueHd->CrtSec);
             DBGPRINT2(SPEC, "Que = (%s) has (%d) wrk items\n",
                                   pQueInfo->cstrQueType,
                                   NoOfWrkItms
                                     );
        }

        DBGPRINT0(SPEC, "----------Count of Wrk items End-----------\n");
     }
} // end of try
finally {
      if (AbnormalTermination())
      {
         DBGPRINT0(SPEC, "WinsSetFlags terminated abnormally\n");
      }
      WinsDbg = DbgFlagsStore;
      LeaveCriticalSection(&WinsCnfCnfCrtSec);
 }  //end of finally { }
#endif
  return(Status);
}

DWORD
WinsBackup (
   LPBYTE                pBackupPath,
   short                 fIncremental
        )
{
 DWORD RetVal = WINS_FAILURE;
 try {
#if 0
   RetVal = NmsDbBackup(pBackupPath, fIncremental ? NMSDB_INCREMENTAL_BACKUP :
                        NMSDB_FULL_BACKUP);
#endif
   //
   // Always do full backup until Jet is solid enough in doing incremental
   // backups. Ian does not seem very sure about how robust it is currently.
   // (7/6/94)
   //
   RetVal = NmsDbBackup(pBackupPath, NMSDB_FULL_BACKUP);
  }
 except(EXCEPTION_EXECUTE_HANDLER) {
    DBGPRINTEXC("WinsBackup");
#if 0
    DBGPRINT2(ERR, "WinsBackup: Could not do %s backup to dir (%s)\n", fIncremental ? "INCREMENTAL" : "FULL", pBackupPath);

    DBGPRINT1(ERR, "WinsBackup: Could not do full backup to dir (%s)\n", pBackupPath);
#endif
    WinsEvtLogDetEvt(FALSE, WINS_EVT_BACKUP_ERR, NULL, __LINE__, "s", pBackupPath);
 }
 if (RetVal != WINS_SUCCESS)
 {
#if 0
   RetVal = fIncremental ? WINSINTF_INC_BACKUP_FAILED : WINSINTF_FULL_BACKUP_FAILED;
#endif
   RetVal = WINSINTF_FULL_BACKUP_FAILED;
 }
 else
 {
   RetVal = WINSINTF_SUCCESS;
 }
 return(RetVal);
}


DWORD
WinsTerm (
        handle_t        ClientHdl,
        short                fAbruptTerm
        )
{
  DBGPRINT1(FLOW, "WINS TERMINATED %s BY ADMINISTRATOR\n", fAbruptTerm ? "ABRUPTLY" : "GRACEFULLY");

  UNREFERENCED_PARAMETER(ClientHdl);

  if (fAbruptTerm)
  {
        fNmsAbruptTerm = TRUE;
          WinsMscSignalHdl(NmsMainTermEvt);
          ExitProcess(WINS_SUCCESS);

//        EnterCriticalSection(&NmsTermCrtSec);
//        NmsTotalTrmThdCnt = 0;  //force the count to less than 0
//        LeaveCriticalSection(&NmsTermCrtSec);
  }

  WinsMscSignalHdl(NmsMainTermEvt);
  return(WINSINTF_SUCCESS);
}

DWORD
WinsRecordAction(
        PWINSINTF_RECORD_ACTION_T        *ppRecAction
        )

/*++

Routine Description:
        This function is called to register, query, release a name

Arguments:
        pRecAction - Info about the operation to do and the name to insert,
                     query or release

Externals Used:
        None


Return Value:

   Success status codes -- WINSINTF_SUCCESS
   Error status codes   -- WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsRecordAction()

Side Effects:

Comments:
        None
--*/

{

  STATUS             RetStat;
  RPL_REC_ENTRY_T   Rec;
  NMSDB_STAT_INFO_T StatInfo;
  NMSMSGF_CNT_ADD_T CntAdd;
  DWORD                    i, n;
  BOOL                    fSwapped = FALSE;
  PWINSINTF_RECORD_ACTION_T pRecAction = *ppRecAction;

  NmsDbThdInit(WINS_E_WINSRPC);
  NmsDbOpenTables(WINS_E_WINSRPC);
  DBGMYNAME("RPC-WinsRecordAction");

try {
  CntAdd.NoOfAdds          = 1;
  CntAdd.Add[0].AddTyp_e  = pRecAction->Add.Type;
  CntAdd.Add[0].AddLen    = pRecAction->Add.Len;
  CntAdd.Add[0].Add.IPAdd = pRecAction->Add.IPAdd;




  //
  // Check to see if it is a PDC name (0x1B in the 16th byte).  Do this only
  // if the name is atleast 16 bytes long.  Winscl or some other tool may
  // send a shorter name. Netbt will never send a shorter name.
  //
  if ((pRecAction->NameLen >= (WINS_MAX_NS_NETBIOS_NAME_LEN - 1)) && (*(pRecAction->pName + 15) == 0x1B))
  {
        WINS_SWAP_BYTES_M(pRecAction->pName, pRecAction->pName + 15);
        fSwapped = TRUE;
  }

  //
  // just in case the admin. tool is screwing up and passing us an invalid
  // name length, adjust the length.
  //
  if (pRecAction->NameLen > WINS_MAX_NAME_SZ)
  {
      pRecAction->NameLen = WINS_MAX_NAME_SZ - 1;
  }

  //
  // Terminate name with NULL, just in case user didn't do it.
  //
  *(pRecAction->pName + pRecAction->NameLen) = (TCHAR)NULL;

  switch(pRecAction->Cmd_e)
  {
        case(WINSINTF_E_INSERT):

                if (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE)
                {

                 RetStat = NmsNmhNamRegInd(
                                NULL,                   //no dialogue handle
                                (LPBYTE)pRecAction->pName,
                                pRecAction->NameLen + 1, //to include the ending                                                         //0 byte. See GetName()
                                                         //in nmsmsgf.c
                                CntAdd.Add,
                                pRecAction->NodeTyp,
                                NULL,
                                0,
                                0,
                                FALSE,        //it is a name reg (nor a ref)
                                pRecAction->fStatic,
                                TRUE                  // administrative action
                                );
                }
                else  // the record is a group or  multihomed
                {

                if (
                        (pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED )
                                        ||
                        (pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP )
                   )
                {
                        for (i = 0; i < pRecAction->NoOfAdds; i++)
                        {
                             //
                             // pAdd is a unique pointer and so can be 
                             // NULL.  We however do not protect oureelves
                             // here for the following reasons
                             //
                             //  - the call can only be executed by Admins
                             //    on this machine and through tools
                             //    that MS provides that do not pass pAdd as
                             //    NULL.  The rpc call is not published
                             //
                             //  - AV will be caught and a failure returned.
                             //    No harm done.
                             //
                             CntAdd.Add[i].AddTyp_e  =
                                        (pRecAction->pAdd + i)->Type;
                             CntAdd.Add[i].AddLen    =
                                        (pRecAction->pAdd + i)->Len;
                             CntAdd.Add[i].Add.IPAdd =
                                        (pRecAction->pAdd + i)->IPAdd;
                        }
                        CntAdd.NoOfAdds          = pRecAction->NoOfAdds;

                }
                RetStat= NmsNmhNamRegGrp(
                                NULL,                   //no dialogue handle
                                (LPBYTE)pRecAction->pName,
                                pRecAction->NameLen + 1,
                                &CntAdd,
                                0,                //node type (not used)
                                NULL,
                                0,
                                0,
                                pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED ? NMSDB_MULTIHOMED_ENTRY : (NMSDB_IS_IT_SPEC_GRP_NM_M(pRecAction->pName) || (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? NMSDB_NORM_GRP_ENTRY : NMSDB_SPEC_GRP_ENTRY),
                                FALSE,        //it is a name reg (nor a ref)
                                pRecAction->fStatic,
                                TRUE                  // administrative action
                                );
                }
                break;

        case(WINSINTF_E_RELEASE):

                if (
                        (pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                                            ||
                        (pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP)
                   )
                {
                        if (pRecAction->pAdd != NULL)
                        {
                             CntAdd.Add[0].AddTyp_e  =  pRecAction->pAdd->Type;
                             CntAdd.Add[0].AddLen    =  pRecAction->pAdd->Len;
                             CntAdd.Add[0].Add.IPAdd =  pRecAction->pAdd->IPAdd;
                        }
                }


                RetStat = NmsNmhNamRel(
                                NULL,                   //no dialogue handle
                                (LPBYTE)pRecAction->pName,
                                pRecAction->NameLen + 1,
                                CntAdd.Add,
                                pRecAction->TypOfRec_e ==
                                        WINSINTF_E_UNIQUE ? FALSE : TRUE,
                                NULL,
                                0,
                                0,
                                TRUE                  // administrative action
                                     );

                break;

        case(WINSINTF_E_QUERY):

                //
                // Anybody can query a record.  We don't have any security 
                // for plain queries. Therefore somebody can cause a leak
                // by making calls with pAdd pointing to allocated memory.
                // Let us free that memory and proceed.  We can return 
                // failure also but let us cover for our legit caller's 
                // mistakes.  Currently, the only known callers of this
                // function are winsmon, winscl, winsadmn (NT 4 and before)
                // and wins snapin.   
                //
                if (pRecAction->pAdd != NULL)
                {
                     midl_user_free(pRecAction->pAdd);
                }
                RetStat = NmsNmhNamQuery(
                            NULL,                   //no dialogue handle
                            (LPBYTE)pRecAction->pName,
                            pRecAction->NameLen + 1,
                            NULL,
                            0,
                            0,
                            TRUE,                  // administrative action
                            &StatInfo
                             );

                if (RetStat == WINS_SUCCESS)
                {
                  pRecAction->TypOfRec_e = StatInfo.EntTyp;
                  pRecAction->OwnerId    = StatInfo.OwnerId;
                  pRecAction->State_e    =
                                        (WINSINTF_STATE_E)StatInfo.EntryState_e;
                  pRecAction->TimeStamp    = StatInfo.TimeStamp;
                  if (
                        NMSDB_ENTRY_UNIQUE_M(StatInfo.EntTyp)
                                ||
                        NMSDB_ENTRY_NORM_GRP_M(StatInfo.EntTyp)
                   )
                 {
                    pRecAction->NoOfAdds    = 0;
                    pRecAction->pAdd       = NULL;
                    pRecAction->Add.IPAdd  =
                                StatInfo.NodeAdds.Mem[0].Add.Add.IPAdd;
                    pRecAction->Add.Type  =
                                (UCHAR) StatInfo.NodeAdds.Mem[0].Add.AddTyp_e;
                    pRecAction->Add.Len  =
                                StatInfo.NodeAdds.Mem[0].Add.AddLen;
                 }
                 else
                 {

                  PNMSDB_WINS_STATE_E pWinsState_e;
                  PCOMM_ADD_T         pAdd;
                  PVERS_NO_T     pStartVersNo;

                  EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
try {
                  if (StatInfo.NodeAdds.NoOfMems > 0)
                  {
                    pRecAction->NoOfAdds = StatInfo.NodeAdds.NoOfMems * 2;
                    pRecAction->pAdd = midl_user_allocate(pRecAction->NoOfAdds * sizeof(WINSINTF_ADD_T));
                  }
                  else
                  {
                    pRecAction->NoOfAdds = 0;
                    pRecAction->pAdd = NULL;
                  }
                  for (
                        n = 0, i = 0;
                        n < (StatInfo.NodeAdds.NoOfMems)  && n < WINSINTF_MAX_MEM;                         n++
                     )
                  {
                        RPL_FIND_ADD_BY_OWNER_ID_M(
                                  StatInfo.NodeAdds.Mem[n].OwnerId,
                                  pAdd,
                                  pWinsState_e,
                                  pStartVersNo
                                        );
                       (pRecAction->pAdd + i++)->IPAdd = pAdd->Add.IPAdd;

                       (pRecAction->pAdd + i++)->IPAdd   =
                          StatInfo.NodeAdds.Mem[n].Add.Add.IPAdd;


                  }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        WINSEVT_LOG_M(ExcCode, WINS_EVT_RPC_EXC);
        DBGPRINT1(EXC, "WinsRecordAction: Got Exception (%x)\n", ExcCode);
        }
                  LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
                }

                pRecAction->NodeTyp  = StatInfo.NodeTyp;
                pRecAction->VersNo   = StatInfo.VersNo;
                pRecAction->fStatic  = StatInfo.fStatic;
              }
              else
              {
                  pRecAction->NoOfAdds = 0;
                  pRecAction->pAdd = NULL;
              }
              break;

        case(WINSINTF_E_MODIFY):

                //
                // Note: Currently, the administrator can not change the
                // address in the record
                //
                time((time_t *)&Rec.NewTimeStamp);

                //
                // If the record type is wrong, return a failure
                //
                if (pRecAction->TypOfRec_e > WINSINTF_E_MULTIHOMED)
                {
                        RetStat = WINS_FAILURE;
                        break;
                }
                //
                // If the state specified is wrong, return a failure
                //
                if (pRecAction->State_e > WINSINTF_E_DELETED)
                {
                        RetStat = WINS_FAILURE;
                        break;
                }
                NMSDB_SET_ENTRY_TYPE_M(Rec.Flag, pRecAction->TypOfRec_e);
                NMSDB_SET_NODE_TYPE_M(Rec.Flag, pRecAction->NodeTyp);
                NMSDB_SET_STDYN_M(Rec.Flag, pRecAction->fStatic);

                //
                // Fall through
                //

        case(WINSINTF_E_DELETE):
                NMSDB_SET_STATE_M(Rec.Flag, pRecAction->State_e)

                Rec.pName = pRecAction->pName;
                Rec.NameLen = pRecAction->NameLen + 1;

                //
                // NOTE:
                // The index on the name address table was set to
                // the clustered index column (as required by this function)
                // in NmsDbThdInit()
                //

                RetStat = NmsDbQueryNUpdIfMatch(
                                        &Rec,
                                        THREAD_PRIORITY_NORMAL,
                                        FALSE,  //don't change priority to
                                                //normal
                                        WINS_E_WINSRPC //ensures no matching
                                                       //of timestamps
                                                );
                if (RetStat == WINS_SUCCESS)
                {
                  DBGPRINT1(DET, "WinsRecordAction: Record (%s) deleted\n",
                                                  Rec.pName);
FUTURES("use macros defined in winsevt.h. Change to warning")
                  if (WinsCnf.LogDetailedEvts > 0)
                  {
                     WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_DELETED, NULL, __LINE__, "s", Rec.pName);
                  }
                }
                break;


        default:
                RetStat = WINS_FAILURE;
                break;

  }
 } // end of try
 except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        WINSEVT_LOG_M(ExcCode, WINS_EVT_RPC_EXC);
        DBGPRINT1(EXC, "WinsRecordAction: Got Exception (%x)\n", ExcCode);
        }
  if (fSwapped)
  {
        WINS_SWAP_BYTES_M(pRecAction->pName, pRecAction->pName + 15);
  }
  //
  // Let us end the session
  //
  NmsDbCloseTables();
  NmsDbEndSession();
  if (RetStat == WINS_SUCCESS)
  {
      RetStat = WINSINTF_SUCCESS;
  }
  else
  {
      if (pRecAction->Cmd_e == WINSINTF_E_QUERY)
      {
             RetStat = WINSINTF_REC_NOT_FOUND;
      }
      else
      {
             RetStat = WINSINTF_FAILURE;
      }
  }
  return(RetStat);
}

DWORD
GetWinsStatus(
   IN  WINSINTF_CMD_E          Cmd_e,
   OUT LPVOID  pResults,
   BOOL fNew
        )

/*++

Routine Description:
        This function is called to get the information pertaining to WINS
        Refer WINSINTF_RESULTS_T data structure to see what information
        is retrieved

Arguments:
        Cmd_e    - Command to execute
        pResults -  Info. retrieved

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsStatus()

Side Effects:

Comments:
        None
--*/

{

        DWORD RetVal = WINSINTF_FAILURE;

        switch(Cmd_e)
        {

                case(WINSINTF_E_ADDVERSMAP):
                                if (fNew)
                                {
                                   break;
                                }
                                RetVal = sGetVersNo(pResults);
                                break;
                case(WINSINTF_E_CONFIG):
                                RetVal = GetConfig(pResults, fNew, FALSE);
                                break;
                case(WINSINTF_E_CONFIG_ALL_MAPS):
                                RetVal = GetConfig(pResults, fNew, TRUE);
                                break;
                case(WINSINTF_E_STAT):
                                RetVal = GetStatistics(pResults, fNew);
                                break;
                default:
                  DBGPRINT1(ERR, "WinsStatus: Weird: Bad RPC Status command = (%D) \n", Cmd_e);
                  WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_BAD_RPC_STATUS_CMD);
                  break;

        }
        return(RetVal);

}

DWORD
WinsTrigger(
        PWINSINTF_ADD_T           pWinsAdd,
        WINSINTF_TRIG_TYPE_E         TrigType_e
        )

/*++

Routine Description:
        This function is called to send a trigger to a remote WINS so that
        it may pull the latest information from it

Arguments:

        pWinsAdd - Address of WINS to send a Push update notification to

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsTrigger

Side Effects:

Comments:
        A Trigger is sent to a remote WINS only if it is specified
        under the PULL/PUSH subkey of the PARTNERS key in the registry
--*/

{

        PRPL_CONFIG_REC_T        pPnr;
        DWORD                        RetCode = WINSINTF_SUCCESS;
        BOOL                        fRplPnr = FALSE;
        QUE_CMD_TYP_E                CmdType_e;

        DBGENTER("WinsTrigger\n");
        //
        // Enter the critical sections guarded by WinsCnfCnfCrtSec and
        // NmsNmhNamRegCrtSec. There is no danger of deadlock because we
        // always enter the two critical sections in the following sequence
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);

PERF("Do we need to enter the following critical section")
//        EnterCriticalSection(&NmsNmhNamRegCrtSec);
try {
        if (
                (TrigType_e == WINSINTF_E_PUSH)
                        ||
                (TrigType_e == WINSINTF_E_PUSH_PROP)
              )
        {
                DBGPRINT1(DET, "WinsTrigger. Send Push trigger to (%x)\n",
                                     pWinsAdd->IPAdd);

                CmdType_e = (TrigType_e == WINSINTF_E_PUSH ?
                                QUE_E_CMD_SND_PUSH_NTF :
                                QUE_E_CMD_SND_PUSH_NTF_PROP);

                pPnr      = WinsCnf.PushInfo.pPushCnfRecs;
        }
        else        // it is a pull trigger
        {
                DBGPRINT1(DET, "WinsTrigger. Send Pull trigger to (%x)\n",
                                     pWinsAdd->IPAdd);

                CmdType_e  = QUE_E_CMD_REPLICATE;
                pPnr       = WinsCnf.PullInfo.pPullCnfRecs;

        }

        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
           if (pPnr != NULL)
           {
              //
              // Search for the Cnf record for the WINS we want to
              // send the PUSH notification to/Replicate with.
              //
              for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                        !fRplPnr;
                                // no third expression
                  )
               {


                   DBGPRINT1(DET, "WinsTrigger. Comparing with (%x)\n",
                                     pPnr->WinsAdd.Add.IPAdd);
                   //
                   // Check if this is the one we want
                   //
                   if (pPnr->WinsAdd.Add.IPAdd == pWinsAdd->IPAdd)
                   {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;

                        //
                        // Make it 0, so that we always try to establish
                        // a connection.  Otherwise, pull thread may not
                        // try if it has already exhausted the number of
                        // retries
                        //
                        pPnr->RetryCount = 0;
                        continue;                //so that we can break out

                   }
                   //
                   // Get the next record that follows this one sequentially
                   //
                   pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
              } // end of for
          } // end of if (pPnr != 0)
       }  // end of if (fRplOnlyWCnfPnrs)
       else
       {
                //
                // Allocate from the general heap because that is what
                // is used by the replicator.
                //
                WinsMscAlloc(RPL_CONFIG_REC_SIZE, &pPnr);
                COMM_INIT_ADD_M(&pPnr->WinsAdd, pWinsAdd->IPAdd);
                pPnr->MagicNo           = 0;
                pPnr->RetryCount        = 0;
                pPnr->LastCommFailTime  = 0;
                pPnr->PushNtfTries    = 0;
                fRplPnr                     = TRUE;

                //
                // We want the buffer to be deallocated by the PULL thread
                //
                pPnr->fTemp = TRUE;
       }

       //
       // If replication needs to be done
       //
       if (fRplPnr)
       {
                //
                // Call RplInsertQue to insert the push request to
                // the Pull Thread
                //
                ERplInsertQue(
                             WINS_E_WINSRPC,
                             CmdType_e,
                             NULL,        //no Dlg Hdl
                             NULL,        //no msg is there
                             0,                //msg length
                             pPnr,   //client context
                             pPnr->MagicNo
                             );

       }
  } // end of try block

except (EXCEPTION_EXECUTE_HANDLER) {
                DWORD ExcCode = GetExceptionCode();
                DBGPRINT1(EXC, "WinsTrigger: Got Exception (%x)\n", ExcCode);
                WINSEVT_LOG_D_M(ExcCode, WINS_EVT_PUSH_TRIGGER_EXC);
                RetCode = WINSINTF_FAILURE;
  }

        //
        // Leave the critical section guarded by NmsNmhNamRegCrtSec.
        //
//        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        //
        // if replication was allowed only with configured partners and
        // there was no WINS with the address specified by the client,
        // return failure
        //
        if (!fRplPnr)
        {
                RetCode = WINSINTF_RPL_NOT_ALLOWED;
        }

        DBGLEAVE("WinsTrigger\n");
        return(RetCode);
}

DWORD
sGetVersNo(
        LPVOID  pResultsA
        )

/*++

Routine Description:

        This function returns with the highest version number of records
        owned by a particular WINS

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        COMM_ADD_T        WinsAdd;
        DWORD                OwnerId;
        STATUS                RetStat;
        VERS_NO_T        VersNo;
        BOOL                fAllocNew = FALSE;
        PWINSINTF_RESULTS_T  pResults  = pResultsA;

        WinsAdd.AddLen    = sizeof(COMM_IP_ADD_T);
        WinsAdd.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
        WinsAdd.Add.IPAdd = pResults->AddVersMaps[0].Add.IPAdd;
        RetStat = RplFindOwnerId(
                        &WinsAdd,
                        &fAllocNew,                //don't assign if not there
                        &OwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                              );
        if(RetStat != WINS_SUCCESS)
        {
                return(WINSINTF_FAILURE);
        }

        if (OwnerId == 0)
        {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
                NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, VersNo);
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
                pResults->AddVersMaps[0].VersNo = VersNo;
        }
        else
        {
           EnterCriticalSection(&RplVersNoStoreCrtSec);
           try {
                   pResults->AddVersMaps[0].VersNo =
                                        (pRplPullOwnerVersNo+OwnerId)->VersNo;
            }
            except(EXCEPTION_EXECUTE_HANDLER) {
                                DBGPRINTEXC("sGetVersNo");
                        }
            LeaveCriticalSection(&RplVersNoStoreCrtSec);
        }
        return(WINSINTF_SUCCESS);

}

DWORD
GetConfig(
        OUT  LPVOID  pResultsA,
        IN   BOOL    fNew,
        IN   BOOL    fAllMaps
        )

/*++

Routine Description:
        This function returns with configuration information
        and counter info related to replication

Arguments:
        pResults - has the information retrieved

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        GetWinsStatus()

Side Effects:

Comments:
        None
--*/

{

        PNMSDB_WINS_STATE_E pWinsState_e;
        PCOMM_ADD_T            pWinsAdd;
        PVERS_NO_T          pStartVersNo;
        DWORD                    i, n;
        VERS_NO_T            MyMaxVersNo;
        PWINSINTF_ADD_VERS_MAP_T pAddVersMaps, pAddVersMapsStore;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
        BOOL                 fDel;
        VERS_NO_T            VersNoForDelRec;


        if (fAllMaps)
        {
          fDel = FALSE;
          VersNoForDelRec.HighPart = MAXLONG;
          VersNoForDelRec.LowPart  = MAXULONG;
        }
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        MyMaxVersNo = NmsNmhMyMaxVersNo;
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        if (fNew)
        {

             pResultsN->pAddVersMaps =
                     midl_user_allocate(NmsDbNoOfOwners * sizeof(WINSINTF_ADD_VERS_MAP_T));
             if (pResultsN->pAddVersMaps == NULL)
                 return WINSINTF_FAILURE;

             pAddVersMaps = pResultsN->pAddVersMaps;

        }
        else
        {
             pAddVersMaps = pResults->AddVersMaps;
        }
        pAddVersMapsStore = pAddVersMaps;
        //
        // First extract the timeouts and Non-remote WINS information
        // from the WinsCnf global var.  We enter the WinsCnfCnfCrtSec
        // since we need to synchronize with the thread doing the
        // reinitialization (Main thread)
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);
        if (!fNew)
        {
        pResults->RefreshInterval    = WinsCnf.RefreshInterval;
        pResults->TombstoneInterval  = WinsCnf.TombstoneInterval;
        pResults->TombstoneTimeout   = WinsCnf.TombstoneTimeout;
        pResults->VerifyInterval     = WinsCnf.VerifyInterval;
        pResults->WinsPriorityClass  = WinsCnf.WinsPriorityClass == (DWORD)WINSINTF_E_NORMAL ? NORMAL_PRIORITY_CLASS : HIGH_PRIORITY_CLASS;
        pResults->NoOfWorkerThds     = NmsNoOfNbtThds;
        }
        else
        {
        pResultsN->RefreshInterval    = WinsCnf.RefreshInterval;
        pResultsN->TombstoneInterval  = WinsCnf.TombstoneInterval;
        pResultsN->TombstoneTimeout   = WinsCnf.TombstoneTimeout;
        pResultsN->VerifyInterval     = WinsCnf.VerifyInterval;
        pResultsN->WinsPriorityClass  = WinsCnf.WinsPriorityClass == (DWORD)WINSINTF_E_NORMAL ? NORMAL_PRIORITY_CLASS : HIGH_PRIORITY_CLASS;
        pResultsN->NoOfWorkerThds     = NmsNoOfNbtThds;

        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        //
        // Enter two critical sections in sequence. No danger of deadlock
        // here. The only other thread that takes both these critical section
        // is the RplPush thread. It takes these in the same order (See
        // HandleVersMapReq())
        //
        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        EnterCriticalSection(&RplVersNoStoreCrtSec);
try {
NONPORT("Change when using different address family")

         for (
                i=0, n = 0;
                i < NmsDbNoOfOwners;
                i++
             )
         {

                if (!fNew && (i == WINSINTF_MAX_NO_RPL_PNRS))
                {
                    break;
                }
                //
                // if the record is deleted in the in-memory table, it
                // means that there are no records for it in the
                // database
                //
                if ((pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_DELETED)
                {
                        //
                        // if only active mappings are sought, skip this
                        // entry
                        //
                        if (!fAllMaps)
                        {
                          continue;
                        }
                        else
                        {
                             fDel = TRUE;
                        }
                }

                //
                // Find address corresponding to the owner id.
                //
                RPL_FIND_ADD_BY_OWNER_ID_M(i, pWinsAdd, pWinsState_e,
                                                pStartVersNo);

                //
                //  It is possible for NmsDbNoOfOwners to be more than the
                //  number of initialized RplPullVersNoTbl entries.  When
                //  we reach a NULL entry, we break out of the loop.
                //
                if (pWinsAdd != NULL)
                {
                        pAddVersMaps->Add.Type   = WINSINTF_TCP_IP;
                        pAddVersMaps->Add.Len    = pWinsAdd->AddLen;
                        pAddVersMaps->Add.IPAdd  =  pWinsAdd->Add.IPAdd;

                        pAddVersMaps++->VersNo =  (fDel == FALSE) ? (pRplPullOwnerVersNo+i)->VersNo : VersNoForDelRec;
                }
                else
                {
                        break;
                }
                if (fDel)
                {
                    fDel = FALSE;
                }
                n++;
         } // end of for ..

         //
         // Since RplPullOwnerVersNo[0] may be out of date, let us get
         // get the uptodate value
         //
         NMSNMH_DEC_VERS_NO_M(MyMaxVersNo,
                              pAddVersMapsStore->VersNo
                             );
         if (fNew)
         {
           pResultsN->NoOfOwners = n;
         }
         else
         {
           pResults->NoOfOwners = n;

         }
NOTE("Wins Mib agent relies on the first entry being that of the local WINS")
NOTE("See WinsMib.c -- EnumAddKeys")
#if 0
         //
         // Since RplPullOwnerVersNo[0] may be out of date, let us get
         // get the uptodate value
         //
         NMSNMH_DEC_VERS_NO_M(MyMaxVersNo,
                              pResults->AddVersMaps[0].VersNo
                             );
#endif
  }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("GetConfig");
        //
        // log a message
        //
 }
        LeaveCriticalSection(&RplVersNoStoreCrtSec);
        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

        return(WINSINTF_SUCCESS);
}

DWORD
GetStatistics(
        LPVOID  pResultsA,
        BOOL                 fNew
        )

/*++

Routine Description:

        This function returns with the highest version number of records
        owned by a particular WINS

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PRPL_CONFIG_REC_T         pPnr;
        PWINSINTF_RPL_COUNTERS_T  pPnrData;
        DWORD                     i;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;


        ASSERT(pResults != NULL);

        
        //
        // If client passed us a non-null pRplPnr, then we return failure
        // so as to avoid a memory leak.  
        //
        if (!fNew)
        {
              if (pResults->WinsStat.pRplPnrs != NULL)
              {
                    return(WINSINTF_FAILURE);
              }

        }
        else
        {

              if (pResultsN->WinsStat.pRplPnrs != NULL)
              {
                    return(WINSINTF_FAILURE);
              }
        }
        //
        // Copy the counters
        //
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        if (!fNew)
        {
        pResults->WinsStat.Counters = WinsIntfStat.Counters;
FUTURES("Get rid of of the following two fields")
        pResults->WinsStat.Counters.NoOfQueries =
                                WinsIntfStat.Counters.NoOfSuccQueries +
                                  WinsIntfStat.Counters.NoOfFailQueries;
        pResults->WinsStat.Counters.NoOfRel = WinsIntfStat.Counters.NoOfSuccRel
                                        + WinsIntfStat.Counters.NoOfFailRel;
        }
        else
        {
        pResultsN->WinsStat.Counters = WinsIntfStat.Counters;
FUTURES("Get rid of of the following two fields")
        pResultsN->WinsStat.Counters.NoOfQueries =
                                WinsIntfStat.Counters.NoOfSuccQueries +
                                  WinsIntfStat.Counters.NoOfFailQueries;
        pResultsN->WinsStat.Counters.NoOfRel = WinsIntfStat.Counters.NoOfSuccRel
                                        + WinsIntfStat.Counters.NoOfFailRel;

        }
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        //
        // Copy the TimeStamps and replication specific counters
        //
        EnterCriticalSection(&WinsIntfCrtSec);
        {
            PWINSINTF_STAT_T pWinsStat = (fNew) ? &(pResultsN->WinsStat) : &(pResults->WinsStat);
            TIME_ZONE_INFORMATION tzInfo;

            GetTimeZoneInformation(&tzInfo);
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.WinsStartTime), &(pWinsStat->TimeStamps.WinsStartTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastPScvTime), &(pWinsStat->TimeStamps.LastPScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastATScvTime), &(pWinsStat->TimeStamps.LastATScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastTombScvTime), &(pWinsStat->TimeStamps.LastTombScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastVerifyScvTime), &(pWinsStat->TimeStamps.LastVerifyScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastInitDbTime), &(pWinsStat->TimeStamps.LastInitDbTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastPRplTime), &(pWinsStat->TimeStamps.LastPRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastATRplTime), &(pWinsStat->TimeStamps.LastATRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastNTRplTime), &(pWinsStat->TimeStamps.LastNTRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastACTRplTime), &(pWinsStat->TimeStamps.LastACTRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.CounterResetTime), &(pWinsStat->TimeStamps.CounterResetTime));
        }
        LeaveCriticalSection(&WinsIntfCrtSec);
        EnterCriticalSection(&WinsCnfCnfCrtSec);
try {
        DWORD  NoOfPnrs;
        pPnr       = WinsCnf.PullInfo.pPullCnfRecs;
        if (!fNew)
        {
          NoOfPnrs = pResults->WinsStat.NoOfPnrs = WinsCnf.PullInfo.NoOfPushPnrs;

        }
        else
        {
          NoOfPnrs = pResultsN->WinsStat.NoOfPnrs = WinsCnf.PullInfo.NoOfPushPnrs;
        }

        //
        // If no. of push pnrs (pnrs under the pull key) is > 0
        //
        if (NoOfPnrs > 0)
        {
           if (!fNew)
           {
             pPnrData = pResults->WinsStat.pRplPnrs =
                        midl_user_allocate(pResults->WinsStat.NoOfPnrs *
                                         sizeof(WINSINTF_RPL_COUNTERS_T));
           }
           else
           {
             pPnrData = pResultsN->WinsStat.pRplPnrs =
                        midl_user_allocate(pResultsN->WinsStat.NoOfPnrs *
                                         sizeof(WINSINTF_RPL_COUNTERS_T));

           }
PERF("remove one of the expressions in the test condition of the if statement")
           for (
                 i = 0;
                (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                        &&
                i < NoOfPnrs;
                pPnrData++, i++
               )
           {

                   pPnrData->Add.IPAdd     = pPnr->WinsAdd.Add.IPAdd;
                   (VOID)InterlockedExchange(
                                        &pPnrData->NoOfRpls, pPnr->NoOfRpls);
                   (VOID)InterlockedExchange(
                                        &pPnrData->NoOfCommFails,
                                        pPnr->NoOfCommFails
                                        );
                   //
                   // Get the next record that follows this one sequentially
                   //
                   pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
           }
        }
        else
        {
           if (!fNew)
           {
               pResults->WinsStat.pRplPnrs = NULL;
           }
           else
           {
               pResultsN->WinsStat.pRplPnrs = NULL;
           }
        }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("GetStatistics");
        //
        // log a message
        //
        }

        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        GetConfig(pResultsA, fNew, FALSE);
        return(WINSINTF_SUCCESS);
} // GetStatistics


DWORD
WinsDoStaticInit(
        LPWSTR  pDataFilePath,
        DWORD   fDel
        )

/*++

Routine Description:
        This function does the STATIC initialization of WINS

Arguments:
        pDataFilePath - Path to the data file or NULL

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsDoStaticInit
Side Effects:

Comments:
        None
--*/

{

        WINSCNF_CNF_T        WinsCnf;
        STATUS               RetStat = WINS_SUCCESS;

        //
        // If no path has been specified, take the values from the registry
        //
        if (pDataFilePath == NULL)
        {
           //
           // Read the DataFiles info information
           //
           // This function will return with either the name of the default
           // file to read or one or more files specified under the
           // Parameters\Datafiles key of WINS
           //
           (VOID)WinsCnfGetNamesOfDataFiles(&WinsCnf);
        }
        else
        {
FUTURES("expensive.  Change idl prototype to pass length")
                if (lstrlen(pDataFilePath) >= WINS_MAX_FILENAME_SZ)
                {

                        return(WINSINTF_STATIC_INIT_FAILED);
                }
                //
                // Set time of data initialization
                //
                WinsIntfSetTime(NULL, WINSINTF_E_INIT_DB);
                WinsMscAlloc(WINSCNF_FILE_INFO_SZ, &WinsCnf.pStaticDataFile);

                lstrcpy(WinsCnf.pStaticDataFile->FileNm,  pDataFilePath);
                WinsCnf.pStaticDataFile->StrType = REG_EXPAND_SZ;
                WinsCnf.NoOfDataFiles = 1;
        }

        //
        // If Static initialization fails, it will be logged.
        // This function does not return an error code
        //
        if ((RetStat = WinsPrsDoStaticInit(
                          WinsCnf.pStaticDataFile,
                          WinsCnf.NoOfDataFiles,
                           FALSE                   //do it synchronously
                                   )) == WINS_SUCCESS)
        {
           if ((pDataFilePath != NULL) && fDel)
           {
             if (!DeleteFile(pDataFilePath))
             {
                DWORD Error;
                Error = GetLastError();
                if (Error != ERROR_FILE_NOT_FOUND)
                {
                    DBGPRINT1(ERR, "DbgOpenFile: Could not delete the data file. Error = (%d).  Dbg file will not be truncated\n", Error);
                    WinsEvtLogDetEvt(FALSE, WINS_EVT_COULD_NOT_DELETE_FILE,
                      TEXT("winsintf.c"), __LINE__, "ud", pDataFilePath, Error);
                    RetStat = Error;

                }
             }

           }
        }
        return (RetStat == WINS_SUCCESS ? WINSINTF_SUCCESS : WINSINTF_STATIC_INIT_FAILED);
}
DWORD
WinsDoScavenging(
        VOID
        )

/*++

Routine Description:
        This function starts the scavenging cycle

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  exception from WinsMscSignalHdl

Error Handling:

Called by:
        R_WinsDoScavenging
Side Effects:

Comments:
        None
--*/

{
        PQUE_SCV_REQ_WRK_ITM_T pWrkItm;

        pWrkItm = WinsMscHeapAlloc( NmsRpcHeapHdl, sizeof(QUE_SCV_REQ_WRK_ITM_T));
        pWrkItm->Opcode_e = WINSINTF_E_SCV_GENERAL;
        pWrkItm->CmdTyp_e = QUE_E_CMD_SCV_ADMIN;
        pWrkItm->fForce   = 0;
        pWrkItm->Age      = 1;   //should not be zero since zero implies
                                 //consistency check on all replicas.
        WinsLogAdminEvent( WINS_EVT_ADMIN_SCVENGING_INITIATED, 0 );
        QueInsertScvWrkItm((PLIST_ENTRY)pWrkItm);
         return (WINSINTF_SUCCESS);
}

DWORD
WinsDoScavengingNew(
    PWINSINTF_SCV_REQ_T  pScvReq
        )

/*++

Routine Description:
        This function starts the scavenging cycle

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  exception from WinsMscSignalHdl

Error Handling:

Called by:
        R_WinsDoScavenging
Side Effects:

Comments:
        None
--*/

{
        PQUE_SCV_REQ_WRK_ITM_T pWrkItm;
        pWrkItm = WinsMscHeapAlloc( NmsRpcHeapHdl, sizeof(QUE_SCV_REQ_WRK_ITM_T));
        pWrkItm->Opcode_e = pScvReq->Opcode_e;
        pWrkItm->Age      = pScvReq->Age;
        pWrkItm->fForce   = pScvReq->fForce;
        if (WINSINTF_E_SCV_GENERAL == pWrkItm->Opcode_e ) {
            WinsLogAdminEvent( WINS_EVT_ADMIN_SCVENGING_INITIATED, 0 );
        } else {
            WinsLogAdminEvent( WINS_EVT_ADMIN_CCCHECK_INITIATED, 0);
        }
        QueInsertScvWrkItm((PLIST_ENTRY)pWrkItm);
         return (WINSINTF_SUCCESS);
}

DWORD
WinsGetDbRecs (
        PWINSINTF_ADD_T             pWinsAdd,
        WINSINTF_VERS_NO_T          MinVersNo,
        WINSINTF_VERS_NO_T          MaxVersNo,
        PWINSINTF_RECS_T          pRecs
        )

/*++

Routine Description:
        This function returns with all the records (that can fit into the
        buffer passed) owned by a WINS in the local db of this WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        COMM_ADD_T           Address;
        PRPL_REC_ENTRY_T     pBuff = NULL;
        LPVOID               pStartBuff;
        DWORD                BuffLen;
        DWORD                NoOfRecs;
        PWINSINTF_RECORD_ACTION_T pRow;
        DWORD                i;
        DWORD                ind;
        //VERS_NO_T          MinVersNo = {0,0};
        DWORD                EntType;
        PWINSTHD_TLS_T       pTls;
        //ULONG                Status;
        BOOL                 fExcRaised = FALSE;


//   PVOID pCallersAdd, pCallersCaller;
//   RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
        DBGENTER("WinsGetDbRecs\n");

        if (LiLtr(MaxVersNo, MinVersNo))
        {
                return(WINSINTF_FAILURE);
        }

        Address.AddTyp_e  = pWinsAdd->Type;
        Address.AddLen    = pWinsAdd->Len;

        //
        // snmp agent can pass a 0 for the address to ask for all records
        // owned by the local wins.
        //
        if (pWinsAdd->IPAdd == 0)
        {
                  Address.AddTyp_e  = NmsLocalAdd.AddTyp_e;
                  Address.AddLen    = NmsLocalAdd.AddLen;
                  Address.Add.IPAdd = NmsLocalAdd.Add.IPAdd;
        }
        else
        {
                  Address.AddTyp_e  = pWinsAdd->Type;
                  Address.AddLen    = pWinsAdd->Len;
                  Address.Add.IPAdd = pWinsAdd->IPAdd;
        }
        //
        // initialize this thread with the db engine
        //
        NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsGetDbRecs");

PERF("The caller can pass the number of records for which space has been")
PERF("allocated in buffer pointed to by pRec in the NoOfRecs field. We should")
PERF("We should pass this argument to NmsDbGetDataRecs so that it does not get")
PERF("more records than are necessary")

        GET_TLS_M(pTls);
try {
        NmsDbGetDataRecs(
                        WINS_E_WINSRPC,
                        0,                //not used
                        MinVersNo,
                        MaxVersNo,
                        0,                //not used
                        LiEqlZero(MinVersNo) && LiEqlZero(MaxVersNo) ? TRUE : FALSE,
                        FALSE,                //not used
                        NULL,                //must be NULL since we are not doing
                                        //scavenging of clutter
                        &Address,
                        FALSE,          //dynamic + static records are wanted
//#if RPL_TYPE
                        WINSCNF_RPL_DEFAULT_TYPE,
//#endif
                        &pBuff,
                        &BuffLen,
                        &NoOfRecs
                        );

        i = 0;
        pStartBuff       = pBuff;

        //
        // If there are records to send back and the client has specified
        // a buffer for them, insert the records
        //
        if  (NoOfRecs > 0)
        {

          //
          // Allocate memory for the no of records
          //
          pRecs->BuffSize  =  sizeof(WINSINTF_RECORD_ACTION_T) * NoOfRecs;

          //
          // If memory can not be allocate, an exception will be returned
          // by midl_user_alloc
          //
          pRecs->pRow      =  midl_user_allocate(pRecs->BuffSize);
//          DBGPRINT1(DET, "WinsGetDbRecs: Address of memory for records is (%d)\n", pRecs->pRow);

#if 0
          pRecs->pRow      =  RpcSmAllocate(pRecs->BuffSize, &Status);
          if (Status != RPC_S_OK)
          {
             DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
          }
#endif
          pRow                    =  pRecs->pRow;


          for (; i<NoOfRecs; i++)
          {

                //
                // Initialize so that we don't get "enum wrong" error.
                //
                pRow->Cmd_e = WINSINTF_E_QUERY;

                //
                // the name retrieved has NULL as the last character.  This
                // We need to pass a name without this NULL.
                //
                pRow->NameLen = pBuff->NameLen;
                if (*pBuff->pName == 0x1B)
                {
                        WINS_SWAP_BYTES_M(pBuff->pName, pBuff->pName + 15);
                }

                pRow->pName =  midl_user_allocate(pRow->NameLen + 1);
                //DBGPRINT2(DET, "WinsGetDbRecs: Address of name = (%s) is (%d) \n", pBuff->pName, pRow->pName);
#if 0
                pRow->pName =  RpcSmAllocate(pRow->NameLen, &Status);
                if (Status != RPC_S_OK)
                {
                         DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
                }
#endif
                WINSMSC_COPY_MEMORY_M(pRow->pName, pBuff->pName,
                                                pRow->NameLen);


                WinsMscHeapFree(pTls->HeapHdl, pBuff->pName);
                EntType = NMSDB_ENTRY_TYPE_M(pBuff->Flag);
                pRow->TypOfRec_e = NMSDB_ENTRY_UNIQUE_M(EntType)
                                                         ? WINSINTF_E_UNIQUE :
                                (NMSDB_ENTRY_NORM_GRP_M(EntType) ?
                                        WINSINTF_E_NORM_GROUP :
                                (NMSDB_ENTRY_SPEC_GRP_M(EntType) ?
                                        WINSINTF_E_SPEC_GROUP :
                                        WINSINTF_E_MULTIHOMED));


                if (
                    (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ||
                    (pRow->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                   )
                {
                    PWINSINTF_ADD_T        pAdd;
                    DWORD                 No;
                    if (pBuff->NoOfAdds > 0)
                    {
                        pRow->NoOfAdds = pBuff->NoOfAdds * 2;

                        //
                        // Each member is comprised of two addresses,
                        // first address is that of the owner WINS, second
                        // address is that of the node registered
                        //
                        pRow->pAdd        =
//                             RpcSmAllocate(
                             midl_user_allocate(
                                        (unsigned int)(pRow->NoOfAdds)
                                                *
                                        sizeof(WINSINTF_ADD_T)//,
//                                        &Status
                                             );
                        //DBGPRINT2(DET, "WinsGetDbRecs: Address of ip address for name = (%s) is (%d) \n", pRow->pName, pRow->pAdd);
#if 0
                        if (Status != RPC_S_OK)
                        {
                             DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
                        }
#endif
                        for (
                                No= 0, ind= 0, pAdd = pRow->pAdd;
                                No < (pRow->NoOfAdds/2);
                                No++
                            )
                        {
                          pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ind)->AddTyp_e;
                          pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                          pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind)->Add.IPAdd;

                          pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ++ind)->AddTyp_e;
                          pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                          pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind++)->Add.IPAdd;
                        }
                        WinsMscHeapFree(pTls->HeapHdl, pBuff->pNodeAdd);
                    }
                }
                else
                {
                          pRow->NoOfAdds   = 0;
                          pRow->pAdd       = NULL;
                          pRow->Add.Type   = (UCHAR)pBuff->NodeAdd[0].AddTyp_e;
                          pRow->Add.Len    = pBuff->NodeAdd[0].AddLen;
                          pRow->Add.IPAdd  = pBuff->NodeAdd[0].Add.IPAdd;
                }
                pRow->NodeTyp     = (BYTE)NMSDB_NODE_TYPE_M(pBuff->Flag);
                pRow->fStatic     = NMSDB_IS_ENTRY_STATIC_M(pBuff->Flag);
                pRow->State_e     = NMSDB_ENTRY_STATE_M(pBuff->Flag);
                pRow->VersNo      = pBuff->VersNo;
                pRow->TimeStamp   = pBuff->TimeStamp;

                pRow++;


                pBuff = (PRPL_REC_ENTRY_T)((LPBYTE)pBuff + RPL_REC_ENTRY_SIZE);
PERF("Do the addition above the for loop and store in a var. Use var. here")

         } // end of for loop
        } //end of if block
        else
        {
                pRecs->pRow = NULL;
        }

 }        // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetDbRecs");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPC_EXC);
        fExcRaised = TRUE;
        }

        pRecs->TotalNoOfRecs = NoOfRecs;

        //
        // Deallocate the buffer allocated by NmsDbGetDataRecs
        //


        WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
        WinsMscHeapDestroy(pTls->HeapHdl);

        if (!fExcRaised)
        {
           pRecs->NoOfRecs = i;
        }
        else
        {
//             RpcSmFree(pRecs->pRow);
            midl_user_free(pRecs->pRow);
            pRecs->NoOfRecs = 0;
        }

        //
        // Let us end the session
        //
        NmsDbCloseTables();
        NmsDbEndSession();

        DBGLEAVE("WinsGetDbRecs\n");
        return (WINSINTF_SUCCESS);
}

VOID
WinsIntfSetTime(
        OUT PSYSTEMTIME                     pTime,
        IN     WINSINTF_TIME_TYPE_E        TimeType_e
        )

/*++

Routine Description:
        This function is called to set the the time in the WINSINTF_STAT_T
        structure

Arguments:
        pTime      - Local Time (returned)
        TimeType_e - The activity for which the time has to be stored

Externals Used:
        None

Return Value:

        NONE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        SYSTEMTIME     SysTime;
        PSYSTEMTIME    pSysTime = &SysTime;

        GetSystemTime(pSysTime);

        EnterCriticalSection(&WinsIntfCrtSec);

        switch(TimeType_e)
        {
         case(WINSINTF_E_WINS_START):
                WinsIntfStat.TimeStamps.WinsStartTime   = *pSysTime;
                break;
         case(WINSINTF_E_PLANNED_SCV):
                WinsIntfStat.TimeStamps.LastPScvTime = *pSysTime;
                break;
         case(WINSINTF_E_ADMIN_TRIG_SCV):
                WinsIntfStat.TimeStamps.LastATScvTime = *pSysTime;
                break;
         case(WINSINTF_E_TOMBSTONES_SCV):
                WinsIntfStat.TimeStamps.LastTombScvTime = *pSysTime;
                break;
         case(WINSINTF_E_VERIFY_SCV):
                WinsIntfStat.TimeStamps.LastVerifyScvTime = *pSysTime;
                break;
         case(WINSINTF_E_INIT_DB):
                WinsIntfStat.TimeStamps.LastInitDbTime = *pSysTime;
                break;
         case(WINSINTF_E_PLANNED_PULL):
                WinsIntfStat.TimeStamps.LastPRplTime = *pSysTime;
                break;
         case(WINSINTF_E_ADMIN_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastATRplTime = *pSysTime;
                break;
         case(WINSINTF_E_NTWRK_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastNTRplTime = *pSysTime;
                break;
         case(WINSINTF_E_UPDCNT_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastNTRplTime = *pSysTime;
                break;
         case(WINSINTF_E_ADDCHG_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastACTRplTime = *pSysTime;
                break;
         case(WINSINTF_E_COUNTER_RESET):
                WinsIntfStat.TimeStamps.CounterResetTime   = *pSysTime;
                break;
         default:
                DBGPRINT1(EXC, "WinsIntfSetTime: Weird Timestamp type = (%d)\n", TimeType_e);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                break;
        }
        LeaveCriticalSection(&WinsIntfCrtSec);

        if (pTime)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);
            SystemTimeToTzSpecificLocalTime(&tzInfo, pSysTime, pTime);
        }

        return;
}

DWORD
WinsDelDbRecs(
        IN PWINSINTF_ADD_T        pAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This func. deletes a specified range of records belonging to a
        particular owner

Arguments:


Externals Used:
        None


Return Value:

   Success status codes -- WINSINTF_SUCCESS
   Error status codes   -- WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsDelDbRecs

Side Effects:

Comments:
        None
--*/

{

        COMM_ADD_T        Address;
        DWORD                RetVal = WINSINTF_SUCCESS;
        DWORD                dwOwnerId;
        BOOL                fAllocNew = FALSE;

          Address.AddTyp_e  = pAdd->Type;
          Address.AddLen    = pAdd->Len;
          Address.Add.IPAdd = pAdd->IPAdd;

        //
        // initialize this thread with the db engine
        //
          NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsDelDbRecs");


        if (RplFindOwnerId(
                        &Address,
                        &fAllocNew,        //do not allocate an entry if not
                                        //present
                        &dwOwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                      ) != WINS_SUCCESS)

        {
                DBGPRINT0(DET, "WinsDelDataRecs: WINS is not in the owner-add mapping table\n");
                RetVal = WINSINTF_FAILURE;
        }
        else
        {
            if (NmsDbDelDataRecs(
                        dwOwnerId,
                        MinVersNo,
                        MaxVersNo,
                        TRUE,         //enter critical section
                        FALSE         //no fragmented deletion
                        ) != WINS_SUCCESS)
            {
                RetVal = WINSINTF_FAILURE;
            }
        }

          //
          // Let us end the session
          //
        NmsDbCloseTables();
          NmsDbEndSession();
        return(RetVal);
}

DWORD
WinsTombstoneDbRecs(
        IN PWINSINTF_ADD_T           pAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This func. tombstones a specified range of records belonging to a
        particular owner

Arguments:


Externals Used:
        None


Return Value:

   Success status codes -- WINSINTF_SUCCESS
   Error status codes   -- WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsTombstoneDbRecs

Side Effects:


Comments:
        None
--*/

{

        DWORD                RetVal = WINSINTF_SUCCESS;
        COMM_ADD_T        Address;
        DWORD                dwOwnerId;
        BOOL                fAllocNew = FALSE;

        Address.AddTyp_e  = pAdd->Type;
        Address.AddLen    = pAdd->Len;
        Address.Add.IPAdd = pAdd->IPAdd;


        //
        // initialize this thread with the db engine
        //
        NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsTombstoneDbRecs");

        if (RplFindOwnerId(
                        &Address,
                        &fAllocNew,        //do not allocate an entry if not
                                        //present
                        &dwOwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                      ) != WINS_SUCCESS)

        {
                DBGPRINT0(DET, "WinsTombstoneDataRecs: WINS is not in the owner-add mapping table\n");
                RetVal = WINSINTF_FAILURE;
        }else if(NmsDbTombstoneDataRecs(
                    dwOwnerId,
                    MinVersNo,
                    MaxVersNo
                    ) != WINS_SUCCESS)
        {
            RetVal = WINSINTF_FAILURE;
        }
        // Let us end the session
        NmsDbCloseTables();
        NmsDbEndSession();
        return(RetVal);
}

DWORD
WinsPullRange(
        IN PWINSINTF_ADD_T        pWinsAdd,
        IN PWINSINTF_ADD_T        pOwnerAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This function is called to pull a range of records owned by a particular
        WINS server from another WINS server.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        PWINSINTF_PULL_RANGE_INFO_T pPullRangeInfo;
        PRPL_CONFIG_REC_T        pPnr;
        BOOL                        fRplPnr = FALSE;
        DWORD                        RetCode = WINSINTF_SUCCESS;


        //
        // if the minimum version number is > than the max version number
        // return a failure code
        //
        if (LiGtr(MinVersNo, MaxVersNo))
        {
                return(WINSINTF_FAILURE);

        }
        //
        // Enter the critical sections guarded by WinsCnfCnfCrtSec and
        // NmsNmhNamRegCrtSec. There is no danger of deadlock because we
        // always enter the two critical sections in the following sequence
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);

PERF("Do we need to enter the following critical section")
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
try {
        pPnr = WinsCnf.PullInfo.pPullCnfRecs;

        //
        // If we are allowed to pull only from configured partners,
        // let us try to find the config record of the partner
        //
        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
           if (pPnr != NULL)
           {
              //
              // Search for the Cnf record for the WINS we want to
              // send the PULL RANGE request to.
              //
              for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                        !fRplPnr;
                                // no third expression
                  )
               {


                   //
                   // Check if this is the one we want
                   //
                   if (pPnr->WinsAdd.Add.IPAdd == pWinsAdd->IPAdd)
                   {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        fRplPnr = TRUE;

                        //
                        // Make it 0, so that we always try to establish
                        // a connection.  Otherwise, pull thread may not
                        // try if it has already exhausted the number of
                        // retries
                        //
                        pPnr->RetryCount = 0;
                        continue;                //so that we can break out

                   }
                   //
                   // Get the next record that follows this one sequentially
                   //
                   pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
              } // end of for
          } // end of if (pPnr != 0)
       }  // end of if (fRplOnlyWCnfPnrs)
       else
       {
                pPnr = WinsMscHeapAlloc( NmsRpcHeapHdl, RPL_CONFIG_REC_SIZE);
                COMM_INIT_ADD_M(&pPnr->WinsAdd, pWinsAdd->IPAdd);
                pPnr->MagicNo           = 0;
                pPnr->RetryCount        = 0;
                pPnr->LastCommFailTime  = 0;
                pPnr->PushNtfTries    = 0;
                fRplPnr                     = TRUE;

                //
                // We want the buffer to be deallocated by the PULL thread
                //
                pPnr->fTemp   = TRUE;

//#if RPL_TYPE
                //
                // We need to pull according to the RplType for the pull pnrs
                //
                pPnr->RplType = WinsCnf.PullInfo.RplType;
//#endif

       }


        if (fRplPnr)
        {
            pPullRangeInfo = WinsMscHeapAlloc(
                                        NmsRpcHeapHdl,
                                        sizeof(WINSINTF_PULL_RANGE_INFO_T)
                                             );
#if 0
            WinsMscAlloc(sizeof(WINSINTF_PULL_RANGE_INFO_T),
                                  &pPullRangeInfo);
#endif
            pPullRangeInfo->pPnr      =  pPnr;
            pPullRangeInfo->OwnAdd    =  *pOwnerAdd;
            pPullRangeInfo->MinVersNo =  MinVersNo;
            pPullRangeInfo->MaxVersNo =  MaxVersNo;


           //
           // Call RplInsertQue to insert the push request to
           // the Pull Thread
           //
           ERplInsertQue(
                     WINS_E_WINSRPC,
                     QUE_E_CMD_PULL_RANGE,
                     NULL,        //no Dlg Hdl
                     NULL,        //no msg is there
                     0,                //msg length
                     pPullRangeInfo,       //client context
                     pPnr->MagicNo
                     );
        }
 }
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("WinsPullRange");
                WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_PUSH_TRIGGER_EXC);
                RetCode = WINSINTF_FAILURE;
  }

        //
        // Leave the critical section guarded by NmsNmhNamRegCrtSec.
        //
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        //
        // if replication was allowed only with configured partners and
        // there was no WINS with the address specified by the client,
        // return failure
        //
        if (!fRplPnr)
        {
                RetCode = WINSINTF_FAILURE;
        }

        return(RetCode);
}

DWORD
WinsSetPriorityClass(
        IN WINSINTF_PRIORITY_CLASS_E        PriorityClass_e
        )

/*++

Routine Description:
        This function sets the priority class of the Wins process.

Arguments:
        PriorityClass -- Priority Class of the WINS process

Externals Used:
        WinsCnf


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        //DWORD   OldPrCls;
        DWORD   NewPrCls;
        HANDLE  ProcHdl;
        DWORD   RetVal = WINSINTF_SUCCESS;

        switch(PriorityClass_e)
        {
                case(WINSINTF_E_NORMAL):
                        NewPrCls = NORMAL_PRIORITY_CLASS;
                        break;
                case(WINSINTF_E_HIGH):
                        NewPrCls = HIGH_PRIORITY_CLASS;
                        break;
                default:
                        DBGPRINT0(DET, "WinsSetPriorityClass: Invalid Priority Class\n");
                        return(WINSINTF_FAILURE);
                        break;
        }


        ProcHdl = GetCurrentProcess();

        EnterCriticalSection(&WinsCnfCnfCrtSec);
#if 0
try {
FUTURES("Use a WinsMsc functions here for consistency")

        if ((OldPrCls = GetPriorityClass(ProcHdl)) == 0)
        {
                DBGPRINT1(ERR, "WinsSetPriorityClass: Can not Proc Priority. Error = (%d)\n", GetLastError());
                RetVal = WINSINTF_FAILURE;
        }
        else
        {
           if (OldPrCls == NewPrCls)
           {
                DBGPRINT1(ERR, "WinsSetPriorityClass: Process already has this Priority Class = (%d)\n", NewPrCls);
           }
           else
           {
#endif
                if (SetPriorityClass(ProcHdl, NewPrCls) == FALSE)
                {
                        DBGPRINT1(ERR, "WinsSetPriorityClass: SetPriorityClass() Failed. Error = (%d)\n", GetLastError());
                }
                else
                {
                        WinsCnf.WinsPriorityClass = (DWORD)PriorityClass_e;
                }
#if 0
           }
       }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsSetPriorityCls");
        }
#endif

        //
        // ProcHdl is a pseudo-handle and does not need to be closed
        //
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
        return(WINSINTF_SUCCESS);
}

DWORD
WinsResetCounters(
        VOID
        )

/*++

Routine Description:
        This function resets/clears the counters

Arguments:
        None

Externals Used:
        NmsNmhNamRegCrtSec

Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
        R_WinsResetCounters

Side Effects:

Comments:
        None
--*/

{
  DWORD i;
  PRPL_CONFIG_REC_T         pPnr;
  //
  // Copy the counters
  //
  EnterCriticalSection(&NmsNmhNamRegCrtSec);
  (VOID)RtlFillMemory(&WinsIntfStat.Counters, sizeof(WinsIntfStat.Counters), 0);
  LeaveCriticalSection(&NmsNmhNamRegCrtSec);
  // now clear the per partner info.
  EnterCriticalSection(&WinsCnfCnfCrtSec);
  pPnr       = WinsCnf.PullInfo.pPullCnfRecs;
  for (i = 0; (i<WinsCnf.PullInfo.NoOfPushPnrs) && (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE) ; i++) {
      pPnr->NoOfRpls = 0;
      pPnr->NoOfCommFails = 0;
      pPnr = WinsCnfGetNextRplCnfRec(pPnr,RPL_E_IN_SEQ);
  }
  LeaveCriticalSection(&WinsCnfCnfCrtSec);

  //
  // Even if we have multiple threads doing resets (unlikely occurence),
  // the window between the above critical section and the one entered
  // by the following function does not cause any problem.
  //
  WinsIntfSetTime(NULL, WINSINTF_E_COUNTER_RESET);

  return(WINSINTF_SUCCESS);
}

DWORD
WinsWorkerThdUpd(
        DWORD NewNoOfNbtThds
        )

/*++

Routine Description:
        This function is called to change the count of the NBT threads in
        the WINS process.

Arguments:
        NewNoOfNbtThds  - The new count of the Nbt threads

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        //
        // If the WINS server is not in steady state or if the new count
        // of Nbt threads requested is outside the allowed range, return
        // failure
        //
CHECK("Somehow, if the number of threads is equal to the max. number allowed")
CHECK("pTls comes out as NULL for all NBT threads (seen at termination)")
          if (

             ((WinsCnf.State_e != WINSCNF_E_RUNNING)
                        &&
             (WinsCnf.State_e != WINSCNF_E_PAUSED))
                        ||
             (NewNoOfNbtThds >= WINSTHD_MAX_NO_NBT_THDS)
                        ||
             (NewNoOfNbtThds < WINSTHD_MIN_NO_NBT_THDS)
          )
          {
                return(WINSINTF_FAILURE);
          }

        EnterCriticalSection(&WinsCnfCnfCrtSec);
        WinsIntfNoOfNbtThds = NewNoOfNbtThds;

try {
        //
        // If the new count is more than the existing count, store the new
        // count in a global and signal an Nbt thread. The signaled
        // Nbt thread will create all the extra threads needed
        //
        if (NewNoOfNbtThds > NmsNoOfNbtThds)
        {
                WinsMscSignalHdl(NmsCrDelNbtThdEvt);
        }
        else
        {
                //
                // if the new count is same as the existing count, return
                // success
                //
                if (NewNoOfNbtThds == NmsNoOfNbtThds)
                {
                        DBGPRINT1(FLOW, "WinsWorkerThdUpd: Wins server already has %d threads\n", NewNoOfNbtThds);
                }
                else  // NewNoOfNbtThds < NmsNoOfNbtThds
                {
                        //
                        // Signal a thread to delete self. The signaled thread will
                        // signal the event again if more than one thread has to be
                        // deleted
                        //
                        WinsMscSignalHdl(NmsCrDelNbtThdEvt);
                }
        }
}
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsWorkerThdUpd");
        }

        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        return(WINSINTF_SUCCESS);
}



DWORD
WinsGetNameAndAdd(
        PWINSINTF_ADD_T   pWinsAdd,
        LPBYTE                      pUncName
        )
{
  DWORD RetStat = WINSINTF_SUCCESS;

//  TCHAR UncName[MAX_COMPUTERNAME_LENGTH + 1];
//  DWORD LenOfBuff = WINSINTF_MAX_COMPUTERNAME_LENGTH;
  DWORD LenOfBuff = MAX_COMPUTERNAME_LENGTH + 1;
  pWinsAdd->IPAdd = NmsLocalAdd.Add.IPAdd;
FUTURES("Change this to GetComputerName when winsadmn is made unicode compliant")
  if (GetComputerNameA(pUncName, &LenOfBuff) == FALSE)
  {
     DBGPRINT1(ERR, "WinsGetNameAndAdd: Name error. Error=(%x)\n", GetLastError());
     RetStat = GetLastError();
  }
  return(RetStat);
}



#define INITIAL_RAMPUP_NO       3

DWORD
WinsGetBrowserNames(
        PWINSINTF_BIND_DATA_T             pWinsHdl,
        PWINSINTF_BROWSER_NAMES_T         pNames
        )
{

        DWORD              RetVal = WINSINTF_SUCCESS;
        time_t             CurrentTime;
        static   DWORD     sNoOfTimes = 0;
        static   time_t    sLastTime = 0;
        BOOL               fPopCache = FALSE;


        UNREFERENCED_PARAMETER(pWinsHdl);

        //
        // If this the initial ramp up period, populate the cache
        //
        if (sNoOfTimes++ < INITIAL_RAMPUP_NO)
        {
                //
                // if this is the first call, create the dom. cache event.
                //
                if (sNoOfTimes == 1)
                {
                    WinsMscCreateEvt(L"WinsDomCachEvt", FALSE, &sDomCache.EvtHdl);
                }
                DBGPRINT1(SPEC, "WinsGetBrowserNames: sNoOfTimes = (%d)\n", sNoOfTimes);
                fPopCache = TRUE;
        }
        else
        {
          //
          // Initial ramp up period is past.  Populate the cache if 3 mts
          // have expired since it was last populated
          //
          if ((time(&CurrentTime) - sLastTime) > THREE_MTS || sDomCache.bRefresh)
          {
                DBGPRINT0(SPEC, "WinsGetBrowserNames: Pop Cache due to timeout\n");
                sDomCache.bRefresh = FALSE;
                sLastTime = CurrentTime;
                fPopCache = TRUE;
          }
        }
try {
        //
        // Populate the cache if fPopCache is set or if the number of entries
        // in the current cache are 0
        //
        if (fPopCache || (sDomCache.SzOfBlock == 0))
        {
          //
          // if our cache has some data, deallocate it first.
          //
          // Note: There could be an rpc thread in the rpc code accessing
          // this buffer. I can't free this buffer until it is done.
          //
          if (sDomCache.SzOfBlock > 0)
          {
                DWORD i;
                PWINSINTF_BROWSER_INFO_T pBrInfo = sDomCache.pInfo;
                DWORD NoOfUsers;

                //
                // Wait until all users are done. We won't iterate more than
                //
                // We can iterate a max. of INITIAL_RAMPUP_NO of times and
                // that too only at initial ramp up time. If a thread is
                // waiting on the event, another thread will also wait
                // on it (except during initial rampup time)
                //
                do {
                 EnterCriticalSection(&WinsIntfNoOfUsersCrtSec);
                 NoOfUsers = sDomCache.NoOfUsers;
                 LeaveCriticalSection(&WinsIntfNoOfUsersCrtSec);
                 if (NoOfUsers > 0)
                 {
                    WinsMscWaitInfinite(sDomCache.EvtHdl);
                 }
                } while (NoOfUsers > 0);
                //
                // Free all memory allocated for names
                //
                for (i=0;  i< sDomCache.EntriesRead; i++, pBrInfo++)
                {
                   midl_user_free(pBrInfo->pName);
                }

                //
                // Free the main block
                //
                midl_user_free(sDomCache.pInfo);
                sDomCache.SzOfBlock = 0;
                pNames->EntriesRead = 0;
                pNames->pInfo = NULL;
          }

          NmsDbThdInit(WINS_E_WINSRPC);
          NmsDbOpenTables(WINS_E_WINSRPC);
          DBGMYNAME("RPC-WinsGetBrowserNames");

          //
          // Get all records starting with 1B Names
          //
          RetVal = NmsDbGetNamesWPrefixChar(
                                        0x1B,
                                        &pNames->pInfo,
                                        &pNames->EntriesRead
                                          );
          NmsDbCloseTables();
          NmsDbEndSession();

          //
          // Store the info. only if there is something to be stored.
          //
          if (
                (RetVal == WINS_SUCCESS)
                        &&
                (pNames->EntriesRead > 0)
             )
          {
             sDomCache.SzOfBlock =
                        pNames->EntriesRead * sizeof(WINSINTF_BROWSER_INFO_T);
            // sDomCache.pInfo = midl_user_allocate(sDomCache.SzOfBlock);
            // WINSMSC_COPY_MEMORY_M(sDomCache.pInfo, pNames->pInfo,
    //                                            sDomCache.SzOfBlock);
             sDomCache.pInfo = pNames->pInfo;
             sDomCache.EntriesRead = pNames->EntriesRead;
          }
          else
          {
                //
                // We did not get anything from the db
                //
                sDomCache.SzOfBlock = 0;
                pNames->EntriesRead = 0;
                pNames->pInfo = NULL;
          }
        }
        else
        {
                //
                // Use the cached info.
                //
                //pNames->pInfo = midl_user_allocate(sDomCache.SzOfBlock);
                //WINSMSC_COPY_MEMORY_M(pNames->pInfo, sDomCache.pInfo,
                //                                sDomCache.SzOfBlock);
                pNames->pInfo = sDomCache.pInfo;
                pNames->EntriesRead = sDomCache.EntriesRead;
        }
 }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetBrowserNames");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_BROWSER_NAME_EXC);
        pNames->EntriesRead = 0;
        pNames->pInfo = NULL;
        RetVal = WINSINTF_FAILURE;
        }
        return(RetVal);
}

VOID
R_WinsGetBrowserNames_notify_flag(boolean __MIDL_NotifyFlag
)
/*++

Routine Description:
  Called by rpc to indicate that it is done with the buffer returned by
  WinsGetBrowserNames

Arguments:

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
     //
     // Decrement the user count. If equal to 0, signal the event to let
     // another thread go on.
     //
     EnterCriticalSection(&WinsIntfNoOfUsersCrtSec);

     //
     // workaround an rpc bug (18627) where it may call notify without calling
     // R_WinsGetBrowserNames (checkout winsif_s.c)
     //
     if (
           (sDomCache.NoOfUsers > 0) &&
           (--sDomCache.NoOfUsers == 0) &&
           sDomCache.EvtHdl != NULL
        )
     {
          WinsMscSignalHdl(sDomCache.EvtHdl);
     }
     LeaveCriticalSection(&WinsIntfNoOfUsersCrtSec);
     return;
}

DWORD
WinsDeleteWins(
        PWINSINTF_ADD_T   pWinsAdd
        )
{
        PCOMM_ADD_T        pAdd;
        DWORD                RetVal = WINSINTF_FAILURE;


        if (pWinsAdd->IPAdd == NmsLocalAdd.Add.IPAdd)
        {
                WINSINTF_VERS_NO_T MinVersNo = {0};
                WINSINTF_VERS_NO_T MaxVersNo = {0};
                RetVal = WinsDelDbRecs(pWinsAdd, MinVersNo, MaxVersNo);
#if 0
                //
                // We always keep the entry for the local WINS. For any
                //
                DBGPRINT0(ERR, "WinsDeleteWins: Sorry, you can not delete the entry for the local WINS\n");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_DELETE_LOCAL_WINS_DISALLOWED);
                RetVal = WINSINTF_CAN_NOT_DEL_LOCAL_WINS;
#endif
        }
        else
        {
                WCHAR String[WINS_MAX_NAME_SZ];
                struct in_addr InAddr;

                InAddr.s_addr = htonl(pWinsAdd->IPAdd);
                (VOID)WinsMscConvertAsciiStringToUnicode(
                            inet_ntoa( InAddr),
                            (LPBYTE)String,
                            WINS_MAX_NAME_SZ);

                WinsLogAdminEvent(WINS_EVT_ADMIN_DEL_OWNER_INITIATED,1,String);

                //
                // Allocate from the general heap (not from the rpc heap)
                // since this memory will be deallocated by DeleteWins in
                // rplpull.c which I don't want to tie to just rpc work.
                //
                   WinsMscAlloc(sizeof(COMM_ADD_T), &pAdd);
                   pAdd->AddTyp_e = pWinsAdd->Type;
                   pAdd->AddLen    = pWinsAdd->Len;
                pAdd->Add.IPAdd = pWinsAdd->IPAdd;

                //
                // Call RplInsertQue to insert the push request to
                // the Pull Thread
                //
                ERplInsertQue(
                     WINS_E_WINSRPC,
                     QUE_E_CMD_DELETE_WINS,
                     NULL,        //no Dlg Hdl
                     NULL,        //no msg is there
                     0,                //msg length
                     pAdd,   //client context,
                     0      //no magic no
                     );
                RetVal = WINSINTF_SUCCESS;
        }
        return(RetVal);
}

#define MAX_RECS_TO_RETURN  5000
DWORD
WinsGetDbRecsByName (
        PWINSINTF_ADD_T             pWinsAdd,
        DWORD                       Location,
        LPBYTE                      pName,
        DWORD                       NameLen,
        DWORD                       NoOfRecsDesired,
        DWORD                       TypeOfRecs,
        PWINSINTF_RECS_T            pRecs
        )

/*++

Routine Description:
        This function returns with all the records (that can fit into the
        buffer passed) owned by a WINS in the local db of this WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        COMM_ADD_T           Address;
        LPVOID               pBuff = NULL;
        DWORD                BuffLen;
        DWORD                NoOfRecs = 0;
        DWORD                Status;
        PWINSTHD_TLS_T        pTls;

        DBGENTER("WinsGetDbRecsByName\n");


        if ((NoOfRecsDesired == 0) || (NoOfRecsDesired > MAX_RECS_TO_RETURN))
        {
                NoOfRecsDesired = MAX_RECS_TO_RETURN;
        }


        if ((pWinsAdd != NULL) && (pWinsAdd->IPAdd != 0))
        {
                  Address.AddTyp_e  = pWinsAdd->Type;
                  Address.AddLen    = pWinsAdd->Len;
                  Address.Add.IPAdd = pWinsAdd->IPAdd;
        }
        //
        // initialize this thread with the db engine
        //
        NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsGetDbRecsByName");
 try {
        if ((pName != NULL) && (NameLen != 0))
        {
           //
           // Terminate name with NULL, just in case user didn't do it.
           //
           *(pName + NameLen) = (BYTE)NULL;
        }
        if ((pName == NULL) && (NameLen > 0))
        {
             NameLen = 0;
        }

PERF("The caller can pass the number of records for which space has been")
PERF("allocated in buffer pointed to by pRec in the NoOfRecs field. We should")
PERF("We should pass this argument to NmsDbGetDataRecs so that it does not get")
PERF("more records than are necessary")

        Status = NmsDbGetDataRecsByName(
                        pName,
                        NameLen != 0 ? NameLen + 1 : 0,
                        Location,
                        NoOfRecsDesired,
                        pWinsAdd != NULL ? &Address : NULL,
                        TypeOfRecs,
                        &pBuff,
                        &BuffLen,
                        &NoOfRecs
                        );


        if (Status == WINS_SUCCESS)
        {
            Status = PackageRecs( pBuff, BuffLen, NoOfRecs, pRecs);
        }

      }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetDbRecsByName");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPC_EXC);
        Status = WINS_FAILURE;
 }
        //
        // Free the buffer and destroy the heap.
        //
        GET_TLS_M(pTls);
        if (pTls->HeapHdl != NULL)
        {
               if (pBuff != NULL)
               {
                  WinsMscHeapFree(pTls->HeapHdl, pBuff);
               }
               WinsMscHeapDestroy(pTls->HeapHdl);
//               pTls->HeapHdl = NULL;
        }

        //
        // Let us end the session
        //
        NmsDbCloseTables();
        NmsDbEndSession();

        if (Status != WINS_SUCCESS)
        {
            pRecs->pRow = NULL;
            pRecs->NoOfRecs = 0;
            Status = WINSINTF_FAILURE;
        }
        else
        {
            if (pRecs->NoOfRecs == 0)
            {
              pRecs->pRow = NULL;
              pRecs->NoOfRecs = 0;
              Status = WINSINTF_REC_NOT_FOUND;
            }
        }
        DBGLEAVE("WinsGetDbRecsByName\n");
        return (Status);
}

STATUS
PackageRecs(
        PRPL_REC_ENTRY2_T     pBuff,
        DWORD                BuffLen,
        DWORD                NoOfRecs,
        PWINSINTF_RECS_T     pRecs
     )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
//        ULONG                Status;
        BOOL                 fExcRaised = FALSE;
        PWINSINTF_RECORD_ACTION_T pRow;
        DWORD                i;
        DWORD                ind;
        DWORD                EntType;
 //       DWORD                MaxAdds;
        PWINSTHD_TLS_T       pTls;

        DBGENTER("PackageRecs\n");

        i = 0;
        GET_TLS_M(pTls);
try {

        //
        // If there are records to send back and the client has specified
        // a buffer for them, insert the records
        //
        if  (NoOfRecs > 0)
        {

          //
          // Allocate memory for the no of records
          //
          pRecs->BuffSize  =  sizeof(WINSINTF_RECORD_ACTION_T) * NoOfRecs;

          //
          // If memory can not be allocate, an exception will be returned
          // by midl_user_alloc
          //
          pRecs->pRow      =  midl_user_allocate(pRecs->BuffSize);

#if 0
          pRecs->pRow      =  RpcSmAllocate(pRecs->BuffSize, &Status);

          if (Status != RPC_S_OK)
          {
             DBGPRINT1(ERR, "PackageRecs: RpcSmAllocate returned error = (%x)\n", Status);
          }
#endif
          pRow                    =  pRecs->pRow;


          for (; i<NoOfRecs; i++)
          {

                //
                // Initialize so that we don't get "enum wrong" error.
                //
                pRow->Cmd_e = WINSINTF_E_QUERY;

                //
                // the name retrieved has NULL as the last character.  This
                // We need to pass a name without this NULL.
                //
                pRow->NameLen = pBuff->NameLen;
                if (*pBuff->pName == 0x1B)
                {
                        WINS_SWAP_BYTES_M(pBuff->pName, pBuff->pName + 15);
                }

                // +1 added to fix #390830
                pRow->pName =  midl_user_allocate(pRow->NameLen + 1);
#if 0
                pRow->pName =  RpcSmAllocate(pRow->NameLen, &Status);
                if (Status != RPC_S_OK)
                {
                   DBGPRINT1(ERR, "PackageRecs: RpcSmAllocate returned error = (%x)\n", Status);
                }
#endif
                WINSMSC_COPY_MEMORY_M(pRow->pName, pBuff->pName,pRow->NameLen);
                WinsMscHeapFree(pTls->HeapHdl, pBuff->pName);

                EntType = NMSDB_ENTRY_TYPE_M(pBuff->Flag);
                pRow->TypOfRec_e = NMSDB_ENTRY_UNIQUE_M(EntType)
                                                         ? WINSINTF_E_UNIQUE :
                                (NMSDB_ENTRY_NORM_GRP_M(EntType) ?
                                        WINSINTF_E_NORM_GROUP :
                                (NMSDB_ENTRY_SPEC_GRP_M(EntType) ?
                                        WINSINTF_E_SPEC_GROUP :
                                        WINSINTF_E_MULTIHOMED));


                if (
                    (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ||
                    (pRow->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                   )
                {
                        PWINSINTF_ADD_T       pAdd;
                        DWORD                 No;

                        if (pBuff->NoOfAdds > 0)
                        {
                            pRow->NoOfAdds = pBuff->NoOfAdds * 2;


                           //
                           // Each member is comprised of two addresses,
                           // first address is that of the owner WINS, second
                           // address is that of the node registered
                           //
                           pRow->pAdd        =
//                             RpcSmAllocate(
                             midl_user_allocate(
                                        (unsigned int)(pRow->NoOfAdds)
                                                *
                                        sizeof(WINSINTF_ADD_T)//,
//                                        &Status
                                             );

#if 0
          if (Status != RPC_S_OK)
          {
             DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
          }
#endif

                           for (
                                No= 0, ind= 0, pAdd = pRow->pAdd;
                                No < (pRow->NoOfAdds/2);
                                No++
                            )
                          {
                           pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ind)->AddTyp_e;
                           pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                           pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind)->Add.IPAdd;

                           pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ++ind)->AddTyp_e;
                           pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                           pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind++)->Add.IPAdd;
                          }
                          WinsMscHeapFree(pTls->HeapHdl, pBuff->pNodeAdd);
                       }
                }
                else
                {
                          pRow->NoOfAdds =  0;
                          pRow->pAdd       = NULL;
                          pRow->Add.Type   = (UCHAR)pBuff->NodeAdd[0].AddTyp_e;
                          pRow->Add.Len    = pBuff->NodeAdd[0].AddLen;
                          pRow->Add.IPAdd  = pBuff->NodeAdd[0].Add.IPAdd;
                }
                pRow->NodeTyp     = (BYTE)NMSDB_NODE_TYPE_M(pBuff->Flag);
                pRow->fStatic     = NMSDB_IS_ENTRY_STATIC_M(pBuff->Flag);
                pRow->State_e     = NMSDB_ENTRY_STATE_M(pBuff->Flag);
                pRow->VersNo      = pBuff->VersNo;
                pRow->TimeStamp   = pBuff->TimeStamp;
                pRow->OwnerId     = pBuff->OwnerId;
                pRow++;


                pBuff = (PRPL_REC_ENTRY2_T)((LPBYTE)pBuff + RPL_REC_ENTRY2_SIZE);
PERF("Do the addition above the for loop and store in a var. Use var. here")

         } // end of for loop
        } //end of if block
        else
        {
                pRecs->pRow = NULL;
        }

 }        // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetDbRecs");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPC_EXC);
        fExcRaised = TRUE;
        }

        pRecs->TotalNoOfRecs = NoOfRecs;

        if (!fExcRaised)
        {
           pRecs->NoOfRecs = i;
        }
        else
        {
        //     RpcSmFree(pRecs->pRow);
            midl_user_free(pRecs->pRow);
            pRecs->NoOfRecs = 0;
        }

        DBGENTER("PackageRecs\n");
        return (WINSINTF_SUCCESS);
}




//void __RPC_FAR * __RPC_API
void *
midl_user_allocate(size_t cBytes)
{
#if 0
//#ifdef WINSDBG
        LPVOID pMem = WinsMscHeapAlloc(NmsRpcHeapHdl, cBytes);
        DBGPRINT1(DET, "midl_user_alloc: Memory allocated is (%d)\n", pMem);
        return(pMem);
//#else
#endif
        return(WinsMscHeapAlloc(NmsRpcHeapHdl, cBytes));
}

//void __RPC_FAR __RPC_API
void
//midl_user_free(void __RPC_FAR *pMem)
midl_user_free(void  *pMem)
{
        if (pMem != NULL)
        {
//                DBGPRINT1(DET, "midl_user_free: Memory to free is (%d)\n", pMem);
                WinsMscHeapFree(NmsRpcHeapHdl, pMem);
        }
        return;
}

VOID
LogClientInfo(
  RPC_BINDING_HANDLE ClientHdl,
  BOOL                   fAbruptTerm
  )
{
  RPC_STATUS        RpcRet;
  RPC_BINDING_HANDLE Binding;
  PTUCHAR pStringBinding;
  PTUCHAR pProtSeq;
  PTUCHAR pNetworkAddress;
  WINSEVT_STRS_T EvtStrs;

NOTE("remove #if 0 when we go to 540 or above")
#if 0
  RpcRet = RpcBindingServerFromClient(ClientHdl,  &Binding);

  if (RpcRet != RPC_S_OK)
  {
        DBGPRINT1(ERR, "LogClientInfo: Can not get binding handle. Rpc Error = (%d)\nThis could be because named pipe protocol is being used\n", RpcRet);
        Binding = ClientHdl;
  }
#endif
NOTE("remove when we go to 540 or above")
  Binding = ClientHdl;


  RpcRet = RpcBindingToStringBinding(Binding, &pStringBinding);
  if (RpcRet != RPC_S_OK)
  {
        DBGPRINT1(ERR, "LogClientInfo: RpcBindingToStringBinding returned error = (%d)\n", RpcRet);
          return;
  }
  RpcRet = RpcStringBindingParse(
                                pStringBinding,
                                NULL,        //don't want uuid
                                &pProtSeq,
                                &pNetworkAddress,
                                NULL,                //end point
                                NULL                //network options
                                );
  if (RpcRet != RPC_S_OK)
  {
        DBGPRINT1(ERR, "LogClientInfo: RpcStringBindingParse returned error = (%d)\n", RpcRet);
        RpcStringFree(&pStringBinding);
          return;
  }

#ifndef UNICODE
  DBGPRINT2(FLOW, "LogClientInfo: The protocol sequence and address used by client are (%s) and (%s)\n", pProtSeq, pNetworkAddress);
#else
#ifdef WINSDBG
  IF_DBG(FLOW)
  {
    wprintf(L"LogClientInfo: The protocol sequence and address used by client are (%s) and (%s)\n", pProtSeq, pNetworkAddress);
  }
#endif
#endif
  RpcStringFree(&pProtSeq);
  RpcStringFree(&pNetworkAddress);

  EvtStrs.NoOfStrs = 1;
  EvtStrs.pStr[0] = (LPTSTR)pNetworkAddress;
  if (fAbruptTerm)
  {
    WINSEVT_LOG_STR_D_M(WINS_EVT_ADMIN_ABRUPT_SHUTDOWN, &EvtStrs);
  }
  else
  {
    WINSEVT_LOG_STR_D_M(WINS_EVT_ADMIN_ORDERLY_SHUTDOWN, &EvtStrs);
  }
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\nmfilter.c ===
#include <string.h>
#include "wins.h"
#include "winsmsc.h"
#include "nmfilter.h"

// local defines
#define SET_BIT(Mask, Key)     (Mask)[(Key)>>3] |= 1<<((Key)&7)
#define CLR_BIT(Mask, Key)     (Mask)[(Key)>>3] &= ~(1<<((Key)&7))
#define IS_SET(Mask, Key)      ((Mask)[(Key)>>3] & (1<<((Key)&7)))

// the root of the filter tree.
PNMFILTER_TREE      g_p1BFilter = NULL;
// critical section protecting the filter tree
CRITICAL_SECTION    g_cs1BFilter;

//--------------------------
// init the filter passed as parameter
PNMFILTER_TREE
InitNmFilter(PNMFILTER_TREE pFilter)
{
    if (pFilter != NULL)
        DestroyNmFilter(pFilter);

    // create the root node of the filter. This stands only for the common point
    // of all filters starting with different chars.
    //
    WinsMscAlloc(sizeof(NMFILTER_TREE), &pFilter);
    InitializeListHead(&pFilter->Link);
    pFilter->chKey = 0;
    // for the root of the filter only, nRef is zero
    pFilter->nRef = 0;
    // for the FollowMap, memory has been zeroed on allocation
    // for the Flags, memory has been zeroed on allocation
    InitializeListHead(&pFilter->Follow);
    return pFilter;
}

//--------------------------
// clears the whole subtree from the node given as parameter, 
// the node itself being also deleted
PNMFILTER_TREE
DestroyNmFilter(PNMFILTER_TREE pNode)
{
    if (pNode == NULL)
        return NULL;

    while(!IsListEmpty(&pNode->Follow))
    {
        PLIST_ENTRY     pEntry;
        PNMFILTER_TREE  pFollow;

        pEntry = RemoveHeadList(&pNode->Follow);
        pFollow = CONTAINING_RECORD(pEntry, NMFILTER_TREE, Link);

        DestroyNmFilter(pFollow);
    }
    WinsMscDealloc(pNode);

    return NULL;
}

//--------------------------
// inserts a name in the filter
VOID
InsertNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen)
{
    PNMFILTER_TREE pFollow = NULL;
    
    // the assumption is that the filter has been initialized already (hence pNode != NULL)
    //
    // if no data has been given, mark this node as being terminal and get out
    if (nLen == 0)
    {
        pNode->Flags |= NMFILTER_FLAG_TERMINAL;
        return;
    }

    // we do have a name to add
    // quick check if there is a follower for *pName already
    if (!IS_SET(pNode->FollowMap, *pName))
    {
        WinsMscAlloc(sizeof(NMFILTER_TREE), &pFollow);
        InitializeListHead(&pFollow->Link);
        pFollow->chKey = *pName;
        // this is the first reference for this key
        pFollow->nRef = 1;
        // for the FollowMap, memory has been zeroed on allocation
        // for the Flags, memory has been zeroed on allocation
        InitializeListHead(&pFollow->Follow);
        // insert this follower at the end of the node's "Follow" list (lowest nRef)
        InsertTailList(&pNode->Follow, &pFollow->Link);
        // set the bit in the map saying there is now a follower for this key
        SET_BIT(pNode->FollowMap, *pName);
    }
    else
    {
        PLIST_ENTRY     pEntry;

        // we have a follower for the given key
        // we need first to locate it
        for (pEntry = pNode->Follow.Blink; pEntry != &pNode->Follow; pEntry = pEntry->Blink)
        {
            PNMFILTER_TREE  pCandidate;

            pCandidate = CONTAINING_RECORD(pEntry, NMFILTER_TREE, Link);

            // if we didn't find yet the right follower..
            if (pFollow == NULL)
            {
                // check if the current entry is not the right one
                if (pCandidate->chKey == *pName)
                {
                    pFollow = pCandidate;
                    // since this is a new reference to this follower, bump up nRef
                    pFollow->nRef++;
                }
            }
            else
            {
                // we did find the follower by going backwards in the list. Then move this
                // follower closer to the head of the list based on its nRef (the list should
                // be ordered descendingly by nRef)
                if (pFollow->nRef < pCandidate->nRef && pCandidate->Link.Flink != &pFollow->Link)
                {
                    RemoveEntryList(&pFollow->Link);
                    InsertHeadList(&pCandidate->Link, &pFollow->Link);
                    break;
                }
            }
        }
        // at this point, pFollow should be non-null!! the bit from FollowMap assured us the 
        // follower had to exist.
    }

    // now let the follower do the rest of the work
    pName++; nLen--;
    InsertNmInFilter(pFollow, pName, nLen);
}

//--------------------------
// checks whether a name is present in the filter or not
BOOL
IsNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen)
{
    PLIST_ENTRY     pEntry;

    // if there is no filter, this means we filter the whole universe.
    // just return true.
    if (pNode == NULL)
        return TRUE;

    // if there are no more keys to look for, return true
    // if this node is marked as "terminal" (meaning there is a name
    // in the filter that ends at this level
    if (nLen == 0)
        return (pNode->Flags & NMFILTER_FLAG_TERMINAL);

    // if there is no follower for the name, it means 
    if (!IS_SET(pNode->FollowMap, *pName))
        return FALSE;

    // we do have a valid name, and a follower for it.
    // now just locate the follower and pass it the task of checking the remainings of the name
    for (pEntry = pNode->Follow.Flink; pEntry != &pNode->Follow; pEntry = pEntry->Flink)
    {
        PNMFILTER_TREE  pCandidate;
        pCandidate = CONTAINING_RECORD(pEntry, NMFILTER_TREE, Link);
        if (pCandidate->chKey == *pName)
        {
            pName++; nLen--;
            return IsNmInFilter(pCandidate, pName, nLen);
        }
    }

    // if we reached this point, something is wrong - we didn't find a follower although
    // the bitmap said there should be one. Just return FALSE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winsmsc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        winsmsc.c



Abstract:

   This module contains miscellanous functions that in general are used by
   more than one component of WINS.  Some of the functions in this module are
   wrappers for WIN32 api functions.  These wrappers serve to isolate
   WINS code from changes in the WIN32 api.

Functions:

         WinsMscAlloc
        WinsMscDealloc
        WinsMscFreeMem
        WinsMscWaitInfinite
        WinsMscWaitTimed
        WinsMscCreateEvt
        WinsMscSetUpThd
        WinsMscWaitUntilSignaled
        WinsMscWaitTimedUntilSignaled
        WinsMscHeapAlloc
        WinsMscHeapFree
        WinsMscHeapCreate
        WinsMscHeapDestroy
        WinsMscTermThd
        WinsMscSignalHdl
        WinsMscResetHdl
        WinsMscCloseHdl
        WinsMscCreateThd
        WinsMscSetThdPriority
        WinsMscOpenFile
        WinsMscMapFile


Portability:
        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

#include <string.h>

#if 0
//
// The following is just for the system call
//
#ifdef WINSDBG
#include <process.h>
#include <stdlib.h>
#endif
#endif

#include "wins.h"
#include "nms.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winscnf.h"
#include "winstmm.h"
#include "winsevt.h"
#include "winsque.h"
#include "winsprs.h"
#include "winsdbg.h"

/*
 *        Local Macro Declarations
 */

#define  PERCENT_CHAR         TEXT('%')
/*
 *        Local Typedef Declarations
 */


/*
 *        Global Variable Definitions
 */



/*
 *        Local Variable Definitions
 */



/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */

__inline
VOID
WinsMscAlloc(
        IN   DWORD    BuffSize,
        OUT  LPVOID  *ppRspBuff
        )


/*++

Routine Description:
        This function is called to allocate memory.


Arguments:
        BuffSize  - Size of buffer to allocate
        ppRspBuff - Buffer allocated

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:

        NmsDbGetDataRecs, GetGroupMembers
Side Effects:

Comments:
        None
--*/

{
FUTURES("Change this function into a macro")

        *ppRspBuff = WinsMscHeapAlloc(GenBuffHeapHdl, BuffSize);

        return;
}

__inline
VOID
WinsMscDealloc(
        IN LPVOID        pBuff
        )

/*++

Routine Description:

        This function frees memory allocated via NmsDbAlloc
Arguments:
        pBuff  -- Buffer to deallocate


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/


{
FUTURES("Change this function into a macro")
        WinsMscHeapFree(GenBuffHeapHdl, pBuff);
        return;
}



VOID
WinsMscFreeMem(
        IN  PWINS_MEM_T pWinsMem
        )

/*++

Routine Description:
         This function is called to free memory that is pointed to by one
        or more pointers in the pWinsMem array


        This function is called from all those functions that allocate
        memory or that acquire memory allocated by called function via
        OUT args of those "memory allocating" called functions.

Arguments:

        pWinsMem - ptr to an array of buffers to deallocate

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        pWinsMem array should end with a NULL pointer
--*/

{

  if (pWinsMem != NULL)
  {

          for (; pWinsMem->pMem != NULL; pWinsMem++)
          {
                WinsMscDealloc(pWinsMem->pMem);
          }
  }
  return;
}

VOID
WinsMscWaitInfinite(
        IN HANDLE  Hdl
)

/*++

Routine Description:
        The function is called to wait on a handle until signalled.

Arguments:
        Hdl -- handle to wait on until signaled


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        DWORD        RetVal = WAIT_OBJECT_0;

        /*
         The function should return only if the handle is in the signaled state
        */
        RetVal = WaitForSingleObject(Hdl, INFINITE);

        if (RetVal != WAIT_OBJECT_0)
        {
                WINS_RAISE_EXC_M(WINS_EXC_ABNORMAL_TERM);
        }

        return;
}

VOID
WinsMscWaitTimed(
        IN HANDLE    Hdl,
        IN DWORD     TimeOut,
        OUT LPBOOL   pfSignaled
)

/*++

Routine Description:
        The function is called to wait on a handle until signalled.

Arguments:
        Hdl        - handle to wait on until signaled
        TimeOut    - TIme for which the wait has to be done
        pfSIgnaled - Indicates whether the hdl got signaled.


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        DWORD        RetVal = WAIT_OBJECT_0;

        *pfSignaled = TRUE;

        /*
         The function should return only if the handle is in the signaled state
        */
        RetVal = WaitForSingleObject(Hdl, TimeOut);

        if (RetVal == WAIT_ABANDONED)
        {
                WINS_RAISE_EXC_M(WINS_EXC_ABNORMAL_TERM);

        }
        if (RetVal == WAIT_TIMEOUT)
        {
                if (TimeOut == INFINITE)
                {
                        WINS_RAISE_EXC_M(WINS_EXC_ABNORMAL_TERM);
                }
                else
                {
                   *pfSignaled = FALSE;
                }
        }


        return;
}

VOID
WinsMscCreateEvt(
        IN LPTSTR         pName,
        IN BOOL                fManualReset,
        IN PHANDLE        pHdl
        )

/*++

Routine Description:
        This function creates an event with the specified name


Arguments:
        pName                 - Name of Event to create
        fManualReset        - Flag indicating whether it is a manual reset event
        pHdl            - Handle to Event created


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        Init in nms.c

Side Effects:

Comments:
        None
--*/

{

   DWORD        Error;

   *pHdl = CreateEvent(
                        NULL,                //default security attributes
                        fManualReset,        //auto reset event
                        FALSE,          //Not signalled initially
                        pName            // name
                        );

   if (*pHdl == NULL)
   {
        Error = GetLastError();
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_CREATE_EVT);
        WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_RSRCS);
   }

   return;
}


STATUS
WinsMscSetUpThd(
        PQUE_HD_T                pQueHd,
        LPTHREAD_START_ROUTINE  pThdInitFn,
        LPVOID                        pParam,
        PHANDLE                        pThdHdl,
        LPDWORD                        pThdId
        )

/*++

Routine Description:

        This function initializes a queue and its critical section, creates
        an event and a thread to wait on that event.  The event is signaled
        whenever a work item is put on the queue.

Arguments:
        pQueHd     - Head of queue to be monitored by the thread
        pThdInitFn - Startup function of the thread
        pParam     - param to be passed to the startup function
        pThdhdl    - Hdl of thread created by this function
        pThdId     - Id of thread created by this function

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   -- none currently

Error Handling:

Called by:
        WinsTmmInit, RplInit, NmsChlInit
Side Effects:

Comments:
        None
--*/

{

        DWORD   ThdId;

        /*
        *  Initialize the critical section that protects the work queue of
        *  the Pull thread
        */
        InitializeCriticalSection(&pQueHd->CrtSec);

        /*
        *  Initialize the listhead for the pull thread's queue
        */
        InitializeListHead(&pQueHd->Head);

        /*
        * Create an auto-reset event for the above queue
        */
        WinsMscCreateEvt(
                        NULL,                //create without name
                        FALSE,                //auto-reser var
                        &pQueHd->EvtHdl
                        );

        /*
          Create the thread
        */
        *pThdHdl = WinsMscCreateThd(
                         pThdInitFn,
                         pParam,
                         &ThdId
                        );

        if (pThdId != NULL)
        {
          *pThdId = ThdId;
        }
        return(WINS_SUCCESS);

}



VOID
WinsMscWaitUntilSignaled(
        LPHANDLE        pHdlArray,
        DWORD                NoOfHdls,
        LPDWORD                pIndexOfHdlSignaled,
        BOOL            fAlertable
        )

/*++

Routine Description:
        This function is called to wait on multiple handles, one of which
        is the handle which is signaled at termination time


Arguments:
        pHdlArray - Array of handles to wait on
        NoOfHdls  - No of hdls in the array
        pIndexOfHdlSignaled - Index of the hdl signaled

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:

--*/
{

        DWORD  RetHdl;

        do {
            RetHdl = WaitForMultipleObjectsEx(
                                    NoOfHdls,        //# of handles in the array
                                    pHdlArray,        //array of handles
                                    FALSE,                //return when any of the events
                                                    //gets signaled
                                    INFINITE,        //Infinite timeout
                                    fAlertable
                                  );

            DBGPRINT1(DET, "WinsMscWaitUntilSignaled. WaitForMultipleObjects returned (%d)\n", RetHdl);
            // if we got signaled due to IO completion queued on the thread
            // just go back and wait again
        } while (fAlertable && WAIT_IO_COMPLETION == RetHdl);

        if (RetHdl == 0xFFFFFFFF)
        {
                DBGPRINT1(EXC, "WinsMscWaitUntilSignaled. WaitForMultipleObjects returned error. Error = (%d)\n", GetLastError());
                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
        }

        *pIndexOfHdlSignaled = RetHdl - WAIT_OBJECT_0;
        if (*pIndexOfHdlSignaled >= NoOfHdls)
        {

            WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);

        }

        return;
}


VOID
WinsMscWaitTimedUntilSignaled(
        LPHANDLE        pHdlArray,
        DWORD                NoOfHdls,
        LPDWORD                pIndexOfHdlSignaled,
        DWORD                TimeOut,
        LPBOOL                pfSignaled
        )

/*++

Routine Description:
        This function is called to wait on multiple handles, one of which
        is the handle which is signaled at termination time


Arguments:
        pHdlArray              - Array of handles to wait on
        NoOfHdls            - No of handles in the array
        pIndexOfHdlSignaled - Index of handle signaled
        Timeout             - Max time for which to do the wait
        pfSignaled          - indicates whether a hdl was signaled


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:

--*/
{

        DWORD  RetHdl = 0xFFFFFFFF;
        DWORD  Error;
        int        Index;

        *pfSignaled = TRUE;

        RetHdl = WaitForMultipleObjects(
                                NoOfHdls,        //# of handles in the array
                                pHdlArray,        //array of handles
                                FALSE,                //return when either event gets
                                                //signaled
                                TimeOut                //Infinite timeout
                              );

        if (RetHdl == 0xFFFFFFFF)
        {
                Error = GetLastError();
                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
        }

        if (RetHdl == WAIT_TIMEOUT)
        {
                *pfSignaled = FALSE;
                return;
        }

        Index = RetHdl - WAIT_OBJECT_0;

        if ((Index >= (int)NoOfHdls) || (Index < 0))
        {

            DBGPRINT1(EXC, "WinsMscWaitTimedUntilSignaled: Index of handle signaled (%d) is INVALID\n", Index);

            Index = RetHdl - WAIT_ABANDONED_0 ;
            if ((Index > 0) && (Index < (int)NoOfHdls))
            {
                    DBGPRINT1(EXC, "WinsMscWaitTimedUntilSignaled: Index of handle in the abandoned state (%d)\n", Index);
            }

            WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);

        }
        else
        {
                *pIndexOfHdlSignaled = Index;
        }
        return;
}



__inline
LPVOID
WinsMscHeapAlloc(
  IN  HANDLE     HeapHdl,
  IN  DWORD      Size
        )

/*++

Routine Description:
  The function returns with a buffer allocated from the specified heap



Arguments:

        HeapHdl  - Handle to the heap
        ppBuff   - Buffer allocated
        Size     - Size of Buffer

Externals Used:
        None

Return Value:

   Success status codes -- ptr to the allocated memory
   Error status codes   -- NULL

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{


  LPVOID  pBuff;
#ifdef WINSDBG
  LPDWORD pHeapCntr;
#endif

  //
  // Note: It is very important that the memory be initialized to zero
  //       (for example, until we have longlong (LARGE INTEGER) support
  //           in the db engine - JET, we will retrieve the version number
  //           as a long data type and store it in the LowPart field of the
  //           large integer storing the version number in our in-memory
  //       data structure.  The HighPart will be 0 by default due to
  //       the initialization done at allocation time.  This is what
  //       we want.
  //

  //
  // if you pass a very large value for the size, HeapAlloc returns NULL
  // instead of raising an exception.
  //
  pBuff = (MSG_T)HeapAlloc(
                        HeapHdl,
                        HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
                        Size
                        );

  DBGPRINT2(HEAP, "HeapAlloc: HeapHandle = (%p), pBuff = (%p)\n",
                        HeapHdl, pBuff);

#ifdef WINSDBG
    if (Size == 0)
    {
           DBGPRINT2(ERR, "WinsMscHeapAlloc: Size = 0; pBuff returned = (%p); HeapHdl = (%p)\n", pBuff, HeapHdl);

    }
    IF_DBG(HEAP_CNTRS)
    {

        if (HeapHdl ==  CommUdpBuffHeapHdl)
        {
              pHeapCntr = &NmsUdpHeapAlloc;
        } else if (HeapHdl ==  CommUdpDlgHeapHdl)
        {
              pHeapCntr = &NmsUdpDlgHeapAlloc;
        } else if (HeapHdl == CommAssocDlgHeapHdl)
        {
                  pHeapCntr = &NmsDlgHeapAlloc;
        } else if (HeapHdl == CommAssocTcpMsgHeapHdl)
        {
                  pHeapCntr = &NmsTcpMsgHeapAlloc;
        } else if (HeapHdl == GenBuffHeapHdl)
        {
                  pHeapCntr = &NmsGenHeapAlloc;
        } else if (HeapHdl ==  QueBuffHeapHdl)
        {
                  pHeapCntr = &NmsQueHeapAlloc;
        } else if (HeapHdl ==  NmsChlHeapHdl)
        {
                  pHeapCntr = &NmsChlHeapAlloc;
        } else if (HeapHdl ==  CommAssocAssocHeapHdl)
        {
                  pHeapCntr = &NmsAssocHeapAlloc;
        } else if (HeapHdl ==  RplWrkItmHeapHdl)
        {
                  pHeapCntr = &NmsRplWrkItmHeapAlloc;
        } else if (HeapHdl ==  NmsRpcHeapHdl)
        {
                  pHeapCntr = &NmsRpcHeapAlloc;
        } else if (HeapHdl ==  WinsTmmHeapHdl)
        {
                  pHeapCntr = &NmsTmmHeapAlloc;
        } else
        {
            DBGPRINT1(HEAP, "WinsMscHeapAlloc: HeapHdl = (%p)\n", HeapHdl);
            pHeapCntr = &NmsCatchAllHeapAlloc;
        }


        EnterCriticalSection(&NmsHeapCrtSec);

        (*pHeapCntr)++;
        LeaveCriticalSection(&NmsHeapCrtSec);
    }
#endif
  return(pBuff);
}





__inline
VOID
WinsMscHeapFree(
   IN   HANDLE  HeapHdl,
   IN   LPVOID  pBuff
        )

/*++

Routine Description:
        This function deallocates the memory pointed to by pBuff from the
        specified heap

Arguments:
        HeapHdl  - Handle to the heap
        pBuff         - Buffer to deallocate

Externals Used:


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

  DWORD  Error;
  BOOL   fStatus;
#ifdef WINSDBG
  LPDWORD pHeapCntr;
#endif

  DBGPRINT2(HEAP, "HeapFree: HeapHandle = (%p), pBuff = (%p)\n",
                        HeapHdl, pBuff);

  fStatus = HeapFree(
                HeapHdl,
                0,                //we want mutual exclusion
                pBuff
                    );

  if (!fStatus)
  {
        Error = GetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_HEAP_ERROR);
        WINS_RAISE_EXC_M(WINS_EXC_HEAP_FREE_ERR);
  }
#ifdef WINSDBG
    IF_DBG(HEAP_CNTRS)
    {
        if (HeapHdl ==  CommUdpBuffHeapHdl)
        {
              pHeapCntr = &NmsUdpHeapFree;
        } else  if (HeapHdl ==  CommUdpDlgHeapHdl)
        {
              pHeapCntr = &NmsUdpDlgHeapFree;
        } else if (HeapHdl == CommAssocDlgHeapHdl)
        {
                  pHeapCntr = &NmsDlgHeapFree;
        } else if (HeapHdl == CommAssocTcpMsgHeapHdl)
        {
                  pHeapCntr = &NmsTcpMsgHeapFree;
        } else if (HeapHdl == GenBuffHeapHdl)
        {
                  pHeapCntr = &NmsGenHeapFree;
        } else if (HeapHdl ==  QueBuffHeapHdl)
        {
                  pHeapCntr = &NmsQueHeapFree;
        } else if (HeapHdl ==  NmsChlHeapHdl)
        {
                  pHeapCntr = &NmsChlHeapFree;
        } else if (HeapHdl ==  CommAssocAssocHeapHdl)
        {
                  pHeapCntr = &NmsAssocHeapFree;
        } else if (HeapHdl ==  RplWrkItmHeapHdl)
        {
                  pHeapCntr = &NmsRplWrkItmHeapFree;
        } else if (HeapHdl ==  NmsRpcHeapHdl)
        {
                  pHeapCntr = &NmsRpcHeapFree;
        } else if (HeapHdl ==  WinsTmmHeapHdl)
        {
                  pHeapCntr = &NmsTmmHeapFree;
        } else
        {
            DBGPRINT1(HEAP, "WinsMscHeapFree: HeapHdl = (%p)\n", HeapHdl);
            pHeapCntr = &NmsCatchAllHeapFree;
        }
        EnterCriticalSection(&NmsHeapCrtSec);
        (*pHeapCntr)++;
        LeaveCriticalSection(&NmsHeapCrtSec);
    }
#endif
  return;

}



HANDLE
WinsMscHeapCreate(
        IN     DWORD         Options,
        IN     DWORD    InitSize
        )

/*++

Routine Description:
        This function creates a heap with the specified options


Arguments:
        Options -- Options for the HeapCreate function (Example: whether or
                   not to enable mutual exclusion)

        InitSize -- Initial Size of the heap (committed memory size)


Externals Used:
        None


Return Value:

   Success status codes --  Hdl to heap
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DWORD   Error;
        HANDLE  HeapHdl;

        HeapHdl = HeapCreate(
                                Options,
                                InitSize,
                                0        //limited only by available memory
                                     );


        if (HeapHdl == NULL)
        {
          Error = GetLastError();
          DBGPRINT0(HEAP, "Cant create heap\n");
          WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_HEAP);
          WINS_RAISE_EXC_M(WINS_EXC_HEAP_CREATE_ERR);
        }

#ifdef WINSDBG
    IF_DBG(HEAP_CNTRS)
    {
        DBGPRINT1(HEAP_CRDL, "HeapCreate: HeapHandle = (%p)\n", HeapHdl);
        EnterCriticalSection(&NmsHeapCrtSec);
        NmsHeapCreate++;
        LeaveCriticalSection(&NmsHeapCrtSec);
    }
#endif
        return(HeapHdl);

}

VOID
WinsMscHeapDestroy(
        HANDLE HeapHdl
        )

/*++

Routine Description:
        This is a wrapper for the HeapDestroy function

Arguments:
        HeapHdl - Handle to heap to destroy

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WrapUp() in nms.c

Side Effects:

Comments:
        None
--*/
{
        BOOL  fRetVal;
        fRetVal = HeapDestroy(HeapHdl);

        ASSERT(fRetVal);
#ifdef WINSDBG
    if (!fRetVal)
    {
        DBGPRINT1(ERR, "HeapDestroy: FAILED -- HeapHandle used = (%p)\n", HeapHdl);
    }
    else
    {
     IF_DBG(HEAP_CNTRS)
     {
        if (HeapHdl ==  CommUdpBuffHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Udp Buff heap\n");
        } else if (HeapHdl == CommAssocDlgHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Dlg Buff heap\n");
        } else if (HeapHdl == GenBuffHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Gen Buff heap\n");
        } else if (HeapHdl ==  QueBuffHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Que Buff heap\n");
        } else if (HeapHdl ==  NmsChlHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Chl Buff heap\n");
        } else if (HeapHdl ==  CommAssocAssocHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Assoc Buff heap\n");
        } else if (HeapHdl ==  RplWrkItmHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Rpl Work Item heap\n");
        } else if (HeapHdl ==  NmsRpcHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Rpc Work Item heap\n");
        } else if (HeapHdl ==  WinsTmmHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Tmm Work Item heap\n");
        } else
        {
              static DWORD sAdjust = 0;
              DBGPRINT0(HEAP_CRDL, "Catchall Work Item heap\n");
              EnterCriticalSection(&NmsHeapCrtSec);
              if (((NmsHeapCreate - NmsHeapDestroy) == 12) && (NmsCatchAllHeapAlloc > (NmsCatchAllHeapFree + sAdjust)))
              {
                   PWINSTHD_TLS_T  pTls;
                   pTls = TlsGetValue(WinsTlsIndex);
                   if (pTls == NULL)
                   {
                      DBGPRINT1(ERR, "WinsMscHeapDestroy: Could not get  TLS. GetLastError() = (%d)\n", GetLastError());
                   }
                   else
                   {
                      DBGPRINT4(ERR, "WinsMscHeapDestroy: %s thd noticed a mismatch between allocs (%d) and frees (%d). Free count was adjusted by (%d)\n", pTls->ThdName, NmsCatchAllHeapAlloc, NmsCatchAllHeapFree, sAdjust);
                      sAdjust = NmsCatchAllHeapAlloc - NmsCatchAllHeapFree;
                      //system("net send pradeepb MISMATCH");
                   }
              }
              LeaveCriticalSection(&NmsHeapCrtSec);
        }

        DBGPRINT1(HEAP_CRDL, "HeapDestroy: HeapHandle = (%p)\n", HeapHdl);
        EnterCriticalSection(&NmsHeapCrtSec);
        NmsHeapDestroy++;
        LeaveCriticalSection(&NmsHeapCrtSec);
     }
   }
#endif
        return;
} //WinsMscHeapDestroy


VOID
WinsMscTermThd(
   IN  STATUS ExitStatus,
   IN  DWORD  DbSessionExistent
        )

/*++

Routine Description:
        This function is called to terminate the thread.
        The function does the necessary cleanup and exit.

Arguments:
        ExitStatus            - Status to exit with
        DbSessionExistent - indicates whether DB session is existent

Externals Used:
        None


Return Value:
        Thread is exited

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DBGPRINT0(FLOW, "Enter: WinsMscTermThd\n");

        /*
        *  End the database session if it exists.  Decrement the count of
        *  threads.  If it reaches 1, signal the main thread so that it can
        *  terminate itself. At the end terminate yourself.
        *
        */

        //
        // I could enter the critical section after the if block but it is
        // not important.  This way, I get the prints in the right
        // order.
        //
        EnterCriticalSection(&NmsTermCrtSec);
        if (DbSessionExistent == WINS_DB_SESSION_EXISTS)
        {
try {
                if (ExitStatus == WINS_SUCCESS)
                {
                  DBGPRINT0(FLOW, "Ending the db session for thd -- ");
                }
                else
                {
                  DBGPRINT0(ERR, "Ending the db session for thd -- ");
                }
                DBGPRINTNAME;
                DBGPRINT0(FLOW,"\n");

                //for now, we don't check the return value
                NmsDbEndSession();
 }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsMscTermThd");
 }
        } // end of if block

        //
        // If the total thread count after decrementing is 1, it means
        // that after we exit from this thread, only the main thread
        // will be left.  Let us signal it to inform it of this situation.
        //
        // If the exit status is not success, it means that we have enetered
        // this function as a result of a fatal error/exception.  We need
        // to signal the main thread to kick off the process termination
        //
        if ((--NmsTotalTrmThdCnt == 1) || (ExitStatus != WINS_SUCCESS))
        {
            DBGPRINT1(FLOW, "Signaling the main thread. Exit status = (%x)\n",
                                ExitStatus);
            if (!SetEvent(NmsMainTermEvt))
            {
                WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_SIGNAL_MAIN_THD);

            }
        }

        //
        // If NmsTotalTrmThdCnt reached 1 above, then the main thread will
        // exit invalidating the NmsTermCrtSec.  We may get an INVALID_HANDLE
        // exception.  If we get it, it is ok.
        //
try {
        LeaveCriticalSection(&NmsTermCrtSec);
  }
except(EXCEPTION_EXECUTE_HANDLER) {
    if (GetExceptionCode() == STATUS_INVALID_HANDLE)
    {
        DBGPRINT1(FLOW, "WinsMscTermThd: LAST THREAD. NmsTotalTrmThdCnt = (%d)\n", NmsTotalTrmThdCnt);
    }
    else
    {
        WINS_RERAISE_EXC_M();
    }
   }


        DBGPRINT0(FLOW, "EXITING the thread\n");
        ExitThread(ExitStatus);

        return;
}


VOID
WinsMscSignalHdl(
        IN  HANDLE Hdl
)

/*++

Routine Description:
        This function is a wrapper for the WIN32 SignalEvent function

Arguments:
        Hdl  - Handle to signal

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

    if (!SetEvent(Hdl))
    {
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_SIGNAL_HDL);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }

    return;

}
VOID
WinsMscResetHdl(
        IN  HANDLE Hdl
)

/*++

Routine Description:
        This function is a wrapper for the WIN32 ResetEvent function

Arguments:
        Hdl  - Handle to signal

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        Change to a macro
--*/
{

    if (!ResetEvent(Hdl))
    {
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_RESET_HDL);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
    return;
}


VOID
WinsMscCloseHdl (
        HANDLE  Hdl
        )

/*++

Routine Description:
        This function is a wrapper for the WIN32 CloseHandle function

Arguments:
        Hdl  - Handle to  close


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        change to a macro
--*/

{

        BOOL fRet;

        fRet = CloseHandle(Hdl);
        if(!fRet)
        {
                DBGPRINT0(ERR, "WinsMscCloseHdl:Could not close handle\n");
                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
            }
            return;


}



HANDLE
WinsMscCreateThd(
        IN  LPTHREAD_START_ROUTINE      pThdInitFn,
        IN  LPVOID                        pParam,
        OUT LPDWORD                        pThdId
        )

/*++

Routine Description:
        This function is a wrapper around the WIN32 Create Thread function

Arguments:
        pThdInitFn        - Thread startup function
        pParam                 - Param to be passed to the startup function
        pThdId                - Thd Id


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        HANDLE ThdHdl;                //Thread handle
        DWORD  Error;

        /*
         * Create a thread with no sec attributes (i.e. it will take the
         * security attributes of the process), and default stack size
        */
        ThdHdl = CreateThread(
                                 NULL,                 /*no sec. attrbutes*/
                                 0,                   /*default stack size*/
                                   pThdInitFn,
                                 pParam,         /*arg*/
                                 0,                 /*run it now*/
                                 pThdId
                                );

        if (ThdHdl == NULL)
        {
          Error = GetLastError();

          DBGPRINT1(ERR, "WinsMscCreateThd: Can not create thread. Error = (%d)\n",
                                Error);
          WINSEVT_LOG_M( Error,  WINS_EVT_CANT_CREATE_THD);
          WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_RSRCS);
        }

        return(ThdHdl);
}

VOID
WinsMscSetThreadPriority(
        HANDLE        ThdHdl,
        int        PrLvl
        )

/*++

Routine Description:
        This function is a wrapper for the "set thread priority" function

Arguments:
        ThdHdl - Handle of thread whose priority needs to be set
        PrLvl  - New Prirority level

Externals Used:
        None

Return Value:

        None
Error Handling:


Called by:
        DoScavenging in nmsscv.c

Side Effects:

Comments:
        None
--*/

{
        BOOL        fRet;
        DWORD   Error;

        //
        // Set the priority
        //
        fRet = SetThreadPriority(
                          ThdHdl,
                          PrLvl
                         );
        if (!fRet)
        {
             Error = GetLastError();
             DBGPRINT1(ERR, "NmsScvInit: Could not lower the priority of the scavanmger thread. Error = (%d)\n", Error);
             WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_UNABLE_TO_CHG_PRIORITY);
             WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }
        return;
}



BOOL
WinsMscOpenFile(
        IN   LPTCH                pFileName,
        IN   DWORD                StrType,
        OUT  LPHANDLE                pFileHdl
        )

/*++

Routine Description:
        This is a wrapper for the WIN32 function to open an existing file

Arguments:
        pFileName   - Name of file
        StrType            - Indicates REG_EXPAND_SZ or REG_SZ
        pFileHdl    - handle to file if it could be opened

Externals Used:
        None


Return Value:

   Success status codes -- TRUE
   Error status codes   -- FALSE

Error Handling:

Called by:


Side Effects:

Comments:
        None
--*/

{
        DWORD                    Error;
        SECURITY_ATTRIBUTES SecAtt;
        TCHAR                    ExpandedFileName[WINS_MAX_FILENAME_SZ];
        LPTCH                    pHoldFileName;

        SecAtt.nLength              = sizeof(SecAtt);
        SecAtt.lpSecurityDescriptor = NULL;  //use default security descriptor
        SecAtt.bInheritHandle       = FALSE; //actually don't care


    if (!WinsMscGetName(StrType, pFileName, ExpandedFileName,
                 WINS_MAX_FILENAME_SZ, &pHoldFileName))
    {
            return(FALSE);
    }

        //
        // Open the file for reading and position self to start of the
        // file
        //
        *pFileHdl = CreateFile(
                        pHoldFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        &SecAtt,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0                        //ignored ?? check
                       );

        if (*pFileHdl == INVALID_HANDLE_VALUE)
        {
                WINSEVT_STRS_T        EvtStr;
                EvtStr.NoOfStrs = 1;
                EvtStr.pStr[0] = pHoldFileName;
                Error = GetLastError();

                DBGPRINT1(ERR, "WinsMscOpenFile: Could not open the  file (Error = %d)\n", Error);
FUTURES("Use WINSEVT_LOG_STR_M.  Make sure it takes TCHAR instead of CHAR")
                WINSEVT_LOG_STR_M(WINS_EVT_FILE_ERR, &EvtStr);

                return(FALSE);
        }
        return(TRUE);
 }


BOOL
WinsMscMapFile(
        IN OUT PWINSPRS_FILE_INFO_T   pFileInfo
        )

/*++

Routine Description:
        This function maps a file into allocated memory

Arguments:
        FileHdl    - Handle to the file
        pFileInfo  - Address of buffer into which the file was mapped

Externals Used:
        None


Return Value:

   Success status codes -- TRUE
   Error status codes   -- FALSE

Error Handling:

Called by:

Side Effects:

Comments:
        Note: The function returns an error if te file is more than
       2**32 bytes in size
--*/

{
        DWORD  HighWordOfFSz = 0;
        DWORD  Error;
        DWORD  cBytesRead;
        BOOL   fRetVal = FALSE;
try {
        //
        // get the size of the file so that we can allocate enough memory
        // to read the file in
        //
        pFileInfo->FileSize = GetFileSize(pFileInfo->FileHdl, &HighWordOfFSz);

        if (HighWordOfFSz)
        {
                DBGPRINT1(ERR, "WinsMscMapFile: File too big. High word of size is (%x)\n", HighWordOfFSz);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_FILE_TOO_BIG);
                fRetVal = FALSE;

        }
        else
        {
                //
                // if the low word of size is 0xFFFFFFFF either it is a valid
                // size or it is an error.  Check it
                //
                if (pFileInfo->FileSize == 0xFFFFFFFF)
                {
                        Error = GetLastError();
                        if (Error != NO_ERROR)
                        {
                                DBGPRINT1(ERR, "WinsMscMapFile: Error from GetFileSz = (%d)\n", Error);
                                WINSEVT_LOG_M(Error, WINS_EVT_FILE_ERR);
                                fRetVal = FALSE;
                        }
                }
                else
                {
                        //
                        // Allocate a buffer to hold the contents of the file
                        //
                        WinsMscAlloc(
                                        pFileInfo->FileSize,
                                        &pFileInfo->pFileBuff
                                    );
                        pFileInfo->pLimit = pFileInfo->pFileBuff +
                                                pFileInfo->FileSize;

                        fRetVal = ReadFile(
                                        pFileInfo->FileHdl,
                                        pFileInfo->pFileBuff,
                                        pFileInfo->FileSize,
                                        &cBytesRead,
                                        NULL
                                         );
                        if (!fRetVal)
                        {
                                DBGPRINT1(ERR,
        "WinsMscMapFile: Error reading file (Error = %d)\n", GetLastError());
                                WinsMscDealloc(pFileInfo->pFileBuff);
                        }

                }
        }
 }   // end of try ...
 except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsMscParse");
        }
        //
        // close the file
        //
        if (!CloseHandle(pFileInfo->FileHdl))
        {
                Error = GetLastError();
                DBGPRINT1(ERR, "WinsMscMapFile: Could not close the file (Error = %d)\n", Error);
        }
#ifdef WINSDBG
        else
        {
                DBGPRINT0(DET, "WinsMscMapFile: Closed handle to open file\n");
        }
#endif

   return(fRetVal);
}

VOID
WinsMscLogEvtStrs(
    LPBYTE          pAscii,
    DWORD           Evt,
    BOOL            fInfo
   )

{

        WINSEVT_STRS_T  EvtStrs;
        WCHAR String[NMSDB_MAX_NAM_LEN];
        EvtStrs.NoOfStrs = 1;
        (VOID)WinsMscConvertAsciiStringToUnicode(
                        pAscii,
                        (LPBYTE)String,
                        NMSDB_MAX_NAM_LEN);
         EvtStrs.pStr[0] = String;
         if (!fInfo)
         {
            WINSEVT_LOG_STR_M(Evt, &EvtStrs);
         }
         else
         {
            WINSEVT_LOG_INFO_STR_D_M(Evt, &EvtStrs);
         }

         return;
}

VOID
WinsMscConvertUnicodeStringToAscii(
        LPBYTE pUnicodeString,
        LPBYTE pAsciiString,
        DWORD  MaxSz
        )
{
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pUnicodeString, -1,
                                pAsciiString, MaxSz, NULL,
                                NULL);
        return;
}
VOID
WinsMscConvertAsciiStringToUnicode(
        LPBYTE pAsciiString,
        LPBYTE pUnicodeString,
        DWORD  MaxSz
        )
{
     MultiByteToWideChar(CP_ACP, 0, pAsciiString, -1,
                                              (LPWSTR)pUnicodeString, MaxSz);

        return;
}

BOOL
WinsMscGetName(
   DWORD    StrType,
   LPTSTR   pFileName,
   LPTSTR   pExpandedFileName,
   DWORD    ExpandedFileNameBuffLen,
   LPTSTR   *ppHoldFileName
  )
{
    DWORD ChInDest;

        if (StrType == REG_EXPAND_SZ)
        {
                ChInDest = ExpandEnvironmentStrings(
                                pFileName,
                                pExpandedFileName,
                                ExpandedFileNameBuffLen);

                if (ChInDest == 0)
                {
                        WINSEVT_STRS_T        EvtStr;
                        EvtStr.NoOfStrs = 1;
                        EvtStr.pStr[0] = pFileName;
                        DBGPRINT2(ERR, "WinsPrsDoStaticInit: Could not expand environment strings in (%s). Error is (%d)\n", pFileName, (DWORD)GetLastError());
                        WINSEVT_LOG_STR_M(WINS_EVT_FILE_ERR, &EvtStr);
                        return(FALSE);
                }
                //
                // If only part of the expanded name could be stored, log error
                //
                if (ChInDest > ExpandedFileNameBuffLen)
                {
                        WINSEVT_STRS_T        EvtStr;
                        EvtStr.NoOfStrs = 1;
                        EvtStr.pStr[0] = pFileName;
                        DBGPRINT2(ERR, "WinsPrsDoStaticInit: File name after expansion is just too big (%d> 255).\nThe name to be expanded is (%s))", ChInDest, pFileName);
                        WINSEVT_LOG_STR_M(WINS_EVT_FILE_NAME_TOO_BIG, &EvtStr);
                        return(FALSE);
                }
                *ppHoldFileName = pExpandedFileName;
        }
        else
        {
                //
                // There were no env. var. to expand
                //
                *ppHoldFileName = pFileName;
        }
    return(TRUE);
}


VOID
WinsMscSendControlToSc(
  DWORD ControlCode
)
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
  SERVICE_STATUS ServiceStatus;
  BOOL  fStatus;
  SC_HANDLE ScHdl;
  SC_HANDLE SvcHdl;
  BOOL  sCalled = FALSE;

try {
  ScHdl = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
  if (ScHdl == NULL)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from OpenSCManager\n", GetLastError());
    return;
  }

  SvcHdl = OpenService(ScHdl, WINS_SERVER, SERVICE_ALL_ACCESS);
  if (SvcHdl == NULL)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from OpenService\n", GetLastError());
    goto CLOSE_SC;
  }

  fStatus =  ControlService(SvcHdl, ControlCode, &ServiceStatus);
  if (!fStatus)
  {
    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from ControlService\n", GetLastError());
    goto CLOSE_SERVICE;
  }
  else
  {
    DBGPRINT1(FLOW, "WinsMscSendControlToSc: Current State is (%d)\n",
          ServiceStatus.dwCurrentState);

  }
CLOSE_SERVICE:
  fStatus = CloseServiceHandle(SvcHdl);
  if (!fStatus)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from CloseServiceHandle called for service\n", GetLastError());
  }

CLOSE_SC:
  fStatus = CloseServiceHandle(ScHdl);
  if (!fStatus)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from CloseServiceHandle called for SC\n", GetLastError());
  }
 }
 except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("WinsMscSendControlToSc");
 }
  return;
}

unsigned
WinsMscPutMsg(
  unsigned usMsgNum,
  ... )

/*++

Routine Description:
    Displays a message

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
    //unsigned msglen;
    //va_list arglist;
    //LPVOID  pMsg;
    //HINSTANCE hModule;

    DBGENTER("WinsMscPutMsg\n");

    //--ft: #106568 - WINS is a service and it shouldn't pop up message boxes.
    //--this is mostly annoying for cluster: in case the db. is corrupted WINS is popping the message wnd
    //--and does not terminate (at least the process wins.exe will be there for as long as the dialog is
    //--on the screen. This will prevent the cluster from bringing up WINS resource on the same node.
    //--In case of such a failure, the event being logged (in system log) should suffice.
    //
    //if ((hModule = LoadLibrary(TEXT("winsevnt.dll")))==NULL)
    //{
    //    DBGPRINT1(ERR, "WinsMscPutMsg: LoadLibrary(\"winsevnt.dll\") failed with error = (%d)\n.", GetLastError());
    //    return 0;
    //}
    //va_start(arglist, usMsgNum);
    //if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
    //      FORMAT_MESSAGE_FROM_HMODULE,
    //      hModule,
    //      usMsgNum,
    //      0L,       // Default country ID.
    //      (LPTSTR)&pMsg,
    //      0,
    //      &arglist)))
    //{
    //   DBGPRINT1(ERR, "WinsMscPutMsg: FormatMessage failed with error = (%d)\n",
    //        GetLastError());
    //}
    //else
    //{

    //  DBGPRINT0(DET, "WinsMscPutMsg: Putting up the message box\n");
    //  if(MessageBoxEx(NULL, pMsg, WINS_SERVER_FULL_NAME, MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONSTOP, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0)
    //  {
    //     DBGPRINT1(ERR, "WinsMscPutMsg: MessageBoxEx failed with error = (%d)\n", GetLastError());

    //  }
    //  LocalFree(pMsg);
    //}

    //FreeLibrary(hModule);

    WINSEVT_LOG_M(WINS_FAILURE, usMsgNum);
    DBGLEAVE("WinsMscPutMsg\n");

    //return(msglen);
    return 0;
}

LPTSTR
WinsMscGetString(
  DWORD StrId
  )

/*++

Routine Description:
    This routine retrieves string corresponding to strid from the resource file.

Arguments:

    StrId - The unique id of the string.

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
    unsigned msglen;
    va_list arglist;
    LPTSTR  pMsg = NULL;
    HINSTANCE hModule;

    DBGENTER("WinsMscPutMsg\n");

    if ((hModule = LoadLibrary(TEXT("winsevnt.dll"))) == NULL)
    {
        DBGPRINT1(ERR, "LoadLibrary(\"winsevnt.dll\") failed with error = (%d)\n",
            GetLastError());
        return NULL;
    }

    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_HMODULE,
          hModule,
          StrId,
          0L,       // Default country ID.
          (LPTSTR)&pMsg,
          0,
          NULL)))
    {
       DBGPRINT1(ERR, "WinsMscPutMsg: FormatMessage failed with error = (%d)\n",
            GetLastError());
    }

    FreeLibrary(hModule);
    DBGLEAVE("WinsMscPutMsg\n");

    return(pMsg);
}

VOID
WinsMscChkTermEvt(
#ifdef WINSDBG
               WINS_CLIENT_E  Client_e,
#endif
               BOOL            fTermTrans
 )

/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        Currently (8/6/94), fTermTrans is set only by the scavenger thread
--*/

{
     DWORD fSignaled;
        /*
         *  We may have been signaled by the main thread
         *  Check it.
         */
        WinsMscWaitTimed(
                             NmsTermEvt,
                             0,              //timeout is 0
                             &fSignaled
                        );

        if (fSignaled)
        {
                   DBGPRINT1(DET, "WinsCnfChkTermEvt: %s thread got termination signal\n", Client_e == WINS_E_RPLPULL ? "PULL" : "SCV");

                   if (fTermTrans)
                   {
                       NmsDbEndTransaction(); //ignore return code
                   }
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
        }

     return;
}

VOID
WinsMscDelFiles(
  BOOL   fMultiple,
  LPCTSTR pFilePattern,
  LPTSTR  pFilePath
 )
{
    DWORD ErrCode;
#ifdef WINSDBG
   BYTE  FileNameAscii[WINS_MAX_FILENAME_SZ];
#endif
   DBGENTER("WinsMscDelFiles\n");
   if (fMultiple)
   {
        WIN32_FIND_DATA FileInfo;
        HANDLE          SearchHandle;
        TCHAR           FullFilePath[WINS_MAX_FILENAME_SZ + MAX_PATH + 2];

        //
        // Construct the full file pattern
        //
        lstrcpy(FullFilePath, pFilePath);
        lstrcat(FullFilePath, L"\\");
        lstrcat(FullFilePath, pFilePattern);

        SearchHandle = FindFirstFile(FullFilePath, &FileInfo);
        if (SearchHandle == INVALID_HANDLE_VALUE)
        {
             DBGPRINT1(ERR, "WinsMscDelFiles: FindFirstFile returned error = (%d)\n", GetLastError());
             return;
        }

        do {
             //
             // construct the full file path
             //
             lstrcpy(FullFilePath, pFilePath);
             lstrcat(FullFilePath, L"\\");
             lstrcat(FullFilePath, FileInfo.cFileName);

#ifdef WINSDBG
             WinsMscConvertUnicodeStringToAscii((LPBYTE)FullFilePath, FileNameAscii, sizeof(FileNameAscii));
             DBGPRINT1(DET, "WinsMscDelFiles: Deleting %s ..\n", FileNameAscii);

#endif
             if (!DeleteFile(FullFilePath))
             {
               DBGPRINT1(ERR, "WinsMscDelFiles: DeleteFile returned error = (%d)\n", GetLastError());
                FindClose(SearchHandle);
                return;
             }

        } while(FindNextFile(SearchHandle, &FileInfo));
        if ((ErrCode = GetLastError()) != ERROR_NO_MORE_FILES)
        {
               DBGPRINT1(ERR, "WinsMscDelFiles: FindNextFile returned error = (%d)\n", ErrCode);

        }
        if (!FindClose(SearchHandle))
        {
               DBGPRINT1(ERR, "WinsMscDelFiles: FindClose returned error = (%d)\n", ErrCode);
        }

   }
   else
   {
             if (!DeleteFile(pFilePattern))
             {
               DBGPRINT1(ERR, "WinsMscDelFiles: DeleteFile returned error = (%d)\n", GetLastError());
                return;
             }
   }

   DBGLEAVE("WinsMscDelFiles\n");
   return;
}

VOID
WinsMscHeapReAlloc(
    IN   HANDLE   HeapHdl,
        IN   DWORD    BuffSize,
        OUT  LPVOID  *ppRspBuff
        )


/*++

Routine Description:
        This function is called to allocate memory.


Arguments:
        BuffSize  - Size of buffer to allocate
        ppRspBuff - Buffer allocated

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:

        NmsDbGetDataRecs, GetGroupMembers
Side Effects:

Comments:
        None
--*/

{

        *ppRspBuff = HeapReAlloc(
                   HeapHdl,
                   HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
                   *ppRspBuff,
                   BuffSize
                            );
   DBGPRINT3(HEAP, "WinsMscHeapReAlloc: HeapHdl = (%p), pStartBuff = (%p), BuffSize = (%d)\n", HeapHdl, *ppRspBuff, BuffSize);


        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winsprs.c ===
// NOTE:
//
// Unless the data read from the STATIC file is converted to UNICODE, we should
// not have UNICODE defined for this module
//
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	winsprs.c

Abstract:
    This source contains the functions that parse the lmhosts file.


Functions:
	GetTokens,
	IsKeyWord,
	Fgets,
	PrimeDb
	ExpandName,
	RegOrdinaryName,
	RegGrpName
	WinsPrsDoStaticInit
	

Portability:

	This module is portable


Author:

	Pradeep Bahl (PradeepB)  	Apr-1993

	Stole the parsing code from lm_parse.c, lm_io.c, and lm_parse.c in
	streams\tcpip\nbt; Modified it appropriately

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/

/*
 *       Includes
*/
#include <ctype.h>
#include <string.h>
#include "wins.h"
#include "nms.h"		//required for DBGPRINT statements
#include <winuser.h>
#include "winsevt.h"
#include "winsprs.h"
#include "winsmsc.h"
#include "nmsmsgf.h"
#include "nmsnmh.h"
#include "comm.h"
#include "winsintf.h"


/*
 *	Local Macro Declarations
*/


#define   DOMAIN_TOKEN 		"#DOM:"
#define   PRELOAD_TOKEN 	"#PRE"
#define   INCLUDE_TOKEN		"#INCLUDE"
#define   BEG_ALT_TOKEN		"#BEGIN_ALTERNATE"
#define   END_ALT_TOKEN		"#END_ALTERNATE"

#define   DOMAIN_TOKEN_SIZE 	(sizeof(DOMAIN_TOKEN) - 1)	

//
// To mark special groups in the lmhosts file
//
#define   SPEC_GRP_TOKEN 	"#SG:"
#define   SPEC_GRP_TOKEN_SIZE 	(sizeof(SPEC_GRP_TOKEN) - 1)	

//
// To indicate an mh node
//
#define   MH_TOKEN 	         "#MH"
#define   MH_TOKEN_SIZE          (sizeof(MH_TOKEN) - 1)	



#define  QUOTE_CHAR		'"'
#define  TAB_CHAR		'\t'
#define  SPACE_CHAR		' '
#define  CARRIAGE_RETURN_CHAR   '\r'
#define  NEWLINE_CHAR		'\n'
#define  COMMENT_CHAR		'#'
#define  BACKSLASH_CHAR		'\\'
#define  ZERO_CHAR      '0'
#define  x_CHAR         'x'
#define  X_CHAR			'X'

//
// Size of array to hold a non-coded netbios name read from a file (lmhosts)
//
#define NON_CODED_NAME_SIZE	17
/*
 *	Local Typedef Declarations
 */


//
// Private Definitions
//
typedef	struct _FILE_PARAM_T {
      		PWINSCNF_DATAFILE_INFO_T	pDataFile;
      		DWORD				NoOfFiles;
		} FILE_PARAM_T, *PFILE_PARAM_T;

//
// GetTokens() parses a line and returns the tokens in the following
// order:
//
typedef enum _TOKEN_ORDER_E {
    E_IPADDRESS = 0,                                      // first token
    E_NBNAME,                                             // 2nd token
    E_GROUPNAME,                                          // 3rd or 4th token
    E_NOTUSED,                                            // #PRE, if any
    E_MAX_TOKENS                                           // this must be last

} TOKEN_ORDER_E, *PTOKEN_ORDER_E;

//
// If the line category is E_SPEC_GRP, then we have just one token
//
#define SPEC_GRP_TOKEN_POS        0

//
// As each line in an lmhosts file is parsed, it is classified into one of
// the categories enumerated below.
//
// However, Preload is a special member of the enum (ignored by us).
//
//
typedef enum _TYPE_OF_LINE_E {

    E_COMMENT          = 0x0000,                         // comment line
    E_ORDINARY         = 0x0001,                         // ip_addr NetBIOS name
    E_DOMAIN           = 0x0002,                         // ... #DOM:name
    E_INCLUDE          = 0x0003,                         // #INCLUDE file
    E_BEGIN_ALTERNATE  = 0x0004,                         // #BEGIN_ALTERNATE
    E_END_ALTERNATE    = 0x0005,                         // #END_ALTERNATE
    E_SPEC_GRP         = 0x0006,                         // #Spec Grp
    E_SGWADD           = 0x0007,                         // #Spec Grp with add

    E_PRELOAD           = 0x8000,                         // ... #PRE
    E_MH                = 0x8001                        // ip_addr NetBIOS name
                                                         // for a mh machine
} TYPE_OF_LINE_E, *PTYPE_OF_LINE_E;


//
// In an lmhosts file, the following are recognized as keywords:
//
//     #BEGIN_ALTERNATE        #END_ALTERNATE          #PRE
//     #DOM:                   #INCLUDE
//
// Information about each keyword is kept in a KEYWORD structure.
//
//
typedef struct _KEYWORD_T {                           // reserved keyword
    LPBYTE           pKString;                         //  NULL terminated
    size_t          KStrlen;                          //  length of token
    TYPE_OF_LINE_E  KType_e;                          //  type of line
    DWORD           KNoOfOperands;                    //  max operands on line
} KEYWORD_T, *PKEYWORD_T;


//
// Information about the type of line read is kept in the LINE_CHARACTERISTICS
// structure
//
typedef struct _LINE_CHARACTERISTICS_T
{
    int     LineCategory:4;                               // enum _TYPE_OF_LINE
    int     LinePreload:1;                                // marked with #PRE ?
    int     Mh:1;                                         // marked with #MH ?
} LINE_CHARACTERISTICS_T, *PLINE_CHARACTERISTICS_T;

/*
 *	Global Variable Definitions
*/



/*
 *	Local Variable Definitions
 */


//
// In an lmhosts file, the token '#' in any column usually denotes that
// the rest of the line is to be ignored.  However, a '#' may also be the
// first character of a keyword.
//
// Keywords are divided into two groups:
//
//  1. decorations that must either be the 3rd or 4th token of a line,
//  2. directives that must begin in column 0,
//
//
KEYWORD_T Decoration[] = {
    DOMAIN_TOKEN,   sizeof(DOMAIN_TOKEN) - 1,   E_DOMAIN,   4,
    PRELOAD_TOKEN,  sizeof(PRELOAD_TOKEN) - 1,  E_PRELOAD,  4,
    SPEC_GRP_TOKEN, sizeof(SPEC_GRP_TOKEN) - 1, E_SGWADD,   4,
    MH_TOKEN,       sizeof(MH_TOKEN) - 1,       E_MH,       4,
    NULL,           0                                   // must be last
};


KEYWORD_T Directive[] = {
    INCLUDE_TOKEN,  sizeof(INCLUDE_TOKEN) - 1,  E_INCLUDE,         2,
    BEG_ALT_TOKEN,  sizeof(BEG_ALT_TOKEN) - 1,  E_BEGIN_ALTERNATE, 1,
    END_ALT_TOKEN,  sizeof(END_ALT_TOKEN) - 1,  E_END_ALTERNATE,   1,
    SPEC_GRP_TOKEN, sizeof(SPEC_GRP_TOKEN) - 1, E_SPEC_GRP, 1,
    NULL,           0                                   // must be last
};



/*
 *	Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */


//
// Local (Private) Functions
//
STATIC
BOOL
ChkAdd(
    LPBYTE pstrAdd,
    LPDWORD pAdd
        );
STATIC
LINE_CHARACTERISTICS_T
GetTokens (
    IN OUT LPBYTE    pLine,
    OUT    LPBYTE    *ppToken,
    IN OUT LPDWORD  pNumTokens
    );

STATIC
PKEYWORD_T
IsKeyWord (
    IN LPBYTE 	  pString,
    IN PKEYWORD_T pTable
    );

STATIC
LPBYTE
Fgets (
	PWINSPRS_FILE_INFO_T	pFileInfo,
	LPDWORD			pCount
    );


STATIC
VOID
PrimeDb (
	PWINSPRS_FILE_INFO_T	pFileInfo
    );

STATIC
BOOL
ExpandName (
    OUT LPBYTE 	  pDest,
    IN  LPBYTE 	  pSrc,
    IN  BYTE 	  LastCh,
    OUT  LPBOOL    pfQuoted
    );

STATIC
VOID
CheckForInt(
    IN OUT LPBYTE 	  pDest,
    IN  BOOL      fQuoted
);

STATIC
VOID
RegOrdinaryName(
	LPBYTE	pName,
	DWORD	IpAdd	
  );

VOID
RegGrpName(
	LPBYTE	pName,
	DWORD	IpAdd,
        DWORD   TypeOfRec
	);
STATIC
DWORD
DoStaticInitThdFn(
	IN LPVOID	pThdParam
	);

STATIC
LINE_CHARACTERISTICS_T
GetTokens (
    IN OUT LPBYTE   pLine,
    OUT    LPBYTE   *ppToken,
    IN OUT LPDWORD  pNumTokens
    )

/*++

Routine Description:

    This function parses a line for tokens.  A maximum of *pnumtokens
    are collected.

Arguments:

    pLine        -  pointer to the NULL terminated line to parse
    pToken       -  an array of pointers to tokens collected
    pNumTokens   -  on input, number of elements in the array, token[];
                    on output, number of tokens collected in token[]

Return Value:

    The characteristics of this lmhosts line.

Notes:

    1. Each token must be separated by white space.  Hence, the keyword
       "#PRE" in the following line won't be recognized:

            11.1.12.132     lothair#PRE

    2. Any ordinary line can be decorated with a "#PRE", a "#DOM:name" or
       both.  Hence, the following lines must all be recognized:

            111.21.112.3        kernel          #DOM:ntwins #PRE
            111.21.112.4        orville         #PRE        #DOM:ntdev
            111.21.112.7        cliffv4         #DOM:ntlan
            111.21.112.132      lothair         #PRE

--*/

{
    enum _PARSE_E
    {                                      // current fsm state
        E_START_OF_LINE,
        E_WHITESPACE,
        E_TOKEN
    } State_e;

    LPBYTE 		   pCh;                          // current fsm input
    //LPBYTE 		   pByte;                          // current fsm input
    PKEYWORD_T 		   pKeyword;
    DWORD 		   Index;
    DWORD		   MaxTokens;
    LINE_CHARACTERISTICS_T Retval;
    BOOL		   fQuoteSeen = FALSE;
    BOOL		   fBreakOut  = FALSE;

    //
    // Zero out the token array
    //
    RtlZeroMemory(ppToken, *pNumTokens * sizeof(LPBYTE *));

    State_e             = E_START_OF_LINE;
    Retval.LineCategory = E_ORDINARY;
    Retval.LinePreload  = 0;
    Retval.Mh           = 0;
    MaxTokens           = *pNumTokens;
    Index               = 0;

    for (pCh = pLine; *pCh != (BYTE)NULL  && !fBreakOut; pCh++)
    {
      switch ((int)*pCh)
      {
        //
        // does the '#' signify the start of a reserved keyword, or the
        // start of a comment ?
        //
        case COMMENT_CHAR:
            //
            // if a quote character has been seen earlier, skip this
	    // char
            //
	    if(fQuoteSeen)
	    {
		continue;
	    }	

	    //
	    // See if we have a keyword.  Use the appropriate table for the
	    // lookup
	    //
            pKeyword = IsKeyWord(
                            pCh,
                            (State_e == E_START_OF_LINE) ?
					Directive : Decoration
			       );

	    //
            // If it is a keyword
	    //
            if (pKeyword)
	    {
                State_e     = E_TOKEN;
                MaxTokens   = pKeyword->KNoOfOperands;

                switch (pKeyword->KType_e)
		{
                	case E_PRELOAD:
                    		Retval.LinePreload = 1;
                    		continue;

                	case E_MH:
                    		Retval.Mh = 1;
                    		continue;

			//
			// It is one of the other keywords
			//
                	default:
                    		ASSERT(Index     <  MaxTokens);

                    		ppToken[Index++]      = pCh;
                    		Retval.LineCategory  = pKeyword->KType_e;
                    		continue;
                }

                ASSERT(0);
            }

	    //
            // Since it is not a keyword, it is a comment
            //
            if (State_e == E_START_OF_LINE)
	    {
                Retval.LineCategory = E_COMMENT;
            }
            /* fall through */

        case CARRIAGE_RETURN_CHAR:
        case NEWLINE_CHAR:
            *pCh = (BYTE) NULL;
	    fBreakOut = TRUE;
            break; 			//break out of the loop. We are done

        case SPACE_CHAR:
        case TAB_CHAR:
	    //
	    // if State is Token, and there is no ending quote to worry about
	    // we change the state to WhiteSpace
	    //
            if (State_e == E_TOKEN)
	    {
		if (!fQuoteSeen)
		{
                	State_e = E_WHITESPACE;
                	*pCh  = (BYTE)NULL;

			//
			// If we have accumulated the desired number of tokens
			// break out of the loop
			//
                	if (Index == MaxTokens)
			{
				fBreakOut = TRUE;
                    		break;
                	}
		}
            }
            continue;

	case QUOTE_CHAR:

		//
		// Check whether we have seen the beginning quote char earlier
		//
		if(fQuoteSeen)
		{
			//
			// Ending quote consumed.  Set flag to FALSE
			//
			fQuoteSeen = FALSE;
		}
		else  // companion quote not seen earlier
		{
		        //
			// This could be the starting quote of the #DOM:
			// keyword's string or could be the starting
			// quote of the nbtname string
			//
			if (State_e == E_TOKEN)
			{
			   //
			   // It is the starting quote of the #DOM: keyword
			   // string
			   //
               // --ft: the statement above doesn't stand for legal LMHOSTS lines like:
               // #SG:"SGNoMember"
               // so I commented out the assert below:
			   //ASSERT(Index > E_NBNAME);
			}
			else
			{

			  //
			  // Must be the starting quote of the Nbt name
			  //
			  ASSERT(Index == E_NBNAME);

	    		  State_e = E_TOKEN;
	    		  //
	    		  // Store the pointer to the token
            		  //
            		  ppToken[Index++] = pCh;
			}
	    		fQuoteSeen = TRUE;
		}
		continue;

        default:

	    //
	    // If this is the token state, continue
	    //
            if (State_e == E_TOKEN) 	
	    {
                continue;
            }
            ASSERT(Index     <  MaxTokens);
	
	    State_e = E_TOKEN;
	    //
	    // Store the pointer to the token
            //
            ppToken[Index++] = pCh;
            continue;
      } // end of switch
    } // end of for loop


    *pNumTokens = Index;

    return(Retval);

} // GetTokens




STATIC
PKEYWORD_T
IsKeyWord (
    IN LPBYTE     pString,
    IN PKEYWORD_T pKTable
    )

/*++

Routine Description:

    This function determines whether the string is a reserved keyword.

Arguments:

    pString  -  the string to search
    pKTable   -  an array of keywords to look for

Return Value:

    A pointer to the relevant keyword object, or NULL if unsuccessful

--*/

{
    size_t     StringSize;
    PKEYWORD_T pSpecial;


    StringSize = strlen(pString);

    for (pSpecial = pKTable; pSpecial->pKString; pSpecial++) {

	//
	// If the length of the string is less than that of the keyword,
	// go on to the next keyword in the table
	//
        if (StringSize < pSpecial->KStrlen)
	{
            continue;
        }

	//
	// if length of string is greater than or equal to the keyword
	// length and the string matches the keyword in the # of characters
	// that comprise the keywordm, return the address of the keyword
	// structure
	//
FUTURES("use lstrncmp when it becomes available")
        if (
		(StringSize >= pSpecial->KStrlen)
			&&
                !strncmp(pString, pSpecial->pKString, pSpecial->KStrlen)
	   )
	{
                return(pSpecial);
        }
    }
    return((PKEYWORD_T) NULL);

} // IsKeyWord




VOID
PrimeDb (
	PWINSPRS_FILE_INFO_T	pFileInfo
    )
/*++

Routine Description:
	This function primes the WINS db

Arguments:


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
    LPBYTE 		    CurrLine;
    DWORD 		    Count;
    DWORD		    NWords;
    LPBYTE     	    	    ppToken[E_MAX_TOKENS];
    LINE_CHARACTERISTICS_T  CurrLineChar;
    DWORD                   Add;
    BOOL                    fBadAdd;
    DWORD                   TkSize;
    DWORD                   TypeOfRec;

try {

    //
    // Loop over all records
    //
    pFileInfo->pCurrPos = pFileInfo->pFileBuff;
    while (CurrLine = Fgets(pFileInfo, &Count) )
    {

        NWords        = E_MAX_TOKENS;

        fBadAdd       = FALSE;
        CurrLineChar  = GetTokens(CurrLine, ppToken, &NWords);
        switch (CurrLineChar.LineCategory)
	{

        	case E_SGWADD:
                        TypeOfRec = NMSDB_USER_SPEC_GRP_ENTRY;
                        TkSize     = SPEC_GRP_TOKEN_SIZE;

                            //fall through
        	case E_DOMAIN:

                        if (CurrLineChar.LineCategory == E_DOMAIN)
                        {
                          TypeOfRec = NMSDB_SPEC_GRP_ENTRY;
                          TkSize     = DOMAIN_TOKEN_SIZE;
                        }

		        //
			// If there are too few words in the line, go
			// get the next line
			//
            		if ((NWords - 1) < E_GROUPNAME)
			{
                		continue;
            		}

                        if (ChkAdd(ppToken[E_IPADDRESS], &Add))
                        {

	    		  //
            	          // Register the domain name (group name with 1C at
			  // the end)
            		  //
            		  RegGrpName(
                       		 ppToken[E_GROUPNAME] +  TkSize,
                        	 Add,
                                 TypeOfRec
                                 );
                        }
                        else
                        {
                                fBadAdd = TRUE;
                        }

	     		//
	     		// Fall through
	     		//

		case E_ORDINARY:

			//
			// If there are too few words in the line, go
			// get the next line
			//
			// Don't use (NWords - 1) < E_NBNAME since
			// NWords can be 0 in which case the test will
			// fail
			//

			if (NWords  < (E_NBNAME + 1))
			{
                		continue;
            		}
			else
			{
                            if (!fBadAdd && ChkAdd(ppToken[E_IPADDRESS], &Add))
                            {
                                if (CurrLineChar.Mh)
                                {
            		          RegGrpName(
                       		       ppToken[E_NBNAME],
                        	       Add,
                                       NMSDB_MULTIHOMED_ENTRY
                                          );
                                }
                                else
                                {
		   		  //
		   		  // register the name
		   		  //
		   		  RegOrdinaryName( ppToken[E_NBNAME], Add);
                                }
                            }
                            else
                            {
                                WinsMscLogEvtStrs(
                                                ppToken[E_NBNAME],
                                                WINS_EVT_BAD_ADDRESS,
                                                FALSE
                                                 );
                                DBGPRINT2(ERR, "PrimeDb: Name (%s) has bad address = (%s). It is being ignored\n", ppToken[E_NBNAME], ppToken[E_IPADDRESS]);
                            }
			}
            		continue;
	
                case E_SPEC_GRP:
	    		//
            	        // Register the domain name (group name with 1C at
			// the end)
            		//
            		RegGrpName(
                       		 ppToken[SPEC_GRP_TOKEN_POS] + SPEC_GRP_TOKEN_SIZE,
                        	 0,
                                 NMSDB_USER_SPEC_GRP_ENTRY);
                        continue;


        	case E_INCLUDE:			// fall through
        	case E_BEGIN_ALTERNATE:		// fall through
        	case E_END_ALTERNATE:		// fall through
			continue;
        	default:
            		continue;
        }
    }
}  // end of try block
finally {

	//
	// deallocate the memory to which the file was mapped
	//
  	WinsMscDealloc(pFileInfo->pFileBuff);
 }
    return;

} // PrimeDb



LPBYTE
Fgets (
    IN PWINSPRS_FILE_INFO_T 	pFileInfo,
    OUT LPDWORD 	    	pNoOfCh
    )

/*++

Routine Description:

    This function is vaguely similar to fgets(3).

    Starting at the current seek position, it reads through a newline
    character, or the end of the file. If a newline is encountered, it
    is replaced with a NULL character.

Arguments:

    pfile   -  file to read from
    nbytes  -  the number of characters read, excluding the NULL character

Return Value:

    A pointer to the beginning of the line, or NULL if we are at or past
    the end of the file.

--*/

{
    LPBYTE pEndOfLine;
    LPBYTE pStartOfLine;
    SIZE_T MaxCh;

    //
    // Store the current position  in the memory buffer
    //
    pStartOfLine = (LPBYTE)pFileInfo->pCurrPos;

    //
    // If it is greater or equal than the limit, return NULL
    //
    if (pStartOfLine >= (LPBYTE)pFileInfo->pLimit) {

        return(NULL);
    }

    //
    // Store the max. number of bytes between the current position and
    // the end of the buffer.
    //
    MaxCh  = (pFileInfo->pLimit - pFileInfo->pCurrPos);

    //
    // get to the end of the line
    //
    pEndOfLine = (LPBYTE)memchr(pStartOfLine, NEWLINE_CHAR, (size_t)MaxCh);

    if (!pEndOfLine)
    {

	DBGPRINT0(FLOW, "Data file does not end in newline\n");
        return(NULL);
    }

    *pEndOfLine = (BYTE)NULL;

    pFileInfo->pCurrPos = pEndOfLine + 1;	//adjust the pointer

    ASSERT(pFileInfo->pCurrPos <= pFileInfo->pLimit);

    *pNoOfCh = (DWORD) (pEndOfLine - pStartOfLine);
    return(pStartOfLine);

} // Fgets


VOID
RegOrdinaryName(
	IN LPBYTE	pName,
	IN DWORD	IPAdd	
  )

/*++

Routine Description:
	This function registers a unique name

Arguments:
	
	pName - Name to register
	IPAdd - Address to register

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	BYTE		Dest[WINS_MAX_LINE_SZ];	
	BOOL		fQuoted;
	COMM_ADD_T	NodeAdd;
        LPBYTE      pDest = Dest;

	NodeAdd.AddLen    = sizeof(COMM_IP_ADD_T);
	NodeAdd.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
	NodeAdd.Add.IPAdd = IPAdd;
	
	//
	// Form the name.  If the name is < 16 characters, 0x20 will
	// be put in the Sixteenth bytes
	//
	if (!ExpandName(Dest, pName, 0x20, &fQuoted))
        {
                DBGPRINT1(ERR, "Name (%s) has more than 16 characters\n", pName);
                return;
        }

	NMSMSGF_MODIFY_NAME_IF_REQD_M(Dest);	
	
	NmsNmhNamRegInd(
			 NULL,
			 Dest,
			 strlen(Dest) + 1,  //we always store the terminating
					     //NULL
			 &NodeAdd,
			 NMSMSGF_E_BNODE,	
			 NULL,
			 0,
			 0,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
		       );
	//
	// If the name was not quoted, register the other two records
	// (same name -- different suffixes)
	//
	if(!fQuoted)
	{
#if 0
                if (*pDest == 0x1B)
                {
                   WINS_SWAP_BYTES_M(pDest, pDest + 15);
                }
#endif
		Dest[NON_CODED_NAME_SIZE - 2] = 0x3;
		NmsNmhNamRegInd(
			 NULL,
			 Dest,
			 strlen(Dest) + 1, //we always store the terminating
					    //NULL
			 &NodeAdd,
			 NMSMSGF_E_BNODE,	
			 NULL,
			 0,
			 0,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
		       );

		Dest[NON_CODED_NAME_SIZE - 2] = 0x0;
		NmsNmhNamRegInd(
			 NULL,
			 Dest,
			 strlen(Dest) + 2,  //add 1 since terminating 0x0 is
					     //to be stored (will be taken
					     //as NULL by strlen
			 &NodeAdd,
			 NMSMSGF_E_BNODE,	
			 NULL,
			 0,
			 0,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
		       );
	}	
	return;
}

VOID
RegGrpName(
	IN  LPBYTE	pName,
	IN  DWORD	IPAdd,
        IN  DWORD       TypeOfRec
	)

/*++

Routine Description:

	This function registers a domain name

Arguments:
	pName - Name to register
	IpAdd - Address to register

Externals Used:
	None

	
Return Value:

	None
Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

	BYTE	    Dest[WINS_MAX_LINE_SZ];	
	BOOL	    fQuoted;
	NMSMSGF_CNT_ADD_T  CntAdd;
        DWORD       RecType;
        BYTE        SixteenthByte;

        if (*pName == EOS)
        {
            WinsMscLogEvtStrs(pName, WINS_EVT_NAME_FMT_ERR, FALSE);
            return;
        }

        //
        // don't want 0 ip address to be put in
        //
        if (IPAdd)
        {
	  CntAdd.NoOfAdds		= 1;
	  CntAdd.Add[0].AddLen    = sizeof(COMM_IP_ADD_T);
	  CntAdd.Add[0].AddTyp_e  = COMM_ADD_E_TCPUDPIP;
	  CntAdd.Add[0].Add.IPAdd	= IPAdd;
        }
        else
        {
	  CntAdd.NoOfAdds		= 0;
        }

        if (TypeOfRec != NMSDB_SPEC_GRP_ENTRY)
        {
          SixteenthByte = 0x20;
        }
        else
        {
          SixteenthByte = 0x1C;
        }

        //
        // We can get called for domains, user. spec. grps and mh names.
        //
        RecType = (TypeOfRec == NMSDB_USER_SPEC_GRP_ENTRY) ?
                                       NMSDB_SPEC_GRP_ENTRY : TypeOfRec;
	//
	// If the name length is < 16 characters, 0x20 or 0x1C will be put in
	// the Sixteenth byte
	//
	if (!ExpandName(Dest, pName, SixteenthByte, &fQuoted))
        {
            return;
        }

        if (RecType == NMSDB_MULTIHOMED_ENTRY)
        {
          //
          // switch the 1st and Sixteenth bytes if the Sixteenth byte is a 0x1B.  This
          // is done only for non-group names
          //
	  NMSMSGF_MODIFY_NAME_IF_REQD_M(Dest);	
        }

	//
	// register the group
	//
	NmsNmhNamRegGrp(
			 NULL,
			 Dest,
			 strlen(Dest) + 1,  // to store the null
			 &CntAdd,
			 0,		     //Node type (not used)
			 NULL,
			 0,
			 0,
			 RecType,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
			);

        if (RecType == NMSDB_MULTIHOMED_ENTRY)
        {
	  //
	  // If the name was not quoted, register the other two records
	  // (same name -- different suffixes)
	  //
	  if(!fQuoted)
	  {
		Dest[NON_CODED_NAME_SIZE - 2] = 0x3;
	        NmsNmhNamRegGrp(
			 NULL,
			 Dest,
			 strlen(Dest) + 1,  // to store the null
			 &CntAdd,
			 0,		     //Node type (not used)
			 NULL,
			 0,
			 0,
			 RecType,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
			);

		Dest[NON_CODED_NAME_SIZE - 2] = 0x0;
	        NmsNmhNamRegGrp(
			 NULL,
			 Dest,
			 strlen(Dest) + 2,  // to store the null
			 &CntAdd,
			 0,		     //Node type (not used)
			 NULL,
			 0,
			 0,
			 RecType,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
			);
	  }	
        }
	return;		
}



BOOL
ExpandName (
    OUT LPBYTE 	  pDest,
    IN  LPBYTE 	  pSrc,
    IN  BYTE 	  LastCh,
    OUT  LPBOOL    pfQuoted
    )

/*++

Routine Description:

    This function expands an lmhosts entry into a full 16 byte NetBIOS
    name.  It is padded with blanks up to 15 bytes; the Sixteenth byte is the
    input parameter, last.


    Both dest and source are NULL terminated strings.

Arguments:

    pDest            -  sizeof(dest) must be WINSPRS_NONCODED_NMSZ
    pSrc             -  the lmhosts entry
    LastCh           -  the Sixteenth byte of the NetBIOS name
    pfQuoted         -  flag to indicate whether the string was quoted or not

Return Value:
	None
--*/


{
    BYTE    Ch;
    DWORD   i = 0;
    LPBYTE  pFrom = pSrc;
    LPBYTE  pTo   = pDest;

    // Detect if it is quoted name..
    *pfQuoted = (*pFrom == QUOTE_CHAR);
    // ..and skip the initial quote char
    pFrom += *pfQuoted;

    // count for as many chars as are in a legal NetBios name (15) plus
    // the terminating char. (NON_CODED_NAME_SIZE is #defined to be 17)
    for (i = 0; i < NON_CODED_NAME_SIZE - 1; i++)
    {
        // get the next char from the name
        Ch = *(pFrom++);

        // check if it is a terminating char
        if (!Ch || (*pfQuoted ? Ch == QUOTE_CHAR : Ch == NEWLINE_CHAR))
            break;

        // check if the name doesn't exceed the legal 15 chars
        if (i == NON_CODED_NAME_SIZE - 2)
        {
            // We have picked up 15 characters already and there are more in the name
            // This is illegal so log error and bail out
            DBGPRINT1(ERR, "Name (%s) has more than 16 characters\n", pSrc);
            WinsMscLogEvtStrs(pSrc, WINS_EVT_BAD_NAME, FALSE);
            return FALSE;
        }

        // If the char is a leading DBCS byte then accept the extended char as it
        // is (take the trailing byte and go on.
        if (IsDBCSLeadByteEx(CP_ACP, Ch))
        {
            *pTo++ = Ch;
            *pTo++ = *pFrom++;
            continue;
        }

        // If the name is not quoted, map lower case alpha chars to upper case.
        // Note: don't use _toupper since _toupper does not check whether its
        // argument is indeed a lowercase char.
        if (!*pfQuoted && IsCharAlpha(Ch))
        {
            if(IsCharLower(Ch))
	        {
		        LPBYTE pCh;
    		    BYTE   sCh[2];
		        sCh[0] = Ch;
		        sCh[1] = (BYTE)NULL;
		        
		        pCh = (LPBYTE)CharUpperA(sCh);
		        Ch  = *pCh;
	        }
        }

        // Check if we have hex value in the name
        if (Ch == BACKSLASH_CHAR)
        {
            DWORD NoOfChar;
            INT   NumValue = 0;
            CHAR  Ch2;
            BOOL  fFailed = FALSE;

            // the hex value can be either \A3 or \xFC (obviously with any kind of hex digits)
            Ch = *pFrom;
            Ch2 = *(pFrom+1);

            if (Ch == BACKSLASH_CHAR)
            {
                // '\\' should be seen as one '\', hence keep Ch as it is and break from switch
                pFrom++;
            }
            else
            {
                if ((Ch == X_CHAR || Ch == x_CHAR) || 
                     (Ch == ZERO_CHAR && (Ch2 == X_CHAR || Ch2 == x_CHAR))
                    )
                {
                    DBGPRINT1(TMP, "Parsing hex num %s\n", pFrom);
                    // skip over x or 0x.
                    pFrom += (Ch == X_CHAR || Ch == x_CHAR) ? 1 : 2;
                    // we do have a hex number here. Pick up at most the first two digits.
                    fFailed = (sscanf(pFrom, "%2x%n", &NumValue, &NoOfChar) == 0 || NoOfChar == 0);

                    DBGPRINT2(TMP, "fFailed=%d; HexNumValue=0x%x\n", fFailed, NumValue);
                }
                else
                {
                    DBGPRINT1(TMP, "Parsing dec num %s\n", pFrom);
                    // it might be a decimal number. Pick up at most the first 3 digits.
                    fFailed = (sscanf(pFrom, "%3u%n", &NumValue, &NoOfChar) == 0 || NoOfChar == 0 || NumValue > 255);

                    DBGPRINT2(TMP, "fFailed=%d; DecNumValue=%u\n", fFailed, NumValue);
                }

                if (fFailed)
                {
                    // log an event and bail out with error.
                    DBGPRINT1(ERR, "Name (%s) contains incorrectly formed character code.\n", pSrc);
                    WinsMscLogEvtStrs(pSrc, WINS_EVT_BAD_CHARCODING, FALSE);
                    return FALSE;
                }

                // everything went fine, copy the hex value back to Ch
                Ch = (BYTE)NumValue;
                // and make sure to advance on the pFrom string
                pFrom += NoOfChar;
            }
        }

        // finally copy the char to the destination string
	    *pTo = Ch;
        // advance with the pointer on the destination string
        pTo++;
    } //end of for loop

    // if there were less than expected char, form the valid netbios name
    // by padding it with spaces
    for (;i < NON_CODED_NAME_SIZE - 2; i++, pTo++)
        *pTo = SPACE_CHAR;

    *pTo =      (BYTE)NULL;
    *(pTo+1) =  (BYTE)NULL;
    CheckForInt(pDest, *pfQuoted);

    // at the end, append the LastCh (16th byte) to the name.
    *pTo = LastCh;

    return(TRUE);
} // ExpandName

VOID
CheckForInt(
 LPBYTE pDest,
 BOOL   fQuoted
 )

/*++

Routine Description:
  This function munges the name so that if there are any characters
  from a different code set, they are converted properly

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
   WCHAR            UnicodeBuf[255];
   UNICODE_STRING   UnicodeStr;
   STRING           TmpStr;
   NTSTATUS        NTStatus;

   DBGENTER("CheckForInt\n");
    //
    // Now, convert to UNICODE then to OEM to force the ANSI -> OEM munge.
    // Then convert back to UNICODE and uppercase the name. Finally convert
    // back to OEM.
    //
    UnicodeStr.Length        = 0;
    UnicodeStr.MaximumLength = sizeof(UnicodeBuf);
    UnicodeStr.Buffer        = UnicodeBuf;

    RtlInitString(&TmpStr, pDest);

    NTStatus = RtlAnsiStringToUnicodeString(&UnicodeStr, &TmpStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:  Ansi -> Unicode failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }

    NTStatus = RtlUnicodeStringToOemString(&TmpStr, &UnicodeStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:   Unicode -> Oem failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }

    NTStatus = RtlOemStringToUnicodeString(&UnicodeStr, &TmpStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:    Oem -> Unicode failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }


    if (!fQuoted)
        NTStatus = RtlUpcaseUnicodeStringToOemString(&TmpStr, &UnicodeStr, FALSE);
    else
        NTStatus = RtlUnicodeStringToOemString(&TmpStr, &UnicodeStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:    Unicode -> Oem failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }
ERROR_PROC:
    DBGLEAVE("CheckForInt\n");
    return;
}

STATUS
WinsPrsDoStaticInit(
      IN PWINSCNF_DATAFILE_INFO_T	pDataFile,
      IN DWORD				NoOfFiles,
      IN BOOL                           fAsync
	)

/*++

Routine Description:
	This function is called to do the STATIC initialization of the WINS
	db

Arguments:
	pDataFiles - Pointer to buffer containing one or more data file	
		     structures (PWINSCNF_DATAFILE_INFO_T)

Externals Used:
	None

	
Return Value:

	None
Error Handling:

Called by:
	Init()
Side Effects:

Comments:
	None
--*/

{
	DWORD ThdId;
	PFILE_PARAM_T  pFileParam;
        STATUS  RetStat = WINS_SUCCESS;
        HANDLE  sThdHdl = NULL;
		
try {
	WinsMscAlloc(sizeof(FILE_PARAM_T), &pFileParam);
	pFileParam->pDataFile = pDataFile;
	pFileParam->NoOfFiles = NoOfFiles;
        if (fAsync)
        {
	       sThdHdl =
                     WinsMscCreateThd(DoStaticInitThdFn, pFileParam, &ThdId);
               //
               // We don't need the handle, so let us close it
               //
               CloseHandle(sThdHdl);
        }
        else
        {
	       RetStat = DoStaticInitThdFn(pFileParam);
        }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("WinsPrsDoStaticInit");
	WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_STATIC_INIT_ERR);
	}
	return(RetStat);
}	

DWORD
DoStaticInitThdFn(
	IN LPVOID	pThdParam
	)

/*++

Routine Description:
	This thread reads one or more files to do STATIC initialization

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	WINSPRS_FILE_INFO_T	FileInfo;
	DWORD 		i;
        PWINSCNF_DATAFILE_INFO_T	pDataFile =
				(((PFILE_PARAM_T)pThdParam)->pDataFile);
        DWORD				NoOfFiles =
				(((PFILE_PARAM_T)pThdParam)->NoOfFiles);
	LPVOID		pSvDataFilePtr = pDataFile;
        DWORD       RetStat = WINS_SUCCESS;

	//
	// initialize this thread with the db engine
	//
	// This is not an RPC thread.  It could have been created either by
	// the main thread (doing an init/reinit) or by an rpc thread. For
	// either case, we do not want the counter NmsTermThdCnt to be
	// incremented in NmsDbThdInit(). Instead of passing a client
	// var to indicate which thread invoked it, we call it an RPC
	// thread to have NmsDbThdInit do the right thing.  NmsDbOpenTables
	// will also do the right thing.
	//
  	NmsDbThdInit(WINS_E_WINSRPC);
	NmsDbOpenTables(WINS_E_WINSRPC);

	EnterCriticalSection(&WinsIntfCrtSec);
	WinsIntfNoCncrntStaticInits++;
	LeaveCriticalSection(&WinsIntfCrtSec);
try {

	for (
		i = 0;
		i < NoOfFiles;
		i++, pDataFile = (PWINSCNF_DATAFILE_INFO_T)((LPBYTE)pDataFile +
				  WINSCNF_FILE_INFO_SZ)
	    )
	{
		//
		// Open the file
		//
		if (
			!WinsMscOpenFile(
				pDataFile->FileNm,
				pDataFile->StrType,
				&FileInfo.FileHdl
				    )
		   )
		{
			WINSEVT_STRS_T	EvtStrs;
#ifndef UNICODE
			DBGPRINT1(ERR, "WinsPrsDoStaticInit: Could not open file= (%s)\n", pDataFile->FileNm);
#else		


#ifdef WINSDBG
			IF_DBG(ERR)
			{
				wprintf(L"WinsPrsDoStatisInit: Could not open file = (%s)\n", pDataFile->FileNm);
			}				
#endif
#endif
			EvtStrs.NoOfStrs = 1;
			EvtStrs.pStr[0]  = pDataFile->FileNm;
			WINSEVT_LOG_STR_M(WINS_EVT_CANT_OPEN_DATAFILE, &EvtStrs);
            RetStat = WINS_FAILURE;
			continue;	
		}

#ifndef UNICODE
		DBGPRINT1(DET, "WinsPrsDoStaticInit: Opened file (%s) for doing STATIC initialization\n", pDataFile->FileNm);
#else
#ifdef WINSDBG
		IF_DBG(ERR)
		{
			wprintf(L"WinsPrsDoStatisInit: Opened file (%s) for doing STATIC initialization\n", pDataFile->FileNm);
		}
#endif
#endif
		//
		// Map the file into allocated memory
		//
		if(!WinsMscMapFile(&FileInfo))
		{
			continue;	
		}
	
		//
		// prime the db
		//
		PrimeDb(&FileInfo);

	} // end of for loop
 } // end of try ..
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("DoStaticInitThdFn");
	WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_STATIC_INIT_ERR);
	}

	EnterCriticalSection(&WinsIntfCrtSec);
	WinsIntfNoCncrntStaticInits--;
	LeaveCriticalSection(&WinsIntfCrtSec);

  	//
  	// Let us end the session
  	//
try {
	NmsDbCloseTables();
  	NmsDbEndSession();
}
except (EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("DoStaticInit: During wrap up");
  }

	//
	// Deallocate the memory
	//
	ASSERT(pSvDataFilePtr != NULL);
	WinsMscDealloc(pSvDataFilePtr);
	//
	// Be sure to deallocate the thread param
	//
	WinsMscDealloc(pThdParam);

//	ExitThread(WINS_SUCCESS);
	return(RetStat);	//to shutup compiler warning
}

BOOL
ChkAdd(
    LPBYTE pstrAdd,
    LPDWORD pAdd
        )

/*++

Routine Description:
        This function converts a dotted decimel ip address to
        a DWORD.  We don't use inet_addr() to do this, since it
        returns 0xFFFFFFFF for an address that has one of its
        parts > 255 and returns some value for an invalid address
        (for example, one with 3 dots)

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

        BYTE    Tmp[WINS_MAX_LINE_SZ];
        DWORD   Word[4];
        LPBYTE  pPos;
        DWORD   Count = 0;
        BOOL    fInvalid = FALSE;

        //
        // We must see three dots
        //
        while(Count < 4)
        {
                if ((pPos = strchr(pstrAdd, (int)'.')) != NULL)
                {

                     do
                     {
                        //
                        // Copy all chars before the dot
                        //
                        (void)RtlCopyMemory(Tmp, pstrAdd, pPos - pstrAdd);

                        //
                        // Put a NULL at the end
                        //
                        Tmp[pPos - pstrAdd] = EOS;
                        Word[Count] = (DWORD)atol(Tmp);

                        //
                        //atol returns 0 if it can not convert
                        //but 0 can be a valid return too (if we have '0' to
                        // connvert
                        //
                        if (Word[Count] == 0)
                        {
                                if (Tmp[0] != '0')
                                {
                                        fInvalid = TRUE;
                                        break;
                                }
                        }
                        else
                        {
                           if (Word[Count] > 255)
                           {
                                fInvalid = TRUE;
                                break;
                           }
                        }
                        Count++;
                        pstrAdd = ++pPos;
                    } while ((Count == 3) && (pPos = pstrAdd + strlen(pstrAdd)));
                    if (fInvalid)
                    {
                        break;
                    }
                }
                else
                {
                        //
                        // less than 3 dots seen, break out of the loop
                        //
                        break;
                }
        } // end of while (Count < 4)
        if ((Count < 4) || fInvalid)
        {
                return(FALSE);
        }
        else
        {
                *pAdd = (LONG)((Word[0] << 24) + (Word[1] << 16) +
                                (Word[2] << 8) + Word[3]);
        }
        return(TRUE);
}


#if 0
VOID
GetFullPath(
    IN LPBYTE  pTarget,
    OUT LPBYTE pPath
    )

/*++

Routine Description:

    This function returns the full path of the STATIC  file.  This is done
    by forming a unicode string from the concatenation of the C strings
    DatabasePath and the string, file.

    You must RtlFreeUnicodeString(path) after calling this function
    successfully !

Arguments:

    target    -  the name of the file.  This can either be a full path name
                 or a mere file name.
    path    -  a pointer to a UNICODE_STRING structure

Return Value:

    STATUS_SUCCESS if successful.

Notes:

    RtlMoveMemory() handles overlapped copies; RtlCopyMemory() doesn't.

--*/

{
    NTSTATUS status;
    ULONG unicodesize;
    STRING directory, file, prefix, remote;

    RtlInitString(&prefix, "\\DosDevices");
    RtlInitString(&remote, "\\DosDevices\\UNC");

    //
    // if the target begins with a '\', or contains a DOS drive letter,
    // then assume that it specifies a full path.  Otherwise, prepend the
    // default directory, DatabasePath, to create a full path.
    //
    //
    if ((*target == '\\') || (target[1] == ':')) {

        RtlInitString(&directory, target);
        RtlInitString(&file, NULL);
    }
    else {
        RtlInitString(&directory, DatabasePath);
        RtlInitString(&file, target);
    }

    ASSERT(RtlAnsiStringToUnicodeSize(&prefix) <=
                                    RtlAnsiStringToUnicodeSize(&remote));

    unicodesize = RtlAnsiStringToUnicodeSize(&remote) +
                    RtlAnsiStringToUnicodeSize(&directory) +
                    RtlAnsiStringToUnicodeSize(&file) +
                    2 * sizeof(OBJ_NAME_PATH_SEPARATOR) +
                    sizeof(UNICODE_NULL);

    path->Length        = 0;
    path->MaximumLength = (USHORT) unicodesize;
    path->Buffer        = ExAllocatePool(NonPagedPool, unicodesize);

    if (!path->Buffer) {
        return(STATUS_NO_MEMORY);
    }

    //
    // does the directory specify a DOS drive ?
    //
    // If the second character of directory is a colon, then it must specify
    // a DOS drive.  If so, it must be prefixed with "\\DosDevices".
    //
    //
    if (directory.Buffer[1] == ':') {
        status = LmpConcatenate(path, &prefix);

        if (status != STATUS_SUCCESS) {
            path->MaximumLength = 0;
            ExFreePool(path->Buffer);
            return(status);
        }
    }


    //
    // does the directory specify a remote file ?
    //
    // If so, it must be prefixed with "\\DosDevices\\UNC", and the double
    // slashes of the UNC name eliminated.
    //
    //
    if ((directory.Buffer[0] == '\\') && (directory.Buffer[1] == '\\')) {
        status = LmpConcatenate(path, &remote);

        if (status != STATUS_SUCCESS) {
            path->MaximumLength = 0;
            ExFreePool(path->Buffer);
            return(status);
        }

        directory.Length--;

        ASSERT(((ULONG) directory.Length - 1) > 0);

        RtlMoveMemory(                                  // overlapped copy
                    &(directory.Buffer[1]),             // Destination
                    &(directory.Buffer[2]),             // Source
                    (ULONG) directory.Length - 1);      // Length
    }


    //
    // is the first part of the directory "%SystemRoot%" ?
    //
    // If so, it must be changed to "\\SystemRoot\\".
    //
    //          0123456789 123456789 1
    //          %SystemRoot%\somewhere
    //
    //
    if (strncmp(directory.Buffer, "%SystemRoot%", 12) == 0) {

        directory.Buffer[0]  = '\\';
        directory.Buffer[11] = '\\';

        if (directory.Buffer[12] == '\\') {
            ASSERT(directory.Length >= 13);

            if (directory.Length > 13) {
                RtlMoveMemory(                          // overlapped copy
                        &(directory.Buffer[12]),        // Destination
                        &(directory.Buffer[13]),        // Source
                        (ULONG) directory.Length - 13); // Length

                directory.Buffer[directory.Length - 1] = (CHAR) NULL;
            }

            directory.Length--;
        }
    }

    status = LmpConcatenate(path, &directory);

    if (status != STATUS_SUCCESS) {
        path->MaximumLength = 0;
        ExFreePool(path->Buffer);
        return(status);
    }

    if (!(file.Length)) {
        return(status);
    }

    status = LmpConcatenate(path, &file);

    if (status != STATUS_SUCCESS) {
        path->MaximumLength = 0;
        ExFreePool(path->Buffer);
        return(status);
    }

    return(STATUS_SUCCESS);

} // LmGetFullPath
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winsevt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:



Abstract:

 	This module provides error logging routines needed for the entire
 	WINS.  See header file winsevt.h for the
 	macros which use the functions in this module.

Functions:


Portability:

       The current implementation of the module is not portable.

Author:

	Pradeep Bahl (PradeepB)  	Dec-1992

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/


#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include "wins.h"
#ifdef DBGSVC
#include "nms.h"
#endif
#include "winsevt.h"
#include "winscnf.h"
#include "winsmsc.h"




/*
 *	Local Macro Declarations
 */
#if 0

/*
 *  get_month_m:
 *
 *  This macro converts a numerical month (0-11) to a month string
 *  abbreviation.
 *
 *  NOTE:  This macro must *NOT* be called with an expression as an argument.
 *         If this is done, then you will get the expression
 *         evaluated 11 times
 *	   (probably not desired).
 */

#define get_month_m(month_int)		\
       (((month_int) == 0)  ? "JAN" :	\
	((month_int) == 1)  ? "FEB" :	\
	((month_int) == 2)  ? "MAR" :	\
	((month_int) == 3)  ? "APR" :	\
	((month_int) == 4)  ? "MAY" :	\
	((month_int) == 5)  ? "JUN" :	\
	((month_int) == 6)  ? "JUL" :	\
	((month_int) == 7)  ? "AUG" :	\
	((month_int) == 8)  ? "SEP" :	\
	((month_int) == 9)  ? "OCT" :	\
	((month_int) == 10) ? "NOV" : "DEC" \
	)
#endif

/*
 *	Local Typedef Declarations
 */



/*
 *	Global Variable Definitions
 */



/*
 *	Local Variable Definitions
 */



/*
 *	Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */


/*
 *  Function Name:
 *	extern WinsEvtLogEvt
 *
 *  Function Description:
 *      This is funtion that logs all errors from the WINS process.  It should
 *	only be "called" using the WINSEVT_ macros, except within
 *	this module.
 *
 *  Arguments:
 *	IN  StatusCode		- integer containing the status code of the
 *				  error to be printed.
 *
 *  Return value:
 *	None.
 *
 *  Error Handling:
 *	None.
 *
 *  Extern Variables used:
 *	None.
 *
 *  Side Effects:
 *	None.
 *
 *  Comments:
 *	Make sure that printf is thread-renetrant.
 *
 */
VOID
WinsEvtLogEvt
	(
	LONG 		BinaryData,
	WORD  	        EvtTyp,
	DWORD		EvtId,
	LPTSTR		pFileStr,
	DWORD 		LineNumber,
	PWINSEVT_STRS_T	pStr
	)
{
	BOOL  fRet = TRUE;
	DWORD Error;
	DWORD NoOfBytes;
	WORD	BinData[4];
	
	BinData[0] = (WORD)(LineNumber & 0xFFFF);
	BinData[1] = (WORD)(LineNumber >> 16);
	BinData[2] = (WORD)(BinaryData & 0xFFFF); //lower word first
	BinData[3] = (WORD)(BinaryData >> 16);	  //then higher word
				
try {

	NoOfBytes = sizeof(BinData);	


	fRet = ReportEvent(
		    WinsCnf.LogHdl,
		    (WORD)EvtTyp,
		    (WORD)0,			//category zero
		    EvtId,
		    NULL,		//no user SID
		    (WORD)(pStr != NULL ? pStr->NoOfStrs : 0),//no of strings
		    NoOfBytes,		//no of bytes in binary data
		    pStr != NULL ? (LPCTSTR *)(pStr->pStr) : (LPCTSTR *)NULL,//address of string arr
		    BinData		//address of data
		   );
	if (!fRet)
	{
		Error = GetLastError();
		DBGPRINT1(
			ERR,
			"WinsEvtLogEvt: ReportEvent returned error = (%d)",
			Error
			 );

	}
	
 }
except(EXCEPTION_EXECUTE_HANDLER) {

	DBGPRINT1(EXC, "WinsEvtLogEvt: Report Event generated the exception (%x).  Check if you have the right access. You should have power user access on this machine\n", GetExceptionCode());
	
	}

	return;
}


VOID
WinsEvtLogDetEvt(
     BOOL       fInfo,
     DWORD      EvtId,
     LPTSTR     pFileName,
     DWORD 	LineNumber,
     LPSTR      pFormat,
     ...
        )

{
        LPBYTE pFmt = pFormat;
        DWORD  NoOfStr = 0;
        DWORD  NoOfW = 0;
        DWORD  Data[30];
        LPWSTR ppwStr[10];
        WCHAR  wStr[10][80];
        BOOL   fRet = TRUE;
        DWORD  Error;
        DWORD  ArrIndex = 0;

        va_list ap;

        if (!WinsCnf.LogDetailedEvts)
            return;

        DBGENTER("WinsEvtLogDetEvt\n");

try {

        va_start(ap, pFormat);
        Data[NoOfW++] = LineNumber;
        if (pFileName != (LPTSTR)NULL)
        {
                ppwStr[NoOfStr++] = pFileName;
        }
        for (; *pFmt; pFmt++)
        {
               switch(*pFmt)
               {
                case('d'):
                        Data[NoOfW++] = (DWORD)va_arg(ap, long);
                        break;

                case('s'):
                        WinsMscConvertAsciiStringToUnicode(
                                               va_arg(ap, char *),
                                               (LPBYTE)wStr[ArrIndex], 80);
                        ppwStr[NoOfStr++] = wStr[ArrIndex++];

                        break;

                case('u'):
                        ppwStr[NoOfStr++] = va_arg(ap, short *);
                        break;

                default:
                        break;
               }
        }
        ppwStr[NoOfStr] = (LPWSTR)NULL;
	fRet = ReportEvent(
		    WinsCnf.LogHdl,
		    (WORD)(fInfo ? EVENTLOG_INFORMATION_TYPE : EVENTLOG_ERROR_TYPE),
		    (WORD)0,			//category zero
		    EvtId,
		    NULL,		//no user SID
		    (WORD)NoOfStr,       //no of strings
		    NoOfW * sizeof(DWORD),	  //no of bytes in binary data
		    NoOfStr != 0 ? (LPCTSTR *)ppwStr : (LPCTSTR *)NULL,//address of string arr
		    Data		//address of data
		   );
	if (!fRet)
	{
		Error = GetLastError();
		DBGPRINT1(
			ERR,
			"WinsEvtLogDetEvt: ReportEvent returned error = (%d)",
			Error
			 );

	}
    va_end(ap);
} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {

	DBGPRINT1(EXC, "WinsLogDetEvt: Report Event generated the exception (%x).  Check if you have the right access. You should have power user access on this machine\n", GetExceptionCode());
	
	}

        DBGLEAVE("WinsEvtLogDetEvt\n");
        return;
}

VOID
WinsLogAdminEvent(
    IN      DWORD               EventId,
    IN      DWORD               StrArgs,
    IN      ...
    )
/*++

Routine Description:

    This routine is called to log admin triggerd events.

Arguments:

    EventId - The id of the event to be logged.

    StrArgs - No of additional args.

Return Value:

    None

Comments:
    This routine must be called fromt he RPC API processing code only.
        None
--*/
{
    RPC_STATUS              RpcStatus;
    TCHAR                   UserNameBuf[MAX_PATH+1];
    DWORD                   Size;
    WINSEVT_STRS_T          EvtStr;
    va_list                 ap;
    DWORD                   i;

    // first impersonate the client.
    RpcStatus = RpcImpersonateClient( NULL );
    if (RPC_S_OK != RpcStatus) {
        DBGPRINT1(ERR, "WinsLogAdminEvent: Could not impersonate client (Error = %ld)\n", RpcStatus);
        return;
    }
    if (!GetUserName(UserNameBuf,&Size)) {
        DBGPRINT1(ERR, "WinsLogAdminEvent: Could not get user name (Error = %ld)\n", GetLastError());
        goto Cleanup;
    }
    EvtStr.NoOfStrs = 1;
    EvtStr.pStr[0] = UserNameBuf;
    ASSERT( StrArgs < MAX_NO_STRINGS );

    va_start(ap,StrArgs);
    for(i=1;i<= StrArgs && i<= MAX_NO_STRINGS; i++) {
        EvtStr.pStr[i] = va_arg(ap, LPTSTR);
        EvtStr.NoOfStrs++;
    }
    va_end(ap);

    WINSEVT_LOG_INFO_STR_M(EventId, &EvtStr);

Cleanup:
    RpcStatus = RpcRevertToSelf();
    if (RPC_S_OK != RpcStatus) {
        ASSERT( FALSE );
    }
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winsque.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Contains functions for queuing and dequeuing  to/from the various
    work queues


Functions:
        QueInsertNbtWrkItm
        QueRemoveNbtWrkItm
        QueInsertChlReqWrkItm
        QueRemoveChlReqWrkItm
        QueInsertChlRspWrkItm
        QueRemoveChlRspWrkItm
        QueInsertWrkItm
        QueGetWrkItm
        QueAllocWrkItm
        QueDeallocWrkItm
        QueInsertWrkItmAtHdOfList

Portability:

        This module is portable
Author:

    Pradeep Bahl (pradeepb)        18-Nov-1992


Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include "comm.h"
//#include "winsque.h"
#include "nms.h"
#include "nmsdb.h"
#include "nmschl.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "rplpush.h"
#include "rplmsgf.h"
#include "winsque.h"

/*
 *        Local Macro Declarations
 */


/*
 *        Local Typedef Declarations
*/



/*
 *        Global Variable Definitions
 */
//
// The various queue heads
//
QUE_HD_T  QueNbtWrkQueHd;  //head for nbt req queue

#if REG_N_QUERY_SEP > 0
QUE_HD_T  QueOtherNbtWrkQueHd;  //head for nbt req queue
#endif
DWORD     QueOtherNbtWrkQueMaxLen;

QUE_HD_T  QueRplPullQueHd; //head for rpl pull thread's queue
QUE_HD_T  QueRplPushQueHd; //head for rpl push thread's queue
QUE_HD_T  QueNmsNrcqQueHd; //head for challenge queue used by NBT
QUE_HD_T  QueNmsRrcqQueHd; //head for challenge queue used by Replicator
QUE_HD_T  QueNmsCrqQueHd;  //head for response queue to challenges sent
QUE_HD_T  QueWinsTmmQueHd; //head for timer manager's queue
QUE_HD_T  QueWinsScvQueHd; //head for Scavenger's queue
QUE_HD_T  QueInvalidQueHd; //head for an invalid queue


HANDLE                  QueBuffHeapHdl;  //handle to heap for use for nbt queue items
/*
 *        Local Variable Definitions
*/
/*
        pWinsQueQueHd

        Array indexed by the enumerator QUE_TYP_E values.  This array
        maps the QUE_TYP_E to the address of the queue head

*/
PQUE_HD_T        pWinsQueQueHd[QUE_E_TOTAL_NO_QS] = {
                                &QueNbtWrkQueHd,    //nbt requests
#if REG_N_QUERY_SEP > 0
                                &QueOtherNbtWrkQueHd,    //nbt requests
#endif
                                &QueRplPullQueHd,   //Pull requests
                                &QueRplPushQueHd,   //Push requests
                                &QueNmsNrcqQueHd,   //Chl request from nbt thds
                                &QueNmsRrcqQueHd,   //Chl req. from Pull thd
                                &QueNmsCrqQueHd,    //Chl rsp from UDP thd
                                &QueWinsTmmQueHd,   //timer queue
                                &QueWinsScvQueHd,   //Scavenger queue
                                &QueInvalidQueHd
                                };

STATIC  fsChlWaitForRsp = FALSE;

CHECK("The timer queue may not be a PLIST_ENTRY queue.  We may not")
CHECK("just insert the work item at the end")

/*
 *        Local Function Prototype Declarations
*/

STATIC
BOOL
ChlRspDropped(
        MSG_T   pMsg
        );



//
// Function definitions start here
//

STATUS
QueInsertNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        )

/*++

Routine Description:
        This function inserts a work item on the nbt request queue


Arguments:
        pDlgHdl - Handle to dialogue under which the nbt request was received
        pMsg    - Nbt work item
        MsgLen  - Size of work item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        QueNbtReq in nms.c

Side Effects:

Comments:
        None
--*/


{


     PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
     STATUS                   RetStat;

     QueAllocWrkItm(
                        QueBuffHeapHdl,
                        sizeof(NBT_REQ_WRK_ITM_T),
                        (LPVOID *)&pNbtWrkItm
                       );

     pNbtWrkItm->DlgHdl = *pDlgHdl;
     pNbtWrkItm->pMsg   = pMsg;
     pNbtWrkItm->MsgLen = MsgLen;

     RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pNbtWrkItm,
                        QUE_E_NBT_REQ,
                        NULL                         /*ptr to que head*/
                               );

     return(RetStat);
}



STATUS
QueRemoveNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T     ppMsg,
        OUT PMSG_LEN_T pMsgLen
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        pDlgHdl - Handle to dialogue of nbt request dequeued
        pMsg    - Nbt work item
        MsgLen  - Size of work item


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NbtThdInitFn() in nms.c

Side Effects:

Comments:
        None
--*/

{

  PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
  STATUS                    RetStat;

  RetStat = QueGetWrkItm(QUE_E_NBT_REQ, &pNbtWrkItm);

  if (RetStat != WINS_SUCCESS)
  {
        *ppMsg = NULL;
  }
  else
  {

          *ppMsg      = pNbtWrkItm->pMsg;
          *pMsgLen    = pNbtWrkItm->MsgLen;
        *pDlgHdl    = pNbtWrkItm->DlgHdl;


          QueDeallocWrkItm( QueBuffHeapHdl,  pNbtWrkItm );
  }

  return(RetStat);

}
#if REG_N_QUERY_SEP > 0
STATUS
QueInsertOtherNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        )

/*++

Routine Description:
        This function inserts a work item on the nbt request queue


Arguments:
        pDlgHdl - Handle to dialogue under which the nbt request was received
        pMsg    - Nbt work item
        MsgLen  - Size of work item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        QueNbtReq in nms.c

Side Effects:

Comments:
        None
--*/


{


     PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
     STATUS                   RetStat;
     static BOOL              SpoofingStarted = FALSE;

     QueAllocWrkItm(
                        QueBuffHeapHdl,
                        sizeof(NBT_REQ_WRK_ITM_T),
                        (LPVOID *)&pNbtWrkItm
                       );

     pNbtWrkItm->DlgHdl = *pDlgHdl;
     pNbtWrkItm->pMsg   = pMsg;
     pNbtWrkItm->MsgLen = MsgLen;

     RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pNbtWrkItm,
                        QUE_E_OTHER_NBT_REQ,
                        NULL                         /*ptr to que head*/
                               );
     //
     // If the queue is full, the request was not inserted, so
     // drop it. Log an event after every 100 requests have
     // been dropped
     //
     if (RetStat == WINS_QUEUE_FULL)
     {
        static DWORD    sNoOfReqSpoofed = 0;
        static DWORD    sBlockOfReq = 1;

#if DBG
        static DWORD sNoOfReqDropped = 0;
#endif
        if (!WinsCnf.fDoSpoofing)
        {
#if DBG
          NmsRegReqQDropped++;
          if (sNoOfReqDropped++ == 5000)
          {
             sNoOfReqDropped = 0;
             DBGPRINT1(ERR, "ENmsHandleMsg: REG QUEUE FULL. REQUESTS DROPPED = (%d\n", NmsRegReqQDropped);
          }

#endif
         //
         // NOTE : freeing the buffers here takes away from modularity aspects
         // of code but saves us cycles on the critical path
         //
         ECommFreeBuff(pMsg);
         ECommEndDlg(pDlgHdl);
       }
       else
       {

        //
        // we respond to groups of 300
        // refresh/reg requests with a refresh interval of a multiple of
        // 5 mts.  The multiple is based on the group #.  The refresh interval
        // is not allowed to go over 1-2 hrs .
        //
        if (sNoOfReqSpoofed > 100)
        {
              if (sBlockOfReq == 10)
              {
                     sBlockOfReq = 1;
              }
              else
              {
                     sBlockOfReq++;
              }
              sNoOfReqSpoofed = 0;
        }
        else
        {
              sNoOfReqSpoofed++;
        }

        if (!SpoofingStarted) 
        {
            WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_SPOOFING_STARTED);
            SpoofingStarted = TRUE;
        }
        DBGPRINT1(DET, "QueInsertOtherNbtWrkItm: Spoofing - SpoofBlockNum %d\n", sBlockOfReq);
        NmsMsgfSndNamRsp(pDlgHdl, pMsg, MsgLen, sBlockOfReq);
       }
       QueDeallocWrkItm( QueBuffHeapHdl,  pNbtWrkItm );
    }

    if ((WINS_SUCCESS == RetStat) && SpoofingStarted &&  QueOtherNbtWrkQueHd.NoOfEntries < (QueOtherNbtWrkQueMaxLen >> 2)) 
    {
        WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_SPOOFING_COMPLETED);
        SpoofingStarted = FALSE;

    }
    return(RetStat);
}



STATUS
QueRemoveOtherNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T     ppMsg,
        OUT PMSG_LEN_T pMsgLen
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        pDlgHdl - Handle to dialogue of nbt request dequeued
        pMsg    - Nbt work item
        MsgLen  - Size of work item


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NbtThdInitFn() in nms.c

Side Effects:

Comments:
        None
--*/

{

  PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
  STATUS                    RetStat;

  RetStat = QueGetWrkItm(QUE_E_OTHER_NBT_REQ, &pNbtWrkItm);

  if (RetStat != WINS_SUCCESS)
  {
        *ppMsg = NULL;
  }
  else
  {

          *ppMsg      = pNbtWrkItm->pMsg;
          *pMsgLen    = pNbtWrkItm->MsgLen;
        *pDlgHdl    = pNbtWrkItm->DlgHdl;


          QueDeallocWrkItm( QueBuffHeapHdl,  pNbtWrkItm );
  }

  return(RetStat);

}
#endif

STATUS
QueInsertChlReqWrkItm(
        IN NMSCHL_CMD_TYP_E    CmdTyp_e,
        IN WINS_CLIENT_E       Client_e,
        IN PCOMM_HDL_T         pDlgHdl,
        IN MSG_T               pMsg,
        IN MSG_LEN_T           MsgLen,
        IN DWORD               QuesNamSecLen,
        IN PNMSDB_ROW_INFO_T   pNodeToReg,
        IN PNMSDB_STAT_INFO_T  pNodeInCnf,
        //IN PCOMM_ADD_T         pAddOfNodeInCnf,
        IN PCOMM_ADD_T               pAddOfRemWins
        )

/*++

Routine Description:
        This function inserts a work item on the nbt request queue

Arguments:
        pDlgHdl - Handle to dialogue under which the nbt request was received
        pMsg    - Nbt work item
        MsgLen  - Size of work item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        NmsChlHdlNamReg

Side Effects:

Comments:
        None
--*/


{


     PCHL_REQ_WRK_ITM_T  pWrkItm = NULL;
     STATUS                   RetStat = WINS_SUCCESS;
     DWORD                 Error   = 0;
     BOOL                 fLvCrtSec = FALSE;
     DWORD                 i;

     QueAllocWrkItm(
                        NmsChlHeapHdl,
                        sizeof(CHL_REQ_WRK_ITM_T),
                        (LPVOID *)&pWrkItm
                       );

     pWrkItm->CmdTyp_e       = CmdTyp_e;
     pWrkItm->Client_e       = Client_e;
     if (pDlgHdl != NULL)
     {
             pWrkItm->DlgHdl      = *pDlgHdl;
     }
     pWrkItm->pMsg           = pMsg;
     pWrkItm->MsgLen         = MsgLen;
     pWrkItm->QuesNamSecLen  = QuesNamSecLen;
     pWrkItm->NodeToReg      = *pNodeToReg;

     pWrkItm->NodeAddsInCnf.NoOfMems = pNodeInCnf->NodeAdds.NoOfMems;
     for (i=0; i < pNodeInCnf->NodeAdds.NoOfMems; i++)
     {
         pWrkItm->NodeAddsInCnf.Mem[i] = pNodeInCnf->NodeAdds.Mem[i];
     }
     pWrkItm->NoOfAddsToUse   = pNodeInCnf->NodeAdds.NoOfMems;
     pWrkItm->NoOfAddsToUseSv = pNodeInCnf->NodeAdds.NoOfMems;

     pWrkItm->OwnerIdInCnf  = pNodeInCnf->OwnerId;
     pWrkItm->fGroupInCnf   = NMSDB_ENTRY_GRP_M(pNodeInCnf->EntTyp);

    // pWrkItm->NodeTypInCnf  = pNodeInCnf->NodeTyp;
    // pWrkItm->EntTypInCnf   = pNodeInCnf->EntTyp;


     if (pNodeToReg->pNodeAdd != NULL)
     {
        pWrkItm->AddToReg =  *(pNodeToReg->pNodeAdd);
     }
     if (pAddOfRemWins != NULL)
     {
             pWrkItm->AddOfRemWins   = *pAddOfRemWins;
     }

     switch(Client_e)
     {
        case(WINS_E_NMSNMH):
                        pWrkItm->QueTyp_e = QUE_E_NMSNRCQ;
                        break;

        case(WINS_E_RPLPULL):
                        pWrkItm->QueTyp_e = QUE_E_NMSRRCQ;
                        break;

        default:
                        DBGPRINT0(ERR, "QueInsertChlWrkItm: Invalid Client\n");
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        break;

     }

     RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pWrkItm,
                        pWrkItm->QueTyp_e,
                        NULL /*ptr to que head*/
                               );

     return(RetStat);
}



STATUS
QueRemoveChlReqWrkItm(
        IN         HANDLE                EvtHdl,
        IN OUT         LPVOID                *ppaWrkItm,
        OUT        LPDWORD                pNoOfReqs
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        EvtHdl     - handle of event signaled (not used currently)
        ppaWrkItm  - pointer to array  of pointers (to work items) to
                     initialize
        pNoOfReqs  - No of Requests acquired (in the array pointed by
                     the ppaWrkItm arg


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ChlThdInitFn() in nmschl.c

Side Effects:

Comments:
        None
--*/

{

          STATUS                    RetStat    = WINS_SUCCESS;
          PQUE_HD_T             pQueHd;

        UNREFERENCED_PARAMETER(EvtHdl);
        *pNoOfReqs = 0;

        //
        // EvtHdl is the handle of the event signaled.  We don't use
        // it since we always need to check the queues in the sequence
        // Nrcq, Rrcq, Srcq irrespective of the event that got signaled.
        //
        // EvtHdl is passed as an input argument for future extensibility

        //
        // We could have had one critical section for both the queues but that
        // could slow NBT threads due to replication. We don't
        // want that.
        //


        //
        // First check the NBT Request challenge queue
        //
        pQueHd        = &QueNmsNrcqQueHd;
        EnterCriticalSection(&pQueHd->CrtSec);
try {

        //
        // We have a limit to the number of nodes
        // we will challenge at any one time
        //
          while (
                (!IsListEmpty(&pQueHd->Head)) &&
                (*pNoOfReqs < NMSCHL_MAX_CHL_REQ_AT_ONE_TIME)
             )
          {
                  *ppaWrkItm++    = RemoveHeadList(&pQueHd->Head);
                (*pNoOfReqs)++;
          }
}
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
 }
        //
        // if we have reached the limit return
        //
        if (*pNoOfReqs == NMSCHL_MAX_CHL_REQ_AT_ONE_TIME)
        {
        DBGPRINT0(CHL, "QueRemoveChlReqWrkItm: Limit reached with just nbt requests\n");
                *ppaWrkItm = NULL;   //delimiter to the list
                return(WINS_SUCCESS);
        }

        //
        // Now check the Replicator request challenge queue (populated
        // by the Pull handler
        //
        pQueHd = &QueNmsRrcqQueHd;
        EnterCriticalSection(&pQueHd->CrtSec);
try {
          while(
                (!IsListEmpty(&pQueHd->Head))  &&
                (*pNoOfReqs < NMSCHL_MAX_CHL_REQ_AT_ONE_TIME)
             )
          {
                  *ppaWrkItm++    = RemoveHeadList(&pQueHd->Head);
                (*pNoOfReqs)++;
          }
}
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
 }

        if (*pNoOfReqs == 0)
        {
                RetStat = WINS_NO_REQ;
        }
        else
        {
                *ppaWrkItm = NULL;   //delimiter to the list
        }

          return(RetStat);
}




STATUS
QueInsertChlRspWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        )

/*++

Routine Description:
        This function inserts a work item on the challenge response queue


Arguments:

        pDlgHdl - Handle to dialogue under which the nbt response was received
        pMsg    - response message
        MsgLen  - response msg length

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ENmsHdlMsg in nms.c

Side Effects:

Comments:
        None
--*/


{


     PCHL_REQ_WRK_ITM_T  pWrkItm = NULL;
     STATUS                RetStat = WINS_SUCCESS;
     DWORD                      Error   = 0;

     if (!ChlRspDropped(pMsg))
     {
       QueAllocWrkItm(
                        NmsChlHeapHdl,
                        sizeof(CHL_RSP_WRK_ITM_T),
                        (LPVOID *)&pWrkItm
                       );

       pWrkItm->DlgHdl = *pDlgHdl;
       pWrkItm->pMsg   = pMsg;
       pWrkItm->MsgLen = MsgLen;

       RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pWrkItm,
                        QUE_E_NMSCRQ,
                        NULL /*ptr to que head*/
                               );

     }
     return(RetStat);
}

STATUS
QueRemoveChlRspWrkItm(
        IN LPVOID                *ppWrkItm
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        ppaWrkItm  - address of an array of pointers to chl request work items

Externals Used:
        None

Return Value:

   Success status codes --   WINS_SUCCESS
   Error status codes   --   WINS_FAILURE

Error Handling:

Called by:
        ChlThdInitFn() in nmschl.c

Side Effects:

Comments:
        None
--*/

{

  STATUS                    RetStat;
  RetStat = QueGetWrkItm(QUE_E_NMSCRQ, ppWrkItm);
  return(RetStat);
}


STATUS
QueInsertWrkItm (
        IN               PLIST_ENTRY        pWrkItm,
        IN  OPTIONAL QUE_TYP_E                QueTyp_e,
        IN  OPTIONAL PQUE_HD_T                pQueHdPassed
        )

/*++

Routine Description:
        This function is called to queue a work item on
        a queue.  If the pQueHdPassed is Non NULL, the work item is queued
        on that queue, else, it is queued on the queue specified by
        QueTyp_e.

        TMM will use pQueHdPassed to specify the queue while other clients
        of the queue services will specify QueTyp_e

Arguments:
        pWrkItm      - Work Item to queue
        QueTyp_e     - Type of queue to queue it on (may or may not have valid                                       value)
        pQueHdPassed - Head of queue (may or may not be passed)

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue, QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
//        DWORD                Error;

        if (pQueHdPassed == NULL)
        {

                pQueHd = pWinsQueQueHd[QueTyp_e];
        }
        else
        {
                pQueHd = pQueHdPassed;
        }

        EnterCriticalSection(&pQueHd->CrtSec);
try {

        //
        // If we are surpassing the limit in the Reg/Ref/Rel queue,
        // don't insert the wrk. item.
        //
        if ((pQueHd == &QueOtherNbtWrkQueHd) &&
            (pQueHd->NoOfEntries > QueOtherNbtWrkQueMaxLen))
        {
               RetStat = WINS_QUEUE_FULL;
        }
        else
        {
          InsertTailList(&pQueHd->Head, pWrkItm);
          pQueHd->NoOfEntries++;
          if (!SetEvent(pQueHd->EvtHdl))
          {
//              Error   = GetLastError();
                RetStat = WINS_FAILURE;
          }
        }
  }
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
}

        return(RetStat);

}

STATUS
QueGetWrkItm (
        IN  QUE_TYP_E                QueTyp_e,
        OUT LPVOID                *ppWrkItm
        )

/*++

Routine Description:
        This function is called to dequeue a work item from
        a queue

Arguments:

        QueTyp_e  - Type of queue to get the wrk item from
        ppWrkItm  - Work Item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS or WINS_NO_REQ
   Error status codes   --  None at present

Error Handling:

Called by:
        RplPullInit, QueNbtRemoveWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T       pQueHd;

        pQueHd         = pWinsQueQueHd[QueTyp_e];

        EnterCriticalSection(&pQueHd->CrtSec);
try {
        if (IsListEmpty(&pQueHd->Head))
        {
                *ppWrkItm = NULL;
                RetStat   = WINS_NO_REQ;
        }
        else
        {
                  *ppWrkItm    = RemoveHeadList(&pQueHd->Head);
                  pQueHd->NoOfEntries--;
        }
  }
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
 }
        return(RetStat);
}




__inline
VOID
QueAllocWrkItm(
        IN   HANDLE        HeapHdl,
        IN   DWORD        Size,
        OUT  LPVOID        *ppBuf
        )

/*++

Routine Description:

        This function allocates a work item.  The work item is allocated
        from a heap

Arguments:

        ppBuf - Buffer (work item) allocated

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{



  //
  //  WinsMscHeapAlloc will return an exception if it is not able to
  //  allocate a buffer.  So there is no need to check the return value
  //  for NULL.
  //
  *ppBuf = WinsMscHeapAlloc(HeapHdl, Size );
  return;
}


__inline
VOID
QueDeallocWrkItm(
   IN  HANDLE HeapHdl,
   IN  PVOID  pBuff
        )

/*++

Routine Description:
        This function deallcoated a nbt request  work item

Arguments:
        pBuff - Nbt req. work item to deallocate

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  none currently

Error Handling:

Called by:
        QueRemoveNbtWrkItm
Side Effects:

Comments:
        None
--*/
{


  WinsMscHeapFree(
                        HeapHdl,
                        pBuff
                   );


  return;

}



STATUS
QueInsertWrkItmAtHdOfList (
        IN  PLIST_ENTRY                pWrkItm,
        IN  QUE_TYP_E                QueTyp_e,
        IN  PQUE_HD_T                pQueHdPassed
        )

/*++

Routine Description:
        This function is called to queue a work item
        at the head of a queue.  If the pQueHdPassed is Non NULL,
        the work item is queued on that queue, else, it is queued on
        the queue specified by QueTyp_e.

        TMM will use pQueHdPassed to specify the queue while other clients
        of the queue services will specify QueTyp_e

Arguments:
        pWrlItm      - Work Item to queue
        QueTyp_e     - Type of queue to queue it on (may or may not have valid                                       value)
        pQueHdPassed - ListHead of queue (may or may not be passed)

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        ProcRsp in nmschl.c

Side Effects:

Comments:
        This function differs from QueInsertWrkItm in that it inserts
        the work item at the head of a queue versus at the tail.  I
        prefered to create this function rather than have an extra
        argument to QueInsertWrkItm to save an if test.  QueInsertWrkItm
        is used by the UDP listener thread and I want to do the minimum
        work I can in that thread.


--*/
{
FUTURES("I may get rid of this function since it is very similar to QueInsertWrkItm")
        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
        DWORD                Error;

        if (pQueHdPassed == NULL)
        {

                pQueHd = pWinsQueQueHd[QueTyp_e];
        }
        else
        {
                pQueHd = pQueHdPassed;
        }

        EnterCriticalSection(&pQueHd->CrtSec);
try {
          InsertHeadList(&pQueHd->Head, pWrkItm);
        if (!SetEvent(pQueHd->EvtHdl))
        {
           Error   = GetLastError();
           RetStat = WINS_FAILURE;
        }
}
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
  }

#ifdef WINSDBG
    NmsChlNoReqAtHdOfList++;
#endif
        return(RetStat);

}



STATUS
QueInsertRplPushWrkItm (
        IN               PLIST_ENTRY        pWrkItm,
        IN           BOOL                fAlreadyInCrtSec
        )

/*++

Routine Description:
        This function is called to queue a work item on
        the Push thread's queue.

Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd = pWinsQueQueHd[QUE_E_RPLPUSH];

        //
        // if we are already in the critical section, no need to enter it
        // again
        //
        if (!fAlreadyInCrtSec)
        {
                EnterCriticalSection(&pQueHd->CrtSec);
        }
try {
        //
        // if the push thread does not exist, create it.
        //
        if (!fRplPushThdExists)
        {
              WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdHdl =
                                WinsMscCreateThd(
                                        RplPushInit,
                                        NULL,
                                        &WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdId
                                        );
             fRplPushThdExists = TRUE;
             WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].fTaken = TRUE;
             WinsThdPool.ThdCount++;
        }

        //
        // Insert the work item and signal the thread.
        //
          InsertTailList(&pQueHd->Head, pWrkItm);
        if (!SetEvent(pQueHd->EvtHdl))
        {
           WINSEVT_LOG_M(WINS_EVT_SFT_ERR, GetLastError());
           RetStat = WINS_FAILURE;
        }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "QueInsertRplPushWrkItm: Got exception (%d)\n",ExcCode);
        //
        // no need to log an event. WinsMscCreateThd logs it
        //

  }
        //
        // If we entered the critical section, we should get out of it
        //
        if (!fAlreadyInCrtSec)
        {
                LeaveCriticalSection(&pQueHd->CrtSec);
        }

        return(RetStat);

}

VOID
QueChlWaitForRsp(
    VOID
    )
{
    EnterCriticalSection(&QueNmsCrqQueHd.CrtSec);
    fsChlWaitForRsp = TRUE;
    LeaveCriticalSection(&QueNmsCrqQueHd.CrtSec);
    return;
}

VOID
QueChlNoWaitForRsp(
    VOID
    )
{
    EnterCriticalSection(&QueNmsCrqQueHd.CrtSec);
    fsChlWaitForRsp = FALSE;
    LeaveCriticalSection(&QueNmsCrqQueHd.CrtSec);
    return;
}

BOOL
ChlRspDropped(
        MSG_T   pMsg
        )
{
    BOOL fFreeBuff = FALSE;
    EnterCriticalSection(&QueNmsCrqQueHd.CrtSec);

    //
    // If the challenge thread is not wait for responses, drop the
    // datagram
    //
    if (!fsChlWaitForRsp)
    {
        fFreeBuff = TRUE;

    }
    LeaveCriticalSection(&QueNmsCrqQueHd.CrtSec);
    if (fFreeBuff)
    {
#ifdef WINSDBG
        NmsChlNoRspDropped++;
#endif
        ECommFreeBuff(pMsg);
        return(TRUE);
    }
    return(FALSE);
}

STATUS
QueInsertNetNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        )

/*++

Routine Description:
        This function is called to queue a push ntf work item on
    the RPLPULL  queue. It checks if there is another push ntf
    work item from the same WINS on the queue.  If there is, it is replaced
    with this new one. This is done because the new one has more information
    than the previous one.  The old one is terminated to free up the connection.


Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue, QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
    PQUE_RPL_REQ_WRK_ITM_T pTmp;
    COMM_IP_ADD_T  IpAddNew;
    COMM_IP_ADD_T  IpAddInList;
    BOOL           fBreak = FALSE;
    PRPL_CONFIG_REC_T pCnfRec;


    //
    // Get address of the WINS sending the notfication
    //
    pTmp = (PQUE_RPL_REQ_WRK_ITM_T)pWrkItm;
    pCnfRec = pTmp->pClientCtx;
    COMM_GET_IPADD_M(&pTmp->DlgHdl, &IpAddNew);
        pQueHd = pWinsQueQueHd[QUE_E_RPLPULL];

        EnterCriticalSection(&pQueHd->CrtSec);
try {
    for(pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pQueHd->Head.Flink;
        pTmp !=  (PQUE_RPL_REQ_WRK_ITM_T)pQueHd;
        pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pTmp->Head.Flink)
    {


       if ( pTmp->CmdTyp_e == QUE_E_CMD_HDL_PUSH_NTF )
       {
            //
            // Get address of the WINS that sent this notification
            //
            COMM_GET_IPADD_M(&pTmp->DlgHdl, &IpAddInList);
            if (IpAddInList == IpAddNew)
            {
                 DBGPRINT1(DET, "QueInsertNetNtfWrkItm: Found an earlier Net Ntf work item. Replacing it.  WINS address = (%x)\n", IpAddInList);
                 //
                 // switch the work items since the new one takes precedence
                 // over the old one.
                 //
                 pWrkItm->Flink = pTmp->Head.Flink;
                 pWrkItm->Blink = pTmp->Head.Blink;
                 pTmp->Head.Blink->Flink = pWrkItm;
                 pTmp->Head.Flink->Blink = pWrkItm;
                 fBreak = TRUE;
                 break;
            }
        }
     }
     //
     // If there was no match, insert at tail end of list
     //
     if (!fBreak)
     {
          InsertTailList(&pQueHd->Head, pWrkItm);
     }
     if (!SetEvent(pQueHd->EvtHdl))
     {
//              Error   = GetLastError();
               RetStat = WINS_FAILURE;
     }
    } // end of try
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
}
    //
    // If we found a match, terminate the old work item
    //
    // Do this outside the critical section
    //
    if (fBreak)
    {
CHECK("Can we avoid the try block")
try {
#if PRSCONN
      RPLMSGF_MSG_OPCODE_E Opcode_e;
      BOOL                 fPrsDlg;
#endif


#if PRSCONN
      //
      // If the ntf was sent on a persistent dlg, we do not terminate it since
      // it will be terminated by the remote WINS when it so chooses. This
      // dlg is used for multiple such notifications.  If
      // it was sent on a non-persistent dlg, we will terminate it since the
      // remote WINS create a dlg for each such notification
      //
      RPLMSGF_GET_OPC_FROM_MSG_M(pTmp->pMsg, Opcode_e);

      fPrsDlg = ((Opcode_e == RPLMSGF_E_UPDATE_NTF_PRS) || (Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP_PRS));
      if (!fPrsDlg)
      {
         ECommEndDlg(&pTmp->DlgHdl);
      }
#else
      ECommEndDlg(&pTmp->DlgHdl);
#endif
      //
      // Terminate the dequeued request.
      //
      ECommFreeBuff(pTmp->pMsg - COMM_HEADER_SIZE);
      QueDeallocWrkItm(RplWrkItmHeapHdl, pTmp);

  }
except (EXCEPTION_EXECUTE_HANDLER) {
     DBGPRINTEXC("QueInsertNtfWrkItm");
    }
   }

        return(RetStat);

}
STATUS
QueInsertSndNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItmp
        )

/*++

Routine Description:
        This function is called to queue a send push ntf work item on
    the RPLPULL  queue. It checks if there is another send push ntf
    work item from the same WINS on the queue.  If there is, it is replaced
    with this new one. This is done because the new one has more information
    than the previous one.  The old one is terminated to free up the connection.


Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue, QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
    PQUE_RPL_REQ_WRK_ITM_T pTmp;
    PQUE_RPL_REQ_WRK_ITM_T pWrkItm = (PQUE_RPL_REQ_WRK_ITM_T)pWrkItmp;
    COMM_IP_ADD_T  IpAddNew;
    COMM_IP_ADD_T  IpAddInList;
    BOOL           fBreak = FALSE;
    PRPL_CONFIG_REC_T pCnfRec;


    pTmp = (PQUE_RPL_REQ_WRK_ITM_T)pWrkItm;
    pCnfRec = pTmp->pClientCtx;
    IpAddNew = pCnfRec->WinsAdd.Add.IPAdd;
        pQueHd = pWinsQueQueHd[QUE_E_RPLPULL];

        EnterCriticalSection(&pQueHd->CrtSec);
try {
    for(
        pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pQueHd->Head.Flink;
        pTmp !=  (PQUE_RPL_REQ_WRK_ITM_T)pQueHd;
        // no 3rd expression
        )
    {

        //
        // If this is a push ntf item, then go on to the next if test
        //
        if (( pTmp->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF ) ||
                        (pTmp->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF_PROP))
        {
                IpAddInList = ((PRPL_CONFIG_REC_T)(pTmp->pClientCtx))->WinsAdd.Add.IPAdd;
                //
                // If the push is to the same WINS, replace the work item
                //
                if (IpAddInList == IpAddNew)
                {
                   if (pTmp->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF_PROP)
                   {
                       pWrkItm->CmdTyp_e = pTmp->CmdTyp_e;
                   }

                   DBGPRINT1(DET, "QueInsertSndNtfWrkItm: Found an earlier Snd Ntf work item. Replacing it.  WINS address = (%x)\n", IpAddInList);

                   //
                   // switch the work items since the new one takes precedence
                   // over the old one.
                   //
                   pWrkItmp->Flink = pTmp->Head.Flink;
                   pWrkItmp->Blink = pTmp->Head.Blink;
                   pTmp->Head.Blink->Flink = pWrkItmp;
                   pTmp->Head.Flink->Blink = pWrkItmp;
                   fBreak = TRUE;
                   break;
                }
        }
        pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pTmp->Head.Flink;
    }
    if (!fBreak)
    {
          InsertTailList(&pQueHd->Head, pWrkItmp);
    }
    if (!SetEvent(pQueHd->EvtHdl))
    {
//              Error   = GetLastError();
           RetStat = WINS_FAILURE;
     }
  }
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);

    //
    // if we replaced an item, we need to deallocate it here.
    //
    if (fBreak)
    {
       QueDeallocWrkItm(RplWrkItmHeapHdl, pTmp);
    }
}
        return(RetStat);

}

__inline
STATUS
QueInsertScvWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        )

/*++

Routine Description:
        This function is called to queue a work item on
        the Push thread's queue.

Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue

Side Effects:

Comments:
        None
--*/
{
        return(QueInsertWrkItm ( pWrkItm, QUE_E_WINSSCVQ, NULL));
}
__inline
STATUS
QueRemoveScvWrkItm(
        IN OUT     LPVOID                *ppWrkItm
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        ppWrkItm  - pointer to array  of pointers (to work items) to
                     initialize


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        return(QueGetWrkItm(QUE_E_WINSSCVQ, ppWrkItm));
}


VOID
WinsQueInit(
    LPTSTR     pName,
    PQUE_HD_T  pQueHd
    )

/*++

Routine Description:
          Function to init a queue

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	    //
	    // Create the response event handle.  This event is signaled
	    // by the UDP listener thread when it stores a response
	    // in the spReqWrkItmArr array
	    //
	    WinsMscCreateEvt(
			  pName,
			  FALSE,	//auto-reset
			  &pQueHd->EvtHdl
			);


	    //
	    // Initialize the critical section for the response queue
	    //				
	    InitializeCriticalSection(&pQueHd->CrtSec);
	
	    //
	    //Initialize the queue head for the response queue
	    //
	    InitializeListHead(&pQueHd->Head);
        pQueHd->NoOfEntries = 0;  //not required really since QueHd structures
                                  //are externs
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\makefile.inc ===
wins.rc: ..\msg\winsevnt.rc ..\msg\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\msc\winstmm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        winstmm.c


Abstract:
        This module contains the timer manager functions


Functions:
        WinsTmmInsertEntry
        TmmThdInitFn
        WinsTmmInit
        HandleReq
        SignalClient
        WinsTmmDeleteReqs
        WinsTmmDeallocReq

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Mar-1993 

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include "nms.h"
#include "winsevt.h"
#include "winsmsc.h"
#include "winstmm.h"
#include "winsque.h"
#include "winsthd.h"

/*
 *        Local Macro Declarations
 */

/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */

HANDLE                WinsTmmHeapHdl;  //handle of heap to allocate TMM work items
                                // from

/*
 *        Local Variable Definitions
*/
STATIC CRITICAL_SECTION                sTmmReqCntCrtSec;
STATIC DWORD                        sTmmReqCnt = 0;

//
// This stores the req. id of the request at the top of the queue 
// (i.e. one for which the timer thread is doing a timed wait)
//
STATIC        DWORD                        sReqIdOfCurrReq;
/*
 *        Local Function Prototype Declarations
 */
STATIC
DWORD
TmmThdInitFn(
        LPVOID pParam
        );

VOID
HandleReq(
        OUT  LPLONG                        pDeltaTime        
        );

VOID 
SignalClient(
        VOID
        );


/* prototypes for functions local to this module go here */


VOID 
WinsTmmInsertEntry(
        PQUE_TMM_REQ_WRK_ITM_T    pPassedWrkItm,
        WINS_CLIENT_E             Client_e,
        QUE_CMD_TYP_E             CmdTyp_e,
        BOOL                      fResubmit,
        time_t                    AbsTime,
        DWORD                     TimeInt,
        PQUE_HD_T                 pRspQueHd,
        LPVOID                    pClientCtx,
        DWORD                     MagicNo,
        PWINSTMM_TIMER_REQ_ACCT_T pSetTimerReqs
        )

/*++

Routine Description:

        This function is called to insert a work item into the Timer Manager's
        request queue (delta queue).  It allocates a work item if required         
        (if pWrkItm != NULL) and enqueues it in its proper position in 
        the delta queue of the TMM thread.  It then signals the TMM thread
        if required. 

Arguments:

        pWrkItm    - work item to queue (if pWrkItm != NULL)
        Client_e   - id. of client that submitted the request
        CmdTyp_e   - type of command (set timer, modify timer, etc)
        fResubmit  - Is it a resubmit
        AbsTime   - absolute time (in secs) at which the client needs to be
                     notified
        TimeInt    - time interval in seconds after which the client needs to
                     be notified
        pRspQueHd  - Que Head of the queue where the notification needs to be
                     queued
        pClientCtx - Client's context that needs to be put in the work item
        pSetTimerReqs - For future extensibility
                     

Externals Used:
        None

        
Return Value:

        None
Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PQUE_TMM_REQ_WRK_ITM_T        pWrkItm;
        PQUE_TMM_REQ_WRK_ITM_T        pTmp;
        BOOL                        fInserted = FALSE;

        UNREFERENCED_PARAMETER(pSetTimerReqs);

        if (!pPassedWrkItm)
        {
                QueAllocWrkItm(
                        WinsTmmHeapHdl,
                        sizeof(QUE_TMM_REQ_WRK_ITM_T),
                        &pWrkItm
                      );
        }
        else
        {
                pWrkItm = pPassedWrkItm;
        }

        //
        // Put a request id (a monotonically increasing number)
        //
        EnterCriticalSection(&sTmmReqCntCrtSec);        
        sTmmReqCnt++;        
        LeaveCriticalSection(&sTmmReqCntCrtSec);        
        pWrkItm->ReqId      = sTmmReqCnt; 

        //
        // If work item was allocated or if it is not a resubmit
        // init the rest of the fields appropriately
        //
        pWrkItm->CmdTyp_e   = CmdTyp_e;
        pWrkItm->AbsTime    = AbsTime;
        pWrkItm->TimeInt    = TimeInt;
        pWrkItm->QueTyp_e   = QUE_E_WINSTMQ;
        pWrkItm->RspEvtHdl  = pRspQueHd->EvtHdl;
        pWrkItm->pRspQueHd  = pRspQueHd;
        pWrkItm->pClientCtx = pClientCtx;
        pWrkItm->Client_e   = Client_e; 
        pWrkItm->MagicNo    = MagicNo;

        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);
try {
        if (IsListEmpty(&QueWinsTmmQueHd.Head))
        {
                InsertTailList(&QueWinsTmmQueHd.Head, &pWrkItm->Head);
                if (!SetEvent(QueWinsTmmQueHd.EvtHdl))
                {

                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SIGNAL_TMM_ERR);
                        DBGPRINT0(EXC, "Could not signal Tmm Thd\n");
                        WINS_RAISE_EXC_M(WINS_EXC_SIGNAL_TMM_ERR);
                }
                fInserted = TRUE;
        }
        else
        {
                //
                // get the address of the first entry in the queue.
                //
                pTmp = (PQUE_TMM_REQ_WRK_ITM_T)QueWinsTmmQueHd.Head.Flink;

                //
                // Go over the circular linked list until we hit the head
                // of the queue
                //
                while(pTmp != (PQUE_TMM_REQ_WRK_ITM_T)&QueWinsTmmQueHd.Head)
                {

                   //
                   //  If the list entry has a longer timer than the new entry,
                   //  insert the new entry before it
                   //
                   if (pTmp->AbsTime > pWrkItm->AbsTime)
                   {
                        pWrkItm->Head.Flink     = &pTmp->Head;
                        pWrkItm->Head.Blink     = pTmp->Head.Blink;
                        pTmp->Head.Blink->Flink = &pWrkItm->Head;
                        pTmp->Head.Blink        = &pWrkItm->Head;
                        fInserted = TRUE;

                        //
                        // The element has been inserted. Let us break out
                        // of the loop
                        //
                        break;
                   }        
                   pTmp = (PQUE_TMM_REQ_WRK_ITM_T)pTmp->Head.Flink;
                }
                
        }        
        //
        // If the entry was not inserted (i.e. all entries in the queue have
        // a shorter expiry than our entry), insert the entry  at the 
        // end of the list
        //
        if (!fInserted)
        {
                InsertTailList(&QueWinsTmmQueHd.Head, &pWrkItm->Head);
        }

        //
        // If this is the top most entry in the queue and there is 
        // at least one more entry in the queue, signal the TMM
        // thread so that it can start a timer for it.  If the above
        // is not true, relax (either the TMM thread has already been 
        // signaled (if this is the only item in the queue) or it does not 
        // need to be signaled (this is not the top-most item in the queue). 
        //
        if (
                (pWrkItm->Head.Blink == &QueWinsTmmQueHd.Head)  
                                && 
                (pWrkItm->Head.Flink != &QueWinsTmmQueHd.Head)  
            )
        {
                if (!SetEvent(QueWinsTmmQueHd.EvtHdl))
                {

                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SIGNAL_TMM_ERR);
                        DBGPRINT0(EXC, "Could not signal Tmm Thd\n");
                        WINS_RAISE_EXC_M(WINS_EXC_SIGNAL_TMM_ERR);
                }
        }
  } // end of try ..

finally {
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);                
 }
        return;
}



VOID
WinsTmmInit(
        VOID
        )

/*++

Routine Description:
        This is the function that initializes the timer manager

Arguments:
        None

Externals Used:
        None

        
Return Value:
        None

Error Handling:

Called by:
        Init in nms.c
Side Effects:
        A timer thread is created
Comments:
        None
--*/

{

        
        STATUS   RetStat;

        //
        // Initialize the critical section guarding the counter for 
        // Tmm requests
        //
        InitializeCriticalSection(&sTmmReqCntCrtSec);

        /*
        * Create heap for allocating name challenge work items
        */
        DBGPRINT0(HEAP_CRDL, "WinsTmmInit: Tmm. Chl. heap\n");
        WinsTmmHeapHdl =  WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */ 
                TMM_INIT_HEAP_SIZE 
                );

        InitializeListHead(&QueWinsTmmQueHd.Head);

        
        //
        //
        // Create the timer thread.  This function will
        // initialize the critical section and the Evt handle passed
        // to it
        //        
        RetStat = WinsMscSetUpThd(
                        &QueWinsTmmQueHd,                //queue head
                        TmmThdInitFn,                        //init function
                        NULL,                                   // no param
                        &WinsThdPool.TimerThds[0].ThdHdl,
                        &WinsThdPool.TimerThds[0].ThdId
                        );

        if (RetStat == WINS_SUCCESS)
        {
                WinsThdPool.TimerThds[0].fTaken = TRUE;
                WinsThdPool.ThdCount++;  //increment the thread count
        }
        else
        {
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }

        return;                
}


DWORD
TmmThdInitFn(
        LPVOID pParam
        )

/*++

Routine Description:
        This is the top-most function of the TMM thread

Arguments:
        pParam - Param to the top most function (not used)

Externals Used:
        None

        
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        WinsTmmInit

Side Effects:

Comments:
        None
--*/

{

        LONG                        DeltaTime;
        BOOL                        fSignaled;
                
        UNREFERENCED_PARAMETER(pParam);
        
try {
        while(TRUE)
        {
                WinsMscWaitInfinite(QueWinsTmmQueHd.EvtHdl);

                while(!IsListEmpty(&QueWinsTmmQueHd.Head))
                {
                   HandleReq(&DeltaTime);

                   if (DeltaTime != 0)
                   {
                        //
                        // Do a timed wait until either the timer expires
                        // or the event is signaled. 
                        //
                        WinsMscWaitTimed(
                                QueWinsTmmQueHd.EvtHdl,
                                DeltaTime * 1000,  //convert to millisecs
                                &fSignaled
                                        );

                        //
                        // If signaled (interrupte from the wait), it means
                        // that there is a more urgent request in the timer
                        // queue.
                        //
                        if (fSignaled)
                        {
                                HandleReq(&DeltaTime);
                        }
                        else  //timer expired
                        {
                                SignalClient();
                        }
                   }
                   else
                   {
                        SignalClient();

                   }
                }
        }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
                
                DBGPRINT0(EXC, 
                  "TmmThdInitFn: Timer Thread encountered an exception\n");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_TMM_EXC);
                ExitThread(WINS_FAILURE);

}
                        
        //
        // We should never reach here
        //
        ASSERT(0);
        return(WINS_FAILURE);

}


VOID
HandleReq(
        OUT  LPLONG                        pDeltaTime        
        )

/*++

Routine Description:
        This function is called to handle a timer request.  The function
        is called when the Timer thread is signaled.

Arguments:
        pDeltaTime -  Time Interval to wait for before signaling the client 

Externals Used:
        None

        
Return Value:
        None

Error Handling:

Called by:
        TmmThdInitFn

Side Effects:

Comments:
        None
--*/

{
        
        time_t                AbsTime;        
        time_t                CurrTime;
        QUE_CMD_TYP_E        CmdTyp_e;


        (void)time(&CurrTime);
        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);

        //
        // If list is empty, return.  
        //
        if (IsListEmpty(&QueWinsTmmQueHd.Head))
        {
                *pDeltaTime = 0;
                LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);
                return;
        }

        //
        // Retrieve the absolute time corresponding to the
        // first entry in the timer queue.
        //
        AbsTime  = ((PQUE_TMM_REQ_WRK_ITM_T)
                        (QueWinsTmmQueHd.Head.Flink))->AbsTime; 
        CmdTyp_e = ((PQUE_TMM_REQ_WRK_ITM_T)
                        (QueWinsTmmQueHd.Head.Flink))->CmdTyp_e;        
        
        ASSERT(CmdTyp_e == QUE_E_CMD_SET_TIMER);

        //
        // Store the request id of the request that we will wait on
        // in the STATIC
        //
        sReqIdOfCurrReq =  ((PQUE_TMM_REQ_WRK_ITM_T)
                                (QueWinsTmmQueHd.Head.Flink))->ReqId;        
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);
        
        switch(CmdTyp_e)
        {
                case(QUE_E_CMD_SET_TIMER):
                        *pDeltaTime = (LONG)(AbsTime - CurrTime);        

                        //
                        // It is possible that we might have a small
                        // negative value here, just because of the
                        // time it took to process the request. 
                        //
                        if (*pDeltaTime < 0)
                        {
                           *pDeltaTime = 0;
                        }
                        break;
                case(QUE_E_CMD_MODIFY_TIMER):
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        DBGPRINT0(ERR, "Not supported yet\n");
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        break;
                case(QUE_E_CMD_CANCEL_TIMER):
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        DBGPRINT0(ERR, "Not supported yet\n");
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        break;
                default:
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        DBGPRINT1(EXC, "Wierd: Invalid Request. CmdType is (%d), \n", CmdTyp_e);
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        break;
        }
        return;
}


VOID 
SignalClient(
        VOID
        )

/*++

Routine Description:
        This function is called to notify the client that its 
        timer request has expired.

Arguments:

        None

Externals Used:
        None

        
Return Value:
        None

Error Handling:

Called by:
        TmmThdInitFn

Side Effects:

Comments:
        None
--*/

{
        PQUE_TMM_REQ_WRK_ITM_T        pWrkItm;

FUTURES("Optimize to signal all clients whose requests have expired")
        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);
        pWrkItm = (PQUE_TMM_REQ_WRK_ITM_T)RemoveHeadList(&QueWinsTmmQueHd.Head);

        //
        // If the top of the queue has a different work item than the 
        // one we were doing a timed wait for, it means that the there has
        // been a queue purge (see WinsTmmDeleteEntry. Simply return.
        //
        if (sReqIdOfCurrReq != pWrkItm->ReqId)
        {
                LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);        
                return;
        }
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);                

        pWrkItm->CmdTyp_e = QUE_E_CMD_TIMER_EXPIRED;

        //
        // Insert into client's queue
        //
        QueInsertWrkItm(
                        &pWrkItm->Head,
                        0,                //not used -- change to an enumrator val
                        pWrkItm->pRspQueHd
                       );
        
        return;
}


VOID
WinsTmmDeleteReqs(
        WINS_CLIENT_E        Client_e
        )

/*++

Routine Description:
        This function is called to delete all set timer requests submitted
        by a client

Arguments:


Externals Used:
        None

        
Return Value:

        None
Error Handling:

Called by:
        Reconfig (in rplpull.c)
Side Effects:

Comments:
        In the future, enhance this function so that it delete requests
        based on other criteria
                
--*/
{

        PQUE_TMM_REQ_WRK_ITM_T        pTmp;
        PQUE_TMM_REQ_WRK_ITM_T        pMemToDealloc;
        BOOL                    fFirstEntry = FALSE;

        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);
try {        

        if (!IsListEmpty(&QueWinsTmmQueHd.Head))
        {
                //
                // get the address of the first entry in the queue.  
                //
                pTmp = (PQUE_TMM_REQ_WRK_ITM_T)QueWinsTmmQueHd.Head.Flink;

                //
                // We loop until we get to the head of the list  (the linked
                // list is a circular list)
                //
                while(pTmp != (PQUE_TMM_REQ_WRK_ITM_T)&QueWinsTmmQueHd.Head)
                {

                           //
                           //  If the entry  was queued by the client, get rid of 
                        //  it
                           //
                           if (pTmp->Client_e == Client_e)
                           {
                                //
                                // If this is the first entry in the queue, it 
                                // means that the timer thread is doing a 
                                // wait on it.  Signal it. 
                                //
                                if (
                                    !fFirstEntry 
                                        && 
                                    (pTmp->Head.Blink == &QueWinsTmmQueHd.Head)
                                   )
                                {
                                        fFirstEntry = TRUE;
                                }


//                                if (pTmp->Head.Flink ==  &QueWinsTmmQueHd.Head)
                                if (fFirstEntry)
                                {
                                        if (!SetEvent(QueWinsTmmQueHd.EvtHdl))
                                        {

                                                WINSEVT_LOG_M(
                                                            WINS_FAILURE, 
                                                            WINS_EVT_SIGNAL_TMM_ERR
                                                                  );
                                                DBGPRINT0(EXC, 
                                                        "Could not signal Tmm for canceling a request\n");
                                                WINS_RAISE_EXC_M(WINS_EXC_SIGNAL_TMM_ERR);
                                        }
                                }

                                //
                                // unlink the request
                                //
                                pTmp->Head.Flink->Blink = pTmp->Head.Blink;
                                pTmp->Head.Blink->Flink = pTmp->Head.Flink;
                                pMemToDealloc = pTmp;
                                   pTmp = (PQUE_TMM_REQ_WRK_ITM_T)pTmp->Head.Flink;

                                //
                                // Dealloc the dequeued work item
                                //
                                WinsTmmDeallocReq(pMemToDealloc);
                           }        
                        else
                        {
                                   pTmp = (PQUE_TMM_REQ_WRK_ITM_T)pTmp->Head.Flink;
                        }
                }
         }
 } // end of try block
except(EXCEPTION_EXECUTE_HANDLER)  {
        DBGPRINT1(EXC, "WinsTmmDeleteReqs: Got exception (%x)\n",
                        (DWORD)GetExceptionCode());
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_TMM_EXC);
 }
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);                
        return;
}



__inline
VOID
WinsTmmDeallocReq(
        PQUE_TMM_REQ_WRK_ITM_T pWrkItm
        )

/*++

Routine Description:
        This function is called to deallocate a timer request work item

Arguments:

        pWrkItm - Work Item

Externals Used:
        WinsTmmHeapHdl        

Return Value:
        None

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/

{

        //
        // deallocate the work item
        //
        QueDeallocWrkItm(
                        WinsTmmHeapHdl,
                        pWrkItm
                        );

        return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\nmschl.c ===
/*+

Copyright (c) 1990  Microsoft Corporation

Module Name:
	nmschl.c

Abstract:
	This module contains the name challenge functions


Functions:

	NmsChlInit
	NmsChlHdlNamReg
	ChlThdInitFn
	HandleWrkItm
	WaitForRsp
	ProcRsp
	ChlUpdateDb
	InfRemWins


Portability:

	This module is portable

Author:

	Pradeep Bahl (PradeepB)  	Jan-1993

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include "nms.h"
#include "nmsdb.h"
#include "winsque.h"
#include "comm.h"
#include "winsthd.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#include "nmsnmh.h"
#include "nmschl.h"
#include "nmsmsgf.h"
#include "rplmsgf.h"


/*
 *	Local Macro Declarations
*/


//
// Computation of the time it can take for a WINS to conduct a challenge
// (in msecs)
//
#define WACK_TTL			(((1 << WinsCnf.MaxNoOfRetries) * \
					 WinsCnf.RetryInterval) + \
					WAIT_PAD)

//
// WAIT_PAD is used to increase the TTL sent to an NBT node that sent us the
// name registration request.  The pad is on top of the TTL we compute
// (WACK_TLL) above to determine how much time WINS will take to conduct
// the challenge. The pad is supposed to take care of the situation where
// WINS is dragging its feet due to a sudden transient peak in network
// load or cpu load.

#define  WAIT_PAD		       500	//500 msecs in case WINS is very
					        //busy

/*
 *	Global Variable Definitions
 */

//
// heap used to allocate work items for the challenge request and response
// queues
//
HANDLE  	   NmsChlHeapHdl;



/*
 *	Local Variable Definitions
 */
//
// It maintains a running count of how many responses to queries/releases are
// pending
//
DWORD		   scPendingRsp = 0;

//
// The maximum # of requests that the name challenge manager sends at any
// one time. This number is never allowed to go over
// NMSCHL_MAX_CHL_REQ_AT_ONE_TIME.  In fact after one series of
// challenges are over (i.e. either they have timed out or we have received
// responses for them, this counter is reinitialized to 0)
//
// This var. is reinitialized to zero when a batch of challenge requests
// is acquired from the one or more of the challenge request queues
//
// It maintains the total # of requests acquired from the request queues.
//
DWORD		   sMaxTransId = 0;
#ifdef WINSDBG
DWORD              NmsChlNoOfReqNbt;
DWORD              NmsChlNoOfReqRpl;
DWORD              NmsChlNoNoRsp;
DWORD              NmsChlNoInvRsp;
DWORD              NmsChlNoRspDropped;
DWORD              NmsChlNoReqDequeued;
DWORD              NmsChlNoRspDequeued;
DWORD              NmsChlNoReqAtHdOfList;
#endif
//
// We have a dimension 1 larger than the max. number of challenge requests
// handled at one time so that we can terminate the list with a NULL.
//
STATIC  PCHL_REQ_WRK_ITM_T   spReqWrkItmArr[NMSCHL_MAX_CHL_REQ_AT_ONE_TIME + 1];

/*
 *	Local Function Prototype Declarations
 */
STATIC
DWORD
ChlThdInitFn(
	IN LPVOID pThreadParam
	);

STATIC
STATUS
HandleWrkItm(
	PCHL_REQ_WRK_ITM_T	*ppaWrkItm,
	DWORD			MaxTransId,
	BOOL			fRetry	
	);


STATIC
STATUS
WaitForRsp(
	   VOID
	);

STATIC
STATUS
ProcRsp(
	VOID
	);

STATIC
STATUS
ChlUpdateDb(
        BOOL                    fUpdVersNoOfCnfRec,
	WINS_CLIENT_E		Client_e,
	PNMSDB_ROW_INFO_T	pRowInfo,
	DWORD			OwnerIdInCnf,
	BOOL			fRefreshOnly
	);
STATIC
VOID
InfRemWins(
	PCHL_REQ_WRK_ITM_T	pWrkItm
	  );

STATIC
STATUS
ProcAddList(
	PCHL_REQ_WRK_ITM_T	pReqWrkItm,
	PNMSMSGF_CNT_ADD_T	pCntAdd,
	LPBOOL			pfAdded
	);

/* prototypes for functions local to this module go here */

STATUS
NmsChlInit(
	VOID
	)

/*++

Routine Description:

	This function is called to initialize the name challenge component

Arguments:
	None

Externals Used:
	None

	
Return Value:
	WINS_SUCCESS or a failure code.  The function can also raise an
	exception in case of fatal errors

Error Handling:

Called by:
	Init in nms.c

Side Effects:
	
Comments:
	None
--*/

{

	STATUS RetStat = WINS_SUCCESS;
	
	/*
	* Create heap for allocating name challenge work items
	*/
        DBGPRINT0(HEAP_CRDL, "NmsChlInit: Chl. Mgr. heap\n");
	NmsChlHeapHdl =  WinsMscHeapCreate(
		0,    /*to have mutual exclusion	*/
		NMSCHL_INIT_BUFF_HEAP_SIZE
		);


	//
	//  Initialize the spReqWrkItmArr elements to NULL
	//	
	//  ANSI C should do it for us (all externals are initialized
	//  automatically, but I am taking no chances).  This is
	//  init time overhead.
	//
	WINSMSC_FILL_MEMORY_M((void *)spReqWrkItmArr, sizeof(spReqWrkItmArr), 0);
	
	
	//
	// Create the response event handle.  This event is signaled
	// by the UDP listener thread when it stores a response
	// in the spReqWrkItmArr array
	//
	WinsMscCreateEvt(
			  TEXT("WinsNmsChlRspEvt"),
			  FALSE,	//auto-reset
			  &QueNmsCrqQueHd.EvtHdl
			);

	//
	// Initialize the critical section for the response queue
	//				
	InitializeCriticalSection(&QueNmsCrqQueHd.CrtSec);
	
	//
	//Initialize the queue head for the response queue
	//
	InitializeListHead(&QueNmsCrqQueHd.Head);
	
	//
	// Since this thread deals with two request queues instead of
	// one, we need to create one more
	// critical section and event handle and initialize the
	// queue head of this  other queue.  The second queue
	// will be created when we create the thread
	//	
	InitializeListHead(&QueNmsRrcqQueHd.Head);	

	
	WinsMscCreateEvt(
			     TEXT("WinsNmsChlReplReqEvt"),
			     FALSE,		//Auto Reset
			     &QueNmsRrcqQueHd.EvtHdl
			  );

	InitializeCriticalSection(&QueNmsRrcqQueHd.CrtSec);

	//
	//
	// Create the name challenge thread.  This function will
	// initialize the critical section and the Evt handle passed
	// to it
	//	
	RetStat = WinsMscSetUpThd(
			&QueNmsNrcqQueHd,		//queue head
			ChlThdInitFn,		        //init function
			NULL,	   		        // no param
			&WinsThdPool.ChlThd[0].ThdHdl,
			&WinsThdPool.ChlThd[0].ThdId
			);

	if (RetStat == WINS_SUCCESS)
	{
		WinsThdPool.ChlThd[0].fTaken = TRUE;
		WinsThdPool.ThdCount++;  //increment the thread count
	}
	return(RetStat);

} // NmsChlInit()



STATUS
NmsChlHdlNamReg(
	IN NMSCHL_CMD_TYP_E   CmdTyp_e,
	IN WINS_CLIENT_E      Client_e,
	IN PCOMM_HDL_T        pDlgHdl,	
	IN MSG_T              pMsg,
        IN MSG_LEN_T          MsgLen,
	IN DWORD	      QuesNamSecLen,
	IN PNMSDB_ROW_INFO_T  pNodeToReg,
	IN PNMSDB_STAT_INFO_T  pNodeInCnf,
//	IN PCOMM_ADD_T	      pAddOfNodeInCnf,
	IN PCOMM_ADD_T	      pAddOfRemWins
	)

/*++

Routine Description:
	This function is called to handle a name registration that resulted
	in a conflict


Arguments:
	CmdTyp_e  - Type of command (challenge, challenge and release if
			challenge succeeds, release -- see nmschl.h)
	Client_e  - client (nms or replicator)
	pDlgHdl   - Dlg hdl (only if client is nms)
	pMsg      - Buffer containing request (only if client is nms)
	Msglen    - length of above buffer
	QuesNamSecLen - Length of question name section in buffer
	pNodeToreq  - Info about name to register
	pAddOfNodeInCnf - address of node in conflict (i.e. has name) with the
			  node trying to register

Externals Used:
	None

	
Return Value:

	WINS_SUCCESS or a failure code.  The function can also raise an
	exception in case of fatal errors

Error Handling:

Called by:
	NmsNmhNamRegInd, NmsNmhNamRegGrp (in an Nbt thread)

Side Effects:

Comments:
	None
--*/

{


	STATUS RetStat = WINS_SUCCESS;
#if USENETBT == 0
	BYTE   aBuff[COMM_DATAGRAM_SIZE];
#else
	BYTE   aBuff[COMM_DATAGRAM_SIZE + COMM_NETBT_REM_ADD_SIZE];
#endif
	DWORD  BuffLen;
	
	DBGENTER("NmsChlHdlNamReg\n");

	//
	//  Before inserting the request, send a WACK. The Time period
	//  in the TTL should be equal to WinsCnf.RetryInterval
	//
	//  Note: WACK is sent only if pDlgHdl is NON-NULL since that
	//        implies that the request is from an NBT thread
	//
	if (pDlgHdl != NULL)
	{
	
		COMM_ADD_T	NodeToSendWACKTo;
                DWORD       WackTtl;

                if (NMSDB_ENTRY_MULTIHOMED_M(pNodeInCnf->EntTyp))
                {
                        WackTtl = pNodeInCnf->NodeAdds.NoOfMems * WACK_TTL;
                }
                else
                {
                        WackTtl = WACK_TTL;
                }

		//
		// Format the WACK
		//
		NmsMsgfFrmWACK(
#if USENETBT == 0
				aBuff,
#else
				aBuff + COMM_NETBT_REM_ADD_SIZE,
#endif
				&BuffLen,
				pMsg,
				QuesNamSecLen,
				WackTtl
			     );


		//
		// We extract the address from the DlgHdl and don't use
		// the address passed in the name packet since a node
		// can register a name with an address different than
		// its own.
		//
		// RFCs are silent about the above
		//
		NodeToSendWACKTo.AddLen    = COMM_IP_ADD_SIZE;
		COMM_GET_IPADD_M(pDlgHdl, &NodeToSendWACKTo.Add.IPAdd);
		NodeToSendWACKTo.AddTyp_e  = COMM_ADD_E_TCPUDPIP;

		DBGPRINT2(CHL, "NmsChlHdlNamReg: Sending WACK to node with name = (%s) and address = (%X)\n", pNodeToReg->pName, NodeToSendWACKTo.Add.IPAdd);

		//
		// Send the WACK.  Use the explicit NBT dlg handle since the
		// WACK has to be sent as a UDP packet.
		//
		ECommSendMsg(
			&CommExNbtDlgHdl,
			&NodeToSendWACKTo,
#if USENETBT == 0
			aBuff,
#else
			aBuff + COMM_NETBT_REM_ADD_SIZE,
#endif	
			BuffLen

 	    	            );
	}	

        WINSMSC_COPY_MEMORY_M(
                pNodeToReg->Name,
                pNodeToReg->pName,
                pNodeToReg->NameLen
                        );
	//
	// Insert the request in the challenge queue so that the challenge
	// thread can get it
	//
	RetStat = QueInsertChlReqWrkItm(
			  CmdTyp_e,
			  Client_e,
			  pDlgHdl,
			  pMsg,
			  MsgLen,
			  QuesNamSecLen,
			  pNodeToReg,
			  pNodeInCnf,
			  pAddOfRemWins
			  );

#ifdef WINSDBG
        if (Client_e == WINS_E_NMSNMH)
        {
           NmsChlNoOfReqNbt++;
        }
        else
        {
           NmsChlNoOfReqRpl++;
        }
#endif
	DBGLEAVE("NmsChlHdlNamReg\n");
	return(RetStat);

} // NmsChlHdlNamReg()	





DWORD
ChlThdInitFn(
	IN LPVOID pThreadParam
	)
	
/*++

Routine Description:
	This is the initialization function for the name challenge thread


Arguments:
	pThreadParam  - NOT USED

Externals Used:
	None

	
Return Value:

	This function should never return.  If it returns it means there
	is some problem.  WINS_FAILURE is returned when this happens

Error Handling:

Called by:
	NmsChlInit

Side Effects:
	A name challenge thread is created

Comments:
	None
--*/

{
	
	STATUS 			RetStat = WINS_SUCCESS;
	HANDLE			ThdEvtHdlArray[3];	
	DWORD			ArrInd;		//index of hdl signaled
	PCHL_REQ_WRK_ITM_T	pWrkItm = NULL;
    BOOL                    fTablesOpen = FALSE;

    BOOL    bRecoverable = FALSE;
	UNREFERENCED_PARAMETER(pThreadParam);

while(TRUE)
{
try {
  if (!bRecoverable)
  {
	/*

	   Initialize the thread with the database
	*/
	NmsDbThdInit(WINS_E_NMSCHL);
	DBGMYNAME("Name Challenge Thread");

	/*
	 *  Initialize the array of handles on which the challenge thread will
	 *  wait.
	*/
	ThdEvtHdlArray[0]    =  NmsTermEvt;	        //termination event var
	ThdEvtHdlArray[1]    =  QueNmsNrcqQueHd.EvtHdl; //work queue event var
	ThdEvtHdlArray[2]    =  QueNmsRrcqQueHd.EvtHdl; //work queue event var

    bRecoverable = TRUE;
  }
	
	while (TRUE)
	{

		WinsMscWaitUntilSignaled(
				ThdEvtHdlArray,
				sizeof(ThdEvtHdlArray)/sizeof(HANDLE),
				&ArrInd,
                FALSE
					);	

		//
		// if NmsTermEvt was signaled, terminate self
		//
		if (ArrInd == 0)
		{
		      WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
		}	

		while (TRUE)
		{	
			scPendingRsp      = 0;  //reinit TransId Counter to 0
			sMaxTransId       = 0;  //reinit MaxTransId Counter to 0
			RetStat =  QueRemoveChlReqWrkItm(
						ThdEvtHdlArray[ArrInd],
						(LPVOID *)spReqWrkItmArr,
						&sMaxTransId
						     );

			if (RetStat == WINS_NO_REQ)
			{
				break;   //break out of while loop	
			}	
			else   // one or more items were dequeued
			{
#ifdef WINSDBG
                                NmsChlNoReqDequeued += sMaxTransId;
#endif
				NmsDbOpenTables(WINS_E_NMSCHL);
                                fTablesOpen = TRUE;
				scPendingRsp = sMaxTransId;	

                                QueChlWaitForRsp();
				//
				// If HandleWrkItm fails, it will raise
				// an exception
				//
				HandleWrkItm(
					      spReqWrkItmArr,
					      sMaxTransId,
					      FALSE  //not a retry
					    );
				//
				// Wait for responses to all requests sent
				// WaitForRsp() function will return only
				// after all requests are done with
				// as a result of responses having been
				// received for them, they having timed out
				// after the requisite number of retries or
				// a mix of both.
				//
				WaitForRsp();

                                QueChlNoWaitForRsp();

				NmsDbCloseTables();
                                fTablesOpen = FALSE;

			}
		} // end of while (TRUE)
      } // end of while (TRUE)

     } // end of try {..}

except (EXCEPTION_EXECUTE_HANDLER) {
  if (bRecoverable)
  {
    DWORD   No;
    DWORD ExcCode = GetExceptionCode();
    DBGPRINTEXC("ChlThdInitFn: Name Challenge Thread");
    //
    // If ExcCode is NBT_ERR, it could mean that the main thread
    // closed the netbt handle.
    //
    if ( ExcCode == WINS_EXC_NBT_ERR)
    {
         if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
         {
	        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
         }
         else
         {
            //if ((WinsCnf.State_e != WINSCNF_E_PAUSED) && (!fWinsCnfInitStatePaused))
            {
	           WINSEVT_LOG_M(ExcCode, WINS_EVT_CHL_EXC);
            }
         }
    }
    else
    {
	   WINSEVT_LOG_M(ExcCode, WINS_EVT_CHL_EXC);
    }
	
    if(fTablesOpen)
    {
	NmsDbCloseTables();
        fTablesOpen = FALSE;
    }

    //
    // For all requests that were never sent, free them
    //
    for (No=0; No < sMaxTransId; No++)
    {
           if (spReqWrkItmArr[No] != NULL)
           {
                if (spReqWrkItmArr[No]->pMsg != NULL)
                {
		   ECommFreeBuff(spReqWrkItmArr[No]->pMsg);
                }
		QueDeallocWrkItm(NmsChlHeapHdl, spReqWrkItmArr[No]);
           }
    }

    QueChlNoWaitForRsp();

  } // end of if (bRecoverable)
  else // if (bRecoverable)
  {
	DBGPRINTEXC("ChlThdInitFn: Name Challenge Thread");
	//
	// If NmsDbThdInit comes back with an exception, it is possible
	// that the session has not yet been started.  Passing
	// WINS_DB_SESSION_EXISTS however is ok
	//
	//
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_CHL_ABNORMAL_SHUTDOWN);
	WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);	
  } // if (bRecoverable)
} // exception handler
} // while(TRUE)
  //
  // We should never get here
  //
  return(WINS_FAILURE);

}  // ChlThdInitFn()



STATUS
HandleWrkItm(
	IN PCHL_REQ_WRK_ITM_T	*ppaWrkItm,
	IN DWORD		MaxTransId,
	IN BOOL			fRetry
	)

/*++

Routine Description:
	This function is called to send a name query to the node that
	was confliciting


Arguments:
	ppaWrkItm  - Address of an array of pointers to work items that
		    got queued in one or more of the challenge queues
		
	MaxTransId - One more than the index of the last filled entry in
		     the array

	fRetry	   - indicates whether HandleWrkItm is being called to
		     retry a request

Externals Used:
	None

	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
	ChlThdInitFn(), WaitForRsp

Side Effects:

Comments:
	None
--*/

{
#if USENETBT == 0
	BYTE 	        	Buff[COMM_DATAGRAM_SIZE];
#else
	BYTE 	        	Buff[COMM_DATAGRAM_SIZE + COMM_NETBT_REM_ADD_SIZE];
#endif
	MSG_LEN_T		MsgLen;
	LPBYTE			pName           = NULL;
	DWORD			NameLen         = 0;
	PCOMM_ADD_T  		pAddOfNodeInCnf = NULL;
	NMSCHL_CMD_TYP_E	CmdTyp_e;
	NMSMSGF_NODE_TYP_E	NodeTyp_e;
	DWORD			cPendingRsp     = 0; //count of pending
						     //responses
	volatile DWORD		i;

	DBGENTER("HandleWrkItm\n");

PERF("For retries, reuse the buffer sent for the initial try. This means")
PERF("that I need to allocate it and store it in the request work item")
PERF("instead of using the stack for it")
	UNREFERENCED_PARAMETER(fRetry);

	//
	// Loop over all slots of the array that were filled as a result of
	// the acquisition of requests from the challenge request queue(s)
	//
FUTURES("Remove the exception handler out of production code")
try {
        DBGPRINT1(CHL, "HandleWrkItm: Max Trans. Id = (%d)\n", MaxTransId);
	for(
		i = 0;
		i < MaxTransId;
		ppaWrkItm++, i++
	    )
	{
		//
		// if we have hit an empty slot, it means that this function
		// has been called to retry one or more requests that
		// did not get satisfied in the first wait period.  The empty
		// slot indicates that a request that occupied this slot
		// got satisfied in one of the earlier retries.  Just
		// skip the empty slot
		//
		if (fRetry && (*ppaWrkItm == NULL))
		{
			DBGPRINT1(CHL, "HandleWrkItm: HIT a NULL entry. Trans. Id = (%d)\n", i);
			continue;
		}

		(*ppaWrkItm)->NodeToReg.pName = (*ppaWrkItm)->NodeToReg.Name;

		CmdTyp_e  	= (*ppaWrkItm)->CmdTyp_e;
		NodeTyp_e 	= (*ppaWrkItm)->NodeToReg.NodeTyp;

		pName      = (*ppaWrkItm)->NodeToReg.pName;

		//
		// if the first character is 0x1B, swap the bytes
		// This is for supporting the browser. See
		// NmsMsgfProcNbtReq
		//
		if (*pName == 0x1B)
		{
			WINS_SWAP_BYTES_M(pName, pName + 15);
		}
       	        NameLen    = (*ppaWrkItm)->NodeToReg.NameLen;
		
	
		//
		// get the last address (the only address unless the node in
		// conflict is a multihomed node) from the list of addresses
		//
        	pAddOfNodeInCnf = &((*ppaWrkItm)->NodeAddsInCnf.Mem[
					(*ppaWrkItm)->NoOfAddsToUse - 1	
							].Add);
		


		//
		//  If the command is directing us to do a challenge, send a
		//  name query
		//
		if (
			(CmdTyp_e == NMSCHL_E_CHL)
				||
			(CmdTyp_e == NMSCHL_E_CHL_N_REL_N_INF)
				||
			(CmdTyp_e == NMSCHL_E_CHL_N_REL)
		   )
	        {
			DBGPRINT3(CHL, "HandleWrkItm: Sending Name Query Request with Transid = (%d) to node with name = (%s) and address = (%X)\n", i, pName, pAddOfNodeInCnf->Add.IPAdd);
		
			NmsMsgfFrmNamQueryReq(
						i, 	//Transaction Id
#if USENETBT == 0
						Buff,
#else
						Buff + COMM_NETBT_REM_ADD_SIZE,
#endif
						&MsgLen,
						pName,
						NameLen
			    		     );	

			(*ppaWrkItm)->ReqTyp_e	        = NMSMSGF_E_NAM_QUERY;
		}	
		else   // has to be NMSCHL_E_REL or NMSCHL_E_REL_N_INF or
                       // NMSCHL_E_REL_ONLY
		{
		
			DBGPRINT3(CHL,
			    "HandleWrkItm: Sending Name Release Request with Transid = (%d) to node with name = (%s) and address = (%X)\n", i, pName, pAddOfNodeInCnf->Add.IPAdd);

			NmsMsgfFrmNamRelReq(
						i, 	//Transaction Id
#if USENETBT == 0
						Buff,
#else
						Buff + COMM_NETBT_REM_ADD_SIZE,
#endif
						&MsgLen,
						pName,
						NameLen,
						NodeTyp_e,
						pAddOfNodeInCnf
			    		  );	
			(*ppaWrkItm)->ReqTyp_e	        = NMSMSGF_E_NAM_REL;
		}

		ECommSendMsg(
				&CommExNbtDlgHdl,
				pAddOfNodeInCnf,
#if USENETBT == 0
				Buff,
#else
				Buff + COMM_NETBT_REM_ADD_SIZE,
#endif
				MsgLen
 	    	   	    );
		cPendingRsp++;
	}
	
	//
	// Do a sanity check
	//
#ifdef WINSDBG
	if (cPendingRsp != scPendingRsp)
	{
		DBGPRINT2(EXC, "SOFTWARE ERROR.  THE COUNT OF PENDING RESPONSES (%d) AS COMPUTED BY THE HandleWrkItm FN DOES NOT MATCH WITH THE EXPECTED ONE (%d)\n\n", cPendingRsp, scPendingRsp);
		WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
	}
#endif
}	
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("HandleWrkItm");

        //
        // if the exception is an nbt error, it is expected if wins is in
        // the paused state.  Do not reraise the exception if this is the
        // case.  We want to go through our WaitRsp() function so that
        // the new records (replicas or registrations) get registered.
        // If this results in an inconsistent db, it will straighten
        // itself out soon after WINS is unpaused.
        //
        //if (!((GetExceptionCode() == WINS_EXC_NBT_ERR) && (WinsCnf.State_e ==
         //         WINSCNF_E_PAUSED) || (fWinsCnfInitStatePaused)))
        {
	   WINS_RERAISE_EXC_M();
        }
#if 0
        else
        {
            //
            // For all requests that were never sent, free them
            //
            for (No=0; No < sMaxTransId; No++, pReqWrkItm++)
            {
                if (pReqWrkItm != NULL)
                {
                  if (pReqWrkItm->pMsg != NULL)
                  {
		   ECommFreeBuff(pReqWrkItm->pMsg);
                  }
		  QueDeallocWrkItm(NmsChlHeapHdl, pReqWrkItm);

                }
            }
#endif
    }  // end of except { .. }

	DBGLEAVE("HandleWrkItm\n");
	return(WINS_SUCCESS);

} // HandleWrkItm()




STATUS
WaitForRsp(
	   VOID
	)

/*++

Routine Description:
	This function is responsible for waiting for responses to all
	requests that have been sent until either they time out or their
	responses are received.

Arguments:
	None

Externals Used:
	None

Return Value:
	WINS_SUCCESS or a failure code.  The function can also raise an
	exception in case of fatal errors

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	HANDLE ThdEvtHdlArray[2];	
    	DWORD  Count 	  = 0;
    	DWORD  TickCntSv;
 	DWORD  TickCnt    = 0;
	DWORD  TimeLeft;
	BOOL   fSignaled  = TRUE;	//was an event signaled
	DWORD  ArrInd     = 0;		//Not used
	DWORD  i 	  = 0;
	NMSMSGF_ERR_CODE_E Rcode_e = NMSMSGF_E_SRV_ERR;
	PCHL_REQ_WRK_ITM_T pReqWrkItm;
	NMSMSGF_RSP_INFO_T RspInfo;
        BOOL               fNewTry = TRUE;

	/*
	 *  Initialize the array of handles on which the challenge thread will
	 *  wait.
	*/
	ThdEvtHdlArray[0]    =  NmsTermEvt;	       //termination event var
	ThdEvtHdlArray[1]    =  QueNmsCrqQueHd.EvtHdl; //work queue event var
	
FUTURES("Remove the try out of production level code")
try {	
	while(TRUE)
	{
            if (fNewTry)
            {
	      //
	      // Get the number of msecs that have
	      // elapsed since windows was started
	      //
	      TickCntSv     = GetTickCount();
	      TimeLeft      = (1 << Count) * WinsCnf.RetryInterval;
            }

	    //
	    // Check if we have exhausted all retries for this batch of
	    // requests
            //
	    if (Count == WinsCnf.MaxNoOfRetries)
	    {
		
		//
		// CleanUp all spReqWrkItmArr entries which have not
		// been satisfied as yet.
		//
		for (i = 0; i < sMaxTransId; i++)
		{	
		   if (spReqWrkItmArr[i] != NULL)
		   {
#ifdef  WINSDBG
                      NmsChlNoNoRsp++;
#endif
		      pReqWrkItm = spReqWrkItmArr[i];

		      //
		      // Decrement the count of addresses to send query or
		      // release  to.
		      //
		      pReqWrkItm->NoOfAddsToUse--;	

		      //
		      //
		      // If there are no more addresses to challenge/release
                      //
		      if (pReqWrkItm->NoOfAddsToUse == 0)
		      {
						
			   //
			   // Just in case the record to register is a UNIQUE
			   // record.  No need to have an if (will add overhead)
			   //
			   pReqWrkItm->NodeToReg.pNodeAdd =
						&pReqWrkItm->AddToReg;
			   //
			   // In case the row we are putting in the database is
			   // one given to use by the Replicator, we don't
			   // need to set Rcode_e.  However, to avoid an if
			   // test, we just set it.  It will remain unused
			   //
                          if (pReqWrkItm->CmdTyp_e != NMSCHL_E_REL_ONLY)
                          {
			      if (
			        ChlUpdateDb(
                                        FALSE,
					pReqWrkItm->Client_e,
					&pReqWrkItm->NodeToReg,
					pReqWrkItm->OwnerIdInCnf,
					FALSE  //not just a refresh
					) ==  WINS_SUCCESS
			         )

			      {
				    DBGPRINT0(CHL, "WaitForRsp:Database Updated\n");
				    //
				    // if the remote WINS has to be notified of
				    // the update, do so
				    //
			             if(pReqWrkItm->CmdTyp_e ==
                                                  NMSCHL_E_REL_N_INF)
				    {
					   InfRemWins(pReqWrkItm);
				
				    }
				    Rcode_e = NMSMSGF_E_SUCCESS;
			      }
			      else
			      {
				     Rcode_e = NMSMSGF_E_SRV_ERR;
				     WINSEVT_LOG_M(
					    WINS_FAILURE,
					    WINS_EVT_CHLSND_REG_RSP_ERR
					     );

				     DBGPRINT0(CHL, "WaitForRsp:Server Error\n");
                              }
			  }
			
			  //
			  // Send a response only if the registration request
			  // was sent by an NBT node
			  //
			  if (
				(pReqWrkItm->Client_e == WINS_E_NMSNMH)
					&&
				(!pReqWrkItm->NodeToReg.fStatic)
					&&
				(!pReqWrkItm->NodeToReg.fAdmin)
			   )
			  {
				RspInfo.pMsg   = pReqWrkItm->pMsg;
				RspInfo.MsgLen = pReqWrkItm->MsgLen;
				RspInfo.QuesNamSecLen =
						pReqWrkItm->QuesNamSecLen;
				RspInfo.Rcode_e = Rcode_e;

				if (Rcode_e == NMSMSGF_E_SUCCESS)
				{
				   EnterCriticalSection(&WinsCnfCnfCrtSec);
				   RspInfo.RefreshInterval =
						WinsCnf.RefreshInterval;
				   LeaveCriticalSection(&WinsCnfCnfCrtSec);
				}
				

			     	NmsNmhSndNamRegRsp(
					&pReqWrkItm->DlgHdl,
					&RspInfo
						  );
			   }

		          //
		          //  deallocate the req  wrk items
		          //
		          QueDeallocWrkItm(NmsChlHeapHdl, pReqWrkItm);

		   }
		   else  // we haven't yet dealt with all the addresses. So,
			 // let us requeue the work item.
		   {

			 //
			 // Reinsert the work item since there are other
			 // addresses that we need to handle in HandleWrkItm()
			 //
             DBGPRINT2(CHL, "WaitForRsp: Name = (%s); NoOfAddsToUse is (%d)\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
			 QueInsertWrkItmAtHdOfList(
						&pReqWrkItm->Head,
						pReqWrkItm->QueTyp_e,
						NULL
						    );

		   }

		   //
		   // Reinit the array entry to obliterate the
		   // possibility of error (see ProcRsp)
		   //
		   spReqWrkItmArr[i] = NULL;
		   scPendingRsp--; //actually there is no need for this
				   //since scPendingRsp will be inited
				   //after dequeing requests

		  } 	// end of if
	        }  	//end of for loop for looping over sReqWrkItm array

	        break; 	//break out of the while(TRUE) loop

	     }
	     else   //count is != WinsCnf.MaxNoOfRetries
	     {

	   	WinsMscWaitTimedUntilSignaled(
			ThdEvtHdlArray,
			sizeof(ThdEvtHdlArray)/sizeof(HANDLE),
			&ArrInd,	
			TimeLeft,
			&fSignaled
			    );

	       //
	       //  if signaled, it means a response item is in the response
	       //  queue.
	       //
	       if (fSignaled)
	       {
					
                  DWORD TicksToSub;

		  //
		  // If signaled for termination, do it
		  //
		  if (ArrInd == 0)
	 	  {
			WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
		  }

		  DBGPRINT0(CHL, "WaitForRsp: Received a response\n");
#ifdef WINSDBG
                  NmsChlNoRspDequeued++;
#endif
		  ProcRsp();	


		  //
		  //  If no responses are expected, break out of loop
		  //
		  if (scPendingRsp == 0)
		  {
			break;  	//break out of the while loop
		  }

	  	  //
	  	  // Get the number of msecs that have
	  	  // elapsed since windows was started
	  	  //
	  	  TickCnt = GetTickCount();

		  //
		  // If there has been a wrap around (will happen every 49.7
		  // days of Windows being up
		  //
		  if (TickCnt < TickCntSv)
		  {
		     TicksToSub = (TickCnt + (MAXULONG - TickCntSv));

		  }
		  else
		  {	
		     TicksToSub = TickCnt - TickCntSv;
		  }

                  //
                  // We don't want to subtract a biger number from a
                  // smaller number.  This will result in a huge value for
                  // TimeLeft making the challenge thread block forever.
                  //
                  if (TimeLeft > TicksToSub)
                  {
			TimeLeft -= TicksToSub;		
                        fNewTry = FALSE;
                  }
                  else
                  {
	    	        Count++;		//increment the count of retries
		        if ( Count != WinsCnf.MaxNoOfRetries)
		        {
			  //
			  // The Retry time interval being over, let us
			  // retry all those requests that did not get
			  // satisfied (i.e. no responses yet)
			  //
			  HandleWrkItm(
					spReqWrkItmArr,
					sMaxTransId,
					TRUE		//it is a retry	
				     );
                          //
                          // We have waited for the entire allowed
                          // wait time.  Time to do a retry
                          //
                          fNewTry = TRUE;
		        }
                  }
	       }
	       else
	       {
	    	  Count++;		//increment the count of retries
		  if ( Count != WinsCnf.MaxNoOfRetries)
		  {
			//
			// The Retry time interval being over, let us
			// retry all those requests that did not get
			// satisfied (i.e. no responses yet)
			//
			HandleWrkItm(
					spReqWrkItmArr,
					sMaxTransId,
					TRUE		//it is a retry	
				     );
                       fNewTry = TRUE;
		  }
	       }
	     }
	
	 }  // end of while (TRUE)
} // end of try ..
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("WaitForRsp");

	//
	// must be some serious error. Reraise the exception
	//
	WINS_RERAISE_EXC_M();

 } // end of except { ..}
	return(WINS_SUCCESS);

}  // WaitForRsp()


STATUS
ProcRsp(
	VOID
	)

/*++

Routine Description:
	This function is called to process one or more work items
	queued on the challenge response queue.

	This response can be to  name query or name release requests sent
	earlier

Arguments:
	None

Externals Used:
	None

	
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
	WaitForRsp()

Side Effects:

Comments:
	None
--*/
{

	DWORD  		       TransId  = 0;
	NMSMSGF_NAM_REQ_TYP_E  Opcode_e   = NMSMSGF_E_NAM_QUERY;
	BYTE		       Name[NMSMSGF_RFC_MAX_NAM_LEN];
	DWORD		       NameLen;
//	COMM_IP_ADD_T	       IPAdd;
	NMSMSGF_CNT_ADD_T      CntAdd;
	NMSMSGF_ERR_CODE_E     Rcode_e;
	PCHL_REQ_WRK_ITM_T     pReqWrkItm;
	STATUS		       RetVal;
	PCHL_RSP_WRK_ITM_T     pRspWrkItm;
	STATUS		       RetStat = WINS_SUCCESS;
	LPBYTE		       pNameToComp;
	DWORD		       NameLenUsedInComp;
	BOOL		       fAdded;
    BOOL               fGroup;

	DBGENTER("ProcRsp\n");
	while (TRUE)
	{
		//dequeue each response and process
		RetVal = QueRemoveChlRspWrkItm(&pRspWrkItm);

		if (RetVal == WINS_NO_REQ)
		{
			break;
		}
		if (
			NmsMsgfUfmNamRsp(
			 	pRspWrkItm->pMsg,
			 	&Opcode_e,
			 	&TransId,
			 	Name,
			 	&NameLen,
			 	&CntAdd,
			 	&Rcode_e,
                &fGroup
					) == WINS_FAILURE
	   	   )
		{

	   		//
			// Throw away response
			//	
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;
		}

        	//
		// Get the request corresponding to the response.
		//	
                if (TransId >= sMaxTransId)
                {
	   		//
			// Throw away response
			//	
                        DBGPRINT3(ERR, "ProcRsp: Rsp: Name = (%s); Transid = (%d), Opcode_e = (%d). Being rejected (TOO LARGE TRANS. ID)\n", Name, TransId, Opcode_e);
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;


                }
		pReqWrkItm = spReqWrkItmArr[TransId];
		if (!pReqWrkItm)
		{
			//
			// Throw this response away
			//
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;
		}	


		//
		// First and foremost check whether the response is for one of
		// the current requests (we want to guard against mismatching
		// the response to a request (the response could be for an old
		// request that is no longer in our spReqWrkItmArr array.
		//	

		
		//
		// Compare the Name and the Opcode from where the
		// response came with the same in the request
		//	
	        pNameToComp       =  pReqWrkItm->NodeToReg.pName;
		NameLenUsedInComp =  pReqWrkItm->NodeToReg.NameLen;

		RetVal = (ULONG) WINSMSC_COMPARE_MEMORY_M(
				       Name,
				       pNameToComp,
				       NameLenUsedInComp
						   );
		if (
		      (RetVal != NameLenUsedInComp )
		      		 ||
		      ( pReqWrkItm->ReqTyp_e != Opcode_e )
		     )
		{
			//
			// Throw this response away
			//
		        DBGPRINT5(ERR, "ProcRsp: Mismatch between response and request. Req/Res Name (%s/%s); ReqType_e/Opcode_e = (%d/%d). TransId = (%d)\n", pNameToComp, Name, pReqWrkItm->ReqTyp_e, Opcode_e, TransId);
		        WINSEVT_LOG_INFO_D_M(
					    WINS_SUCCESS,
					    WINS_EVT_REQ_RSP_MISMATCH
					  );
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;

		}

		//
		// We have a valid response
		//
		DBGPRINT3(CHL, "ProcRsp: (%s) Response is for name = (%s); 16th char (%X)\n", Opcode_e == NMSMSGF_E_NAM_REL ? "RELEASE" : "QUERY", Name, Name[15]);
		//
		// Decrement the count of addresses to send query or release
		// to.  We send query/release to the next address in the list
                // if we get back a negative response to the current one. This
                // is just for extra safety (in case we have one or more
                // addresses in our list that are no longer valid for the name)
		//
		pReqWrkItm->NoOfAddsToUse--;	

		if (Opcode_e == NMSMSGF_E_NAM_REL)
		{
			
			//
			// If there are more addresses for sending the releases
			// to, insert the work item at the head of the queue
			//
			if ( (Rcode_e != NMSMSGF_E_SUCCESS) &&
                                      (pReqWrkItm->NoOfAddsToUse > 0))
			{
		   	   //
		   	   // The request has been processed. Init its
			   // position in the array. Also,
			   // decrement scPendingRsp.
		   	   //
		   	   spReqWrkItmArr[TransId] = NULL;
		   	   scPendingRsp--;

			   //
			   // Now, we have to send the RELEASE to the next
			   // address on the list .  This
			   // request has to be processed in the same
			   // way as all the other requests that are
			   // queued on our request queues (i.e. retry
			   // a certain number of times using a certain
			   // time interval).  Since we are in the
			   // middle of an execution of a batch of
			   // requests, queue this request at the head
			   // of the   next batch of requests.
			   //
             DBGPRINT2(CHL, "ProcRsp: Name = (%s); NoOfAddsToUse is (%d)\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
			   QueInsertWrkItmAtHdOfList(
						&pReqWrkItm->Head,
						pReqWrkItm->QueTyp_e,
						NULL
						);
			   //
			   // Throw the response away
			   //
			   ECommFreeBuff(pRspWrkItm->pMsg);

			   //
			   // deallocate the response buffer
			   //
		   	   QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
			   return(WINS_SUCCESS);
			}	

                        //
                        // Either the name was released or we have exhausted
                        // the list of addresses without getting a positive
                        // release response
                        //

			//
			// Update the database.  Note: There is no need to
			// check the Rcode_e value since even if the release
			// request failed, we will overwrite the entry
			//
                        // A release is sent as a result of a clash during
                        // replication only, so a client id. of WINS_E_RPLPULL
                        // is correct.
                        //

                        if (pReqWrkItm->CmdTyp_e == NMSCHL_E_REL)
                        {
			   pReqWrkItm->NodeToReg.pNodeAdd =
						&pReqWrkItm->AddToReg;
		           if (ChlUpdateDb(
                                        FALSE,
					WINS_E_RPLPULL,
					&pReqWrkItm->NodeToReg,
					pReqWrkItm->OwnerIdInCnf,
					FALSE  //not just a refresh
				       ) != WINS_SUCCESS
			       )
			   {
			   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_UPDATE_DB);
			   DBGPRINT0(CHL, "ProcRsp:COULD NOT UPDATE THE DB AFTER A RELEASE \n");
			   Rcode_e = NMSMSGF_E_SRV_ERR;
			   }
			   else
			   {
				//
				// if the remote WINS has to be notified of
				// the update.
                                //
                                // NOTE: This code won't be executed.
				//
				if(spReqWrkItmArr[TransId]->CmdTyp_e ==
						NMSCHL_E_REL_N_INF)
				{
					InfRemWins(
						spReqWrkItmArr[TransId]
					  	  );
				}
				Rcode_e = NMSMSGF_E_SUCCESS;
			   }
                      }

		}	
		else  // it is a name query response
		{

#ifdef WINSDBG
		  {
		    DWORD i;	
		    for (i=0; i<CntAdd.NoOfAdds;i++)
		    {
			DBGPRINT2(CHL, "ProcRsp: Address (%d) is (%X)\n", (i+1),CntAdd.Add[i].Add.IPAdd);
		    }
		   }
#endif
		
		   //
		   //  if the challenge succeded, we may need
		   //  to update the database
		   //
		   if (Rcode_e != NMSMSGF_E_SUCCESS ||
               pReqWrkItm->fGroupInCnf != fGroup)
		   {
			
			//
			// a negative name query response was received
            // OR Record type (unique vs group) doesn't match
            // (the second check is to consider the case of
            // a node which used the same name first as unique
            // and then as group)
			//

			//
			// If there are no more addresses to query
			//
			if (pReqWrkItm->NoOfAddsToUse == 0)
			{				
			  //
			  // Update the database
			  //
			  pReqWrkItm->NodeToReg.pNodeAdd =
						&pReqWrkItm->AddToReg;
		          if (ChlUpdateDb(
                                FALSE,
				pReqWrkItm->Client_e,
				&pReqWrkItm->NodeToReg,
				pReqWrkItm->OwnerIdInCnf,
				FALSE
				       ) == WINS_SUCCESS
			     )
		          {
		
		             //
			     // Set Rcode_e to SUCCESS
			     //
		       	     Rcode_e = NMSMSGF_E_SUCCESS;
		          }
			  else
			  {
			     Rcode_e = NMSMSGF_E_SRV_ERR;
			     WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_UPDATE_DB);
			  }
		       }
		       else
		       {
				//
				// We need to challenge (query) the next
				// address in the list of addresses
				//
		   	        spReqWrkItmArr[TransId] = NULL;
		   		scPendingRsp--;
			
             DBGPRINT2(CHL, "ProcRsp: Name = (%s); NoOfAddsToUse is (%d)\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
				QueInsertWrkItmAtHdOfList(
							&pReqWrkItm->Head,
							pReqWrkItm->QueTyp_e,
							NULL
							);
				//
				// Throw this response away
				//
				ECommFreeBuff(pRspWrkItm->pMsg);

				//
				// deallocate the response buffer
				//
		   		QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
				return(WINS_SUCCESS);
		       }
		   }
		   else  // positive name query response received
		   {

                         //
                         // if the cmd is CHL_N_REL, we need to now tell
                         // the remote node to release the name.
                         //

                         if (CntAdd.NoOfAdds == 1)
                         {
                           //
                           // Note: the CmdType_e will be CHL_N_REL
                           // only if the client is WINS_E_RPLPULL
                           //
			   if (pReqWrkItm->CmdTyp_e ==  NMSCHL_E_CHL_N_REL)
			   {
                                  DWORD No;

				  //
				  // We need to tell the remote node
				  // release all names.
				  //
				  pReqWrkItm->CmdTyp_e = NMSCHL_E_REL_ONLY;

		   	          spReqWrkItmArr[TransId] = NULL;
		   		  scPendingRsp--;

                                  //
                                  // We need to update the Version
                                  // no of the conflicting entry
                                  //
		          	 (VOID)ChlUpdateDb(
                                                TRUE,  //update vers. no.
						WINS_E_NMSNMH,  //to speed fn up
						&pReqWrkItm->NodeToReg,
						pReqWrkItm->OwnerIdInCnf,
					        FALSE	
				       			);

                                 //
                                 // Tell the remote guy to release
                                 // the name. Copy the addresses of
                                 // into the proper field
                                 //
		                 pReqWrkItm->NoOfAddsToUse =
                                      pReqWrkItm->NodeToReg.NodeAdds.NoOfMems;	
                                 ASSERT(pReqWrkItm->NoOfAddsToUse <= NMSDB_MAX_MEMS_IN_GRP);
                                 for (No=0; No < pReqWrkItm->NoOfAddsToUse; No++)
                                 {
                                        *(pReqWrkItm->NodeAddsInCnf.Mem + No) = *(pReqWrkItm->NodeToReg.NodeAdds.Mem + No);

                                 }
                                 pReqWrkItm->NodeAddsInCnf.NoOfMems
                                                  = pReqWrkItm->NoOfAddsToUse;

                  DBGPRINT2(CHL, "ProcRsp: Name = (%s); NoOfAddsToUse is (%d); request REL_ONLY\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
				  QueInsertWrkItmAtHdOfList(
							&pReqWrkItm->Head,
							pReqWrkItm->QueTyp_e,
							NULL
							);
				  //
				  // Throw this response away
				  //
				  ECommFreeBuff(pRspWrkItm->pMsg);

				  //
				  // deallocate the response buffer
				  //
		   		  QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
				  return(WINS_SUCCESS);
                          }
                        }

			//
			// If more than one address was returned in the
			// query response, it means that the challenged
			// node is a multi-homed node.  Actually, a multihomed
			// node could return just one address too. This is
			// because it might have just come up and the name
			// may not have yet been registered for the multiple
			// adapters.

			//
			// Note: We execute the else code if the
			// record to register is a special group
			//
			if (	
			     !NMSDB_ENTRY_GRP_M(pReqWrkItm->NodeToReg.EntTyp)
			   )
			{
				//
				// Check if we need to update the db
				//
				RetStat = ProcAddList(
						pReqWrkItm,
						&CntAdd,
						&fAdded
						      );	

				if (RetStat == WINS_FAILURE)
				{
				      //
				      // There is atleast one address in the
				      // list to register that is not in the
				      // list of addresses returned.  This means
				      // that at least one of the addresses to
				      // register is not claimed by the node
				      // that responded.  We can not honor
                                      // this registration
				      //

				      //
				      // NAME ACTIVE error
				      //
				      Rcode_e = NMSMSGF_E_ACT_ERR;
				}
				else
				{
			  	  	//
			  		// Update the database
			  		//
			  		pReqWrkItm->NodeToReg.pNodeAdd =
						  &pReqWrkItm->AddToReg;

		          		if (ChlUpdateDb(
                                                FALSE,
						pReqWrkItm->Client_e,
						&pReqWrkItm->NodeToReg,
						pReqWrkItm->OwnerIdInCnf,
						!fAdded
				       			) == WINS_SUCCESS
			     		  )
		          		{
		
		             		   //
			     		   // Set Rcode_e to SUCCESS
			     		   //
		       	     		   Rcode_e = NMSMSGF_E_SUCCESS;
		          		 }
			  		 else
			  		 {
			     			Rcode_e = NMSMSGF_E_SRV_ERR;
			     			WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_UPDATE_DB);
			  		 }

				}
					
			}
CHECK("Should a local multihomed node be told to release the name if it ")
CHECK("with a replica. This is what is done for the local unique/remote unique")
CHECK("name clash.  It seems the right strategy but may need to be rethought")

			else  // entry to register is a group
			{
				//
				// set Rcode_e to Error code
				//
				Rcode_e = NMSMSGF_E_ACT_ERR;
			}
		   }
		}	

		//
		// The request has been processed. Init its position
		// in the array.  Send the response to the waiting node
		// This will free the buffer too.
		//
		//  Also, decrement scPendingRsp.  This was incremented by
		//  HandleWrkItm for each query/release sent.
		//
		spReqWrkItmArr[TransId] = NULL;
		scPendingRsp--;

		//
		// Send a registration response only if the client that
		// submitted the request was an NBT thread.
		//
		if (
                       (pReqWrkItm->Client_e == WINS_E_NMSNMH)
					&&
			(!pReqWrkItm->NodeToReg.fStatic)
					&&
			(!pReqWrkItm->NodeToReg.fAdmin)
                   )
		{
			NMSMSGF_RSP_INFO_T	RspInfo;

			RspInfo.pMsg          = pReqWrkItm->pMsg;
			RspInfo.MsgLen 	      = pReqWrkItm->MsgLen;
			RspInfo.QuesNamSecLen = pReqWrkItm->QuesNamSecLen;
			RspInfo.Rcode_e       = Rcode_e;

			if (Rcode_e == NMSMSGF_E_SUCCESS)
			{
			   EnterCriticalSection(&WinsCnfCnfCrtSec);
			   RspInfo.RefreshInterval = WinsCnf.RefreshInterval;
			   LeaveCriticalSection(&WinsCnfCnfCrtSec);
			  DBGPRINT0(CHL, "ProcRsp: Sending a Positive name registration response\n");
			}
#ifdef WINSDBG
			else
			{
			  DBGPRINT0(CHL, "ProcRsp: Sending a negative name registration response\n");
			}
#endif

			NmsNmhSndNamRegRsp(
			 	        &pReqWrkItm->DlgHdl,
					&RspInfo
			      	          );
			
		}

	        //
	        // Throw this response away
		//
	        ECommFreeBuff(pRspWrkItm->pMsg);

		//
		//  deallocate the req and rsp wrk items
		//
		QueDeallocWrkItm(NmsChlHeapHdl, pReqWrkItm);
		QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
	}

	DBGLEAVE("ProcRsp\n");
	return(WINS_SUCCESS);
} // ProcRsp()



STATUS
ChlUpdateDb(
        BOOL                    fUpdVersNoOfCnfRec,
	WINS_CLIENT_E		Client_e,
	PNMSDB_ROW_INFO_T	pRowInfo,
	DWORD			OwnerIdInCnf,	
	BOOL			fRefreshOnly
	)

/*++

Routine Description:
	This function is called to update the database.  It is called
	by ProcRsp and by ChlThdInitFn when challenge succeeds

Arguments:
	Client_e - id of client that submitted the request
	pRowInfo - info about the record to be inserted

Externals Used:
	None

	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
	WaitForRsp(), ProcRsp()
Side Effects:

Comments:
	None
--*/

{
	NMSDB_STAT_INFO_T   StatInfo;
	STATUS		    RetStat    = WINS_SUCCESS;
        BOOL                fIncVersNo = FALSE;

	DBGENTER("ChlUpdateDb\n");

	//
	// update the time
	//
PERF("We can avoid this call to time, since we called time earlier before we")
PERF("challenge.  In the worst case that time will be off by a 2.5-3")
PERF("unless the thread is preempted for a long time")
PERF("assuming a name challenge and release took place.  In the best case")
PERF("it will be off by 1.25-1.5 secs (if just a challenge).  We can add ")
PERF("1.25 secs to that time  and avoid the overhead of a function call")

	(void)time(&pRowInfo->TimeStamp);

	if (((Client_e == WINS_E_NMSNMH) && !fRefreshOnly) ||
                   fUpdVersNoOfCnfRec)
        {
            fIncVersNo =  TRUE;
        }
	EnterCriticalSection(&NmsNmhNamRegCrtSec);
    if (pRowInfo->OwnerId == NMSDB_LOCAL_OWNER_ID)
    {
        pRowInfo->TimeStamp += WinsCnf.RefreshInterval;
    }
    else
    {
        pRowInfo->TimeStamp += WinsCnf.VerifyInterval;
    }
   try
   {

	//
	// If the client (the one that submitted the challenge request) is
	// an NBT thread, we need to store the new version number.  If the
	// client is the replicator, we use the version number in the
	// record
	//
	if (fIncVersNo)
	{
		pRowInfo->VersNo = NmsNmhMyMaxVersNo;
	}

	StatInfo.OwnerId = OwnerIdInCnf;
	if (*(pRowInfo->pName+15) == 0x1B)
	{
		WINS_SWAP_BYTES_M(pRowInfo->pName, pRowInfo->pName+15);
	}

        //
        // If the vers. no of the local record needs to be updated, do so.
        //
        if (fUpdVersNoOfCnfRec)
        {
            RetStat = NmsDbUpdateVersNo (FALSE, pRowInfo, &StatInfo);
        }
        else
        {
	   RetStat = NmsDbSeekNUpdateRow(
				pRowInfo,
				&StatInfo
			   	     );
        }

	if ((RetStat == WINS_SUCCESS) && (StatInfo.StatCode == NMSDB_SUCCESS))
	{
		//
		// If the client is an NBT thread, we increment the version
		// number since the record we inserted in the db is
		// owned by us (we could also check the owner id here).  If
		// the client is the replicator thread, we don't do anything
		//
		if (fIncVersNo)
		{
			NMSNMH_INC_VERS_COUNTER_M(
				NmsNmhMyMaxVersNo,
				NmsNmhMyMaxVersNo
					    );

			//
			// if fAddChgTrigger is TRUE, we pass RPL_PUSH_PROP
			// as the first parameter. Its value is TRUE. See
			// rpl.h
			//
			RPL_PUSH_NTF_M(
			  (WinsCnf.PushInfo.fAddChgTrigger ? RPL_PUSH_PROP :
				RPL_PUSH_NO_PROP), NULL, NULL, NULL);
		}
	}
	else
	{
		DBGPRINT1(ERR, "ChlUpdateDb: Update of record with name (%s) FAILED\n", pRowInfo->pName);

		RetStat = WINS_FAILURE;
	}
  }
  except (EXCEPTION_EXECUTE_HANDLER)
  {
		DBGPRINTEXC("ChlUpdateDb")
		WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_CANT_UPDATE_DB);
  }
	LeaveCriticalSection(&NmsNmhNamRegCrtSec);

	DBGLEAVE("ChlUpdateDb\n");
	return (RetStat);
} //ChlUpdateDb()


VOID
InfRemWins(
	PCHL_REQ_WRK_ITM_T	pWrkItm
	  )

/*++

Routine Description:

	This function is called when a remote WINS has to be
	told to change the version stamp of a record that was
	pulled by the local WINS at replication.  The need for this
	has arisen because the pulled record collided with a record
	owned by the local WINS (both records being in the active
	state).
	
	
Arguments:
	pWrkItm - the work item that got queued to the name challenge
		  manager

Externals Used:
	None
	
Return Value:
	None

Error Handling:

Called by:
	
	ProcRsp	

Side Effects:

Comments:
	None
--*/
{
	COMM_HDL_T	DlgHdl;
	BYTE		ReqBuff[RPLMSGF_UPDVERSNO_REQ_SIZE];
	LPBYTE		pRspBuff;
	DWORD		ReqBuffLen;
	DWORD		RspBuffLen;
	NMSMSGF_ERR_CODE_E Rcode_e = 0;  //init to 0.  This is initialization
					 //is important since we update
					 //the LSB of Rcode_e with the
					 //the return status
					

	DBGENTER("InfRemWins\n");
try {

	//
	// Log an event since this is an important event to monitor (at
	// least initially)
	//
NONPORT("Change the following for transport independence")
	WINSEVT_LOG_INFO_D_M(pWrkItm->AddOfRemWins.Add.IPAdd,
				WINS_EVT_INF_REM_WINS);

	//
	// Start a dialogue to send the update version number request
	//	

   	//
   	// Init the pEnt field to NULL so that ECommEndDlg (in the
   	// exception handler) called as a result of an exception from
   	// behaves fine.
   	//
   	DlgHdl.pEnt = NULL;

	ECommStartDlg(
		&pWrkItm->AddOfRemWins,
		COMM_E_RPL,
		&DlgHdl	
		     );	


	RplMsgfFrmUpdVersNoReq(
				&ReqBuff[COMM_N_TCP_HDR_SZ],
				pWrkItm->NodeToReg.pName,
				pWrkItm->NodeToReg.NameLen,
				&ReqBuffLen
			      );
					

	//
	// Send the "Update Version number" request
	//
	ECommSndCmd(
			&DlgHdl,
			&ReqBuff[COMM_N_TCP_HDR_SZ],
			ReqBuffLen,
			&pRspBuff,
			&RspBuffLen
			);
	//
	// decipher the reponse to get the result code sent by the
	// remote WINS
	//			
	RplMsgfUfmUpdVersNoRsp(
				pRspBuff + 4,  //past the opcode
				(LPBYTE)&Rcode_e
			      );

	if (Rcode_e != NMSMSGF_E_SUCCESS)
	{
		DBGPRINT0(ERR, "Remote WINS could not update the version no. of its record");
		WINSEVT_LOG_M(pWrkItm->AddOfRemWins.Add.IPAdd, WINS_EVT_REM_WINS_CANT_UPD_VERS_NO);
FUTURES("Take some corrective action -- maybe")

	}

	//
	// deallocate the request and response buffers
	//
#if 0
	WinsMscDealloc(pReqBuff);
#endif
	ECommFreeBuff(pRspBuff - COMM_HEADER_SIZE);

 } // end of try block
		
except (EXCEPTION_EXECUTE_HANDLER) {

	DWORD  ExcCode = GetExceptionCode();
	DBGPRINT1(EXC, "InfRemWins: Got exception (%x)\n", ExcCode );
	if (ExcCode == WINS_EXC_COMM_FAIL)
	{
		DBGPRINT1(ERR, "InfRemWins: Could not inform WINS (%x) that it should update the version number for a record", pWrkItm->AddOfRemWins.Add.IPAdd);	
		//
		//insert a timer request for retrying
		//
		
FUTURES("Incorporate code to insert a timer request so that we can retry")
	}
	else
	{
		//severe error.
		DBGPRINT0(ERR, "InfRemWins: Some severe error was encountered\n");
	}
	WINSEVT_LOG_M(ExcCode, WINS_EVT_INF_REM_WINS_EXC);
   }	
	//
	// End the dialogue
	//
	ECommEndDlg( &DlgHdl );
	
	DBGLEAVE("InfRemWins\n");
	return;

} // InfRemWins()


STATUS
ProcAddList(
	PCHL_REQ_WRK_ITM_T	pReqWrkItm,
	PNMSMSGF_CNT_ADD_T	pCntAdd,
	LPBOOL			pfAdded
	)

/*++

Routine Description:
	
Arguments:
	pWrkItm - the work item that got queued to the name challenge
		  manager
	pCntAdd - List of addresses returned on a query

Externals Used:
	None
	
Return Value:
	None

Error Handling:

Called by:
	
	ProcRsp	

Side Effects:

Comments:
	The function will never be called when the state
	of the entry to register is a TOMBSTONE or if the entry to register
	is a group.

--*/
{	
	DWORD  i, n;
	DWORD  NoOfAddsToReg;
	STATUS RetStat = WINS_SUCCESS;
        PNMSDB_GRP_MEM_ENTRY_T  pMem;
        PCOMM_ADD_T  pAddInRsp;
	
	DBGENTER("ProcAddList\n");
	*pfAdded = FALSE;  //no address of conflicting entry has yet been
			   //added to list of addresses of record to register

	//
	// If the node to register is a unique record
	//
	if (pReqWrkItm->NodeToReg.EntTyp == NMSDB_UNIQUE_ENTRY)
	{
		NoOfAddsToReg = 1;
		pReqWrkItm->NodeToReg.NodeAdds.Mem[0].Add =
						pReqWrkItm->AddToReg;
		pReqWrkItm->NodeToReg.NodeAdds.Mem[0].OwnerId =
						pReqWrkItm->NodeToReg.OwnerId;
		pReqWrkItm->NodeToReg.NodeAdds.Mem[0].TimeStamp =
						pReqWrkItm->NodeToReg.TimeStamp;
		pReqWrkItm->NodeToReg.NodeAdds.NoOfMems = 1;
						
	}
	else  // has to be multihomed (see comment above)
	{
	   NoOfAddsToReg = pReqWrkItm->NodeToReg.NodeAdds.NoOfMems;

	   //
	   // The addresses are already there in NodeToReg.NodeAdds structure
	   //
	
	}

	//
	// If the address(es) to register are not a subset of the addresses
	// returned (i.e. atleast one address to register is not there in
	// the list returned), we return FAILURE.
	//

	//
	// Loop over all addresses to register
	//
	for (i=0; i < NoOfAddsToReg; i++)
	{
		//
		// Compare with each address returned to see if there is
		// a match. Note: pCntAdd->NoOfAdds is > 1 (this function
		// isn't called otherwise).
		//
		for (n=0; n < pCntAdd->NoOfAdds; n++)
		{
PERF("use pointer arithmetic")
			if (pReqWrkItm->NodeToReg.NodeAdds.Mem[i].Add.Add.IPAdd ==
					pCntAdd->Add[n].Add.IPAdd)
			{
				//
				// There is a match, break out so that we can
				// can get to the next address in the list of
				// addresses to register
				//
				break;
			}
		}

		//
		// if there was no match, we have an address to register that
		// either the queried (challenged) node does not have or refuses
		// to divulge to us.  We must reject the registration/refresh
		//
		if (n == pCntAdd->NoOfAdds)
		{
			RetStat = WINS_FAILURE;
			break;
		}
      }

      //
      // The address(es) to register are a subset of the addresses returned
      // by the node (on a query)
      //
      if ( RetStat == WINS_SUCCESS)
      {
       	DWORD Index;

        //
        // Remove those members in the conflicting record that are
        // not in the list returned by the node
        //
	for (
		    i=0, pMem = pReqWrkItm->NodeAddsInCnf.Mem;
			i < min(pReqWrkItm->NodeAddsInCnf.NoOfMems,
				 NMSMSGF_MAX_NO_MULTIH_ADDS);
			i++, pMem++
		    )
        {
		    pAddInRsp =  pCntAdd->Add;
		    for (n=0; n < pCntAdd->NoOfAdds; n++, pAddInRsp++)
		    {
PERF("use pointer arithmetic")
			   if (pMem->Add.Add.IPAdd == pAddInRsp->Add.IPAdd)
			   {
				//
				// There is a match, break out so that we can
				// can get to the next address in the list of
				// addresses in the conflicting record
				//
				break;
			   }
		     }
             if (n == pCntAdd->NoOfAdds)
             {
                //
                // remove the conflicting member from the list
                // This is done by setting its address to NONE.  Later
                // on, we simply won't add this address.
                //
                DBGPRINT3(CHL, "ProcAddList: Removing member (%x) from list of name = (%s)[%x]\n", pMem->Add.Add.IPAdd, pReqWrkItm->NodeToReg.Name, pReqWrkItm->NodeToReg.Name[15]);
                pMem->Add.Add.IPAdd = INADDR_NONE;

             }
        }

        DBGPRINT0(CHL, "ProcAddList: Add conflicting record members\n");

	//
	// The record in conflict has to be ACTIVE
	// (otherwise this function wouldn't have been called -- See
	// the clash functions in nmsnmh.c).  We add all those addresses
	// in the active conflicting record to the list of addresses in
	// the record to register that are not there in it already
	//

	//
	// Add to list of addresses to register all the addresses in
	// the conflicting record.  Note: The conflicting record
	// will not have any address in common with the record
	// to register (common addresses were removed in the clash
	// handling functions of nmsnmh.c via MemInGrp())
	//
	
	//
	// NOTE: the NoOfMems of the NodeAddsInCnf field is guaranteed
	// to be > 0
	//
        //
        // Also NOTE: If the challenged node returned us a list > 25 members
        // long and our list of members to register can no accommodate
        // all the members that need to be added, we will just add those
        // that can be added without violating the NMSMSGF_MAX_NO_MULTIH_ADDS
        // constraint.  The members added could be 0 if we already have
        // the first 25 in our list.  Neverthless we will update our
        // db entry.  This is because some of the conflicting record's
        // members may be old. They will get removed this way (we don't
        // compare the list returned by the challenged node with what is
        // in the conflicting record currently, so old entries will be
        // there until they are scavenged or fall off).
        //
	Index = pReqWrkItm->NodeToReg.NodeAdds.NoOfMems;
	pMem = pReqWrkItm->NodeAddsInCnf.Mem;
	for (   i=0;
		i < min(pReqWrkItm->NodeAddsInCnf.NoOfMems,
				 (NMSMSGF_MAX_NO_MULTIH_ADDS - Index));
			i++, pMem++
	     )
	{
		//
		// we need to add the conflicting record's
		// address into the registering record's
		// list of addresses
		//
                if (pMem->Add.Add.IPAdd != INADDR_NONE)
                {
		  pReqWrkItm->NodeToReg.NodeAdds.Mem[
			 	pReqWrkItm->NodeToReg.NodeAdds.NoOfMems
						] = *pMem;
		  pReqWrkItm->NodeToReg.NodeAdds.NoOfMems++;
                }
	}	
		
	//
	// Setting *pfAdded to TRUE will increment the version number.
	// We do want to increment the version number because
	// the reason we are here means one of the following:
	//
	//  	1)We got a refresh (unique) for an address not in the
	//        conf. rec.
	//	2)We got a registration for an address that is/is not
	// 	  there in the conflicting record.
	//
	//   For the first case above, we definitely want to increment
	//   the version no.  For the second case, it is not strictly
	//   required but is preferable for syncing up entries at
	//   different WINS servers right away.
	//
	*pfAdded = TRUE;

	//
	// If the record to register was a unique record
	// change its type to MULTIHOMED.
	//
	if ( NMSDB_ENTRY_UNIQUE_M(pReqWrkItm->NodeToReg.EntTyp) )
	{
		pReqWrkItm->NodeToReg.EntTyp = NMSDB_MULTIHOMED_ENTRY;
	}

      }

      DBGLEAVE("ProcAddList\n");
      return(RetStat);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\nms.c ===
/*
  Possible improvements

  If there were a way to end all sessions with one Jet call, there would be
  no need to have each nbt thread call WinsMscWaitUntilSignaled. It could simply
  call WaitForSingleObject.
*/

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        nms.c


Abstract:
        This module contains functions used by the name space manager (NMS)

        This is the top-most module of the name space manager component of
        WINS.  It contains functions used for initializing WINS and for
        providing an interface nto NMS to other components to WINS.


Functions:

        main
        WinsMain
        Init
        CreateNbtThdPool
        NbtThdInitFn
        CreateMem
        ENmsHandleMsg
        NmsAllocWrkItm
        NmsDeallocWrkItm
        NmsServiceControlHandler
        SignalWinsThds
        UpdateStatus
        WrapUp



Portability:
        This module is portable across various platforms

Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

#include "wins.h"
#include  <lmerr.h>
#include  <lmcons.h>
#include  <secobj.h>        //required for ACE_DATA
#include "winsif.h"  //required because winsif_v1_0_s_ifspec is being
                     //referenced
#include "winsi2.h"
#ifdef WINSDBG
#include <time.h>
#endif

#include "winscnf.h"
#include "nmsdb.h"
#include "winsque.h"
#include "winsthd.h"
#include "comm.h"
#include "assoc.h"
#include "winsmsc.h"
#include "nms.h"
#include "nmsmsgf.h"
#include "nmschl.h"
#include "nmsnmh.h"
#include "nmsscv.h"
#include "winsevt.h"
#include "winstmm.h"
#include "rplpull.h"
#include "rplpush.h"
#include "winsintf.h"
#include "lmaccess.h"
#include "winswriter.hpp"

/*
 *        Local Macro Declarations
 */
#define NMS_RANGE_SIZE          500
#define NMS_HW_SIZE             400

#define DBG_FILE_MAX_SIZE           1000000  //1 MB
#define DBG_TIME_INTVL_FOR_CHK      1800     //30 mts

/*
 *        Local Typedef Declarations
 */
/*
 *        Global Variable Definitions
 */

WINSTHD_POOL_T          WinsThdPool;              //thread pool for WINS
DWORD                    WinsTlsIndex;              //TLS index for NBT threads
HANDLE                  NmsMainTermEvt;     //For terminating the WINS service
HANDLE                  NmsTermEvt;              //Termination event
HANDLE                  NmsCrDelNbtThdEvt;
CRITICAL_SECTION  NmsTermCrtSec;      //Critical Section guarding count of
                                      //threads
//STATIC CRITICAL_SECTION  sSvcCtrlCrtSec;      //Critical Section guarding service

                                         //controller initiated action


GENERIC_MAPPING          NmsInfoMapping = {
                                        STANDARD_RIGHTS_READ,
                                        STANDARD_RIGHTS_WRITE,
                                        STANDARD_RIGHTS_EXECUTE,
                                        WINS_ALL_ACCESS
                                    };
#ifdef WINSDBG

FUTURES("put all ctrs in a structure")
CRITICAL_SECTION  sDbgCrtSec;

DWORD   NmsGenHeapAlloc;
DWORD   NmsDlgHeapAlloc;
DWORD   NmsTcpMsgHeapAlloc;
DWORD   NmsUdpHeapAlloc;
DWORD   NmsUdpDlgHeapAlloc;
DWORD   NmsQueHeapAlloc;
DWORD   NmsAssocHeapAlloc;
DWORD   NmsRpcHeapAlloc;
DWORD   NmsRplWrkItmHeapAlloc;
DWORD   NmsChlHeapAlloc;
DWORD   NmsTmmHeapAlloc;
DWORD   NmsCatchAllHeapAlloc;

DWORD   NmsHeapAllocForList;

DWORD   NmsGenHeapFree;
DWORD   NmsDlgHeapFree;
DWORD   NmsTcpMsgHeapFree;
DWORD   NmsUdpHeapFree;
DWORD   NmsUdpDlgHeapFree;
DWORD   NmsQueHeapFree;
DWORD   NmsAssocHeapFree;
DWORD   NmsRpcHeapFree;
DWORD   NmsRplWrkItmHeapFree;
DWORD   NmsChlHeapFree;
DWORD   NmsTmmHeapFree;
DWORD   NmsCatchAllHeapFree;

DWORD   NmsHeapCreate;
DWORD   NmsHeapDestroy;


//
// Count of updates (to version number) made by WINS.
//
DWORD   NmsUpdCtrs[WINS_NO_OF_CLIENTS][2][4][3][2];
DWORD   NmsRplUpd;
DWORD   NmsRplGUpd;
DWORD   NmsNmhUpd;
DWORD   NmsNmhGUpd;
DWORD   NmsNmhRelUpd;
DWORD   NmsNmhRelGUpd;
DWORD   NmsScvUpd;
DWORD   NmsScvGUpd;
DWORD   NmsChlUpd;
DWORD   NmsChlGUpd;
DWORD   NmsRpcUpd;
DWORD   NmsRpcGUpd;
DWORD   NmsOthUpd;
DWORD   NmsOthGUpd;

NMS_CTRS_T NmsCtrs;


CRITICAL_SECTION NmsHeapCrtSec;

STATIC        volatile DWORD                 sReqDq = 0;   //for testing only
STATIC        volatile DWORD                 sRegReqDq = 0;   //for testing only
STATIC        volatile DWORD                 sReqQ = 0;     //for testing only
STATIC        volatile DWORD                 sRegReqQ = 0;   //for testing only
STATIC        volatile DWORD                 sRsp = 0;   //for testing only

STATIC   time_t sDbgLastChkTime;


volatile DWORD                 NmsRegReqQDropped = 0;   //for testing only




extern DWORD   NmsGenHeapAlloc;
#endif

PSECURITY_DESCRIPTOR pNmsSecurityDescriptor = NULL;

COMM_ADD_T          NmsLocalAdd = {0};  //My own address
ULONG                  WinsDbg;            //for debugging purposes. see winsdbg.h
/*
 *  NmsTotalTrmThdCnt -- The total number of threads that deal with NmsTermEvt
 *                      event
 *                      These are -- main thread, nbt threads, name challenge thd,
 *                                   scavenger thread, replication threads
 */
DWORD                  NmsTotalTrmThdCnt = 1;  //set to 1 for the main thread
HANDLE                  GenBuffHeapHdl;  //handle to heap for use for queue items
HANDLE                  NmsRpcHeapHdl;  //handle to heap for use  by rpc
DWORD                  NmsNoOfNbtThds         = 0;
BOOL                  fNmsAbruptTerm          = FALSE;
BOOL                  fNmsMainSessionActive = FALSE;

//
// Counter to indicate how many rpc calls that have to do with Jet are
// currently in progress
//
DWORD                 NmsNoOfRpcCallsToDb;

//
// This is set to TRUE to indicate that there are one or more threads
// that have active DB sessions but are not included in the count of
// threads with such sessions.  When this is set to TRUE, the main thread
// will not call JetTerm (from within NmsDbRelRes) due to a limitation
// in Jet.  We take a thread out of the count when it is involved in an
// activity that can take long since we do not want to hold up WINS termination
// for long.  For example, the pull thread is taken out when it is trying
// to establish a connection.
//
BOOL          fNmsThdOutOfReck = FALSE;

#if defined (DBGSVC) || TEST_DATA > 0
HANDLE                    NmsFileHdl = INVALID_HANDLE_VALUE;
HANDLE                    NmsDbgFileHdl = INVALID_HANDLE_VALUE;
#define           QUERY_FAIL_FILE  TEXT("wins.out")
#endif

VERS_NO_T         NmsRangeSize                 = {0};
VERS_NO_T         NmsHalfRangeSize             = {0};
VERS_NO_T         NmsVersNoToStartFromNextTime = {0};
VERS_NO_T         NmsHighWaterMarkVersNo       = {0};

/*
 *        Local Variable Definitions
 */

static BOOL          sfHeapsCreated = FALSE;


static HANDLE           sNbtThdEvtHdlArray[3]; //event array to wait on (NBT thread)
static  BOOL          fsBackupOnTerm = TRUE;

#if REG_N_QUERY_SEP > 0
STATIC HANDLE           sOtherNbtThdEvtHdlArray[2]; //event array to wait on (NBT thread)
#endif

SERVICE_STATUS          ServiceStatus;
SERVICE_STATUS_HANDLE   ServiceStatusHdl;

/*
 *        Local Function Prototype Declarations
*/
#if TEST_DATA > 0 || defined(DBGSVC)
STATIC BOOL
DbgOpenFile(
        LPTSTR pFileNm,
        BOOL   fReopen
        );
#endif

STATIC
STATUS
ProcessInit(
        VOID
);

//
// Create a pool of NBT threads (Threads that service NBT requests)
//
STATIC
STATUS
CreateNbtThdPool(
        IN  DWORD NoOfThds,
        IN  LPTHREAD_START_ROUTINE NbtThdInitFn
        );

//
// Initialize memory for use by NMS
//
STATIC
VOID
CreateMem(
        VOID
        );

//
// Startup function of an NBT thread
//
STATIC
DWORD
NbtThdInitFn(
        IN LPVOID pThreadParam
        );
#if REG_N_QUERY_SEP > 0
//
// Startup function of an NBT thread for registering
//
STATIC
DWORD
OtherNbtThdInitFn(
        IN LPVOID pThreadParam
        );

#endif

//
// Signal all threads inside WINS that have a session with the db engine
//
STATIC
VOID
SignalWinsThds (
        VOID
        );

//
// Update status for the benefit of the service controller
//
STATIC
VOID
UpdateStatus(
    VOID
    );


STATIC
VOID
CrDelNbtThd(
        VOID
        );

//
// Main function of WINS called by the thread that is created for
// listerning to the service controller
//
STATIC
VOID
WinsMain(
  DWORD dwArgc,
  LPTSTR *lpszArgv
);

//
// Responsible for the reinitialization of WINS
//
STATIC
VOID
Reinit(
  WINSCNF_HDL_SIGNALED_E IndexOfHdlSignaled_e
);

//
// Responsible for initializing RPC
//
STATIC
BOOL
InitializeRpc(
    VOID
    );

STATIC
BOOL
InitSecurity(
        VOID
        );
STATIC
VOID
WrapUp(
        DWORD  ErrorCode,
        BOOL   fSvcSpecific
    );

STATIC
VOID
GetMachineInfo(
 VOID
);

//
// The main function
//
VOID __cdecl
main(
     VOID
    )

/*++

Routine Description:
        This is the main function of the WINS server.  It calls the
        StartServiceCtrlDispatcher to connect the main thread of this process
        (executing this function) to the Service Control Manager.


Arguments:
        dwArgc - no. of arguments to this function
        lpszArgv - list of pointers to the arguments

Externals Used:
        WinsCnf

Return Value:
        None

Error Handling:
        Message is printed if DBG ids defined

Called by:
        Startup code

Side Effects:

        None
Comments:
        None
--*/

{
        //
        //WINS server is a service in its own process
        //
        SERVICE_TABLE_ENTRY DispatchTable[] = {
                { WINS_SERVER,  WinsMain },
                { NULL, NULL                  }
                };

        //
        // Set WinsDbg if debugging is turned on
        // Set RplEnabled if Replicator functionality is to be turned on
        // Set ScvEnabled if Scavenging functionality is to be turned on
        //
        DBGINIT;
        DBGCHK_IF_RPL_DISABLED;
        DBGCHK_IF_SCV_DISABLED;
        DBGCHK_IF_PERFMON_ENABLED;


#ifndef WINS_INTERACTIVE
        if (! StartServiceCtrlDispatcher(DispatchTable) )
        {
                DBGPRINT0(ERR, "Main: StartServiceCtrlDispatcher Error\n");
                return;
        }
#else
        WinsMain(1, (LPTSTR *)NULL);
#endif
        return;
}


VOID
WinsMain(
  DWORD  dwArgc,
  LPTSTR *lpszArgv
)

/*++

Routine Description:

        This is the SERVICE_MAIN_FUNCTION of the WINS server.  It
        is called when the service controller starts the service.


Arguments:
        dwArgc   -- no of arguments
        lpszArgc -- argument strings


Externals Used:

        WinsCnf
        NmsTermEvt

Return Value:

        None

Error Handling:

Called by:
        main()

Side Effects:

Comments:
        None
--*/
{
   STATUS           RetStat = WINS_SUCCESS;
#ifndef WINS_INTERACTIVE
   DWORD       Error;
#endif
   HANDLE           ThdEvtHdlArray[WINSCNF_E_NO_OF_HDLS_TO_MONITOR];
   WINSCNF_HDL_SIGNALED_E   IndexOfHdlSignaled_e;//index in the
                                                 //ThdEvtHdlArray of the
                                        //handle that got signaled.  Used as
                                        //an arg to WinsMscWaitUntilSignaled
   DWORD   ExitCode = WINS_SUCCESS;

   UNREFERENCED_PARAMETER(dwArgc);
   UNREFERENCED_PARAMETER(lpszArgv);

   /*
    * Initialize the critical section that guards the
    * NmsTotalTrmThdCnt count  var.
    *
    * NOTE: The initialization of this critical section should occur
    * prior to registering with the service controller.  We are playing
    * it safe just in case in the future SignalWinsThds gets called
    * as part of the cleanup action due to an error that occurs right after
    * we have made ourselves known to the service controller
    *
    * In any case, we must initialize it before calling NmsDbThdInit(). In
    * short it must occue prior to the creation of any thread
    *
   */
   InitializeCriticalSection(&NmsTermCrtSec);

#ifndef WINS_INTERACTIVE
    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    ServiceStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    ServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted        = 0;
    ServiceStatus.dwCheckPoint              = 1;

    //
    // Though 10000 is fine most of the times, for a slow overloaded system,
    // it may not be enough.  Let us be extra conservative and specify
    // 60000 (60 secs). Most of the time is taken by Jet.  In fact, in
    // case the db is corrupted, we will do a restore which can take long.
    // So, add another 60 secs for a grand total of 120000.
    //
FUTURES("Specify 60 secs here and 60secs in nmsdb.c if Restore is to be")
FUTURES("attempted")
    ServiceStatus.dwWaitHint                = 120000;
    ServiceStatus.dwWin32ExitCode           = NO_ERROR;
    ServiceStatus.dwServiceSpecificExitCode = 0;

//    InitializeCriticalSection(&sSvcCtrlCrtSec);
    //
    // Initialize workstation to receive service requests by registering the
    // control handler.
    //
    ServiceStatusHdl = RegisterServiceCtrlHandler(
                              WINS_SERVER,
                              NmsServiceControlHandler
                              );

    if ( ServiceStatusHdl == (SERVICE_STATUS_HANDLE) 0) {
        Error = GetLastError();
               DBGPRINT1(ERR,"Wins: RegisterServiceCtrlHandler error = (%d)\n",
                                                                Error);
        return;
    }

    //
    // Tell Service Controller that we are start pending.
    //
    UpdateStatus();

#endif

#ifdef WINSDBG
        InitializeCriticalSection(&sDbgCrtSec);
#endif
#ifdef WINSDBG
DBGSTART_PERFMON
        fWinsCnfHighResPerfCntr =
                          QueryPerformanceFrequency(&LiWinsCnfPerfCntrFreq);
        if (!fWinsCnfHighResPerfCntr)
        {
                printf("WinsMain: The hardware does not support the high resolution performance monitor\n");
        }
        else
        {
                printf("WinsMain: The hardware supports the high resolution performance monitor.\nThe FREQUENCY is (%d %d)\n",
                                        LiWinsCnfPerfCntrFreq.HighPart,
                                        LiWinsCnfPerfCntrFreq.LowPart
                        );
        }

DBGEND_PERFMON
#endif

try {

    /*
	 First and foremost, open (or create if non-existent) the log file
    */
    WinsCnfInitLog();

    //
    //  Call the initialization function for WINS.  This function will
    //  make the WINS server operational.
    //

#ifdef WINSDBG
    IF_DBG(INIT_BRKPNT)
    {
        DbgUserBreakPoint();
    }
#endif

    RetStat = ProcessInit();

    if ( RetStat != WINS_SUCCESS)
    {

        fNmsAbruptTerm = TRUE;
        WrapUp(RetStat, TRUE);
        DBGPRINT0(ERR, "WinsMain: Initialization Failed\n");
           DBGPRINT0(ERR, "WINS Server has terminated\n");
        return;
    }
#ifndef WINS_INTERACTIVE
    else
    {
        //
        // Tell the service controller that we are up and running now
        //
        ServiceStatus.dwCheckPoint          = 0;
        ServiceStatus.dwCurrentState        = SERVICE_RUNNING;
        ServiceStatus.dwControlsAccepted    = SERVICE_ACCEPT_STOP |
                                              SERVICE_ACCEPT_SHUTDOWN |
                                              SERVICE_ACCEPT_PAUSE_CONTINUE;

        UpdateStatus( );
        if (fWinsCnfInitStatePaused)
        {
           ServiceStatus.dwCurrentState        =  SERVICE_PAUSED;
           UpdateStatus( );
        }

    }

    //
    // If Continue has been sent by the pull thread, it may have been
    // sent while we were in the START_PENDING state.  So, send it again.
    // Sending it again is ok.  We should also send it if we don't have
    // any pnrs to pull from.
    //
    EnterCriticalSection(&RplVersNoStoreCrtSec);
    if ((fRplPullContinueSent) || (WinsCnf.PullInfo.NoOfPushPnrs == 0))
    {
        WinsMscSendControlToSc(SERVICE_CONTROL_CONTINUE);
    }
    LeaveCriticalSection(&RplVersNoStoreCrtSec);
#endif

    //
    // Wait until we are told to stop or when the configuration changes.
    //

    //
    //  Initialize the array of handles on which this  thread will
    //  wait.
    //
    //  K&R C and  ANSI C do not allow non-constant initialization of
    //  an array or a structure.  C++ (not all compilers) allows it.
    //  So, we do it at run time.
    //
    ThdEvtHdlArray[WINSCNF_E_WINS_HDL]        =  WinsCnf.WinsKChgEvtHdl;
    ThdEvtHdlArray[WINSCNF_E_PARAMETERS_HDL]  =  WinsCnf.ParametersKChgEvtHdl;
    ThdEvtHdlArray[WINSCNF_E_PARTNERS_HDL]    =  WinsCnf.PartnersKChgEvtHdl;
    ThdEvtHdlArray[WINSCNF_E_TERM_HDL]        =  NmsMainTermEvt;


FUTURES("I may want to create another thread to do all the initialization and")
FUTURES("wait on the registry change notification key.  That way, the main")
FUTURES("thread will wait only on the TermEvt event. The justification for")
FUTURES("having another thread is debatable, so I am not doing so now ")

     while(TRUE)
     {
            WinsMscWaitUntilSignaled (
               ThdEvtHdlArray,
               sizeof(ThdEvtHdlArray)/sizeof(HANDLE),
               (LPDWORD)&IndexOfHdlSignaled_e,
               TRUE
               );

            if (IndexOfHdlSignaled_e == WINSCNF_E_TERM_HDL)
            {

            DBGPRINT0(FLOW, "WinsMain: Got termination signal\n");

            //
            // Wrap up
            //
            WrapUp(ERROR_SUCCESS, FALSE);
            break;

        }
        else  // registry change notification received. Do reinitialization
        {
           //
           // reinitialize the WINS server according to changes in the
           // registry
           //
           Reinit(IndexOfHdlSignaled_e);
        }
      }
   }
except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("WinsMain");

        //
        // we received an exception.  Set the fNmsAbruptTerm so that
        // JetTerm is not called.
        //
        fNmsAbruptTerm = TRUE;
        //
        // Have an exception handler around this call just in case the
        // WINS or the system is really sick and Wrapup also generates
        // an exception. We are not bothered about performance at this
        // point.
        //
FUTURES("Check into restructuring the exception handlers in a better way")
try {
        WrapUp(GetExceptionCode(), TRUE);
}
except (EXCEPTION_EXECUTE_HANDLER) {
         DBGPRINTEXC("WinsMain");
 }
        ExitCode        = GetExceptionCode();

        WINSEVT_LOG_M(ExitCode, WINS_EVT_ABNORMAL_SHUTDOWN);
  }

#ifndef WINS_INTERACTIVE

    //
    // If it is not one of WINS specific codes, it may be a WIN32 api
    // or NTstatus codes.  Just in case it is an NTStatus codes, convert
    // it to a wins32 code since that is what the Service Controller likes.
    //
    if ((ExitCode & WINS_FIRST_ERR_STATUS) != WINS_FIRST_ERR_STATUS)
    {
        ExitCode = RtlNtStatusToDosError((NTSTATUS)ExitCode);
        ServiceStatus.dwWin32ExitCode = ExitCode;
        ServiceStatus.dwServiceSpecificExitCode = 0;
    }
    else
    {
        ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        ServiceStatus.dwServiceSpecificExitCode = ExitCode;
    }
    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //
    ServiceStatus.dwCurrentState                = SERVICE_STOPPED;
    ServiceStatus.dwControlsAccepted            = 0;
    ServiceStatus.dwCheckPoint                  = 0;
    ServiceStatus.dwWaitHint                    = 0;

    UpdateStatus();
#endif

   DBGPRINT0(ERR, "WINS Server has terminated\n");
   return;
} // end of WinsMain()




STATUS
ProcessInit(
        VOID
)

/*++

Routine Description:

        This is the function that initializes the WINS.  It is executed in
        the main thread of the process

Arguments:
        None


Externals Used:
        None

Called by:
        WinsMain()

Comments:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{
        DWORD NoOfThds;


        /*
         * Initialize the Critical Section used for name registrations and
         * refreshes
        */
        InitializeCriticalSection(&NmsNmhNamRegCrtSec);

        //
        // Initialize the critical section that protects the statistics
        // var. (WinsIntfStat).  This needs to be done here before any
        // thread is created because various threads call WinsIntfSetTime
        // which uses this critical section
        //
        InitializeCriticalSection(&WinsIntfCrtSec);
        InitializeCriticalSection(&WinsIntfPotentiallyLongCrtSec);
        InitializeCriticalSection(&WinsIntfNoOfUsersCrtSec);

#if  TEST_DATA > 0
        //
        // Set WinsDbg so that we don't miss any printfs until we read
        // the registry
        //
        WinsDbg = DBG_ERR | DBG_EXC | DBG_FLOW | DBG_DET | DBG_HEAP_CRDL |
                        DBG_HEAP_CNTRS;

        (VOID)DbgOpenFile(QUERY_FAIL_FILE, FALSE);
#endif
#if defined(DBGSVC) || defined(WINS_INTERACTIVE)
//#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
#ifdef DBG
        (VOID)time(&sDbgLastChkTime);
        (VOID)DbgOpenFile(WINSDBG_FILE, FALSE);
#endif
#endif
        //
        // Initialize the Counter that keeps track of the highest version
        // number registered by this server
        //
        WINS_ASSIGN_INT_TO_LI_M(NmsNmhMyMaxVersNo, 1);
        NmsRangeSize.QuadPart     = NMS_RANGE_SIZE;
        NmsHalfRangeSize.QuadPart = NMS_HW_SIZE;

        NmsVersNoToStartFromNextTime.QuadPart = LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);
        NmsHighWaterMarkVersNo.QuadPart       = LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);

        //
        // The lowest version to start scavenging from
        //
        NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;

        //
        // Initialize the global var. to be used to increment/decrement the
        // above counter by 1.
        //
        WINS_ASSIGN_INT_TO_LI_M(NmsNmhIncNo, 1);

        /*
         * Create Memory Heaps used by the Name Space Manager
        */
        CreateMem();

         /*
         * Allocate a TLS index so that each thread can set and get
         * thread specific info
        */
        WinsTlsIndex = TlsAlloc();

        if (WinsTlsIndex == 0xFFFFFFFF)
        {
                DBGPRINT1(ERR,
                "Init: Unable to allocate TLS index. Error = (%d)\n",
                GetLastError()
                         );
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }

        //
        // Initialize the thread count to 1 (to account for this thread)
        //
        WinsThdPool.ThdCount = 1;


        //
        // Allocate an array of 100 slots to store version numbers
        //
        RplPullAllocVersNoArray( &pRplPullOwnerVersNo, RplPullMaxNoOfWins );

        //
        // Store local machine's ip address in NmsLocalAdd.  We need to
        // do this before calling WinsCnfInitConfig so that we can
        // make sure that this WINS is not listed as its own partner
        // in the registry
        //
        if (ECommGetMyAdd(&NmsLocalAdd) != WINS_SUCCESS)
        {
            WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_BAD_WINS_ADDRESS);
            return(WINS_FAILURE);
        }
        /*
         * Read the configuration information from the registry
         * into in-memory data structures
        */
        WinsCnfInitConfig();

     //   if (fWinsCnfInitStatePaused)
      //  {
       //     NtClose(WinsCnfNbtHandle);
       // }
        //
        // Get machine information
        //
        GetMachineInfo();

        //
        // Update Status
        //
        /*
         * Initialize the Database Manager
        */
        if (NmsDbInit() != WINS_SUCCESS)
        {
                return(WINS_FAILURE);
        }


#ifndef WINS_INTERACTIVE
        //
        // Though 3000 should be ok, let us be extra conservative and
        // specify 30000.  Actually, if DNS is down, it takes around
        // 35 secs for timeout (rpc over tcpip may result in query to
        // WINS if query WINS for resolution check box is checked). So,
        // let us add another 30 secs for that for a total of 60000
        // Throw in another 30 secs for good measure to arrive at a grand
        // total of 120 secs.
        //
        ServiceStatus.dwWaitHint                = 120000;
        ServiceStatus.dwCheckPoint++;
        UpdateStatus();   //inform the service control manager
#endif


        //
        // NOTE: The value of NmsNmhMyMaxVersNo may have been changed by
        // NmsDbInit()
        //

        // If we did not find the version counter value for next time in
        // the registry or if the high water mark is lower than our
        // max. version number, adjust it and the next time start version
        // number and write it to the registry (since we are about to start
        // the worker threads).
        //
        if (!fWinsCnfReadNextTimeVersNo || LiLtr(NmsHighWaterMarkVersNo,
                                                    NmsNmhMyMaxVersNo))
        {
             NmsVersNoToStartFromNextTime.QuadPart =
                         LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);
             NmsHighWaterMarkVersNo.QuadPart       =
                         LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);

             WinsCnfWriteReg(&fWinsCnfReadNextTimeVersNo);
        }

        /*
        *        Create the two event variables used for termination
        */

        //
        // NmsTermEvt is signaled by this main thread to signal all those
        // WINS threads that have db session to wrap up their sessions and
        // terminate
        //
        WinsMscCreateEvt(
                        TEXT("WinsTermEvt"),
                        TRUE,                //Manual Reset
                        &NmsTermEvt
                        );

        /*
         * NmsMainTermEvt -- This event is signaled by the service controller
         * or by another thread in the WINS server to request termination.
        */
        WinsMscCreateEvt(
                        TEXT("WinsMainTermEvt"),
                        FALSE,                //Auto Reset
                        &NmsMainTermEvt
                        );


        /*
         *  Do Static Initialization if required
        */
        if(WinsCnf.fStaticInit)
        {
                   //
                   // Do the initialization and deallocate the memory
                   //
                   if (WinsCnf.pStaticDataFile != NULL)
                   {
                         (VOID)WinsPrsDoStaticInit(
                                        WinsCnf.pStaticDataFile,
                                        WinsCnf.NoOfDataFiles,
                                        TRUE            //do it asynchronously
                                              );
                          //
                          // No need to deallocate memory for data file.
                          // It should have been freed by WinsPrsDoStaticInit
                          //
                   }
        }
        /*
        * Create the nbt request thread pool
        */

        //
        // If the user has not specified the number of threads, use the
        // processor count to determine the same, else use the value given
        // by user.
        //
        if (WinsCnf.MaxNoOfWrkThds == 0)
        {
           NoOfThds = WinsCnf.NoOfProcessors + 1;
        }
        else
        {
           NoOfThds =  WinsCnf.MaxNoOfWrkThds == 1 ? 2 : WinsCnf.MaxNoOfWrkThds;
        }
        CreateNbtThdPool(
                         NoOfThds,
        //                WinsCnf.MaxNoOfWrkThds == 1 ? 2 : WinsCnf.MaxNoOfWrkThds,
                        //WINSTHD_DEF_NO_NBT_THDS,
                        NbtThdInitFn
                        );


        /*
         *Initialize the name challenge manager
        */
        NmsChlInit();


        /*
         * Initialize the Timer Manager
        */
        WinsTmmInit();

        /*
         *Initialize the Replicator. Initialize it before initializing
         * the comm threads or the rpc threads.  This is because, the
         * comm threads and the rpc threads can create the Push thread
         * if it is not-existent.  fRplPushThdExists is set to TRUE or
         * FALSE by this function without the protection of a critical
         * section
        */
        ERplInit();


        /*
         *Initialize the Comm. subsystem
        */
        ECommInit();

        /*
         * Initialize the scavenger code
        */
        NmsScvInit();

        /*
         * All threads have been created.
        */


// We can not mark state as steady state until all threads are in
// steady state
FUTURES("Mark state as STEADY STATE only after the above is true")
        //
        // Mark state as steady state.  This is actually a PSEUDO steady
        // state since all the threads may not have initialized yet. This
        // will however do for rpc threads that need to know whether the
        // critical sections have been initialized or not
        //

        //
        // NOTE: there is no need to enter a critical section here even
        // though there are other threads (rpc threads) reading this since
        // if they find the value to be anything other than RUNNING
        // they will return a failure which is ok for the minute time window
        // where concurrent write and reads are going on
        //
        WinsCnf.State_e = WINSCNF_E_RUNNING;

        //
        // Do all RPC related initialization.
        //
        if (InitializeRpc() == FALSE)
        {
                DBGPRINT0(ERR, "Init: Rpc not initialized properly. Is Rpc service up\n");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_RPC_NOT_INIT);
        }

        NmsDbCloseTables();

        //
        // Log an informational message
        //
        WinsIntfSetTime(NULL, WINSINTF_E_WINS_START);
        WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_WINS_OPERATIONAL);
        DBGPRINT0(DET, "WINS: Operational\n");
        return(WINS_SUCCESS);
}


VOID
ENmsHandleMsg(
        IN  PCOMM_HDL_T pDlgHdl,
        IN  MSG_T        pMsg,
        IN  MSG_LEN_T   MsgLen
        )

/*++

Routine Description:

  This function queues the message either on the nbt request queue or on
  the nbt response queue.


Arguments:

        pDlgHdl - Dialogue handle
        pMsg        - Ptr to message to process
        MsgLen        - Message length


Externals Used:
        None

Called by:
        ParseMsg in comm.c

Comments:
        None

Return Value:
        None
--*/

{

        DWORD fRsp;
        BYTE Opcode = *(pMsg + 2);
        STATUS RetStat;

        /*
        *  Check whether the message is a request or a response
        */
        fRsp = NMS_RESPONSE_MASK & Opcode;

        if (!fRsp)
        {

           if ((WinsCnf.State_e == WINSCNF_E_PAUSED)  || fWinsCnfInitStatePaused)
           {
              //
              // Don't even let the queries go through since
              // the InitTimePaused state is meant for building
              // up the db while the backup handles the load
              // This way clients time out and try the backup.
              // If we let queries through, clients may get
              // back -ve query responses and will not go to
              // the backup for the name resolution
              //
              ECommFreeBuff(pMsg);
              ECommEndDlg(pDlgHdl);
              return;
           }
           DBGPRINT0(FLOW,
              "ENmsHandleMsg: Listener thread: queuing a work item\n");
#if REG_N_QUERY_SEP > 0
           if (((NMS_OPCODE_MASK & Opcode) >> 3) == NMSMSGF_E_NAM_QUERY)
           {
              QueInsertNbtWrkItm(pDlgHdl, pMsg, MsgLen);
#ifdef WINSDBG
              sReqQ++;
#endif
           }
           else
           {
              RetStat = QueInsertOtherNbtWrkItm(pDlgHdl, pMsg, MsgLen);

#ifdef WINSDBG
              sRegReqQ++;
#endif
           }
#else
              QueInsertNbtWrkItm(pDlgHdl, pMsg, MsgLen);
              sReqQ++;
#endif
        }
        else
        {
           DBGPRINT0(FLOW,
                 "UDP listener thread: queuing a response work item\n");
           QueInsertChlRspWrkItm(pDlgHdl, pMsg, MsgLen);
#ifdef WINSDBG
           sRsp++;
#endif
        }

        return;
}



VOID
CreateMem(
        VOID
        )

/*++

Routine Description:

        This function creates the heap that is used for allocating work
        items for the NBT work queues.  It also creates a heap for general
        allocation.

Arguments:
        None


Externals Used:
        GenBuffHeapHdl, QueBuffHeapHdl


Return Value:
        None

Error Handling:

Called by:
        Init

Side Effects:

Comments:
        None
--*/

{

#ifdef WINSDBG
        InitializeCriticalSection(&NmsHeapCrtSec);
#endif
        /*
         * Create heap for general allocation of memory
        */
        DBGPRINT0(HEAP_CRDL, "CreateMem: Gen. Buff Heap\n");
        GenBuffHeapHdl = WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */
                GEN_INIT_BUFF_HEAP_SIZE
                );

        /*
         * Create heap for allocating nbt work items
        */
        DBGPRINT0(HEAP_CRDL, "CreateMem: Que. Buff Heap\n");
        QueBuffHeapHdl = WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */
                QUE_INIT_BUFF_HEAP_SIZE
                );

        /*
         * Create heap for  rpc use
        */
        DBGPRINT0(HEAP_CRDL, "CreateMem: Rpc. Buff Heap\n");
        NmsRpcHeapHdl = WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */
                RPC_INIT_BUFF_HEAP_SIZE
                );


        //
        // Let us set the flag looked at by WrapUp()
        //
        sfHeapsCreated = TRUE;
        return;
}


STATUS
CreateNbtThdPool(
        IN  DWORD                    NoOfThds,
        IN  LPTHREAD_START_ROUTINE NbtThdInitFn
        )

/*++

Routine Description:
        This function creates the nbt request thread pool

Arguments:
        NoOfThds     -- No. of threads to create
        NbtThdInitFn -- Initialization function for the threads


Externals Used:
        QueNbtWrkQueHd, sNbtThdEvtHdlArray

Called by:
        Init

Comments:
        None

Return Value:

   Success status codes --  Function should never return for a normal
                            thread.  It returns WINS_SUCCESS for an
                            overload thread

   Error status codes   --  WINS_FATAL_ERR

--*/


{

        DWORD              i;                 //counter for the number of threads
        DWORD             Error;
        PLIST_ENTRY  pHead;

#if REG_N_QUERY_SEP > 0
        pHead = &QueOtherNbtWrkQueHd.Head;

        /*
         * Initialize the critical section that protects the
         * nbt req. queue
        */
        InitializeCriticalSection(&QueOtherNbtWrkQueHd.CrtSec);

        /*
        * Initialize the listhead for the nbt request queue
        */
        InitializeListHead(pHead);

        /*
        *  Create an auto-reset event for the nbt request queue
        */
        WinsMscCreateEvt(
                        NULL,   //create without name
                        FALSE,  //auto-reset var.
                        &QueOtherNbtWrkQueHd.EvtHdl
                        );

#endif
        pHead = &QueNbtWrkQueHd.Head;

        /*
         * Initialize the critical section that protects the
         * nbt req. queue
        */
        InitializeCriticalSection(&QueNbtWrkQueHd.CrtSec);

        /*
        * Initialize the listhead for the nbt request queue
        */
        InitializeListHead(pHead);

        /*
        *  Create an auto-reset event for the nbt request queue
        */
        WinsMscCreateEvt(
                        NULL,   //create without name
                        FALSE,  //auto-reset var.
                        &QueNbtWrkQueHd.EvtHdl
                        );

        /*
        *  Create an auto-reset event for the dynamic creation/deletion of
        *  Nbt threads.
        */
        WinsMscCreateEvt(
                        NULL,   //create without name
                        FALSE,  //auto-reset var.
                        &NmsCrDelNbtThdEvt
                        );

        /*
         *  Initialize the array of handles on which each nbt thread will
         *  wait.
        */
        sNbtThdEvtHdlArray[0]    =  QueNbtWrkQueHd.EvtHdl; //work queue event
                                                           //var
        sNbtThdEvtHdlArray[1]    =  NmsCrDelNbtThdEvt; //
        sNbtThdEvtHdlArray[2]    =  NmsTermEvt;             //termination event var
#if REG_N_QUERY_SEP > 0
        /*
         *  Initialize the array of handles on which each nbt reg. thread will
         *  wait.
        */
        sOtherNbtThdEvtHdlArray[0]  =  QueOtherNbtWrkQueHd.EvtHdl; //work queue event
                                                              //var
        sOtherNbtThdEvtHdlArray[1]  =  NmsTermEvt;     //termination event var
#endif

        /*
         * Create the nbt request handling threads
        */
        for (i=0; i < NoOfThds -1; i++)
        {

#if REG_N_QUERY_SEP > 0
                DBGPRINT1(DET, "CreateNbtThdPool: Creating query thread no (%d)\n", i);
#else
                DBGPRINT1(DET, "NbtThdInitFn: Creating worker thread no (%d)\n", i);
#endif
                /*
                  Create an NBT req thread
                */
                WinsThdPool.NbtReqThds[i].ThdHdl = CreateThread(
                                        NULL,  /*def sec. attributes*/
                                        0,     /*use default stack size*/
                                        NbtThdInitFn,
                                        NULL,  /*no arg*/
                                        0,     /*run it now*/
                                        &WinsThdPool.NbtReqThds[i].ThdId
                                        );


                if (NULL == WinsThdPool.NbtReqThds[i].ThdHdl)
                {
                        Error = GetLastError();
                        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_WRK_THD);
                }
                else
                {
                    WinsThdPool.NbtReqThds[i].fTaken = TRUE;
                    NmsNoOfNbtThds++;
                }

        }

#if REG_N_QUERY_SEP > 0
        DBGPRINT1(DET, "NbtThdInitFn: Creating reg/rel thread no (%d)\n", i);
        /*
                  Create an NBT req thread
        */
        WinsThdPool.NbtReqThds[i].ThdHdl = CreateThread(
                                        NULL,  /*def sec. attributes*/
                                        0,     /*use default stack size*/
                                        OtherNbtThdInitFn,
                                        NULL,  /*no arg*/
                                        0,     /*run it now*/
                                        &WinsThdPool.NbtReqThds[i].ThdId
                                        );


        if (NULL == WinsThdPool.NbtReqThds[i].ThdHdl)
        {
                  Error = GetLastError();
                  WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_WRK_THD);
        }
        else
        {
                WinsThdPool.NbtReqThds[i].fTaken = TRUE;
                NmsNoOfNbtThds++;
        }
#endif
        /*
        * if no thread could be created, there is something really wrong
        */
        if (NmsNoOfNbtThds == 0)
        {
          WINSEVT_LOG_M(Error, WINS_EVT_CANT_INIT);
          return(WINS_FATAL_ERR);
        }
        WinsThdPool.ThdCount +=  NmsNoOfNbtThds;

        return(WINS_SUCCESS);
}



DWORD
NbtThdInitFn(
        IN  LPVOID pThreadParam
        )

/*++

Routine Description:

        This function is the startup function of threads created
        for the nbt request thread pool

Arguments:
        pThreadParam  - Input argument which if present indicates that this
                        is an overload thread


Externals Used:
        sNbtThdEvtHdlArray

Called by:
        CreateNbtThdPool
Comments:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{



        COMM_HDL_T                    DlgHdl;
        MSG_T                     pMsg;
        MSG_LEN_T                  MsgLen;
        PNBT_REQ_WRK_ITM_T        pWrkItm;
        DWORD                        ArrInd;        //Index of hdl in hdl array
try {
        /*
         *  Initialize the thread with the database
        */
        NmsDbThdInit(WINS_E_NMSNMH);
#if REG_N_QUERY_SEP > 0
        DBGMYNAME("Nbt Query Thread");
#else
        DBGMYNAME("Nbt Thread");
#endif

        //
        // The worker thread is more important that all other threads.
        //
        // Set the priority of this thread to one level above what it is
        // for WINS.
        //
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

        /*
         * if thread param is NON-NULL, then it means that this is
         * an overload thread
        */
        if (pThreadParam != NULL)
        {

           //
           //Exract the dlg handle, message and msglen from work item
           //
           pWrkItm = pThreadParam;

           DlgHdl = pWrkItm->DlgHdl;
           pMsg   = pWrkItm->pMsg;
           MsgLen = pWrkItm->MsgLen;

           /*
            *        process the request
           */
           NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                        );

           /*
            *        Loop until there are no more requests to process in
            *        the NBT queue.
           */
           while(TRUE)
           {

             if ( QueRemoveNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                )
             {
                break;
             }
             else
             {
                NmsDbOpenTables(WINS_E_NMSNMH);
                NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                                 );
                NmsDbCloseTables();
             }
          }
        }
        else // this is a normal thread
        {

LOOP:
  try {
          /*
           *loop forever
          */
          while(TRUE)
          {

            /*
             *        Block until signaled
            */
            WinsMscWaitUntilSignaled(
                sNbtThdEvtHdlArray,
                sizeof(sNbtThdEvtHdlArray)/sizeof(HANDLE),   //no of events
                                                             //in array
                &ArrInd,
                FALSE
                                    );


           if (ArrInd == 0)
           {
             /*
                Loop until there are no more requests to process in
                the NBT queue.
             */
             while(TRUE)
             {

                if (
                   QueRemoveNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                  )
                {
                    break;
                }
                else
                {
#ifdef WINSDBG
                    ++sReqDq;
#endif
//                    DBGPRINT1(SPEC, "Nms: Dequeued Name Query Request no = (%d)\n",
//                                        sReqDq);

                    DBGPRINT0(FLOW, "NBT thread: Dequeued a Request\n");
                    NmsDbOpenTables(WINS_E_NMSNMH);
                    NmsMsgfProcNbtReq(
                                &DlgHdl,
                                pMsg,
                                MsgLen
                                    );
                    NmsDbCloseTables();
                } // end of else
            } // end of while (TRUE)  for getting requests from the queue
          } // end of if (signaled for name request handling)
          else
          {
                //
                // If signaled for creating/deleting threads, do so
                //
                if (ArrInd == 1)
                {
                        CrDelNbtThd();
                }
                else
                {
                      //
                      //  If Array Index indicates termination event, terminate the
                      //  the thread
                      //
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                }
          }
         } // end of while (TRUE) (never ending loop)

 }  // end of inner try {..}
 except(EXCEPTION_EXECUTE_HANDLER) {

        DWORD ExcCode = GetExceptionCode();
        DBGPRINTEXC("NbtThdInitFn: Nbt Thread \n");

        //
        // If ExcCode indicates NBT_ERR, it could mean that
        // the main thread closed the netbt handle
        //
        if (ExcCode == WINS_EXC_NBT_ERR)
        {
               if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
               {
                  WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
               }
               else
               {
                  //if (WinsCnf.State_e != WINSCNF_E_PAUSED)
                  {
                       WINSEVT_LOG_M(ExcCode, WINS_EVT_WRK_EXC);
                  }
               }
        }
        else
        {
           WINSEVT_LOG_M(ExcCode, WINS_EVT_WRK_EXC);
        }
    }

        goto LOOP;
        } // end of else (this is a normal thread)
  } // end of outer try block

except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("NbtThdInitFn: Nbt Thread exiting abnormally\n");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_WRK_ABNORMAL_SHUTDOWN);

        //
        // If NmsDbThdInit() results in an exception, it is possible
        // that the session has not yet been started.  Passing
        // WINS_DB_SESSION_EXISTS however is ok
        //
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
        }

        /*
         *Only an overload thread should reach this return
        */
        ASSERT(pThreadParam != NULL);
        WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
        return(WINS_SUCCESS);
}
#if REG_N_QUERY_SEP > 0
DWORD
OtherNbtThdInitFn(
        IN  LPVOID pThreadParam
        )

/*++

Routine Description:

        This function is the startup function of threads created
        for the nbt request thread pool

Arguments:
        pThreadParam  - Input argument which if present indicates that this
                        is an overload thread


Externals Used:
        sNbtThdEvtHdlArray

Called by:
        CreateNbtThdPool
Comments:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{



        COMM_HDL_T                    DlgHdl;
        MSG_T                     pMsg;
        MSG_LEN_T                  MsgLen;
        PNBT_REQ_WRK_ITM_T        pWrkItm;
        DWORD                        ArrInd;        //Index of hdl in hdl array
try {
        /*
         *  Initialize the thread with the database
        */
        NmsDbThdInit(WINS_E_NMSNMH);
        DBGMYNAME("Nbt Reg Thread");

        //
        // The worker thread is more important that all other threads.
        //
        // Set the priority of this thread to one level above what it is
        // for WINS.
        //
//        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

        /*
         * if thread param is NON-NULL, then it means that this is
         * an overload thread
        */
        if (pThreadParam != NULL)
        {

           //
           //Exract the dlg handle, message and msglen from work item
           //
           pWrkItm = pThreadParam;

           DlgHdl = pWrkItm->DlgHdl;
           pMsg   = pWrkItm->pMsg;
           MsgLen = pWrkItm->MsgLen;

           /*
            *        process the request
           */
           NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                        );

           /*
            *        Loop until there are no more requests to process in
            *        the NBT queue.
           */
           while(TRUE)
           {

             if ( QueRemoveOtherNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                )
             {
                break;
             }
             else
             {
                NmsDbOpenTables(WINS_E_NMSNMH);
                NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                                 );
                NmsDbCloseTables();
             }
          }
        }
        else // this is a normal thread
        {

LOOP:
  try {
          /*
           *loop forever
          */
          while(TRUE)
          {

            /*
             *        Block until signaled
            */
            WinsMscWaitUntilSignaled(
                sOtherNbtThdEvtHdlArray,
                sizeof(sOtherNbtThdEvtHdlArray)/sizeof(HANDLE),   //no of events
                                                             //in array
                &ArrInd,
                FALSE
                                    );


           if (ArrInd == 0)
           {
             /*
                Loop until there are no more requests to process in
                the NBT queue.
             */
             while(TRUE)
             {

                if (
                   QueRemoveOtherNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                  )
                {
                    break;
                }
                else
                {
#ifdef WINSDBG
                    ++sRegReqDq;
#endif
//                    DBGPRINT1(SPEC, "Nms: Dequeued Name Reg/Rel Request no = (%d)\n",
//                                        sRegReqDq);

                    DBGPRINT0(FLOW, "NBT thread: Dequeued a Request\n");
                    NmsDbOpenTables(WINS_E_NMSNMH);
                    NmsMsgfProcNbtReq(
                                &DlgHdl,
                                pMsg,
                                MsgLen
                                    );
                    NmsDbCloseTables();
                } // end of else
            } // end of while (TRUE)  for getting requests from the queue
          } // end of if (signaled for name request handling)
          else
          {
                      //
                      //  If Array Index indicates termination event, terminate the
                      //  the thread
                      //
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
          }
         } // end of while (TRUE) (never ending loop)

 }  // end of inner try {..}
 except(EXCEPTION_EXECUTE_HANDLER) {

        DWORD ExcCode = GetExceptionCode();
        DBGPRINTEXC("OtherNbtThdInitFn: Nbt Reg/Rel Thread \n");

        //
        // If ExcCode indicates NBT_ERR, it could mean that
        // the main thread closed the netbt handle
        //
        if (ExcCode == WINS_EXC_NBT_ERR)
        {
               if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
               {
                  WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
               }
               else
               {
                  //if (WinsCnf.State_e != WINSCNF_E_PAUSED)
                  {
                       WINSEVT_LOG_M(ExcCode, WINS_EVT_WRK_EXC);
                  }
               }
        }
    }

        goto LOOP;
        } // end of else (this is a normal thread)
  } // end of outer try block

except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("NbtThdInitFn: Nbt Reg Thread exiting abnormally\n");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_WRK_ABNORMAL_SHUTDOWN);

        //
        // If NmsDbThdInit() results in an exception, it is possible
        // that the session has not yet been started.  Passing
        // WINS_DB_SESSION_EXISTS however is ok
        //
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
        }

        /*
         *Only an overload thread should reach this return
        */
        ASSERT(pThreadParam != NULL);
        WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
        return(WINS_SUCCESS);
}

#endif

VOID
SignalWinsThds (
        VOID
        )

/*++

Routine Description:
        This function is called to terminate all threads in the process.


Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsMain()
Side Effects:

Comments:
        None
--*/
{
        time_t  ThdTermStartTime;
        DBGENTER("SignalWinsThds\n");

        //
        // Close the udp and tcp sockets
        //
        WinsCnf.State_e = WINSCNF_E_TERMINATING;

        //
        // Signal the manual-reset event variable NmsTermEvt.  This
        // should signal all threads that deal with the db
        //
        // makes sure to set the Nbt handle to NULL to avoid NtClose() to be called from ECommGetMyAdd
        // on a closed handle - this would result in raising an exception. (bug #86768)
        //
        NtClose(WinsCnfNbtHandle);
        WinsCnfNbtHandle = NULL;

        SetEvent(NmsTermEvt);

#if USENETBT == 0
        closesocket(CommUdpPortHandle);
#else
#if MCAST > 0
        CommSendMcastMsg(COMM_MCAST_WINS_DOWN);
        CommLeaveMcastGrp();
        closesocket(CommUdpPortHandle);
#endif
#endif
        //
        // Just in case we are terminating before having created the socket
        //
        if (CommTcpPortHandle != INVALID_SOCKET)
        {
           CommDisc(CommTcpPortHandle, FALSE);
        }

#define FIVE_MTS  300          //seconds
        //
        // This is an infinite loop.
        //
        (VOID)time(&ThdTermStartTime);
        while(TRUE)
        {
                time_t  CurrTime;
                DWORD   TrmThdCnt;
                //
                // If all threads that deal with the db have terminated
                // break out of the loop.
                //
                // It is possible that WINS is terminating during
                // initialization itself.  The Counter is incremented
                // in NmsDbThdInit() as each thread that has to deal with the
                // db engine initializes itself with it.
                //
                // If NmsTotalTrmThdCnt is <=1 break.  The count can go
                // lower than 1 if a db thread is terminating without having
                // incremented the above counter
                //
                EnterCriticalSection(&NmsTermCrtSec);
                TrmThdCnt = NmsTotalTrmThdCnt;
                LeaveCriticalSection(&NmsTermCrtSec);
                if ((TrmThdCnt <= 1) || fNmsAbruptTerm)
                {
                        break;
                }

                if (((CurrTime = time(NULL)) - ThdTermStartTime) < FIVE_MTS)
                {
                  //
                  // Wait until signaled (when all threads have or are about
                  // to terminate)
                  //
                  DBGPRINT1(DET, "SignalWinsThds: Thd count left (%d)\n", TrmThdCnt);
                  WinsMscWaitInfinite(NmsMainTermEvt);
                }
                else
                {
                     DBGPRINT1(ERR, "SignalWinsThds: Thd count left (%d); BREAKING OUT DUE TO ONE HOUR DELAY\n", TrmThdCnt);
                     WINSEVT_LOG_M(WINS_EVT_TERM_DUE_TIME_LMT, TrmThdCnt);
                     break;
                }
        }

        //
        // End the Db Session for this thread (main thread).
        //
        if (fNmsMainSessionActive)
        {
                NmsDbEndSession();
        }


FUTURES("Check state of WINS. If Rpc has been initialized or maybe even")
FUTURES("otherwise, call RpcEpUnRegister")


        DBGLEAVE("SignalWinsThds\n");
        return;
} // SignalWinsThds()



VOID
UpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the workstation service status with the Service
    Controller.

Arguments:

    None.

Return Value:

   None

--*/
{
    DWORD Status = NO_ERROR;


    if (ServiceStatusHdl == (SERVICE_STATUS_HANDLE) 0) {
        DBGPRINT0(ERR, "WINS Server: Cannot call SetServiceStatus, no status handle.\n");
        return;
    }

    if (! SetServiceStatus(ServiceStatusHdl, &ServiceStatus))
    {
        Status = GetLastError();
        DBGPRINT1(ERR, " WINS Server: SetServiceStatus error %lu\n", Status);
    }

    return;
} //UpdateStatus()



VOID
NmsServiceControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Wins service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
             service to perform.

Return Value:

    None.

--*/
{
    BOOL  fRet = FALSE;
//    EnterCriticalSection(&sSvcCtrlCrtSec);
try {
     switch (Opcode)
     {

        case SERVICE_CONTROL_SHUTDOWN:
              //
              // Backup can take a long time to execute.  If the service
              // controller kills us in the middle, it will mess up the
              // backup. So, let us disable it.
              //
              fsBackupOnTerm = FALSE;
        case SERVICE_CONTROL_STOP:

            DBGPRINT1(DET, "NmsServiceControlHandler: %s Signal received\n", Opcode == SERVICE_CONTROL_STOP ? "STOP" : "SHUTDOWN");
            if (ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING)
            {

                ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
                ServiceStatus.dwCheckPoint   = 1;

                //
                // We keep a high wait time (5 mts) to take care of the
                // case where the replicator pull thread is busy trying
                // to set up communication with partners that are not
                // up.  Tcpip stack takes around a minute and a half to come
                // back in case of failure. Also, WINS might have to do
                // backup on termination.
                //
                ServiceStatus.dwWaitHint     = 300000;

                //
                // Send the status response.
                //
                UpdateStatus();


                WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_ORDERLY_SHUTDOWN);
                //
                // Signal the main thread
                //
                if (! SetEvent(NmsMainTermEvt))
                {

                   //
                   // Problem with setting event to terminate Workstation
                   // service.
                   //
                   DBGPRINT1(ERR,
               "Service Control Handler: Error signaling NmsMainTermEvt %lu\n",
                              GetLastError());

                }

                fRet = TRUE;
            }
            break;

        case SERVICE_CONTROL_PAUSE:
                if (WinsCnf.State_e == WINSCNF_E_RUNNING)
                {
                   DBGPRINT0(DET,"NmsServiceControlHandler: Pausing WINS\n");
                   WinsCnf.State_e =  WINSCNF_E_PAUSED;
//                   NtClose(WinsCnfNbtHandle);
//                   SndQueryToLocalNetbt();
                   //CommDisc(CommTcpPortHandle);
                }
                ServiceStatus.dwCurrentState = SERVICE_PAUSED;
                break;
        case SERVICE_CONTROL_CONTINUE:
                //
                // If the state is paused as a result of a pause from the sc
                // or if it is paused as a result of a registry directive,
                // we need to unpause it
                //
                if (
                       (WinsCnf.State_e == WINSCNF_E_PAUSED)
                                 ||
                       fWinsCnfInitStatePaused
                   )
                {

                   //
                   // If paused as a result of sc directive, open nbt since
                   // we closed it earlier.  Note: We can have a case where
                   // WINS was init time paused and then it got a pause from
                   // sc.  The state would have then changed from RUNNING to
                   // PAUSED.
                   //
                   if (fWinsCnfInitStatePaused)
                   {
                         fWinsCnfInitStatePaused = FALSE;
                   }
                  //  CommCreateUdpThd();
                   // CommCreateTcpThd();
                    WinsCnf.State_e = WINSCNF_E_RUNNING;
                    ServiceStatus.dwCurrentState = SERVICE_RUNNING;
                }
                break;
        case SERVICE_CONTROL_INTERROGATE:
            break;

        //
        // Service specific command
        //
        case WINS_ABRUPT_TERM:
                fNmsAbruptTerm = TRUE;

                //
                // Signal the main thread
                //
                if (! SetEvent(NmsMainTermEvt))
                {

                    //
                    // Problem with setting event to terminate Workstation
                    // service.
                    //
                    DBGPRINT1(ERR,
                "Service Control Handler: Error signaling NmsMainTermEvt for abrupt termination. Error = %lu\n",
                               GetLastError());

                }
                fRet = TRUE;
                break;

        default:
            break;
    }
}
  except(EXCEPTION_EXECUTE_HANDLER) {
           DBGPRINTEXC("NmsServiceControlHandler");
    }
//    LeaveCriticalSection(&sSvcCtrlCrtSec);

    if (!fRet)
    {
       //
       // Send the status response.
       //
       UpdateStatus();
    }
    return;
} //NmsServiceControlHandler


VOID
Reinit(
        WINSCNF_HDL_SIGNALED_E IndexOfHdlSignaled_e
  )

/*++

Routine Description:
        This function is called whenever the configuration of the WINS changes.

Arguments:
        None

Externals Used:
        WinsCnf

Return Value:
        None

Error Handling:

Called by:
        WinsMain

Side Effects:

Comments:
--*/

{
        PWINSCNF_CNF_T        pWinsCnf;
        DBGENTER("Reinit\n");
try {

        if (IndexOfHdlSignaled_e == WINSCNF_E_WINS_HDL)
        {

                // request notification for any subsequent changes (we have
                // to request changes every time we get a notification if we
                // want notification of further changes).
                //
                WinsCnfAskToBeNotified(WINSCNF_E_WINS_KEY);

                //
                // Maybe a key has been created or deleted
                //
                WinsCnfOpenSubKeys();
                DBGLEAVE("Reinit\n");
                return;
        }
        //
        // If either PULL or PUSH information has changed, copy the
        // read the new data from the registry and inform the
        // replicator
        //
        if  (IndexOfHdlSignaled_e == WINSCNF_E_PARTNERS_HDL)
        {
                WinsCnfAskToBeNotified(WINSCNF_E_PARTNERS_KEY);

                //
                // Allocate the WinsCnf structure
                //
                WinsMscAlloc(
                        sizeof(WINSCNF_CNF_T),
                        &pWinsCnf
                    );

                //
                // Read the Partner information
                //
                WinsCnfReadPartnerInfo(pWinsCnf);

                //
                // Copy some (not all) of the configuration information into
                // the global WinsCnf structure. Sanity check of the
                // parameters will be done by this function and the
                // scavenger thread will be signaled if required.
                //
                WinsCnfCopyWinsCnf(WINS_E_RPLPULL, pWinsCnf);


                //
                // Send the reconfig message to the Pull thread
                //
                // Note: The PULL thread will deallocate memory pointed
                // to be pWinsCnf when it gets done
                //
                ERplInsertQue(
                        WINS_E_WINSCNF,
                        QUE_E_CMD_CONFIG,
                        NULL,                        //no dlg handle
                        NULL,                        //no msg
                        0,                        //msg len
                        pWinsCnf,                //client ctx
                        pWinsCnf->MagicNo
                            );
                DBGLEAVE("Reinit\n");
                return;
        }

        //
        // Parameters related to WINS's configuration (nothing to do with
        // how it interacts with its PARTNERS) have changed. Let us read
        // the new data and signal the scavenger thread
        //
        if (IndexOfHdlSignaled_e == WINSCNF_E_PARAMETERS_HDL)
        {
                WinsCnfAskToBeNotified(WINSCNF_E_PARAMETERS_KEY);

                //
                // Allocate the WinsCnf structure
                //
                WinsMscAlloc(
                        sizeof(WINSCNF_CNF_T),
                        &pWinsCnf
                    );


                //
                // Read the registry information
                //
                WinsCnfReadWinsInfo(pWinsCnf);

                //
                // Copy some of the information read in into WinsCnf.
                //
                WinsCnfCopyWinsCnf(WINS_E_WINSCNF, pWinsCnf);

                WinsWorkerThdUpd(WinsCnf.MaxNoOfWrkThds);
                //
                // If the flag for doing STATIC initialization is set, do it
                //
                if (pWinsCnf->fStaticInit)
                {
                   EnterCriticalSection(&WinsIntfCrtSec);
                   if (WinsIntfNoCncrntStaticInits >
                                WINSCNF_MAX_CNCRNT_STATIC_INITS)
                    {
                        DBGPRINT1(ERR, "Reinit: Too many concurrent STATIC initializations are going on (No = %d). Try later\n", WinsIntfNoCncrntStaticInits);
                         WINSEVT_LOG_M(WinsIntfNoCncrntStaticInits, WINS_EVT_TOO_MANY_STATIC_INITS);
                         LeaveCriticalSection(&WinsIntfCrtSec);
                    }
                    else
                    {
                         LeaveCriticalSection(&WinsIntfCrtSec);
                         (VOID)WinsPrsDoStaticInit(
                                        pWinsCnf->pStaticDataFile,
                                        pWinsCnf->NoOfDataFiles,
                                        TRUE            //do it asynchronously
                                                      );
                          //
                          // No need to deallocate memory for data file.
                          // It should have been freed by WinsPrsDoStaticInit
                          //
                    }
                }

                WinsMscDealloc(pWinsCnf);

                //
                // Signal the scavenger thread
                //
FUTURES("Signal the scavenger thread only if parameters relevant to")
FUTURES("scavenging have changed. This requires some if tests.")
                WinsMscSignalHdl(WinsCnf.CnfChgEvtHdl);

        }

        DBGLEAVE("Reinit\n");
        return;


} // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("Reinit")
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
        }

        DBGLEAVE("Reinit\n");
        return;
}




#define USE_TCP
#define AUTO_BIND


BOOL
InitializeRpc(
    VOID
    )

/*++

Routine Description:
        This function is called to do all initialization necessary for
        making WINS respond to rpc calls

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  TRUE
   Error status codes   --  FALSE

Error Handling:

Called by:
        WinsMain

Side Effects:

Comments:
        None
--*/

{
    RPC_STATUS                 RpcStatus;
    RPC_BINDING_VECTOR         *pRpcBindingVector;
    BOOL                       fBool;

    DBGENTER("InitializeRpc\n");

#ifdef USE_TCP
#ifdef AUTO_BIND

    //
    // Specify the protocol sequence to use
    //
    RpcStatus = RpcServerUseProtseq(
                    TEXT("ncacn_ip_tcp"),
                    NMS_MAX_RPC_CALLS,          //Max Calls
                    0);

    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "Error: InitializeRpc: Tcp/Ip = RpcServerUseProtSeq = %u\n", RpcStatus );
        return( FALSE );
    }
    RpcStatus = RpcServerUseProtseq(
                    TEXT("ncalrpc"),
                    NMS_MAX_RPC_CALLS,          //Max Calls
                    NULL);

    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "Error: InitializeRpc: Local Rpc - RpcServerUseProtSeq = %u\n", RpcStatus );
        return( FALSE );
    }
FUTURES("Take this out to save on threads.  Take it out when winsadmn is")
FUTURES("updated to work with just tcp/ip")
    //
    //  Use Named pipes
    //
    RpcStatus = RpcServerUseProtseqEp(
                    TEXT("ncacn_np"),
                    NMS_MAX_RPC_CALLS, // maximum concurrent calls
                    WINS_NAMED_PIPE,
                    NULL//pSecurityDescriptor
                    );
    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "Error: InitializeRpc: Named Pipes - RpcServerUseProtSeq = %u\n", RpcStatus );
        return( FALSE );
    }

    //
    // Get the binding vector to use when registring self as end point
    //
    RpcStatus = RpcServerInqBindings(&pRpcBindingVector);

    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "InitializeRpc: RpcServerInqBindings  = %u\n",
                                                RpcStatus);
        return( FALSE );
    }

    //
    // Register  end point(s) with the end point mapper
    // RpcEpRegister instead of RpcEpRegisterNoReplace is used since
    // it will replace a stale entry in the endpoint map database (left
    // if the server stops running without calling RpcEpUnregister()).
    // Using RpcEpRegister however means that only a single instance of
    // the WINS server will run on a host.  This is OK.
    //
    // A dynamic end-point expires when the server instance stops running.
    //
FUTURES("From 541 onwards, one can replace the last parameter - Null string")
FUTURES("by a NULL")
    RpcStatus = RpcEpRegister(
                    winsif_v1_0_s_ifspec,
                    pRpcBindingVector,
                    NULL,
                    TEXT("") );

    if ( RpcStatus != RPC_S_OK)
    {
        DBGPRINT1( ERR, "InitializeRpc: RpcEpRegister  = %u \n", RpcStatus);
        return( FALSE );
    }

    RpcStatus = RpcEpRegister(
                    winsi2_v1_0_s_ifspec,
                    pRpcBindingVector,
                    NULL,
                    TEXT("") );

    if ( RpcStatus != RPC_S_OK)
    {
        DBGPRINT1( ERR, "InitializeRpc: RpcEpRegister  = %u \n", RpcStatus);
        return( FALSE );
    }

#else  // AUTO_BIND
    RpcStatus = RpcServerUseProtseqEp(
                    TEXT("ncacn_ip_tcp"),
                    NMS_MAX_RPC_CALLS, // maximum concurrent calls
                    WINS_SERVER_PORT,
                    0
                    );

#endif // AUTO_BIND

#else

    //
    //  Use Named pipes
    //
    RpcStatus = RpcServerUseProtseqEp(
                    TEXT("ncacn_np"),
                    NMS_MAX_RPC_CALLS, // maximum concurrent calls
                    WINS_NAMED_PIPE,
                    NULL
                    );

    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR, "InitializeRpc: Cannot set server\n");
        return(FALSE);
    }

#endif
    //
    // Free the security descriptor
    //
FUTURES("Currently there is a bug in rpc where they use the memory pointed")
FUTURES("by pSecurityDescriptor even after RpcServerUseProtSeq returns")
FUTURES("uncomment the following after the rpc bug is fixed - 4/7/94")
//    WinsMscDealloc(pSecurityDescriptor);
    //
    // Register Interface Handle
    //
    RpcStatus = RpcServerRegisterIf(winsif_v1_0_s_ifspec, 0, 0);
    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR,  "InitializeRpc: Registration of winsif failed\n");
        return(FALSE);
    }
    RpcStatus = RpcServerRegisterIf(winsi2_v1_0_s_ifspec, 0, 0);
    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR,  "InitializeRpc: Registration of winsi2 failed\n");
        return(FALSE);
    }

#if SECURITY > 0
    //
    // register authentication info (used for tcpip calls).
    //
    RpcStatus = RpcServerRegisterAuthInfo(
                        WINS_SERVER,
                        RPC_C_AUTHN_WINNT,
                        NULL,  //use default encryption key acquisition method
                        NULL   //since NULL was passed for function address
                               //above, NULL needs to be passed here for arg
                        );
    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT0(ERR, "InitializeRpc: Cannot Register authentication info\n");
        return(FALSE);
    }

    if (!InitSecurity())
    {
        return(FALSE);
    }
#endif

    //
    // WINS is ready to process RPC calls.  The maximum no. of RPC calls
    // parameter (2nd) should not be less than that specified than any of
    // the RPC calls before (RpcServerUseProtseq)
    //
    RpcStatus = RpcServerListen(
                        NMS_MIN_RPC_CALL_THDS,
                        NMS_MAX_RPC_CALLS,
                        TRUE
                               );
    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR, "InitializeRpc: Listen failed\n");
        return(FALSE);
    }


    DBGLEAVE("InitializeRpc\n");
    return(TRUE);

}
BOOL
SecurityAllowedPathAddWins()
{
#define  _WINS_CFG_KEY  TEXT("System\\CurrentControlSet\\Services\\Wins")
#define  SECURITY_ALLOWED_PATH_KEY TEXT("System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths")
#define  ALLOWED_PATHS TEXT("Machine")
    DWORD NTStatus, ValSize, ValTyp;
    LPBYTE  ValData;
    LPWSTR   NextPath;
    HKEY    hKey;

    // Now openup the WINS regkey for remote lookup by readonly operators
    NTStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    SECURITY_ALLOWED_PATH_KEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    if (!NT_SUCCESS(NTStatus)) {
        DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not open security allowed path key (%ld)\n", NTStatus);
        return FALSE;
    }
    ValSize = 0;
    NTStatus = RegQueryValueEx(
                    hKey,
                    ALLOWED_PATHS,
                    NULL,
                    &ValTyp,
                    NULL,
                    &ValSize
                    );
    if (!NT_SUCCESS(NTStatus) || ValTyp != REG_MULTI_SZ) {
        DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not query allowed path value (%ld)\n", NTStatus);
        return FALSE;
    }

try {
    ValSize += (wcslen(_WINS_CFG_KEY) + 1)* sizeof (WCHAR);
    WinsMscAlloc(ValSize , &ValData);
    NTStatus = RegQueryValueEx(
                    hKey,
                    ALLOWED_PATHS,
                    NULL,
                    &ValTyp,
                    ValData,
                    &ValSize
                    );
    if (!NT_SUCCESS(NTStatus)){
        DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not query allowed path value (%ld)\n", NTStatus);
        return FALSE;
    }


    // First check if WINS key is alreay there or not.
    NextPath = (WCHAR *)ValData;
    while (*NextPath != L'\0' && wcscmp(NextPath, _WINS_CFG_KEY)) {
        NextPath += (wcslen(NextPath) + 1);
    }
    if (*NextPath == L'\0') {
        // The WINS path is not there, so add it.
        wcscpy(NextPath, _WINS_CFG_KEY);
        NextPath += (wcslen(NextPath) + 1);
        *NextPath = L'\0';

        ValSize += (wcslen(_WINS_CFG_KEY) + 1)* sizeof (WCHAR);
        NTStatus = RegSetValueEx(
                        hKey,
                        ALLOWED_PATHS,
                        0,
                        ValTyp,
                        ValData,
                        ValSize
                        );
        if (!NT_SUCCESS(NTStatus)){
            DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not set allowed path value (%ld)\n", NTStatus);
            return FALSE;
        }
    }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "SecurityAllowedPathAddWins: Got Exception (%x)\n", ExcCode);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
    }
    return TRUE;
}


BOOL
InitSecurity()
/*++

Routine Description:
        This function initializes the security descriptor and
        InfoMapping for use by rpc functions

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:


Comments:
        None
--*/

{
   NTSTATUS     NTStatus;
   DWORD        SidSize = 0;
   LPWSTR		ReferencedDomainName = NULL;
   DWORD		ReferencedDomainNameSize = 0;
   SID_NAME_USE	SidUse;
   DWORD        AceCount;
   BOOL         Result;
   NET_API_STATUS NetStatus;
    PSID         WinsSid = NULL;
    GROUP_INFO_1 WinsGroupInfo = {
            WinsMscGetString(WINS_USERS_GROUP_NAME),
            WinsMscGetString(WINS_USERS_GROUP_DESCRIPTION)};


   ACE_DATA        AceData[5] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &AliasAccountOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &AliasSystemOpsSid},

       {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
              WINS_QUERY_ACCESS,     &WinsSid}

        };
     AceCount = 4;

    //
    // Create sids
    //
    NTStatus = NetpCreateWellKnownSids(NULL);
    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "InitSecurity: Could not create well known Sids. Status returned is (%d)\n", NTStatus);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_SEC_OBJ_ERR);
        return(FALSE);
    }


    try {
        // Add Wins ReadOnly operators group if it doesn't
        // exist
        NetStatus = NetLocalGroupAdd(
                        NULL,
                        1,
                        (LPVOID)&WinsGroupInfo,
                        NULL
                        );
        if (NERR_Success != NetStatus && NERR_GroupExists != NetStatus && ERROR_ALIAS_EXISTS != NetStatus) {
            DBGPRINT1(ERR, "InitSecurity: NetGroupAdd Failed %ld \n",NetStatus);
            WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
        }
        // Lookup SID for WINS read only operators group
        Result = LookupAccountName(
                    NULL,
                    WinsGroupInfo.grpi1_name,
                    WinsSid,
                    &SidSize,
                    ReferencedDomainName,
                    &ReferencedDomainNameSize,
                    &SidUse
                    );
        if (!Result && (ERROR_INSUFFICIENT_BUFFER == GetLastError())) {
            WinsMscAlloc(SidSize, &WinsSid);
            WinsMscAlloc(ReferencedDomainNameSize*sizeof(WCHAR), &ReferencedDomainName);
            Result = LookupAccountName(
                        NULL,
                        WinsGroupInfo.grpi1_name,
                        WinsSid,
                        &SidSize,
                        ReferencedDomainName,
                        &ReferencedDomainNameSize,
                        &SidUse
                        );
            WinsMscDealloc(ReferencedDomainName);
            if (!Result) {
                DBGPRINT1(ERR, "InitSecurity: LookupAccountName Failed (%lx)\n", GetLastError());
                WinsMscDealloc(WinsSid);
                WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
            } else{
                AceCount++;
                DBGPRINT0(DET, "InitSecurity: LookupAccountName Succeded \n");
            }
        }else{
            DBGPRINT1(ERR, "InitSecurity: LookupAccountName Failed (%lx)\n", GetLastError());
            WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "InitSecurity: Got Exception (%x)\n", ExcCode);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
    }



    //
    // Actually create the security descriptor.
    //

    NTStatus = NetpCreateSecurityObject(
               AceData,
               AceCount,
               NULL, //LocalSystemSid,
               NULL, //LocalSystemSid,
               &NmsInfoMapping,
               &pNmsSecurityDescriptor
                );

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "InitSecurity: Could not create security descriptor. Status returned is (%d)\n", NTStatus);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_SEC_OBJ_ERR);
        return(FALSE);
    }

    SecurityAllowedPathAddWins();
    return(TRUE);
}

VOID
WrapUp(
        DWORD ErrorCode,
        BOOL  fSvcSpecific
    )

/*++

Routine Description:
        This function is called to release all resources held by WINS

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:


Side Effects:

Comments:
        None
--*/

{
    static BOOL        sfFirstTime = TRUE;
    BOOL               fWinsIniting = FALSE;
    if (sfFirstTime)
    {
        sfFirstTime = FALSE;
    }
    else
    {
        return;
    }

    //
    // Set flag if we are terminating during initialization.  This is
    // to avoid doing "backup on termination".  Normally, we shouldn't
    // have to skip the NmsDbBackup() call (it should simply return with
    // success/error but this is another instance where we have to work
    // around jet bugs.  Currently (7/7/94) JetBackup simply hangs when
    // called without a valid wins.mdb file being there.
    //
    fWinsIniting = (WinsCnf.State_e == WINSCNF_E_INITING);

    /*
     *         signal all threads to do cleanup and exit gracefully
     *
    */
    SignalWinsThds();

#ifdef WINSDBG
    NmsPrintCtrs();
#endif


    //
    // Close all keys
    //
    WinsCnfCloseKeys();

    //
    // We are almost done.  Let us check if we were told to backup
    // on termination.
    //
    if (!fWinsIniting && (WinsCnf.pBackupDirPath != NULL) && WinsCnf.fDoBackupOnTerm && fsBackupOnTerm)
    {

#ifndef WINS_INTERACTIVE
           //
           // Backup can take a while, so let us make sure that the
           // service controller does not give up on us.
           //
           ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
           ServiceStatus.dwCheckPoint   = 1;

           ServiceStatus.dwWaitHint     = 120000;     // 2 mts
           UpdateStatus();
#endif
try {
           (VOID)NmsDbBackup(WinsCnf.pBackupDirPath, NMSDB_FULL_BACKUP);
}
except(EXCEPTION_EXECUTE_HANDLER)      {
           DBGPRINTEXC("WrapUp: During NmsDbBackup\n");
     }
    }
    /*
     *  Release all resources used by the system
     *  This will result in all data being flushed to disk
    */
    WinsWriterTerm();

    NmsDbRelRes();

#if defined(DBGSVC) || defined(WINS_INTERACTIVE)
//#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
       if (NmsDbgFileHdl != INVALID_HANDLE_VALUE)
       {
                (VOID)CloseHandle(NmsDbgFileHdl);
       }
#endif
#if TEST_DATA > 0
        if (NmsFileHdl != INVALID_HANDLE_VALUE)
        {
                if (!CloseHandle(NmsFileHdl))
                {
                        DBGPRINT0(ERR, "WrapUp: Could not close output file\n");
                }
        }
#endif

#ifndef WINS_INTERACTIVE
     //
     // Tell the service controller that we stopped
     //
     ServiceStatus.dwCurrentState        = SERVICE_STOPPED;
     ServiceStatus.dwControlsAccepted    = 0;
     ServiceStatus.dwCheckPoint          = 0;
     ServiceStatus.dwWaitHint            = 0;
     ServiceStatus.dwServiceSpecificExitCode = ErrorCode;
     ServiceStatus.dwWin32ExitCode       = fSvcSpecific ? ERROR_SERVICE_SPECIFIC_ERROR : ErrorCode;

     UpdateStatus();
#endif

    return;
}


VOID
CrDelNbtThd(
        VOID
        )

/*++

Routine Description:
        This function creates or deletes an Nbt threads.

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsUpdThdCnt
Side Effects:

Comments:
        None
--*/

{

        DWORD   ThdId = GetCurrentThreadId();

        EnterCriticalSection(&WinsCnfCnfCrtSec);

try {
        //
        // If the existing number of threads is less than that desired, create
        // the extra ones.
        //
        if (WinsIntfNoOfNbtThds > NmsNoOfNbtThds)
        {
                while(NmsNoOfNbtThds < WinsIntfNoOfNbtThds)
                {
                  //
                  // Create an Nbt Thread
                  //
                  WinsThdPool.NbtReqThds[NmsNoOfNbtThds].ThdHdl = CreateThread(
                                        NULL,  /*def sec. attributes*/
                                        0,     /*use default stack size*/
                                        NbtThdInitFn,
                                        NULL,  /*no arg*/
                                        0,     /*run it now*/
                                        &WinsThdPool.NbtReqThds[NmsNoOfNbtThds].ThdId
                                        );


                 WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_WRK_THD_CREATED);
                 if (NULL == WinsThdPool.NbtReqThds[NmsNoOfNbtThds].ThdHdl)
                 {
                        WINSEVT_LOG_M(GetLastError(),
                                        WINS_EVT_CANT_CREATE_WRK_THD);
                 }
                 WinsThdPool.NbtReqThds[NmsNoOfNbtThds++].fTaken = TRUE;
                 DBGPRINT1(FLOW, "CrDelNbtThd: Created thread no = (%d) \n",
                                NmsNoOfNbtThds);
                }
        }
        else
        {
                //
                // If the count is less, terminate self after doing some
                // cleanup. The count could be same too in case more than
                // one rpc thread were invoked concurrently to create/delete
                // the threads (i.e. a second rpc thread changes the count
                // prior to this NBT thread looking at it)
                //
                if (WinsIntfNoOfNbtThds < NmsNoOfNbtThds)
                {

                   DWORD   i, n;
                   DBGPRINT0(FLOW, "CrDelNbtThd: EXITING\n");

                   //
                   // Find the slot for this thread
                   //
                   for (i = 0; i < NmsNoOfNbtThds; i++)
                   {
                        if (WinsThdPool.NbtReqThds[i].ThdId == ThdId)
                        {
                                break;
                        }
                   }
                   ASSERT(i < NmsNoOfNbtThds);

                   //
                   // Shift all successive filled slots one place down
                   //
                   for (n = i, i = i + 1 ; i <= NmsNoOfNbtThds; n++, i++)
                   {
                        WinsThdPool.NbtReqThds[n] =
                                WinsThdPool.NbtReqThds[i];
                   }

                   //
                   // Mark the last slot as empty
                   //
                   WinsThdPool.NbtReqThds[NmsNoOfNbtThds].fTaken = FALSE;

                   NmsNoOfNbtThds--;

                   //
                   // If the count is still less, signal the event again
                   //
                   if (WinsIntfNoOfNbtThds < NmsNoOfNbtThds)
                   {
                        WinsMscSignalHdl(NmsCrDelNbtThdEvt);
                   }

                   LeaveCriticalSection(&WinsCnfCnfCrtSec);
                   WINSEVT_LOG_INFO_D_M(WINS_SUCCESS,
                                        WINS_EVT_WRK_THD_TERMINATED);
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                }
        }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("CrDelNbtThd");
        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
        return;

}

VOID
GetMachineInfo(
 VOID
)

/*++

Routine Description:
    This function gets information about the machine WINS is running on

Arguments:
   NONE

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
#define LOW_MEM_SIZE           8000000
#define MEDIUM_MEM_SIZE        12000000
#define LARGE_MEM_SIZE         16000000
#define SMALL_DB_BUFFER_COUNT  200
#define MEDIUM_DB_BUFFER_COUNT 400
#define LARGE_DB_BUFFER_COUNT  500

    SYSTEM_INFO  SystemInfo;
    MEMORYSTATUS MemStatus;
    BYTE Tmp[30], Tmp2[30], Tmp3[30];
    WinsCnf.NoOfProcessors = 1;
    WinsCnf.NoOfDbBuffers  = SMALL_DB_BUFFER_COUNT;

    GetSystemInfo(&SystemInfo);
    if (SystemInfo.dwNumberOfProcessors != 0)
    {
      DBGPRINT1(DET, "GetMachineInfo: The number of processors are (%d)\n",
                               SystemInfo.dwNumberOfProcessors);


      WinsCnf.NoOfProcessors = SystemInfo.dwNumberOfProcessors;
    }

    GlobalMemoryStatus(&MemStatus);
    DBGPRINT2(DET, "Total Phys. Memory = (%d); Total Avail Phys Memory = (%d)\n",
                       MemStatus.dwTotalPhys, MemStatus.dwAvailPhys);

    if (WinsCnf.LogDetailedEvts > 0)
    {
       WinsEvtLogDetEvt(TRUE, WINS_EVT_MACHINE_INFO,
                            NULL, __LINE__, "sss", _itoa((int)SystemInfo.dwNumberOfProcessors, Tmp, 10),
                        _itoa((int)MemStatus.dwTotalPhys, Tmp2, 10),
                        _itoa((int)MemStatus.dwAvailPhys, Tmp3, 10));
    }

    if ((MemStatus.dwAvailPhys >= MEDIUM_MEM_SIZE) &&
            (MemStatus.dwAvailPhys < LARGE_MEM_SIZE))
    {
       WinsCnf.NoOfDbBuffers = MEDIUM_DB_BUFFER_COUNT;
    }
    else
    {
        if (MemStatus.dwAvailPhys >= LARGE_MEM_SIZE)
        {
            WinsCnf.NoOfDbBuffers = LARGE_DB_BUFFER_COUNT;
        }
        else
        {
            WinsCnf.NoOfDbBuffers = SMALL_DB_BUFFER_COUNT;
        }
    }
    return;

}

VOID
ENmsWinsUpdateStatus(
  DWORD MSecsToWait
 )
{
#ifndef WINS_INTERACTIVE
        ServiceStatus.dwWaitHint                = MSecsToWait;
        ServiceStatus.dwCheckPoint++;
        UpdateStatus();   //inform the service control manager
#endif
        return;
}

#if TEST_DATA > 0 || defined(DBGSVC)
BOOL
DbgOpenFile(
        LPTSTR pFileNm,
        BOOL   fReopen
        )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
    NmsChkDbgFileSize
Side Effects:

Comments:
	Don't use DBGPRINTF in this function, else stack overflow would result.
--*/

{
          SECURITY_ATTRIBUTES        SecAtt;
          DWORD                      HowToCreate;
          HANDLE                     *pTmpHdl;
          int             BytesWritten;
          char str[200];

          SecAtt.nLength              = sizeof(SecAtt);
          SecAtt.lpSecurityDescriptor = NULL;  //use default security descriptor
          SecAtt.bInheritHandle       = FALSE; //actually don't care

          if (!lstrcmp(pFileNm, WINSDBG_FILE))
          {
                HowToCreate =  CREATE_ALWAYS;
                pTmpHdl     =  &NmsDbgFileHdl;
                if (fReopen)
                {
                    if (!DeleteFile(WINSDBG_FILE_BK))
                    {
                       DWORD Error;
                       Error = GetLastError();
                       if (Error != ERROR_FILE_NOT_FOUND)
                       {
                           IF_DBG(ERR)
                           {
                             sprintf(str, "DbgOpenFile: Could not delete the backup file. Error = (%d).  Dbg file will not be truncated\n", Error);
                             WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
                           }
                            WinsEvtLogDetEvt(TRUE, WINS_EVT_COULD_NOT_DELETE_FILE,
                            TEXT("nms.c"), __LINE__, "ud", WINSDBG_FILE_BK, Error);
                            return(FALSE);

                       }
                   }
                   //--ft: fix #20801: don't use NmsDbgFileHdl once the handle is closed
                   if (NmsDbgFileHdl != NULL)
                   {
                       CloseHandle(NmsDbgFileHdl);
                       NmsDbgFileHdl = NULL;
                       if (!MoveFile(WINSDBG_FILE, WINSDBG_FILE_BK))
                           return (FALSE);
                   }

               }
          }
          else
          {
                HowToCreate = TRUNCATE_EXISTING;
                pTmpHdl =  &NmsFileHdl;               //for wins.rec
          }

          //
          // Open the file for reading and position self to start of the
          // file
          //
          *pTmpHdl = CreateFile(
                        pFileNm,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        &SecAtt,
                        HowToCreate,
                        FILE_ATTRIBUTE_NORMAL,
                        0                        //ignored ?? check
                       );

          if (*pTmpHdl == INVALID_HANDLE_VALUE)
          {

#ifndef UNICODE
               IF_DBG(ERR)
               {
                    sprintf(str, "DbgOpen: Could not open %s (Error = %d)\n", pFileNm, GetLastError());
                    WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
               }
#else
#ifdef WINSDBG
                IF_DBG(ERR)
                {
                  wprintf(L"DbgOpen: Could not open %s (Error = %d)\n", pFileNm, GetLastError());
                }
#endif
#endif
                return(FALSE);
          }
          return(TRUE);
}


#define LIMIT_OPEN_FAILURES  3
#if defined(DBGSVC)
VOID
NmsChkDbgFileSz(
    VOID
    )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
    NOTE NOTE:  Do not put a DBGPRINT statement inside this function, otherwise
                infinite recursion will occur.	
--*/

{
       DWORD           FileSize;
       time_t          CurrTime;
       BOOL            fOpened = FALSE;
       static DWORD    sFailureNo = 0;
       int             BytesWritten;
       char str[200];

       return;
       //
       // We check every half hour.  If the size has become more than
       // that allowed, move wins.dbg to wins.bak and reopen it
       //
       if (time(&CurrTime) > (sDbgLastChkTime + DBG_TIME_INTVL_FOR_CHK))
       {

          //
          // Is the log file too big?
          //
          EnterCriticalSection(&sDbgCrtSec);
try {
          IF_DBG(DET)
          {
              sprintf(str, "NmsChkDbgFileSz: Getting File Size\n");
              WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
          }
          FileSize = GetFileSize( NmsDbgFileHdl, NULL );
          if ( FileSize == 0xFFFFFFFF )
          {
             IF_DBG(ERR)
             {
              sprintf(str, "NmsChkDbgFileSize: Cannot GetFileSize %ld\n", GetLastError() );
              WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
             }
             return;
          }
          else
          {
            if ( FileSize > DBG_FILE_MAX_SIZE )
            {
               IF_DBG(ERR)
               {
                 sprintf(str, "NmsChkDbgFileSz: REOPEN A NEW DEBUG FILE\n");
                 WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
               }
               fOpened = DbgOpenFile( WINSDBG_FILE, TRUE );
            }
          }
          //
          // if the new file could not be opened (it could be because another
          // thread was writing to it), then we want to retry again (upto
          // a certain limit)
          //
          //
          if (fOpened)
          {
             sFailureNo = 0;
             sDbgLastChkTime = CurrTime;
          }
          else
          {
               if (++sFailureNo > LIMIT_OPEN_FAILURES)
               {
                  sFailureNo = 0;
                  sDbgLastChkTime = CurrTime;
               }
          }
}
except(EXCEPTION_EXECUTE_HANDLER) {

 }
          LeaveCriticalSection(&sDbgCrtSec);
      }

      return;
}

#endif
#endif

#ifdef WINSDBG
VOID
NmsPrintCtrs(
 VOID
 )
{
static LPBYTE pTypeOfUpd[2] = {"INSERT", "REPLACE"};
static LPBYTE pTypeOfRec[4] = {"UNIQUE", "NORM GRP", "SPEC GRP", "MH"};
static LPBYTE pStateOfRec[3] = {"ACTIVE", "RELEASE", "TOMBSTONE"};
static LPBYTE pIndexUpd[2] = {"REFRESH", "UPDATE"};
DWORD h, i,j,k,n;
LPDWORD pNoOfUpd;
DWORD   TotalUpd, GTotalUpd = 0;
DWORD   TotalIndexUpd, GTotalIndexUpd = 0;
 BOOL   fDef = FALSE;
     DBGPRINT4(HEAP_CNTRS, "WrapUp Summary\n\
\t# Udp Alloc/Free:          (%d/%d)\n  \
\t# Gen Alloc/Free:          (%d/%d)\n",
        NmsUdpHeapAlloc, NmsUdpHeapFree, NmsGenHeapAlloc, NmsGenHeapFree);

    DBGPRINT2(HEAP_CNTRS, "\
\t# Udp Dlg Alloc/Free:          (%d/%d)\n",
        NmsUdpDlgHeapAlloc, NmsUdpDlgHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Chl Alloc/Free:          (%d/%d)\n  \
\t# Assoc Alloc/Free:          (%d/%d)\n",
        NmsChlHeapAlloc, NmsChlHeapFree,NmsAssocHeapAlloc, NmsAssocHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Que Alloc/Free:          (%d/%d)\n  \
\t# RplWrkItm Alloc/Free:          (%d/%d)\n",
      NmsQueHeapAlloc, NmsQueHeapFree,
       NmsRplWrkItmHeapAlloc, NmsRplWrkItmHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Tmm Alloc/Free:          (%d/%d)\n\
\t# Catch All Alloc/Free:          (%d/%d)\n",
    NmsTmmHeapAlloc, NmsTmmHeapFree,NmsCatchAllHeapAlloc, NmsCatchAllHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Dlg Alloc/Free:          (%d/%d)\n\
\t# Tcp Msg Alloc/Free:      (%d/%d)\n",
    NmsDlgHeapAlloc, NmsDlgHeapFree,
    NmsTcpMsgHeapAlloc, NmsTcpMsgHeapFree);

    DBGPRINT2(HEAP_CNTRS, "\
\t# Rpc Alloc/Free:          (%d/%d)\n",
    NmsRpcHeapAlloc, NmsRpcHeapFree);

    DBGPRINT3(HEAP_CNTRS, "\n\n \
\t# of Heap Allocs for List = (%d)\n \
\t# of Heap Creates = (%d)\n \
\t# of Heap Destroys = (%d)\n",
                NmsHeapAllocForList, NmsHeapCreate, NmsHeapDestroy);

     DBGPRINT2(HEAP_CNTRS, "\nOther counters\n\n\
\t# of Dgrms recd\t(%d)\n\
\t# of repeat dgrms recd\t(%d)\n",
        CommNoOfDgrms,
        CommNoOfRepeatDgrms);

     DBGPRINT4(HEAP_CNTRS, "\
\t# of Chl req. queued by Nbt and Rpl(%d, %d)/Dequeued Chl req\t(%d)\n\
\t# of Queued Chl req at Hd. of List\t(%d)\n",
        NmsChlNoOfReqNbt, NmsChlNoOfReqRpl,
        NmsChlNoReqDequeued,
        NmsChlNoReqAtHdOfList);

     DBGPRINT3(HEAP_CNTRS, "\
\t# of Dequeued Chl req with no rsp\t(%d)\n\
\t# of Dequeud inv. resp\t(%d)\n\
\t# of Dequeued Chl rsp\t(%d)\n",
        NmsChlNoNoRsp,
        NmsChlNoInvRsp,
        NmsChlNoRspDequeued);



#if REG_N_QUERY_SEP > 0
     DBGPRINT3(HEAP_CNTRS, "   \
\t# of reg requests queued by udp thread       (%d)\n\
\t# of query requests queued by udp thread       (%d)\n\
\t# of chl. responses queued by udp thread       (%d)\n",
 sRegReqQ, sReqQ, sRsp);

     DBGPRINT4(HEAP_CNTRS, "   \
\t# of reg requests dequeued by worker threads       (%d)\n\
\t# of query requests dequeued by worker threads       (%d)\n\
\t# of tcp connections  (%d)\n\
\t# chl. Responses dropped: (%d)\n", sRegReqDq, sReqDq, CommConnCount, NmsChlNoRspDropped);


#else
     DBGPRINT2(HEAP_CNTRS, "   \
\t# of requests deqeued by worker threads       (%d)\n\
\t# Responses dropped: (%d)\n", sReqDq, NmsChlNoRspDropped);
#endif

    DBGPRINT0(UPD_CNTRS, "---UPDATE COUNTERS SUMMARY------\n");

    for (n=0; n<WINS_NO_OF_CLIENTS; n++)
    {
      switch(n)
      {
         case(WINS_E_NMSNMH):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "NMSNMH counters\n");
                      break;
         case(WINS_E_NMSSCV):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "NMSSCV counters\n");
                      break;

         case(WINS_E_NMSCHL):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "NMSCHL counters\n");
                      break;
         case(WINS_E_RPLPULL):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "RPLPULL counters\n");
                      break;
         case(WINS_E_WINSRPC):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "WINSRPC counters\n");
                      break;
         default:
                      fDef = TRUE;
                      break;
      }
      if (fDef)
      {
         fDef = FALSE;
         continue;
      }
      TotalUpd = 0;
      TotalIndexUpd = 0;
      for (j=0; j<2; j++)
      {
         for (k=0;k<4;k++)
         {
           for(i=0;i<3;i++)
           {
              for(h=0;h<2;h++)
              {
               pNoOfUpd = &NmsUpdCtrs[n][j][k][i][h];
               if (*pNoOfUpd != 0)
               {
                 DBGPRINT4(UPD_CNTRS, "%s - %s - %s - %s\t", pIndexUpd[h], pTypeOfUpd[j], pTypeOfRec[k], pStateOfRec[i]);
                 DBGPRINT1(UPD_CNTRS, "%d\n", *pNoOfUpd);
                 if (h==1)
                 {
                   TotalIndexUpd += *pNoOfUpd;
                   GTotalIndexUpd += *pNoOfUpd;
                 }
                 TotalUpd += *pNoOfUpd;
                 GTotalUpd += *pNoOfUpd;
               }
             }
          }
        }
      }
      DBGPRINT1(UPD_CNTRS, "TOTAL INDEX UPDATES = (%d)\n",  TotalIndexUpd);
      DBGPRINT1(UPD_CNTRS, "TOTAL UPDATES = (%d)\n",  TotalUpd);
    }
    DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
    DBGPRINT1(UPD_CNTRS, "GRAND TOTAL INDEX UPDATES = (%d)\n",  GTotalIndexUpd);
    DBGPRINT1(UPD_CNTRS, "GRAND TOTAL UPDATES = (%d)\n",  GTotalUpd);
    DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
    DBGPRINT5(UPD_CNTRS, "\
\t# of AddVersReq     (%d)\n\
\t# of SndEntReq      (%d)\n\
\t# of UpdNtfReq      (%d)\n\
\t# of UpdVerfsReq    (%d)\n\
\t# of InvReq      (%d)\n",
                 NmsCtrs.RplPushCtrs.NoAddVersReq,
                 NmsCtrs.RplPushCtrs.NoSndEntReq,
                 NmsCtrs.RplPushCtrs.NoUpdNtfReq,
                 NmsCtrs.RplPushCtrs.NoUpdVersReq,
                 NmsCtrs.RplPushCtrs.NoInvReq );

    DBGPRINT0(UPD_CNTRS, "---UPDATE COUNTERS SUMMARY------\n");

    DBGPRINT0(HEAP_CNTRS, "----------Counters Summary End--------------\n\n");

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\nmsnmh.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        nmsnmh.c

Abstract:

        This module contains functions of the name handler component of the
        name space manager of WINS.

        The name handler is responsible for handling all name registrations,
        name refreshes, name requests, and name releases.


Functions:
        NmsNmhNamRegInd         - Register Unique Name
        NmsNmhNamRegGrp         - Register Group Name
        NmsNmhNamRelease        - Release a name
        NmsNmhNamQuery          - Query a name
         .....
         .....

Portability:
        This module is portable

Author:
        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person           Description of modification
        -----------------        -------          ----------------------------
--*/

/*
        Includes
*/

#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "wins.h"
#include "nmsdb.h"
#include "comm.h"
#include "nms.h"
#include "nmsnmh.h"
#include "nmsmsgf.h"
#include "nmschl.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winsmsc.h"
#include "winsque.h"
#include "rpl.h"
#include "winsintf.h"



/*
 *        Local Macro Declarations
 */

/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */

VERS_NO_T           NmsNmhMyMaxVersNo;             //max. vers. no of entries owned
                                           //by this wins
VERS_NO_T           NmsNmhIncNo;                          //a large integer initialized to 1
CRITICAL_SECTION   NmsNmhNamRegCrtSec;     //for name registrations and
                                           //refreshes

/*
 *        Local Variable Definitions
 */


/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */

//
// Send response to name release request
//
STATIC
STATUS
SndNamRelRsp(
        PCOMM_HDL_T                pDlgHdl,
        PNMSMSGF_RSP_INFO_T   pRspInfo
        );

//
// Send response to name query request
//
STATIC
STATUS
SndNamQueryRsp(
        PCOMM_HDL_T              pDlgHdl,
        PNMSMSGF_RSP_INFO_T   pRspInfo
        );


//
// handle clash at name registration of a unique entry
//
STATIC
STATUS
ClashAtRegInd (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        IN  BOOL                fRefresh,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfAddMem,
        OUT PBOOL               pfAddDiff,
        OUT PBOOL                pfRetPosRsp
 );


//
// handle clash at name registration of a group entry
//
STATIC
STATUS
ClashAtRegGrp (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        IN  BOOL                fRefresh,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRetPosRsp
 );

//
// handle clash at the name registration of unique entry's replica
//
STATIC
VOID
ClashAtReplUniqueR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfInformWins
 );

//
// handle clash at the name registration of group entry's replica
//
STATIC
VOID
ClashAtReplGrpR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfUpdTimeStamp,
        OUT PBOOL                pfInformWins

 );

//
// check if the entry to register is a member of the special group found in
// the db
//
STATIC
BOOL
MemInGrp(
        IN PCOMM_ADD_T         pAddToReg,
        IN PNMSDB_STAT_INFO_T  pEntryInCnf,
        IN PBOOL               pfOwned,
        IN BOOL                fRemoveReplica
        );

STATIC
VOID
RemoveAllMemOfOwner(
      PNMSDB_STAT_INFO_T pEntry,
      DWORD OwnerId
 );
//
// Do a union of two special groups
//
STATIC
BOOL
UnionGrps(
        IN PNMSDB_ROW_INFO_T        pEntryToReg,
        IN PNMSDB_STAT_INFO_T        pEntryInCnf
        );

FUTURES("use when internet group masks are used")
#if 0
STATIC
BYTE
HexAsciiToBinary(
        LPBYTE pByte
        );
STATIC
BOOL
IsItSpecGrpNm(
        LPBYTE pName
        );
#endif

//
//  Function definitions
//



STATUS
NmsNmhNamRegInd(
        IN PCOMM_HDL_T          pDlgHdl,
        IN LPBYTE               pName,
        IN DWORD                NameLen,
        IN PCOMM_ADD_T          pNodeAdd,
        IN BYTE                 NodeTyp, //change to take Flag byte
        IN MSG_T                pMsg,
        IN MSG_LEN_T            MsgLen,
        IN DWORD                QuesNamSecLen,
        IN BOOL                 fRefresh,
        IN BOOL                 fStatic,
        IN BOOL                 fAdmin
        )

/*++

Routine Description:
        This function registers a unique name in the directory database.


Arguments:
        pDlgHdl         - Dialogue Handle
        pName           - Name to be registered
        NameLen         - Length of Name
        NodeTyp         - Whether nbt node doing the registration is a P or M                                   node
        pNodeAdd        - NBT node's address
        NodeTyp         - Type of Node (B, M, P)
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fRefresh        - Is it a refresh request
        fStatic         - Is it a STATIC entry
        fAdmin          - Is it an administrative action


Externals Used:
        NmsNmhNamRegCrtSec, NmsNmhMyMaxVersNo


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/

{


        NMSDB_ROW_INFO_T   RowInfo;    // contains row info
        NMSDB_STAT_INFO_T  StatusInfo; /* error status and associated
                                        * info returned by the NmsDb func
                                        */
        BOOL               fChlBeingDone = FALSE; //indicates whether
                                                  //challenge is being
                                         //done
        BOOL               fUpdate;      //indicates whether conflicting entry
                                         //needs to be overwritten
        BOOL               fUpdVersNo;   //indicates whether version number
                                         //needs to be incremented
        BOOL               fChallenge;   //indicates whether a challenge needs
                                        //to be done
        time_t             ltime;        //stores time since Jan 1, 1970
                                                 //is a browser name
        BOOL               fAddDiff;     //indicates that the address is diff
        BOOL               fAddMem;      //indicates whether member should be
                                         //added to the multihomed entry
        BOOL               fRetPosRsp;

        NMSMSGF_ERR_CODE_E Rcode_e = NMSMSGF_E_SUCCESS;
        STATUS             RetStat = WINS_SUCCESS;
        NMSMSGF_RSP_INFO_T RspInfo;
#ifdef WINSDBG
        DWORD              StartTimeInMsec;
       // DWORD              EndTimeInMsec;
#endif
        //DBG_PERFMON_VAR

        /*
        * initialize the row info. data structure with the data to insert into
        * the row.  The data passed is
        *
        * Name, NameLen, address, group/unique status,
        * timestamp, version number
        */
        DBGENTER("NmsNmhNamRegInd\n");

        //
        // if the 16th char is 0x1C or 0x1E, reject the registration
        // since these names are reserved.
        //
        if ((*(pName + 15) == 0x1C) || (*(pName + 15) == 0x1E))
        {
                RspInfo.RefreshInterval = 0;
                Rcode_e = NMSMSGF_E_RFS_ERR;
                goto SNDRSP;
        }

        RowInfo.pName = pName;

        DBGPRINT3(FLOW, "NmsNmhNamRegInd: %s name to register -- (%s). 16th char is (%x)\n", fStatic ? "STATIC" : "DYNAMIC", RowInfo.pName, *(RowInfo.pName+15));

        RowInfo.NameLen         =  NameLen;
        RowInfo.pNodeAdd        =  pNodeAdd;
        RowInfo.NodeTyp         =  NodeTyp; //Node type (B, P or M node)
        RowInfo.EntTyp          =  NMSDB_UNIQUE_ENTRY;  // this is a unique
                                                        //registration
        (void)time(&ltime);      //time() does not return any error code

        RowInfo.EntryState_e    = NMSDB_E_ACTIVE;
        RowInfo.OwnerId         = NMSDB_LOCAL_OWNER_ID;
        RowInfo.fUpdVersNo      = TRUE;
        RowInfo.fUpdTimeStamp   = TRUE;
        RowInfo.fLocal          = !(fStatic || fAdmin) ? COMM_IS_IT_LOCAL_M(pDlgHdl) : FALSE;
        RowInfo.fStatic         = fStatic;
        RowInfo.fAdmin          = fAdmin;
//        RowInfo.CommitGrBit     = 0;

FUTURES("Currently there we don't check to see whether the address in the")
FUTURES("packet is same as the address of the node that sent this request")
FUTURES("RFCs are silent about this.  Investigate")

        //
        // Check if it is a browser name.  If yes, it requires
        // special handling
        //
        if (!NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
        {

                /*
                *  Enter Critical Section
                */
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //DBG_START_PERF_MONITORING

                //
                // Put expiry time here
                //
                ltime += WinsCnf.RefreshInterval;
                RowInfo.TimeStamp       = (fStatic ? MAXLONG : ltime);


PERF("Adds to critical section code. Improve perf by getting rid of this")
PERF("Administrator would then get a cumulative count of reg and ref")
                if (!fRefresh)
                {
                        WinsIntfStat.Counters.NoOfUniqueReg++;
                }
                else
                {
                        WinsIntfStat.Counters.NoOfUniqueRef++;
                }


               //
               // Set the refresh interval field. We must do this
               // from within the WinsCnfCnfCrtSec or NmsNmhNamRegCrtSec
               // critical section (synchronize with main thread doing
               // reinitialization or with an RPC thread)
               //
               RspInfo.RefreshInterval = WinsCnf.RefreshInterval;

                /*
                   * Store version number
                */
                RowInfo.VersNo = NmsNmhMyMaxVersNo;

        try {
#ifdef WINSDBG
                IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif

                /*
                 *   Insert record in the directory
                */
                RetStat = NmsDbInsertRowInd(
                                          &RowInfo,
                                          &StatusInfo
                                            );
#ifdef WINSDBG
                IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamRegInd: Time in NmsDbInsertRowInd is = (%d msecs). RetStat is (%d)\n", GetTickCount() - StartTimeInMsec,
RetStat); }
#endif
                if (RetStat == WINS_SUCCESS)
                {
                   /*
                     * If there is a conflict, do the appropriate
                    *  processing
                   */
                   if (StatusInfo.StatCode == NMSDB_CONFLICT)
                   {
                       DBGPRINT0(FLOW, "NmsNmhNamRegInd: Name Conflict\n");
                       ClashAtRegInd(
                                        &RowInfo,
                                        &StatusInfo,
                                        fRefresh,
                                        &fUpdate,
                                        &fUpdVersNo,
                                        &fChallenge,
                                        &fAddMem,
                                        &fAddDiff,
                                        &fRetPosRsp
                                       );

PERF("Change the order of if tests to improve performance")
                       if (fChallenge)
                       {
                                DBGPRINT0(FLOW,
            "NmsNmhNamRegInd: Handing name registration to challenge manager\n");
                                WinsIntfStat.Counters.NoOfUniqueCnf++;

                                //
                                //Ask the Name Challenge component to take
                                //it from here
                                //
                                NmsChlHdlNamReg(
                                        NMSCHL_E_CHL,
                                        WINS_E_NMSNMH,
                                        pDlgHdl,
                                        pMsg,
                                        MsgLen,
                                        QuesNamSecLen,
                                        &RowInfo,
                                        &StatusInfo,
                                        NULL
                                               );
                                fChlBeingDone = TRUE;
                        }
                        else
                            {
                                if (fUpdate)
                                {
                                    if (!fUpdVersNo)
                                    {
                                        RowInfo.fUpdVersNo = FALSE;
                                    }
                                    else
                                    {
                                       WinsIntfStat.Counters.NoOfUniqueCnf++;
                                    }
//                                    RowInfo.CommitGrBit     = JET_bitCommitLazyFlush;
                                    RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                                 );

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - Maybe")
                                   if ((RetStat != WINS_SUCCESS) || (StatusInfo.StatCode != NMSDB_SUCCESS))
                                   {
                                        Rcode_e = NMSMSGF_E_SRV_ERR;
                                   }
                                   else //we succeeded in inserting the row
                                   {

                                        DBGPRINT1(FLOW,
                                          "%s Registration Done after conflict \n",
                                           fStatic ? "STATIC" : "DYNAMIC");
                                        if (fUpdVersNo)
                                        {
                                               NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                                      );
                                          //
                                          // Send a Push Notification if required
                                          //
                                          DBGIF(fWinsCnfRplEnabled)
                                          RPL_PUSH_NTF_M(
                                          (WinsCnf.PushInfo.fAddChgTrigger == TRUE) ? fAddDiff : RPL_PUSH_NO_PROP, NULL, NULL, NULL);
                                        }
                                   }
                           }
                           else  // no simple update required
                           {
                             if (fRetPosRsp)
                             {
                                Rcode_e = NMSMSGF_E_SUCCESS;
                             }
                             else
                             {
                               if (fAddMem)
                               {

                                 DWORD i;
                                 PNMSDB_GRP_MEM_ENTRY_T pRowMem =
                                        &RowInfo.NodeAdds.Mem[1];
                                 PNMSDB_GRP_MEM_ENTRY_T pCnfMem =
                                        StatusInfo.NodeAdds.Mem;

                                 //
                                 // Add the new member
                                 //
                                 // Note: first member in RowInfo.NodeAdds is the
                                 // one we tried to register.  We tack on
                                 // all the members found in the conflicting
                                 // record to it
                                 //
                                 RowInfo.NodeAdds.Mem[0].OwnerId =
                                                NMSDB_LOCAL_OWNER_ID;

                                   RowInfo.NodeAdds.Mem[0].TimeStamp =
                                              ltime;

                                 RowInfo.NodeAdds.Mem[0].Add = *pNodeAdd;

                                 for (
                                        i = 0;
                                        i < min(StatusInfo.NodeAdds.NoOfMems,
                                                (NMSDB_MAX_MEMS_IN_GRP - 1));
                                                i++, pRowMem++, pCnfMem++)
                                 {
                                   *pRowMem =  *pCnfMem;
                                 }
                                 RowInfo.NodeAdds.NoOfMems =
                                        StatusInfo.NodeAdds.NoOfMems + 1;

                                 RowInfo.EntTyp   = NMSDB_MULTIHOMED_ENTRY;
                                 RowInfo.pNodeAdd = NULL;
                                 if (!fUpdVersNo)
                                 {
                                   RowInfo.fUpdVersNo = FALSE;
                                 }

                                 RetStat = NmsDbUpdateRow(
                                                &RowInfo,
                                                &StatusInfo
                                                    );

                                 if ((RetStat == WINS_SUCCESS) && (StatusInfo.StatCode == NMSDB_SUCCESS))
                                 {
                                   if (fUpdVersNo)
                                   {

                                    NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                               );
                                     //
                                     // Send a Push notification if required
                                     //
                                       DBGIF(fWinsCnfRplEnabled)
                                     RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                        NULL);

                                   }
                                }
                                else
                                {
                                   Rcode_e = NMSMSGF_E_SRV_ERR;
                                }
                               }
                               else
                               {
                                 DBGPRINT1(FLOW,
                                        " %s Registration Failed. Conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC"
                                       );
                                 DBGPRINT1(DET, "%s Registration Failed. Conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC");
                                 Rcode_e = NMSMSGF_E_ACT_ERR;
                               }

                           }
                         }
                        }
                     }
                     else  //no conflict means success
                     {

                                DBGPRINT1(FLOW,
                                      "%s Registration Done. No conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC");
#if 0
                                DBGPRINT1(SPEC,
                                        " %s Registration Done. No conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC");
#endif

                                       NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                           );
                                //
                                // Send a Push Notification if required
                                //
                                DBGIF(fWinsCnfRplEnabled)
                                RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);

                      }
                }
                else //RetStat != WINS_SUCCESS
                {
                        Rcode_e = NMSMSGF_E_SRV_ERR;
                }
             } // end of try block
             except (EXCEPTION_EXECUTE_HANDLER) {
                        DBGPRINTEXC("NmsNmhNamRegInd");
                        DBGPRINT3(EXC, "NmsNmhNamRegInd. Name is (%s), Version No  (%d %d)\n", RowInfo.pName, RowInfo.VersNo.HighPart, RowInfo.VersNo.LowPart);

                        WinsEvtLogDetEvt(FALSE, WINS_EVT_REG_UNIQUE_ERR,
                            NULL, __LINE__, "sddd", RowInfo.pName,
                            GetExceptionCode(),
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);

                        Rcode_e = NMSMSGF_E_SRV_ERR;
              }
              LeaveCriticalSection(&NmsNmhNamRegCrtSec);
//              DBG_PRINT_PERF_DATA
        }
        else
        {
                /*
                *  Enter Critical Section
                */
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // Set the refresh interval field
                //
                RspInfo.RefreshInterval = WinsCnf.RefreshInterval;
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // The name registration was for a browser name.
                // We always return a positive response
                //
                Rcode_e = NMSMSGF_E_SUCCESS;

        }

SNDRSP:
        //
        // Send a response only if we did not hand over the request to the
        // name challenge manager and if it is neither a STATIC initialization
        // request nor a rpc request
        //
        if ((!fChlBeingDone) && (!fStatic) && (!fAdmin))
        {

                DBGPRINT1(FLOW,
                   "NmsNmhNamRegInd: Sending %s name registration response\n",
                           Rcode_e == NMSMSGF_E_SUCCESS ? "positive" :
                                                "negative" );

                RspInfo.Rcode_e         = Rcode_e;
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;

                NmsNmhSndNamRegRsp( pDlgHdl, &RspInfo );
        }

        //
        // If it is an RPC request, we need to return a success or a failure
        // indication.
        //
        if (fAdmin)
        {
                if (Rcode_e != NMSMSGF_E_SUCCESS)
                {
                        DBGLEAVE("NmsNmhNamRegInd\n");
                        return(WINS_FAILURE);
                }
        }

        DBGLEAVE("NmsNmhNamRegInd\n");
        return(WINS_SUCCESS);
}

STATUS
NmsNmhNamRegGrp(
        IN PCOMM_HDL_T          pDlgHdl,
        IN PBYTE                pName,
        IN DWORD                NameLen,
        IN PNMSMSGF_CNT_ADD_T   pCntAdd,
        IN BYTE                 NodeTyp, //change to take Flag byte
        IN MSG_T                pMsg,
        IN MSG_LEN_T            MsgLen,
        IN DWORD                QuesNamSecLen,
        IN DWORD                TypeOfRec,
        IN BOOL                 fRefresh,
        IN BOOL                 fStatic,
        IN BOOL                 fAdmin
        )

/*++

Routine Description:
        This function registers a group record.

        Special group:
                the name is registered with the IP address in the member list
        Normal group
                the name is registered with single address (to avoid
                                special casing. The address is not used)


        In case the group registration succeeds, a positive name registration
        response is sent, else a negative name registration response is sent.


Arguments:

        pDlgHdl                - Dialogue Handle
        pName                - Name to be registered
        NameLen                - Length of Name
        pNodeAdd        - NBT node's address
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fStatic                - Is it a STATIC entry
        fAdmin                - Is it an administrative action



Externals Used:
        NmsNmhNamRegCrtSec, NmsNmhMyMaxVersNo

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/
{


        NMSDB_ROW_INFO_T   RowInfo;       // contains row info
        NMSDB_STAT_INFO_T  StatusInfo;   /* error status and associated
                                          * info returned by the NmsDb func
                                          */
        BOOL                   fChlBeingDone = FALSE; //indicates whether
                                                  //challenge is being
                                                  //done
        BOOL                   fAddMem;    //indicates whether member should be
                                           //added to the group
        BOOL                   fUpdate;    //indicates whether conflicting entry
                                           //needs to be overwritten
        BOOL                   fUpdVersNo; //inidicates whether version number
                                           //needs to be incremented
        BOOL                   fChallenge; //indicates whether a challenge needs
                                           //to be done
        time_t                 ltime;      //stores time since Jan 1, 1970

        BOOL                   fIsSpecial = FALSE;  //Is this a special group
        NMSMSGF_ERR_CODE_E Rcode_e = NMSMSGF_E_SUCCESS;
        STATUS                 RetStat = WINS_SUCCESS;
        BOOL                   fRetPosRsp;
        NMSMSGF_RSP_INFO_T     RspInfo;
#ifdef WINSDBG
        DWORD                  StartTimeInMsec;
//        DWORD                  EndTimeInMsec;
#endif

        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhNamRegGrp\n");

        /*
        *  initialize the row info. data structure with the data to insert into
        *  the row.  The data passed is

        *  Name, NameLen, IP address, group/unique status,
        *  timestamp, version number
        */
        RowInfo.pName = pName;
        RowInfo.pNodeAdd = NULL;

        DBGPRINT4(FLOW, "NmsNmhNamRegGrp: %s Name (%s) to register -- (%s). 16th char is (%x)\n", fStatic ? "STATIC" : "DYNAMIC", RowInfo.pName, TypeOfRec == NMSDB_MULTIHOMED_ENTRY ? "MULTIHOMED" : "NORMAL/SPECIAL GROUP", *(RowInfo.pName + 15));

        RowInfo.NameLen   = NameLen;
        (void)time(&ltime); //time does not return any error code

        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        ltime += WinsCnf.RefreshInterval;
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        //Initialize this
        RspInfo.RefreshInterval = 0;
PERF("Stop checking for 1B name in nmsmsgf.c. Do the switch in RegInd and ")
PERF("RegGrp function. That way, we will save some cycles for the grp reg/ref")
        //
        // do the initialization based on the type of group.
        //
        //  Note: If the name qualifies as a special group name, then
        //        even if it is a multihomed, we mark it as a special group
        //
        if (NMSDB_IS_IT_SPEC_GRP_NM_M(pName) || (TypeOfRec == NMSDB_SPEC_GRP_ENTRY))
//      if (IsItSpecGrpNm(pName))
        {
              DWORD i;
              RowInfo.EntTyp =  NMSDB_SPEC_GRP_ENTRY; // this is a special grp
                                                      //registration
              RowInfo.NodeAdds.NoOfMems         = pCntAdd->NoOfAdds;
              for (i = 0; i < pCntAdd->NoOfAdds; i++)
              {
                   RowInfo.NodeAdds.Mem[i].Add      = pCntAdd->Add[i];
                   RowInfo.NodeAdds.Mem[i].OwnerId  = NMSDB_LOCAL_OWNER_ID;

                   //
                   // Put expiration time here.  WE PUT A MAXULONG FOR A STATIC
                   // SPECIAL GROUP MEMBER ONLY (I.E. NOT FOR MH NAMES).  This
                   // would require changes to MemInGrp().
                   //
FUTURES("set MAXULONG for mh members also")
                   RowInfo.NodeAdds.Mem[i].TimeStamp = ((fStatic && (TypeOfRec == NMSDB_SPEC_GRP_ENTRY)) ? MAXLONG : ltime);
              }

              //
              // Init pNodeAdd field to NULL.  This field is checked by
              // QueInsertChlReqWrkItm called by NmsChlHdlNamReg (called
              // to hand over a challenge request to the name challenge mgr).
              //
              RowInfo.pNodeAdd = NULL;
        }
        else  // normal group or a multi-homed registration
        {
          //
          // if the name is not mh, it means that it is a group. The
          // registration for this group may have come with the MULTIHOMED
          // opcode (meaning it is a multihomed node registering the group)
          // (see nmsmsgf.c)
          //
          if (TypeOfRec != NMSDB_MULTIHOMED_ENTRY)
          {
              if (*pName != 0x1B)
              {
                RowInfo.pNodeAdd  = &pCntAdd->Add[0];
                RowInfo.EntTyp    = NMSDB_NORM_GRP_ENTRY;
                RowInfo.NodeAdds.NoOfMems         = pCntAdd->NoOfAdds;
                RowInfo.NodeAdds.Mem[0].Add      = pCntAdd->Add[0];
                RowInfo.NodeAdds.Mem[0].OwnerId  = NMSDB_LOCAL_OWNER_ID;
                RowInfo.NodeAdds.Mem[0].TimeStamp = ltime; // put current time
              }
              else
              {
                //
                // a 1B name is for browser use. We can not let this one
                // preempt it
                //
NOTE("TTL is not being set. This shouldn't break UB nodes, but you never know")
                Rcode_e = NMSMSGF_E_RFS_ERR;
                goto SNDRSP;
              }
          }
          else
          {
             //
             // It is a multihomed entry
             //
             if (NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
             {
                /*
                *  Enter Critical Section
                */
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // Set the refresh interval field
                //
                RspInfo.RefreshInterval = WinsCnf.RefreshInterval;
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // The name registration was for a browser name.
                // We always return a positive response
                //
                Rcode_e = NMSMSGF_E_SUCCESS;
                goto SNDRSP;

            }
            else
            {

                   DWORD i;
                   if (*(RowInfo.pName+15) == 0x1E)
                   {
                        Rcode_e = NMSMSGF_E_RFS_ERR;
                        goto SNDRSP;
                   }
                   RowInfo.NodeAdds.NoOfMems         = pCntAdd->NoOfAdds;
                   for (i = 0; i < pCntAdd->NoOfAdds; i++)
                   {
                          RowInfo.NodeAdds.Mem[i].Add      = pCntAdd->Add[i];
                          RowInfo.NodeAdds.Mem[i].OwnerId  = NMSDB_LOCAL_OWNER_ID;
                          RowInfo.NodeAdds.Mem[i].TimeStamp = ltime; // put current time
                   }
                   RowInfo.EntTyp    = NMSDB_MULTIHOMED_ENTRY;
             }
          }
        }

        RowInfo.TimeStamp     = (fStatic ? MAXLONG : ltime);
        RowInfo.OwnerId       = NMSDB_LOCAL_OWNER_ID;
        RowInfo.EntryState_e  = NMSDB_E_ACTIVE;
        RowInfo.fUpdVersNo    = TRUE;
        RowInfo.fUpdTimeStamp = TRUE;
        RowInfo.fLocal          = !(fStatic || fAdmin) ? COMM_IS_IT_LOCAL_M(pDlgHdl) : FALSE;
        RowInfo.fStatic       = fStatic;
        RowInfo.fAdmin        = fAdmin;
//        RowInfo.CommitGrBit   = 0;

        //
        // Put this initialization here even though it is not required for
        // special group groups. This is to save cycles in
        // the critical section (check UpdateDb in nmsdb.c; if
        // we don't initialize this for special groups, we have to
        // put an if test (with associated & to get the type of record
        // bits) versus an or.
        //
        RowInfo.NodeTyp       =  NodeTyp; //Node type (B, P or M node)


        /*
         * Enter Critical Section
        */
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_START_PERF_MONITORING
PERF("Adds to critical section code. Improve perf by getting rid of this")
PERF("Administrator would then get a cumulative count of reg and ref")
        if (!fRefresh)
        {
                WinsIntfStat.Counters.NoOfGroupReg++;
        }
        else
        {
                WinsIntfStat.Counters.NoOfGroupRef++;
        }

        //
        // Set the refresh interval field. We must do this
        // from within the WinsCnfCnfCrtSec or NmsNmhNamRegCrtSec
        // critical section
        //
        RspInfo.RefreshInterval = WinsCnf.RefreshInterval;

        /*
         * Store version number
        */
        RowInfo.VersNo        = NmsNmhMyMaxVersNo;

try
  {
#ifdef WINSDBG
        IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif

        /*
        * Insert record in the directory
        */
        RetStat = NmsDbInsertRowGrp(
                                &RowInfo,
                                &StatusInfo
                           );

#ifdef WINSDBG
        IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamRegGrp: Time in NmsDbInsertRowGrp is = (%d msecs). RetStat is (%d)\n", GetTickCount() - StartTimeInMsec, RetStat); }
#endif

       if (RetStat == WINS_SUCCESS)
       {
        /*
        * If there is a conflict, do the appropriate processing
        */
        if (StatusInfo.StatCode == NMSDB_CONFLICT)
        {

          RetStat = ClashAtRegGrp(
                        &RowInfo,
                        &StatusInfo,
                        fRefresh,  // will never be TRUE for a multihomed reg
                        &fAddMem,
                        &fUpdate,
                        &fUpdVersNo,
                        &fChallenge,
                        &fRetPosRsp
                        );

          if (RetStat == WINS_SUCCESS)
          {

                  //
                  //  If fChallenge is set, it means that we should challenge the
                  //  node in conflict.
                  //
                  if (fChallenge)
                  {
                          WinsIntfStat.Counters.NoOfGroupCnf++;
                        fChlBeingDone = TRUE;
                          NmsChlHdlNamReg(
                                NMSCHL_E_CHL,
                                WINS_E_NMSNMH,
                                pDlgHdl,
                                pMsg,
                                MsgLen,
                                QuesNamSecLen,
                                &RowInfo,
                                &StatusInfo,
                        //        &StatusInfo.NodeAdds.Mem[0].Add,
                                NULL
                               );
                  }
                  else
                  {
                        if (fUpdate)
                        {
                                //
                                // In case of a special group, we could
                                // be updating the row without incrementing
                                // its version number (the row is not owned
                                // by us)
                                //
                                   if (!fUpdVersNo)
                                   {
                                       RowInfo.fUpdVersNo   = FALSE;
                                }
                                else
                                {
                                          WinsIntfStat.Counters.NoOfGroupCnf++;
                                }

FUTURES("Check return status of NmsDbUpdateRow instead of checking StatCode")
                                RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                       );

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - Maybe")
                                if ((RetStat != WINS_SUCCESS) || (StatusInfo.StatCode != NMSDB_SUCCESS))
                                {
                                    Rcode_e = NMSMSGF_E_SRV_ERR;
                                }
                                else //we succeeded in inserting the row
                                {
                                    DBGPRINT1(FLOW,
                                      "%s Registration Done after conflict.\n",
                                           fStatic ? "STATIC" : "DYNAMIC");

                                        if (fUpdVersNo)
                                        {
                                                NMSNMH_INC_VERS_COUNTER_M(
                                                        NmsNmhMyMaxVersNo,
                                                        NmsNmhMyMaxVersNo
                                                               );

                                                //
                                                // Send a Push notification if
                                                // required
                                                //
                                                  DBGIF(fWinsCnfRplEnabled)
                                                   RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                                    NULL);
                                        }
                                }
                     }
                     else
                     {
                           //
                           // if a member needs to be added
                           //
                           if (fAddMem)
                           {

                               DWORD i;
                               PNMSDB_GRP_MEM_ENTRY_T pRegMem = &RowInfo.NodeAdds.Mem[RowInfo.NodeAdds.NoOfMems];
                               PNMSDB_GRP_MEM_ENTRY_T pCnfMem = StatusInfo.NodeAdds.Mem;
PERF("Needs to be optimized")

                               //
                               // Add the new member
                               //
                               // Note: Members in RowInfo.NodeAdds are the
                               // ones we tried to register.  We tack on
                               // all the members found in the conflicting
                               // record to it. A special group will have
                               // just one member; a multihomed record can
                               // have 1-NMSDB_MAX_MEMS_IN_GRP members.
                               //
                               // We always prefer locally registered
                               // group members to those that registered at
                               // other name servers.
                               //
                               for (
                                   i = 0;
                                   i < min(StatusInfo.NodeAdds.NoOfMems,
                                         (NMSDB_MAX_MEMS_IN_GRP - RowInfo.NodeAdds.NoOfMems));
                                   i++)
                               {
                                 *pRegMem++ = *pCnfMem++;
                               }
                               RowInfo.NodeAdds.NoOfMems += i;
                               RowInfo.pNodeAdd           = NULL;

                               //
                               // The situations where this would be
                               // FALSE is 1) when the member already exists,
                               // is owned by us and is in a record owned
                               // by us also. 2) a MH record clashes with a 
                               // non-owned MH record
                               //
                               if (!fUpdVersNo)
                               {
                                    RowInfo.fUpdVersNo = FALSE;
//                                  ASSERT(StatusInfo.OwnerId == NMSDB_LOCAL_OWNER_ID);
                               }
//                             RowInfo.CommitGrBit     = JET_bitCommitLazyFlush;
                               RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                                    );
                                if ((RetStat == WINS_SUCCESS) && (StatusInfo.StatCode == NMSDB_SUCCESS))
                                {
                                    if (fUpdVersNo)
                                    {
                                            NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                               );
                                        //
                                        // Send a Push notification if required
                                        //
                                        DBGIF(fWinsCnfRplEnabled)
                                        RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                        NULL);
                                    }
                               }
                               else
                               {
                                        DBGPRINT3(ERR, "NmsNmhNamRegGrp: Could not add member to the special group (%s[%x]). No Of Members existent are (%d)\n", RowInfo.pName, RowInfo.pName[15], RowInfo.NodeAdds.NoOfMems - 1);
                                        Rcode_e = NMSMSGF_E_SRV_ERR;
                               }
                           }
                           else
                           {
                             if (!fRetPosRsp)
                             {
                                 DBGPRINT1(FLOW,
                                        " %s Registration Failed. Conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC"
                                       );
                                 Rcode_e = NMSMSGF_E_ACT_ERR;
                             }
                           }
                        }
                        }
                } //RetStat from ClashAtRegGrp != WINS_SUCCESS
                else
                {
                        Rcode_e = NMSMSGF_E_SRV_ERR;
                }
       }
       else  //no conflict means success
       {
                DBGPRINT2(FLOW, "%s %s Registration Done. No conflict\n",
                                fStatic ? "STATIC" : "DYNAMIC",
                                TypeOfRec == NMSDB_MULTIHOMED_ENTRY ? "MULTIHOMED" : "GROUP");
                       NMSNMH_INC_VERS_COUNTER_M(
                                        NmsNmhMyMaxVersNo,
                                        NmsNmhMyMaxVersNo
                                       );
                DBGIF(fWinsCnfRplEnabled)
                RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
       }
      }
      else  //RetStat != SUCCESS
      {
        Rcode_e = NMSMSGF_E_SRV_ERR;

      }
     } // end of try block

except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhNamRegGrp");
                WinsEvtLogDetEvt(FALSE, WINS_EVT_REG_GRP_ERR,
                            NULL, __LINE__, "sddd", RowInfo.pName,
                            GetExceptionCode(),
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);

//                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_REG_GRP_ERR);
                Rcode_e = NMSMSGF_E_SRV_ERR;
        }

        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_PRINT_PERF_DATA;

SNDRSP:
        //
        // Send a response only if we did not hand over the request to the
        // name challenge manager and if it is neither a STATIC initialization
        // request nor a rpc request
        //
        if ((!fChlBeingDone) && (!fStatic) && (!fAdmin))
        {

                DBGPRINT1(FLOW,
                   "NmsNmhNamRegGrp: Sending %s name registration response\n",
                           Rcode_e == NMSMSGF_E_SUCCESS ? "positive" :
                                                "negative" );

                RspInfo.Rcode_e         = Rcode_e;
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;

                NmsNmhSndNamRegRsp( pDlgHdl, &RspInfo );
        }

        //
        // If it is an RPC request, we need to return a success or a failure
        // indication.
        //
        if (fAdmin)
        {
                if (Rcode_e != NMSMSGF_E_SUCCESS)
                {
                            DBGLEAVE("NmsNmhNamRegGrp\n");
                        return(WINS_FAILURE);
                }
        }

        DBGLEAVE("NmsNmhNamRegGrp\n");
        return(WINS_SUCCESS);

}

#if 0
__inline
BYTE
HexAsciiToBinary(
        LPBYTE pByte
        )

/*++

Routine Description:
        This function converts two bytes (each byte contains the ascii
        equivalent of a hex character in the range 0-F) to a binary
        representation

Arguments:


Externals Used:
        None


Return Value:


Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        BYTE  Byte = 0;
        DWORD Nibbles = 0;
        do
        {
          if (*pByte >= '0' && *pByte <= '9')
          {
                Byte += (*pByte - '0') << (Nibbles * 4);
          }
          else
          {
                Byte += (*pByte - 'A') << (Nibbles * 4);
          }
          pByte++;
        } while (++Nibbles < 2);
        return(Byte);
}

BOOL
IsItSpecGrpNm(
        LPBYTE pName
        )

/*++

Routine Description:
        This function is called to check whether the name is a special
        (internel group)

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DWORD        Index;
        DWORD   ByteIndex;
        BYTE    TmpName[16];
        LPBYTE  pTmpName = TmpName;
        LPBYTE  pSpecGrpMaskByte;
        LPBYTE  pSpecGrpMask;


        if (NMSDB_IS_IT_DOMAIN_NM_M((pName)))
        {
                return(TRUE);
        }
        else
        {
                //
                // if spec. grp mask were specified in the registry
                //
                if (WinsCnf.SpecGrpMasks.NoOfSpecGrpMasks > 0)
                {
                        //
                        // for each spec. grp mask, && it with the name
                        // and then see if the result is same as
                        // the mask.  If yes, then the name is a special group
                        //
                        for (
                                Index = 0,
                                pSpecGrpMask =
                                        WinsCnf.SpecGrpMasks.pSpecGrpMasks;
                                Index < WinsCnf.SpecGrpMasks.NoOfSpecGrpMasks;
                                Index++, pSpecGrpMask += WINSCNF_SPEC_GRP_MASK_SZ + 1
                            )
                        {
                                for (
                                        ByteIndex = 0, pSpecGrpMaskByte =
                                                        pSpecGrpMask;
                                        ByteIndex < WINSCNF_SPEC_GRP_MASK_SZ;
                                        ByteIndex++, pName++
                                    )
                                {
                                        *pTmpName++ = *pName &&
                                           HexAsciiToBinary(pSpecGrpMaskByte);

                                        //
                                        // Increment by 2 since we have two
                                        // bytes in the mask for each
                                        // character in the name
                                        //
                                        pSpecGrpMaskByte += 2;

                                }
                                if (WINSMSC_COMPARE_MEMORY_M(TmpName, pSpecGrpMask, WINSCNF_SPEC_GRP_MASK_SZ) == WINSCNF_SPEC_GRP_MASK_SZ)
                                {
                                        return(TRUE);
                                }
                                //
                                // iterate in order to get the next mask
                                //
                        }
                }
        }
        return(FALSE);
}
#endif
STATUS
NmsNmhNamRel(
        IN PCOMM_HDL_T                pDlgHdl,
        IN LPBYTE                pName,
        IN DWORD                NameLen,
        IN PCOMM_ADD_T                pNodeAdd,
        IN BOOL                        fGrp,
        IN MSG_T                pMsg,
        IN MSG_LEN_T                MsgLen,
        IN DWORD                QuesNamSecLen,
        IN BOOL                        fAdmin
        )

/*++

Routine Description:
        This function releases a record.

        In case the release succeeds, a positive name release
        response is sent, else a negative name release response is sent.

Arguments:

        pDlgHdl                - Dialogue Handle
        pName                - Name to be registered
        NameLen                - Length of Name
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fAdmin                - Is it an administrative action

Externals Used:
        NmsNmhNamRegCrtSec

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/
{


        NMSDB_ROW_INFO_T   RowInfo;      // contains row info
        NMSDB_STAT_INFO_T  StatusInfo;         /* error status and associated
                                         *  info returned by the NmsDb func
                                         */
        time_t                   ltime;  //stores time since Jan 1, 1970
        STATUS                   RetStat = WINS_FAILURE;
        NMSMSGF_RSP_INFO_T RspInfo;
        BOOL                   fBrowser = FALSE;
        BOOL                   fExcRecd = FALSE;
#ifdef WINSDBG
        DWORD                  StartTimeInMsec;
//        DWORD                  EndTimeInMsec;
#endif
        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhNamRel\n");
        /*
        *    Initialize the row info. data structure with the data to insert
        *    into the row.  The data passed is Name, NameLen, IP address,
        *    group/unique status, timestamp, version number
        */

        RowInfo.pName     = pName;
        RowInfo.NameLen   = NameLen;

        DBGPRINT2(FLOW,
         "NmsNmhNamRel: Name To Release = %s. 16th char is (%x)\n",
                                RowInfo.pName, *(RowInfo.pName+15));

        (void)time(&ltime); //time does not return any error code
        RowInfo.TimeStamp    = ltime;     //put the current time here
        RowInfo.OwnerId      = NMSDB_LOCAL_OWNER_ID;
        RowInfo.pNodeAdd     = pNodeAdd;
        RowInfo.fAdmin       = fAdmin;

        //
        //
        // If the release is for a group, mark it as a NORMAL or a SPECIAL
        // GROUP.
        //
        if (fGrp)
        {

                //
                // Since the group bit was set in the release request pkt
                // set the EntTyp field of RowInfo to NORM_GRP (or SPEC_GRP)
                // to indicate to the callee that we want to release a group
                //
                RowInfo.EntTyp                    = NMSDB_NORM_GRP_ENTRY;
        }
        else
        {
                //
                // The entry to release can be a unique or multihomed. We
                // put UNIQUE for lack of knowing better.
                //
                RowInfo.EntTyp                    = NMSDB_UNIQUE_ENTRY;
                if (NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
                {
                        //
                        // It is a browser name. We always return a positive
                        // name release response.
                        //
                        fBrowser             = TRUE;
                        StatusInfo.StatCode = NMSDB_SUCCESS;
						StatusInfo.fLocal = FALSE;
                        RetStat             = WINS_SUCCESS;
                }
        }


        //
        // If it is a browser name that needs to be released, we just send
        // a positive response
        //
        if (!fBrowser)
        {
             //
             // Enter the critical section since we will be updating the record
             //
             EnterCriticalSection(&NmsNmhNamRegCrtSec);


             /*
              * Store version number (in case we change ownership to self)
             */
             RowInfo.VersNo = NmsNmhMyMaxVersNo;

             //DBG_START_PERF_MONITORING
//             WinsIntfStat.Counters.NoOfRel++;
        try {
             //
             // Release the record in the directory.
             //
#ifdef WINSDBG
             IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif
             StatusInfo.fLocal = FALSE;
             RetStat = NmsDbRelRow( &RowInfo,  &StatusInfo );
#ifdef WINSDBG
             IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamRelRow: Time in NmsDbRelRow is = (%d). RetStat is (%d msecs)\n", GetTickCount() - StartTimeInMsec,
RetStat); }
#endif

            }
       except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhNamRel");
                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_NAM_REL_ERR);
                RspInfo.Rcode_e = NMSMSGF_E_SRV_ERR;
                fExcRecd = TRUE;
            }
            if (!fExcRecd && (StatusInfo.StatCode == NMSDB_SUCCESS))
            {
              WinsIntfStat.Counters.NoOfSuccRel++;
            }
            else
            {
              WinsIntfStat.Counters.NoOfFailRel++;
            }

            LeaveCriticalSection(&NmsNmhNamRegCrtSec);
            //DBG_PRINT_PERF_DATA
       }


        //
        // Send a response only it is not an administrator initiated request
        //
        if (!fAdmin)
        {
                if (!fExcRecd)
                {
                        RspInfo.Rcode_e =
                                ((StatusInfo.StatCode == NMSDB_SUCCESS)
                                && (RetStat == WINS_SUCCESS)) ?
                                 NMSMSGF_E_SUCCESS :
                                 NMSMSGF_E_ACT_ERR;
                }
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;

                //
                // If it is a locally registered name, mark it as such
                //
                if (StatusInfo.fLocal)
                {
                     COMM_SET_LOCAL_M(pDlgHdl);
                }

                //
                //Note: We always return the NodeType and Address that we got
                //in the request pkt. So the above fields are all that
                //need to be initialized
                //
                DBGPRINT1(FLOW, "NmsNmhNamRel: Name Release was %s\n",
                                RspInfo.Rcode_e == NMSMSGF_E_SUCCESS ?
                                        "SUCCESSFUL" : "FAILURE" );
#if 0
                WINSEVT_LOG_IF_ERR_M(
                               SndNamRelRsp(
                                pDlgHdl,
                                &RspInfo
                                    ),
                        WINS_EVT_SND_REL_RSP_ERR
                    );
#endif
                SndNamRelRsp( pDlgHdl,  &RspInfo);

        }
        else  // an RPC request
        {
                if (
                        (StatusInfo.StatCode != NMSDB_SUCCESS)
                                ||
                        (RetStat != WINS_SUCCESS)
                   )
                {
                        DBGLEAVE("NmsNmhNamRel\n");
                        return(WINS_FAILURE);
                }

        }
        DBGLEAVE("NmsNmhNamRel\n");
        return(WINS_SUCCESS);

} //NmsNmhNamRel()





STATUS
NmsNmhNamQuery(
        IN PCOMM_HDL_T                pDlgHdl,  //dlg handle
        IN LPBYTE                pName,          //Name to release
        IN DWORD                NameLen,  //length of name to release
        IN MSG_T                pMsg,          //length of message
        IN MSG_LEN_T                MsgLen,          //length of message
        IN DWORD                QuesNamSecLen, //length of question name
                                              //sec. in msg
        IN BOOL                        fAdmin,
        OUT PNMSDB_STAT_INFO_T        pStatInfo
  )

/*++

Routine Description:
        This function queries a record.


        In case the query succeeds, a positive name query
        response is sent, else a negative name query response is sent.

Arguments:

        pDlgHdl                - Dialogue Handle
        pName                - Name to be registered
        NameLen                - Length of Name
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fAdmin                - Is it an administrative action
        pStatInfo        - ptr to row information retrieved by this function


Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:


Called by:
        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/
{


        NMSDB_ROW_INFO_T      RowInfo;      // contains row info
        NMSDB_STAT_INFO_T     StatusInfo;   /* error status and associated
                                            *info returned by the NmsDb func
                                            */
        time_t                      ltime;
        STATUS                      RetStat  = WINS_SUCCESS;
        BOOL                      fBrowser = FALSE;
        BOOL                      fExcRecd = FALSE;
        NMSMSGF_RSP_INFO_T    RspInfo;
#ifdef WINSDBG
        DWORD                  StartTimeInMsec;
//        DWORD                  EndTimeInMsec;
#endif

        DBGENTER("NmsNmhNamQuery\n");

        /*
         *  Initialize the row info. data structure with the
         *  name of the entry to query
         *
        */
        RowInfo.pName   = pName;
        RowInfo.NameLen = NameLen;
        RowInfo.fAdmin  = fAdmin;

        DBGPRINT2(FLOW,
         "NmsNmhNamQuery: Name To Query = %s. 16th char is (%x)\n",
                                RowInfo.pName, *(RowInfo.pName+15));
        //
        // get the current time.
        //
        // This is required when querying special groups
        //
        (void)time(&ltime); //time does not return any error code
        RowInfo.TimeStamp    = ltime; // put current time here

        //
        // This initialization is required when query is for a special group
        //
CHECK("I don't think this is required now. Check NmsDbQueryRow")
        RowInfo.NodeAdds.Mem[0].Add.Add.IPAdd = 0;  //init to 0 since GetGrpMem
                                                    //looks at it


FUTURES("Don't check. Let it query. The query will fail")
        if (NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
        {
                //
                // It is a browser name. We always return a negative
                // name query response.
                //
                fBrowser             = TRUE;
                StatusInfo.StatCode = NMSDB_SUCCESS;
                RetStat             = WINS_FAILURE;
        }
        else
        {
        try {

#ifdef WINSDBG
           IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif

           //
           // Query the record in the directory.
           //
           RetStat = NmsDbQueryRow(
                                &RowInfo,
                                &StatusInfo
                                             );
#ifdef WINSDBG
          IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamQuery: Time in NmsDbQueryRow is = (%d). RetStat is (%d msecs)\n", GetTickCount() - StartTimeInMsec, RetStat); }
#endif
               } // end of try block
        except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhNamQuery");
                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_NAM_QUERY_ERR);
                RspInfo.Rcode_e = NMSMSGF_E_SRV_ERR;
                fExcRecd = TRUE;
             }
        }


        //
        // Do the following only if not invoked in an RPC thread (i.e. via
        // an administrator)
        //
        if (!fAdmin)
        {
                //
                // if no exception was raised
                //
                if (!fExcRecd)
                {

FUTURES("Rcode for neg, response should be different for different error cases")
                    RspInfo.Rcode_e =
                                ((StatusInfo.StatCode == NMSDB_SUCCESS)
                                && (RetStat == WINS_SUCCESS)) ?
                                 NMSMSGF_E_SUCCESS :
                                 NMSMSGF_E_NAM_ERR;

                    if (RspInfo.Rcode_e == NMSMSGF_E_SUCCESS)
                    {

                      DBGPRINT1(SPEC,
                                "Name queried has the fLocal flag set to %d\n",
                                StatusInfo.fLocal);

                      if (!StatusInfo.fLocal)
                      {
                        //
                        //  if this was a query for a special group, we
                        //  need to query the corresponding 1B name
                        //
#ifdef WINSDBG
                        if (NMSDB_IS_IT_DOMAIN_NM_M(RowInfo.pName))
                        {
                            DBGPRINT2(SPEC,
                                         "Answer 1C query (%d members). %s1B prepended\n",
                                         StatusInfo.NodeAdds.NoOfMems,
                                         WinsCnf.fAdd1Bto1CQueries ? "" : "No ");
                        }
#endif

                        if (NMSDB_IS_IT_DOMAIN_NM_M(RowInfo.pName) &&
                            WinsCnf.fAdd1Bto1CQueries)
                        {
                          NMSDB_ROW_INFO_T        StatusInfo2;
                          BOOL                        fExc = FALSE;
                          *(RowInfo.pName+15) = 0x1B;
                          WINS_SWAP_BYTES_M(RowInfo.pName, RowInfo.pName+15);
                          try {

                               //
                               // Query the record in the directory.
                               //
                               RetStat = NmsDbQueryRow(
                                &RowInfo,
                                &StatusInfo2
                                             );

                                  } // end of try block
                           except (EXCEPTION_EXECUTE_HANDLER) {
                              DBGPRINTEXC("NmsNmhNamQuery: Querying 1B name");
                              WINSEVT_LOG_D_M(
                                        GetExceptionCode(),
                                        WINS_EVT_NAM_QUERY_ERR
                                           );
                              fExc = TRUE;
                                 }

                           //
                           // If there was no exception or failure, add the
                           // address for the 1B name to the list. Ideally,
                           // we should check if the address is already there
                           // and if so not add it.  If not there but the
                           // number of members is < NMSDB_MAX_MEMS_IN_GRP, we
                           // should add the address at the begining shifting
                           // the other members one slot to the right (
                           // instead of replacing the last member with the
                           // first).  Checking for presence or doing the
                           // shifting will consume a lot of cycles, so it
                           // is not being done.
                           //

                           if ((RetStat != WINS_FAILURE) && !fExc)
                           {
                                if (
                                        StatusInfo.NodeAdds.NoOfMems <
                                                NMSDB_MAX_MEMS_IN_GRP
                                   )
                                {
                                   StatusInfo.NodeAdds.Mem[
                                        StatusInfo.NodeAdds.NoOfMems++] =
                                             StatusInfo.NodeAdds.Mem[0];
                                   StatusInfo.NodeAdds.Mem[0] =
                                                StatusInfo2.NodeAdds.Mem[0];
                                }
                                else
                                {
                                   StatusInfo.NodeAdds.Mem[NMSDB_MAX_MEMS_IN_GRP- 1]
                                        = StatusInfo.NodeAdds.Mem[0];
                                   StatusInfo.NodeAdds.Mem[0] =
                                        StatusInfo2.NodeAdds.Mem[0];
                                }
                           }
                        }
                       }   //if (!StatusInfo.fLocal)
                       else
                       {
                            COMM_SET_LOCAL_M(pDlgHdl);
                       }

                     } //if (RspInfo.Rcode_e == NMSMSGF_E_SUCCESS)
                } //if (!ExcCode)
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;
                RspInfo.NodeTyp_e       = StatusInfo.NodeTyp;
                RspInfo.EntTyp          = StatusInfo.EntTyp;
                RspInfo.pNodeAdds       = &StatusInfo.NodeAdds;


                //
                // NOTE: Multiple NBT threads could be doing this simultaneously
                //
                //  This is the best I can do without a critical section
                //
NOTE("The count may not be correct if we have multiple worker threads")
                if (RspInfo.Rcode_e == NMSMSGF_E_SUCCESS)
                {
                        WinsIntfStat.Counters.NoOfSuccQueries++;
                }
                else
                {
#if TEST_DATA > 0
                    DWORD BytesWritten;

                    if (NmsFileHdl != INVALID_HANDLE_VALUE)
                    {
                        pName[NameLen - 1] = '\n';
                        pName[NameLen] = '\0';
                        if (!WriteFile(NmsFileHdl,
                                  pName,
                                  NameLen + 1,
                                  &BytesWritten,
                                  NULL
                                 )
                           )
                        {
                                DBGPRINT1(ERR, "Could not write name (%s) to file\n", pName);
                        }
                    }

#endif
                        WinsIntfStat.Counters.NoOfFailQueries++;
                }

                DBGPRINT1(FLOW, "NmsNmhNamQuery: %s in querying record\n",
                                RspInfo.Rcode_e == NMSMSGF_E_SUCCESS ?
                                        "SUCCEEDED" : "FAILED" );
                WINSEVT_LOG_IF_ERR_M(
                        SndNamQueryRsp(
                          pDlgHdl,
                          &RspInfo
                                      ),
                     WINS_EVT_SND_QUERY_RSP_ERR
                     );
        }
        else
        {
                //
                // We are in an RPC thread.
                //
                if (
                        (RetStat != WINS_SUCCESS)
                                ||
                        (StatusInfo.StatCode != NMSDB_SUCCESS)
                   )
                {
                        DBGLEAVE("NmsNmhNamQuery\n");
                        return(WINS_FAILURE);
                }
                else
                {
                        DWORD i;

                        pStatInfo->NodeAdds.NoOfMems =
                                        StatusInfo.NodeAdds.NoOfMems;
                        for (i=0; i < StatusInfo.NodeAdds.NoOfMems; i++)
                        {
                          pStatInfo->NodeAdds.Mem[i].Add =
                                        StatusInfo.NodeAdds.Mem[i].Add;

                          pStatInfo->NodeAdds.Mem[i].OwnerId =
                                        StatusInfo.NodeAdds.Mem[i].OwnerId;

                          pStatInfo->NodeAdds.Mem[i].TimeStamp =
                                        StatusInfo.NodeAdds.Mem[i].TimeStamp;
                        }

                        pStatInfo->VersNo    = StatusInfo.VersNo;
                        pStatInfo->OwnerId   = StatusInfo.OwnerId;
                        pStatInfo->EntTyp    = StatusInfo.EntTyp;
                        pStatInfo->TimeStamp = StatusInfo.TimeStamp;
                        pStatInfo->NodeTyp   = StatusInfo.NodeTyp;
                        pStatInfo->EntryState_e   = StatusInfo.EntryState_e;
                        pStatInfo->fStatic   = StatusInfo.fStatic;

                }

        }
        DBGLEAVE("NmsNmhNamQuery\n");
        return(WINS_SUCCESS);
} //NmsNmhNamQuery()


VOID
NmsNmhSndNamRegRsp(
        IN  PCOMM_HDL_T                              pDlgHdl,
        IN  PNMSMSGF_RSP_INFO_T        pRspInfo
        )

/*++

Routine Description:
        This function sends the name registration response to the nbt client.


Arguments:

        pDlgHdl                - Dialogue Handle
        pRspInfo         - pointer to the response info structure

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        DBGENTER("NmsNmhSndNamRegRsp\n");

        /*
         *        format the name registration response packet
        */
        NmsMsgfFrmNamRspMsg(
                        pDlgHdl,
                        NMSMSGF_E_NAM_REG,
                        pRspInfo
                           );
        /*
         *        Call COMM to send it.  No need to check the return status
        */
        (VOID)ECommSndRsp(
                        pDlgHdl,
                        pRspInfo->pMsg,
                        pRspInfo->MsgLen
                   );
        /*
         *  Deallocate the Buffer
        */
        ECommFreeBuff(pRspInfo->pMsg);

        DBGLEAVE("NmsNmhSndNamRegRsp\n");
        return;

} //NmsNmhSndNamRegRsp()


FUTURES("change return type of this function to VOID")
STATUS
SndNamRelRsp(
        IN PCOMM_HDL_T                 pDlgHdl,
        IN PNMSMSGF_RSP_INFO_T   pRspInfo
        )

/*++

Routine Description:
        This function sends the name release response to the nbt client.


Arguments:
        pDlgHdl                - Dialogue Handle
        pRspInfo         - Response Info

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        DBGENTER("SndNamRelRsp\n");

        /*
                format the name registration response packet
        */
        NmsMsgfFrmNamRspMsg(
                        pDlgHdl,
                        NMSMSGF_E_NAM_REL,
                        pRspInfo
                           );
        /*
         *        Call COMM to send it.  No need to check the return status
        */
        (VOID)ECommSndRsp(
                        pDlgHdl,
                        pRspInfo->pMsg,
                        pRspInfo->MsgLen
                   );

        /*
         *  Deallocate the Buffer
        */
        ECommFreeBuff(pRspInfo->pMsg);

        DBGLEAVE("SndNamRelRsp\n");
        return(WINS_SUCCESS);

} // SndNamRelRsp()

STATUS
SndNamQueryRsp(
        IN PCOMM_HDL_T                 pDlgHdl,
        IN PNMSMSGF_RSP_INFO_T   pRspInfo
        )

/*++

Routine Description:
        This function sends the name registration response to the nbt client.

Arguments:
        pDlgHdl                - Dialogue Handle
        pRspInfo         - Response Info

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        DBGENTER("SndNamQueryRsp\n");

        /*
                format the name registration response packet
        */
        NmsMsgfFrmNamRspMsg(
                        pDlgHdl,
                        NMSMSGF_E_NAM_QUERY,
                        pRspInfo
                           );
        /*
         *        Call COMM to send it.  No need to check the return status
        */
        (VOID)ECommSndRsp(
                        pDlgHdl,
                        pRspInfo->pMsg,
                        pRspInfo->MsgLen
                   );

FUTURES("When we start supporting responses > COMM_DATAGRAM_SIZE, the ")
FUTURES("deallocation call will have to change")
        /*
         *  Deallocate the Buffer
        */
        ECommFreeBuff(pRspInfo->pMsg);

        DBGLEAVE("SndNamQueryRsp\n");
        return(WINS_SUCCESS);

} // SndNamQueryRsp()

STATUS
ClashAtRegInd (
        IN  PNMSDB_ROW_INFO_T    pEntryToReg,
        IN  PNMSDB_STAT_INFO_T   pEntryInCnf,
        IN  BOOL                 fRefresh,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfAddDiff,
        OUT PBOOL                pfRetPosRsp
 )

/*++

Routine Description:

        This function is called when there is a clash at the registrationo                 of a unique entry sent by an NBT node

Arguments:
        pEntryToReg  -- Entry that couldn't be registered due to conflict
        pEntryInCnf  -- Entry in conflict
        fRefresh     -- indicates whether it is a registration or a refresh
                        (used only when the clash is with a multihomed entry)
        pfUpdate  -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo  -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE
        pfChallenge  -- TRUE means that conflicting entry should be challenged
        pfAddDiff    -- TRUE means that the address of the conflicting entry
                        needs to be changed (besides other fields like timestamp                        owner id, etc).  If *pfChallenge is TRUE, this field
                        is FALSE since *pfChallenge of TRUE implies address
                        change when the challenge succeeds

Externals Used:
        None

Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegInd,  NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        STATUS                 RetStat = WINS_SUCCESS;
        DWORD                  CompAddRes;  /*Result of comparing addresses*/
        BOOL                   fOwned;
        BOOL                   fFound;

        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;
        BOOL                   fContToDyn = FALSE;

        DBGENTER("ClashAtRegInd\n");
        *pfUpdate     = FALSE;
        *pfUpdVersNo  = FALSE;
        *pfChallenge  = FALSE;
        *pfAddMem     = FALSE;
        *pfAddDiff    = FALSE;
        *pfRetPosRsp  = FALSE;

        //
        // If the conflicting record was statically initialized and
        //
        if (  pEntryInCnf->fStatic )
        {
                DBGPRINT0(FLOW, "ClashAtRegInd: Clash with a STATIC record\n");


                //
                // If entry in conflict is a unique/multihomd entry, we
                // compare the address.
                //
                //
                // Since in the majority of cases, the conflict will be
                // with a unique record, we first check whether the
                // conflicting record is unique.  This saves some cyles.
                // The alternative way would have been to check whether
                // conflicting record is a group and if not do the for loop
                // For the case where the record was unique, the for loop
                // would have executed only once.
                //
                if (NMSDB_ENTRY_UNIQUE_M(pEntryInCnf->EntTyp))
                {
                        CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                );
                }
                else
                {
                        DWORD  NoOfEnt;
                        PNMSDB_GRP_MEM_ENTRY_T pCnfMem;

                        //
                        // Entry in conflict is a group or a mh entry
                        //
                        CompAddRes = COMM_DIFF_ADD;
                        if (fRefresh &&
                              NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp))
                        {
                           pCnfMem   =  pEntryInCnf->NodeAdds.Mem;
                           for (NoOfEnt = 0;
                                NoOfEnt < pEntryInCnf->NodeAdds.NoOfMems;
                                pCnfMem++, NoOfEnt++)
                           {
                                  //
                                  // save on cycles by comparing just the IP
                                  // address.
                                  //
NONPORT("Change to stuff within #if 0 #endif when more than one transport")
NONPORT("is supported")
                                  if (pCnfMem->Add.Add.IPAdd ==
                                               pEntryToReg->pNodeAdd->Add.IPAdd)
                                  {
                                            CompAddRes = COMM_SAME_ADD;
                                            break;
                                  }
                           } // compare refresh add. with each add in the static
                             // mh entry
                        } //a refresh clashed with a static mh entry
                }  // conflicting entry is either multihomed or a group
#if 0
                //
                // Compare with address when the entry in conflict is
                // not a group.
                //
                // NOTE: For multihomed entry, we are comparing with the
                // first (perhaps only) address.  Strictly speaking, we
                // should compare with all addresses, but this will add
                // to overhead for the majority of cases. See FUTURES
                // above.
                //
                if (!NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                {
                        CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                );
                }
                else
                {
                        CompAddRes = COMM_DIFF_ADD;
                }
#endif
                //
                // If the record to register is not a STATIC record, we
                // return right away.  We don't update a STATIC record with a
                // dynamic record in this function (do it in NmsDbQueryNUpd when
                // called in an RPC thread -- see winsintf.c)
                //
                // If however the record to register is also STATIC, then we
                // overwrite the one in the db with it.
                //
                if (pEntryToReg->fStatic)
                {
                         //
                         // If addresses are different, we need to propagate
                         // the change right away. So, set the fAddDiff flag.
                         //
                         if  (CompAddRes == COMM_DIFF_ADD)
                         {
                                *pfAddDiff   = TRUE;
                         }

                        *pfUpdate    = TRUE;

                         //
                         // If the address changed or if we replaced a STATIC
                         // replica, we should update the version number
                         // to initiate replication
                         //
                         if (
                              (pEntryInCnf->OwnerId != NMSDB_LOCAL_OWNER_ID)
                                        ||
                               *pfAddDiff
                            )
                         {
                                *pfUpdVersNo = TRUE;
                         }

                }
                else  // entry to register is dynamic
                {
                         //
                         // If addresses are the same, we return a positive
                         // response
                         //
                         if (CompAddRes == COMM_SAME_ADD)
                         {
                                *pfRetPosRsp   = TRUE;
                         }
                         else
                         {
                              if (fPStatic  &&
                                       !NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                              {
                                   fContToDyn = TRUE;
                              }
                         }
                }
                //
                // If we don't need to conduct the tests meant for dynamic
                // records, return
                //
                if (!fContToDyn)
                {
                  DBGLEAVE("ClashAtRegInd\n");
                  return(WINS_SUCCESS);
                }
        }

        if (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
        {
           switch(StateOfEntryInCnf_e)
           {

                case(NMSDB_E_TOMBSTONE):
                        *pfUpdate    = TRUE;
                        *pfUpdVersNo = TRUE;

                         CompAddRes = ECommCompAdd(
                                &pEntryInCnf->NodeAdds.Mem[0].Add,
                                pEntryToReg->pNodeAdd
                                                );
                         if (CompAddRes == COMM_DIFF_ADD)
                         {
                                *pfAddDiff = TRUE;
                         }
                         break;

                case(NMSDB_E_RELEASED):

                         CompAddRes = ECommCompAdd(
                                &pEntryInCnf->NodeAdds.Mem[0].Add,
                                pEntryToReg->pNodeAdd
                                                );

                        switch(CompAddRes)
                        {
                           case(COMM_SAME_ADD):
                                *pfUpdate    = TRUE;

#if 0
                                //
                                // If database record is a replica, we need
                                // to overwrite it with the new one (owned by
                                // the local WINS).  This means that we must
                                // update the version number to cause
                                // propagation
                                //
                                if (
                                        pEntryInCnf->OwnerId !=
                                                pEntryToReg->OwnerId
                                   )
                                {
                                   *pfUpdVersNo = TRUE;
                                }
#endif
                                //
                                // update the version number.  Maybe this
                                // record never replicated to one or more
                                // WINS servers before.  We should
                                // update the version number so that it gets
                                // replicated
                                //
                                *pfUpdVersNo = TRUE;

                                break;

                            //
                            // address is not same
                            //
                            default:

                                *pfUpdate     = TRUE;
                                *pfUpdVersNo  = TRUE;
                                *pfAddDiff    = TRUE;
                                break;
                         }
                        break;

                case(NMSDB_E_ACTIVE):

                         //
                         // We do the following only if the entry in
                         // conflict is a unique entry
                         //
                         //  If it is a group entry (normal group), we give
                         //  up trying to register.
                         //
                        CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                         );

                        switch(CompAddRes)
                        {
                                    case(COMM_SAME_ADD):
                                        //
                                        // If it is a repeat name reg.
                                        // just update the timestamp
                                        //
                                        if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                        {
                                                *pfUpdate = TRUE;
                                        }
                                        else
                                        {
                                                //
                                                // Clash is with a replica
                                                // Update both the owner id and
                                                // and the version number
                                                //
                                                *pfUpdate     = TRUE;
                                                *pfUpdVersNo  = TRUE;
                                        }
                                        break;

                                       default:


                                            *pfChallenge = TRUE;

                                          //
                                          // No need to set the pAddDiff
                                          // flag.  The above flag implies that
                                          //
                                       break;
                         }
                         break;


                default:
                        DBGPRINT1(ERR,
                         "ClashAtRegInd: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        RetStat = WINS_FAILURE;
                        break;

              }
        }
        else  //conflicting entry is a group or a multihomed entry
        {
                //
                // There are two type of group records
                //
                // Normal group -- do not contain any addresses in them so there
                //                 is no challenge to be done here.
                // Special group -- store addresses in them but the members are
                //                  not supposed to be challenged.
                //
CHECK("According to the Func. Spec. Page 14, footnote 3, we are supposed")
CHECK("to reject the unique registration regardless of the state of a group")
CHECK("--Normal or Special. Think this one through")
                if (
                        (NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                                        &&
                        (StateOfEntryInCnf_e == NMSDB_E_TOMBSTONE)
                   )
                {
                        *pfUpdate    = TRUE;
                        *pfUpdVersNo = TRUE;
                }
                else  // conflicting record is  not a tombstone special group
                {
                        if (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp))
                        {
                             //
                             // If the multihomed entry is active
                             //
                             if(StateOfEntryInCnf_e == NMSDB_E_ACTIVE)
                             {

                                DBGPRINT3(SPEC, "ClashAtRegInd: Name to reg = (%s), Vers. No (%d, %d)\n", pEntryToReg->pName, pEntryToReg->VersNo.HighPart, pEntryToReg->VersNo.LowPart);
                                //
                                // MemInGrp will remove the entry from the
                                // conflicting record if present.  That is what
                                // we want.
                                //
                                fFound = MemInGrp(
                                            pEntryToReg->pNodeAdd,
                                            pEntryInCnf,
                                            &fOwned, FALSE);


                                //
                                // If this is a refresh
                                //
                                if (fFound && fRefresh)
                                {
                                        DBGPRINT0(DET, "ClashAtRegInd: Refresh of a multihomed entry. Simple Update will be done\n");

                                        *pfAddMem = TRUE;
                                        if (!fOwned)
                                        {
                                                //
                                                // It is a refresh for an
                                                // address that is not owned
                                                // by the local WINS
                                                //
                                                *pfUpdVersNo = TRUE;
                                        }
                                }
                                else  //either address was not found or it
                                      //is a registration
                                {
                                        //
                                        // It is a registration, or a refresh
                                        // for an address not found in the
                                        // multihomed record.
                                        //
                                        // The active multihomed entry needs to
                                        // be challenged if there is atleast one                                        // address left in it.
                                        //
                                        if (pEntryInCnf->NodeAdds.NoOfMems > 0)
                                        {
                                           DBGPRINT0(DET, "ClashAtRegInd: Clash with a multihomed entry. Atleast one address is different. Resorting to challenge\n");
                                           *pfChallenge = TRUE;
                                        }
                                        else
                                        {
                                           DBGPRINT0(DET, "ClashAtRegInd: Clash with a multihomed entry. Addresses match. Will do simple update\n");

                                                //ASSERT(fFound);
                                                if (!fOwned)
                                                {
                                                        *pfUpdVersNo = TRUE;
                                                }

                                                //
                                                // Update the entry
                                                //
                                                *pfUpdate = TRUE;
                                        }
                                }
                             }
                             else //multihomed entry in conflict is a
                                  //tombstone or released
                             {
                                *pfUpdate    = TRUE;
                                *pfUpdVersNo = TRUE;
                             }
                        }
                        //
                        // if the conflicting entry is not a tombstone special
                        // group and is not multihomed (i.e. it is a normal
                        // group or active/released special group), we
                        // do nothing (i.e. reject the registration)
                        //
                }
        }

        DBGLEAVE("ClashAtRegInd\n");
        return(RetStat);

} // ClashAtRegInd()

STATUS
ClashAtRegGrp (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        IN  BOOL                fRefresh,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRetPosRsp
 )

/*++

Routine Description:

        This function is called when there is a clash at registration time
        of a group entry

Arguments:

        pEntryToReg  -- Entry that couldn't be registered due to conflict
        pEntryInCnf  -- Entry in conflict
        pfAddMem     -- TRUE means that the member should be added to group
        pfUpdate     -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo  -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE
        pfChallenge  -- TRUE means that conflicting entry should be challenged
        pfRetPosRsp  -- TRUE means that we should return a positive response.
                        This will be TRUE only if all other flags are
                        FALSE

Externals Used:
        None

Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        STATUS                 RetStat                    = WINS_SUCCESS;
        BOOL                   fOwned;
        DWORD                  i;
        BOOL                   fFound;

        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;
        BOOL                   fContToDyn = FALSE;


        DBGENTER("ClashAtRegGrp\n");

        *pfAddMem     = FALSE;
        *pfUpdate     = FALSE;
        *pfUpdVersNo  = FALSE;
        *pfChallenge  = FALSE;
        *pfRetPosRsp  = FALSE;

        //
        // If the conflicting record was statically initialized and
        // we haven't been told to treat static records as P-static or
        // if the record to register is also a static record, do the following.
        //
        if ( pEntryInCnf->fStatic )
        {
                DBGPRINT0(FLOW, "ClashAtRegGrp: Clash with a STATIC record\n");
                if (pEntryToReg->fStatic)
                {
                        if (
                                ((pEntryToReg->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                                                &&
                                (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY))
                                               ||
                                ((pEntryToReg->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                                                &&
                                (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY))
                           )
                        {
                            // *pfAddMem = TRUE;
                            //
                            // We are not interested in finding out whether
                            // the address exists or not.  If it exists, it
                            // won't after the following call.
                            //
                            for (i=0; i < pEntryToReg->NodeAdds.NoOfMems; i++)
                            {

                               (VOID)MemInGrp(&pEntryToReg->NodeAdds.Mem[i].Add,
                                             pEntryInCnf,
                                             &fOwned, FALSE);
                               //
                               //fOwned will be FALSE if either the address does
                               //not exist or if it existed but was owned by
                               //another WINS server. For both cases, we update
                               //the version number.
                               //NOTE: In case the address exists but is a
                               //permanent one (TimeStamp == MAXULONG), fOwned
                               //returned will be TRUE. This will result
                               //in us skipping the update.
                               //Currently MAXULONG is there only for static
                               //SG members.
                               //
                               if (!*pfUpdVersNo && !fOwned)
                               {
                                *pfUpdVersNo  = TRUE;
                                *pfAddMem     = TRUE;
                               }
                             }
                             if (!*pfUpdVersNo)
                             {
                                 *pfRetPosRsp = TRUE;

                             }
                       } // both are special groups or mh names
                       else
                       {
                             *pfUpdate    = TRUE;
                             *pfUpdVersNo = TRUE;
                       }
                }
                else  // entry to register is a dynamic entry
                {
                        //
                        // We send a positive response if a normal group
                        // clashes with a statically initialized normal group
                        //
                        if ( NMSDB_ENTRY_NORM_GRP_M(pEntryToReg->EntTyp) )
                        {
                                if (NMSDB_ENTRY_NORM_GRP_M(pEntryInCnf->EntTyp))
                                {
                                   *pfRetPosRsp = TRUE;
                                }
                                //
                                // if the entry in conflict is a special group, we add
                                // this (potential) new group member to the list of members.
                                // Note: we do not touch multi-homed or unique static
                                // entry.
                                //
                                else if ( NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp) )
                                {
                                   //
                                   //NOTE: In case the address exists but is a
                                   // perm. one (TimeStamp == MAXULONG), fOwned
                                   // returned will be TRUE. This will result
                                   // in us skipping the update. Currently
                                   // MAXULONG is there only for static
                                   // SG members.
                                   //
                                   (VOID)MemInGrp(
                                             &pEntryToReg->NodeAdds.Mem[0].Add,
                                             pEntryInCnf,
                                             &fOwned, TRUE);
                                    if (!fOwned)
                                    {
                                      *pfUpdVersNo  = TRUE;
                                      *pfAddMem     = TRUE;
                                      pEntryToReg->fStatic = TRUE;
                                      pEntryToReg->EntTyp = NMSDB_SPEC_GRP_ENTRY;
                                    }
                                } else {
                                    //
                                    // the entry in conflict is either unique or multihomed
                                    //
                                    DBGPRINT1(FLOW, "ClashAtRegGrp: Conflict of a NORM. GRP (to reg) with a STATIC ACTIVE %s entry.\n",
                                    NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp) ? "MULTIHOMED" : "UNIQUE");
                                    //
                                    // if we are told to treat static as P-Static, then do the challenge etc.
                                    //
                                    if (fPStatic)
                                    {
                                          fContToDyn = TRUE;
                                    }

								}
                        }
                        else
                        {
                            if (
                                  (NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp))
                                                &&
                                  (NMSDB_ENTRY_SPEC_GRP_M(pEntryToReg->EntTyp))
                               )
                            {

                                  //
                                  // Always send a positive response, even
                                  // though we are not adding the address to
                                  // the list
                                  //
                                  *pfRetPosRsp = TRUE;
                            }   // both entries are special group entries
                            else
                            {
                               if (fPStatic && !NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                               {
                                     fContToDyn = TRUE;
                               }
                               else
                               {
                                  if (
                                   NMSDB_ENTRY_MULTIHOMED_M(pEntryToReg->EntTyp)
                                        &&
                                   (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp) ||
                                    NMSDB_ENTRY_UNIQUE_M(pEntryInCnf->EntTyp))
                                     )
                                   {
                                     DWORD NoOfMem;
                                     PNMSDB_GRP_MEM_ENTRY_T pCnfMem =
                                                pEntryInCnf->NodeAdds.Mem;
                                     for (NoOfMem=0;
                                       NoOfMem < pEntryInCnf->NodeAdds.NoOfMems;
                                            pCnfMem++, NoOfMem++)
                                     {
                                        //
                                        // if addresses are same, break out of
                                        // the loop
                                        //
                                        if (pCnfMem->Add.Add.IPAdd ==
                                        pEntryToReg->NodeAdds.Mem[0].Add.Add.IPAdd)
                                        {
                                                *pfRetPosRsp = TRUE;
                                                break;
                                        } //addresses match
                                      } //for loop over all members
                                    } //both entries are multihomed
                                  } // Either PStatic flag is not set or the
                                    // conflicting entry is not a group
                               } //one of the entries is not a special group
                        } //one of the entries is not a normal group
                } //entry to reg is dynamic

                //
                // If we don't need to conduct the tests meant for dynamic
                // records, return
                //
                if (!fContToDyn)
                {
                   DBGLEAVE("ClashAtRegGrp\n");
                   return(WINS_SUCCESS);
                }
        }

        //
        // We are here means that entry in conflict is either dynamic or
        // should be treated as a dynamic entry (p-dynamic)
        //

        if (pEntryToReg->EntTyp == NMSDB_SPEC_GRP_ENTRY)
        {
             if (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
             {
                   //
                   // If the entry is not active it means that it has
                   // no members.
                   //
                   // If it is active, we add the member if
                   // not there already.
                   //
                   if (StateOfEntryInCnf_e != NMSDB_E_ACTIVE)
                   {
                           *pfUpdate    = TRUE;
                           *pfUpdVersNo = TRUE;

                   }
                   else // entry in conflict is an ACTIVE dynamic SG entry
                   {

                        //
                        // If Entry to register is static, we have got to
                        // do an update if for no other reason than to change
                        // the flags.
                        //
                        if (pEntryToReg->fStatic)
                        {
                             *pfAddMem     = TRUE;
                             *pfUpdVersNo  = TRUE;
                             for (i = 0;i < pEntryToReg->NodeAdds.NoOfMems;i++)
                             {
                                (VOID)MemInGrp(
                                         &pEntryToReg->NodeAdds.Mem[i].Add,
                                         pEntryInCnf,
                                         &fOwned,
                                         FALSE // no need to remove replica
                                              );
                             }
                        }
                        else // entry to register is a dynamic SG entry
                        {

                          //
                          // We need to update the entry if for no other
                          // reason than to update the time stamp
                          //
                          *pfAddMem     = TRUE;

                          //
                          // We are not interested in finding out whether
                          // the address exists or not.  If it exists, it
                          // won't after the following call.
                          //
                          fFound = MemInGrp(&pEntryToReg->NodeAdds.Mem[0].Add,
                                             pEntryInCnf,
                                             &fOwned,
                                             FALSE //no need to remove replica
                                                   //mem. That will be high
                                                   //overhead
                                                );
                           //
                           // If entry is either not there or the record is
                           // a replica increment the version number.
                           //
                           if (!fFound ||
                                (pEntryInCnf->OwnerId != NMSDB_LOCAL_OWNER_ID))
                           {
                              *pfUpdVersNo  = TRUE;
                           }

                        }
                   }
             }
             else  //entry in conflict is a normal group or a
                   //unique/multihomed entry
             {
                if (pEntryInCnf->EntTyp == NMSDB_NORM_GRP_ENTRY)
                {
CHECK("I may not want to update it. Check it")
                            *pfUpdate    = TRUE;
                            *pfUpdVersNo = TRUE;
                }
                else  //conflicting entry is a unique/multihomed entry
                {
                        if (StateOfEntryInCnf_e == NMSDB_E_ACTIVE)
                        {
                                 DBGPRINT1(FLOW, "ClashAtRegGrp: Conflict of a SPEC. GRP (to reg) with an ACTIVE %s entry.  Resorting to challenge\n",
                         NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp) ?
                         "MULTIHOMED" : "UNIQUE");
                                if (
                                        (NMSDB_ENTRY_MULTIHOMED_M(
                                                pEntryInCnf->EntTyp)
                                                &&
                                        (pEntryInCnf->NodeAdds.NoOfMems > 0))
                                                ||
                                        NMSDB_ENTRY_UNIQUE_M(
                                                pEntryInCnf->EntTyp)
                                   )
                                {
                                        *pfChallenge = TRUE;
                                }
                                else
                                {
                                    *pfUpdate    = TRUE;
                                    *pfUpdVersNo = TRUE;
                                }
                        }
                        else  // unique/multihomed entry is either released
                              // or a tombstone
                        {
                                *pfUpdate    = TRUE;
                                *pfUpdVersNo = TRUE;
                        }
                }
             }
        }
        else   // Entry to register is a normal group/multihomed entry
        {
           //
           // If entry is a normal group
           //
           if (NMSDB_ENTRY_NORM_GRP_M(pEntryToReg->EntTyp))
           {
             switch(StateOfEntryInCnf_e)
             {

                case(NMSDB_E_TOMBSTONE):
                        *pfUpdate    = TRUE;
                        *pfUpdVersNo = TRUE;
                        break;

                case(NMSDB_E_RELEASED):

                        if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                        {
                                *pfUpdate    = TRUE;
                                *pfUpdVersNo = TRUE;
                        }
                        else  //Normal group entry
                        {
                                //
                                // If the owner id is the same (i.e.
                                // local WINS is the owner)
                                //
                                if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                {
                                        *pfUpdate = TRUE;  //this should
                                                           //update the
                                                              //time stamp
                                }
                                else
                                {
                                        //
                                        // Update the owner id., timestamp
                                        // and version number
                                        //
                                        *pfUpdate    = TRUE;
                                        *pfUpdVersNo = TRUE;
                                }
                        }
                        break;

                //
                // Entry to register is an ACTIVE normal group entry
                // and it is clashing with an ACTIVE records in the db
                //
                case(NMSDB_E_ACTIVE):

                        if (
                                (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                        ||
                                (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                           )
                        {
                             DBGPRINT1(FLOW, "ClashAtRegGrp: Normal Grp (to Reg) Conflicting with an ACTIVE %s entry.  Resorting to Challenge\n",
                                pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY ?                                        "UNIQUE" : "MULTIHOMED");
                                if (
                                        (NMSDB_ENTRY_MULTIHOMED_M(
                                                pEntryInCnf->EntTyp)
                                                &&
                                        (pEntryInCnf->NodeAdds.NoOfMems > 0))
                                                ||
                                        NMSDB_ENTRY_UNIQUE_M(
                                                pEntryInCnf->EntTyp)
                                   )
                                {
                                        *pfChallenge = TRUE;
                                }
                                else
                                {
                                    *pfUpdate    = TRUE;
                                        *pfUpdVersNo = TRUE;
                                }
                        }
                        else
                        {
                             if (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                             {
                                        DBGPRINT0(FLOW, "ClashAtRegGrp: Conflicting entry is an ACTIVE spec. group entry. NO UPDATE WILL BE DONE \n");

                             }
                             else //entry in cnf is an active normal group entry
                             {

                                   DBGPRINT0(FLOW, "ClashAtRegGrp: Conflicting entry is an ACTIVE normal group entry. Do a simple update \n");
                                   *pfUpdate    = TRUE;
                                   if (pEntryInCnf->OwnerId !=
                                                NMSDB_LOCAL_OWNER_ID)
                                   {
                                      *pfUpdVersNo = TRUE;
                                   }
                             }

                        }
                        break;

                default:
                        //
                        //  Something really wrong here. Maybe the
                        //  database got corrupted.
                        //
                        DBGPRINT1(ERR,
                         "ClashAtRegGrp: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        RetStat = WINS_FAILURE;
                        break;
             } // end of switch
          }
          else  // entry to register is a multihomed entry
          {
                switch(StateOfEntryInCnf_e)
                {
                        //
                        // If entry in database is a tombstone, we overwrite it
                        //
                        case(NMSDB_E_TOMBSTONE):
                            *pfUpdate    = TRUE;
                            *pfUpdVersNo = TRUE;
                            break;

                        //
                        // A released entry unless it is a normal group is
                        // overwritten
                        //
                        case(NMSDB_E_RELEASED):

                          if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                          {
                                *pfUpdate    = TRUE;

                                //
                                // Even if the entry in conflict is a multihomed                                // entry, we update the version number.
                                //
                                *pfUpdVersNo = TRUE;
                          }
                          break;

                        case(NMSDB_E_ACTIVE):

                                //
                                // we resort to a challenge only if the
                                // conflicting entry is a unique or
                                // multihomed entry
                                //
                                if (
                                        NMSDB_ENTRY_MULTIHOMED_M(
                                                        pEntryInCnf->EntTyp
                                                            )
                                                ||
                                        NMSDB_ENTRY_UNIQUE_M(
                                                        pEntryInCnf->EntTyp
                                                            )
                                   )
                                {
                                        if (NMSDB_ENTRY_MULTIHOMED_M(
                                                pEntryInCnf->EntTyp)
                                           )
                                        {

                                                BOOL  fFound;
                                                DWORD i;

                                                for ( i = 0;
                                                      i < pEntryToReg->NodeAdds.NoOfMems;                                                       i++
                                                    )
                                                {

                                                   //
                                                   // If found, MemInGrp will
                                                   // remove the address from
                                                   // the Mem array of the
                                                   // conflicting record
                                                   //
                                                      fFound = MemInGrp(
                                                          &pEntryToReg->NodeAdds.Mem[i].Add,
                                                           pEntryInCnf,
                                                           &fOwned,
                                                           FALSE);
                                                   //
                                                   // Address not found,
                                                   // continue to the next
                                                   // address
                                                   //
                                                   if (!fFound)
                                                   {
                                                        continue;
                                                   }

                                                   //
                                                   // if not owned by this WINS
                                                   // the version number must
                                                   // be updated if we end up
                                                   // just updating the entry (
                                                   // i.e. if fAddMem gets set
                                                   // to TRUE down below)
                                                   //
                                                   if (!fOwned)
                                                   {
                                                        *pfUpdVersNo = TRUE;
                                                   }
                                                }

                                                //
                                                // If all addresses to register
                                                // are already there in the
                                                // conflicting record and it
                                                // is a refresh or if the
                                                // addresses to register are
                                                // same as in the conflicting
                                                // record, we need to update
                                                // the timestamp and possibly
                                                // the version number (see
                                                // above).  There is no need to
                                                // do any challenge
                                                // here.
                                                //
                                                if (
                        //
                        // Note the following code would be executed only
                        // if we start supporting our own opcode for multihomed
                        // refresh (the need for this will arise if we go
                        // with the approach of refreshing multiple addresses
                        // simultaneously).
                        //
FUTURES("May need the code within #if 0 and #endif in the future. See ")
FUTURES("the comment above")
#if 0
                                                    (
                                                    (i == pEntryToReg->NodeAdds.NoOfMems)
                                                          &&
                                                        fRefresh
                                                    )
                                                         ||
#endif
                                                    (pEntryInCnf->NodeAdds.NoOfMems == 0)
                                                  )
                                                {
                        DBGPRINT0(DET, "ClashAtRegGrp: Clash between two multihomed entries.  The addresses are the same. Simple update will be done\n");
                                                    *pfAddMem = TRUE;
                                                }
                                                else
                                                {
                                                  //
                                                  // We do a challenge even
                                                  // if the conflicting entry's
                                                  // addresses are a superset
                                                  // of the addresses in the
                                                  // entry to register
                                                  //
                        DBGPRINT0(DET, "ClashAtRegGrp: Clash between two multihomed entries.  Atleast one address is different. Resorting to a challenge\n");
                                                   //
                                                   // The  multihomed entry
                                                   // needs to be challenged
                                                   //
                                                      *pfChallenge = TRUE;
                                                }
                                        }
                                        else
                                        {

                                              //
                                              // If there is any address in
                                              // the multihomed entry to
                                              // register that is different
                                              // than the address in the unique
                                              // entry, we need to challenge
                                              // the unique entry
                                              //
                                              if (
                                            (pEntryToReg->NodeAdds.NoOfMems > 1)
                                                        ||

                                            (WINSMSC_COMPARE_MEMORY_M(
                                              &pEntryToReg->NodeAdds.Mem[0].Add.Add.IPAdd,
                                                  &pEntryInCnf->NodeAdds.Mem[0].Add.Add.IPAdd, sizeof(COMM_IP_ADD_T))
                                                        != sizeof(COMM_IP_ADD_T)                                             )
                                                )

                                             {
                DBGPRINT0(DET, "ClashAtRegGrp: Clash between multihomed entry (to reg) and active unique entry. At least one address differs. Resorting to challenge\n");
                                                //
                                                // The  unique entry
                                                // needs to be challenged
                                                //
                                                *pfChallenge = TRUE;
                                             }
                                             else
                                             {
                DBGPRINT0(DET, "ClashAtRegGrp: Clash between multihomed entry (to reg) and active unique entry. Addresses same. Simple update will be done\n");
                                                //
                                                // Update the entry in the db
                                                //
                                                *pfUpdate    = TRUE;
                                                *pfUpdVersNo = TRUE;

                                             }
                                        }
                                }
#ifdef WINSDBG
                                else
                                {
                                        DBGPRINT1(FLOW, "ClashAtRegGrp: CLASH OF A MULTIHOMED ENTRY WITH AN ACTIVE %s GROUP ENTRY. NO UPDATE WILL BE DONE\n", NMSDB_ENTRY_NORM_GRP_M(pEntryInCnf->EntTyp) ? "NORMAL" : "SPECIAL");

                                }
#endif

                                break;
                }
          }

        }

        DBGLEAVE("ClashAtRegGrp\n");
        return(RetStat);

} //ClashAtRegGrp()


BOOL
MemInGrp(
        IN PCOMM_ADD_T              pAddToReg,
        IN PNMSDB_STAT_INFO_T       pEntryInCnf,
        IN PBOOL                    pfOwned,
        IN BOOL                     fRemoveReplica
        )

/*++

Routine Description:

        This function is called to check if the address of the entry to register
        is in the list of addresses in the conflicting entry.


Arguments:
        pAddToReg   - Address to Register
        pEntryInCnf - Entry in conflict

        fRemoveReplica - This will be set if the caller wants this function
                          to remove a replica member.
                          A replica (the last one in the list) will be replaced
                          only if there is no match and the number of members
                          in the list is hitting the limit.

Externals Used:
        None

Return Value:

        TRUE if the entry to register is a member of the group
        FALSE otherwise

Error Handling:

Called by:
        ClashAtRegGrp
Side Effects:

Comments:
        The two entries in conflict are special group entries.
        fRemoveReplica  will be set to TRUE only by ClashAtRegGrp when
        registering a  special group (because we prefer a local member to a
        replica)

        NOTE: if the member that matches is a permanent member as indicated
              by the timestamp (== MAXULONG), then it is not replaced.
--*/

{
        DWORD                         no;
        BOOL                          fFound = FALSE;
        DWORD                         RetVal;
        DWORD                         i;
        PNMSDB_GRP_MEM_ENTRY_T  pMem = pEntryInCnf->NodeAdds.Mem;
        BOOL                        fRplFound = FALSE;
        DWORD                   RplId = 0;                // id. of replica to
                                                        // remove.
        DWORD                   NoOfMem;

        DBGENTER("MemInGrp\n");

        *pfOwned = FALSE;

#ifdef WINSDBG
        if (pEntryInCnf->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
           DBGPRINT2(EXC, "MemInGrp: No of Mems in Cnf entry = (%d); Add of entry to reg. is (%x)\n", pEntryInCnf->NodeAdds.NoOfMems, pAddToReg->Add.IPAdd);
        }
#endif

        ASSERT(pEntryInCnf->NodeAdds.NoOfMems <= NMSDB_MAX_MEMS_IN_GRP);
        NoOfMem =  min(pEntryInCnf->NodeAdds.NoOfMems, NMSDB_MAX_MEMS_IN_GRP);

        //
        // Compare each member in the conflicting record against the member to
        // be  registered
        //
        for (no = 0; no < NoOfMem ; no++, pMem++ )
        {
                //
                // if the caller wants us to remove a replica member
                // for the case where there is no match
                //
                if (fRemoveReplica)
                {
                        //
                        // If the member in the conflicting record is a
                        // replica, save its index if it is more than
                        // the one we saved earlier.
                        //
                        if (pMem->OwnerId != NMSDB_LOCAL_OWNER_ID)
                        {
                                fRplFound = TRUE;
                                if (no > RplId)
                                {
                                        RplId          = no;
                                }
                        }
                }


                RetVal = (ULONG) WINSMSC_COMPARE_MEMORY_M(
                                pAddToReg,
                                &pMem->Add,
                                sizeof(COMM_ADD_T)
                           );

                if (RetVal == sizeof(COMM_ADD_T))
                {
                        //
                        // if this is a permanent member, let us set
                        // fOwned to TRUE since we do not want to
                        // replace this member. The caller will check
                        // fOwned and if TRUE will not replace it.
                        // Currently, MAXULONG can be there only for
                        // static SG members
                        if (pMem->TimeStamp == MAXLONG)
                        {
                          ASSERT(NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp));
                          *pfOwned = TRUE;
                          break;
                        }
                        fFound = TRUE;

PERF("The following is a convoluted and potentially high overhead way")
PERF("to handle a refresh for a member (i.e. when member is owned by us")
PERF("We take it out here and then add it later (with current time stamp)")
PERF("in NmsNmhNamRegGrp.  Improve this by using the code that is between.")
PERF("#if 0 and #endif. Also, when updating db, just overwrite the affected")
PERF("entry instead of writing the whole record")
                         //
                         //if the member is owned by us, *pfOwned is set to
                         //TRUE
                         //
                         if  ( pMem->OwnerId == NMSDB_LOCAL_OWNER_ID )
                         {
                                *pfOwned = TRUE;
                         }

                        //
                        // Get rid of the member whose address is the
                        // same.  The client will insert an entry for the
                        // member with the local WINS as the owner
                        // and the current timestamp.
                        //
                        for(
                             i = no;
                             i < (NoOfMem - 1);
                             i++, pMem++
                            )
                          {
                                   *pMem = *(pMem + 1);
                          }
                        --NoOfMem;
                        break;
               }
        }
        pEntryInCnf->NodeAdds.NoOfMems = NoOfMem;

        //
        // if we were asked to remove replica on no match, check if a
        // replica member was found.  Note: We remove a replica to make
        // space for a member that we got. We don't need to remove a replica
        // if there is space left in the group
        //
        if (
                fRemoveReplica &&
                !fFound &&
                fRplFound &&
                (pEntryInCnf->NodeAdds.NoOfMems == NMSDB_MAX_MEMS_IN_GRP)
            )
        {
                //
                // Remove the replica
                //
                for (
                        i = RplId, pMem = &pEntryInCnf->NodeAdds.Mem[RplId];
                        i < (pEntryInCnf->NodeAdds.NoOfMems - 1);
                        i++, pMem++
                    )
                {

                          *pMem = *(pMem + 1);

                }
                --(pEntryInCnf->NodeAdds.NoOfMems);
//                fFound = TRUE;
        }

        DBGLEAVE("MemInGrp\n");
        return(fFound);
} //MemInGrp()


VOID
RemoveAllMemOfOwner(
      PNMSDB_STAT_INFO_T pEntry,
      DWORD OwnerId
 )

/*++

Routine Description:
    Removes all members that are owned by OwnerId

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
   DWORD NoOfMems = pEntry->NodeAdds.NoOfMems;
   PNMSDB_GRP_MEM_ENTRY_T pMem = &pEntry->NodeAdds.Mem[NoOfMems-1];

   DBGPRINT1(FLOW, "ENTER: RemoveAllMemOfOwner: Owner Id= (%d)\n", OwnerId);
   //
   // loop over all members of the entry starting from the last one
   //
   for (; NoOfMems > 0; NoOfMems--, pMem--)
   {
       //
       // If owner id matches, we need to remove it and decrement the
       // count
       //
       if (pMem->OwnerId == OwnerId)
       {
           DWORD No;
           DBGPRINT1(DET, "RemoveAllMemOfOwner: Removing Member with address = (%x)\n", pMem->Add.Add.IPAdd);
           //
           // shift all following members one position to the left
           //
           memcpy( pMem, (pMem + 1),
                   sizeof(NMSDB_GRP_MEM_ENTRY_T)*(pEntry->NodeAdds.NoOfMems - NoOfMems));
           pEntry->NodeAdds.NoOfMems--;
       }
   }
   DBGPRINT1(FLOW, "LEAVE: RemoveAllMemOfOwner. No Of Mems in Conflicting record = (%d)\n", pEntry->NodeAdds.NoOfMems);
   return;
}


VOID
ClashAtReplUniqueR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfInformWins
 )

/*++

Routine Description:

        This function is called when there is a clash at replication time
        between  a replica that is unique and an entry in the database

Arguments:

        pReplToReg  -- Replica that couldn't be registered due to conflict
        pEntryInCnf -- Entry in conflict
        pfUpdate    -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE
        pfChallenge -- TRUE means that conflicting entry should be challenged
        pfRelease   -- TRUE means that conflicting entry's node should be
                       asked to release the name.

                       If both pfChallenge and pfRelease are TRUE, then it
                       means that the conflicting entry should first be
                       challenged.  If the challenge fails, the node should
                       be asked to release the name. If the challenge succeeds,
                       no release need be sent
        pfInformWins -- Inform remote WINS from which we received the replica
                        about the outcome
        pfAddChgd    -- Indicates that the address got changed

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        NmsNmhReplRegInd

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        DWORD                  CompAddRes;  /*Result of comparing addresses*/
        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;

        DBGENTER("ClashAtReplUniqueR\n");
        *pfUpdate     = FALSE;
        *pfUpdVersNo  = FALSE;
        *pfChallenge  = FALSE;
        *pfRelease    = FALSE;
        *pfInformWins = FALSE;

        if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId) {
            *pfUpdate = TRUE;
            DBGPRINT0(DET,
                    "ClashAtUniqueR: overwrite replica by same owner replica \n");
            return;
        }

        //
        // If the conflicting record was statically initialized we
        // return right away, unless the replica is also a STATIC or
        // belongs to the same owner.
        //
        if (pEntryInCnf->fStatic)
        {
                DBGPRINT0(DET, "ClashAtReplUniqueR: Clash with a STATIC record\n");
                //
                // If we have been asked to treat static records as
                // P-Static, then if the conflicting entry is not a group
                // we continue on, else we return.
                //
                if (!(fPStatic && !NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp)))
                {
//                          WINSEVT_LOG_INFO_D_M(WINS_FAILURE, WINS_EVT_REPLICA_CLASH_W_STATIC);
                    if (WinsCnf.LogDetailedEvts > 0)
                    {
                       WinsEvtLogDetEvt(FALSE, WINS_EVT_REPLICA_CLASH_W_STATIC,
                        NULL, __LINE__, "s", pEntryToReg->pName);
                    }
                      return;

                }
        }
        else
        {
                //
                // a STATIC replica always replaces a dynamic entry.
                //
                if (pEntryToReg->fStatic)
                {
                        *pfUpdate = TRUE;
                        return;
                }
        }

        if (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
        {
           switch(StateOfEntryInCnf_e)
           {

                case(NMSDB_E_TOMBSTONE):   //fall through
                case(NMSDB_E_RELEASED):

                        *pfUpdate    = TRUE;
                        break;

                case(NMSDB_E_ACTIVE):

                        if (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                        {

                                 CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                        );

                                switch(CompAddRes)
                                {
                                      case(COMM_DIFF_ADD):

                                        //
                                        // If entry in conflict is active
                                        // and owned by us,
                                        // tell the node of the entry to
                                        // release the name.  In other
                                        // words we always replace it
                                        // with the replica.
                                        //

                                        if (pEntryInCnf->OwnerId
                                                == NMSDB_LOCAL_OWNER_ID)
                                        {
                                                *pfChallenge     = TRUE;
                                                *pfRelease       = TRUE;
                                        //      *pfInformWins    = TRUE;
                                        }
                                        else  //D is a replica
                                        {
                                                //
                                                // replace with replica
                                                //
                                            //  *pfChallenge     = TRUE;
                                                *pfUpdate        = TRUE;
                                        }

                                        break;

                                    //
                                    // D and R  (database entry and replica
                                    // have same address)
                                    //
                                    default:
                                           *pfUpdate     = TRUE;
                                           break;
                                }
                         }
                         else   //entry to register is a Tombstone (has to be)
                         {
                                ASSERT(StateOfEntryToReg_e == NMSDB_E_TOMBSTONE);
                                //
                                // If we own the entry in the db, we need to
                                // increment its version number
                                //
                                if (pEntryInCnf->OwnerId
                                                == NMSDB_LOCAL_OWNER_ID)
                                {
                                        //
                                        // We update the version number of the
                                        // entry in the database
                                        //
                                        *pfUpdVersNo = TRUE;
                                }
                                else  //the entry in conflict is a replica
                                {
                                   //
                                   // Both replicas have the same owner.
                                   //
                                   if (
                                        pEntryInCnf->OwnerId ==
                                                  pEntryToReg->OwnerId
                                      )
                                   {
                                        *pfUpdate = TRUE;
                                   }
#ifdef WINSDBG
                                   else
                                   {
                                        DBGPRINT0(FLOW, "ClashAtReplUniqueR: Clash between two replicas with different owner ids.  Replica in db is active while one received is a tombstone. Db will not be updated\n");
                                   }
#endif

                                }

                         }
                         break;


                default:
                        //
                        // Some weirdness.
                        // Set this the pfUpdate to TRUE so that we overwrite this record.
                        *pfUpdate = TRUE;
                        DBGPRINT1(ERR,
                         "ClashAtReplUniqueR: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_BAD_RECORD);
                        break;

              }
        }
        else  // the entry in conflict is a group (normal or special) entry or
              // a multihomed entry
        {
                //
                // do nothing if it is a normal group or if it is an active
                // special group.  If it is a special group and it is not
                // active, it can be replaced
                //
                if  (
                        (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                                &&
                        (StateOfEntryInCnf_e != NMSDB_E_ACTIVE)
                    )
                {
CHECK("Check with the latest spec. to make sure the following is correct")
                        //
                        // Replace with replica
                        //
                        *pfUpdate = TRUE;
                }
                else
                {
                        if (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                        {
                                if (StateOfEntryInCnf_e == NMSDB_E_ACTIVE)
                                {
                                        if (StateOfEntryToReg_e ==
                                                        NMSDB_E_ACTIVE)
                                        {
                                                if (pEntryInCnf->OwnerId ==
                                                        pEntryToReg->OwnerId
                                                   )
                                                {
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: ACTIVE unique replica with an ACTIVE MULTIHOMED replica (same owner). Update will be done\n");
                                                        *pfUpdate = TRUE;
                                                }
                                                else
                                                {
//
//  Put within #if 0 and #endif if we want to challenge an entry regardless of
// who owns it (can result in challenges across WAN lines)
//
//#if 0
                                                     if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
//#endif
                                                  {

                                                    BOOL  fOwned;


                                                    //
                                                    // If found, MemInGrp
                                                    // will remove the
                                                    // address from
                                                    // the Mem array of the
                                                    // conflicting record
                                                    //
                                                    (VOID) MemInGrp(
                                                          pEntryToReg->
                                                            pNodeAdd,
                                                           pEntryInCnf,
                                                           &fOwned,
                                                           FALSE);

                                                    if (pEntryInCnf->NodeAdds.NoOfMems != 0)
                                                    {
                                                      RemoveAllMemOfOwner(
                                                        pEntryInCnf,
                                                        pEntryToReg->OwnerId);
                                                    }
                                                    //
                                                    // Active unique replica
                                                    // has the same address as
                                                    // the owned active
                                                    // multihomed record.Replace
                                                    //
                                                    if (pEntryInCnf->NodeAdds.NoOfMems == 0)
                                                    {

                                                        *pfUpdate = TRUE;
                                                    }
                                                    else
                                                    {
                                                      //
                                                      // An active unique
                                                      // replica has clashed
                                                      // with an active
                                                      // owned multihomed entry.
                                                      // The multihomed entry
                                                      // needs to be challenged
                                                      //
                                                      *pfChallenge = TRUE;

//
// Comment out #if 0 if we want to challenge regardless of ownership
//
#if 0
                                                     if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                                                     {
#endif
                                                      *pfRelease   = TRUE;
#if 0
                                                     }
#endif
                                                     // *pfInformWins = TRUE;
                                                    }
                                                  }
//
//  Put within #if 0 and #endif if we want to challenge an entry regardless of
// who owns it (can result in challenges across WAN lines). See above
//
//#if 0
                                                  else
                                                  {
CHECK("Maybe, we should not do any update in this case")
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: ACTIVE unique replica with an ACTIVE MULTIHOMED replica (diff owner). Simple Update will be done\n");

                                                        *pfUpdate = TRUE;
                                                  }
//#endif
                                                }
                                        }
                                        else // entry to register is a TOMBSTONE
                                        {
                                                if (pEntryInCnf->OwnerId ==
                                                        pEntryToReg->OwnerId
                                                   )
                                                {
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: TOMBSTONE unique replica with an ACTIVE MULTIHOMED replica (same owner). Update will be done\n");
                                                        *pfUpdate = TRUE;
                                                }
                                                else
                                                {
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: TOMBSTONE unique replica with an ACTIVE MULTIHOMED entry (different owners). No Update will be done\n");
                                                }
                                        }
                                }
                                else // state of multihomed entry in Db is
                                     // not active. We need to replace it
                                     // with the replica
                                {
                                        *pfUpdate = TRUE;
                                }

                        }
                        else
                        {

                                DBGPRINT0(FLOW,
                                         "ClashAtReplUniqueR: Clash is either with a normal group or an active special group. No update will be done to the db\n");
                        }
                }


        }
        DBGLEAVE("ClashAtReplUniqueR\n");
        return;
} //ClashAtReplUniqueR()

VOID
ClashAtReplGrpR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfUpdTimeStamp,
        OUT PBOOL                pfInformWins
 )

/*++

Routine Description:

        This function is called when there is a clash at replication time
        betweeen a replica that is a group and an entry in the database.

Arguments:

        pEntryToReg  -- Entry that couldn't be registered due to conflict
        pEntryInCnf  -- Entry in conflict
        pfAddMem     -- TRUE means that the members in the replica should be
                        added to  the group entry in the database
        pfUpdate     -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo  -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        BOOL                       fMemInGrp            = FALSE;
        DWORD                       i;
        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;

        DBGENTER("ClashAtReplGrpR\n");
        *pfAddMem          = FALSE;
        *pfUpdate          = FALSE;
        *pfUpdVersNo       = FALSE;
        *pfRelease         = FALSE;
        *pfChallenge       = FALSE;
        *pfUpdTimeStamp    = TRUE;
        *pfInformWins      = FALSE;

        if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId) {
            *pfUpdate = TRUE;
            DBGPRINT0(DET,
                    "ClashAtReplGrpR: overwrite replica by same owner replica \n");
            return;
        }

        //
        // If the conflicting record was statically initialized we
        // return right away unless the replica and the conflicting
        // entry belong to the same owner and the replica is also a
        // STATIC record.
        //
        if (pEntryInCnf->fStatic)
        {
                DBGPRINT0(DET,
                        "ClashAtReplGrpR: Conflict with a STATIC entry\n");



              //
              // if both records are user defined special groups, do
              // same conflict handling as you would when a
              // the conflicting record is a dynamic record
              //
              if (!((NMSDB_ENTRY_USER_SPEC_GRP_M(pEntryToReg->pName, pEntryToReg->EntTyp)) &&
                    (NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp))))
              {
                 if ((NMSDB_ENTRY_NORM_GRP_M(pEntryToReg->EntTyp)) &&
                    (NMSDB_ENTRY_USER_SPEC_GRP_M(pEntryToReg->pName, pEntryInCnf->EntTyp)))
                 {

NOTE("Currently, NORM GRP can have the wrong owner id. since this is not")
NOTE("replicated.  The owner id. of the WINS being pulled from is used")
                          *pfAddMem       = UnionGrps(
                                                     pEntryToReg,
                                                     pEntryInCnf
                                                    );
                           if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                           {
                                    *pfUpdVersNo    = *pfAddMem;
                           }
                           pEntryToReg->EntTyp = NMSDB_SPEC_GRP_ENTRY;
                           return;

                 }
                 else
                 {

                   //
                   // If static records need to be treated as P-static and
                   // the conflicting entry as well as the entry to register
                   // are multihomed, we continue on, else we return
                   //
                   if (!(fPStatic && (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp)) && (NMSDB_ENTRY_MULTIHOMED_M(pEntryToReg->EntTyp))))
                   {
                    if (WinsCnf.LogDetailedEvts > 0)
                    {
                       WinsEvtLogDetEvt(FALSE, WINS_EVT_REPLICA_CLASH_W_STATIC,
                        NULL, __LINE__, "s", pEntryToReg->pName);
//                         WINSEVT_LOG_INFO_D_M(WINS_FAILURE, WINS_EVT_REPLICA_CLASH_W_STATIC);
                    }
                     return;
                   }
                }
              }
        }

        if (pEntryToReg->EntTyp == NMSDB_SPEC_GRP_ENTRY)
        {
             switch(StateOfEntryInCnf_e)
             {
                case(NMSDB_E_TOMBSTONE):
                        *pfUpdate = TRUE;
                        break;
                case(NMSDB_E_RELEASED):
                        if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                        {
                                *pfUpdate = TRUE;
                        }
                        break;

                case(NMSDB_E_ACTIVE):

                       if (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                       {
                          if (StateOfEntryToReg_e == NMSDB_E_TOMBSTONE)
                          {
                            if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                            {
                                *pfUpdTimeStamp = FALSE;
                                *pfUpdVersNo    = TRUE;
                                // we should propagate this change right away
                                // because others think this is a tombstone
                                // record.

                                RPL_PUSH_NTF_M(RPL_PUSH_PROP, NULL, NULL, NULL);

                            }
                            else
                            {
                                //
                                // SG Tombstone replica clashed with a SG
                                // Active replica.  We
                                // replace it (in other words, make it a
                                // tombstone).  It makes sense since if this
                                // SG was really active, it would be owned
                                // by another owner (any time a member is
                                // registered, the ownership becomes that
                                // of the registering WINS).
                                // and so if this name is really active,
                                // the owner wins will push it back
                                // as active.
                                //
                                *pfUpdate = TRUE;

                                // In order to propagate this
                                // conflict to the owner quickly, trigger
                                // push with propagation unless owner himself
                                // sent this tombstone.
                                if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId) {
                                    RPL_PUSH_NTF_M(RPL_PUSH_PROP, NULL, NULL, NULL);
                                }

                                DBGPRINT0(FLOW, "ClashAtReplGrpR: TOMBSTONE spec. grp. replica clashed with ACTIVE spec. grp replica. No update will be done\n");
                            }
                          }
                          else //EntryToReg is ACTIVE
                          {
                                   *pfAddMem       = UnionGrps(
                                                         pEntryToReg,
                                                         pEntryInCnf
                                                        );
                                   if (pEntryInCnf->OwnerId ==
                                                NMSDB_LOCAL_OWNER_ID)
                                   {
                                        *pfUpdVersNo    = *pfAddMem;
                                   }
                          }
                       }
                       else  //Entry in conflict is an active normal group
                             //or unique/multihomed entry
                       {
                         if  (
                                (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                                ||
                                (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                             )
                         {
                                //
                                // The following means that we are overwriting
                                // an active unique entry with an active or
                                // tombstone special group replica.
                                //
                                if (
                                    (pEntryInCnf->OwnerId ==
                                                NMSDB_LOCAL_OWNER_ID)
                                                &&
                                    (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                                  )
                                {
        DBGPRINT0(DET, "ClashAtReplGrpR: Active spec. grp replica clashed with owned active unique/multihomed entry. Owned entry will be released\n");
                                    *pfRelease = TRUE;
                                }
                                else
                                {
                                   if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                   {
        DBGPRINT0(DET, "ClashAtReplGrpR: Spec. grp replica clashed with same owner's active/multihomed entry. Simple update will be done\n");
                                        *pfUpdate = TRUE;
                                   }
                                }
                         }
#ifdef WINSDBG
                        else
                        {
                                DBGPRINT0(FLOW, "ClashAtReplGrpR: Clash is with an active normal group. No change needs to be made to the db\n");
                        }
#endif
                       }
                      break;
                default:
                        //
                        //  Something really wrong here. Maybe the
                        //  database got corrupted.
                        // Set this the pfUpdate to TRUE so that we overwrite this record.
                        *pfUpdate = TRUE;
                        DBGPRINT1(ERR,
                         "ClashAtReplGrpR: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_BAD_RECORD);
                        break;
          } //end of switch
        }
        else   // Entry to register is a normal group entry or a multihomed
               // entry
        {
           if (pEntryToReg->EntTyp == NMSDB_MULTIHOMED_ENTRY)
           {
             switch(StateOfEntryInCnf_e)
             {
                   case(NMSDB_E_TOMBSTONE):
                          *pfUpdate = TRUE;
                          break;
                   case(NMSDB_E_RELEASED):
                          if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                          {
                                *pfUpdate = TRUE;
                          }
                          break;
                   case(NMSDB_E_ACTIVE):
                        if (
                              (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                                ||
                              (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                           )
                        {
                                if (StateOfEntryToReg_e == NMSDB_E_TOMBSTONE)
                                {
                                        //
                                        // if Db entry is a replica
                                        //
                                        if (
                                                pEntryInCnf->OwnerId !=
                                                   NMSDB_LOCAL_OWNER_ID
                                           )
                                        {
                                          //
                                          // if replica to reg and replica in
                                          // in db have the same owner,
                                          // we replace the active db entry
                                          // with the tombstone replica
                                          //
                                          if (pEntryInCnf->OwnerId
                                                == pEntryToReg->OwnerId)
                                          {
                                                *pfUpdate = TRUE;
                                          }
#ifdef WINSDBG
                                          else
                                          {
                                                DBGPRINT1(DET, "ClashAtReplGrpR:CLASH BETWEEN TOMBSTONE MULTIHOMED REPLICA WITH AN ACTIVE %s REPLICA IN DB. REPLICAS HAVE DIFFERENT OWNERS.  DB REPLICA WILL NOT BE UPDATED\n",
        NMSDB_ENTRY_UNIQUE_M(pEntryInCnf->EntTyp) ? "UNIQUE" : "MULTIHOMED");
                                          }
#endif
                                         }
                                        else //db entry is active and is owned
                                             //by us.
                                        {
                                            //
                                            // Remove all members owned by the
                                            // WINS server that owns this
                                            // Tombstone replica from the
                                            // entry in  conflict.
                                           if (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp))
                                           {
                                            BOOL  fFound = FALSE;
                                            BOOL  fAtLeastOneRm = FALSE;
                                            BOOL  fOwned;
                                            PNMSDB_GRP_MEM_ENTRY_T  pMem =
                                             pEntryToReg->NodeAdds.Mem;
                                            for ( i = 0;
                                                      i < pEntryToReg->NodeAdds.NoOfMems;                                                       i++, pMem++
                                                    )
                                            {
                                                   if (pMem->OwnerId == pEntryToReg->OwnerId)
                                                   {
PERF("Actually, we should only remove those members that are owned by the")
PERF("remote WINS server. The current way (members with same address removed")
PERF("is less efficient since it can result in challenges when the members")
PERF("that are removed refresh with the local WINS server")

                                                      //
                                                      // If found, MemInGrp will
                                                      // remove the address from
                                                      // the Mem array of the
                                                      // conflicting record
                                                      //
                                                      fFound = MemInGrp(
                                                          &pMem->Add,
                                                           pEntryInCnf,
                                                           &fOwned,
                                                           FALSE);
                                                       }
                                                       if (!fAtLeastOneRm && fFound)
                                                       {
                                                           fAtLeastOneRm = TRUE;
                                                       }

                                            }

                                            //
                                            // If atleast one member was
                                            // found, put in the new member
                                            // list in the db.
                                            //
                                            if (fAtLeastOneRm)
                                            {
                                                PNMSDB_GRP_MEM_ENTRY_T pCnfMem, pRegMem;
                                                pCnfMem = pEntryInCnf->NodeAdds.Mem;
                                                pRegMem = pEntryToReg->NodeAdds.Mem;
                                                for (i=0;
                                                      i < pEntryInCnf->NodeAdds.NoOfMems;                                                i++, pRegMem++,pCnfMem++
                                                    )
                                               {
                                                 *pRegMem = *pCnfMem;

                                               }
                                               pEntryToReg->NodeAdds.NoOfMems =
                                                pEntryInCnf->NodeAdds.NoOfMems;

                                               //
                                               // if no. of mems left is > 0, it
                                               // means that the record is
                                               // still active.
                                               //
                                               if (pEntryToReg->NodeAdds.NoOfMems != 0)
                                               {
                                                pEntryToReg->EntryState_e = NMSDB_E_ACTIVE;
                                               }
                                               //
                                               // Setting *pfAddMem to TRUE
                                               // ensures that the new list
                                               // gets in
                                               //

                                               *pfAddMem = TRUE;

                                            }
                                           }

                                            //
                                            //
                                            // We update the version number
                                            // of the entry in the database
                                            // to cause propagation
                                            //

                                            *pfUpdVersNo = TRUE;
                                        }
                                }
                                else  //State Of Entry to Reg has to be ACTIVE
                                {
                                        //
                                        // Clash of an ACTIVE multihomed replica
                                        // with an active unique/multihomed
                                        // entry. We need to challenge the
                                        // conflicting
                                        // entry
                                        //
                                        if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                        {
                                                DBGPRINT0(DET, "ClashAtReplGrpR: ACTIVE unique/multihomed replica with an ACTIVE MULTIHOMED replica (same owner). Update will be done\n");
                                                *pfUpdate = TRUE;
                                        }
                                        else
                                        {
//
// Uncomment if challenge is desired instead of a simple update
//
//#if 0
                                                    if (pEntryInCnf->OwnerId ==
                                                        NMSDB_LOCAL_OWNER_ID)
//#endif
                                                    {
                                                      DWORD i;
                                                      BOOL  fOwned;
                                                  PNMSDB_GRP_MEM_ENTRY_T pRegMem= pEntryToReg->NodeAdds.Mem;

                                                      for ( i = 0;
                                                        i <
                                                         pEntryToReg->NodeAdds.NoOfMems;
                                                         i++, pRegMem++ )
                                                      {

                                                           //
                                                           //If found, MemInGrp
                                                           // will remove the
                                                           // address from
                                                           // the Mem array of
                                                           // the conflicting
                                                           // record
                                                           //
                                                           (VOID) MemInGrp(
                                                            &pRegMem->Add,
                                                            pEntryInCnf, &fOwned,
                                                          FALSE);

                                                      }
                                                     if (pEntryInCnf->NodeAdds.NoOfMems != 0)
                                                     {
                                                      RemoveAllMemOfOwner(
                                                          pEntryInCnf,
                                                          pEntryToReg->OwnerId);

                                                      }
                                                      if (pEntryInCnf->NodeAdds.NoOfMems == 0)
                                                      {
 DBGPRINT0(DET, "ClashAtReplGrpR: Clash between active unique/multihomed with an owned unique/multihomed entry with subset/same address(es).  Simple update will be done\n");
                                                        *pfUpdate = TRUE;
                                                      }
                                                      else
                                                      {
                                                          //
                                                          //An active mh. rpl
                                                          //clashed with an
                                                          //active owned unique
                                                          //or multih entry.
                                                          //The multih entry
                                                          //needs to be
                                                          //challenged
                                                          //
 DBGPRINT0(DET, "ClashAtReplGrpR: Active multihomed replica with an owned unique/multihomed entry with one or more different address(es).  Challenge of owned entry will be done\n");
                                                       *pfChallenge = TRUE;
//
// Uncomment if challenge is desired instead of a simple update
//
#if 0
                                                    if (pEntryInCnf->OwnerId ==
                                                        NMSDB_LOCAL_OWNER_ID)
                                                    {
#endif
                                                       *pfRelease = TRUE;
                                                       //*pfInformWins = TRUE;
#if 0
                                                    }
#endif
                                                      }
                                                     }
//
// comment if challenge is desired instead of a simple update
//
//#if 0
                                                     else
                                                     {
                    DBGPRINT0(DET, "ClashAtReplGrpR: ACTIVE multihomed replica with an ACTIVE MULTIHOMED/UNIQUE replica (diff owner). Update will be done\n");

                                                        *pfUpdate = TRUE;
                                                     }
//#endif
                                              } // end of else (Entry to reg has
                                             // different owner than
                                             // conflicting entry

                                 } // end of else (EntryToReg is ACTIVE)
                   } //end of if entry in conflict is a unique/multihomed
#ifdef WINSDBG
                   else
                   {
                        DBGPRINT0(DET, "ClashAtReplGrpR: Clash of an active multihomed entry with an active group entry. No Update will be done\n");

                   }
#endif
                   break;
             }
           }
           else  //entry to register is a normal group entry
           {
             switch(StateOfEntryInCnf_e)
             {

                    case(NMSDB_E_RELEASED):

                              // fall through

                    case(NMSDB_E_TOMBSTONE):
                           *pfUpdate    = TRUE;
                           break;



                    case(NMSDB_E_ACTIVE):
                           if (
                                    (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                                    ||
                                    (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                              )
                           {
                                  //
                                  // replace unique entry with this normal
                                  // group only if the group is active
                                  //
                                  if (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                                  {

  DBGPRINT0(DET, "ClashAtReplGrpR: Clash of ACTIVE normal group entry with an owned unique/multihomed entry in db. It will be released\n");
                                        if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                                        {
                                                *pfRelease = TRUE;
                                        }
                                        else
                                        {
  DBGPRINT0(DET, "ClashAtReplGrpR: Clash of ACTIVE normal group entry with a replica unique/multihomed entry in db. Simple update will be done\n");
                                           *pfUpdate = TRUE;

                                        }
                                }
                        }
                        else // entry in conflict is a normal or special group
                        {

                                if (pEntryInCnf->EntTyp == NMSDB_NORM_GRP_ENTRY)
                                {
                                  //
                                  // We own it but so does another WINS.
                                  // We store the replica just in
                                  // case, all the clients have started
                                  // registering  with other WINS servers.
                                  //
                                  //
                                  // Aside: It is possible that members of
                                  // the normal  group are going to us and to
                                  // another WINS.  This is the worst case as
                                  // far as replication traffic is concerned.
                                  //
                                  //
                                  //If the owned entry is ACTIVE and the
                                  //pulled entry an out of date TOMBSTONE
                                  //(will only happen if WINS server we are
                                  //pulling from was down for a while), we
                                  //will not replace the record
                                  //
                                  if (pEntryInCnf->OwnerId ==
                                                NMSDB_LOCAL_OWNER_ID)
                                  {
                                        if (StateOfEntryToReg_e !=
                                                        NMSDB_E_TOMBSTONE)
                                        {
                                                *pfUpdate = TRUE;
                                        }
                                  }
#if 0
                                        if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                                        {
                                           //
                                           // update the version number to
                                           // cause propagation
                                           //
                                           *pfUpdVersNo = TRUE;
                                        }
#endif
                                             else
                                             {
                                                    //
                                                    // Entry owned is a replica.
                                                    // We need to update it with
                                                    // the new replica if the
                                                    // owner id is the same.
                                                    //
                                                    if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId)
                                                    {
                                                        *pfUpdate = TRUE;
                                                    }
                                                    else
                                                    {
                                                        DBGPRINT0(DET, "ClastAtReplGrpR: Clash between two normal group replicas owned by different owners. No update is needed\n");
                                                    }

                                            }
                                }
#ifdef WINSDBG
                                //
                                // Actually we should never have a normal group
                                // clashing with a special group since only
                                // a name ending with 1c is a special group.
                                //
                                else // entry in conflict is a special group
                                {
                                   //
                                   // Since it is an active special
                                   // group entry there is no need to update it
                                   //
                                   if (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                                   {
                                        DBGPRINT0(DET, "ClashAtReplGrpR: Clash between an ACTIVE normal group replica and an active special group entry in the db. No Update will be done\n");
                                   }
                                   else
                                   {
                                      DBGPRINT0(DET, "ClashAtReplGrpR: Clash between a TOMBSTONE normal and an active SPEC GRP entry. Db won't be updated\n");
                                   }
                                }
#endif
                        }
                        break;

                default:
                        //
                        //  Something really wrong here. Maybe the
                        //  database got corrupted.
                        //
                        DBGPRINT1(ERR,
                         "ClashAtReplGrpR: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                        break;
             }
          }

        }
        DBGLEAVE("ClashAtReplGrpR\n");
        return;

} //ClashAtReplGrpR()





STATUS
NmsNmhReplRegInd(
        IN LPBYTE          pName,
        IN DWORD           NameLen,
        IN PCOMM_ADD_T     pNodeAdd,
        IN DWORD           Flag,
        IN DWORD            OwnerId,
        IN VERS_NO_T       VersNo,
        IN PCOMM_ADD_T     pAddOfRemWins
        )

/*++

Routine Description:
        This function registers a replica in the directory database.

        A record in the database comprises of the following fields
                name
                IP address
                time stamp
                owner id.
                flags byte that contain the following information
                                group/unique status
                                node type (P or M)

                version number



Arguments:
        pName           - Name to be registered
        NameLen         - Length of Name
        Flag            - Flag word
        pNodeAdd        - NBT node's address
        OwnerId         - Owner if the record (WINS that registered it)
        VersNo                - Version Number

Externals Used:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

        PullEntries in rplpull.c

Side Effects:

Comments:
        None
--*/

{


        NMSDB_ROW_INFO_T       RowInfo;    // contains row info
        NMSDB_STAT_INFO_T      StatusInfo; /* error status and associated
                                            * info returned by the NmsDb func
                                           */
        BOOL                   fUpdate;    //indicates whether conflicting entry
                                           //needs to be overwritten
        BOOL                   fUpdVersNo; //indicates whether version number
                                           //needs to be incremented
        BOOL                   fChallenge; //indicates whether a challenge needs
                                           //to be done
        BOOL                   fRelease;   //indicates whether a node should
                                           // be asked to release the name
        BOOL                   fInformWins; //indicates whether the remote WINS
                                            //has to be apprised of the clash
                                            //result. Can be TRUE only if both
                                            //fChallenge and fRelease are TRUE
        time_t                   ltime;     //stores time since Jan 1, 1970
        STATUS                   RetStat = WINS_SUCCESS;
        NMSCHL_CMD_TYP_E   CmdTyp_e;        //type of command specified to
                                            //NmsChl
        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhReplRegInd\n");

        fUpdate =   FALSE;

        /*
        * initialize the row info. data structure with the data to insert into
        * the row.  The data passed is

        * Name, NameLen, address, group/unique status,
        * timestamp, version number
        */
        RowInfo.pName     =  pName;
        RowInfo.NameLen   =  NameLen;
        RowInfo.pNodeAdd  =  pNodeAdd;
        RowInfo.NodeTyp   =  (BYTE)((Flag & NMSDB_BIT_NODE_TYP)
                                        >> NMSDB_SHIFT_NODE_TYP);
                                                  //Node type (B, P or M node)
        RowInfo.EntTyp    =  NMSDB_UNIQUE_ENTRY;  // this is a unique
                                                  //registration

        (void)time(&ltime); //time does not return any error code
        RowInfo.EntryState_e = NMSDB_ENTRY_STATE_M(Flag);
        RowInfo.OwnerId      = OwnerId;
        RowInfo.VersNo       = VersNo;
        RowInfo.fUpdVersNo   = TRUE;
        RowInfo.fUpdTimeStamp= TRUE;
        RowInfo.fStatic      = NMSDB_IS_ENTRY_STATIC_M(Flag);
        RowInfo.fLocal       = FALSE;
        RowInfo.fAdmin             = FALSE;
//        RowInfo.CommitGrBit   = 0;

        DBGPRINT4(DET, "NmsNmhReplRegInd: Name (%s);16th char (%X);State (%d); Entry is (%s)\n", RowInfo.pName, *(RowInfo.pName+15),RowInfo.EntryState_e, RowInfo.fStatic ? "STATIC" : "DYNAMIC");
       DBGPRINT2(DET,"Vers. No. is (%d %d)\n", VersNo.HighPart, VersNo.LowPart);

        /*
        * Enter Critical Section
        */
PERF("Try to get rid of this or atleast minimise its impact")
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_START_PERF_MONITORING

try
  {
        if ( NMSDB_ENTRY_TOMB_M(Flag) ) {
            RowInfo.TimeStamp    =  ltime + WinsCnf.TombstoneTimeout;
        }
        else if (OwnerId == NMSDB_LOCAL_OWNER_ID)
        {
            RowInfo.TimeStamp    =  ltime + WinsCnf.RefreshInterval;
        }
        else
        {
             RowInfo.TimeStamp    = ltime + WinsCnf.VerifyInterval;
        }

        /*
        *   Insert record in the directory
        */
        RetStat = NmsDbInsertRowInd(
                          &RowInfo,
                          &StatusInfo
                         );


      if (RetStat == WINS_SUCCESS)
      {
        /*
         * If there is a conflict, do the appropriate processing
        */
        if (StatusInfo.StatCode == NMSDB_CONFLICT)
        {

                DBGPRINT0(FLOW, "NmsNmhReplRegInd: Name Conflict\n");
                  ClashAtReplUniqueR(
                        &RowInfo,
                        &StatusInfo,
                        &fUpdate,
                        &fUpdVersNo,
                        &fChallenge,
                        &fRelease,
                        &fInformWins
                          );

                //
                // if we need to challenge a node or release a name
                // hand over the request to the name challenge manager
                //
                if ((fChallenge) || (fRelease))
                {

                    DBGPRINT0(FLOW,
                        "NmsNmh: Handing name registration to challenge manager\n");
                    /*
                     *        Ask the Name Challenge component to take it from
                     *        here
                    */
                    if (fChallenge)
                    {
                        if (fRelease)
                        {
                          if (!fInformWins)
                          {
                             //
                             // Set this since we use it when we do the release.
                             //
                             RowInfo.NodeAdds.NoOfMems        = 1;
                             RowInfo.NodeAdds.Mem[0].OwnerId  = OwnerId;
                             RowInfo.NodeAdds.Mem[0].TimeStamp   = RowInfo.TimeStamp;
                             RowInfo.NodeAdds.Mem[0].Add   = *pNodeAdd;

                             //
                             // Clash with active/multihomed
                             //
                             CmdTyp_e = NMSCHL_E_CHL_N_REL;
                          }
                          else
                          {
                             //
                             // We will never enter this code.
                             //
                             ASSERT(0);
                             CmdTyp_e = NMSCHL_E_CHL_N_REL_N_INF;
                          }
                       }
                       else
                       {
                             CmdTyp_e = NMSCHL_E_CHL;

                       }
                    }
                    else
                    {
                        if (fRelease)
                        {

                                if (!fInformWins)
                                {

                                        CmdTyp_e = NMSCHL_E_REL;
                                }
                                else
                                {
                                        //
                                        // We will never enter this code.
                                        //
                                        ASSERT(0);
                                        CmdTyp_e = NMSCHL_E_REL_N_INF;
                                }
                        }
                    }

                    NmsChlHdlNamReg(
                                CmdTyp_e,
                                WINS_E_RPLPULL,
                                NULL,
                                NULL,
                                0,
                                0,
                                &RowInfo,
                                &StatusInfo,
                                pAddOfRemWins
                                       );


            }
            else  // it is not a request for the name challenge manager
            {

                   //
                   //  If version number needs to be updated, do so
                   if (fUpdVersNo)
                   {
                        RowInfo.VersNo       = NmsNmhMyMaxVersNo;
                        RowInfo.fUpdTimeStamp = FALSE;
                        RetStat = NmsDbUpdateVersNo(
                                        TRUE,
                                        &RowInfo,
                                        &StatusInfo
                                       );
                        DBGPRINT1(FLOW,
                         "NmsNmhReplRegInd: Version Number changed to (%d)\n",
                          NmsNmhMyMaxVersNo);
                   }
                   else
                   {
                      if (fUpdate)
                      {

                           //
                           // The row needs to be updated
                           //
                           RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                       );
                      }
                      else  //no update need be done
                      {
                        StatusInfo.StatCode = NMSDB_SUCCESS;
                        DBGPRINT0(FLOW,
                         "Repl Registration (unique entry) not needed for this Conflict\n");
                      }
                  }

FUTURES("Use WINS status codes. Get rid of NMSDB status codes -- Maybe")
                  if (
                       (RetStat != WINS_SUCCESS) ||
                       (StatusInfo.StatCode != NMSDB_SUCCESS)
                     )
                  {
                        RetStat = WINS_FAILURE;
                        DBGPRINT5(ERR, "NmsNmhReplUniqueR: Could not update Db with replica %s[%x] of Owner Id (%d) and Vers. No (%d %d)\n", RowInfo.pName, *(RowInfo.pName + 15), RowInfo.OwnerId, RowInfo.VersNo.HighPart, RowInfo.VersNo.LowPart);
                  }
                  else //we succeeded in inserting the row
                  {
                        DBGPRINT0(FLOW, "NmsNmhReplRegInd: Updated Db\n");
                        if (fUpdVersNo)
                        {
                          NMSNMH_INC_VERS_COUNTER_M(
                                        NmsNmhMyMaxVersNo,
                                        NmsNmhMyMaxVersNo
                                               );
                          //
                          // Send a Push Notification if required
                          //
                          DBGIF(fWinsCnfRplEnabled)
                          RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);

                        }

                 }
            }
       }
#ifdef WINSDBG
       else  //no conflict means success
       {

                DBGPRINT0(FLOW,
                  "NmsNmhReplRegInd:Replica Registration Done. No conflict\n");
       }
#endif

      } // end of if (RetStat == WINS_SUCCESS)
#ifdef WINSDBG
      else
      {
        DBGPRINT0(ERR, "NmsNmhReplRegInd: Could not register replica\n");
      }
#endif
    } // end of try block
except (EXCEPTION_EXECUTE_HANDLER) {
        DWORD   ExcCode = GetExceptionCode();

                DBGPRINTEXC("NmsNmhReplRegInd");
                DBGPRINT4(EXC, "NmsNmhNamReplRegInd. Name is (%s), Version No  (%d %d); Owner Id (%d)\n", RowInfo.pName, RowInfo.VersNo.HighPart,
          RowInfo.VersNo.LowPart, RowInfo.OwnerId);
                WinsEvtLogDetEvt(FALSE, WINS_EVT_RPL_REG_UNIQUE_ERR,
                            NULL, __LINE__, "sdddd", RowInfo.pName,
                            ExcCode,
                            pAddOfRemWins != NULL ? pAddOfRemWins->Add.IPAdd : 0,
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);

            if (WINS_EXC_BAD_RECORD == ExcCode && fUpdate) {
                // The row needs to be updated
                DBGPRINT4(EXC, "NmsNmhNamReplRegInd. Bad Record will overwitten by Name is (%s), Version No  (%d %d); Owner Id (%d)\n", RowInfo.pName, RowInfo.VersNo.HighPart,
                                  RowInfo.VersNo.LowPart, RowInfo.OwnerId);
                RetStat = NmsDbUpdateRow(&RowInfo,&StatusInfo);
                if ( WINS_SUCCESS == RetStat && NMSDB_SUCCESS == StatusInfo.StatCode ) {
                    NMSNMH_INC_VERS_COUNTER_M(NmsNmhMyMaxVersNo,NmsNmhMyMaxVersNo);
                    // Send a Push Notification if required
                    DBGIF(fWinsCnfRplEnabled)
                    RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
                } else {
                    // dont let bad record stop replication.
                    RetStat = WINS_SUCCESS;
                }
            } else {
                RetStat = WINS_FAILURE;
            }
        }

    LeaveCriticalSection(&NmsNmhNamRegCrtSec);
    //DBG_PRINT_PERF_DATA
    return(RetStat);

}  //NmsNmhReplRegInd()




STATUS
NmsNmhReplGrpMems(
        IN LPBYTE               pName,
        IN DWORD                NameLen,
        IN BYTE                 EntTyp,
        IN PNMSDB_NODE_ADDS_T   pGrpMem,
        IN DWORD                Flag,                 //change to take Flag byte
        IN DWORD                OwnerId,
        IN VERS_NO_T            VersNo,
        IN PCOMM_ADD_T          pAddOfRemWins
        )

/*++

Routine Description:
        This function is called to register a replica of a group

Arguments:
        pName   - Name of replica to register
        NameLen - Length of the name
        EntTyp  - Type of replica (Normal group or special group)
        pGrpMem - Address of array of group members
        Flag    - Flag word of replica record
        OwnerId - Owner Id
        VersNo  - Version No.

Externals Used:
        NmsNmhNamRegCrtSec


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --   WINS_FAILURE

Error Handling:

Called by:
        PullEntries() in rplpull.c

Side Effects:

Comments:
        None
--*/

{

        DWORD  i;
        NMSDB_ROW_INFO_T   RowInfo;
        time_t             ltime;
        NMSDB_STAT_INFO_T  StatusInfo;
        STATUS             RetStat = WINS_SUCCESS;
        BOOL               fUpdate;      //indicates whether conflicting entry
                                         //needs to be overwritten
        BOOL               fUpdVersNo;   //indicates whether version number
                                         //needs to be incremented
        BOOL               fAddMem;      //indicates whether a member needs to
                                         //be added
        BOOL               fRelease;     //indicates whether a node should
                                         // be asked to release the name
        BOOL               fChallenge;   //indicates whether a node should
                                         // be challenged (will be set to TRUE
                                         // only for the multihomed scenario)
        BOOL               fUpdTimeStamp;  //indicates whether the time stamp
                                         // of the entry should be changed
        BOOL               fInformWins;
        NMSCHL_CMD_TYP_E   CmdTyp_e;     //type of command specified to NmsChl
        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhReplGrpMems\n");

        fUpdate =   FALSE;

        /*
        *  initialize the row info. data structure with the data to insert into
        *  the row.  The data passed is

        *  Name, NameLen, IP address, group/unique status,
        *  timestamp, version number
        */
        RowInfo.pName = pName;

        RowInfo.NameLen = NameLen;
        RowInfo.NodeAdds.NoOfMems = pGrpMem->NoOfMems;

PERF("Since this function will be called multiple times, it would be better")
PERF("to call time() in the caller (i.e. PullEntries)")
        (void)time(&ltime);         //time() does not return any error code

        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        if ( NMSDB_ENTRY_TOMB_M(Flag) ) {
            ltime += WinsCnf.TombstoneTimeout;
        }
        else if (OwnerId == NMSDB_LOCAL_OWNER_ID)
        {
              ltime  +=  WinsCnf.RefreshInterval;
        }
        else
        {
              ltime  +=  WinsCnf.VerifyInterval;

        }
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        if (EntTyp != NMSDB_NORM_GRP_ENTRY)
        {
                if (EntTyp == NMSDB_MULTIHOMED_ENTRY)
                {
                   //
                   // For multihomed nodes
                   //
                   RowInfo.NodeTyp   =  (BYTE)((Flag & NMSDB_BIT_NODE_TYP)
                                                >> NMSDB_SHIFT_NODE_TYP);
                }
                else
                {
                   RowInfo.NodeTyp = 0;
                }

                //
                // It is a special group entry or a multihomed entry
                //
                for(i=0; i<pGrpMem->NoOfMems; i++)
                {
                   RowInfo.NodeAdds.Mem[i].Add       = pGrpMem->Mem[i].Add;
                   RowInfo.NodeAdds.Mem[i].OwnerId   = pGrpMem->Mem[i].OwnerId;
                   RowInfo.NodeAdds.Mem[i].TimeStamp = ltime;
#if 0
NOTE("Currently, the timestamp of the record or those of its members is not")
NOTE("replicated.  There is no need for this.  In the future, if a WINS server")
NOTE("starts looking at the timestamps of non-owned members of a special group")
NOTE("or a multihomed entry, we would need to replicate this")

                   RowInfo.NodeAdds.Mem[i].TimeStamp =
                                                   pGrpMem->Mem[i].TimeStamp;
#endif
                }

                RowInfo.pNodeAdd = NULL;
        }
        else  // replica is a normal group
        {
                RowInfo.pNodeAdd = &pGrpMem->Mem[0].Add;
                RowInfo.NodeAdds.Mem[0].Add       = pGrpMem->Mem[0].Add;
                RowInfo.NodeAdds.Mem[0].OwnerId   = pGrpMem->Mem[0].OwnerId;
                RowInfo.NodeAdds.Mem[0].TimeStamp = ltime;
                RowInfo.NodeTyp = 0;
        }

        RowInfo.EntTyp       =  EntTyp;
        RowInfo.OwnerId      =  OwnerId;           // this is a replica
        RowInfo.VersNo       =  VersNo;
        RowInfo.TimeStamp    =  ltime;
        RowInfo.EntryState_e =  NMSDB_ENTRY_STATE_M(Flag);
        RowInfo.fUpdVersNo   =  TRUE;
        RowInfo.fUpdTimeStamp=  TRUE;
        RowInfo.fStatic      =  NMSDB_IS_ENTRY_STATIC_M(Flag);
        RowInfo.fAdmin       =  FALSE;
        RowInfo.fLocal       =  FALSE;
//        RowInfo.CommitGrBit  =  0;

        DBGPRINT5(DET, "NmsNmhReplGrpMems: Name (%s);16th char (%X);State (%d); Static flag (%d); Entry is a %s\n", RowInfo.pName, *(RowInfo.pName+15), RowInfo.EntryState_e, RowInfo.fStatic,
        (EntTyp == NMSDB_NORM_GRP_ENTRY ? "NORMAL GROUP" : (EntTyp == NMSDB_SPEC_GRP_ENTRY) ? "SPECIAL GROUP" : "MULTIHOMED"));
       DBGPRINT2(DET, "Vers. No. is (%d %d)\n", VersNo.HighPart, VersNo.LowPart);

        /*
        * Enter Critical Section
        */
PERF("Try to get rid of this or atleast minimise its impact")
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_START_PERF_MONITORING
try  {
        RetStat = NmsDbInsertRowGrp(
                        &RowInfo,
                        &StatusInfo
                       );
       if (RetStat == WINS_SUCCESS)
       {
                /*
                * If there is a conflict, do the appropriate processing
                */
                if (StatusInfo.StatCode == NMSDB_CONFLICT)
                {

                         DBGPRINT0(FLOW, "NmsNmhReplGrpMems: Name Conflict\n");

                         ClashAtReplGrpR(
                                &RowInfo,
                                &StatusInfo,
                                &fAddMem,
                                &fUpdate,
                                &fUpdVersNo,
                                &fRelease,
                                &fChallenge,
                                &fUpdTimeStamp,
                                &fInformWins
                                        );

PERF("Might want to examine which cases happen most often and then rearrange")
PERF("this so that the most often expected cases come first in the following")
PERF("if tests")
                        //
                        // if fRelease or fChallenge (will be set only for
                        // multihomed case) is TRUE, we don't look at any other
                        // attributes
                        //
                        if (fRelease)
                        {
                                  DBGPRINT0(FLOW,
                                  "NmsNmhReplGrpMems: Handing name registration to challenge manager\n");

                                if (fChallenge)
                                {
                                   /*
                                    *Ask the Name Challenge comp to take it from
                                    *here. fInformWins will not ever by TRUE as
                                    * it stands currently 10/15/98 (has been
                                    * the case since the beginning).
                                   */
                                   CmdTyp_e = (fInformWins ?
                                                NMSCHL_E_CHL_N_REL_N_INF :
                                                        NMSCHL_E_CHL_N_REL);
                                }
                                else
                                {
                                   CmdTyp_e = NMSCHL_E_REL;
                                }

                                    NmsChlHdlNamReg(
                                                CmdTyp_e,
                                                WINS_E_RPLPULL,
                                                NULL,
                                                NULL,
                                                0,
                                                0,
                                                &RowInfo,
                                                &StatusInfo,
                                                pAddOfRemWins
                                                     );
                        }
                        else  // we need to handle this in this thread only
                        {
                           //
                           // If one or more members have to be added to the
                           // list already there (RowInfo.NodeAdds will have
                           // these new members)
                           //
                           if (fAddMem)
                           {

                                //
                                // The owner stays the same
                                //
                                //RowInfo.OwnerId = StatusInfo.OwnerId;

                                //
                                //  If vers number needs to be updated, do so
                                //
                                //  Note: This should never happen if the
                                //        record in the db is not owned by this
                                //        WINS
                                //
                                if (fUpdVersNo)
                                {
                                       //
                                       // The owner stays the same.  We will
                                       // never update the version number
                                       // unless it is owned by the local WINS
                                       //
                                       RowInfo.OwnerId = NMSDB_LOCAL_OWNER_ID;
                                       RowInfo.VersNo  = NmsNmhMyMaxVersNo;
                                       ASSERT(StatusInfo.OwnerId ==
                                                        NMSDB_LOCAL_OWNER_ID);
                                }

                                //
                                // If fUpdVersNo is not set, it means that
                                // the record is owned by another WINS. Because
                                // we are adding a member, we should change
                                // both the owner id and the version number
                                // to that of the current record. In other
                                // words, do an update. This will ensure that
                                // partners of this WINS will see the changed
                                // member list.
                                //
#if 0
                                else
                                {
                                    RowInfo.fUpdVersNo   =  FALSE;
                                }
#endif

                                RetStat =   NmsDbUpdateRow (
                                                &RowInfo,
                                                &StatusInfo
                                                         );
                           }
                           else // no member needs to be added
                           {
                                //
                                //  If vers number needs to be updated, do so
                                //
                                if (fUpdVersNo)
                                {
                                        RowInfo.VersNo    = NmsNmhMyMaxVersNo;
                                        //
                                        // we use the attribute fUpdTimeStamp
                                        // only if fUpdVersNo is TRUE (and
                                        // fAddMem == FALSE)
                                        //
                                        RowInfo.fUpdTimeStamp = fUpdTimeStamp;
                                        RetStat =   NmsDbUpdateVersNo(
                                                         TRUE,
                                                         &RowInfo,
                                                         &StatusInfo
                                                                       );
                                }
                                else
                                {
                                        //
                                        // If the entire record needs to be
                                        // updated do so.
                                        //
                                        if (fUpdate)
                                        {
                                                RetStat =   NmsDbUpdateRow(
                                                        &RowInfo,
                                                        &StatusInfo
                                                                    );
                                                DBGPRINT0(FLOW,
                                           "NmsNmhReplGrpMems: Updated Db\n");
                                        }
                                        else
                                        {
                                            StatusInfo.StatCode = NMSDB_SUCCESS;
                                            DBGPRINT0(FLOW,
                                                     "Repl Registration (group) not needed for this conflict\n");
                                        }
                                }  // vers no. not to be incremented
                           } // no member needs to be added

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - Maybe")
                           //we succeeded in inserting the row
                           if (
                              (RetStat != WINS_SUCCESS) ||
                              (StatusInfo.StatCode != NMSDB_SUCCESS)
                              )
                           {
                               RetStat = WINS_FAILURE;
                               DBGPRINT5(ERR, "NmsNmhReplGrpR: Could not update Db with replica %s[%x] of Owner Id (%d) and Vers. No (%d %d)\n", RowInfo.pName, *(RowInfo.pName + 15), RowInfo.OwnerId, RowInfo.VersNo.HighPart, RowInfo.VersNo.LowPart);
                           }
                           else
                           {
                                if (fUpdVersNo)
                                {
                                        NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                               );
                                        DBGIF(fWinsCnfRplEnabled)
                                        RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                        NULL);

                                }
                           }
                        }  // need to handle it in this thread only
                 }
                 else  //no conflict means success
                 {

                        DBGPRINT0(FLOW,
                                "Replica Registration Done. No conflict\n");
                 }
        } // end of if (RetStat == WINS_SUCCESS)
#ifdef WINSDBG
        else
        {
                DBGPRINT0(ERR,
                        "NmsNmhReplGrpMems: Could not register replica\n");
        }
#endif
    } // end of try block
except (EXCEPTION_EXECUTE_HANDLER) {
         BYTE Tmp[20];
         DWORD   ExcCode = GetExceptionCode();
         DBGPRINT1(EXC, "NmsNmhReplGrpMems: Got exception (%d)\n",
                                        ExcCode);
         WinsEvtLogDetEvt(FALSE, WINS_EVT_RPL_REG_GRP_MEM_ERR,
                            NULL, __LINE__, "sdsdd", RowInfo.pName,
                            ExcCode,
                            pAddOfRemWins != NULL ? _itoa(pAddOfRemWins->Add.IPAdd, Tmp, 10) : "SEE AN EARLIER LOG",
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);
         if (WINS_EXC_BAD_RECORD == ExcCode && fUpdate) {
             // The row needs to be updated
             DBGPRINT4(EXC, "NmsNmhNamReplGrpMems. Bad Record will overwitten by Name is (%s), Version No  (%d %d); Owner Id (%d)\n", RowInfo.pName, RowInfo.VersNo.HighPart,
                               RowInfo.VersNo.LowPart, RowInfo.OwnerId);
             RetStat = NmsDbUpdateRow(&RowInfo,&StatusInfo);
             if ( WINS_SUCCESS == RetStat && NMSDB_SUCCESS == StatusInfo.StatCode ) {
                 NMSNMH_INC_VERS_COUNTER_M(NmsNmhMyMaxVersNo,NmsNmhMyMaxVersNo);
                 // Send a Push Notification if required
                 DBGIF(fWinsCnfRplEnabled)
                 RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
             } else {
                 // dont let bad record stop replication.
                 RetStat = WINS_SUCCESS;
             }
         } else {
             RetStat = WINS_FAILURE;
         }

          RetStat = WINS_FAILURE;
        }

        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_PRINT_PERF_DATA
        DBGLEAVE("NmsNmhReplGrpMems\n");
        return(RetStat);

} //NmsNmhReplGrpMems()



BOOL
UnionGrps(
        PNMSDB_ROW_INFO_T        pEntryToReg,
        PNMSDB_ROW_INFO_T        pEntryInCnf
        )

/*++

Routine Description:
        This function is called to create a union of special groups

Arguments:
        pEntryToReg - Entry to register
        pEntryInCnf - Entry In conflict

Externals Used:
        None

Return Value:
        TRUE  if the union is a superset
        FALSE otherwise

Error Handling:

Called by:
        ClashAtReplGrpR

Side Effects:

Comments:
        None
--*/

{

        DWORD                         no;
        DWORD                         i, n;
        BOOL                        fFound;
        BOOL                        fToRemove;
        BOOL                        fUnion = FALSE;
        PNMSDB_GRP_MEM_ENTRY_T        pCnfMems;
        PNMSDB_GRP_MEM_ENTRY_T        pRegMems;
        PNMSDB_ADD_STATE_T        pOwnAddTbl = pNmsDbOwnAddTbl;
        BOOL                        fMemToReplaceFound;
        DWORD                        IdOfMemToReplace;
        DWORD                        EntryInCnfMemsBeforeUnion;
        DWORD                        EntryToRegMemsBeforeUnion;

        DBGENTER("UnionGrps\n");


        DBGPRINT2(DET, "UnionGrps: No Of Mems To register = (%d)\nNo Of Mems in Conflicting record = (%d)\n",
                                pEntryToReg->NodeAdds.NoOfMems,
                                pEntryInCnf->NodeAdds.NoOfMems
                   );
        //
        // Remember the number of members in the conflicting record before
        // performing the union. After the union, if the list grows, we make the
        // local wins owner of this record NMSDB_LOCAL_OWNER_ID. This causes
        // the verid to go up and hence will update the member list of this record
        // in our replication partner dbs.
        //
        EntryInCnfMemsBeforeUnion = pEntryInCnf->NodeAdds.NoOfMems;
        EntryToRegMemsBeforeUnion = pEntryToReg->NodeAdds.NoOfMems;

        //
        // First, remove all members from the conflicting record that
        // are owned by the WINS whose replica we pulled but are not
        // in the list of the remote WINS sever owned members of the replica
        //
        pCnfMems              = pEntryInCnf->NodeAdds.Mem;
        for (i=0; i < pEntryInCnf->NodeAdds.NoOfMems; )
        {
           if (pCnfMems->OwnerId == pEntryToReg->OwnerId)
           {
              pRegMems = pEntryToReg->NodeAdds.Mem;
              fToRemove = TRUE;
              for (no=0; no < pEntryToReg->NodeAdds.NoOfMems; no++, pRegMems++)
              {

                    if (pCnfMems->OwnerId != pRegMems->OwnerId)
                    {
                         //
                         // OwnerId is different from that of the replica,
                         // go to the next member in the list
                         //
                         continue;
                    }
                    else  //owner id same as that of replica member
                    {
                         if (pCnfMems->Add.Add.IPAdd != pRegMems->Add.Add.IPAdd)
                         {
                                  //
                                  // IP add. different, continue on so that
                                  // we compare with the next member in
                                  // the replica
                                  //
                                  continue;
                         }
                         else  //ip addresses are same
                         {
                                 fToRemove = FALSE;
                                 break;
                         }
                    }
              } // end of for
              if (fToRemove)
              {
                     PNMSDB_GRP_MEM_ENTRY_T pMem;
                     DBGPRINT4(FLOW, "UnionGrps: REMOVING conflicting member no = (%d) of (%s) with owner id. = (%d)  and address (%x)\n", i, pEntryToReg->pName, pCnfMems->OwnerId, pCnfMems->Add.Add.IPAdd);
                     pMem = pCnfMems;
                     for (n = i; n < (pEntryInCnf->NodeAdds.NoOfMems - 1); n++)
                     {
                        *pMem = *(pMem + 1);
                        pMem++;
                     }
                     pEntryInCnf->NodeAdds.NoOfMems--;
                     if (!fUnion)
                     {
                          fUnion = TRUE;
                     }
                     continue;
              }
           }
           i++;
           pCnfMems++;
        } // end of for (loop over conflicting members)

        //
        // For each member in the record to register, do the following..
        //
        pRegMems = pEntryToReg->NodeAdds.Mem;
        for(i=0; i < pEntryToReg->NodeAdds.NoOfMems; pRegMems++, i++)
        {
                    fFound = FALSE;

                  DBGPRINT3(DET, "UnionGrps: Member no (%d) of record to register has IP address = (%d) and owner id. = (%d)\n", i, pRegMems->Add.Add.IPAdd,
                               pRegMems->OwnerId
                          );
                  //
                  // Check against all members of the record in conflict
                  //
                  pCnfMems              = pEntryInCnf->NodeAdds.Mem;
                  fMemToReplaceFound = FALSE;
                  for(no=0; no < pEntryInCnf->NodeAdds.NoOfMems; no++, pCnfMems++)
                  {
                        DBGPRINT3(DET, "UnionGrps: Comparing with member (%d) of conflicting record. Member address is (%d) and owner id is (%d)\n",
                                no, pCnfMems->Add.Add.IPAdd, pCnfMems->OwnerId);

                        //
                        // If the address is the same and the owner Id is the
                        // same, we break out of the loop in order to check
                        // the next member of the record to register's list
                        //
                        if (
                                pCnfMems->Add.Add.IPAdd ==
                                        pRegMems->Add.Add.IPAdd
                           )
                        {
                                if ( pCnfMems->OwnerId == pRegMems->OwnerId )
                                {
                                        DBGPRINT3(DET, "UnionGrps: IP address = (%d) with owner id. of (%d) is already there in conflicting group (%s)\n",
                                        pRegMems->Add.Add.IPAdd,
                                        pRegMems->OwnerId,
                                        pEntryToReg->Name
                                                  );

                                        //
                                        // set fFound to TRUE so that this
                                        // member is not added to StoreMems
                                        // later on in this for loop.
                                        //
                                        fFound = TRUE;
                                }
                                else  //same IP address, but different owners
                                {
                                        DBGPRINT4(DET, "UnionGrps: IP address = (%d) (with owner id. of (%d)) is already there in conflicting group (%s) but is owned by (%d) \n",
                                        pRegMems->Add.Add.IPAdd,
                                        pRegMems->OwnerId,
                                        pEntryToReg->Name,
                                        pCnfMems->OwnerId
                                                );
                                        fFound     = TRUE;

                                        //
                                        // if the timestamp is MAXULONG, then
                                        // we should not replace the owner id.
                                        //Currently MAXULONG is there only for
                                        //static SG members.
                                        //
                                        if (pCnfMems->TimeStamp != MAXLONG)
                                        {
                                         //
                                         // Replace the owner id of the member
                                         // in the conflicting record with that
                                         // of the member in the record to reg
                                         //
                                         pCnfMems->OwnerId = pRegMems->OwnerId;

                                         //
                                         // Set fUnion to TRUE so that the
                                         // caller of this function increments
                                         // the version count (only if the
                                         // conflicting record is owned; In such
                                         // a case, we want to propagate the
                                         // record)
                                         //
                                         fUnion = TRUE;
                                       }
                                }

                                //
                                // break out of the for loop;
                                // We are done with this member of the
                                // record to register
                                //
                                break;

                        }
                        else
                        {
                           //
                           // Addresses don't match.  If the member in the
                           // conflicting record is not owned by the local
                           // WINS it might be a candidate for replacement
                           // if we don't find a member with a matching
                           // address.  NOTE: a member with a timestamp of
                           // MAXULONG is not to be replaced.
                           // Currently, only a static SG member can have
                           // a MAXULONG value
                           //
                           if ((pCnfMems->OwnerId != NMSDB_LOCAL_OWNER_ID)
                                              &&
                              (pCnfMems->TimeStamp != MAXLONG))

                           {
                             if (
                                  !fMemToReplaceFound
                                        &&
                                  ((pOwnAddTbl + pCnfMems->OwnerId)->MemberPrec
                                                  <
                                  (pOwnAddTbl + pRegMems->OwnerId)->MemberPrec)

                                )
                             {
                                     fMemToReplaceFound = TRUE;
                                     IdOfMemToReplace   = no;
                             }
                           }

                        }
                 } // for (..) for looping over all mem. of conflicting record

                 //
                 // If we did not find the member in conflicting record
                 // we insert it into StoreMems if there are vacant slots
                 // at the end
                 //
                 if(!fFound)
                 {
                    if (pEntryInCnf->NodeAdds.NoOfMems < NMSDB_MAX_MEMS_IN_GRP)
                    {
                        //
                        //  add the member of the record to register to
                        //  StoreMems
                        //
                        pEntryInCnf->NodeAdds.Mem[
                                pEntryInCnf->NodeAdds.NoOfMems++] = *pRegMems;

                        fUnion = TRUE;
                   }
                   else
                   {
                        //
                        // if there is atleast one remote member of lower
                        // precedence value, replace it
                        //
                        if (fMemToReplaceFound)
                        {
                                pEntryInCnf->NodeAdds.Mem[IdOfMemToReplace] =
                                                                *pRegMems;
                                fUnion = TRUE;
                        }
                        //
                        // check the next member in the pulled in replica
                        //
                   }
                 }
        }  // end of for loop

        //
        // if the conflicting member list was changed,
        // Copy all information in pEntryInCnf->NodeAdds to
        // pEntryToReg->NodeAdds
        //
        if (fUnion)
        {
          pRegMems = pEntryToReg->NodeAdds.Mem;
          pCnfMems = pEntryInCnf->NodeAdds.Mem;
          for (
                        i=0;
                        i < pEntryInCnf->NodeAdds.NoOfMems;
                        i++, pRegMems++, pCnfMems++
              )
          {
                *pRegMems = *pCnfMems;
          }
          pEntryToReg->NodeAdds.NoOfMems = pEntryInCnf->NodeAdds.NoOfMems;
        }

        // if the new list is bigger, make the local wins the owner of this record.
        if ( pEntryInCnf->NodeAdds.NoOfMems > EntryInCnfMemsBeforeUnion &&
             pEntryInCnf->NodeAdds.NoOfMems > EntryToRegMemsBeforeUnion )
        {
            if ( pEntryInCnf->OwnerId != NMSDB_LOCAL_OWNER_ID ) {
                // change the timestamp to verifyinterval so that this record does not get
                // scavenged.
                time((time_t*)&(pEntryToReg->TimeStamp));
                pEntryToReg->TimeStamp += WinsCnf.VerifyInterval;
                pEntryInCnf->OwnerId = NMSDB_LOCAL_OWNER_ID;
                DBGPRINT3(DET, "UnionGrps: Conflicting mem# %d, registering record mem %d, new list# %d - ownership changed\n",
                          EntryInCnfMemsBeforeUnion, EntryToRegMemsBeforeUnion, pEntryInCnf->NodeAdds.NoOfMems);
            }
        }

        DBGPRINT1(FLOW,
                "UnionGrps: Union %s\n", (fUnion ? "DONE" : "NOT DONE"));
        DBGLEAVE("UnionGrps\n");
        return(fUnion);
} //UnionGrps

VOID
NmsNmhUpdVersNo(
        IN  LPBYTE                pName,
        IN  DWORD                NameLen,
        OUT LPBYTE                pRcode,
        IN  PCOMM_ADD_T         pWinsAdd
        )

/*++

Routine Description:
        This function is called to update the version number of a record

Arguments:

        pName                - Name to be registered
        NameLen                - Length of Name
        pRcode                - result of the operation
        WinsId          - Id of WINS that initiated this operation
                                (not used currently)

Externals Used:

        NmsNmhNamRegCrtSec

Return Value:
        None

Error Handling:

Called by:

        HandleUpdVersNoReq in rplpush.c

Side Effects:

Comments:
        NOTE: This function is supposed to be called only by the PUSH
        thread.  It should *NOT* be called by the PULL thread.  This
        is because of the inherent assumption made by this function
        regarding the type of index to set at the exit point of the function

--*/

{

        NMSDB_ROW_INFO_T   RowInfo;    // contains row info
        NMSDB_STAT_INFO_T  StatusInfo; /* error status and associated
                                        * info returned by the NmsDb func
                                        */
//        time_t                   ltime;        //stores time since Jan 1, 1970

        DBGENTER("NmsNmhUpdVersNo\n");

        /*
        * initialize the row info. data structure with the data to insert into
        * the row.  The data passed is

        * Name, NameLen, address, group/unique status,
        * timestamp, version number
        */
        RowInfo.pName         = pName;
        RowInfo.NameLen       =  NameLen;
        //(void)time(&ltime);               //time does not return any error code
        //RowInfo.TimeStamp     = ltime; // put current time here
        RowInfo.fUpdVersNo    = TRUE;
        RowInfo.fUpdTimeStamp = FALSE;
        RowInfo.fAdmin        = FALSE;        //does not really have to be set

        //
        // Set the current index to the name column
        //
        NmsDbSetCurrentIndex(
                                NMSDB_E_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
        /*
        * Enter Critical Section
        */
        EnterCriticalSection(&NmsNmhNamRegCrtSec);

        /*
          Store version number
        */
        RowInfo.VersNo        = NmsNmhMyMaxVersNo;

try {
           NmsDbUpdateVersNo(
                                        FALSE,
                                        &RowInfo,
                                        &StatusInfo
                                       );

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - maybe")
           if (StatusInfo.StatCode != NMSDB_SUCCESS)
           {
                        *pRcode = NMSMSGF_E_SRV_ERR;
           }
           else
           {
                DBGPRINT0(FLOW, "NmsNmhUpdVersNo:Vers. No incremented \n");
                       NMSNMH_INC_VERS_COUNTER_M(
                                NmsNmhMyMaxVersNo,
                                NmsNmhMyMaxVersNo
                                       );
                *pRcode = NMSMSGF_E_SUCCESS;
                DBGIF(fWinsCnfRplEnabled)
                RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, pWinsAdd, NULL);
           }

  }
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhUpdVersNo");
                WINSEVT_LOG_D_M(GetExceptionCode(),WINS_EVT_UPD_VERS_NO_ERR);
        }
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        //
        // Set the current index to the owner-version # columns
        //
        NmsDbSetCurrentIndex(
                                NMSDB_E_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_PRIM_INDEX_NAME
                            );
        return;
} //NmsNmhUpdVersNo()



/*
       Clash scenarios:

        Clash of a active unique replica with a normal group, any state:                        Keep the normal group.  Group may be a T because the router
                is down.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\wins.c ===
int
dummy()
{
return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\winsint.c ===
int
dummy()
{
return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\nmsmsgf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	nmsmsgf.c

Abstract:

  This module contains the functions for formatting and unformatting
  the various messages that are sent and/or received from nbt nodes.
  It also contains the function called by the NBT threads to service
  a name request

Functions:

	NmsMsgfProcNbtReq
	GetName
	GetOtherInfo
	NmsMsgfFrmNamRspMsg
	FrmNamRegRsp
	FrmNamRelRsp
	FrmNamQueryRsp
	FormatQueryRspBuff
	FormatName
	NmsMsgfFrmNamQueryReq
	NmsMsgfFrmNamRelReq
	NmsMsgfFrmWACK
	NmsMsgfUfmNamRsp
	
Author:

	Pradeep Bahl (PradeepB)  	Dec-1992

Revision History:

--*/
/*
 Includes
*/

#include "wins.h"
#include "nms.h"
#include "nmsdb.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winsmsc.h"
#include "nmsmsgf.h"
#include "nmsnmh.h"
#include "nmschl.h"
#include "comm.h"
#include "winsintf.h"


/*
  defines
*/


#define NAME_HEADER_SIZE	12	 /* header size (bytes before the Ques
					  * name section of a name packet
					  */

#define NAME_FORMAT_MASK	0xC0      /*top two bits of a byte*/
#define NODE_TYPE_MASK          0x60      /*bit 13 and 14 of NBFLAGs field */
#define SHIFT_NODE_BITS		5	  //shift the node bits in the byte
					  //containing them by this amount
#define LENGTH_MASK		0x3F      /*6 LSBs of the top byte of the
					   * QuesNamSec field
					   */
#define GROUP_BIT_MASK		0x80	   /*bit 7 of the 1st byte (MSB)of the
					    *16 bit NBFLAGS field
					   */
/*
 *  Max length of a Name (including label length octets) in RFC packet
*/
#define RFC_MAX_NAM_LEN  	255

//
// Max size of internal name as derived from the rfc packet name
//
#define MAX_SIZE_INTERNAL_NAME	(RFC_MAX_NAM_LEN - 16)	
					 //This should be = (255 - 16)
					 //since the max size of the netbios
					 //name (with scope attached) can be
					 //be 255.  The first 32 bytes
					 //are encoded. These map to 16
					 //bytes in the internal name


/*
* Max length of a label in a name
*/
#define RFC_MAX_LABEL_LEN	63


/*
 * Sizes of the various fields in the name service packets received or sent
 * by the WINS server.  These sizes are specified in RFC 1002
 */
#define RFC_LEN_QTYP	(2)
#define RFC_LEN_QCLS	(2)
#define RFC_LEN_TTL	(4)
#define RFC_LEN_RDLEN	(2)	
#define RFC_LEN_NBFLAGS	(2)
#define RFC_LEN_NBADD	(4)
#define RFC_LEN_RRTYP	(2)
#define RFC_LEN_RRCLS	(2)
#define RFC_LEN_RRPTR	(2)	

#define RFC_LEN_QTYP_N_QCLS	(RFC_LEN_QTYP + RFC_LEN_QCLS) /* page 10 -
							       *RFC 1002
							       */
#define RFC_LEN_RRTYP_N_RRCLS	(RFC_LEN_RRTYP + RFC_LEN_RRCLS) /* page 11 -
							         *RFC 1002
							         */

/*
 * The following is used by FrmNamQueryRsp in its calculation to determine
 * if the name query buffer would be big enough for the response
*/

#define RFC_LEN_TTL_N_RDLEN	(RFC_LEN_TTL + RFC_LEN_RDLEN)

#define RFC_LEN_RR_N_TTL	(RFC_LEN_RRTYP_N_RRCLS + RFC_LEN_TTL)

#define RFC_LEN_RR_N_TTL_N_RDLEN_N_NBF (RFC_LEN_RR_N_TTL + \
				    RFC_LEN_RDLEN +  RFC_LEN_NBFLAGS)


//
// Length of NBFLAGS and the NB address
//
#define RFC_LEN_NBF_N_NBA	(RFC_LEN_NBFLAGS + RFC_LEN_NBADD)

#define RFC_LEN_RDLEN_N_NBF	(RFC_LEN_RDLEN + RFC_LEN_NBFLAGS)
//
// Length of the RDLEN, NB flags and NB address section. Page 13 of RFC 1002
//
#define RFC_LEN_RDLEN_N_NBF_N_NBA  (RFC_LEN_RDLEN + RFC_LEN_NBF_N_NBA)
/*
 * Size of the TTL, RDLEN, NB Flags and NB address section
*/
#define RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA	(RFC_LEN_TTL + RFC_LEN_RDLEN_N_NBF_N_NBA)

/*
 The value of the 3rd and 4 th byte of the first long of the response packets
 for the different name requests.  The bytes are numbered from the start of
 the pkt.

 Note: for a negative response the Rcode value (4 LSBs of the 4th byte of the
 message) has to be ORed with the LBFW values

*/
#define RFC_NAM_REG_RSP_OPC	  	(0xAD) /*+ve registration response*/
#define RFC_NAM_REG_RSP_4THB		(0x80) /*4th byte of the above pkt */
#define RFC_NAM_REL_RSP_OPC      	(0xB4) /*+ve release response*/
#define RFC_NAM_REL_RSP_4THB		(0x00) /*4th byte of the above pkt*/
						

#define RFC_NAM_QUERY_RSP_OPC_NO_T    (0x85)  /*+ve query resp (complete)*/
#define RFC_NAM_QUERY_RSP_OPC_T       (0x87)  /*+ve query resp (truncated)*/
#define RFC_NAM_QUERY_RSP_4THB	      (0x80)  /*4th byte of the above pkt */


/*
 * Values of different fields in RFC response packet
 */


/*
   QD Count and AN count fields of the Name Reg. Rsp pkt
*/
#define RFC_NAM_REG_RSP_QDCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_QDCNT_2NDB    (0x00)
#define RFC_NAM_REG_RSP_ANCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_ANCNT_2NDB    (0x01)

/*
   NS Count and AR count fields of the Name Reg. Rsp pkt
*/

#define RFC_NAM_REG_RSP_NSCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_NSCNT_2NDB    (0x00)
#define RFC_NAM_REG_RSP_ARCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_ARCNT_2NDB    (0x00)

/*
   QD Count and AN count fields of the Name Rel. Rsp pkt
*/
#define RFC_NAM_REL_RSP_QDCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_QDCNT_2NDB    (0x00)
#define RFC_NAM_REL_RSP_ANCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_ANCNT_2NDB    (0x01)

/*
   NS Count and AR count fields of the Name Rel. Rsp pkt
*/

#define RFC_NAM_REL_RSP_NSCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_NSCNT_2NDB    (0x00)
#define RFC_NAM_REL_RSP_ARCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_ARCNT_2NDB    (0x00)

/*
   QD Count and AN count fields of the Name Query. Rsp pkt
*/

#define RFC_NAM_QUERY_RSP_QDCNT_1STB    (0x00)
#define RFC_NAM_QUERY_RSP_QDCNT_2NDB    (0x00)
#define RFC_NAM_QUERY_RSP_ANCNT_1STB    (0x00)

#define RFC_NAM_QUERY_POS_RSP_ANCNT_2NDB    (0x01)
#define RFC_NAM_QUERY_NEG_RSP_ANCNT_2NDB    (0x00)

/*
   NS Count and AR count fields of the Name Query. Rsp pkt
*/
#define RFC_NAM_QUERY_RSP_NSCNT_1STB    (0x00)
#define RFC_NAM_QUERY_RSP_NSCNT_2NDB    (0x00)
#define RFC_NAM_QUERY_RSP_ARCNT_1STB    (0x00)
#define RFC_NAM_QUERY_RSP_ARCNT_2NDB    (0x00)



/*
 * NB and IN fields of the name query response pkt
 * Page 21 and 22 of RFC 1002
*/

/*
  Positive name query response
*/
#define RFC_NAM_QUERY_POS_RSP_NB_1STB	(0x00)
#define RFC_NAM_QUERY_POS_RSP_NB_2NDB	(0x20)
#define RFC_NAM_QUERY_POS_RSP_IN_1STB	(0x00)
#define RFC_NAM_QUERY_POS_RSP_IN_2NDB	(0x01)

/*
  Negative name query response
*/
#define RFC_NAM_QUERY_NEG_RSP_NB_1STB	(0x00)
#define RFC_NAM_QUERY_NEG_RSP_NB_2NDB	(0x0A)
#define RFC_NAM_QUERY_NEG_RSP_IN_1STB	(0x00)
#define RFC_NAM_QUERY_NEG_RSP_IN_2NDB	(0x01)

/*
   name query request opcode byte and 4th byte
*/
#define RFC_NAM_QUERY_REQ_OPCB		(0x01)
#define RFC_NAM_QUERY_REQ_4THB		(0x0)

/*
   name query request QDCOUNT and ANCOUNT bytes
*/
#define RFC_NAM_QUERY_REQ_QDCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_QDCNT_2NDB	(0x01)
#define RFC_NAM_QUERY_REQ_ANCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_ANCNT_2NDB	(0x00)

/*
   name query request NSCOUNT and ARCOUNT bytes
*/
#define RFC_NAM_QUERY_REQ_NSCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_NSCNT_2NDB	(0x00)
#define RFC_NAM_QUERY_REQ_ARCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_ARCNT_2NDB	(0x00)

/*
   name query request QTYP and QCLS bytes
*/
#define RFC_NAM_QUERY_REQ_QTYP_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_QTYP_2NDB	(0x20)
#define RFC_NAM_QUERY_REQ_QCLS_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_QCLS_2NDB	(0x01)

/*
   name release request opcode byte and 4th byte
*/
#define RFC_NAM_REL_REQ_OPCB		(0x30)
#define RFC_NAM_REL_REQ_4THB		(0x00)

/*
   name release request QDCOUNT and ANCOUNT bytes
*/
#define RFC_NAM_REL_REQ_QDCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_QDCNT_2NDB	(0x01)
#define RFC_NAM_REL_REQ_ANCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_ANCNT_2NDB	(0x00)

/*
   name release request NSCOUNT and ARCOUNT bytes
*/
#define RFC_NAM_REL_REQ_NSCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_NSCNT_2NDB	(0x00)
#define RFC_NAM_REL_REQ_ARCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_ARCNT_2NDB	(0x01)

/*
   name release request QTYP and QCLS bytes
*/
#define RFC_NAM_REL_REQ_QTYP_1STB	(0x00)
#define RFC_NAM_REL_REQ_QTYP_2NDB	(0x20)
#define RFC_NAM_REL_REQ_QCLS_1STB	(0x00)
#define RFC_NAM_REL_REQ_QCLS_2NDB	(0x01)
/*
   name Release request RRTYP and RRCLS bytes
*/
#define RFC_NAM_REL_REQ_RRTYP_1STB	(0x00)
#define RFC_NAM_REL_REQ_RRTYP_2NDB	(0x20)
#define RFC_NAM_REL_REQ_RRCLS_1STB	(0x00)
#define RFC_NAM_REL_REQ_RRCLS_2NDB	(0x01)

/*
   WACK opcode byte and 4th byte
*/
#define RFC_WACK_OPCB		(0xBC)
#define RFC_WACK_4THB		(0x0)

/*
   WACK QDCOUNT and ANCOUNT bytes
*/
#define RFC_WACK_QDCNT_1STB	(0x0)
#define RFC_WACK_QDCNT_2NDB	(0x0)
#define RFC_WACK_ANCNT_1STB	(0x0)
#define RFC_WACK_ANCNT_2NDB	(0x1)

/*
   WACK NSCOUNT and ARCOUNT bytes
*/
#define RFC_WACK_NSCNT_1STB	(0x0)
#define RFC_WACK_NSCNT_2NDB	(0x0)
#define RFC_WACK_ARCNT_1STB	(0x0)
#define RFC_WACK_ARCNT_2NDB	(0x0)
/*
  WACK  RRTYP and RRCLS bytes
*/
#define RFC_WACK_RRTYP_1STB	(0x00)
#define RFC_WACK_RRTYP_2NDB	(0x20)
#define RFC_WACK_RRCLS_1STB	(0x00)
#define RFC_WACK_RRCLS_2NDB	(0x01)

// WACK RDLENGTH Field

#define RFC_WACK_RDLENGTH_1STB	(0x0)
#define RFC_WACK_RDLENGTH_2NDB	(0x02)

/*
 Local variable declarations
*/


/*
 Local function declarations
*/
/*
 *GetName -- Extract name out of packet
*/
STATIC
VOID
GetName(
	IN  OUT LPBYTE  *ppName,
	IN  OUT LPBYTE 	pName,
	OUT     LPDWORD   pNameLen
	);
/*
 * Format Name - Format (encode) name for placing in RFC packet
*/
STATIC
VOID
FormatName(
	IN     LPBYTE pNameToFormat,
	IN     DWORD  LengthOfName,
	IN OUT LPBYTE *ppFormattedName
	);
/*
 * GetOtherInfo -- Get information (excluding the name) from the pkt
 */
STATIC
STATUS
GetOtherInfo(
	IN NMSMSGF_NAM_REQ_TYP_E   Opcode_e,
	IN LPBYTE		   pRR,	   /*point to the RR_NAME section in the
				   	    *name registration packet
					    */
	IN   INT	           QuesNamSecLen, //Size of Ques name section
	OUT  LPBOOL		   pfGrp,         //Flag -- unique/group entry
	OUT  PNMSMSGF_CNT_ADD_T    pCntAdd, 	  //Address	
	OUT  PNMSMSGF_NODE_TYP_E   pNodeTyp_e     //Node Type if unique
	);

/*
 * FrmNamRegRsp - Format name registration response
*/
STATIC
STATUS
FrmNamRegRsp(
  PCOMM_HDL_T 		pDlgHdl,
  PNMSMSGF_RSP_INFO_T	pRspInfo
);


/*
 * FrmNamRelRsp - Format name release response
*/
STATIC
STATUS
FrmNamRelRsp(
  PCOMM_HDL_T 		   pDlgHdl,
  PNMSMSGF_RSP_INFO_T	   pRspInfo
);

#if 0
/*
 * FrmNamQueryRsp - Format name query response
*/
STATIC
STATUS
FrmNamQueryRsp(
  IN  PCOMM_HDL_T 	   	pDlgHdl,
  PNMSMSGF_RSP_INFO_T	        pRspInfo
);
#endif

/*
 * FormatQueryRspBuff - Format name query response buffer
*/
STATIC
STATUS
FormatQueryRspBuff(
   IN  LPBYTE 		 	pDest,
   IN  LPBYTE 		 	pSrc,
   IN  PNMSMSGF_RSP_INFO_T	pRspInfo,
   IN  BOOL		 	fTrunc
  	);



/*
	function definitions
*/

STATUS
NmsMsgfProcNbtReq(
	PCOMM_HDL_T	pDlgHdl,
        MSG_T		pMsg,
	MSG_LEN_T	MsgLen
	)

/*++

Routine Description:

  This function is called by an nbt request thread after it dequeues an nbt
  request message from the work-queue.  The function unformats the message
  and then calls the appropriate function to process it.


Arguments:
	pDlgHdl  - Dlg Handle
	pMsg	 - Message Buffer (contains that RFC packet containing
			the request received from an NBT node)	
	MsgLen   - Length of above buffer

Externals Used:
	None

Called by:

	NbtThdInitFn() in nms.c
Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes  --  WINS_FAILURE

--*/

{

	NMSMSGF_NAM_REQ_TYP_E Opcode;
	BYTE		      Name[NMSDB_MAX_NAM_LEN];
	DWORD		      NameLen;   		/*length of name */
        DWORD		      QuesNamSecLen;   		/*length of question
							 *name  section in
							 *packet
					                 */
	NMSMSGF_NODE_TYP_E    NodeTyp_e = NMSMSGF_E_PNODE;
//	BOOL		      fRefresh;

	NMSMSGF_CNT_ADD_T     CntAdd;
	COMM_ADD_T            Address;	
	BOOL	              fGrp;        /*flag indicating whether the name
					    *is a Unique/Group Netbios name.
					    *fGrp is TRUE if the name is a
					    *group name, else it is FALSE
				            */
	BOOL		     fBuffFreed = FALSE; //indicates whether buffer has
						 //been freed or not

	LPBYTE	pTmp  = (LPBYTE)pMsg;
	LPBYTE  pTmp2;

	DBGENTER("NmsMsgfProcNbtReq\n");

try {	
	// get the opcode
	Opcode = (NMS_OPCODE_MASK & *(pTmp + 2)) >> 3;

#ifdef JIM
	{
	 BYTE	TransId = *pTmp;
	 ASSERT(TransId == 0x80);
	}
#endif
		
	/*
	* make pTmp point to the Question Section. All name request
	* packets have a name header of standard size (RFC 1002) at the top
	*/
	pTmp += NAME_HEADER_SIZE;

	/*
	 * Extract the name ind store in Name. GetName will update pTmp to
	 * point just beyond  the name in the question section
	*/
	pTmp2 = pTmp;	/*save pTmp so that when GetName returns we can
			 * determine the length of the question name section
		         */

	GetName(
		&pTmp,
		Name,
		&NameLen
	       );

	QuesNamSecLen = (ULONG) (pTmp - pTmp2);

	pTmp += RFC_LEN_QTYP_N_QCLS; /* skip past the ques. type and ques.
				      * class fields  We don't need to examine
				      * these.  The question type field
		      		      * will always be NB and question class
				      *field will always be INTERNET
		    		      */
#ifdef  TESTWITHUB
	//
	// Check if the broadcast bit is set. If yes, drop the pkt.
	//
	if (*(pMsg + 3) & 0x10)
	{
		DBGPRINT2(SPEC, "Broadcast pkt BEING DROPPED; name is (%s). Opcode is (%d)\n", Name, Opcode);
#if 0
		printf("Broadcast pkt BEING DROPPED; name is (%s). Opcode is (%d)\n", Name, Opcode);
#endif
		ECommFreeBuff(pMsg);		
		ECommEndDlg(pDlgHdl);
		return(WINS_SUCCESS);
	}
#endif

	//
	// Let us set the flag to TRUE.  If any of the following called
	// functions raises an exception, then it is a requirement that
	// it does so only after freeing the buffer (i.e. it must catch
	// all exceptions, free the buffer and then reraise the
	// exception - if it wants)
	//
	fBuffFreed = TRUE;

	//
	// If the 16th character is a 1B switch it with the 1st character.
	// This is done to support Browsing.  Browsers want a list of all
	// names with 16th character being 1B.  Putting 1B as the
	// 1st character enables WINS to find all 1B names quickly.
	//
	NMSMSGF_MODIFY_NAME_IF_REQD_M(Name);

	/*
	 * Switch on the type of request as determined by the Opcode
	*/
	switch(Opcode)
	{
	
	   /*
	    name registration and refresh are handled the same way
	   */
	   case(NMSMSGF_E_NAM_REF):		
	   case(NMSMSGF_E_NAM_REF_UB):		
		DBGPRINT0(FLOW, "It is a name refresh request\n");

	   case(NMSMSGF_E_NAM_REG): 	/* fall through */
	   case(NMSMSGF_E_MULTIH_REG): 	/* fall through */

		/*
		* Get the flag indicating whether the request is a group
		* registration or a  unique name registration.  The IP
		* address(es) is (are) also retrieved
		*/
		GetOtherInfo(
			   Opcode,
			   pTmp,
			   QuesNamSecLen,
			   &fGrp,
			   &CntAdd,
			   &NodeTyp_e
			 );		
		//
		// If it is not a group or a multihomed registration or
		//
		if (!fGrp  && (Opcode != NMSMSGF_E_MULTIH_REG))
		{
			/*
			 * Register the unique name
			*/
			NmsNmhNamRegInd(
				pDlgHdl,
				Name,
				NameLen,
				CntAdd.Add,
				(BYTE)NodeTyp_e,
				pMsg,
				MsgLen,
				QuesNamSecLen,
				Opcode == NMSMSGF_E_NAM_REG ? FALSE : TRUE,
				NMSDB_ENTRY_IS_NOT_STATIC,	
				FALSE    //is it admin flag ?
					);
		}
		else  //it is a group or is mutihomed
		{
			/*
			 * Register the group name
			*/
			NmsNmhNamRegGrp(
				 pDlgHdl,
				 Name,
				 NameLen,
				 &CntAdd,
				 (BYTE)NodeTyp_e,
				 pMsg,
				 MsgLen,
				 QuesNamSecLen,
				 fGrp ? NMSDB_NORM_GRP_ENTRY : (Opcode == NMSMSGF_E_MULTIH_REG) ? NMSDB_MULTIHOMED_ENTRY : NMSDB_NORM_GRP_ENTRY,
                         //passing NMSDB_NORM_GRP_ENTRY for spec. grp is fine
                         //see NmsNmhNamRegGrp()
				 Opcode == NMSMSGF_E_NAM_REG ? FALSE : TRUE,
				 NMSDB_ENTRY_IS_NOT_STATIC,	
				 FALSE    //is it admin ?
				       );
		}

		break;

	   case(NMSMSGF_E_NAM_QUERY):

#if 0
		Address.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
		Address.AddLen    = sizeof(COMM_IP_ADD_T);
		COMM_GET_IPADD_M(pDlgHdl, &Address.Add.IPAdd);
#endif

#if 0
		//
		// NOTE: Multiple NBT threads could be doing this simultaneously
		//
		//  This is the best I can do without a critical section
		//
FUTURES("The count may not be correct when retrieved by an RPC thread")
		WinsIntfStat.Counters.NoOfQueries++;
#endif
		/*
		  Query the name
		*/
		NmsNmhNamQuery(
				pDlgHdl,
				Name,
				NameLen,
				pMsg,
				MsgLen,
				QuesNamSecLen,
				FALSE,		// is it admin flag
				NULL		//should be non NULL only in
						//an RPC thread
			      );
		break;
	

	   case(NMSMSGF_E_NAM_REL):

		GetOtherInfo(
			   NMSMSGF_E_NAM_REL,
			   pTmp,
			   QuesNamSecLen,
			   &fGrp,
			   &CntAdd,
			   &NodeTyp_e
			 );		

		
		//
		// We should pass down to NmsNmhNamRel function the
		// address of the client requesting name release, not
		// the address passed in the RFC pkt.  The address
		// will be used by NmsDbRelRow to check if the client
		// is authorized to release the record
		//
		Address.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
		Address.AddLen    = sizeof(COMM_IP_ADD_T);
		COMM_GET_IPADD_M(pDlgHdl, &Address.Add.IPAdd);

		/*
		 * Release the name
		*/
		NmsNmhNamRel(
				pDlgHdl,
				Name,
				NameLen,
				&Address,
				fGrp,
				pMsg,
				MsgLen,
				QuesNamSecLen,
				FALSE    //is it admin flag ?
			    );
		break;

	   default:

		fBuffFreed = FALSE;
		DBGPRINT1(EXC, "NmsMsgfProcNbtReq: Invalid Opcode\n", Opcode);
		WINS_RAISE_EXC_M(WINS_EXC_PKT_FORMAT_ERR);
		WINSEVT_LOG_M(Opcode, WINS_EVT_INVALID_OPCODE);

		break;
	}
	
  }
except(EXCEPTION_EXECUTE_HANDLER)  {
	DBGPRINTEXC("NmsMsgfProcNbtReq");

        if (GetExceptionCode() == WINS_EXC_NBT_ERR)
        {
                WINS_RERAISE_EXC_M();
        }

	//
	//  Free the message buffer if not already freed, delete the
	//  dialogue if it is a UDP dialogue.
	//	
	if (!fBuffFreed)
	{
		ECommFreeBuff(pMsg);		
		ECommEndDlg(pDlgHdl);
	}
   }


	DBGLEAVE("NmsMsgfProcNbtReq\n");
        return(WINS_SUCCESS);	
}


VOID
GetName(
	IN  OUT LPBYTE    *ppName,
	IN  OUT LPBYTE 	  pName,
	OUT LPDWORD   pNameLen
	)

/*++

Routine Description:

	This function is called to retrieve the name from the name
	request packet.

Arguments:

	ppName   -- address of ptr to question section in datagram received
	pName	 -- Address of array to hold the name. It is assumed that this is
                atleast NMSMSGF_RFC_MAX_NAM_LEN long.
	pNameLen -- address of variable to hold length of name

Externals Used:
	None

Called by:
	NmsNmhProcNbtReq	

Comments:
	None
	
Return Value:

	None
--*/

{

   INT	  HighTwoBits;  	//First two bits of Question Name section
   INT	  Length;      		//length of label  in Question Name section
   BYTE	  ch;
   LPBYTE pNmInPkt = *ppName;
   INT    inLen   = NMSMSGF_RFC_MAX_NAM_LEN;  // Store the length of the name.


   *pNameLen = 0;

   /*
	Get the high two bits of the first byte of the Question_NAME
	section.  The bits have to be 00.  If they are not, something
	is really wrong.
   */

   if ((HighTwoBits = (NAME_FORMAT_MASK & *pNmInPkt)) != 0)
   {
       goto BadFormat;
   }

   /*
   *	Get the length of the label. Length, extracted this way, is
   *    guranteed to be <= 63.
   */
   Length = LENGTH_MASK & *pNmInPkt;


   pNmInPkt++;	//increment past the length byte


   /*
    *  Decode the first label of the name (the netbios name without the
    *   scope).
    */

   while(Length > 0 )
   {
       ch = *pNmInPkt++ - 'A';
	*pName++  = (ch << 4) | (*pNmInPkt++ - 'A');
	(*pNameLen)++;
	Length -= 2;
   }	

   inLen -= Length;

  /*
     Extract the netbios scope if present
	The netbios scope is not in encoded form
  */
  while(TRUE)
  {
        /*
        * if length byte is not 0, there is a netbios scope.
	* We make sure that if the packet is ill-formed (i.e. the
        * length of the name (including the length bytes) is > 255, we raise
	* an exception. Since *pNameLen is counting the number of bytes
	* in the name that we are forming, we need to compare it with
	* (255 - 16) = 239 since the first 32 bytes of the netbios name
	* map to 16 bytes of our internal name.
        */
   	if (*pNmInPkt != 0)
   	{
		if (*pNameLen > MAX_SIZE_INTERNAL_NAME)
		{
            goto BadFormat;
		}

        if ( --inLen <= 0) {
            goto BadFormat;
        }
	        *pName++ = '.';
		(*pNameLen)++;
   		Length = LENGTH_MASK & *pNmInPkt;

        // check that the we have enough space remaining in the input buffer.
        //
        if ( (inLen -= Length) <= 0 ) {
            goto BadFormat;
        }

		++pNmInPkt;  	//increment past length byte

   		while(Length-- != 0)
        	{
			*pName++ = *pNmInPkt++;
			(*pNameLen)++;
   		}	
   	}
	else
	{
		++pNmInPkt;  	//increment past end  byte (00)
		break;
	}
   }

    if (--inLen >= 0) {
        *pName++ = 0;   /* EOS	*/
    } else {
        goto BadFormat;
    }

   (*pNameLen)++;   //include 0 in the name's length so that it is stored
		    //in the db.  Check out FormatName too since it expects
		    //the length to include this 0

   *ppName  = pNmInPkt; //init the ppName ptr to point just past the name

   return;

BadFormat:
   // log error and raise an exception
   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_PKT_FORMAT_ERR);
   WINS_RAISE_EXC_M(WINS_EXC_PKT_FORMAT_ERR);

   return;
}




STATUS
GetOtherInfo(
	NMSMSGF_NAM_REQ_TYP_E 	   Opcode_e,
	IN LPBYTE		   pRR,	   /*point to the RR_NAME section in the
				   	    *name registration packet
					    */
	IN   INT	           QuesNamSecLen, /*size of Ques name section*/
	OUT  LPBOOL		   pfGrp,  /*flag -- unique/group entry	*/
	OUT  PNMSMSGF_CNT_ADD_T    pCntAdd, /*Counted address array*/
	OUT  PNMSMSGF_NODE_TYP_E   pNodeTyp_e
	)

/*++

Routine Description:
	The function is called to retrieve information other than the
	the name from the pkt

Arguments:
	pRR  	      - address of RR_NAME section in the request packet
	QuesNamSecLen - length of the question names section in the request pkt
	pfGrp	      - TRUE if it is a group registration request
	pAddress      - Address contained in the request
        NodeTyp_e     - Type of node doing the registeration (P, B, M)


Externals Used:
	None

Called by:
	NmsMsgfProcNbtReq

Comments:
	None
	
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{
	INT	HighTwoBits;
	BYTE    *pTmp = pRR;
	LONG UNALIGNED	*pTmpL;


	/*
	 * RR_NAME section should contain a pointer to the Question Section. So
	 * we could skip it.  We are not, however,  just in case another
	 * implementation of NBT does not follow the recommendations of the
	 * RFC and passes us the full name in RR_NAME section
	*/
   	if ((HighTwoBits = NAME_FORMAT_MASK & *pTmp) == 0)
   	{
	
		/*
		 * skip the name (same size as in question_name section) and the
		 * RR_TYPE, RR_CLASS, TTL and RDLENGTH fields
		*/
		pTmp += QuesNamSecLen + RFC_LEN_RRTYP_N_RRCLS +
				RFC_LEN_TTL + RFC_LEN_RDLEN;

   	}
	else
	{
	  	/*
		 * skip the pointer bytes (2), RR_TYPE, RR_CLASS, TTL, and
		 * RDLENGTH flds
	        */
	  	pTmp += RFC_LEN_RRPTR + RFC_LEN_RRTYP_N_RRCLS + RFC_LEN_TTL
		  	  + RFC_LEN_RDLEN;
	}

	
	/*
	 * RFC 1002 - page 12 and 14.
	 *
	 * First 16 buts of the RData section (right after the RDLEN section
	 * has its top most bit set to 0 if the registration is for a group
	*/
	*pfGrp = GROUP_BIT_MASK & *pTmp;  // get the group bit

	/*
	 *Next two MS bits indicate the node type
	*/
	*pNodeTyp_e = (NODE_TYPE_MASK & *pTmp) >> SHIFT_NODE_BITS;
	
	/*
	* Get the IP address.  IP address is 2 bytes away,
	*/
	pTmp += 2;

NONPORT("Port when porting to NON TCP/IP protocols")

	pCntAdd->NoOfAdds = 1;

	/*
 	*  Use ntohl to get the address which is a long in the correct
 	*  byte order
	*/
	pTmpL	= (LPLONG)pTmp;
	pCntAdd->Add[0].Add.IPAdd = ntohl(*pTmpL);
	pCntAdd->Add[0].AddTyp_e  = COMM_ADD_E_TCPUDPIP;
	pCntAdd->Add[0].AddLen    = sizeof(COMM_IP_ADD_T);

	if (Opcode_e == NMSMSGF_E_MULTIH_REG)
	{
		USHORT   RdLen;
		USHORT   NoOfAddsLeft;

		//
		// We are going to register a group of addresses
		//

		//
		// Extract the RDLEN (decrement the pointer)
		//
		RdLen = (USHORT)((*(pTmp - RFC_LEN_RDLEN_N_NBF) << 8) +
				*(pTmp - RFC_LEN_RDLEN_N_NBF + 1));

		NoOfAddsLeft = ((RdLen - RFC_LEN_NBFLAGS)/COMM_IP_ADD_SIZE) - 1;
		if (NoOfAddsLeft >= NMSMSGF_MAX_NO_MULTIH_ADDS)
		{
			DBGPRINT0(FLOW, "The packet for multi-homed registration has more than the max. number of ip addresses supported for a multi-homed client. \n");
			
			WINSEVT_LOG_M(
					NoOfAddsLeft,
					WINS_EVT_LIMIT_MULTIH_ADD_REACHED
				     );
			NoOfAddsLeft = NMSMSGF_MAX_NO_MULTIH_ADDS - 1;
		}

		//
		// Get the remaining addresses
		//
		pTmp += RFC_LEN_NBADD;
		for(
				;  //null first expr
			pCntAdd->NoOfAdds < (DWORD)(NoOfAddsLeft + 1);
			pTmp += RFC_LEN_NBADD, pCntAdd->NoOfAdds++
		   )
		{
			
		  pCntAdd->Add[pCntAdd->NoOfAdds].Add.IPAdd =
						ntohl(*((LPLONG)pTmp));
		  pCntAdd->Add[pCntAdd->NoOfAdds].AddTyp_e  =
						COMM_ADD_E_TCPUDPIP;
		  pCntAdd->Add[pCntAdd->NoOfAdds].AddLen    =
						sizeof(COMM_IP_ADD_T);
		}
	}

	return(WINS_SUCCESS);
}





STATUS
NmsMsgfFrmNamRspMsg(
   PCOMM_HDL_T			pDlgHdl,
   NMSMSGF_NAM_REQ_TYP_E   	NamRspTyp_e,
   PNMSMSGF_RSP_INFO_T		pRspInfo
  	)

/*++

Routine Description:
	This function is called to format a response message for sending
	to an nbt node.

Arguments:
	pDlgHdl	     -- Dlg Handle
	NameRspTye_e -- Type of response message (registration, query, release)
			that needs to be formatted.
	pRspInfo     -- Response Info.

Externals Used:
	None

Called by:
	NmsNmhNamRegInd, NmsNmhNamRegGrp, NmsNmhNamRel, NmsNmhNamQuery

Comments:
	None
	
Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{
	STATUS	RetStat = WINS_SUCCESS;
   	LPBYTE 	pReqBuff  = pRspInfo->pMsg;
   	LPBYTE 	pNewBuff  = pReqBuff;

	//
	// Switch on type of response
	//
	switch(NamRspTyp_e)
	{
	  	case(NMSMSGF_E_NAM_REG):  /* fall through */
	  	case(NMSMSGF_E_NAM_REF):
	  	case(NMSMSGF_E_NAM_REF_UB):

		   (VOID)FrmNamRegRsp(
			pDlgHdl,
			pRspInfo
			       );
		    break;

		case(NMSMSGF_E_NAM_QUERY):

#if 0
		   FrmNamQueryRsp(
			pDlgHdl,
			pRspInfo
				 );
#endif
   		   (VOID)FormatQueryRspBuff(
				pNewBuff,   //ptr to buffer to fill
				pReqBuff,   // ptr to req buffer
				pRspInfo,
				FALSE   //no danger of truncation since
				        //we never send more than 25 ip add
					//in the response
				   );

		    break;

		case(NMSMSGF_E_NAM_REL):

		   (VOID)FrmNamRelRsp(
				pDlgHdl,	
				pRspInfo
			      	     );

		    break;

		default:

		    // error
		    RetStat = WINS_FAILURE;
		    break;
	}

	return(RetStat);
}


STATUS
FrmNamRegRsp(
  PCOMM_HDL_T 		pDlgHdl,
  PNMSMSGF_RSP_INFO_T	pRspInfo
)

/*++

Routine Description:
	This function formats a positive or a negative name registration
	response.

Arguments:

   pDlgHdl  -- Dialogue Handle
   pRspInfo -- Information used to format the response pkt

Externals Used:
	None

Called by:
	NmsMsgfFrmNamRspMsg
Comments:
	None
	
Return Value:

   Success status codes --
   Error status codes  --

--*/

{

   LPBYTE 	pTmpB = pRspInfo->pMsg + 2;
   BYTE         SavedByte;


   /*
	We will use the same buffer that carried the request.  Simple
	moves will be done.  These should be faster than doing
	all the construction from scratch
   */


   /*
     Set the the Transaction Id, Opcode, NMFlags and Rcode field
   */
   *pTmpB++  =  RFC_NAM_REG_RSP_OPC;
   *pTmpB++  =  RFC_NAM_REG_RSP_4THB + pRspInfo->Rcode_e;


   /*
     Set the QD count and the AN count fields
   */
   *pTmpB++  =  RFC_NAM_REG_RSP_QDCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_QDCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ANCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ANCNT_2NDB;

   /*
    Set the NSCOUNT and ARCOUNT fields
   */
   *pTmpB++  =  RFC_NAM_REG_RSP_NSCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_NSCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ARCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ARCNT_2NDB;

   /*
	Increment the pointer past the Question_Class Section
	RR_NAME, RR_TYPE, and RR_CLASS of response are same as
	Question_Name, Question_Type, and Question_Class of
	nbt request.
   */

   pTmpB +=  pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

   SavedByte = *pTmpB & NAME_FORMAT_MASK; //save the format bits of RR section

CHECK("In case of a negative response, does it matter what I put in the TTL")
CHECK("field. It shouldn't matter -- RFC is silent about this")
   //
   // put the TTL in the response
   //
   *pTmpB++ = (BYTE)(pRspInfo->RefreshInterval >> 24);
   *pTmpB++ = (BYTE)((pRspInfo->RefreshInterval >> 16) & 0xFF);
   *pTmpB++ = (BYTE)((pRspInfo->RefreshInterval >> 8) & 0xFF);
   *pTmpB++ = (BYTE)(pRspInfo->RefreshInterval & 0xFF);

   /*
	Move memory that is after RR_NAME into appropriate place

	First we check what form the name in the RR_NAME section is.
	It should be in pointer form (pointer to the QuesNamSec) but
	could be in the regular form.
   */

   if (SavedByte == 0)
   {
	DWORD RRSecLen = pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

	// RR_NAME is as big as the Question_name section.
   	WINSMSC_MOVE_MEMORY_M(
		pTmpB,
		pTmpB + RRSecLen,
		RFC_LEN_RDLEN_N_NBF_N_NBA
		     );

   }
   else
   {
	// RR_NAME is a ptr so it takes up 2 bytes.
   	WINSMSC_MOVE_MEMORY_M(
		      pTmpB,
		      pTmpB + RFC_LEN_RRPTR + RFC_LEN_RRTYP_N_RRCLS,
		      RFC_LEN_RDLEN_N_NBF_N_NBA
		     );
   }

   pTmpB 	    +=   RFC_LEN_RDLEN_N_NBF_N_NBA;
   pRspInfo->MsgLen =    (ULONG) (pTmpB - (LPBYTE)pRspInfo->pMsg);

   return(WINS_SUCCESS);
}



STATUS
FrmNamRelRsp(
  PCOMM_HDL_T 		   pDlgHdl,
  PNMSMSGF_RSP_INFO_T      pRspInfo
)

/*++

Routine Description:

  This function formats a positive or negative name query response.
  The request buffer is made use of for the response.

Arguments:

   pDlgHdl  -- Dialogue Handle
   pRspInfo -- Response Info

Externals Used:
	None

Called by:
	NmsMsgfFrmRspMsg()
Comments:
	None
	
Return Value:

   Success status codes --
   Error status codes  --

--*/

{
   LPBYTE 	pTmpB = pRspInfo->pMsg + 2;
   //LPBYTE 	pTmpB2;


   /*
	We will use the same buffer that carried the request.  Simple
	moves will be done.  These should be faster than doing
	all the construction from scratch
   */

   /*
     Set the the Transaction Id, Opcode, NMFlags and Rcode field
   */
   *pTmpB++  =  RFC_NAM_REL_RSP_OPC;
   *pTmpB++  =  RFC_NAM_REL_RSP_4THB + pRspInfo->Rcode_e;


   /*
     Set the QD count and the AN count fields
   */
   *pTmpB++  =  RFC_NAM_REL_RSP_QDCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_QDCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ANCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ANCNT_2NDB;

   /*
    Set the NSCOUNT and ARCOUNT fields
   */
   *pTmpB++  =  RFC_NAM_REL_RSP_NSCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_NSCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ARCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ARCNT_2NDB;


   /*
	Increment the pointer past the Question_Class Section
	RR_NAME, RR_TYPE, and RR_CLASS of response are same as
	Question_Name, Question_Type, and Question_Class of
	nbt request.
   */
   pTmpB += pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

   if ((*pTmpB & NAME_FORMAT_MASK) == 0)
   {
	DWORD RRSecLen = pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

	// RR_NAME is as big as the Question_name section.
   	WINSMSC_MOVE_MEMORY_M(
		pTmpB,
		pTmpB + RRSecLen,
		RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA
		     );
  }	
  else
  {
	// RR_NAME is a ptr so it takes up 2 bytes. 2 + 4 = 6	
   	WINSMSC_MOVE_MEMORY_M(
		pTmpB,
		pTmpB + RFC_LEN_RRPTR + RFC_LEN_RRTYP_N_RRCLS,
		RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA
		     );
   }
   pTmpB += RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA;

#if 0
// not needed. We always return the NBFLAGS and Address of the requestor
   pTmpB2 =  pTmpB - RFC_LEN_NBFLAGS - RFC_LEN_NBADD;

   //
   // Set the NBFLAGS field
   //
   if (pRspInfo->EntTyp == NMSDB_SPEC_GRP_ENTRY)
   {
   	*pTmpB2++     = 0x80;
   	*pTmpB2++     = 0x00;
   }
   else
   {
	   COMM_IP_ADD_T IPAdd =  pRspInfo->pNodeAdds->Mem[0].Add.Add.IPAdd;
           if (pRspInfo->EntTyp == NMSDB_NORM_GRP_ENTRY)
	   {
   		*pTmpB2++     = 0x80;
	   }
	   else  //it is a unique entry
	   {
   	   	*pTmpB2++     = pRspInfo->NodeTyp_e << NMSDB_SHIFT_NODE_TYP;
	   }
   	   *pTmpB2++     = 0x00;

	   *pTmpB2++ = (BYTE)(IPAdd >> 24);        //MSB
	   *pTmpB2++ = (BYTE)((IPAdd >> 16) % 256);
	   *pTmpB2++ = (BYTE)((IPAdd >> 8) % 256);
	   *pTmpB2++ = (BYTE)(IPAdd % 256); 	   //LSB
	
   }
#endif

   pRspInfo->MsgLen = (ULONG) (pTmpB  - (LPBYTE)pRspInfo->pMsg);
   return(WINS_SUCCESS);

}


#if 0

STATUS
FrmNamQueryRsp(
  IN  PCOMM_HDL_T 	   	pDlgHdl,
  IN  PNMSMSGF_RSP_INFO_T      	pRspInfo
)

/*++

Routine Description:
	This function formats a name query response

Arguments:
   pDlgHdl -- Dialogue Handle
   pRspInfo -- Response Info

Externals Used:
	None

Called by:
	NmsNmhFrmRspMsg()

Comments:
	None
	
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Comments:  Not used currently.  Will make use of it when we have the
	   potential to send more data than can fit in a query response
	   datagram

--*/

{
   BOOL		fTrunc    = FALSE;
   LPBYTE 	pReqBuff  = pRspInfo->pMsg;
   LPBYTE 	pNewBuff  = pReqBuff;
   STATUS	RetStat   = WINS_SUCCESS;

FUTURES("Currently, since we never send more than 25 addresses, there is no")
FUTURES(" danger of overflowing the buffer.  In the future, if we ever change")
FUTURES("that, we should unconditinalize the code below, compile it and check")
FUTURES("it out.  It needs to be modified.  The computation of the size")
FUTURES("is faulty")
   DWORD	RspLen    = 0;
   BYTE		*pTmpB	  = NULL;




   /*
	If this is to be sent as a datagram we will use the same buffer
        that carries the request.

	If it is to be sent on a TCP connection
	we will still use the same buffer if it is a negative name query
	response. If, however, a positive name query response has to be
	sent, we will allocate a buffer storing the response

   */


   if ((!COMM_IS_TCP_MSG_M(pDlgHdl))
   {

	/*
	In the following there is no need to check fGrp flag but
	let us do it for insurance
	*/
	if ((Rcode_e == NMSMSGF_E_SUCCESS) && (NodeAdds.fGrp))
	{
		/*
	  	Check if we need to set the truncation bit in the
	  	datagram.

	  	To do the above,

		Compute the size of the buffer required to house all
		the information and compare with the datagram size
		*/

		if (
			(
			  RspLen = pDlgHdl->MsgLen + RFC_LEN_TTL_N_RDLEN +
				(NodeAdds.NoOfMems * sizeof(COMM_IP_ADD_T))
			)
				> COMM_DATAGRAM_SIZE
		   )
		{
			fTrunc = TRUE;
		}
        }
   }
   else // TCP message with Rcode_e of success
   {

	if (
		(
		  RspLen = *pMsgLen + RFC_LEN_TTL_N_RDLEN +
				(NodeAdds.NoOfMems * sizeof(COMM_IP_ADD))
		)
				> COMM_DATAGRAM_SIZE
	    )
	{
		WinsMscAlloc(RspLen, &pNewBuff);
		if (pNewBuff == NULL)
		{
		   return(WINS_FAILURE);
		}
	}



	*ppMsg = pNewBuff;
	Status = FormatQueryRspBuff(
			pNewBuff,   //ptr to buffer to fill
			pReqBuff,   // ptr to req buffer
			pRspInfo,
			ftrunc
				   );

	WinsMscHeapFree(
			CommUdpBuffHeapHdl,
			pReqBuff
		       ); // get rid of the old buffer


	return(Status);

   }

   RetStat = FormatQueryRspBuff(
			pNewBuff,   //ptr to buffer to fill
			pReqBuff,   // ptr to req buffer
			pRspInfo,
			fTrunc
				   );

   return(RetStat);

}
#endif


STATUS
FormatQueryRspBuff(
   IN  LPBYTE 		   pDest,
   IN  LPBYTE 		   pSrc,
   IN  PNMSMSGF_RSP_INFO_T pRspInfo,
   IN  BOOL		   fTrunc
  	)

/*++

Routine Description:
	This function formats the response for a name query request
	
Arguments:
	pDest - Buffer to contain the formatted response
	pSrc  - Buffer containing the formatted request
	pRspInfo - Response Information
	fTrunc   - whether the response packet is to have the truncation bit set

Externals Used:
	None

Called by:
	FrmNamQueryRsp()

Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE
--*/

{

        DWORD   no;
	LPBYTE  pDestB	  = pDest;
	DWORD	LenOfAdds;
	DWORD	IPAdd;

	*pDestB++ = *pSrc;
	*pDestB++ = *(pSrc + 1);

   	/*
     	The Transaction Id, Opcode, NMFlags and Rcode field
   	*/
   	*pDestB++ =
		( *(pSrc + 2) |
		      ((fTrunc == FALSE)
		           ? RFC_NAM_QUERY_RSP_OPC_NO_T
	                   : RFC_NAM_QUERY_RSP_OPC_T)
		);

	*pDestB++ = RFC_NAM_QUERY_RSP_4THB + pRspInfo->Rcode_e;

   	/*
     	 *	Set the QD count and the AN count fields
   	*/
	*pDestB++  =  RFC_NAM_QUERY_RSP_QDCNT_1STB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_QDCNT_2NDB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_ANCNT_1STB;

   	*pDestB++  =  (pRspInfo->Rcode_e == NMSMSGF_E_SUCCESS) ?
			RFC_NAM_QUERY_POS_RSP_ANCNT_2NDB
			: RFC_NAM_QUERY_NEG_RSP_ANCNT_2NDB;

   	/*
    	Set the NSCOUNT and ARCOUNT fields
   	*/
	*pDestB++  =  RFC_NAM_QUERY_RSP_NSCNT_1STB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_NSCNT_2NDB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_ARCNT_1STB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_ARCNT_2NDB;
	
        pSrc  += pDestB - pDest;

   	/*
	Increment the counter past the Question_Name Section (which is known
	as the RR_NAME section here).

	Use MoveMemory here instead of Copy Memory.  Move Memory handles
	overlapped copies which will happen if pDest and pSrc are
	pointing to the same buffer
   	*/

   	WINSMSC_MOVE_MEMORY_M(
		pDestB,
		pSrc,
		pRspInfo->QuesNamSecLen
		     );

	pDestB +=  pRspInfo->QuesNamSecLen;

	if (pRspInfo->Rcode_e == NMSMSGF_E_SUCCESS)
	{
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_NB_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_NB_2NDB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_IN_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_IN_2NDB;  //RFC 1002 -- page 22
	}
	else
	{
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_NB_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_NB_2NDB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_IN_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_IN_2NDB;  //RFC 1002 -- page 22
	}

	if (!fTrunc)
        {

	  if (pRspInfo->Rcode_e == NMSMSGF_E_SUCCESS)
	  {

CHECK("In case of a negative response, does it matter what I put in the TTL")
CHECK("field. It shouldn't matter -- RFC is silent about this")
	  	/*
	    	  Put 0 in the TTL field. TTL field will not be looked at by the
	    	  Client.
	        */
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;

		//
		// Get the RDLENGTH value
		//
	        LenOfAdds = pRspInfo->pNodeAdds->NoOfMems *
				(RFC_LEN_NBFLAGS  + sizeof(COMM_IP_ADD_T));

		*pDestB++ = (BYTE)(LenOfAdds >> 8);    //MSB
		*pDestB++ = (BYTE)(LenOfAdds % 256);   //LSB

		//
		// Put the NBFLAGS here
		//
		if (
			(pRspInfo->EntTyp != NMSDB_UNIQUE_ENTRY)
		   )
		{	
                        BYTE Nbflags;
                        DWORD StartIndex;
                        if ( pRspInfo->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                        {
			        Nbflags =
                                   pRspInfo->NodeTyp_e << NMSDB_SHIFT_NODE_TYP;
                        }
                        else
                        {
                                //
                                // it is a group (normal/special)
                                //
                                Nbflags = 0x80;
                        }
                        //
                        // It is a group (normal or special) or a multihomed
                        // entry
                        //
                        if (pRspInfo->pNodeAdds->NoOfMems &&
                            WinsCnf.fRandomize1CList &&
                            NMSDB_SPEC_GRP_ENTRY == pRspInfo->EntTyp ) {
                            StartIndex = rand() % pRspInfo->pNodeAdds->NoOfMems;;
                        } else {
                            StartIndex = 0;
                        }
                        for (no = StartIndex; no < pRspInfo->pNodeAdds->NoOfMems; no++)
                        {

                          *pDestB++ = Nbflags;
                          *pDestB++ = 0x0;
                          IPAdd =   pRspInfo->pNodeAdds->Mem[no].Add.Add.IPAdd;
                              NMSMSGF_INSERT_IPADD_M(pDestB, IPAdd);
                            }
                        for (no = 0; no < StartIndex; no++)
                        {

                          *pDestB++ = Nbflags;
                          *pDestB++ = 0x0;
                          IPAdd =   pRspInfo->pNodeAdds->Mem[no].Add.Add.IPAdd;
                              NMSMSGF_INSERT_IPADD_M(pDestB, IPAdd);
                            }

		}
		else
		{
			//
			// It is a unique entry
			//
			*pDestB++ = pRspInfo->NodeTyp_e << NMSDB_SHIFT_NODE_TYP;
			*pDestB++ = 0x0;
		        IPAdd =   pRspInfo->pNodeAdds->Mem[0].Add.Add.IPAdd;
		        NMSMSGF_INSERT_IPADD_M(pDestB, IPAdd);
		}
	  }
	  else  //this is a negative name query response
	  {
	  	/*
	    	  Put 0 in the TTL field. TTL field will not be looked at by the
	    	  Client.
	        */
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;

		/*
		  Put 0 in the RDLENGTH field since we are not passing any
		  address(es)
		*/
                *pDestB++  = 0;
                *pDestB++  = 0;

	  }
CHECK("When a truncated response is sent to the client, is it ok to not")
CHECK("Send any field after the RR_NAME section.  RFC is silent about this")
CHECK("For now, it is ok, since we will never have a situation where a ")
CHECK("truncated response needs to be sent")

         pRspInfo->MsgLen = (ULONG) (pDestB - pDest);

	}
	else
	{
	  //this is a truncated response (does not have any field after
	  //RR_NAME section
          pRspInfo->MsgLen = (ULONG) (pDestB - pDest);
	}

   return(WINS_SUCCESS);

}


VOID
FormatName(
	IN     LPBYTE pNameToFormat,
	IN     DWORD  NamLen,
	IN OUT LPBYTE *ppFormattedName
	)

/*++

Routine Description:
	This function is called to format a name


Arguments:
	pNameToFormat  -- Name to format
	LengthOfName   -- Length of Name
	pFormattedName -- Name after it has been formatted


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
	Note: This function should be called to format only those names
	       whose length as indicated by NameLen includes the ending
	       0. All names stored in the database are valid.
	
--*/

{
	LPBYTE  pTmpB    = *ppFormattedName;
	DWORD	Length;
	LPBYTE  pSaveAdd = pTmpB;  //save address of length octet

	
FUTURES("take out the check below to improve performance")
	//
	//  If NamLen is more then what is prescribed in RFC 1002,
	//  there is something really wrong.  This calls for raising
	//  an exception
	//
	if (NamLen > RFC_MAX_NAM_LEN)
	{
		WINS_RAISE_EXC_M(WINS_FATAL_ERR);
	}

	pTmpB++;		//skip the length octet.  We will write to
				//it later. We have stored the address in
				//pSaveAdd
	NamLen--;		//decrement Namelen since we always store
				//0 at the end of the name. NameLen includes
				//this extra byte
	for (
		Length = 0;
		(*pNameToFormat != '.') && (NamLen != 0);
		Length += 2, NamLen--
	   )
	{
		*pTmpB++ = 'A' + (*pNameToFormat >> 4);
		*pTmpB++ = 'A' + (*pNameToFormat++ & 0x0F);
	}

	*pSaveAdd = (BYTE)Length;
	
	while(NamLen != 0)
	{

		pNameToFormat++;     //increment past the '.'
		pSaveAdd  = pTmpB++; //save add; skip past length octet
			
		NamLen--;	     //to account for the '.'

		for (
			Length = 0;
			(*pNameToFormat != '.') && (NamLen != 0);
			Length++, NamLen--
	   	    )
		{
			*pTmpB++ = *pNameToFormat++;
		}

FUTURES("take out the check below to improve performance")
		//
		// Make sure there is no weirdness
		//
		if (Length > RFC_MAX_LABEL_LEN)
		{
			WINS_RAISE_EXC_M(WINS_FATAL_ERR);
		}
	
		*pSaveAdd = (BYTE)Length;
		if (NamLen == 0)
		{
			break;   //reached end of name
		}

	}

	*pTmpB++         = EOS;
	*ppFormattedName = pTmpB;
	return;
}
	
VOID
NmsMsgfFrmNamQueryReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen
	)

/*++

Routine Description:

	This function formats a name query request packet

Arguments:
	TransId  	-  Transaction Id. to use
	pMsg    	-  Msg Buffer to format
	pMsgLen 	-  Length of formatted message
	pNameToFormat   -  Name to format
	NameLen		-  Length of Name
	

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	HandleWrkItm in nmschl.c

Side Effects:

Comments:
	None
--*/

{
	LPBYTE   pTmpB = pMsg;

	/*
	 * Put the Transaction Id in
	*/	
	*pTmpB++ = (BYTE)(TransId >> 8);
	*pTmpB++ = (BYTE)(TransId & 0xFF);
	

	*pTmpB++ = RFC_NAM_QUERY_REQ_OPCB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_4THB;
			
	*pTmpB++ = RFC_NAM_QUERY_REQ_QDCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QDCNT_2NDB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ANCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ANCNT_2NDB;

	*pTmpB++ = RFC_NAM_QUERY_REQ_NSCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_NSCNT_2NDB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ARCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ARCNT_2NDB;

	FormatName(pNameToFormat, NameLen, &pTmpB);
	
	*pTmpB++ = RFC_NAM_QUERY_REQ_QTYP_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QTYP_2NDB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QCLS_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QCLS_2NDB;

	*pMsgLen = (ULONG) (pTmpB - pMsg);
	return;	
}


VOID
NmsMsgfFrmNamRelReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	)
/*++

Routine Description:

	This function formats a name release request packet

Arguments:
	TransId  	-  Transaction Id. to use
	pMsg    	-  Msg Buffer to format
	pMsgLen 	-  Length of formatted message
	pNameToFormat   -  Name to format
	NameLen		-  Length of Name
	NodeTyp_e	-  Type of Node
	NodeAdd	        -  IP address of node
	

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	HandleWrkItm() in nmschl.c
Side Effects:

Comments:
	None
--*/
{

	LPBYTE   pTmpB = pMsg;


	/*
	 * Put the Transaction Id in
	*/	
	*pTmpB++ = (BYTE)(TransId >> 8);
	*pTmpB++ = (BYTE)(TransId & 0xFF);

	*pTmpB++ = RFC_NAM_REL_REQ_OPCB;
	*pTmpB++ = RFC_NAM_REL_REQ_4THB;
			
	*pTmpB++ = RFC_NAM_REL_REQ_QDCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_QDCNT_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_ANCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_ANCNT_2NDB;

	*pTmpB++ = RFC_NAM_REL_REQ_NSCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_NSCNT_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_ARCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_ARCNT_2NDB;

	FormatName(pNameToFormat, NameLen, &pTmpB);
	
	*pTmpB++ = RFC_NAM_REL_REQ_QTYP_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_QTYP_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_QCLS_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_QCLS_2NDB;


	*pTmpB++ = 0xC0;
	*pTmpB++ = 0x0C;  //Name is at offset 12 from start of message
	
	*pTmpB++ = RFC_NAM_REL_REQ_RRTYP_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_RRTYP_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_RRCLS_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_RRCLS_2NDB;

	//
	// TTL
	//
	*pTmpB++ =  0;
	*pTmpB++ =  0;
	*pTmpB++ =  0;
	*pTmpB++ =  0;

	//
	// RDLENGTH field
	//
	*pTmpB++ = 0x0;
	*pTmpB++ = 0x6; 	//number of bytes to follow


	//
	// NBFLAGS word  (Bit 15 is Group bit (0); bit 13 and 14 are node
	// type bits, rest of the bits are reserved
	//
	*pTmpB++ = NodeTyp_e << 13;
	*pTmpB++ = 0;

	//
	// Store the IP address. MSB first, LSB last (Network Byte Order)
	//
	NMSMSGF_INSERT_IPADD_M(pTmpB, pNodeAdd->Add.IPAdd);
	
	*pMsgLen = (ULONG) (pTmpB - pMsg);
	return;	
}

VOID
NmsMsgfFrmWACK(
  IN  LPBYTE			pBuff,
  OUT LPDWORD			pBuffLen,
  IN  MSG_T	   		pMsg,
  IN  DWORD			QuesNamSecLen,
  IN  DWORD			WackTtl
	)

/*++

Routine Description:
	This function is called to format a WACK for a name registration
	request.

Arguments:

	Buff	      - Buffer to be filled up with WACK msg fields
	pBuffLen      - size of Buffer
	pMsg          - Request Message received
	QuesNamSecLen - Length of Ques Nam Sec of the request message
	WackTtl       - TTL in msecs

Externals Used:
	None

	
Return Value:

	None

Error Handling:

Called by:
	NmsChlHdlNamReg()

Side Effects:

Comments:
	
--*/

{
	LPBYTE   pTmpB = pBuff;
	LPBYTE   pName = pMsg + NAME_HEADER_SIZE;
	DWORD	 Ttl;

	//
	// Compute the TTL in secs (WackTtl is in msecs)
	//
	Ttl = WackTtl / 1000;
	if (WackTtl % 1000 > 0)
	{
		Ttl++;
	}

	/*
	 * Put the Transaction Id in
	*/	
	*pTmpB++ = *pMsg;
	*pTmpB++ = *(pMsg + 1);
	

	*pTmpB++ = RFC_WACK_OPCB;
	*pTmpB++ = RFC_WACK_4THB;
			
	*pTmpB++ = RFC_WACK_QDCNT_1STB;
	*pTmpB++ = RFC_WACK_QDCNT_2NDB;
	*pTmpB++ = RFC_WACK_ANCNT_1STB;
	*pTmpB++ = RFC_WACK_ANCNT_2NDB;

	*pTmpB++ = RFC_WACK_NSCNT_1STB;
	*pTmpB++ = RFC_WACK_NSCNT_2NDB;
	*pTmpB++ = RFC_WACK_ARCNT_1STB;
	*pTmpB++ = RFC_WACK_ARCNT_2NDB;

	WINSMSC_COPY_MEMORY_M(
			pTmpB,
			pName,
			QuesNamSecLen
		     );
			
	pTmpB  += QuesNamSecLen;

	
	*pTmpB++ = RFC_WACK_RRTYP_1STB;
	*pTmpB++ = RFC_WACK_RRTYP_2NDB;
	*pTmpB++ = RFC_WACK_RRCLS_1STB;
	*pTmpB++ = RFC_WACK_RRCLS_2NDB;

	//
	// TTL
	//
	*pTmpB++ =  (BYTE)(Ttl >> 24);
	*pTmpB++ =  (BYTE)((Ttl >> 16) % 256);
	*pTmpB++ =  (BYTE)((Ttl >> 8) % 256);
	*pTmpB++ =  (BYTE)(Ttl % 256);


	*pTmpB++ = RFC_WACK_RDLENGTH_1STB;
	*pTmpB++ = RFC_WACK_RDLENGTH_2NDB;


	//
	// Store the Opcode and NM_FLAGS field.  These fields can	
	// be retrieved directly from the 3rd and 4th byte of the message
	//
	*pTmpB++ = *(pMsg + 2);
	*pTmpB++ = *(pMsg + 3);

		
	*pBuffLen = (ULONG) (pTmpB - pBuff);

	return;	

}




STATUS
NmsMsgfUfmNamRsp(
	IN  LPBYTE		       pMsg,
	OUT PNMSMSGF_NAM_REQ_TYP_E     pOpcode_e,
	OUT LPDWORD		       pTransId,
	OUT LPBYTE		       pName,
	OUT LPDWORD 		       pNameLen,
	OUT PNMSMSGF_CNT_ADD_T	       pCntAdd,
	//OUT PCOMM_IP_ADD_T	       pIpAdd,
	OUT PNMSMSGF_ERR_CODE_E	       pRcode_e,
    OUT BOOL                       *fGroup
	)

/*++

Routine Description:


	The function unformats the response message

Arguments:
	pMsg      - Msg received (to unformat)	
	pOpcde_e  - Opcode
	pTransId  - Transaction Id.
	pName     - Name
	pNameLen  - Name length returned.
	pIpAdd    - IP address
	pRcode_e  - error type (or success)

Externals Used:
	None

Called by:
	ProcRsp in NmsChl.c


Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

--*/

{
	LPBYTE 		       pTmpB   = pMsg;

	//	
	// get the opcode. Extracts the 4 bits in the 3rd byte (bit 11-bit 14)
	//
	*pOpcode_e = (NMS_OPCODE_MASK & *(pTmpB + 2)) >> 3;

	if (    (*pOpcode_e != NMSMSGF_E_NAM_QUERY) &&	
	        (*pOpcode_e != NMSMSGF_E_NAM_REL)
	   )
	{

		*pOpcode_e = NMSMSGF_E_INV_REQ;
		return(WINS_FAILURE);

	}

	//
	// Get the transaction id
	//
	*pTransId  = (DWORD)((*pTmpB  << 8) + *(pTmpB + 1));
//	*pTransId |= (DWORD)(*(pTmpB + 1));

	//
	// get the Rcode_e
	//
	*pRcode_e =  *(pTmpB + 3) % 16;
	
	
	/*
	* make pTmpB point to the RR Section. All name request/response
	* packets have a name header of standard size (RFC 1002) at the top
	*/

	pTmpB += NAME_HEADER_SIZE;

	/*
	 * Extract the name ind store in Name. GetName will update pTmp to
	 * point just beyond  the name in the RR section
	*/

	GetName(
		&pTmpB,
		pName,
		pNameLen
	       );


	//
	//  If it is a negative name query response we are done
	//
	if (
		(*pOpcode_e == NMSMSGF_E_NAM_QUERY)  &&
	   	(*pRcode_e != NMSMSGF_E_SUCCESS)
	   )
	{
		return(WINS_SUCCESS);
	}
	else
	{
	     DWORD  i;

	     pTmpB += RFC_LEN_RR_N_TTL;
		
	     pCntAdd->NoOfAdds =
			((*pTmpB << 8) + *(pTmpB + 1))/RFC_LEN_NBF_N_NBA;	
	     pTmpB += RFC_LEN_RDLEN;
         // 15th bit in NBFLAGS indicates if this is a group name
         *fGroup = (*pTmpB & 0x80 ? TRUE:FALSE);
         pTmpB += RFC_LEN_NBFLAGS;

	     //
             // we have either positive query response or a response to a
	     // release
             //
	     for (	i = 0;
#if 0
			i < min(pCntAdd->NoOfAdds, NMSMSGF_MAX_NO_MULTIH_ADDS);
#endif
			i < min(pCntAdd->NoOfAdds, NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT);
		        i++
                 )
	     {
	        //
	        // Get the IP address.  This macro will increment pTmpB by
		// 4
	        //
	        NMSMSGF_RETRIEVE_IPADD_M(pTmpB, pCntAdd->Add[i].Add.IPAdd);	
		pCntAdd->Add[i].AddTyp_e = COMM_ADD_E_TCPUDPIP;
		pCntAdd->Add[i].AddLen	 = sizeof(PCOMM_IP_ADD_T);
		pTmpB += RFC_LEN_NBFLAGS;
	    }
	}

	return(WINS_SUCCESS);
}


VOID
NmsMsgfSndNamRsp(
  PCOMM_HDL_T pDlgHdl,
  LPBYTE      pMsg,
  DWORD       MsgLen,
  DWORD       BlockOfReq
 )
{
  NMSMSGF_NAM_REQ_TYP_E Opcode;
  DWORD             NameLen;          //length of name
  DWORD             QuesNamSecLen;    //length of question name section in
                                      //packet
  DWORD             Length;

  LPBYTE  pTmp  = (LPBYTE)pMsg;
  LPBYTE  pTmp2;
  NMSMSGF_RSP_INFO_T RspInfo;
  static DWORD   sNoOfTimes = 0;

  DBGPRINT1(DET, "NmsMsgfSndNamRsp: BlockOfReq is (%d)\n", BlockOfReq);
  // get the opcode
  Opcode = (NMS_OPCODE_MASK & *(pTmp + 2)) >> 3;

  //
  // if it is a release request, we drop the datagram
  //
  if (Opcode == NMSMSGF_E_NAM_REL)
  {
        ECommFreeBuff(pMsg);
        ECommEndDlg(pDlgHdl);
        return;
  }

  /*
  * make pTmp point to the Question Section. All name request
  * packets have a name header of standard size (RFC 1002) at the top
  */
  pTmp += NAME_HEADER_SIZE;
  pTmp2 = pTmp;

  NameLen = LENGTH_MASK & *pTmp;
  pTmp  += NameLen + 1;  //pt pTmp to past the first label
  NameLen /= 2;

  while (TRUE)
  {
   if (*pTmp != 0)
   {
       if (NameLen > MAX_SIZE_INTERNAL_NAME)
       {
          ECommFreeBuff(pMsg);
          ECommEndDlg(pDlgHdl);
          return;
       }
       Length = LENGTH_MASK & *pTmp;
       NameLen += Length + 1;
       pTmp += Length + 1;     //increment past length and label
   }
   else
   {
       pTmp++;
       break;
   }
  }

  QuesNamSecLen = (ULONG) (pTmp - pTmp2);


  RspInfo.RefreshInterval = 300 * BlockOfReq;  // 5 mts
  RspInfo.Rcode_e         = NMSMSGF_E_SUCCESS;
  RspInfo.pMsg            = pMsg;
  RspInfo.MsgLen          = MsgLen;
  RspInfo.QuesNamSecLen   = QuesNamSecLen;

  NmsNmhSndNamRegRsp( pDlgHdl, &RspInfo );


  return;

}


#if 0
STATUS
NmsMsgfFrmNamRegReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	)

/*++

Routine Description:

	This function is called to format a name registration request

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
 		
Side Effects:

Comments:
	This fn gets called when a remote WINS has to be told to
	increment the version number of 	
--*/
{

	//
	// Lets format a name release request since this is exactly the
	// same as a name registration request except for the 2nd and
	// 3rd bytes (counting from 0) which house the opcode and
	// nmflags.  We will set these bytes apprropriately after
	// the following call
	//
	NmsMsgfNamRelReq(
  		TransId,
  		pMsg,
  		pMsgLen,
  		pNameToFormat,
  		NameLen,
  		NodeTyp_e,
  		pNodeAdd
			);


	*(pMsg + 2) = 0x29;
	*(pMsg + 3) = 0x00;

	return;	
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\nmsscv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        nmsscv.c

Abstract:
        This module contains functions that implement the functionality
        associated with scavenging

Functions:
        NmsScvInit,
        ScvThdInitFn,
        DoScavenging
        ReconfigScv

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Apr-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include "winsevt.h"
#include "nms.h"
#include "nmsnmh.h"
#include "winsmsc.h"
#include "winsdbg.h"
#include "winsthd.h"
#include "winscnf.h"
#include "nmsdb.h"
#include "winsque.h"
#include "nmsscv.h"
#include "rpl.h"
#include "rplpull.h"
#include "rplmsgf.h"
#include "comm.h"
#include "winsintf.h"
#include "winstmm.h"




#ifdef WINSDBG
#define  SCV_EVT_NM                TEXT("ScvEvtNm")
#else
#define  SCV_EVT_NM                NULL
#endif

//
// The no. of retries and the time interval (in secs) between each retry
// when trying to establish comm. with a WINS for the purpose of verifying
// old active replicas in the local db
//

#define         VERIFY_NO_OF_RETRIES                0        //0 retries
#define                VERIFY_RETRY_TIME_INTERVAL        30        //30 secs


//
// We get rid of extraneous log files every 3 hours.
//
FUTURES("Use symbols for times - defined in winscnf.h")
#define         ONE_HOUR                   3600
#define         THREE_HOURS                10800
#define         TWENTY_FOUR_HOURS          (3600 * 24)
#define         THREE_DAYS                 (TWENTY_FOUR_HOURS * 3)

#define         PERIOD_OF_LOG_DEL          THREE_HOURS
#define         PERIOD_OF_BACKUP           TWENTY_FOUR_HOURS



#define         LOG_SCV_MUL_OF_REF_INTVL   6

/*
 *        Local Macro Declarations
 */
//
// macro to set the state of a record in an in-memory data structure to
// that specified as an arg. if it has timed out.  We check whether
// CurrTime is greater than pRec Timestamp before doing the other if test
// because these numbers otherwise the subtraction will produce a positive
// number even if current time is older than the timestamp (say the date
// on the pc was changed)
//
#define SET_STATE_IF_REQD_M(pRec, CurrentTime, TimeInterval, State, Cntr)   \
                {                                                           \
                        pRec->fScv = FALSE;                                 \
                        if (CurrentTime >= (time_t)(pRec)->TimeStamp)       \
                        {                                                   \
                                NMSDB_SET_STATE_M(                  \
                                                  (pRec)->Flag,     \
                                                  (State)           \
                                                 );                 \
                                (pRec)->NewTimeStamp = (pRec)->TimeStamp +  \
                                                         TimeInterval;  \
                                        (pRec)->fScv = TRUE;            \
                                        NoOfRecsScv++;                  \
                                        (Cntr)++;                       \
                        }                                               \
                }

#define DO_SCV_EVT_NM                TEXT("WinsDoScvEvt")

/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
*/

HANDLE                NmsScvDoScvEvtHdl;//event signaled to initiate scavenging

//
// The min. version number to start scavenging from (for local records)
//
VERS_NO_T          NmsScvMinScvVersNo;
volatile BOOL      fNmsScvThdOutOfReck;
DWORD              sMcastIntvl;

/*
 *        Local Variable Definitions
*/
FUTURES("Put all these in a structure and allocate it. Initialize sBootTime")
FUTURES("in nms.c")

STATIC time_t      sBootTime;       //Boot Time
STATIC time_t      sLastRefTime;    //Last time we looked for active
                                    // entries
STATIC time_t      sLastVerifyTime; //Last time we looked for replicais
STATIC time_t      sLastFullVerifyTime; //Last time we did full validation
STATIC time_t      sLastTombTime;   //Last time we looked for replica
                                    // tombstones


STATIC BOOL        sfAdminForcedScv;  //set to TRUE if the administrator
                                      //forces scavenging
STATIC time_t      sLastDbNullBackupTime;//Last time we deleted extraneous
                                         //log files
STATIC time_t      sLastDbBackupTime; //Last time we last did full backup
#if MCAST > 0
STATIC time_t      sLastMcastTime; //Last time we last did full backup
#endif

/*
 *        Local Function Prototype Declarations
 */
STATIC
STATUS
DoScavenging(
        PNMSSCV_PARAM_T  pScvParam,
        BOOL             fSignaled,
        LPBOOL           pfResetTimer,
        LPBOOL           pfSpTimeOver
        );
STATIC
DWORD
ScvThdInitFn(
        IN LPVOID pThdParam
        );

STATIC
VOID
ReconfigScv(
 PNMSSCV_PARAM_T  pScvParam
        );

STATIC
VOID
UpdDb(
        IN  PNMSSCV_PARAM_T      pScvParam,
        IN  PRPL_REC_ENTRY_T     pStartBuff,
        IN  DWORD                NoOfRecs,
        IN  DWORD                NoOfRecsToUpd
     );

STATIC
STATUS
VerifyDbData(
        PNMSSCV_PARAM_T       pScvParam,
        time_t                CurrentTime,
        DWORD                 Age,
        BOOL                  fForce,
        BOOL                  fPeriodicCC
        );

STATIC
STATUS
PickWinsToUse(
 IN PCOMM_ADD_T pVerifyWinsAdd,
 IN PCOMM_ADD_T pOwnerWinsAdd,
 IN BOOL        fUseRplPnr,
 OUT LPBOOL     pfNonOwnerPnr,
 OUT LPBOOL     pRplType
 );

STATIC
STATUS
EstablishCommForVerify(
  PCOMM_ADD_T pWinsAdd,
  PCOMM_HDL_T pDlgHdl
);

STATIC
VOID
PullAndUpdateDb(
  PCOMM_HDL_T  pDlgHdl,
  PCOMM_ADD_T  pWinsAdd,
  PRPL_REC_ENTRY_T pRspBuff,
  DWORD        WinsIndex,
  VERS_NO_T    MinVersNo,
  VERS_NO_T    MaxVersNo,
  DWORD        RplType,
  DWORD        NoOfLocalRecs,
  time_t       CurrentTime,
  PNMSSCV_PARAM_T pScvParam,
  BOOL         fNonOwnerPnr,
  LPDWORD      pTotNoOfPulledRecs
 );

STATIC
__inline
VOID
FreeDbMemory(
     LPVOID pStartBuff,
     DWORD  NoOfLocalDbRecs,
     PWINSTHD_TLS_T pTls
 );

STATIC
VOID
ChkConfNUpd(
#if SUPPORT612WINS > 0
        IN  PCOMM_HDL_T       pDlgHdl,
#endif
        IN  PCOMM_ADD_T       pOwnerWinsAdd,
        IN  DWORD             RplType,
        IN  DWORD             OwnerId,
        IN  PRPL_REC_ENTRY_T  *ppLocalDbRecs,
        IN  LPBYTE            pPulledRecs,
        IN  DWORD             *pNoOfLocalDbRecs,
        IN  time_t            CurrentTime,
        IN  DWORD             VerifyTimeIntvl,
        IN  BOOL              fNonOwnerPnr,
        OUT LPDWORD           pNoOfPulledRecs,
        OUT PVERS_NO_T        pMaxVersNo
        );

STATIC
VOID
CompareWithLocalRecs(
        IN     VERS_NO_T        VersNo,
        IN     LPBYTE           pName,
        IN     NMSDB_ENTRY_STATE_E  RecState_e,
        IN OUT PRPL_REC_ENTRY_T *ppLocalDbRecs,
        IN OUT DWORD            *pNoOfLocalRecs,
        IN     time_t           CurrentTime,
        IN     BOOL             fNonOwnerPnr,
        IN OUT DWORD            *pNoOfRecsDel,
        OUT    PNMSSCV_REC_ACTION_E  pRecAction_e
        );
STATIC
VOID
DoBackup(
        PNMSSCV_PARAM_T  pScvParam,
        LPBOOL           pfThdPrNormal
      );

#if MCAST > 0
VOID
DoMcastSend(
   DWORD_PTR CurrentTime,
   DWORD Code,
   DWORD fNow
 );
#endif
//
// function definitions start here
//

VOID
NmsScvInit(
        VOID
        )

/*++

Routine Description:
        This function is called to initialize the scavenger thread

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        //
        // Create the  event handle signaled when scavenging has to be
        // initiated.  This  event is signaled by an RPC thread
        // to start scavenging
        //
        WinsMscCreateEvt(
                          DO_SCV_EVT_NM,
                          FALSE,                //auto-reset
                          &NmsScvDoScvEvtHdl
                        );

        //
        // initialize sLastTombTime (used for determining if we need to look for
        // tombstones of replicas) and sLastVerifyTime to current time.
        // Don't forget RefreshTime
        //
        (void)time(&sBootTime);
        sLastVerifyTime     = //fall through
        sLastTombTime       = //fall through
        sLastFullVerifyTime = //fall through
        sLastRefTime        = sBootTime;


        //
        // Initialize the queue used by the scavenger thread
        //
        WinsQueInit(TEXT("NmsScvEvt"), &QueWinsScvQueHd);


        //
        // Create the Scavenger thread
        //
        WinsThdPool.ScvThds[0].ThdHdl = WinsMscCreateThd(
                          ScvThdInitFn,
                          NULL,
                          &WinsThdPool.ScvThds[0].ThdId
                        );


        //
        // Init WinsThdPool properly
        //
        WinsThdPool.ScvThds[0].fTaken  = TRUE;
        WinsThdPool.ThdCount++;

        return;
}

VOID
GetIntervalToDefSpTime(
  LPDWORD pTimeInt
)

/*++

Routine Description:
  This function finds the time interval in seconds upto the Default Specific
  time.

Arguments:
   OUT pTimeInt - Time Interval in seconds

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

   SYSTEMTIME CurrTime;
   GetSystemTime(&CurrTime);

   //
   // If default time hour is greater then current hour, add 3600
   // for the number of hours it is ahead. Then subtract the the
   // number of minutes and seconds in the current time
   //
   if (WINSCNF_DEF_CC_SP_HR > CurrTime.wHour)
   {
      *pTimeInt = (WINSCNF_DEF_CC_SP_HR - CurrTime.wHour) * 3600;
      *pTimeInt -= ((CurrTime.wMinute * 60) + (CurrTime.wSecond));
   }
   else //default hour is same or less than current hour
   {
       *pTimeInt = (CurrTime.wHour - WINSCNF_DEF_CC_SP_HR) * 3600;
       *pTimeInt += (CurrTime.wMinute * 60) + (CurrTime.wSecond);
   }
   return;

}

DWORD
ScvThdInitFn(
        IN LPVOID pThdParam
        )

/*++

Routine Description:
        This function is the initialization function for the scavenger
        thread

Arguments:
        pThdParam - Not used

Externals Used:
        None

Return Value:

   Success status codes --   should never return
   Error status codes  --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        BOOL            fSignaled = FALSE;
        HANDLE          ThdEvtArr[3];
        DWORD           IndexOfHdlSignaled;
        NMSSCV_PARAM_T  ScvParam;
        DWORD           SleepTime;
        time_t          CurrentTime;
        BOOL            fThdPrNormal;
        DWORD           TimeInt;
        QUE_SCV_REQ_WRK_ITM_T  WrkItm;
        BOOL            fResetTimer = TRUE;
        time_t          AbsTime;
        time_t          LastCC;
        BOOL            fTimerRunning = FALSE;
        BOOL            fSpTimeOver = FALSE;

        UNREFERENCED_PARAMETER(pThdParam);


        ThdEvtArr[0] = NmsTermEvt;
        ThdEvtArr[1] = WinsCnf.CnfChgEvtHdl;
        ThdEvtArr[2] = QueWinsScvQueHd.EvtHdl;
try {
        /*

           Initialize the thread with the database
        */
        NmsDbThdInit(WINS_E_NMSSCV);
        DBGMYNAME("Scavenger Thread");

        //
        // get the scavenging parameters from the configuration structure.
        // Note; There is no need for any synchronization here since
        // we are executing in the main thread (process is initalizing
        // at invocation).
        //
        ScvParam.ScvChunk          = WinsCnf.ScvChunk;
        ScvParam.RefreshInterval   = WinsCnf.RefreshInterval;
        ScvParam.TombstoneInterval = WinsCnf.TombstoneInterval;
        ScvParam.TombstoneTimeout  = WinsCnf.TombstoneTimeout;
        ScvParam.VerifyInterval    = WinsCnf.VerifyInterval;
        ScvParam.PrLvl             = WinsCnf.ScvThdPriorityLvl;

        //
        // Load up the CC parameters
        //
        ScvParam.CC.TimeInt        = WinsCnf.CC.TimeInt;
        ScvParam.CC.fSpTime        = WinsCnf.CC.fSpTime;
        ScvParam.CC.SpTimeInt      = WinsCnf.CC.SpTimeInt;
        ScvParam.CC.MaxRecsAAT     = WinsCnf.CC.MaxRecsAAT;
        ScvParam.CC.fUseRplPnrs    = WinsCnf.CC.fUseRplPnrs;

        sMcastIntvl                = WinsCnf.McastIntvl;

       //
       // if backup path is not NULL, copy it into ScvParam structure
       //
       if (WinsCnf.pBackupDirPath != NULL)
       {
                (VOID)strcpy(ScvParam.BackupDirPath, WinsCnf.pBackupDirPath);
       }
       else
       {
                ScvParam.BackupDirPath[0] = EOS;
       }
       //
       // Use a stack variable WrkItm.  Schedule it with the timer thread
       // if required (will happen only if the CC key is present).
       //
FUTURES("Set two work items - for two timer requests. One to fire off at a")
FUTURES("specific time.  The other one for the time interval")
       WrkItm.Opcode_e = WINSINTF_E_VERIFY_SCV; //verify replicas
       WrkItm.Age      = 0;                     //no matter how recent
       WrkItm.fForce   = TRUE;                  //force verification even if
                                                //we did it recently

LOOP:
  try {

        while (TRUE)
        {
                sfAdminForcedScv = FALSE;

                SleepTime = min(min(sMcastIntvl, ScvParam.RefreshInterval),
                                         PERIOD_OF_LOG_DEL);
                if (fResetTimer)
                {
                    if (fTimerRunning)
                    {
                         //
                         // Delete the old timer request.  This should
                         // deallocate it
                         //
                         DBGPRINT0(SCV, "ScvThdInit: Deleting Timer requests\n");
                         WinsTmmDeleteReqs(WINS_E_NMSSCV);
                         fTimerRunning = FALSE;
                    }
                    //
                    // If the time interval for CC is not MAXULONG, it means
                    // user wants CC to be done. TimeInt will be MAXULONG if
                    // there is no Wins\Paramaters\CC key in the registry
                    //
                    if (ScvParam.CC.TimeInt != MAXULONG)
                    {
                      //
                      // if no specific time was indicated, use default (2 am).
                      //
                      if (!fSpTimeOver)
                      {
                        if (!ScvParam.CC.fSpTime)
                        {
                         //
                         // Get the current hour. Schedule a wakeup at exact
                         // 2 am.
                         //
                         GetIntervalToDefSpTime(&TimeInt);
                        }
                        else
                        {
                          TimeInt = ScvParam.CC.SpTimeInt;
                        }
                      }
                      else
                      {
                         TimeInt = ScvParam.CC.TimeInt;
                      }

                      DBGPRINT1(SCV, "ScvThdInit: TimeInt is (%d)\n", TimeInt);

                      // Insert a timer request.  Let the Timer thread create
                      // a work item for it.
                      //
                      (VOID)time(&AbsTime);
                      if( !fSpTimeOver )
                      {
                          AbsTime += (time_t)TimeInt;
                          LastCC = AbsTime;
                      }
                      else
                      {
                          do
                          {
                              LastCC += (time_t)TimeInt;
                          }
                          while( LastCC <= (AbsTime + WINSCNF_MIN_VALID_INTER_CC_INTVL));
                          AbsTime = LastCC;
                      }
                      WinsTmmInsertEntry(
                           NULL,
                           WINS_E_NMSSCV,
                           QUE_E_CMD_SET_TIMER,
                           FALSE,  //not used presently
                           AbsTime,
                           TimeInt,
                           &QueWinsScvQueHd,
                           &WrkItm,
                           0,
                           NULL
                            );
                      fTimerRunning = TRUE;
                      fResetTimer   = FALSE;
                   }
                }

                //
                // Do a timed wait until signaled for termination
                //
                // Multiply the sleep time by 1000 since WinsMscWaitTimed
                // function expects the time interval in msecs.
                //
#ifdef WINSDBG
                {
                   time_t ltime;
                   (VOID)time(&ltime);
                   DBGPRINT2(SCV, "ScvThdInitFn: Sleeping for (%d) secs.  Last scavenging took = (%d secs)\n", SleepTime, ltime - CurrentTime);
                }
#endif
                WinsMscWaitTimedUntilSignaled(
                                ThdEvtArr,
                                sizeof(ThdEvtArr)/sizeof(HANDLE),
                                &IndexOfHdlSignaled,
                                SleepTime * 1000,
                                &fSignaled
                                        );

                //
                // We can be signaled for termination, configuration change,
                // by the admin to do general or specific scavenging or by
                // the timer thread
                //
                if (fSignaled)
                {
                      if (IndexOfHdlSignaled == 0)
                      {
                              WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                      }
                      else
                      {
                        if (IndexOfHdlSignaled == 1)
                        {
                           ReconfigScv(&ScvParam);

                           //
                           // Reset the timer
                           //
                           fResetTimer = TRUE;
                           continue;
                        }

                        //
                        // else, this must be the signal to initiate scavenging
                        // (by the admin. or the timer thread)
                        //
                        sfAdminForcedScv = TRUE;
                      }
                }

           //
           // Get the current time and check if we need to do scavenging
           //
           (void)time(&CurrentTime);

           if (
                ( (CurrentTime > sLastRefTime)
                        &&
                ((CurrentTime - sLastRefTime) >= (time_t)ScvParam.RefreshInterval))
                                ||
                   sfAdminForcedScv
              )
           {

                //
                // Do scavenging
                //
                NmsDbOpenTables(WINS_E_NMSSCV);
                //DBGPRINT0(ERR, "SCVTHDINITFN: OPENED tables\n");
                (VOID)DoScavenging(&ScvParam, fSignaled, &fResetTimer, &fSpTimeOver);
                NmsDbCloseTables();
                //DBGPRINT0(ERR, "SCVTHDINITFN: CLOSED tables\n");

                fTimerRunning = !fResetTimer;

          }
          //
          // If enough time has expired to warrant a purging of old log
          // files, do it (check done in DoBackup). We don't do this
          // on an admin. trigger since it may take long.
          //
         if (!sfAdminForcedScv)
         {
#if MCAST > 0
                 DoMcastSend(CurrentTime, COMM_MCAST_WINS_UP, FALSE);
#endif

                 fThdPrNormal = TRUE;
                 DoBackup(&ScvParam, &fThdPrNormal);
         }

    }  // end of while (TRUE)
} //end of inner try {..}

except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("ScvThdInit");

        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_SCV_EXC);
 }
        goto LOOP;
} //end of outer try {..}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("ScvThdInit");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_SCV_EXC);

        //
        // Let us terminate the thread gracefully
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);

        }

        //
        // We should never get here
        //
        return(WINS_FAILURE);
}

STATUS
DoScavenging(
        PNMSSCV_PARAM_T        pScvParam,
        BOOL                   fSignaled,
        LPBOOL                 pfResetTimer,
        LPBOOL                 pfSpTimeOver
        )

/*++

Routine Description:
        This function is responsible for doing all scavenging

Arguments:
        None

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        ScvThdInitFn()

Side Effects:

Comments:
        None
--*/

{
        PRPL_REC_ENTRY_T        pStartBuff;
        PRPL_REC_ENTRY_T        pRec;
        DWORD                   BuffLen;
        DWORD                   NoOfRecs = 0;
        time_t                  CurrentTime;
        DWORD                   NoOfRecsScv;  //no of records whose state has
                                              //been affected
        DWORD                   TotNoOfRecsScv = 0;  //Total no of records
                                                     //whose state has
                                                     //been affected
        VERS_NO_T               MyMaxVersNo;
        DWORD                   i;            //for loop counter
        DWORD                   RecCnt;
        LARGE_INTEGER           n;            //for loop counter
        LARGE_INTEGER           Tmp;
        DWORD                   State;        //stores state of a record
        VERS_NO_T               VersNoLimit;
        DWORD                   NoOfRecChgToRelSt  = 0;
        DWORD                   NoOfRecChgToTombSt = 0;
        DWORD                   NoOfRecToDel           = 0;
        DWORD                   MaxNoOfRecsReqd = 0;
        BOOL                    fLastEntryDel = FALSE;
        PWINSTHD_TLS_T          pTls;
        PRPL_REC_ENTRY_T        pTmp;
        BOOL                    fRecsExistent = FALSE;
        VERS_NO_T               MinScvVersNo;
#ifdef WINSDBG
        DWORD                   SectionCount = 0;
#endif
        PQUE_SCV_REQ_WRK_ITM_T  pScvWrkItm;
        PQUE_SCV_REQ_WRK_ITM_T  pClientWrkItm;
        PQUE_TMM_REQ_WRK_ITM_T  pTmmWrkItm;
        QUE_SCV_OPC_E           Opcode_e;
        DWORD                   Age;
        STATUS                  RetStat;
        BOOL                    fForce;
        BOOL                    fPeriodicCC = FALSE;


      DBGENTER("DoScavenging\n");
      *pfResetTimer = FALSE;

      // get the thread local storage and initialize to NULL the thread's heap handle.
      GET_TLS_M(pTls);
      pTls->HeapHdl = NULL;


      while (TRUE)
      {

try {
        if (fSignaled)
        {
              RetStat = QueRemoveScvWrkItm((LPVOID *)&pScvWrkItm);
              if (RetStat == WINS_NO_REQ)
              {
                    break;
              }
              else
              {
                    //
                    //  If we got signaled by the timer thread, get the pointer
                    //  to the local WrkItm of ScvThdInitFn()
                    //
                    if (pScvWrkItm->CmdTyp_e == QUE_E_CMD_TIMER_EXPIRED)
                    {
                      DBGPRINT0(SCV, "DoScavenging: Timer Thd. triggered scavenging\n");
                      pClientWrkItm = ((PQUE_TMM_REQ_WRK_ITM_T)(pScvWrkItm))->pClientCtx;
                      fPeriodicCC   = TRUE;

                      if (!*pfResetTimer)
                      {
                         *pfResetTimer = TRUE;
                      }

                      //
                      // If *pfSpTimeOver is false, it means that the timer
                      // thread wokr us up at SpTime specified in registry
                      // (or at 2am if SpTime) was not specifid in registry.
                      // Set *pfSpTimeOver to TRUE so that from hereon we
                      // use TimeInterval specified in the registry as
                      // the time interval
                      //
                      if (!*pfSpTimeOver)
                      {
                        *pfSpTimeOver = TRUE;
                      }
                    }
                    else
                    {
                      pClientWrkItm = pScvWrkItm;
                    }


                    Opcode_e = pClientWrkItm->Opcode_e;
                    Age      = pClientWrkItm->Age;
                    fForce   = (BOOL)pClientWrkItm->fForce;
                    if (*pfResetTimer)
                    {
                      WinsTmmDeallocReq((PQUE_TMM_REQ_WRK_ITM_T)pScvWrkItm);
                    }
                    else
                    {
                      //
                      // Free the admin. initiated rpc work item
                      //
                      WinsMscHeapFree(NmsRpcHeapHdl, pScvWrkItm);
                    }
              }
        }
        else
        {
                //
                // timer expiry of the wait call
                //
                Opcode_e = WINSINTF_E_SCV_GENERAL;
                Age      = pScvParam->VerifyInterval;
                fForce   = FALSE;         // no forceful scavenging
        }


        if (sfAdminForcedScv && !fPeriodicCC)
        {
           WinsIntfSetTime( NULL,  WINSINTF_E_ADMIN_TRIG_SCV );
           DBGPRINTTIME(SCV, "STARTING AN ADMIN. TRIGGERED SCAVENGING CYCLE ", LastATScvTime);
           DBGPRINTTIME(DET, "STARTING AN ADMIN. TRIGGERED SCAVENGING CYCLE ", LastATScvTime);
        }
        else
        {
           WinsIntfSetTime( NULL, WINSINTF_E_PLANNED_SCV);
           DBGPRINTTIME(SCV, "STARTING A SCAVENGING CYCLE ", LastPScvTime);
           DBGPRINTTIME(DET, "STARTING A SCAVENGING CYCLE ", LastPScvTime);
        }

        //
        // get the current time
        //
        (void)time(&CurrentTime);

        if (Opcode_e == WINSINTF_E_SCV_GENERAL)
        {

          WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SCVENGING_STARTED);
          //
          // record current time in sLastRefTime
          //
          sLastRefTime = CurrentTime;
          EnterCriticalSection(&NmsNmhNamRegCrtSec);
          //
          // Store the max. version number in a local since the max. version
          // number is incremented by several threads
          //
          NMSNMH_DEC_VERS_NO_M(
                             NmsNmhMyMaxVersNo,
                             MyMaxVersNo
                            );
          //
          // synchronize with RplPullPullSpecifiedRange
          //
          MinScvVersNo = NmsScvMinScvVersNo;

          LeaveCriticalSection(&NmsNmhNamRegCrtSec);

          //
          // Set thread priority to the level indicated in the WinsCnf
          // structure
          //
          WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          pScvParam->PrLvl
                         );

          // log a detailed event showing the range of version_numbers that
          // are being scavenged. This helps finding out why some particuler
          // record is stalled in the database. (If it doesn't fall in this
          // range it means the scavenger is not even looking at it).
          WinsEvtLogDetEvt(
              TRUE,                 // Informational event
              WINS_EVT_SCV_RANGE,   // event ID
              NULL,                 // NULL filename
              __LINE__,             // line number where this event is logged
              "dddd",               // data section format
              MinScvVersNo.LowPart, MinScvVersNo.HighPart,  // data: 2nd, 3rd words
              MyMaxVersNo.LowPart, MyMaxVersNo.HighPart);   // data: 4th, 5th words

          Tmp.QuadPart = pScvParam->ScvChunk;
          for (
                n.QuadPart = MinScvVersNo.QuadPart; // min. version no. to
                                                    //start from
                LiLeq(n, MyMaxVersNo);      // until we reach the max. vers. no
                                            // no third expression here
            )
          {
                BOOL        fGotSome = FALSE;

                //
                // The max. version number to ask for in one shot.
                //
                VersNoLimit.QuadPart = LiAdd(n, Tmp);

                //
                // If my max. version number is less than the version number
                // computed above, we do not specify a number for the max.
                // records.  If however, my max. vers. no is more, we specify
                // the number equal to the chunk specified in Tmp
                //
                if (LiLeq(MyMaxVersNo, VersNoLimit))
                {
                        MaxNoOfRecsReqd = 0;
                }
                else
                {
                        MaxNoOfRecsReqd = Tmp.LowPart;
                }

                // log a detailed event saying what are the exact records that are retrieved
                // from the database for scavenging. This helps finding out whether the loop is
                // not broken earlier that expected leaving records not scavenged.
                WinsEvtLogDetEvt(
                      TRUE,                                         // Informational event
                      WINS_EVT_SCV_CHUNK,                           // event ID
                      NULL,                                         // NULL filename
                      __LINE__,                                     // line number where this event is logged
                      "ddddd",                                      // data section format
                      MaxNoOfRecsReqd,                              // data: 2nd word
                      n.LowPart, n.HighPart,                        // data: 3rd, 4th words
                      MyMaxVersNo.LowPart, MyMaxVersNo.HighPart);   // data: 5th, 6th words

                // make sure any previous thread heap is cleaned up - NmsDbGetDataRecs will
                // create a new heap and allocate memory.
                if (pTls->HeapHdl != NULL)
                {
                    // destroying the heap deletes all the memory allocated in it
                    WinsMscHeapDestroy(pTls->HeapHdl);
                    pTls->HeapHdl = NULL;
                }
                /*
                * Call database manager function to get all the records. owned
                * by us. No need to check the return status here
                */
                NmsDbGetDataRecs(
                          WINS_E_NMSSCV,
                          pScvParam->PrLvl,
                          n,
                          MyMaxVersNo,  //Max vers. no
                          MaxNoOfRecsReqd,
                          FALSE,          //we want data recs upto MaxVers
                          FALSE,          //not interested in replica tombstones
                          NULL,           //must be NULL since we are not
                                          //doing scavenging of clutter
                          &NmsLocalAdd,
                          FALSE,           //both dynamic & static records should be considered
                          WINSCNF_RPL_DEFAULT_TYPE, //no use here
                          (LPVOID *)&pStartBuff,
                          &BuffLen,
                          &NoOfRecs
                        );


                //
                // If no of records retrieved is 0, we should break out of
                // the loop
                //
                if (NoOfRecs == 0)
                {
                        break;
                }


                fGotSome = TRUE;
                if (!fRecsExistent)
                {
                        fRecsExistent = TRUE;
                }
                NoOfRecsScv  = 0;        // init the counter to 0

                (void)time(&CurrentTime);

                for (
                        i = 0, pRec = pStartBuff;
                        i < NoOfRecs;
                        i++
                    )
                {

                        State =  NMSDB_ENTRY_STATE_M(pRec->Flag);

                        switch (State)
                        {

                            case(NMSDB_E_ACTIVE):
                                // don't touch active static records
                                if (!NMSDB_IS_ENTRY_STATIC_M(pRec->Flag))
                                {
                                    SET_STATE_IF_REQD_M(
                                            pRec,
                                            CurrentTime,
                                            pScvParam->TombstoneInterval,
                                            NMSDB_E_RELEASED,
                                            NoOfRecChgToRelSt
                                                       );
                                }
                                break;

                            case(NMSDB_E_RELEASED):
                                // a static record can't become released, but who knows...
                                // just making sure we don't touch statics in this case
                                if (!NMSDB_IS_ENTRY_STATIC_M(pRec->Flag))
                                {
                                    SET_STATE_IF_REQD_M(
                                            pRec,
                                            CurrentTime,
                                            pScvParam->TombstoneTimeout,
                                            NMSDB_E_TOMBSTONE,
                                            NoOfRecChgToTombSt
                                                       );
                                }
                                break;

                            case(NMSDB_E_TOMBSTONE):

FUTURES("Redesign, so that the if condition is not executed multiple times");
                                //
                                //If there are records to delete and we have
                                //been up and running for at least 3 days, go
                                //ahead and delete them.  The records should
                                //have replicated to atleast one partner by
                                //now.
                                if ((CurrentTime - sBootTime) >= THREE_DAYS ||
                                    sfNoLimitChk)
                                {
                                  SET_STATE_IF_REQD_M(
                                        pRec,
                                        CurrentTime,
                                        pScvParam->TombstoneTimeout, //no use
                                        NMSDB_E_DELETED,
                                        NoOfRecToDel
                                                   );
                                }
                                break;

                           default:
                                DBGPRINT1(EXC, "DoScavenging: Weird State of Record (%d)\n", State);
                                WINSEVT_LOG_M(WINS_EXC_FAILURE, WINS_EVT_SFT_ERR);
                                // Just change the state of the record to tombstone and continue
                                // with scavenging.
                                NMSDB_SET_STATE_M(pRec->Flag, NMSDB_E_TOMBSTONE);
                                break;
                        }

                        pRec = (PRPL_REC_ENTRY_T)(
                                   (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );
                }


                //
                // Make pTmp point to the last record in the
                // buffer.
                //
                pTmp = (PRPL_REC_ENTRY_T)(
                                    (LPBYTE)pRec -   RPL_REC_ENTRY_SIZE);

                //
                // If one or more records need to be scavenged
                //
                if (NoOfRecsScv > 0)
                {
                        if  (NoOfRecToDel > 0)
                        {

                           //
                           // If the most recent record in this chunk has
                           // to be deleted, let us record that fact in a
                           // boolean.
                           // If in the scavenging of the next chunk, the
                           // most recent record is not deleted, the boolean
                           // will be reset.  At this point we don't know
                           // whether or not there is even another record
                           // more recent than this one (the next time, we
                           // retrieve records, we may not get any)
                           //
CHECK("This if test is most probably not required. Get rid of it")
                           if (LiLeq(pTmp->VersNo, MyMaxVersNo))
                           {
                                //
                                // If entry is marked for deletion
                                //
                                if (NMSDB_ENTRY_DEL_M(pTmp->Flag))
                                {
                                        fLastEntryDel = TRUE;
                                }
                                else
                                {
                                        fLastEntryDel = FALSE;
                                }
                           }

                        }
                        else
                        {
                                fLastEntryDel = FALSE;
                        }


                        UpdDb(
                                pScvParam,
                                pStartBuff,
                                NoOfRecs,
                                NoOfRecsScv
                             );
                        TotNoOfRecsScv += NoOfRecsScv;
                }
#ifdef WINSDBG
                else
                {
                        DBGPRINT0(DET,"DoScavenging: NO RECORDS NEED TO BE SCAVENGED AT THIS TIME\n");
                }
#endif

                //
                // if we specified a max. no. and the no. of recs retrieved
                // is less than that, clearly there are no more records to
                // retrieve.  Get rid of the buffer and break out of the loop
                //
                if ((MaxNoOfRecsReqd > 0) && (NoOfRecs < MaxNoOfRecsReqd))
                {
                        break;
                }
                //
                // Set n to the highest version number retrieved if it is
                // more than what n would be set to prior to the next
                // iteration.
                //
                // At the next iteration, n will be compared with the highest
                // version number we have. If equal, then we don't have to
                // iterate anymore (useful when the highest version number
                // is very high but there are one or more records with low
                // version numbers
                //
                if (LiGtr(pTmp->VersNo, VersNoLimit))
                {
                        n = pTmp->VersNo;
                }
                else
                {
                        n = VersNoLimit;
                }

           } // end of for loop for looping over records

           WINSEVT_LOG_INFO_D_M(TotNoOfRecsScv, WINS_EVT_SCV_RECS);
           WINSDBG_INC_SEC_COUNT_M(SectionCount);


           //
           // If the last scavenging action was a deletion, it means that
           // we deleted the highest version numbered record owned by
           // us.  Let us therefore update the Special record that records
           // this version number.
           //
           if (fLastEntryDel)
           {
                WinsMscSetThreadPriority(
                                    WinsThdPool.ScvThds[0].ThdHdl,
                                    THREAD_PRIORITY_NORMAL
                                         );

                (VOID)NmsDbUpdHighestVersNoRec(
                                NULL,  //no pTls
                                MyMaxVersNo,
                                TRUE  //enter critical section
                                        );
                WinsMscSetThreadPriority(
                                    WinsThdPool.ScvThds[0].ThdHdl,
                                          pScvParam->PrLvl
                                        );
           }
           (void)time(&CurrentTime);
           //
           // Let us get rid of the replica tombstones if sufficient time has
           // elapsed since the last time we did this. Exception: If the
           // administrator has requested scavenging, let us do it now.
           // Even if admin. requests it we don't do it unless we have been
           // up and running for atleast 3 days.  This is in line with our
           // philosophy of being absolutely robust even when admin. makes
           // mistakes.
           // sfNoLimitChk allows testers to override this 3 day limitations.
           if (
               ( ((CurrentTime > sLastTombTime)
                        &&
                 (CurrentTime - sLastTombTime) > (time_t)min(
                                            pScvParam->TombstoneTimeout,
                                            pScvParam->TombstoneInterval
                                               ) )
                                ||
                sfAdminForcedScv
               )
                        &&
                ((CurrentTime - sBootTime >= THREE_DAYS) || fForce || sfNoLimitChk)
              )
          {
                NMSSCV_CLUT_T  ClutterInfo;
                WinsIntfSetTime(
                                NULL,
                                WINSINTF_E_TOMBSTONES_SCV
                                );

                NoOfRecsScv  = 0;
                NoOfRecToDel = 0;

                ClutterInfo.Interval            = pScvParam->TombstoneTimeout;
                ClutterInfo.CurrentTime         = CurrentTime;
                ClutterInfo.fAll                = FALSE;  //not used but
                                                          //let us set it

                // make sure any previous thread heap is cleaned up - NmsDbGetDataRecs will
                // create a new heap and allocate memory.
                if (pTls->HeapHdl != NULL)
                {
                    // destroying the heap deletes all the memory allocated in it
                    WinsMscHeapDestroy(pTls->HeapHdl);
                    pTls->HeapHdl = NULL;
                }
                /*
                * Call database manager function to get all the
                * replicas that are tombstones
                */
                DBGPRINT0(DET, "DoScavenging: GETTING REPLICA TOMBSTONES\n");
                NmsDbGetDataRecs(
                                  WINS_E_NMSSCV,
                                  pScvParam->PrLvl,
                                  n,              //no use in this call
                                  MyMaxVersNo,    //no use in this call
                                  0,              //no use in this call
                                  TRUE,           //no use in this call
                                  TRUE,           //Get only replica tombstones
                                  &ClutterInfo,
                                  &NmsLocalAdd,   //no use in this call
                                  FALSE,          //both dyn & static should be taken
                                  WINSCNF_RPL_DEFAULT_TYPE, //no use here
                                  (LPVOID *)&pStartBuff,
                                  &BuffLen,
                                  &NoOfRecs
                                 );

                if(NoOfRecs > 0)
                {

                     for (
                        i = 0, pRec = pStartBuff;
                        i < NoOfRecs;
                        i++
                        )
                      {
                          NMSDB_SET_STATE_M(pRec->Flag, NMSDB_E_DELETED);
                          pRec->fScv   = TRUE;
                          NoOfRecToDel = NoOfRecs;
                          pRec = (PRPL_REC_ENTRY_T)(
                                          (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );

                      }

                      //
                      // If one or more replicas needs to be deleted
                      // call UpdDb
                      //
                      DBGPRINT1(DET, "DoScavenging: %d REPLICAS WILL BE DELETED\n", NoOfRecs);
                      UpdDb(
                               pScvParam,
                               pStartBuff,
                               NoOfRecs,
                               NoOfRecs    //NoOfRecsScv
                               );

                      if (fForce)
                      {
                         DBGPRINT0(SCV, "DoScavenging: FORCEFUL SCAVENGING OF REPLICA TOMBSTONES\n");
                         WINSEVT_LOG_M(WINS_SUCCESS, WINS_EVT_FORCE_SCV_R_T);
                      }

                      WINSEVT_LOG_INFO_D_M(NoOfRecsScv, WINS_EVT_SCV_RPLTOMB);
                }
#ifdef WINSDBG
                else
                {
                        DBGPRINT0(DET, "DoScavenging: NO REPLICA TOMBSTONES DELETED\n");
                }
#endif
                // The records retrieved by the previuos NmsDbGetDataRecs are useless.
                // destroy the heap here.
                if (pTls->HeapHdl != NULL)
                {
                    // destroying the heap deletes all the memory allocated in it
                    WinsMscHeapDestroy(pTls->HeapHdl);
                    pTls->HeapHdl = NULL;
                }

                //
                // record current time in sLastTombTime
                //
                sLastTombTime = CurrentTime;

          } // end of if (test if replica tombstones need to be processed)

           WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SCVENGING_COMPLETED);
        }

         WINSDBG_INC_SEC_COUNT_M(SectionCount);

         if (Opcode_e != WINSINTF_E_SCV_GENERAL)
         {
          WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          pScvParam->PrLvl
                         );
         }
         //
         // If we are due for a verification or if we are being forced to do
         // it by the admin., do it.  Note: Timer Thread initiated verification
         // is always forced.  An admin. initiated one may or may not be forced.
         // We force the admin. to specify the kind of verification he wants.
         // If he chooses to do a forceful one, then we give him a warning.
         // about the overhead of this (specially if a number of admins. are
         // doing forceful verification around the same time or one after
         // another
         //
         if (
                ((CurrentTime > sLastVerifyTime)
                                &&
                ((CurrentTime - sLastVerifyTime) > (time_t)pScvParam->VerifyInterval))
                                ||
                fForce
                                ||

                (sfAdminForcedScv && (sfNoLimitChk || (CurrentTime - sLastVerifyTime) >= ONE_HOUR))
            )
         {
             // --ft: #623712: do verification only if the Opcode allows us to do so (timer does)
             if (Opcode_e == WINSINTF_E_SCV_VERIFY ||
                 Opcode_e == WINSINTF_E_VERIFY_SCV)
             {

                // we might want to always log normal events for consistency checking
                // since this operation happens normally only when initiated by the
                // administrator or at about 24hrs, if configured 
                // (or reg param ..Parameters\ConsistencyCheck:TimeInterval)
                // --ft: #384489: if this is an administrator initiated action...
                //if (sfAdminForcedScv)
                //..log the event as a normal one
                   WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CCCHECK_STARTED);
                //else
                //..log it as a detailed event only.
                //   WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_CCCHECK_STARTED);

                WinsIntfSetTime(
                                NULL,
                                WINSINTF_E_VERIFY_SCV
                                );
                //
                // get all active replicas that are older than the
                // verify interval. Contact the owner WINS to verify their
                // validity
                //
                //DBGPRINT1(ERR, "DoScavenging: pScvParam is (%x)\n", pScvParam);
                (VOID)VerifyDbData(pScvParam, CurrentTime, Age, fForce, fPeriodicCC);
                //WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SCV_CLUTTER);

                // --ft: #384489: see comment above.
                //if (sfAdminForcedScv)
                //..log the event as a normal one
                    WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CCCHECK_COMPLETED);
                //else
                //..log it as a detailed event only.
                //  WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_CCCHECK_COMPLETED);
                sLastVerifyTime = CurrentTime;
             }
         }

         WINSDBG_INC_SEC_COUNT_M(SectionCount);


 }  // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("DoScavenging");
        DBGPRINT1(EXC, "DoScavenging: Section Count (%d)\n", SectionCount);
        DBGPRINT5(EXC, "DoScavenging: Variables - i (%d), NoOfRecs (%d), \
                NoOfRecsScv (%d), pStartBuff (%p), pRec (%p)\n",
                i, NoOfRecs, NoOfRecsScv, pStartBuff, pRec
                 );

        if (GetExceptionCode() != WINS_EXC_COMM_FAIL)
        {

               // make sure any previous thread heap is cleaned up before getting out of this call
               if (pTls->HeapHdl != NULL)
               {
                    // destroying the heap deletes all the memory allocated in it
                    WinsMscHeapDestroy(pTls->HeapHdl);
                    pTls->HeapHdl = NULL;
               }

               //
               // Set thd. priority back to normal
               //
               WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                         );
                //
                // This is serious.  Let us reraise the exception so that
                // WINS comes down
                //
                //WINS_RERAISE_EXC_M();

                //
                // just return so that we close tables in the caller function
                //
                return(WINS_FAILURE);
        }
 }

          //
          // Set thd. priority back to normal
          //
          WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                         );
        if (Opcode_e == WINSINTF_E_SCV_GENERAL)
        {
          //
          //If we were not able to retrieve any owned records in this scavenging
          // cycle, adjust the min. scv vers. no.  Synchronize with
          // RplPullPullSpecifiedRange
          //
          if (!fRecsExistent)
          {
                //
                // NmsScvMinScvVersNo may be greater than MyMaxVersNo
                // (This may happen if we did not find any local records
                // last time around and no registrations have taken
                // place since then).
                //
                if (LiGtr(MyMaxVersNo, NmsScvMinScvVersNo))
                {

                  //
                  //
                  // Change the Low end of the range  that
                  // we will use it at the next Scavenging cycle
                  //
                  EnterCriticalSection(&NmsNmhNamRegCrtSec);

                  //
                  // Set the Min. Scv. Vers. no to 1 more than the max. vers.
                  // no. we used when searching for records to scavenge.
                  //
                  NMSNMH_INC_VERS_NO_M(MyMaxVersNo, MyMaxVersNo);
                  NmsScvMinScvVersNo = MyMaxVersNo;
                  LeaveCriticalSection(&NmsNmhNamRegCrtSec);
               }
         }

         //
         // If we are not executing a work item from the queue, break out
         // of the while loop, else continue (to get the next work item)
         // if there
         //
         if (!fSignaled)
         {
           break;
         }
       }
      } // end of while

       // make sure any previous thread heap is cleaned up before getting out of this call
       if (pTls->HeapHdl != NULL)
       {
            // destroying the heap deletes all the memory allocated in it
            WinsMscHeapDestroy(pTls->HeapHdl);
            pTls->HeapHdl = NULL;
       }

      DBGPRINT0(SCV, "SCAVENGING CYCLE ENDED\n");
      DBGLEAVE("DoScavenging\n");
      return(WINS_SUCCESS);
}

VOID
ReconfigScv(
 PNMSSCV_PARAM_T  pScvParam
        )

/*++

Routine Description:
        This function is called to reinit the scavenging params

Arguments:
        pScvParam - Structure storing the scavenging params

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        ScvThdInitFn
Side Effects:

Comments:
        None
--*/

{
        DBGENTER("ReconfigScv\n");
        //
        // Extract the parameters that are related
        // to scavenging and go back to doing the timed
        // wait.  Since WinsCnf can change any time, we
        // operate with copies. Also, the priority of this
        // thread is changed outside of this critical section
        // See DoScavenging().
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);
try {
        pScvParam->ScvChunk          = WinsCnf.ScvChunk;
        pScvParam->RefreshInterval   = WinsCnf.RefreshInterval;
        pScvParam->TombstoneInterval = WinsCnf.TombstoneInterval;
        pScvParam->TombstoneTimeout  = WinsCnf.TombstoneTimeout;
        pScvParam->PrLvl                 = WinsCnf.ScvThdPriorityLvl;

        //
        // Load up the CC parameters
        //
        pScvParam->CC.TimeInt        = WinsCnf.CC.TimeInt;
        pScvParam->CC.fSpTime        = WinsCnf.CC.fSpTime;
        pScvParam->CC.SpTimeInt      = WinsCnf.CC.SpTimeInt;
        pScvParam->CC.MaxRecsAAT     = WinsCnf.CC.MaxRecsAAT;
        pScvParam->CC.fUseRplPnrs    = WinsCnf.CC.fUseRplPnrs;

        //
        // If the backup path has changed, start using it.
        //
        if (WinsCnf.pBackupDirPath != NULL)
        {
          if (strcmp(WinsCnf.pBackupDirPath, pScvParam->BackupDirPath))
          {
                   strcpy(pScvParam->BackupDirPath, WinsCnf.pBackupDirPath);
          }
        }
        else
        {
                   pScvParam->BackupDirPath[0] = EOS;
        }
 }
finally {
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
}

        DBGLEAVE("ReconfigScv\n");
        return;
}

#ifdef WINSDBG
#pragma optimize ("", off)
#endif

VOID
UpdDb(
        IN  PNMSSCV_PARAM_T        pScvParam,
        IN  PRPL_REC_ENTRY_T        pStartBuff,
        IN  DWORD                NoOfRecs,
        IN  DWORD                NoOfRecsToUpd
     )

/*++

Routine Description:

        This function is called to update the DB

Arguments:
        pScvParam  - Scavenging params
        pStartBuff - Buffer containing records processed by DoScavenging()
        NoOfRecs   - No of records in the above buffer
        NoofRecsToUpd - No of records that need to be modified in the db

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        DoScavenging

Side Effects:

Comments:
        None
--*/

{
        DWORD                   i;
        DWORD                   NoUpdated = 0; //No of records that have been
                                           //updated
        PRPL_REC_ENTRY_T        pRec = pStartBuff;

        DBGENTER("UpdDb\n");

        //
        // Set the current index to be the clustered index
        //
        NmsDbSetCurrentIndex(
                        NMSDB_E_NAM_ADD_TBL_NM,
                        NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
        //
        // Update the database now
        //
        for (
                i = 0;
                i < NoOfRecs;
                i++
            )
        {

                //
                // if the record was updated, update the db
                //
                if (pRec->fScv)
                {
                       if (NmsDbQueryNUpdIfMatch(
                                                pRec,
                                                pScvParam->PrLvl,
                                                TRUE,        //chg pr. lvl
                                                WINS_E_NMSSCV
                                                ) == WINS_SUCCESS
                           )
                       {
                          NoUpdated++;  // no of records that we
                                        //have updated in the db
                       }
                       else
                       {
                          DBGPRINT0(ERR, "DoScavenging: Could not scavenge a record\n");
                          WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SCV_ERR);
                       }
                }

                //
                //  see if we are done
                //
                if (NoUpdated == NoOfRecsToUpd)
                {
                  break;
                }

                pRec = (PRPL_REC_ENTRY_T)(
                                        (LPBYTE)pRec + RPL_REC_ENTRY_SIZE
                                                 );
        }  // end of for loop

        DBGPRINT1(FLOW, "LEAVE: SCAVENGING: UpdDb. Records Updated = (%d)\n",  NoUpdated);
        return;
} // UpdDb()

#ifdef WINSDBG
#pragma optimize ("", on)
#endif



STATUS
VerifyDbData(
        PNMSSCV_PARAM_T       pScvParam,
        time_t                CurrentTime,
        DWORD                 Age,
        BOOL                  fForce,
        BOOL                  fPeriodicCC
        )

/*++

Routine Description:
        This function is called to remove any clutter that might have
        accumulated in the db.  For each owner, excepting self, in the
        db, it gets the version numbers of the active records that are
        older than the verify time interval. It then contacts the owner
        WINS to verify their validity

Arguments:
        pScvParam  - pointer to the scavenging parameters

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        DoScavenging

Side Effects:

Comments:
        None
--*/

{

        DWORD                   MaxOwnerIdFound;
        volatile DWORD          i;
        NMSSCV_CLUT_T           ClutterInfo;
        PRPL_REC_ENTRY_T        pStartBuff;
        DWORD                   BuffLen;
        DWORD                   NoOfLocalDbRecs;
        COMM_ADD_T              OwnerWinsAdd;
        COMM_ADD_T              VerifyWinsAdd;
        PCOMM_ADD_T             pWinsAdd;
        VERS_NO_T               MinVersNo, MaxVersNo;
        PNMSDB_WINS_STATE_E     pWinsState_e;
        PVERS_NO_T              pStartVersNo;
        NMSDB_WINS_STATE_E      WinsState_e;
        COMM_HDL_T              DlgHdl;
        PWINSTHD_TLS_T          pTls;
        static DWORD            sFirstOwnerId = 1;
        DWORD                   FirstOwnerId;
        DWORD                   NoOfPulledRecs;
        DWORD                   TotNoOfPulledRecs = 0;
        DWORD                   LastOwnerId;
        BOOL                    fNonOwnerPnr;
        DWORD                   TotPulledRecsFromOneWins;
        BOOL                    fDlgStarted = FALSE;
        BOOL                    fFirstTime;
        PRPL_REC_ENTRY_T        pLastEntry;
        STATUS                  RetStat;
        DWORD                   RplType;
        BOOL                    fPulledAtLeastOnce;
        VERS_NO_T               MaxVersNoSave;


        DBGENTER("VerifyDbData\n");

        // get the thread local storage and initialize to NULL the thread's heap handle.
        GET_TLS_M(pTls);
        pTls->HeapHdl = NULL;

        //
        // Init the structure used by NmsDbGetDataRecs()
        //
        ClutterInfo.Interval            = pScvParam->VerifyInterval;
        ClutterInfo.CurrentTime         = CurrentTime;
        ClutterInfo.Age                 = Age;
        ClutterInfo.fAll                = TRUE;

        //
        // Set thread priority to NORMAL
        //
        WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                               );

        //
        // Cleanup the owner-address table if it requires cleaning
        //
        NmsDbCleanupOwnAddTbl(&MaxOwnerIdFound);

try {

        //
        // If it is an admin. forced verification or the one that happens
        // due to the verify interval being over, do a full validation
        //
        if (!fPeriodicCC)
        {
              FirstOwnerId       = 1;
              sLastFullVerifyTime = CurrentTime;
        }
        else
        {
            //
            // Periodic verification.  Skip the owners we verified earlier
            //
            if (sFirstOwnerId >= MaxOwnerIdFound)
            {
                sFirstOwnerId = 1;
            }
            FirstOwnerId = sFirstOwnerId;
        }
        LastOwnerId         = MaxOwnerIdFound;

        //
        // for each owner in the db, excluding self, do the following.
        //
        for (i = FirstOwnerId; i <= LastOwnerId; i++)
        {

                //
                // If it is periodic verification and we have pulled more than
                // the max. threshold specified for one particular cycle,
                // break out of the loop
                //
                if (fPeriodicCC && (TotNoOfPulledRecs >= pScvParam->CC.MaxRecsAAT))
                {
                      break;

                }

                //
                // Get all ACTIVE replicas that are older than verify interval.
                //
                ClutterInfo.OwnerId = i;

                //
                // We need to synchronize with the Pull thread which can
                // change the NmsDbOwnAddTbl table.  The entry may have
                // been deleted by the Pull thread (DeleteWins), so we
                // should be ready for access violation
                //
                EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
                RPL_FIND_ADD_BY_OWNER_ID_M(
                        i, pWinsAdd, pWinsState_e, pStartVersNo);

                //
                // The Wins entry should be there.
                //
                ASSERT(pWinsAdd);
                OwnerWinsAdd     = *pWinsAdd;
                WinsState_e      = *pWinsState_e;
                LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

                //
                // If WINS is not active, log a record and continue to
                // the next WINS.  It is possible for WINS to get deleted
                // to between the time we get its records and the time
                // we check the own-add table for its entry.
                //

                if (
                      (WinsState_e == NMSDB_E_WINS_DOWN) ||
                      (WinsState_e == NMSDB_E_WINS_DELETED)
                   )
                {

                        //
                        // if there are records in the db, then the
                        // state of WINS in the in-memory table can not
                        // be deleted
                        //
                        DBGPRINT2(SCV, "VerifyDbData: WINS with index = (%d) and IP Address = (%x) is either down or deleted \n", i, OwnerWinsAdd.Add.IPAdd);
                        continue;
                }



                WINS_ASSIGN_INT_TO_LI_M(MinVersNo, 0);
                fFirstTime = TRUE;
                TotPulledRecsFromOneWins = 0;
                fPulledAtLeastOnce = FALSE;

                //
                // Save the max. vers. no. that we have in the
                // pRplPullOwnerVersNo table in a local.
                //
                EnterCriticalSection(&RplVersNoStoreCrtSec);
#ifdef WINSDBG
                try {
#endif
                  MaxVersNoSave =  (pRplPullOwnerVersNo + i)->VersNo;
#ifdef WINSDBG
                } //end of try { .. }
                finally {
#endif
                   LeaveCriticalSection(&RplVersNoStoreCrtSec);
#ifdef WINSDBG
                }
#endif
                do
                {

                  // make sure any previous thread heap is cleaned up - NmsDbGetDataRecs will
                  // create a new heap and allocate memory.
                  if (pTls->HeapHdl != NULL)
                  {
                    // destroying the heap deletes all the memory allocated in it
                    WinsMscHeapDestroy(pTls->HeapHdl);
                    pTls->HeapHdl = NULL;
                  }

                  NoOfLocalDbRecs = 0;
//                  DBGPRINT1(ERR, "VerifyDbData:1 pScvParam is (%x)\n", pScvParam);
                  MaxVersNo.QuadPart = 0;
                  NmsDbGetDataRecs(
                          WINS_E_NMSSCV,
                          pScvParam->PrLvl,
                          MinVersNo,
                          MaxVersNo,     //not used in this call
                          0,
                          TRUE,       //fUpToLimit set to TRUE
                          FALSE,       //not interested in replica tombstones
                          &ClutterInfo,
                          &OwnerWinsAdd,        //Wins Address - not used
                          FALSE,       //dyn + static recs required
                          WINSCNF_RPL_DEFAULT_TYPE, //no use here
                          (LPVOID *)&pStartBuff,
                          &BuffLen,
                          &NoOfLocalDbRecs
                        );


                  GET_TLS_M(pTls);
                  ASSERT(pTls->HeapHdl != NULL);

                  WinsMscChkTermEvt(
#ifdef WINSDBG
                             WINS_E_NMSSCV,
#endif
                             FALSE
                                );

PERF("Optimize so that we reuse a dlg session if we need to go to the same")
PERF("pnr in a subsequent iteration")
                   //
                   // If this is the first time, we pick a WINS and establish
                   // communications with it. Note: If the max. vers. no
                   // in pRplOwnerVersNo for this WINS is 0, we continue on
                   // to the next WINS in our list.
                   //
                   // We don't care whether or not we were able to retrieve
                   // any records from the db.  If we retrieved 0 but the Wins's
                   // pRplPullOwnerVersNo entry has a positive entry, it means
                   // we are out of synch
                   //
                   if (fFirstTime)
                   {
                      if (MaxVersNoSave.QuadPart == 0)
                      {
                              ASSERT(NoOfLocalDbRecs == 0);
                              DBGPRINT2(SCV, "VerifyDbData: WINS with index = (%d) and address = (%x) has pRplPullOwnerVersNo value of 0. SKIPPING IT\n", i, OwnerWinsAdd.Add.IPAdd);

                              FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                              break;
                      }

                      //
                      // Pick the pnr to use for verification
                      //
                      if (PickWinsToUse(
                          &VerifyWinsAdd,
                          &OwnerWinsAdd,
                          pScvParam->CC.fUseRplPnrs,
                          &fNonOwnerPnr,
                          &RplType) != WINS_SUCCESS)
                      {
                           //
                           // Any error that needed to be logged has already
                           // been logged. Just return success.
                           //
                           FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                           return (WINS_SUCCESS);
                      }


                      //
                      // Establish communication with it.  If we can not
                      // establish comm. with it, break out of the loop
                      //
                      RetStat = EstablishCommForVerify(&VerifyWinsAdd, &DlgHdl);

                      if (RetStat == WINS_FAILURE)
                      {
                         FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                         break;  //go on to the next WINS in the list of owners
                      }
                      fDlgStarted = TRUE;

                      //
                      // get the min and max version numbers of the active
                      // replicas
                      //
                      MinVersNo.QuadPart  = 1;        //pStartBuff->VersNo;
                      fFirstTime = FALSE;
                } // if first time

                {

                  //
                  //Must not pull a version number that is > what we
                  //have in our table to avoid conflicting with the
                  //pull thread.
                  //
                  MaxVersNo =  MaxVersNoSave;
                }
                ASSERT(MaxVersNo.QuadPart <= MaxVersNoSave.QuadPart);

                DBGPRINT5(DET, "VerifyDbData: Going to pull records in the range (%d %d) to (%d %d) from Wins with owner id = (%d)\n",
                                MinVersNo.HighPart, MinVersNo.LowPart,
                                MaxVersNo.HighPart, MaxVersNo.LowPart,
                                i
                             );

                try
                {
                    //
                    // Pull the records in the range from the WINS
                    //
                    PullAndUpdateDb(
                           &DlgHdl,
                           &OwnerWinsAdd,
                           pStartBuff,
                           i,
                           MinVersNo,
                           MaxVersNo,
                           RplType,
                           NoOfLocalDbRecs,
                           CurrentTime,
                           pScvParam,
                           fNonOwnerPnr,
                           &TotPulledRecsFromOneWins
                                      );
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    // just in case some exception is raised while pulling the records,
                    // bail this owner only, not the entire scavenge process
                    FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                    break;
                }

                if (!fPulledAtLeastOnce)
                {
                      fPulledAtLeastOnce = TRUE;
                }
                //
                // deallocate the memory block that was  allocated
                //
                // NmsDbGetDataRecs always allocates a buffer (even if
                // the number of records is 0).  Let us deallocate it
                //
                FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);

                //
                // Make the min. version number 1 more than the the
                // max. vers. no. we used last time
                //
                NMSNMH_INC_VERS_NO_M(MaxVersNo, MinVersNo);

               } while (LiLtr(MaxVersNo,MaxVersNoSave));

               if (fDlgStarted)
               {
                 ECommEndDlg(&DlgHdl);
                 fDlgStarted = FALSE;
               }
               if ((WinsCnf.LogDetailedEvts > 0) &&
                   fPulledAtLeastOnce)
               {
                    WinsEvtLogDetEvt(TRUE, WINS_EVT_CC_NO_RECS, NULL,
                           __LINE__, "ddd", TotPulledRecsFromOneWins,
                             OwnerWinsAdd.Add.IPAdd, VerifyWinsAdd.Add.IPAdd);

                    DBGPRINT3(SCV, "VerifyDbData: WINS pulled (%d) records owned by WINS= (%x) from WINS = (%x) for doing CC\n",
TotPulledRecsFromOneWins, OwnerWinsAdd.Add.IPAdd, VerifyWinsAdd.Add.IPAdd);
              }

              //
              // Total no. of records pulled so far
              //
              TotNoOfPulledRecs += TotPulledRecsFromOneWins;
       } //end of for loop for looping over owners

       //
       // We are done for this cycle.  If this was a CC verify, set
       // sFirstOwnerId to the index of the WINS to start from in the next
       // periodic CC cycle
       //
       if (fPeriodicCC)
       {
          sFirstOwnerId = i;
       }


 }  // end of try
except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("VerifyDbData");
        DBGPRINT2(EXC, "VerifyDbData:  i is (%d),  MaxOwnerIdFound is (%d)\n",i, MaxOwnerIdFound);

        // make sure any previous thread heap is cleaned up before getting out of this call
        if (pTls->HeapHdl != NULL)
        {
            // destroying the heap deletes all the memory allocated in it
            WinsMscHeapDestroy(pTls->HeapHdl);
            pTls->HeapHdl = NULL;
        }

        //--ft: bug #422659--
        // if an exception happens between EstablishCommForVerify and ECommEndDlg
        // we need to make sure we close the connection - otherwise the connection
        // remains active and the sender WINS eventually get stucked in send().
        if (fDlgStarted)
            ECommEndDlg(&DlgHdl);

        WINS_RERAISE_EXC_M();
        }

        // make sure any previous thread heap is cleaned up before getting out of this call
        if (pTls->HeapHdl != NULL)
        {
            // destroying the heap deletes all the memory allocated in it
            WinsMscHeapDestroy(pTls->HeapHdl);
            pTls->HeapHdl = NULL;
        }

        //
        // Set the priority back the old level
        //
        WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          pScvParam->PrLvl
                         );

        DBGLEAVE("VerifyDbData\n");
        return(WINS_SUCCESS);
} // VerifyDbData()

STATUS
PickWinsToUse(
 IN PCOMM_ADD_T pVerifyWinsAdd,
 IN PCOMM_ADD_T pOwnerWinsAdd,
 IN BOOL        fUseRplPnrs,
 OUT LPBOOL     pfNonOwnerPnr,
 OUT LPBOOL     pfRplType
 )

/*++

Routine Description:
  This function picks a WINS to verify the active replicas with

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
    PRPL_CONFIG_REC_T  pRplPnr;
    DWORD              IndexOfPnrToUse;
    STATUS             RetStat = WINS_SUCCESS;

    *pfNonOwnerPnr = FALSE;

    DBGENTER("PickWinsToUse\n");
    //
    // If the admin. specified that we should just use
    // our replication partners for consistency checking,
    // pick a replication partner for this.
    //

    *pfNonOwnerPnr = FALSE;
    EnterCriticalSection(&WinsCnfCnfCrtSec);
    try {
       pRplPnr = RplGetConfigRec(RPL_E_PULL, NULL, pOwnerWinsAdd);
       if (fUseRplPnrs)
       {
         //
         // If this guy is not a partner but there are other partners that
         // we can pick from, pick one
         //
         if (pRplPnr == NULL)
         {
               if (WinsCnf.PullInfo.NoOfPushPnrs > 0)
               {
                 //
                 // Just use one of the pnrs.  Pick one at
                 // random
                 //
                 *pfRplType     = WinsCnf.PullInfo.RplType;

                 srand((unsigned)time(NULL));
                 IndexOfPnrToUse = rand() % WinsCnf.PullInfo.NoOfPushPnrs;

                 *pVerifyWinsAdd = ((PRPL_CONFIG_REC_T)((LPBYTE)WinsCnf.PullInfo.pPullCnfRecs + (IndexOfPnrToUse * RPL_CONFIG_REC_SIZE)))->WinsAdd;


                 *pfNonOwnerPnr = TRUE;
               }
               else
               {
                   DBGPRINT0(ERR, "PickWinsToUse: CC checking NOT DONE since no partners are there\n");
                   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CC_FAILED);
                   RetStat = WINS_FAILURE;
               }
         }
         else
         {
            *pfRplType = pRplPnr->RplType;

         }
       } // if (fUseRplPnr)
       else
       {
          *pfRplType = (pRplPnr != NULL) ? pRplPnr->RplType : WinsCnf.PullInfo.RplType;
       }
  } // end if try {..}
  finally {
          LeaveCriticalSection(&WinsCnfCnfCrtSec);

          if (RetStat == WINS_SUCCESS)
          {
            //
            // If we are to communicate with the owner WINS, set *pVerifyWinsAdd
            // since it was not set above.
            //
            if (!*pfNonOwnerPnr)
            {
              *pVerifyWinsAdd = *pOwnerWinsAdd;
            }
            DBGPRINT3(DET, "VerifyDbData: Using pnr no = (%d) with address = (%x) for verification of records owned by WINS (%x)\n", IndexOfPnrToUse, pVerifyWinsAdd->Add.IPAdd, pOwnerWinsAdd->Add.IPAdd)
          }
  }
  DBGLEAVE("PickWinsToUse\n");
  return (RetStat);
} //PickWinsToUse()

STATUS
EstablishCommForVerify(
  PCOMM_ADD_T pWinsAdd,
  PCOMM_HDL_T pDlgHdl
)

/*++

Routine Description:
    This function is called to setup communication with a WINS

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
     //DWORD  NoOfRetries = 0;
     BOOL   fAbort = FALSE;
     STATUS RetStat = WINS_SUCCESS;

     DBGENTER("EstablishCommForVerify\n");
     //
     // We try a certain number of times to establish a
     // a dialogue.  Currently, it is 1.
     //
     do
     {
          try {
             ECommStartDlg( pWinsAdd, WINS_E_NMSSCV, pDlgHdl );
          }
          except(EXCEPTION_EXECUTE_HANDLER) {
             DBGPRINTEXC("VerifyDbData");
             if (GetExceptionCode() == WINS_EXC_COMM_FAIL)
             {
               DBGPRINT1(EXC, "VerifyDbData: Could not start a dlg with WINS at address (%x)\n", pWinsAdd->Add.IPAdd);

               //--ft: 07/10/00 commented out since VERIFY_NO_OF_RETRIES is 0 anyhow so the test is always false.
               //if (NoOfRetries++ < VERIFY_NO_OF_RETRIES)
               //{
               //       Sleep(VERIFY_RETRY_TIME_INTERVAL);
               //       continue;
               //}
               RetStat = WINS_FAILURE;
            }
            else
            {
               //
               // This is a serious error. Log and abort the verify cycle
               //
               WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
               RetStat = WINS_FAILURE;
            }
        } // end of exception handler
        break;
    } while (TRUE);
    if (RetStat == WINS_FAILURE)
    {
        DBGPRINT1(ERR, "EstablishCommForVerify: Could not start dlg with WINS at address (%x)\n", pWinsAdd->Add.IPAdd);
    }
     DBGLEAVE("EstablishCommForVerify\n");
     return(RetStat);
}  // EstablishCommForVerify()

VOID
PullAndUpdateDb(
  PCOMM_HDL_T  pDlgHdl,
  PCOMM_ADD_T  pOwnerWinsAdd,
  PRPL_REC_ENTRY_T pRspBuff,
  DWORD        WinsIndex,
  VERS_NO_T    MinVersNo,
  VERS_NO_T    MaxVersNo,
  DWORD        RplType,
  DWORD        NoOfLocalDbRecs,
  time_t       CurrentTime,
  PNMSSCV_PARAM_T pScvParam,
  BOOL         fNonOwnerPnr,
  LPDWORD      pTotNoPulledFromOneWins
 )

/*++

Routine Description:
   This pulls the records in the range specified and then updates the db
   accordingly

Arguments:

Externals Used:
	None

	
Return Value:

  NONE

Error Handling:

Called by:
        VerifyDbData()
Side Effects:

Comments:
	None
--*/

{

      LPBYTE                  pBuffOfPulledRecs;
      VERS_NO_T               VersNo;
      DWORD                   NoOfPulledRecs;

      DBGENTER("PullAndUpdateDb\n");
      while (TRUE)
      {
             //
             //Pull the records in the range min-max determined
             //above
             //
             RplPullPullEntries(
                                    pDlgHdl,
                                    WinsIndex,
                                    MaxVersNo,
                                    MinVersNo,
                                    WINS_E_NMSSCV,
                                    &pBuffOfPulledRecs,
                                    FALSE,     //do not want to update counters
                                    RplType
                                  );


             //
             // Update the DB. All valid records are updated.
             // The invalid  records  are deleted from the db
             //

             ChkConfNUpd(
#if SUPPORT612WINS > 0
                      pDlgHdl,
#endif
                      pOwnerWinsAdd,
                      RplType,
                      WinsIndex,
                      &pRspBuff,
                      pBuffOfPulledRecs,
                      &NoOfLocalDbRecs,
                      CurrentTime,
                      pScvParam->VerifyInterval,
                      fNonOwnerPnr,
                      &NoOfPulledRecs,
                      &VersNo
                         );

             *pTotNoPulledFromOneWins += NoOfPulledRecs;

              //
              // Free the response buffer
              //
              ECommFreeBuff(pBuffOfPulledRecs - COMM_HEADER_SIZE);

              //
              //If vers. no. pulled is smaller than the Max. Vers
              //no, specified, check if it is because of the limit
              //we have set  for the max. number or records that
              //can be replicated  at a time.  If yes, pull again.
              //
              if (
                           LiLtr(VersNo, MaxVersNo)
                                      &&
                          (NoOfPulledRecs == RPL_MAX_LIMIT_FOR_RPL)
                 )
              {
                       MinVersNo = VersNo;
                       NMSNMH_INC_VERS_NO_M(MinVersNo, MinVersNo);
                       continue;
              }
              break;   //break out of the loop
      } //end of while (pulled all records in the range from pnr)_
      DBGLEAVE("PullAndUpdateDb\n");
      return;
} // PullAndUpdateDb()

__inline
VOID
FreeDbMemory(
     LPVOID pStartBuff,
     DWORD  NoOfLocalDbRecs,
     PWINSTHD_TLS_T pTls
 )

/*++

Routine Description:
   Frees the memory allocated by NmsDbGetDataRecs()

Arguments:


Externals Used:
	None

	
Return Value:

       NONE

Error Handling:

Called by:
           VerifyDbData()
Side Effects:

Comments:
	None
--*/

{
       PRPL_REC_ENTRY_T        pRec;
       DWORD                   RecCnt;

       for (
               RecCnt=0, pRec = pStartBuff;
               RecCnt < NoOfLocalDbRecs;
               RecCnt++
           )
       {
            WinsMscHeapFree(pTls->HeapHdl, pRec->pName);
            pRec = (PRPL_REC_ENTRY_T)( (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE );
       }
       WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
       WinsMscHeapDestroy(pTls->HeapHdl);
       pTls->HeapHdl = NULL;
       return;
} // FreeDbMemory ()

VOID
ChkConfNUpd(
#if SUPPORT612WINS > 0
        IN PCOMM_HDL_T pDlgHdl,
#endif
        IN  PCOMM_ADD_T         pOwnerWinsAdd,
        IN  DWORD               RplType,
        IN  DWORD               OwnerId,
        IN  PRPL_REC_ENTRY_T    *ppLocalDbRecs,
        IN  LPBYTE              pRspBuff,
        IN  DWORD               *pNoOfLocalDbRecs,
        IN  time_t              CurrentTime,
        IN  DWORD               VerifyTimeIntvl,
        IN  BOOL                fNonOwnerPnr,
        OUT LPDWORD             pNoOfPulledRecs,
        OUT PVERS_NO_T          pMaxVersNo
        )
/*++

Routine Description:
        This function compares the records that have been pulled from
        a WINS with those in its local db.  If the comparison is successful,
        the record's timestamp in the local db is updated.  If the
        comparison is unsuccessful (i.e. the record in the local db has
        no match in the list of records pulled from the remote WINS, the
        record is deleted in the local db

Arguments:
        pLocalDbRecs - Address of buffer holding the local active replicas
        pRspBuff     - Buffer containing records pulled from the remote WINS
        NoOfLocalDbRecs - No of local replicas in the above buffer


Externals Used:
        None

Return Value:
        NONE

Error Handling:

Called by:
        VerifyDbData()

Side Effects:

Comments:
        None
--*/
{
        DWORD            NoOfPulledRecs;
        BYTE             Name[NMSDB_MAX_NAM_LEN];
        DWORD            NameLen;
        BOOL             fGrp;
        DWORD            NoOfAdds;
        COMM_ADD_T       NodeAdd[NMSDB_MAX_MEMS_IN_GRP * 2];  //twice the # of
        VERS_NO_T        VersNo;
        LPBYTE           pTmp = pRspBuff + 4;                //past the opcode
        DWORD            i, j;
        PRPL_REC_ENTRY_T pRecLcl;
        DWORD            NoOfRecsDel = 0;
        PRPL_REC_ENTRY_T pStartOfLocalRecs = *ppLocalDbRecs;
        DWORD            MvNoOfLocalDbRecs = *pNoOfLocalDbRecs;
        DWORD            Flag;
        DWORD            NoOfRecsUpd = 0;
        DWORD            NoOfRecsIns = 0;
        struct in_addr   InAddr;
#if SUPPORT612WINS > 0
    BOOL       fIsPnrBeta1Wins;
#endif

        DBGENTER("ChkConfNUpd\n");


        //
        // Set the current index to be the clustered index
        //
        NmsDbSetCurrentIndex(
                        NMSDB_E_NAM_ADD_TBL_NM,
                        NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
#if SUPPORT612WINS > 0
    COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fIsPnrBeta1Wins);
#endif

        /*
         * Get the no of records from the response and also the first record
         * if there is at least one record in the buffer
        */
        RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                        &pTmp,
                        &NoOfPulledRecs,
                        Name,
                        &NameLen,
                        &fGrp,
                        &NoOfAdds,
                        NodeAdd,
                        &Flag,
                        &VersNo,
                        TRUE /*Is it first time*/
                               );


        if (WinsCnf.LogDetailedEvts > 0)
        {
            PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
            PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
            DWORD IpPartner = pAssocCtx->RemoteAdd.sin_addr.s_addr;

            WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_PULLED, TEXT("Verification"), __LINE__, "ddd", IpPartner, pOwnerWinsAdd->Add.IPAdd, NoOfPulledRecs);
        }

        DBGPRINT3(SCV, "ChkConfNUpd: pulled Records - (%d), local records - (%d), local records Buf (%p)\n",
                        NoOfPulledRecs, *pNoOfLocalDbRecs, pStartOfLocalRecs);


        *pNoOfPulledRecs = NoOfPulledRecs;
        if (NoOfPulledRecs > 0)
        {

                NMSSCV_REC_ACTION_E RecAction_e;


                //
                // After this function returns, all local records that have
                // a version number < the version record of the pulled record
                // will be marked deleted.  Also, if there is a local record
                // with the same version number as the pulled record but a
                // different name it will be marked for deletion and fAddDiff
                // will be set to TRUE so that we register the pulled record
                // A local record with the same name and version number as
                // the pulled one will be updated (timestamp only) in the db.
                //
                CompareWithLocalRecs(
                                VersNo,
                                Name,
                                NMSDB_ENTRY_STATE_M(Flag),
                                &pStartOfLocalRecs,
                                &MvNoOfLocalDbRecs,
                                CurrentTime,
                                fNonOwnerPnr,
                                &NoOfRecsDel,
                                &RecAction_e
                              );
                //
                // If RecAction_e is NMSSCV_E_INSERT and the record is
                // marked as DELETED, it means that the pulled record
                // has the same version number but a different name.
                // This should never happen in a consistent system of
                // WINS servers.  The fact that it happened means that
                // the administrator has goofed up.  The remote WINS server
                // has started afresh (new database) or its database got
                // corrupted.  If any of the above did happen, the
                // administrator should have made sure that at startup,
                // the WINS server was starting from a version counter
                // value that was not less than what any of the other WINS
                // servers thought it to be in.
                //
                // To bring the database upto snuff, this WINS server will
                // register this replica.  If there is a clash, it will
                // be handled appropriately.  One can think of this as
                // a pulling in of replicas at replication time.
                //
                for (
                        i = 0, pRecLcl = *ppLocalDbRecs;
                        pRecLcl < pStartOfLocalRecs;
                        i++
                    )
                {
                    //
                    //
                    // We update/delete the record depending upon the
                    // Flag value set by Compare
                    // not interested in the return code
                    //
                    pRecLcl->NewTimeStamp = (DWORD)CurrentTime + VerifyTimeIntvl;
                    NmsDbQueryNUpdIfMatch(
                                pRecLcl,
                                THREAD_PRIORITY_NORMAL,
                                FALSE,        //don't change pr. lvl
                                WINS_E_NMSSCV
                                );
                    NoOfRecsUpd++;
                    pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl +
                                        RPL_REC_ENTRY_SIZE);

                }

                //
                // register the replica if it needs to be inserted
                //
                if (RecAction_e == NMSSCV_E_INSERT)
                {
                        RplPullRegRepl(
                                        Name,
                                        NameLen,
                                        Flag,
                                        OwnerId,
                                        VersNo,
                                        NoOfAdds,
                                        NodeAdd,
                                        pOwnerWinsAdd,
                                        RplType
                                     );
                         NoOfRecsIns++;
                }

                //
                // Do until we have covered all the local records.
                //
                for (i=1; MvNoOfLocalDbRecs > 0; i++)
                {
                        //
                        // if we have retrieved all the pull records, use a
                        // version number that is > the highest in the local
                        // db recs cache so that all the records more than
                        // the highest version # pulled get deleted -
                        // Check out CompareWithLocalRecs()
                        //
                        if (i < NoOfPulledRecs)
                        {
                          RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                                fIsPnrBeta1Wins,
#endif
                                &pTmp,
                                &NoOfPulledRecs,
                                Name,
                                &NameLen,
                                &fGrp,
                                &NoOfAdds,
                                NodeAdd,
                                &Flag,
                                &VersNo,
                                FALSE /*Is it first time*/
                                       );

                         }
                         else
                         {
                               //
                               // Find out if this is the end of replica records.
                               // if we pulled exactly RPL_MAX_LIMIT_FOR_RPL, then that
                               // may mean that there is more to come. In that case we just
                               // get out of the loop and pull next lot.
                               //
                               // otherwise, this is the last record from the replica.
                               // we set VerNo to highest value so that all the local records
                               // more than the highest vers no of the pulled records get
                               // deleted.
                               //
                               if ( RPL_MAX_LIMIT_FOR_RPL == NoOfPulledRecs )
                               {
                                   break;
                               } else {
                                   if (VersNo.HighPart != MAXLONG)
                                   {
                                     VersNo.LowPart  = MAXULONG;
                                     VersNo.HighPart = MAXLONG;
                                   }
                               }
                         }
                        //
                        //See if there is a hit with a local record.  If there
                        //is a hit, we update the time stamp of the hit
                        //record, else we delete it
                        //
                        // First set, pRecLcl to the address of the first
                        // local record since pStartOfLocalRecs can be changed
                        // by this function. Actually, there is no need to
                        // do this. pRecLcl will be set already
                        //
                        pRecLcl = pStartOfLocalRecs;
                        CompareWithLocalRecs(
                                VersNo,
                                Name,
                                NMSDB_ENTRY_STATE_M(Flag),
                                &pStartOfLocalRecs,
                                &MvNoOfLocalDbRecs,
                                CurrentTime,
                                fNonOwnerPnr,
                                &NoOfRecsDel,
                                &RecAction_e
                              );


                         //
                         // All records upto the new first local record should
                         // be updated/deleted
                         //
                         for (
                                j = 0;
                                pRecLcl < pStartOfLocalRecs;
                                j++
                                )
                         {
                                  //
                                  //We update/delete the record depending
                                  //upon the Flag value set by Compare
                                  // not interested in the return code
                                  //

                                  pRecLcl->NewTimeStamp = (DWORD)CurrentTime + VerifyTimeIntvl;
                                  NmsDbQueryNUpdIfMatch(
                                                pRecLcl,
                                                THREAD_PRIORITY_NORMAL,
                                                FALSE,   //don't change pr. lvl
                                                WINS_E_NMSSCV
                                                );
                                  NoOfRecsUpd++;
                                  pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl +
                                                        RPL_REC_ENTRY_SIZE);

                        }

                        //
                        // register the replica if it needs to be inserted
                        //
                        if (RecAction_e == NMSSCV_E_INSERT)
                        {
                                RplPullRegRepl(
                                        Name,
                                        NameLen,
                                        Flag,
                                        OwnerId,
                                        VersNo,
                                        NoOfAdds,
                                        NodeAdd,
                                        pOwnerWinsAdd,
                                        RplType
                                        );
                               NoOfRecsIns++;
                        }
                }

                //
                // Whatever records were not retrieved must be retrieved
                // now and then inserted
                //
                for (j=i; j < NoOfPulledRecs; j++)
                {

                          RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                                fIsPnrBeta1Wins,
#endif
                                &pTmp,
                                &NoOfPulledRecs,
                                Name,
                                &NameLen,
                                &fGrp,
                                &NoOfAdds,
                                NodeAdd,
                                &Flag,
                                &VersNo,
                                FALSE /*Is it first time*/
                                       );

                                RplPullRegRepl(
                                        Name,
                                        NameLen,
                                        Flag,
                                        OwnerId,
                                        VersNo,
                                        NoOfAdds,
                                        NodeAdd,
                                        pOwnerWinsAdd,
                                        RplType
                                        );
                               NoOfRecsIns++;

                }
        }
        else // we got 0 records from the remote WINS server.  It means that
             // all the active replicas for this WINS need to be deleted
        {
               //
               // We delete records only if the pnr with which we are doing
               // verification is the owner of the records
               //
               VersNo.QuadPart  = 0;
               if (!fNonOwnerPnr)
               {
                pRecLcl = *ppLocalDbRecs;

                //
                // Change state of all replicas that we retrieved to deleted
                //
                for (i = 0; i < *pNoOfLocalDbRecs; i++)
                {
                        NMSDB_SET_STATE_M(pRecLcl->Flag,  NMSDB_E_DELETED);

                        //
                        //
                        // We update/delete the record depending upon the
                        // Flag value set by Compare
                        // not interested in the return code
                        //
                        NmsDbQueryNUpdIfMatch(
                                pRecLcl,
                                THREAD_PRIORITY_NORMAL,
                                FALSE,        //don't change pr. lvl
                                WINS_E_NMSSCV
                                );
                        pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl +
                                        RPL_REC_ENTRY_SIZE);
                        NoOfRecsDel++;
                }
               }

        }

        //
        // Update our couters/pointers for the next iterations.
        // see PullAndUpdateDb routine.
        //
        *pMaxVersNo = VersNo;
        *ppLocalDbRecs = pStartOfLocalRecs;
        *pNoOfLocalDbRecs = MvNoOfLocalDbRecs;

        if (WinsCnf.LogDetailedEvts > 0)
        {
           InAddr.s_addr = htonl(pOwnerWinsAdd->Add.IPAdd);
           WinsEvtLogDetEvt(TRUE, WINS_EVT_CC_STATS, NULL, __LINE__, "sddd", inet_ntoa(InAddr), NoOfRecsIns, NoOfRecsUpd, NoOfRecsDel);

        }
        DBGPRINT4(DET, "ChkConfNUpd: Wins = (%s). NO OF RECS INSERTED = (%d); NO OF RECORDS UPDATED = (%d); NO OF RECS DELETED = (%d)\n", inet_ntoa(InAddr), NoOfRecsIns, NoOfRecsUpd,  NoOfRecsDel);



        DBGLEAVE("ChkConfNUpd\n");

        return;
} // ChkConfNUpd()

VOID
CompareWithLocalRecs(
        IN     VERS_NO_T            VersNo,
        IN     LPBYTE               pName,
        IN     NMSDB_ENTRY_STATE_E  RecState_e,
        IN OUT PRPL_REC_ENTRY_T     *ppLocalDbRecs,
        IN OUT DWORD                *pNoOfLocalRecs,
        IN     time_t               CurrentTime,
        IN     BOOL                 fNonOwnerPnr,
        IN OUT DWORD                *pNoOfRecsDel,
        OUT    PNMSSCV_REC_ACTION_E     pRecAction_e
        )

/*++

Routine Description:
        This function checks if the pulled record is in the buffer containing
        local active replicas.  If it is, it is marked for update (timestamp)
        If it is not, then all replicas in the buffer that have a version
        stamp < the pulled record are marked for deletion

Arguments:
        VersNo       - Version no. of the pulled record
        pName        - Name in the pulled record
        ppLocalDbRecs - ptr to address of buffer containing one or more
                        local active replicas
        pNoOfLocalRecs - count of records in the above buffer
        pNoOfRecsDel   - count of records to be deleted

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        ChkConfNUpd()

Side Effects:

Comments:
        None
--*/

{

        DWORD                        i;
        PRPL_REC_ENTRY_T        pRecLcl = *ppLocalDbRecs;
#ifdef UNICODE
        WCHAR        NameLcl[WINS_MAX_FILENAME_SZ];
        WCHAR        NameRem[WINS_MAX_FILENAME_SZ];
#endif

        //
        // default is don't insert.
        //
        *pRecAction_e = NMSSCV_E_DONT_INSERT;

        //
        // Loop over all local replicas
        //
        for(i=0; i < *pNoOfLocalRecs; i++)
        {
                //
                // if version number of pulled record is less, we should get the
                // next pulled record from the response buffer. We should
                // insert this one into our db
                //
                if (LiLtr(VersNo, pRecLcl->VersNo))
                {

#if 0
                        //
                        // We don't insert tombstones
                        //
                        if (RecState_e == NMSDB_E_ACTIVE)
#endif
                        //
                        // Even tombstones are inserted because we may
                        // have just got rid of the active record (lower
                        // version number than this tombstone). The above
                        // is TRUE only when pulling from an owner WINS
                        //
                        if ((RecState_e == NMSDB_E_ACTIVE) || !fNonOwnerPnr)
                        {
                           *pRecAction_e = NMSSCV_E_INSERT;
                        }
                        break;
                }
                else
                {
                  //
                  // if version number is same, we need to update this record
                  // in our local db.  We mark it for update. Caveat:
                  // if we are verifying with a non-owner, we don't mark
                  // record for deletion. We just keep it since we don't
                  // know who is more current (we or our replication partner)
                  //
                  if (LiEql(VersNo, pRecLcl->VersNo))
                  {
                        if (
                            !(RtlCompareMemory(pRecLcl->pName, pName,
                                   pRecLcl->NameLen) == pRecLcl->NameLen)
                                         &&
                             !fNonOwnerPnr
                           )
                        {
                                DBGPRINT2(DET, "CompareWithLocalRecs: Names are DIFFERENT. Name to Verify (%s), Name pulled (%s).\nThis could mean that the remote WINS server restarted with a vers. counter value < the value in the previous invocation.\n",
 pRecLcl->pName/*pRecLcl->Name*/, pName);
FUTURES("Replace the local record with the pulled record")
                                NMSDB_SET_STATE_M(pRecLcl->Flag, NMSDB_E_DELETED);
                                (*pNoOfRecsDel)++;

                                //
                                // Insert record regardless of its state
                                // (ACTIVE or TOMBSTONE)
                                //
                                *pRecAction_e = NMSSCV_E_INSERT;

                        }
                        i++;  //increment i so that we don't compare the
                              //the next pulled record with all local records
                              //upto the one we just compared this pulled
                              //record with
                        break;
                  }
                  else
                  {
                        //
                        // For the non-owner case, since we don't know whether
                        // our pnr is more/less current than us, we don't delete
                        // the local record
                        //
                        if (!fNonOwnerPnr)
                        {
                          //
                          // version number is greater than record in
                          // our local db. We delete our local db record
                          //
                          NMSDB_SET_STATE_M(pRecLcl->Flag, NMSDB_E_DELETED);
                          (*pNoOfRecsDel)++;
                        }
                  }
                }
                pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl + RPL_REC_ENTRY_SIZE);
        }

        //
        // Adjust the pointer in the buffer of local replicas so that next
        // time we are called in this verify cycle, we don't look at
        // the replicas we have already seen. Also, adjust the count.
        //
        *ppLocalDbRecs = (PRPL_REC_ENTRY_T)(
                           (LPBYTE)(*ppLocalDbRecs) + (i * RPL_REC_ENTRY_SIZE)
                                           );
        *pNoOfLocalRecs = *pNoOfLocalRecs - i;
        return;

} //CompareWithLocalRecs


VOID
DoBackup(
        PNMSSCV_PARAM_T  pScvParam,
        LPBOOL           pfThdPrNormal
      )
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        time_t CurrentTime;

        (void)time(&CurrentTime);

        // if logging is on and a backup path is provided, do a backup every 24hr
        if (WinsCnf.fLoggingOn && (CurrentTime - sLastDbBackupTime) > PERIOD_OF_BACKUP)
        {
#ifdef WINSDBG
            IF_DBG(HEAP_CNTRS)
            {
                WinsSetFlags(WINSINTF_MEMORY_INFO_DUMP | WINSINTF_HEAP_INFO_DUMP | WINSINTF_QUE_ITEMS_DUMP);
            }
#endif
            DBGPRINT0(DET, "DoBackup: Will do scheduled backup now\n");
            if (!*pfThdPrNormal)
            {
                // Set thread priority back to normal
                WinsMscSetThreadPriority(WinsThdPool.ScvThds[0].ThdHdl, THREAD_PRIORITY_NORMAL);
                *pfThdPrNormal = TRUE;
            }
            if (pScvParam->BackupDirPath[0] != EOS)
            {
                if (NmsDbBackup(pScvParam->BackupDirPath, NMSDB_FULL_BACKUP) == WINS_SUCCESS)
                    sLastDbBackupTime = CurrentTime;
            }
        }

        return;
}

#if MCAST > 0
VOID
DoMcastSend(
   DWORD_PTR CurrentTime,
   DWORD Code,
   DWORD fNow
 )
{
  if (fNow || (CurrentTime - sLastMcastTime) >=  sMcastIntvl)
  {
      CommSendMcastMsg(Code);
      if (!fNow)
      {
         sLastMcastTime = CurrentTime;
      }
  }
  return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\winswriter.cpp ===
// for some reason the compiler is not setting this #def when compiling this file
#define CPLUSPLUS

#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <jetwriter.h>
#include "winsdbg.h"
#include "winswriter.hpp"

//{f08c1483-8407-4a26-8c26-6c267a629741}
static const GUID g_GuidWinsWriter = 
{ 0xf08c1483, 0x8407, 0x4a26, { 0x8c, 0x26, 0x6c, 0x26, 0x7a, 0x62, 0x97, 0x41 } };

/////////////////////////////////////////////////////////////////
// Implementation of the CWinsVssJetWriter starts here
//
HRESULT CWinsVssJetWriter::Initialize()
{
    HRESULT hr = S_OK;

    hr = CVssJetWriter::Initialize(
            g_GuidWinsWriter,
            WINSWRITER_NAME,
            TRUE,
            FALSE,
            L"",
            L"");

    return hr;
}

HRESULT CWinsVssJetWriter::Terminate()
{
    CVssJetWriter::Uninitialize();

    return S_OK;
}

//
// Implementation of the CWinsVssJetWriter ends here
/////////////////////////////////////////////////////////////////

// writer instance
static CWinsVssJetWriter   g_WinsWriter;

extern "C" DWORD _cdecl WinsWriterInit()
{
    HRESULT hr = S_OK;

    DBGENTER("WinsWriterInit\n");

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        DBGPRINT1(ERR,"CoInitializeEx failed with hr=%x.\n", hr);
        return HRESULT_CODE(hr);
    }

    hr = CoInitializeSecurity(
			NULL,
			-1,
			NULL,
			NULL,
			RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_IMP_LEVEL_IDENTIFY,
			NULL,
			EOAC_NONE,
			NULL);

    if (FAILED(hr))
    {
        DBGPRINT1(ERR,"CoInitializeSecurity failed with hr=%x.\n", hr);
        return HRESULT_CODE(hr);
    }

    hr = g_WinsWriter.Initialize();
    DBGPRINT1(FLOW,"Vss writer Initialize: code hr=0x%08x\n", hr);

    DBGLEAVE("WinsWriterInit\n");

    return HRESULT_CODE(hr);
}

extern "C" DWORD _cdecl WinsWriterTerm()
{
    DBGENTER("WinsWriterTerm\n");

    g_WinsWriter.Terminate();

    CoUninitialize();

    DBGLEAVE("WinsWriterTerm\n");

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\nms\nmsdb.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:
        nmsdb.c



Abstract:

        This module contains the functions used to interface with the
        database engine of choice.  Currently that engine is the JetBlue
        engine

Functions:
        NmsDbInit
        NmsDbInsertRowInd
        NmsDbInsertRowGrp
        NmsDbRelRow
        NmsDbQueryRow
        NmsDbUpdateRow
        NmsDbSeekNUpdateRow
        NmsDbGetDataRecs
        StoreGrpMems
        CreateTbl
        InitColInfo
        ReadOwnAddTbl
        NmsDbWriteOwnAddTbl
        NmsDbThdInit
        UpdateDb
        NmsDbUpdateVersNo
        NmsDbEndSession
        GetGrpMem
        NmsDbRelRes
        GetMaxVersNos
        InsertGrpMemsInCol
        NmsDbSetCurrentIndex
        NmsDbUpdNQueryIfMatch
        SetSystemParams

Portability:

        This module is portable to different platforms.
        It is not portable across different engines


Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/


/*
        Includes
*/
#include <time.h>
#include <stdio.h>
#include <ctype.h>
#include "wins.h"
#include "nms.h"
#include "nmsnmh.h"
#include "winsthd.h"        //

#include "esent.h"        //blue jet engine's header file

#include "nmsdb.h"        //
#include "winsmsc.h"        //
#include "winscnf.h"        //
#include "winsevt.h"        //
#include "comm.h"        //
#include "rpl.h"
#include "rplpull.h"
#include "rplpush.h"
#include "winsintf.h"
#include "winswriter.hpp"
#include "nmfilter.h"

/*
 *        Local Macro Declarations
 */
#define NAMUSR                "admin"
#define PASSWD                ""

#define SYS_DB_PATH        ".\\wins\\system.mdb"
#define TEMP_DB_PATH       ".\\wins\\winstmp.mdb"
#define CHKPOINT_PATH      ".\\wins"
#define LOGFILE_PATH       CHKPOINT_PATH

// this constants are gone from the jet600 (ese.h) header file. But we still need
// these constants for jet500/jet200 code path.
#define JET_bitIndexClustered		0x00000010
#define JET_bitCommitFlush          0x00000001  /* commit and flush page buffers. */

#define INIT_NO_PAGES_IN_DB         1000        //initial size of database in pages
#define MAX_FIXED_FLD_LEN        255        //maximum size of a fixed field



#define PAD_FOR_REC_HEAP        1000        //pad to use when creating the
                                        //heap for getting records from
                                        //the db.  This pad is to take
                                        //care of heap creation overhead
                                        // and for allocating memory for
                                        // group members.


#define MAX_RECS_BEFORE_COMMIT    100    //max records to retrieve in
                                         //NmsDbGetDataRecs before doing a
                                         //commit
//
// Owner Id of the special record that stores the version number
// of an owned record deleted or replaced with a replica
//

//
// Don't want to wrap around to a negative number. Keep a pad of 16 just
// for the heck of it.
//
#define OWNER_ID_OF_SPEC_REC        0x7FFFFFF0
#define OWNER_ID_OF_SPEC_REC_OLD   250

//
// This determines the max. size (in bytes) of the buffer allocated the
// first time a  range of records need to retrived.
//
#define INIT_NO_OF_ENTRIES        1000

#define NO_COLS_NAM_ADD_TBL         6        //no. of cols in Name Ip table
#define NO_COLS_OWN_ADD_TBL         5        //no. of cols in Name Ip table

//
// Passed as third arg to JetCreateDatabase
//
#define CONNECT_INFO         ";COUNTRY=1; LANGID=0x0409; CP=1252"

//
// Maximum number of sessions that can be active at any one time
//
// There can be a max of MAX_CNCRNT_STATIC_INITS (3 currently; check
// winsintf.c) going on at any one time.
//
#define  MAX_NO_SESSIONS        (NMS_MAX_RPC_CALLS + WINSTHD_MAX_NO_NBT_THDS + \
                                 WINSTHD_NO_RPL_THDS + WINSTHD_NO_SCV_THDS +\
                                 WINSTHD_NO_CHL_THDS + WINSCNF_MAX_CNCRNT_STATIC_INITS )


#pragma warning(4:4532)     // Turn off return from __finally block warning until this code is cleaned
                            // up to use __leave correctly.

#define RET_M(JetRetStat)                                        \
                {                                                \
              DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n", \
                                      (JetRetStat), __LINE__);                \
                 WINSEVT_LOG_M(JetRetStat, WINS_EVT_DATABASE_ERR);  \
                 return(WINS_FAILURE);                                \
                }


#define CALL_M(fn)                                                      \
                {                                                       \
                 JET_ERR _JetRetStat;                                   \
                 if ((_JetRetStat = (fn)) != JET_errSuccess)            \
                 {                                                      \
                        RET_M(_JetRetStat);                              \
                 }                                                      \
                }
// this macro always requires JetRetStat local variable to receive the return value.
#define CALL_N_JMP_M(fn, label)                                                      \
                {                                                       \
                 if ((JetRetStat = (fn)) != JET_errSuccess)            \
                 {                                                      \
                       DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n", \
                                      (JetRetStat), __LINE__);                \
                       WINSEVT_LOG_M(JetRetStat, WINS_EVT_DATABASE_ERR);  \
                       goto label;                                      \
                 }                                                      \
                }
#define CALL_N_RAISE_EXC_IF_ERR_M(fn)                                   \
                {                                                       \
                 JET_ERR _JetRetStat;                                   \
                 if ((_JetRetStat = (fn)) != JET_errSuccess)            \
                 {                                                      \
                   DBGPRINT2(ERR, "Jet Error: _JetRetStat is (%d). Line is (%d)\n", \
                                        _JetRetStat, __LINE__);         \
                   WINSEVT_LOG_M(_JetRetStat, WINS_EVT_DATABASE_ERR);   \
                   WINS_RAISE_EXC_M(WINS_EXC_FAILURE);                  \
                 }                                                      \
                }

#if 0
#define COMMIT_M(pSesId)                                                \
                {                                                       \
                        (JetRetStat) = JetCommitTransaction(            \
                                        *pSesId, JET_bitCommitFlush);   \
                        if (JetRetStat != JET_errSuccess)               \
                        {                                               \
                               DBGPRINT1(ERR, "COMMIT FAILED: JetRetStat is (%d). \n", \
                                        (JetRetStat));                  \
                                WINSEVT_LOG_M((JetRetStat), WINS_EVT_COMMIT_ERR);  \
                        }                                               \
                        pTls->fTransActive = FALSE;                     \
                }

#define ROLLBACK_M(pSesId)                                               \
                {                                                        \
                        WINS_TLS_T        _pTls;                         \
                        JET_SESID        _SessId;                        \
                        JET_ERR  _JetRetStat;                            \
                        if (pSesId == NULL) { GET_TLS_M(_pTls); ASSERT(_pTls != NULL)}                                                                     \
                        _JetRetStat = JetRollback(                         \
                                        _pTls->SesId, JET_bitRollbackAll));\
                        if (_JetRetStat != JET_errSuccess)                 \
                        {                                                  \
                               DBGPRINT1(ERR, "ROllBACK FAILED: JetRetStat is (%d). \n",                                                                   \
                                        _JetRetStat);                      \
                                WINSEVT_LOG_M(_JetRetStat, WINS_EVT_ROLLBACK_ERR);                                                                         \
                        }                                                  \
                        _pTls->fTransActive = FALSE;                       \
                }
#endif

#define JETRET_M(fn)                                                        \
                {                                                           \
                 JET_ERR _JetRetStat;                                       \
                 if ((_JetRetStat = (fn)) != JET_errSuccess)                \
                 {                                                          \
                   DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n",                                                                          \
                                        _JetRetStat, __LINE__);             \
                   WINSEVT_LOG_M(_JetRetStat, WINS_EVT_DATABASE_ERR);       \
                   return(_JetRetStat);                                     \
                 }                                                          \
                }


/*
 *        Local Typedef Declarations
 */


/*
 FLD_T -- describes various attributes of a fld/col of a table
*/
typedef struct _FLD_T {
        PBYTE                        pName;        //name of field
        WORD                        FldTyp;        //field type (unsigned byte, long, etc)
        BOOL                        fIndex; //Is it an index field
        BOOL                        fUnique;//Is the field value supposed to be unq
        PBYTE                        pIndex; //Index name
        PBYTE                        pb;
        DWORD                        Cb;
        DWORD                         Fid;    //field id.
        } FLD_T, *PFLD_T;


/*
 *        Global Variable Definitions
*/


/*
 NmsDbNoOfOwners -- This is the number of  owners that are in the
        owner id to address mapping table.  This variable is set
        by NmsDbInit (when it reads in the above table) and subsequently
        by the replicator

        This variable is protected by a critical section (not used at
        initialization time)

*/

DWORD   NmsDbNoOfOwners          = 0;  //No. of owners in the Nam - Add table


/*
 NmsDbOwnAddTbl -- This is the in-memory table that stores the mappings
                 between the owner id and the addresses.

                This table is initialized at init time with the database
                table NMSDB_OWN_ADD_TBL_NM if it exists.

                subsequently, more entries may be inserted into this
                table at replications as WINS learns of other WINS owners

                The insertions into this table are tagged at the end.
                In case of a configuration change, an entry may get
                flagged as DELETED, in which case it can be reused.
                This particular facet concering deletion is not
                operational currently

                This table is used by RPL_FIND_ADD_BY_OWNER_ID_M and
                by RplFindOwnrId

*/

PNMSDB_ADD_STATE_T      pNmsDbOwnAddTbl;
DWORD                   NmsDbTotNoOfSlots = NMSDB_MAX_OWNERS_INITIALLY;
CRITICAL_SECTION        NmsDbOwnAddTblCrtSec;

VERS_NO_T               NmsDbStartVersNo;
WINS_UID_T              NmsDbUid;

//
// Must be initialized to 0.  It is used by JetInit, JetBeginSession,
// JetGetSystemParameter, JetSetSystemParameter, and JetTerm
//
//  Only JetInit and JetSetSystemParameter take it by reference.  Only
//  JetInit modifies it (Cheen Liao - 2/2/94).
//
JET_INSTANCE            sJetInstance = 0;

/*
 Name of the database file.

 This name will be read from the registry.  For now, we are STATICally
 initializing the file name.
*/
FUTURES("when jet is internationalized, use WINSCNF_DB_NAME")
//BYTE        NmsDbDatabaseFileName[WINS_MAX_FILENAME_SZ] = WINSCNF_DB_NAME_ASCII;


//
// STATICs for storing information about the special record that stores the
// max. version number of an updated local record (one that got deleted or
// replaced by a replica)
//
STATIC BOOL        sfHighestVersNoRecExists = FALSE;

//
// Choose a name that is not likely to be used by any NBT client
//
STATIC LPBYTE        spHighestVersNoRecNameOld = "xx--WINS--xx";
STATIC LPBYTE        spHighestVersNoRecName = "xx--WINS--xx--DHCP--xx--DNS--xx--GARBAGE1--1EGABRAG";  //more than a valid netbios name can store

//
// Stores the version number stored in the special record.
//
STATIC VERS_NO_T sHighestVersNoSaved;

BOOL   fConvJetDbCalled;         //set to TRUE when the convert process has
                                 //been invoked. Checked in NmsDbInit
BOOL   fDbIs200;                 //set to TRUE when the convert process has
                                 //been invoked to convert 200 series db to latest format.
                                 //Checked in NmsDbInit.
BOOL   fDbIs500;                 //set to TRUE when the convert process has
                                 //been invoked to convert 500 series db to latest format.
                                 //Checked in NmsDbInit
/*
 *        Local Variable Definitions
 */

/*
 Values indicating the type of index to be formed on a field.
*/

#define CLUSTERED         0
#define NOINDEX                1
#define PRIMARYPART        2

/*
  sNamAddTblRow

  Metadata about table that maps Names to IP addresses

  Note: The third and fourth fields are not used even though they are
        initialized.
*/

STATIC FLD_T        sNamAddTblRow[NO_COLS_NAM_ADD_TBL] =
        {
        { "name",      JET_coltypBinary,       CLUSTERED,   TRUE, "dname"  },
        { "address",   JET_coltypLongBinary,   NOINDEX,     FALSE, NULL    },
        { "flags",     JET_coltypLong,         NOINDEX,     FALSE, NULL    },
#if NEW_OWID
        { "ownerid",   JET_coltypLong, PRIMARYPART, TRUE, "ownerid"},
#else
        { "ownerid",   JET_coltypUnsignedByte, PRIMARYPART, TRUE, "ownerid"},
#endif
        { "versionno", JET_coltypCurrency,     PRIMARYPART, FALSE,"Version"},
        { "timestamp", JET_coltypLong,         NOINDEX,     FALSE, NULL    }
        };

/*
 The index of various fields in a row of Name -- Add table
*/

#define NAM_ADD_NAME_INDEX       0
#define NAM_ADD_ADDRESS_INDEX    1
#define NAM_ADD_FLAGS_INDEX      2
#define NAM_ADD_OWNERID_INDEX    3
#define NAM_ADD_VERSIONNO_INDEX  4
#define NAM_ADD_TIMESTAMP_INDEX  5

/*
  sOwnAddTblRow

  Metadata about table that maps owner ids to addresses
*/
STATIC FLD_T        sOwnAddTblRow[NO_COLS_OWN_ADD_TBL] =
        {
#if NEW_OWID
        { "OwnerId",   JET_coltypLong, CLUSTERED, TRUE, "OwnerId"  },
#else
        { "OwnerId",   JET_coltypUnsignedByte, CLUSTERED, TRUE, "OwnerId"  },
#endif
        { "address",   JET_coltypBinary,       NOINDEX,   0,     "Address" },
        { "state",     JET_coltypUnsignedByte, NOINDEX,   0,     "State" },
        { "versionno", JET_coltypCurrency,     NOINDEX, FALSE,    "Version"},
        { "uid",       JET_coltypLong,         NOINDEX, FALSE,    "Uid"}
        };

#ifdef WINSDBG
DWORD   NmsDbDelDelDataRecs;
DWORD   NmsDbDelQueryNUpdRecs;
#endif

/*
 The index of various fields in a row of Owner Id -- Add table
*/

#define OWN_ADD_OWNERID_INDEX        0
#define OWN_ADD_ADDRESS_INDEX        1
#define OWN_ADD_STATE_INDEX        2
#define OWN_ADD_VERSIONNO_INDEX 3
#define OWN_ADD_UID_INDEX       4


#if DYNLOADJET

DYN_LOAD_JET_VERSION  DynLoadJetVersion = DYN_LOAD_JET_600;
int NAM_ADD_OWNERID_SIZE;
int OWN_ADD_OWNERID_SIZE;
LPBYTE BASENAME;


NMSDB_JETFTBL_T NmsDbJetFTbl[] = {
#if _X86_
Init,
"JetInit@4", 145, NULL,
Term,
"JetTerm@4", 167, NULL,
Term2,
"JetTerm2@8", 167, NULL,           //Jet200 does not have a JetTerm2
SetSystemParameter,
"JetSetSystemParameter@20", 165, NULL,
BeginSession,
"JetBeginSession@16", 104, NULL,
EndSession,
"JetEndSession@8", 124, NULL,
CreateDatabase,
"JetCreateDatabase@20", 112, NULL,
AttachDatabase,
"JetAttachDatabase@12", 102, NULL,
DetachDatabase,
"JetDetachDatabase@8", 121, NULL,
CreateTable,
"JetCreateTable@24", 115, NULL,
DeleteTable,
"JetDeleteTable@12", 120, NULL,
GetTableColumnInfo,
"JetGetTableColumnInfo@24", 137, NULL,
GetColumnInfo,
"JetGetColumnInfo@28", 127, NULL,
AddColumn,
"JetAddColumn@28", 101, NULL,
CreateIndex,
"JetCreateIndex@28", 113, NULL,
BeginTransaction,
"JetBeginTransaction@4", 105, NULL,
CommitTransaction,
"JetCommitTransaction@8", 109, NULL,
Rollback,
"JetRollback@8", 160, NULL,
CloseDatabase,
"JetCloseDatabase@12",  107, NULL,
CloseTable,
"JetCloseTable@8", 108, NULL,
OpenDatabase,
"JetOpenDatabase@20",  148, NULL,
OpenTable,
"JetOpenTable@28", 149, NULL,
Delete,
"JetDelete@8", 116, NULL,
Update,
"JetUpdate@20", 168, NULL,
RetrieveColumn,
"JetRetrieveColumn@32", 157, NULL,
SetColumn,
"JetSetColumn@28", 162, NULL,
PrepareUpdate,
"JetPrepareUpdate@12", 151, NULL,
GetCurrentIndex,
"JetGetCurrentIndex@16", 128, NULL,
SetCurrentIndex,
"JetSetCurrentIndex@12", 164, NULL,
Move,
"JetMove@16", 147, NULL,
MakeKey,
"JetMakeKey@20", 146, NULL,
Seek,
"JetSeek@12", 161, NULL,
Backup,
"JetBackup@12", 103, NULL,
Restore,
"JetRestore@8", 156, NULL
#else
Init,
"JetInit", 145, NULL,
Term,
"JetTerm", 167, NULL,
Term2,
"JetTerm2", 167, NULL,           //Jet200 does not have a JetTerm2
SetSystemParameter,
"JetSetSystemParameter", 165, NULL,
BeginSession,
"JetBeginSession", 104, NULL,
EndSession,
"JetEndSession", 124, NULL,
CreateDatabase,
"JetCreateDatabase", 112, NULL,
AttachDatabase,
"JetAttachDatabase", 102, NULL,
DetachDatabase,
"JetDetachDatabase", 121, NULL,
CreateTable,
"JetCreateTable", 115, NULL,
DeleteTable,
"JetDeleteTable", 120, NULL,
GetTableColumnInfo,
"JetGetTableColumnInfo", 137, NULL,
GetColumnInfo,
"JetGetColumnInfo", 127, NULL,
AddColumn,
"JetAddColumn", 101, NULL,
CreateIndex,
"JetCreateIndex", 113, NULL,
BeginTransaction,
"JetBeginTransaction", 105, NULL,
CommitTransaction,
"JetCommitTransaction", 109, NULL,
Rollback,
"JetRollback", 160, NULL,
CloseDatabase,
"JetCloseDatabase",  107, NULL,
CloseTable,
"JetCloseTable", 108, NULL,
OpenDatabase,
"JetOpenDatabase",  148, NULL,
OpenTable,
"JetOpenTable", 149, NULL,
Delete,
"JetDelete", 116, NULL,
Update,
"JetUpdate", 168, NULL,
RetrieveColumn,
"JetRetrieveColumn", 157, NULL,
SetColumn,
"JetSetColumn", 162, NULL,
PrepareUpdate,
"JetPrepareUpdate", 151, NULL,
GetCurrentIndex,
"JetGetCurrentIndex", 128, NULL,
SetCurrentIndex,
"JetSetCurrentIndex", 164, NULL,
Move,
"JetMove", 147, NULL,
MakeKey,
"JetMakeKey", 146, NULL,
Seek,
"JetSeek", 161, NULL,
Backup,
"JetBackup", 103, NULL,
Restore,
"JetRestore", 156, NULL
#endif _X86_
  };


#else

#if NEW_OWID
#define NAM_ADD_OWNERID_SIZE    sizeof(DWORD)
#else
#define NAM_ADD_OWNERID_SIZE    sizeof(BYTE)
#endif
#define OWN_ADD_OWNERID_SIZE    NAM_ADD_OWNERID_SIZE

#endif   //DYNLOADJET
/*
 *        Local Function Prototype Declarations
*/

/* prototypes for functions local to this module go here */
STATIC
STATUS
CreateTbl(
        JET_DBID        DbId,
        JET_SESID        SesId,
        JET_TABLEID        *pTblId,
        NMSDB_TBL_NAM_E        TblNam_e //enumerator value for table to create
        );

STATIC
STATUS
InitColInfo (
        JET_SESID        SesId,
        JET_TABLEID        TblId,
        NMSDB_TBL_NAM_E        TblNam_e
        );

STATIC
STATUS
ReadOwnAddTbl(
        JET_SESID          SesId,
        JET_DBID          DbId,
        JET_TABLEID     TblId
        );

STATIC
JET_ERR
UpdateDb (
   JET_SESID             SesId,
   JET_TABLEID             TblId,
   PNMSDB_ROW_INFO_T pRowInfo,
   ULONG             TypOfUpd

       );


STATIC
STATUS
GetGrpMem (
        IN JET_SESID                 SesId,
        IN JET_TABLEID                      TblId,
        IN PNMSDB_ROW_INFO_T          pRowInfo,
        IN DWORD_PTR                  CurrentTime,
        IN OUT PNMSDB_STAT_INFO_T pStatInfo,
//        IN OUT PNMSDB_NODE_ADDS_T pNodeAdds,
        IN BOOL                          fIsStatic,
        OUT LPBOOL                  pfIsMem
        );

STATIC
STATUS
GetMaxVersNos(
        JET_SESID         SesId,
        JET_TABLEID        TblId
        );

STATIC
__inline
VOID
StoreSpecVersNo(
   VOID
);
STATIC
JET_ERR
InsertGrpMemsInCol(
        JET_SESID                SesId,
        JET_TABLEID                TblId,
        PNMSDB_ROW_INFO_T        pRowInfo,
        ULONG                    TypeOfUpd
         );
STATIC
VOID
StoreGrpMems(
   IN  PWINSTHD_TLS_T    pTls,
   IN  WINS_CLIENT_E     WinsClient_e,
   IN  LPBYTE            pName,
   IN  int               ThdPrLvl,
   IN  JET_SESID         SesId,
   IN  JET_TABLEID       TblId,
   IN  BOOL              fIsStatic,
   OUT PRPL_REC_ENTRY_T  pRspBuff
        );

STATIC
STATUS
SetSystemParams(
        BOOL fBeforeInit
        );

STATIC
VOID
UpdHighestVersNoRecIfReqd(
        IN PWINSTHD_TLS_T        pTls,
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T        pStatInfo
        );

STATIC
STATUS
InitializeJetDb(
        PWINSTHD_TLS_T   pTls,
        LPBOOL           pfInitCallSucc,
        LPBOOL           pfDatabaseOpened
        );

STATIC
STATUS
AllocTls(
  LPVOID *ppTls
);

STATUS
ObliterateWins(
       DWORD        i,
       PCOMM_ADD_T  pWinsAdd
      );

#if DYNLOADJET
STATUS
SetForJet(
  VOID
 );
#endif //DYNLOADJET

STATUS
ConvertJetDb(
        JET_ERR             JetRetStat
 );
/*
        function definitions start here
*/

STATUS
NmsDbInit(
        VOID
        )

/*++

Routine Description:

        This function initializes the database manager component of the Name
        Space Manager Component

        It does the following

                calls _tzset to init global variables used by time().  These
                global variables are set so that convertion of UST to local
                time is done (for instance when time() is called)by
                taking into account the timezone information.

                Initialize the database engine

                Start a session with the db engine

                Create and attach to a database file

                Create (and open)  the name-address mapping table
                Create (and open)  the owner-address mapping table

                create a clustered and primary index on the name-address table
                create a clustered index on the owner-address table


        Note: if the database already exists, it

                Attaches to it

                Opens the Name IP address Mapping table

Arguments:
        None

Externals Used:
        NmsDbOwnAddTblCrtSec


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

called by:
        main function of WINS

Side Effects:

Comments:
        None
--*/

{
        JET_ERR             JetRetStat;
        PWINSTHD_TLS_T       pTls;
        BOOL                 fFirstTime = TRUE;

        if (AllocTls(&pTls) != WINS_SUCCESS)
        {
            return(WINS_FAILURE);
        }
        _tzset();        /*
                           func. uses TZ variable to assign values
                           to three global variables used by time().  This is
                           so that  Universal Coordinated Time to may be
                           adjusted to local time (timezone correction)
                        */


#if DYNLOADJET
       if (SetForJet() != WINS_SUCCESS)
       {
              return(WINS_FAILURE);
       }
#endif
       //
       // Set Jet System params (ignore return status)
       //
       (VOID)SetSystemParams(TRUE);

        //
        // Initialize the critical section for protecting the in-memory
        //table NmsDbOwnAddTbl
        //
        // Note: This table is read and written to during stable state by
        //       the Pull thread and the RPC threads executing WinsStatus()
        //
        // Check out RplFindOwnerId in rplpull.c
        //
        InitializeCriticalSection(&NmsDbOwnAddTblCrtSec);

        /*
          Initialize the Jet engine.  This must be the first call
          unless JetSetSystemParameter is called to set system
          parameters.  In that case, this call should be after that
        */
        while(TRUE)
        {
          BOOL  fInitCallSucc;
          BOOL  fDatabaseOpened;

          if (InitializeJetDb(pTls, &fInitCallSucc, &fDatabaseOpened) !=
                                        WINS_SUCCESS)
          {
             DWORD  NoOfRestoresDone = 0;
             if (fFirstTime && !fDbIs200 && !fDbIs500)
             {
                //
                // If we have a backup path, attempt to do a restore
                //
                if (WinsCnf.pBackupDirPath != NULL)
                {

                        DBGPRINT1(DET, "NmsDbInit: Doing Restore from path (%s)\n", WinsCnf.pBackupDirPath);
                        //
                        // If session is active, terminate it since we need
                        // call JetInit again. That requires that first we
                        // call JetTerm which does not expect any session to
                        // be active

                        //
                        if (fNmsMainSessionActive)
                        {
                                //
                                // Close tables opened in the session
                                //
                                NmsDbCloseTables();
                                if (fDatabaseOpened)
                                {
                                    CALL_M(JetCloseDatabase(
                                         pTls->SesId,
                                         pTls->DbId,
                                         0  //find out what grbit can be
                                            //used
                                          )
                                      );
                                }
                                CALL_M(JetEndSession(
                                        pTls->SesId,
                                        0
                                              )
                                          );
                                fNmsMainSessionActive = FALSE;

                        }
                        //
                        // if JetInit was successful, term jet activity
                        //
                        if (fInitCallSucc)
                        {
                                WinsWriterTerm();

                                NmsDbRelRes();
                        }

                        //
                        // We will try JetRestore a max of two times.
                        //
                        while(NoOfRestoresDone++ < 2)
                        {
                          if (DynLoadJetVersion >= DYN_LOAD_JET_500)
                          {
                          JetRetStat = JetRestore(WinsCnf.pBackupDirPath,  NULL);

                          }
                          else
                          {
                          JetRetStat = JetRestore(WinsCnf.pBackupDirPath, 0, NULL, 0);

                          }
                          if (JetRetStat != JET_errSuccess)
                          {
                             if ( (
                                    (JetRetStat == JET_errBadLogVersion)
                                                ||
                                    (JetRetStat == JET_errBadLogSignature)
                                                 ||
                                    (JetRetStat == JET_errInvalidLogSequence)
                                                 ||
                                    (JetRetStat == JET_errExistingLogFileHasBadSignature)
                                     )
                                                  &&
                                     (NoOfRestoresDone == 1)
                               )
                             {
                                TCHAR  LogFilePath[WINS_MAX_FILENAME_SZ];

#define LOG_FILE_SUFFIX        TEXT("*.log")
                                WinsMscConvertAsciiStringToUnicode(
                                      WinsCnf.pLogFilePath, (LPBYTE)LogFilePath, sizeof(LogFilePath)/sizeof(TCHAR));
                                //
                                // Delete log files
                                //
                                WinsMscDelFiles(TRUE, LOG_FILE_SUFFIX, LogFilePath);
                                continue;
                             }

                             WinsMscPutMsg(WINS_EVT_DB_RESTORE_GUIDE);
                             CALL_M(JetRetStat);

                           }
                           WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_DB_RESTORED);
                           break;  // break out of while loop
                        } // end of while()

                        fFirstTime = FALSE;
PERF("remove if not required")
                        sJetInstance = 0;        //defensive programming


#if 0
                        //
                        // Start a session again
                        //
                        if (AllocTls(&pTls) != WINS_SUCCESS)
                        {
                            return(WINS_FAILURE);
                        }
                        //
                        // Set Jet System params (ignore return status)
                        //
                        (VOID)SetSystemParams(TRUE);
#endif
                        continue;
                }

                WinsMscPutMsg(WINS_EVT_DB_RESTORE_GUIDE);

                //
                // There is no back up path specified in the registry.  Return
                //
                return(WINS_FAILURE);
            }
            else
            {
                if (!fDbIs200 && !fDbIs500)
                {
                  WinsMscPutMsg(WINS_EVT_DB_RESTORE_GUIDE);
                }
                else
                {
                  //
                  // If we are converting to NT 5.0, DynLoadJetVersion=DYN_LOAD_JET_600
                  //
                  if ( DynLoadJetVersion == DYN_LOAD_JET_600 ) {

                      //
                      // Put a pop-up and log an event based on which version
                      // of Jet database we are converting from.
                      //
                      if (!fConvJetDbCalled)
                      {
                        WINSEVT_LOG_INFO_D_M(
                            WINS_SUCCESS,
                            fDbIs200 ? WINS_EVT_DB_CONV_351_TO_5_GUIDE
                                     : WINS_EVT_DB_CONV_4_TO_5_GUIDE);
                        // As per bug#339015 remove popups
                        // WinsMscPutMsg(
                        //    fDbIs200 ? WINS_EVT_DB_CONV_351_TO_5_GUIDE
                        //             : WINS_EVT_DB_CONV_4_TO_5_GUIDE);
                      }
                      else
                      {
                        //WinsMscPutMsg(WINS_EVT_TEMP_TERM_UNTIL_CONV_TO_5);
                      }
                  }
                  //
                  // If we are converting to NT 4.0, DynLoadJetVersion=DYN_LOAD_JET_500
                  //
                  else if(DynLoadJetVersion == DYN_LOAD_JET_500) {
                      if (!fConvJetDbCalled)
                      {
                        WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_DB_CONV_GUIDE);
                        WinsMscPutMsg(WINS_EVT_DB_CONV_GUIDE);
                      }
                      else
                      {
                         WinsMscPutMsg(WINS_EVT_TEMP_TERM_UNTIL_CONV);
                      }
                  }else {
                      //
                      // We should never come here.
                      //
                      ASSERT(FALSE);
                  }


                }

                //
                // We got an error a second time.  Return
                //
                return(WINS_FAILURE);
            }
        }
        break;  //break out of the while loop
      } // end of while(TRUE)

      //
      // Init Push records if required
      //
       RPLPUSH_INIT_PUSH_RECS_M(&WinsCnf);

        NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, NmsDbStartVersNo);

        //
        // Set our UID to be the time when the db got initialized
        //
        {
            time_t  timeNow;
            (void)time(&timeNow);

            NmsDbUid = (DWORD)timeNow;
        }
        return(WINS_SUCCESS);
}
STATUS
AllocTls(
  LPVOID *ppTls
)

/*++

Routine Description:
    This function is called to allocate TLS

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
    NmsDbInit

Side Effects:

Comments:
	
--*/

{
        PWINSTHD_TLS_T  pTls;
        WinsMscAlloc( sizeof(WINSTHD_TLS_T),  ppTls);
        pTls = *ppTls;

        pTls->fNamAddTblOpen = FALSE;
        pTls->fOwnAddTblOpen = FALSE;

        /*
         * Let us store the address in the TLS storage
        */
        if (!TlsSetValue(WinsTlsIndex, pTls))
        {
                DWORD Error;
                Error = GetLastError();
                DBGPRINT1(ERR, "NmsDbAllocTlc: TlsSetValue returned error. Error = (%d)\n", Error);
                WINSEVT_LOG_M(Error, WINS_EVT_CANT_INIT);
                return(WINS_FAILURE);
        }
        return(WINS_SUCCESS);
}

STATUS
InitializeJetDb(
        PWINSTHD_TLS_T   pTls,
        LPBOOL           pfInitCallSucc,
        LPBOOL           pfDatabaseOpened
        )

/*++

Routine Description:
        This function opens the Jet db and tables

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/


{
        JET_ERR         JetRetStat;
        JET_SESID       SesId;
        JET_DBID        DbId;
        BOOL            fOwnAddTblCreated = FALSE; /*indicates whether the
                                                   owner id to address
                                                     mapping table was created
                                                     at init time
                                                   */

        *pfDatabaseOpened = FALSE;

        JetRetStat = JetInit(&sJetInstance);
        DBGPRINT1(ERR, "JetInit returning (%d)\n", (JetRetStat));

        if (JetRetStat != JET_errSuccess)
        {
           *pfInitCallSucc = FALSE;
           if ((JetRetStat == JET_errDatabase200Format) || (JetRetStat == JET_errDatabase500Format))
           {
               ConvertJetDb(JetRetStat);

            }
           else
           {

             //
             // We could have got an error  because the LogFilePath
             // is messed up in the registry.  We try again, this time using
             // the default log file path.
             //
             // Most of the time, we get FileNotFound error.  We have seen
             // "bad signature" error once.  Let us just do this for all
             // errors.  The situation will not be any worse than before if
             // JetInit fails again.
             //
             // Set the default log path
             //
             SetSystemParams(FALSE);
             JetRetStat = JetInit(&sJetInstance);
           }
           CALL_M(JetRetStat);
        }

        WinsWriterInit();

        *pfInitCallSucc = TRUE;

        /*
          Start a session.
        */
        CALL_M( JetBeginSession(
                        sJetInstance,
                        &pTls->SesId,
                        NAMUSR,
                        PASSWD  )
               );

        fNmsMainSessionActive = TRUE;
        SesId = pTls->SesId;

        //
        // Create/Open the database
        //
        if ((JetRetStat = JetCreateDatabase(
                                SesId,
//                                NmsDbDatabaseFileName,
                                WinsCnf.pWinsDb,
                                CONNECT_INFO,
                                &pTls->DbId,
                                0        //grbit; Don't want exclusive use
                              )) == JET_errDatabaseDuplicate
           )


        {

                //
                // let us attach to the database.  This is required for
                // opening databases that were created in a different
                // directory (Ian -- 11/23/93).  We will get a warning
                // if the database was created in this very directory
                //
                JetRetStat = JetAttachDatabase( SesId, WinsCnf.pWinsDb/*NmsDbDatabaseFileName*/, 0 );
                if (
                        (JetRetStat != JET_wrnDatabaseAttached)
                                  &&
                        (JetRetStat != JET_errSuccess)
                   )
                {
                        if ((JetRetStat == JET_errDatabase200Format) || (JetRetStat == JET_errDatabase500Format))
                        {
                           //
                           // Start the convert process
                           //

                            JetRetStat = ConvertJetDb(JetRetStat);
                            *pfInitCallSucc = TRUE;

                         }

                    CALL_M(JetRetStat);
                }

                //
                // If JetRetStat is success, it means ...
                //
                // The new db path is different from the old one.  We need
                // to detach so that Jet forgets about the old one. We then
                // attach to the new one again
                //
                if (JetRetStat == JET_errSuccess)
                {
                       CALL_M(JetDetachDatabase(SesId, NULL));
                       CALL_M(JetAttachDatabase(SesId, WinsCnf.pWinsDb, 0 ));
                }
                CALL_M(JetOpenDatabase(
                                        SesId,
                                        //NmsDbDatabaseFileName,
                                        WinsCnf.pWinsDb,
                                        NULL, /*the default engine*/
                                        &pTls->DbId,
                                        0
                                       )
                       );
                *pfDatabaseOpened = TRUE;

                DbId = pTls->DbId;
                JetRetStat = JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_NAM_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &pTls->NamAddTblId
                                        );


                //
                // If the name-address mapping table was not found, create it
                //
                if (JetRetStat == JET_errObjectNotFound)
                {

                   DBGPRINT0(INIT, "InitializeJetDb:Creating Name-Address table\n");
                   CALL_M(CreateTbl(
                                        DbId,
                                        SesId,
                                        &pTls->NamAddTblId,
                                        NMSDB_E_NAM_ADD_TBL_NM
                                            )
                         );
                   //
                   // Set this so that we close the table when we end the
                   // session
                   //
                   pTls->fNamAddTblOpen = TRUE;

                }
                else
                {

                   CALL_M(JetRetStat);
                   pTls->fNamAddTblOpen = TRUE;
                   //
                   // get and store in in-memory data structure, the
                   // information about the columns of the name-address
                   // mapping table
                   //
                   CALL_M(InitColInfo(
                        SesId,
                        pTls->NamAddTblId,
                        NMSDB_E_NAM_ADD_TBL_NM
                            ));

                   //
                   // get the max. version numbers of records owned
                   // by different owners.  These will be stored in
                   // the RplPullOwnerVersNo table
                   //
                   CALL_M(GetMaxVersNos(
                        SesId,
                        pTls->NamAddTblId
                                ));

                }

                //
                // Open the owner-address mapping table
                //
                JetRetStat = JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_OWN_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &pTls->OwnAddTblId
                                        );
                if (JetRetStat == JET_errObjectNotFound)
                {

                   DBGPRINT0(INIT, "InitializeJetDb:Creating Owner-Address table\n");
                   //
                   // Create the ownerid-address mapping table
                   //
                   CALL_M(CreateTbl(
                                DbId,
                                SesId,
                                &pTls->OwnAddTblId,
                                NMSDB_E_OWN_ADD_TBL_NM
                                  )
                          );

                   //
                   // Set this so that we close the table when we
                   // end the session
                   //
                   pTls->fOwnAddTblOpen = TRUE;
                   fOwnAddTblCreated = TRUE;
                }
                else
                {
                   pTls->fOwnAddTblOpen = TRUE;
                   CALL_M(InitColInfo(
                                SesId,
                                pTls->OwnAddTblId,
                                NMSDB_E_OWN_ADD_TBL_NM
                                   )
                           );

                }
        }
        else  //if database file was not existent and has now been created
        {
                 if (JetRetStat == JET_errSuccess)
                 {
                     DBGPRINT0(INIT, "InitializeJetDb: Database file was not there. It has been created\n");
                     *pfDatabaseOpened = TRUE;
                     DbId = pTls->DbId;

                     //
                     // Create the name -address mapping table
                     //
                     CALL_M(CreateTbl(
                             DbId,
                             SesId,
                             &pTls->NamAddTblId,
                             NMSDB_E_NAM_ADD_TBL_NM
                                        )
                           );

                     pTls->fNamAddTblOpen = TRUE;
                     //
                     // Create the ownerid-address mapping table
                     //
                     CALL_M(CreateTbl(
                             DbId,
                             SesId,
                             &pTls->OwnAddTblId,
                             NMSDB_E_OWN_ADD_TBL_NM
                                    )
                           );

                     pTls->fOwnAddTblOpen = TRUE;
                     fOwnAddTblCreated = TRUE;
                }
                else
                {
                    *pfDatabaseOpened = FALSE;
                    RET_M(JetRetStat);
                }
        }

        //
        // Allocate the NmsDbOwnAddTbl table in memory
        //
        WinsMscAlloc(
                    sizeof(NMSDB_ADD_STATE_T) * NmsDbTotNoOfSlots,
                    &pNmsDbOwnAddTbl
                         );

        /*
          If the Owner - Address table was there, read its contents into
          an in-memory table
        */

FUTURES("Pass ptr to an in-memory table instead of having ReadOwnAddTbl")
FUTURES("assume that one is present")

        if (!fOwnAddTblCreated)
        {
                ReadOwnAddTbl(
                        SesId,
                        DbId,
                        pTls->OwnAddTblId
                             );
        }

        //
        // Set the current index on the name-address table to the
        // clustered index
        //

        CALL_M(
                JetSetCurrentIndex( SesId,
                                    pTls->NamAddTblId,
                                    NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                          )
                      );

       return(WINS_SUCCESS);

} // end InitialiazeJetDb


STATUS
NmsDbInsertRowInd(
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function inserts a unique name-IP address mapping row in the
        name-IP address mapping table.  In case of a conflict, it returns
        an error status and information about the conflicting
        record that includes


                Status -- group/unique
                IP address(es) of the conflicting record (one address if
                  it was a unique record, one or more if it was
                  a special group).
                state   -- the state of the record (active/released/tombstone)



Arguments:
        pRowInfo    - Info. about the row to insert
        pStatusInfo - Contains status of the operation + info about the
                      conflicting record, if the registration conflicted
                      with an entry in the db.

Externals Used:
        None

Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegInd

Side Effects:

Comments:
        None
--*/
{

     DWORD              FldNo      = 0;
     JET_ERR            JetRetStat;
     DWORD              FlagVal    = 0;  //flag value of record
     DWORD              ActFldLen  = 0;  //length of fld retrieved
     JET_TABLEID        TblId;
     JET_SESID          SesId;
     PWINSTHD_TLS_T     pTls;
     BOOL               fWaitDone = FALSE;

     GET_TLS_M(pTls);
     ASSERT(pTls != NULL);
     TblId  = pTls->NamAddTblId;
     SesId  = pTls->SesId;

     pStatusInfo->StatCode = NMSDB_SUCCESS;

     JetRetStat = UpdateDb(
                                SesId,
                                TblId,
                                pRowInfo,
                                JET_prepInsert
                             );

     if ( JetRetStat == JET_errKeyDuplicate )
     {
                  pStatusInfo->StatCode = NMSDB_CONFLICT;

                  /*
                   *        retrieve the conflicting record's
                   *    flag byte.
                  */
                  CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pRowInfo->pName,
                        pRowInfo->NameLen,
                        JET_bitNewKey
                          )
                        );

                  if ((JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                            )) ==  JET_errSuccess
                     )
                 {

                         // retrieve the flags column
                         CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                &ActFldLen,
                                0,
                                NULL
                                          )
                              );


                        pStatusInfo->EntTyp  = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
                        pStatusInfo->fStatic = NMSDB_IS_ENTRY_STATIC_M(FlagVal);
                        pStatusInfo->EntryState_e =
                                                NMSDB_ENTRY_STATE_M(FlagVal);

                        if (NMSDB_ENTRY_UNIQUE_M(pStatusInfo->EntTyp))
                        {

FUTURES("Remove this RETINFO thing.  Presumably, it is not needed")
                                /* It is a unique entry*/
                                JET_RETINFO RetInfo;

                                RetInfo.itagSequence = 1;
                                RetInfo.cbStruct     = sizeof(JET_RETINFO);
                                RetInfo.ibLongValue  = 0;

                                          // retrieve the ip address column
                                          CALL_M(
                                   JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                     &(pStatusInfo->NodeAdds.Mem[0].Add),
                                     sizeof(COMM_ADD_T),
                                     &ActFldLen,
                                     0,
                                     &RetInfo
                                                         )
                                      );
                                pStatusInfo->NodeAdds.NoOfMems = 1;

                         }
                         else
                         {
                             if (NMSDB_ENTRY_MULTIHOMED_M(pStatusInfo->EntTyp))
                             {
                                   //
                                   // If status is active, we get the
                                   // group members
                                   //
                                   if (pStatusInfo->EntryState_e ==
                                                        NMSDB_E_ACTIVE)
                                   {
                                        BOOL        fIsMem;

#if 0
//NOTE: No need to do the following, since we don't care about the value of
//fIsMem returned GetGrpMem()
                                         pRowInfo->NodeAdds.NoOfMems   = 1;
                                         pRowInfo->NodeAdds.Mem[0].Add =
                                                        *(pRowInfo->pNodeAdd);
#endif

PERF("If entry in conflict is STATIC, we don't need to get grp members")
PERF("except maybe for multihomed entries. Checkout Clash functions (nmsnmh.c)")
                                        if (GetGrpMem(
                                                SesId,
                                                TblId,
                                                pRowInfo,
                                                pRowInfo->TimeStamp - ((pRowInfo->OwnerId == NMSDB_LOCAL_OWNER_ID) ? WinsCnf.RefreshInterval : WinsCnf.VerifyInterval) ,
                                                pStatusInfo,
                                                pStatusInfo->fStatic,
                                                &fIsMem
                                                  ) != WINS_SUCCESS)
                                         {

                                                return(WINS_FAILURE);

                                         }

                                        //
                                        // If all members are expired, then
                                        // mark entry in conflict as a
                                        // TOMBSTONE (for the benefit of
                                        // ClashAtRegInd and ClashAtReplUniqueR)
                                        //
                                        if (pStatusInfo->NodeAdds.NoOfMems == 0)
                                        {
                                                pStatusInfo->EntryState_e =
                                                        NMSDB_E_RELEASED;
                                        }

                                  }
                                  else
                                  {
                                        pStatusInfo->NodeAdds.NoOfMems = 0;
                                  }
                             }
                        }

#if !NEW_OWID
                       pStatusInfo->OwnerId = 0;
#endif

                        /*
                         * Retrieve the owner Id column.
                        */
                        CALL_M(
                                   JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &pStatusInfo->OwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     0,
                                     NULL
                                                         )
                                      );

                        //
                        // Just in case we challenge this entry and it
                        // happens to be multihomed, we would need to add
                        // it as a member (see ProcAddList).
                        //
                        if (NMSDB_ENTRY_UNIQUE_M(pStatusInfo->EntTyp))
                        {
                                pStatusInfo->NodeAdds.Mem[0].OwnerId =
                                                       pStatusInfo->OwnerId;
                                //
                                // Put the current time stamp as the time
                                // stamp of the member. Though not strictly
                                // correct, it is ok.  We don't
                                // need to retrieve the time stamp of the
                                // conflicting record this way.
                                //
                                if (pStatusInfo->OwnerId ==
                                        NMSDB_LOCAL_OWNER_ID)
                                {
                                        pStatusInfo->NodeAdds.Mem[0].TimeStamp
                                               = pRowInfo->TimeStamp;
                                }
                        }

                        //
                        // If the conflicting record is owned by the local
                        // WINS, we must retrieve the version number.  This
                        // is used to determine whether the special record
                        // storing the highest version number of the
                        // local records should be updated (refer:
                        // NmsDbUpdateRow, NmsDbSeekNUpd, NmsScvDoScavenging,
                        // NmsDbUpdHighestVersNoRec)
                        //
                        if (pStatusInfo->OwnerId == NMSDB_LOCAL_OWNER_ID)
                        {

                                      //
                                      // Retrieve the version number
                                      //
                                      CALL_M( JetRetrieveColumn(
                                          SesId,
                                          TblId,
                                          sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                          &(pStatusInfo->VersNo),
                                          sizeof(VERS_NO_T),
                                          &ActFldLen,
                                          0,
                                          NULL
                                                             )
                                          );


                        }


                }
                else  //could not seek to the record
                {
#if 0
// use the following code only if there is a thread somewhere in WINS that
// updates the db without first entering the NmsNmhNamRegCrtSec critical
// section.

//
// For registration done by RPLPULL thread where the version number is not
// incremented, we do not have to enter the above critical section.  Currently
// we do enter it.  If in the future we stop doing so, we will uncomment the
// following code.
//
                        if (!fWaitDone)
                        {
                           WINSEVT_LOG_INFO_M(
                                                WINS_SUCCESS,
                                                WINS_EVT_CANT_FIND_REC
                                             );
                           Sleep(10);        //sleep for 10 msecs to let the other
                                        //thread commit/rollback the transaction
                                        //that is inserting a record that caused
                                        //the conflict


                           //
                           // Set flag to TRUE so that if we get the same
                           // error again, we can log an error and raise
                           // an exception
                           //
                           fWaitDone = TRUE;
                           continue;  //iterate one more time
                        }
#endif

                        /*
                         * We should never get here.  Something major is wrong
                         * (probably with Jet)
                         */
                        DBGPRINT1(EXC, "NmsDbInsertRowInd: Could not seek to conflicting record. WEIRD. Error is (%d)\n", JetRetStat);
                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                        ASSERTMSG(0, "SEEK ERROR");
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

                }  // end of else

        }  //no duplicate

        CALL_M(JetRetStat);

        return(WINS_SUCCESS);
}


STATUS
NmsDbInsertRowGrp(
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function inserts a group name-IP address mapping row in the
        name-IP address mapping table. It first seeks on the name to see
        if there is an entry with that name.  if yes, it retrieves the
        information about the conflicting record for the benefit of the
        calling function and returns.

        Information retrieved includes
                Status -- group/unique
                IP addresses pertaining to the entry
                state   -- the state of the record (active/released/tombstone)


Arguments:

        pRowInfo    - Info. about the row to insert
        pStatusInfo - Contains status of the operation + info about the
                      conflicting record, if the registration conflicted
                      with an entry in the db.

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/
{

        DWORD       FldNo       = 0;
        JET_ERR     JetRetStat;
        DWORD       FlagVal     = 0;     //flag value of record that is
                                         //retrieved
        DWORD       ActFldLen   = 0;     //length of fld retrieved
        BOOL        fFound      = FALSE; //set to TRUE if Address is found in
                                         //group
        BOOL        fWaitDone     = FALSE;

        JET_RETINFO     RetInfo;
        JET_SESID        SesId;
        JET_TABLEID     TblId;
        PWINSTHD_TLS_T        pTls;

             GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
             TblId  = pTls->NamAddTblId;
             SesId  = pTls->SesId;

        pStatusInfo->StatCode         = NMSDB_SUCCESS;

        //
        // So that we repeat the whole while loop in case we are not
        // able to seek after a conflict
        //
        JetRetStat = UpdateDb(
                                SesId,
                                TblId,
                                pRowInfo,
                                JET_prepInsert
                             );


        if ( JetRetStat == JET_errKeyDuplicate )
        {
                pStatusInfo->StatCode = NMSDB_CONFLICT;

                CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                pRowInfo->pName,
                                pRowInfo->NameLen,
                                JET_bitNewKey
                                    )
                     );

                 if ((JetRetStat = JetSeek(
                            SesId,
                            TblId,
                            JET_bitSeekEQ
                           )) ==  JET_errSuccess
                    )
                 {

                            // retrieve the flags column
                            CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                &ActFldLen,
                                0,
                                NULL
                                     )
                                );

                            pStatusInfo->EntryState_e =
                                                NMSDB_ENTRY_STATE_M(FlagVal);
                            pStatusInfo->EntTyp  =
                                            (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
                            pStatusInfo->fStatic =
                                             NMSDB_IS_ENTRY_STATIC_M(FlagVal);

                            if (pStatusInfo->EntTyp == NMSDB_UNIQUE_ENTRY)
                            {
                                  /* It is a unique entry*/


FUTURES("Remove this RETINFO thing.  Presumably, it is not needed")
                                /* It is a unique entry*/

                                RetInfo.itagSequence = 1;
                                RetInfo.cbStruct     = sizeof(JET_RETINFO);
                                RetInfo.ibLongValue  = 0;

                                // retrieve the ip address column
                                CALL_M(
                                  JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                     &(pStatusInfo->NodeAdds.Mem[0].Add),
                                     sizeof(COMM_ADD_T),
                                     &ActFldLen,
                                     0,
                                     &RetInfo
                                                  )
                                      );

                                pStatusInfo->NodeAdds.NoOfMems = 1;
                            }
                            else //it is a group entry or a multihomed entry
                            {

                                if (pStatusInfo->EntTyp != NMSDB_NORM_GRP_ENTRY)
                                {
                                    //
                                    // If status is active, we get the
                                    // group members
                                    //
                                    if (pStatusInfo->EntryState_e ==
                                                        NMSDB_E_ACTIVE)
                                    {
                                        BOOL        fIsMem;
PERF("If entry in conflict is STATIC, we don't need to get grp members")
PERF("except maybe for multihomed entries. Checkout Clash functions (nmsnmh.c)")
                                        if (GetGrpMem(
                                                SesId,
                                                TblId,
                                                pRowInfo,
                                                pRowInfo->TimeStamp - ((pRowInfo->OwnerId == NMSDB_LOCAL_OWNER_ID) ? WinsCnf.RefreshInterval : WinsCnf.VerifyInterval),
                                                pStatusInfo,
                                                pStatusInfo->fStatic,
                                                &fIsMem
                                                  ) != WINS_SUCCESS)
                                        {
                                                return(WINS_FAILURE);
                                        }
                                        //
                                        // If all members are expired, then
                                        // mark entry in conflict as a
                                        // RELEASED (for the benefit of
                                        // ClashAtRegGrp and ClashAtReplGrpMemR)
                                        //
                                        if (pStatusInfo->NodeAdds.NoOfMems == 0)
                                        {
                                                pStatusInfo->EntryState_e =
                                                        NMSDB_E_RELEASED;
                                        }

                                    }
                                    else
                                    {
                                        pStatusInfo->NodeAdds.NoOfMems = 0;
                                    }
                                }

                        }

#if !NEW_OWID
                       pStatusInfo->OwnerId = 0;
#endif
                        /*
                          Retrieve the owner Id column.
                        */
                        CALL_M(
                                  JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &pStatusInfo->OwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     0,
                                     NULL
                                                         )
                              );

                        //
                        // Just in case we challenge this entry and it
                        // happens to be multihomed, we would need to add
                        // it as a member (see ProcAddList).
                        //
                        if (NMSDB_ENTRY_UNIQUE_M(pStatusInfo->EntTyp))
                        {
                                pStatusInfo->NodeAdds.Mem[0].OwnerId =
                                                       pStatusInfo->OwnerId;
                                if (pStatusInfo->OwnerId ==
                                        NMSDB_LOCAL_OWNER_ID)
                                {
                                     //
                                     // Put the current time stamp as the time
                                     // stamp of the member. Though not strictly
                                     // correct, it is ok.  We don't
                                     // need to retrieve the time stamp of the
                                     // conflicting record this way.
                                     //
                                     pStatusInfo->NodeAdds.Mem[0].TimeStamp
                                               = pRowInfo->TimeStamp;
                                }
                        }

                        //
                        // If the conflicting record is owned by the local
                        // WINS, we must retrieve the version number.  This
                        // is used to determine whether the special record
                        // storing the highest version number of the
                        // local records should be updated (refer:
                        // NmsDbUpdateRow, NmsDbSeekNUpd, NmsScvDoScavenging,                                // NmsDbUpdHighestVersNoRec)
                        //
                        if (pStatusInfo->OwnerId == NMSDB_LOCAL_OWNER_ID)
                        {
                                      //
                                      // Retrieve the version number
                                      //
                                      CALL_M( JetRetrieveColumn(
                                          SesId,
                                          TblId,
                                          sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                          &(pStatusInfo->VersNo),
                                          sizeof(VERS_NO_T),
                                          &ActFldLen,
                                          0,
                                          NULL
                                                             )
                                          );


                        }
                //        break; //break out of the while loop
                   }
                   else
                   {
#if 0
                        if (!fWaitDone)
                        {
                                   WINSEVT_LOG_INFO_M(
                                        WINS_SUCCESS,
                                        WINS_EVT_CANT_FIND_REC
                                                       );

                                   Sleep(10);        //sleep for 10 msecs to let
                                                //the other
                                                //thread commit/rollback the
                                                //transaction that is
                                                //inserting a record that
                                                //caused a conflict


                                   //
                                   // Set flag to TRUE so that if we get the same
                                   // error again, we can log an error and raise
                                  // an exception
                                   //
                                   fWaitDone = TRUE;
                                   continue;         //iterate one more time
                        }
#endif
                        /*
                         * We should never get here.  Something major is wrong.
                         * Either our current index is not on the name column or
                        * there is something wrong with JET
                        */
                        DBGPRINT1(EXC, "NmsDbInsertRowGrp: Could not seek to conflicting record. WEIRD. Error is (%d)\n", JetRetStat);
                        ASSERTMSG(0, "SEEK ERROR");
                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

               }

          }  // not a duplicate

          CALL_M(JetRetStat);
       return(WINS_SUCCESS);
}




STATUS
NmsDbRelRow(
        IN  PNMSDB_ROW_INFO_T            pRowInfo,
        OUT PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++

Routine Description:

        This function releases a record in the database.  Releasing
        requires
                mark state as released
                update time stamp
                mark self as owner

Arguments:
        pRowInfo    - Information about the record to release
        pStatusInfo -  Status of operation

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRelRow

Side Effects:

Comments:
        None
--*/
{

        DWORD   FldNo            = 0;
        JET_ERR JetRetStat;
        DWORD    Ownerid = NMSDB_LOCAL_OWNER_ID;
#if NEW_OWID
        DWORD    OldOwnerId;
#else
        DWORD    OldOwnerId = 0;
#endif
        DWORD   FlagVal    = 0;      //flag value of record that is retrieved
        DWORD   ActFldLen  = 0;      //length of fld retrieved
        BOOL    fFound     = FALSE;  //set to TRUE if Address is found in group
        BOOL    fToRelease = TRUE;   //will be changed to false only for
                                     //a special group
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        JET_RETINFO     RetInfo;
        BYTE            EntTyp;
#ifdef WINSDBG
        BOOL            fUpd = FALSE;
#endif

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId                = pTls->NamAddTblId;
        SesId                = pTls->SesId;

        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M( JetMakeKey(
                SesId,
                TblId,
                pRowInfo->pName,
                pRowInfo->NameLen,
                JET_bitNewKey
                          )
              );

         if ( (JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                                  )
              ) ==  JET_errRecordNotFound
            )
         {
                /*
                 We return success, since the record is not there.

                 This situation can  happen under the following
                 condition.

                        The client sends a name release to another WINS
                        which has not yet got the replica of the record.


                In the second case above, returning a positive name release
                request is ok even though the entry has not been released.
                It will eventually get released as a result of it not being
                refreshed or at the occurrence of a conflict.

                */

NOTE("Currently, NETBT always goes to the local WINS server for registrations")
NOTE("So, if a record is not in this db, it better not be in netbt tables too")
NOTE("If NETBT changes the above semantic in the future i.e. starts going")
NOTE("to a non-local WINS for reg., we should set pStatusInfo->fLocal to TRUE")
NOTE("here")
                return(WINS_SUCCESS);
         }
         else
         {
                if (JetRetStat != JET_errSuccess)
                {
                        DBGPRINT1(ERR,
                                "NmsDbRelRow: Seek returned Error (%d)\n",
                                                JetRetStat);
                        return(WINS_FAILURE);
                }
         }

         // retrieve the flags column
         CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &FlagVal,
                        sizeof(FlagVal),
                        &ActFldLen,
                        0,
                        NULL
                                  )
                );

         //
         // Set the fLocal flag if this entry was registered by this node
         //
         pStatusInfo->fLocal = NMSDB_IS_ENTRY_LOCAL_M(FlagVal);

         if (!NMSDB_ENTRY_ACT_M(FlagVal))
         {

                /*
                 The entry is already released.  This can happen
                 because of the following reasons

                   --client sent a repeat name release since it did not
                     get the response to the earlier one (maybe it got
                     lost or maybe because of a timing window where WINS
                     has sent a response just around the time the client
                     does the retry

                   --entry got released due to no refresh (all refreshes got
                     lost.


                Returning a positive name release is fine.  If the client
                has not got the first one (because it got lost, it will get
                the second one).  If it has now received the first response,
                it will just ignore the second one
                */

CHECK("Make sure that NBT will ignore the second one")

                return(WINS_SUCCESS);
         }


        EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
        //
        // If we got a release for a unique entry but the entry
        // we found is a group entry or vice-versa, return
        // NO_SUCH_ROW status.
        //
        if (
              (
                NMSDB_ENTRY_UNIQUE_M(EntTyp)
                        &&
                   NMSDB_ENTRY_GRP_M(pRowInfo->EntTyp)
              )
                         ||
              (
                NMSDB_ENTRY_GRP_M(EntTyp)
                        &&
                   !NMSDB_ENTRY_GRP_M(pRowInfo->EntTyp)
              )
           )
        {
                DBGPRINT0(ERR, "NmsDbRelRow: Request to release a record with a type (unique/group) than the one for which the release was sent has been ignored\n");
PERF("Remove this logging to increase speed")
                // per bug #336889 remove this
//                WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_REL_TYP_MISMATCH);
                pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                return(WINS_SUCCESS);
        }

         pStatusInfo->EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);

         //
         // If it is a dynamic release request but the entry found is STATIC,
         // we return SUCCESS.
         //
         // Note: Even though the address in the release request may be
         // different from one in the STATIC record, we return SUCCESS.
         //
         // This is to save overhead for the majority of cases (99%) where
         // the addresses are going to be the same.
         //
         if (!pRowInfo->fAdmin && (NMSDB_IS_ENTRY_STATIC_M(FlagVal) &&
                         !NMSDB_ENTRY_USER_SPEC_GRP_M(pRowInfo->pName, pStatusInfo->EntTyp)))
         {
                return(WINS_SUCCESS);
         }

         if (pStatusInfo->EntTyp == NMSDB_UNIQUE_ENTRY)
         {
                  /* retrieve the ip address column*/

                  RetInfo.itagSequence = 1;
                  RetInfo.cbStruct     = sizeof(JET_RETINFO);
                  RetInfo.ibLongValue  = 0;

                  CALL_M( JetRetrieveColumn(
                                  SesId,
                                  TblId,
                                  sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                  &(pStatusInfo->NodeAdds.Mem[0].Add),
                                  sizeof(COMM_ADD_T),
                                  &ActFldLen,
                                  0,
                                  &RetInfo
                                                     )
                             );


                  pStatusInfo->NodeAdds.NoOfMems = 1;

                  //
                  // Extract the Node Type from the Flags byte
                  //
                  pStatusInfo->NodeTyp =  (BYTE)NMSDB_NODE_TYPE_M(FlagVal);

                //
                // if the address of the entry to be released does not
                // match the address of the client requesting the release
                // and it is not an administrative action, we do not release
                // the entry
                //
                if (
                        (pRowInfo->pNodeAdd->Add.IPAdd !=
                                pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd)
                                        &&
                           (!pRowInfo->fAdmin)
                   )

                {
                        DBGPRINT3(ERR, "NmsDbRelRow: Request to release a record (%s) with a different IP address (%x) than that in the release request (%x) has been ignored\n", pRowInfo->pName, pRowInfo->pNodeAdd->Add.IPAdd, pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd);
                        pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
#if 0 //per bug #336875
                        if (WinsCnf.LogDetailedEvts)
                        {
                          WinsEvtLogDetEvt(TRUE, WINS_EVT_REL_ADD_MISMATCH, TEXT("nmsdb"), __LINE__, "sdd", pRowInfo->pName, pRowInfo->pNodeAdd->Add.IPAdd,
                             pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd);
                        }
#endif
//                        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_REL_ADD_MISMATCH);
                        return(WINS_SUCCESS);
                }
        }
        else  // it is a group entry (Normal or Special) or a multihomed entry
        {
                //
                // if it is a special group/multihomed entry, we need to do a
                // number of things
                //
                if (!NMSDB_ENTRY_NORM_GRP_M(pStatusInfo->EntTyp))
                {
                        BOOL   fIsMem;

                        //
                        // Init the following fields since they are used to
                        // by GetGrpMem (for determining fIsMem)
                        //
                        pRowInfo->NodeAdds.NoOfMems   = 1;
                        pRowInfo->NodeAdds.Mem[0].Add = *(pRowInfo->pNodeAdd);

                        //
                        // get all non-expired group/multihomed members
                        //
                        if (GetGrpMem(
                                SesId,
                                TblId,
                                pRowInfo,
                                pRowInfo->TimeStamp,
                                pStatusInfo,
                                NMSDB_IS_ENTRY_STATIC_M(FlagVal),
                                &fIsMem
                                 ) != WINS_SUCCESS)
                        {
                                return(WINS_FAILURE);
                        }

                        //
                        // If client is not a member of the group (maybe it
                        // never registered or if it did, maybe its entry
                        // has timed out.)  We return SUCCESS
                        //
CHECK("Maybe we should return NO_SUCH_ROW here. This will then result")
CHECK("in a NAM_ERR being returned to the client. Also, is there any")
CHECK("need to keep members around even if they have timed out just so")
CHECK("that we don't release a spec. group due to a request from a client")
CHECK("that was never a member. ")
                        if ((!fIsMem) || (pStatusInfo->NodeAdds.NoOfMems == 0))
                        {
                           pStatusInfo->StatCode = NMSDB_SUCCESS;
                           return(WINS_SUCCESS);
                        }
                        else  //client is a member of the group/multihomed list
                        {
                                DWORD i;
                                DWORD n = 0;

                                //
                                // Save the address of the client in a local
                                // var.
                                //
                                COMM_IP_ADD_T  IPAdd =
                                             pRowInfo->NodeAdds.Mem[0].
                                                        Add.Add.IPAdd;
                                //
                                // Init the no. of mems fields of the address
                                // structure to store to 0
                                //
                                pRowInfo->NodeAdds.NoOfMems = 0;

                                //
                                // remove the client from the active list by
                                // storing all other members in the NodeAdds
                                // field of ROW_INFO_T structure. Note:
                                // if there is an address match, we remove
                                // the member irrespective of its ownership.
                                // Also note:  This code is not reachable
                                // for a static record (see above)
                                // unless it is an admin request.
                                //
                                for (i = 0;
                                     i < pStatusInfo->NodeAdds.NoOfMems;
                                     i++
                                     )
                                {
                                        if (
                                 pStatusInfo->NodeAdds.Mem[i].Add.Add.IPAdd
                                          != IPAdd                                                                              )
                                        {
                                                pRowInfo->NodeAdds.Mem[n++]
                                                 = pStatusInfo->NodeAdds.Mem[i];
                                                pRowInfo->NodeAdds.NoOfMems++;
                                        }

                                }
                                //
                                // If there is at least one group/multihomed
                                // member, we do not release the row
                                //
                                if (pRowInfo->NodeAdds.NoOfMems != 0)
                                {
                                        fToRelease = FALSE;
                                }
                        } //end of else
                }
        }

        /*
         * Retrieve the owner Id column.
        */
        CALL_M(
                  JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &OldOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                         )
                  );

        CALL_M(JetBeginTransaction(SesId));
try {
        JetRetStat = JetPrepareUpdate(
                        SesId,
                        TblId,
                        JET_prepReplace
                                 );
        if (
                (JetRetStat != JET_errSuccess)
                        &&
                (JetRetStat != JET_wrnNoWriteLock)
           )
        {
                RET_M(JetRetStat);
        }


        //
        // If we have to release a record not owned by us, let us change
        // it into a tombstone.  This will result in replication of the same.
        // We want this to shorten the db inconsistency window between our
        // db and the db of the WINS that owns this record.
        //
        // Consider the following situation: Client A registers AA at WINS A
        // It then releases AA at WINS B. On a reboot, it registers at WINS A.
        // Subsequent refreshes also go to WINS A.  Since AA was active at WINS
        // A when the registration after the release (at B) came in, the
        // version number wouldn't be incremented and so the record will not
        // replicate again.  B will continue to have the released record
        // until it becomes a tombstone and gets replicated.
        //
        if (fToRelease)
        {
             //
             // Get rid of released state altogether
             //
           if (OldOwnerId != Ownerid)
           {
             FlagVal |= (NMSDB_E_TOMBSTONE << NMSDB_SHIFT_STATE);
             //
             // Strictly speaking, for a record that has been turned into
             // a tombstone, we should be using the tombstonetimeout value,
             // we don't do that here.  Since such a record never went through
             // the released state, we set the expiry to the aggregate of the
             // tombstone interval and tombstone timeout (to doubly safeguard
             // against it getting deleted prematurely - long weekend and
             // everything).
             //
             pRowInfo->TimeStamp +=
                  WinsCnf.TombstoneInterval + WinsCnf.TombstoneTimeout;
             DBGPRINT3(DET, "NmsDbRelRow: Changing from ACTIVE TO TOMBSTONE. Name = (%s),Old and new OwnerId (%d/%d)\n",
                       pRowInfo->pName, OldOwnerId,Ownerid);
FUTURES("Use macro in winevt.h.  Make it a warning")
#if 0 //per bug #336889
             if (WinsCnf.LogDetailedEvts > 0)
             {
                 WinsEvtLogDetEvt(TRUE, WINS_EVT_REL_DIFF_OWN, NULL, __LINE__, "sd", pRowInfo->pName,
                                  OldOwnerId);
             }
#endif

           }
           else
           {
             FlagVal |= (NMSDB_E_RELEASED << NMSDB_SHIFT_STATE);
             pRowInfo->TimeStamp += WinsCnf.TombstoneInterval;
           }
        }
        else        //hit only for a special group/multihomed entry
        {


                pRowInfo->TimeStamp += WinsCnf.RefreshInterval;
                //
                //Set the address field with the new member list
                //
                CALL_M( InsertGrpMemsInCol(
                                        SesId,
                                        TblId,
                                        pRowInfo,
                                        JET_prepReplace
                                          )
                      );

        }
        /*
                Set flags column
                Even though not required for special groups, we set it
                to save ourselves an if test (an if test will impact 99% of the
                client releases).
          */
         CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                0,
                                NULL /*optional info */
                                 )
               );

         //
         // Since we are taking over ownership of this record, we must
         // update the version number also, else there can be a conflict
         //
         if (OldOwnerId != NMSDB_LOCAL_OWNER_ID)
         {
            /* Set the owner byte        */
            CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &Ownerid,
                                NAM_ADD_OWNERID_SIZE,
                                0,
                                NULL /*optional info */
                                 )
               );
            // set the the version number column
            CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &(pRowInfo->VersNo),
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );
#ifdef WINSDBG
             fUpd = TRUE;
             pRowInfo->EntryState_e = NMSDB_E_RELEASED;
#endif

         }



         /* set the timestamp column         */
         CALL_M( JetSetColumn(
                                pTls->SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &(pRowInfo->TimeStamp),
                                sizeof(DWORD),  /*change type to TIME_STAMP_T
                                                 *later*/
                                0,
                                NULL /*optional info */
                                 )
               );


#ifndef WINSDBG
        CALL_M(JetUpdate (
                        SesId,
                        TblId,
                        NULL,
                        0L,
                        NULL
                         )
              );
#else
     JetRetStat =  JetUpdate (  SesId,  TblId,   NULL,  0L,  NULL);
     ASSERT(JetRetStat != JET_errKeyDuplicate);
     if (JetRetStat == JET_errKeyDuplicate)
     {
        WinsEvtLogDetEvt(FALSE, WINS_EVT_DATABASE_UPD_ERR, NULL, __LINE__,
             "sdd", pRowInfo->pName, Ownerid, FlagVal);
     }
     CALL_M(JetRetStat);
#endif

  } // end of try block
finally {

        if (AbnormalTermination())
        {
                // if there is an abnormal termination, we already have an error
                // code here. We shouldn't override it with any other error code.
                JetRollback(SesId, JET_bitRollbackAll);
        }
        else
        {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553).)
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                if (OldOwnerId != NMSDB_LOCAL_OWNER_ID)
                {
                      //
                      // No need to send any push notification since we do
                      // not wish to replicate this change.
                      //
                      // Also, no need to call NMSNMH_INC_VERS_COUNTER_M since
                      // it is ok not to check against threshold if the
                      // version number got incremented because of a release.
                      //
                      NMSNMH_INC_VERS_NO_M(NmsNmhMyMaxVersNo, NmsNmhMyMaxVersNo);
                }
        }
 }
        NMSNMH_UPD_UPD_CTRS_M(fUpd, TRUE, pRowInfo);
        return(WINS_SUCCESS);
}

STATUS
NmsDbQueryRow(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
)

/*++
Routine Description:

        This function queries a record in the database.

Arguments:

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamQuery

Side Effects:

Comments:
        None
--*/
{

        DWORD       FldNo      = 0;
        DWORD       FlagVal    = 0;     //flag value of record that is retrieved
        DWORD       ActFldLen  = 0;     //length of fld retrieved
        BOOL        fFound     = FALSE; //set to TRUE if Address is found in group

        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T        pTls;
        STATUS                RetStat = WINS_SUCCESS;

        pStatusInfo->NodeAdds.NoOfMems = 1;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M(JetBeginTransaction(pTls->SesId));
try {
        CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pRowInfo->pName,
                        pRowInfo->NameLen,
                        JET_bitNewKey
                          )
              );

         if ( JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekEQ
                     ) ==  JET_errSuccess
            )
         {

            // retrieve the flags column
            CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &FlagVal,
                        sizeof(FlagVal),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );


            pStatusInfo->EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
            pStatusInfo->fLocal = NMSDB_IS_ENTRY_LOCAL_M(FlagVal);
            pStatusInfo->NodeTyp = (BYTE)((FlagVal & NMSDB_BIT_NODE_TYP) >> NMSDB_SHIFT_NODE_TYP);

            if (pStatusInfo->EntTyp == NMSDB_UNIQUE_ENTRY)
            {
                /* It is a unique entry*/

                /*
                 * check the flag field to determine if it is
                 * released or a tombstone.   Get the address if
                 * the entry is ACTIVE or if it is an admin query
                */
                if ((NMSDB_ENTRY_ACT_M(FlagVal)) || pRowInfo->fAdmin)
                {

                        JET_RETINFO RetInfo;

                           /* retrieve the ip address column*/

                       RetInfo.itagSequence = 1;
                       RetInfo.cbStruct     = sizeof(JET_RETINFO);
                       RetInfo.ibLongValue  = 0;

                          CALL_M( JetRetrieveColumn(
                                  SesId,
                                  TblId,
                                  sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                  &(pStatusInfo->NodeAdds.Mem[0].Add),
                                  sizeof(COMM_ADD_T),
                                  &ActFldLen,
                                  0,
                                  &RetInfo
                                                     )
                             );

                       pStatusInfo->NodeAdds.NoOfMems = 1;

                }
                else  // the unique entry is released or a tombstone
                {
                    /*
                        If the state is anything other than active, return
                        no such row
                    */
                    pStatusInfo->StatCode          = NMSDB_NO_SUCH_ROW;

                }

           }
           else // it is a group/multihomed record
           {

                /*
                  Check whether this is a normal group or a special group.

                  For normal group, we return the subnet broadcast
                  address.  This means that we have to find the subnet
                  mask for the network from which the request came.

                  For now, we return all 1s (-1).  This
                  indicates the broadcast address on the
                  local subnet (Vol 1, 2, 3 of Comer for the naive)
                */

                if (pStatusInfo->EntTyp == NMSDB_NORM_GRP_ENTRY)
                {

                   DBGPRINT0(FLOW, "Record queried is a normal group record\n");
                   //
                   //  If it is not a TOMBSTONE, return the subnet mask.
                   //  We return the subnet mask even when the state is
                   //  RELEASED because the group may be active at another
                   //  WINS server
                   //
                   if (!(NMSDB_ENTRY_TOMB_M(FlagVal)) || pRowInfo->fAdmin)
                   {
                        pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd = 0xFFFFFFFF;
                   }
                   else  //state is tombstone
                   {
                      pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                   }

                }
                else        // it is a special group/multihomed entry
                {

                        BOOL        fIsMem;

                           DBGPRINT1(FLOW, "Record queried is a %s record\n",
                          NMSDB_ENTRY_SPEC_GRP_M(pStatusInfo->EntTyp) ?
                                "SPECIAL GROUP" : "MULTIHOMED");

#if 0
//NOTE: No need to do the following, since we don't care about the value of
//fIsMem returned GetGrpMem()
                         pRowInfo->NodeAdds.NoOfMems   = 1;
                        pRowInfo->NodeAdds.Mem[0].Add = *(pRowInfo->pNodeAdd);
#endif

                        //
                        // We return only the active members.
                        //
                        // Remember:
                        // A special group/multihomed entry is released when
                        // all its members have timed out.  A member times out
                        // only if it is a non-STATIC entry, is owned by the
                        // local WINS, and has not been refreshed within the
                        // refresh time interval.  All owned entries get
                        // released if they are not refreshed.  A member also
                        // gets removed if a release is received for it.
                        // Now, an owned multihomed entry/special group can have
                        // members owned by other WINS servers. The only member we
                        // may get is one that belongs to the local WINS
                        // for which the WINS got a release earlier (but
                        // the member was not removed)
                        //

                        if (NMSDB_ENTRY_ACT_M(FlagVal) || pRowInfo->fAdmin )
                        {
                                //
                                // Get all non-expired members unless it is
                                // is a STATIC record in which case get all
                                // members regardless of whether or not they
                                // have expired.
                                //
                                // NOTE: For some cases we also want to return expired
                                // members. e.g WINSA has name FOO with members (A,B)
                                // and WINSB has name FOO with members B. WINSA owns the
                                // member B. When B is expired on WINSA and if the replication
                                // is broken for extended period of time, then we still
                                // want to return member B from WINSA. Consider passing TRUE
                                // for the fStatic parameter.
                                GetGrpMem(
                                        SesId,
                                        TblId,
                                        pRowInfo,
                                        pRowInfo->TimeStamp,
                                        pStatusInfo,
                                        NMSDB_IS_ENTRY_STATIC_M(FlagVal),
                                        &fIsMem
                                         );

                                if ((pStatusInfo->NodeAdds.NoOfMems == 0)
                                        && !pRowInfo->fAdmin)
                                {
                                        pStatusInfo->StatCode =
                                                NMSDB_NO_SUCH_ROW;
                                }
                        }
                        else  //special group/multihomed entry is a tombstone
                        {
                                pStatusInfo->NodeAdds.NoOfMems = 0;
                                pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                        }

                        //
                        // If the group/multihomed entry does not have any
                        // members (i.e. all members have timed out, change
                        // the state of the entry to RELEASED
                        //
FUTURES("Maybe change the state of the group to released now")

                } // it is a special group or multihomed entry
           }
        }
        else
        {
           RetStat = WINS_FAILURE;
        }

        //
        // If this function was invoked in an RPC thread and all
        // operation upto now have succeeded, let us get the owner Id and
        // version number of the record
        //
        if ((pRowInfo->fAdmin) && (RetStat == WINS_SUCCESS))
        {

            pStatusInfo->EntryState_e  =  NMSDB_ENTRY_STATE_M(FlagVal);
            pStatusInfo->fStatic       = NMSDB_IS_ENTRY_STATIC_M(FlagVal);

#if !NEW_OWID
pStatusInfo->OwnerId = 0;
#endif
            /*
             * Retrieve the owner Id column.
            */
            CALL_M(
                  JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &pStatusInfo->OwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                         )
                  );
              //
              // Retrieve the version number
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                        &(pStatusInfo->VersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

             //
             // get the timestamp field
             //
             CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pStatusInfo->TimeStamp),
                        sizeof(pStatusInfo->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );
        }
}
finally {
        JET_ERR JetRetStat;
        JetRetStat = JetRollback(pTls->SesId, JET_bitRollbackAll);
        if (!AbnormalTermination())
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
            CALL_M(JetRetStat);
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
        }
        return(RetStat);
}

STATUS
NmsDbUpdateRow(
        IN   PNMSDB_ROW_INFO_T        pRowInfo,
        OUT  PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function replaces a conflicting row in the database with the
        row passed.  It expects the currency to be on the record

Arguments:
        pRowInfo    - Information about the record to insert/replace
        pStatusInfo - Status of operation and information about the conflicting
                      record if the update resulted in a conlfict (only for
                      an insert)

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NBT request thread -- NmsNmhNamRegInd()

Side Effects:

Comments:
        None
--*/
{

        JET_TABLEID     TblId;
        JET_SESID        SesId;
        PWINSTHD_TLS_T        pTls;
#ifdef WINSDBG
        JET_ERR     JetRetStat;
#endif

        pTls  = TlsGetValue(WinsTlsIndex);

        // No need to check whether pTls is NON-NULL.  It has to be

        TblId = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        pStatusInfo->StatCode = NMSDB_SUCCESS;


#ifndef WINSDBG
         /*
          * Replace the row
         */
         CALL_M(
                UpdateDb(
                        SesId,
                        TblId,
                        pRowInfo,
                        JET_prepReplace
                         )
               );
#else

    JetRetStat =   UpdateDb( SesId,  TblId,  pRowInfo, JET_prepReplace );

    if (JetRetStat == JET_errKeyDuplicate)
    {
            BYTE Tmp[20];
            WinsEvtLogDetEvt(FALSE, WINS_EVT_DB_ERR, NULL, __LINE__,
              "sssdd", pRowInfo->pName, _itoa(pRowInfo->VersNo.LowPart, Tmp, 10), _itoa(pStatusInfo->VersNo.LowPart, Tmp, 10), pRowInfo->OwnerId, pStatusInfo->OwnerId);
            DBGPRINT5(ERR, "NmsDbUpdateRow: Could not replace row\nName=(%s);Owner id = (%d);Vers. no = (%d)\nNew owner id = (%d); New Vers.No = (%d)\n",
           pRowInfo->pName, pStatusInfo->OwnerId, pStatusInfo->VersNo.LowPart,
           pRowInfo->OwnerId, pRowInfo->VersNo.LowPart);

            return(WINS_FAILURE);
    }
    else
    {
        CALL_M(JetRetStat);
    }
#endif

        //
        // NOTE: This call must be made after the UpdateDb above
        // because otherwise we will need to seek to the record
        // to be replaced
        //
        UpdHighestVersNoRecIfReqd(pTls, pRowInfo, pStatusInfo);

        return(WINS_SUCCESS);
}

STATUS
NmsDbSeekNUpdateRow(
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function seeks to a conflicting record and then replaces it
        in the database with the row passed.


Arguments:
        pRowInfo - Contains name to query
        pStatusInfo - Information about the name queried


Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ChlUpdDb (Name Challenge thread) in NmsChl.c

Side Effects:

Comments:
        Currently, this function is called only by the Name Challenge manager.
        When it starts getting called by another component, we would need
        to make sure that comparison of the owner id. retrieved from the
        row to be replaced with the one we retrieved prior to handing the
        request to the name challenge manager is the correct action for all
        situations.
--*/
{

        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
#if NEW_OWID
        DWORD            OwnerId;
#else
        DWORD            OwnerId = 0;
#endif
        DWORD           ActFldLen;
        JET_ERR         JetRetStat;
        STATUS          RetStat = WINS_SUCCESS;

        pTls  = TlsGetValue(WinsTlsIndex);

        //
        // No need to check whether pTls is NON-NULL.  It has to be
        //
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;
        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pRowInfo->pName,
                        pRowInfo->NameLen,
                        JET_bitNewKey
                          )
                        );

        if ((JetRetStat = JetSeek(
                SesId,
                TblId,
                JET_bitSeekEQ
                    )) ==  JET_errSuccess
            )
         {


                //
                // Before replacing the row, let us check whether it is still
                // owned by the same owner.  We check this because during the
                // window in which this challenge thread was working, the
                // replicator might have pulled in records from another WINS
                // server and updated the row with another row or a local
                // nbt request might have resulted in the row getting updated
                // (if it was a replica first). In either of the two cases
                // above, we do not want to update the row.
                //

                /*
                 * Retrieve the owner Id column.
                */
                   CALL_M(
                           JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                &ActFldLen,
                                0,
                                NULL
                                           )
                     );

                if (OwnerId == pStatusInfo->OwnerId)
                {

                    /*
                     * Replace the row
                    */
                    CALL_M(
                        UpdateDb(
                                SesId,
                                TblId,
                                pRowInfo,
                                JET_prepReplace
                                 )
                          );

                    //
                    // NOTE: This call must be made after the UpdateDb above
                    // because otherwise we will need to seek to the record
                    // to be replaced
                    //
                    UpdHighestVersNoRecIfReqd(pTls, pRowInfo, pStatusInfo);
                }
         }
         else
         {
                /*
                 * Means that some other thread (other than challenger),
                 * deleted the record. It has to be an rpc thread since
                 * an NBT thread would release the record, not delete it
                */
                WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                RetStat = WINS_FAILURE;
        //        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
         }

         return(RetStat);
}



STATUS
NmsDbGetDataRecs(
        IN  WINS_CLIENT_E   Client_e,
        IN  OPTIONAL INT    ThdPrLvl,
        IN  VERS_NO_T       MinVersNo,
        IN  VERS_NO_T       MaxVersNo,
        IN  DWORD           MaxNoOfRecsReqd,
        IN  BOOL            fUpToLimit,
        IN  BOOL            fOnlyReplTomb OPTIONAL,
        IN  PNMSSCV_CLUT_T  pClutter,
        IN  OUT PCOMM_ADD_T  pWinsAdd,
        IN  BOOL            fOnlyDynRecs,
        IN  DWORD           RplType,
        OUT LPVOID          *ppRBuf,
        OUT LPDWORD         pRspBufLen,
        OUT LPDWORD         pNoOfRecs
)

/*++
Routine Description:

        This function returns all the records in the range MinVersNo to
        MaxVersNo that are owned by the WINS server at address pWinsAdd.

Arguments:
        Client_e  - id of client that called this function (Pull handler in
                    replicator or the scavenger thread)
        ThdPrLvl  - priority level of the scavenger thread
        MinVersNo, MaxVersNo - range of version numbers to retrieve
        MaxNoOfRecsReqd - Max. number of records required
        fUpToLimit - Set to TRUE, if the max. version number arg is to
                     be ignored and records upto the last one in the db
                     have to be retrieved
        fOnlyReplTomb  - Only tombstones desired (valid if Client_e is NMSSCV)
        pWinsAdd   - Wins whose records need to be retrieved (owner WINS)
        ppRbuf           - Buffer to contain the records
        pRspBufLen - size of the buffer
        pNoOfRecs  - No of records in the buffer

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        DoScavenging(), UpdDb in nmsscv.c,
        HandleSndEntriesReq() in rplpush.c

Side Effects:

Comments:
        This function changes the index on the name address table to
        clustered index.

        This function has grown over time.  It needs to be streamlined.

--*/
{
        JET_ERR             JetRetStat;
        DWORD                OwnerId;
        DWORD               ActFldLen; //length of fld retrieved
        VERS_NO_T           VersNoDiff;
        VERS_NO_T           TmpNoOfEntries;
        LPBYTE              pStartBuff;
        DWORD               SaveBufLen;
        BYTE                EntTyp; //type of entry (unique/group/special group)
        PRPL_REC_ENTRY_T    pRspBuf;
        JET_TABLEID         TblId;
        JET_SESID           SesId;
        PWINSTHD_TLS_T      pTls;
#if NEW_OWID
        DWORD                RecordOwnerId;
#else
        DWORD               RecordOwnerId = 0;
#endif
        STATUS              RetStat = WINS_SUCCESS;
        VERS_NO_T           DefNo;
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD               InitHeapSize;
        DWORD               MemSize;

#ifdef WINSDBG
        DWORD               StartTime;
        DWORD               EndTime;
#endif
        DWORD               CommitCnt = 1;   //do not set to any other value
        BOOL                fTransCommitted;
//        LPVOID              pCallersAdd, pCallersCaller;

        DBGENTER("NmsDbGetDataRecs\n");
//        RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
//        DbgPrint("Callers Address = (%x)\nCallersCaller = (%x)\n", pCallersAdd, pCallersCaller);

#ifdef WINSDBG
        if (!fOnlyReplTomb)
        {
           struct in_addr InAddr;
           if (!fUpToLimit)
           {
                InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
                if (MaxNoOfRecsReqd == 0)
                {
                  DBGPRINT5(DET, "NmsDbGetDataRecs:Will retrieve records in the range (%lu %lu) to (%lu %lu) of WINS having address = (%s)\n",
                                MinVersNo.HighPart,
                                MinVersNo.LowPart,
                                MaxVersNo.HighPart,
                                MaxVersNo.LowPart,
                                inet_ntoa(InAddr)
                         );
                }
                else
                {
                  DBGPRINT4(DET, "NmsDbGetDataRecs:Will retrieve a max. of %d records starting from (%lu %lu) version number of WINS having address = (%s)\n",
                                MaxNoOfRecsReqd,
                                MinVersNo.HighPart,
                                MinVersNo.LowPart,
                                inet_ntoa(InAddr)
                         );
                }
           }
           else
           {
                   if (pWinsAdd)
                   {
                       InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
                       DBGPRINT3(DET, "NmsDbGetDataRecs: Will retrieve all records starting from version no (%d %d) for WINS (%s)\n", MinVersNo.HighPart, MinVersNo.LowPart, inet_ntoa(InAddr));


                   }
                   else
                   {
                       //
                       // fToLimit = TRUE and fOnlyReplTomb = FALSE means we
                       // are interested only in (active) replicas
                       //
                       DBGPRINT1(DET, "NmsDbGetDataRecs: Will retrieve all active replica records older than verify interval for WINS with owner id = (%d)\n",
                                pClutter->OwnerId);

                   }

           }
        }
        else
        {
               DBGPRINT1(DET, "NmsDbGetDataRecs: Will retrieve %s replica tombstones\n", fUpToLimit ? "all" : "specified range");
        }
#endif

        //
        // initialize the default no. that determines the size of the
        // buffer to allocate in case the range specified by the Max and
        // Min Vers. No args is > it
        //
PERF("Move this to NmsDbInit")
        WINS_ASSIGN_INT_TO_VERS_NO_M(DefNo, INIT_NO_OF_ENTRIES);
        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        pTls->HeapHdl = NULL;  //make it NULL so that the caller can determine
                               //whether this function allocated a heap
                               //before returning (normally/abnormally)

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;



        /*
          allocate a buffer using some rough calculations.  Note: The
          calculations help only if the difference between MaxVersNo and
          MinVersNo is less than the predefined number (of records) we use for
          allocating a buffer.  if the difference is > this predefined number,
          we use the predefined number since it might still suffice considering
          that  there may be gaps between version numbers of records falling
          in the  Min-Max range
        */
        if ((!fOnlyReplTomb) && (!fUpToLimit))
        {
           //
           // If a max. number has been specified, use that one.
           // Currently, only the scavenger thread specifies a non-zero
           // value for MaxNoOfRecsReqd
           //
           if (MaxNoOfRecsReqd == 0)
           {

             VersNoDiff.QuadPart =  LiSub(MaxVersNo,MinVersNo);

             //
             // If client is the push thread, since we will never send more
             // than RPL_MAX_LIMIT_FOR_RPL records, do not allocate more
             // memory than is required.
             //
             //
             if (Client_e == WINS_E_RPLPUSH)
             {
               LARGE_INTEGER        TmpNo;
               WINS_ASSIGN_INT_TO_LI_M(TmpNo, RPL_MAX_LIMIT_FOR_RPL);
               if (LiGtr(VersNoDiff, TmpNo))
               {
                        VersNoDiff = TmpNo;
               }
             }
             NMSNMH_INC_VERS_NO_M( VersNoDiff, VersNoDiff );
           }
           else
           {
                VersNoDiff.QuadPart  = MaxNoOfRecsReqd;
           }

           TmpNoOfEntries = LiGtr(VersNoDiff, DefNo) ? DefNo : VersNoDiff;
       }
       else
       {
                TmpNoOfEntries = DefNo;
       }

        //
        // Store the memory size for the records.  Note: This
        // does not contain the memory for the name and addresses
        // (in case of a special group or a multihomed entry). The
        // sizes for these will be added as we store each record.
        //
        MemSize     = RPL_REC_ENTRY_SIZE *  (TmpNoOfEntries.LowPart + 1);
        *pRspBufLen = MemSize + 10000; //for good measure;



        //
        // We will create a heap with the above amount of memory plus a
        // pad for heap overhead.  We add TmpNoOfEntries.LowPart * 17
        // since each record will have memory allocated for the name.
        // Names in general will be 17 bytes long (we attach a NULL at the
        // end when registering names).
        //
        if (Client_e == WINS_E_RPLPUSH)
        {
                InitHeapSize = (*pRspBufLen * 4) + (TmpNoOfEntries.LowPart * 17)                                         + PAD_FOR_REC_HEAP;
        }
        else
        {
                InitHeapSize = *pRspBufLen + (TmpNoOfEntries.LowPart * 17)
                                        + PAD_FOR_REC_HEAP;
        }


        //
        // Create the heap
        //
        pTls->HeapHdl = WinsMscHeapCreate(0, InitHeapSize);

        pRspBuf = WinsMscHeapAlloc(pTls->HeapHdl, MemSize);

        pStartBuff  = (LPBYTE)pRspBuf;        //save start of buffer
        SaveBufLen  = MemSize;                //save size of buffer
        *ppRBuf     = pStartBuff;
        *pNoOfRecs  = 0;

        //
        // If we are not acquiring just tombstones
        //
        if (!fOnlyReplTomb)
        {
            //
            // Actually, we can call RplFindOwnerId for Scavenger thread
            // We choose not to do so to avoid some overhead -- see the
            // comment in the else block.
            //
            if (Client_e != WINS_E_NMSSCV)
            {
              BOOL  fAllocNew =  FALSE;
#if 0
              BOOL  fAllocNew =
                              (Client_e == WINS_E_WINSRPC) ? FALSE : TRUE;
              //
              // The following function enters a critical section.
              //
              // We do not want this function to allocate an
              // an entry in the OwnAddTbl table for the Wins if we
              // are executing in a RPC thread.  We want to add
              // a WINS address - Owner Id mapping in the above table
              // (if not existent) only as a result of normal (as versus
              // administrator initiated) actions of the WINS.
              //
              //  NOTE: if there is no entry for the WINS address in the
              //  in-memory owner address table, the administrative
              //  action to retrieve records for a non-existent WINS will
              //  fail later on (as it should). Check out WinsGetDbRecs
              //
#endif
            try {
              if (RplFindOwnerId(
                            pWinsAdd,
                            &fAllocNew,
                            &OwnerId,
                            WINSCNF_E_IGNORE_PREC,
                            WINSCNF_LOW_PREC
                            ) != WINS_SUCCESS
                  )
                {
                        DBGPRINT1(ERR, "NmsDbGetDataRecs: Could not find owner id of address = (%x)\n", pWinsAdd->Add.IPAdd);
                        //
                        // The client may not look at the return value, but
                        // it will look at the *pNoOfRecs value and thus
                        // determine that there are no records.
                        //
                        return(WINS_FAILURE);
                }
             }
            except(EXCEPTION_EXECUTE_HANDLER) {
                        DWORD  ExcCode = GetExceptionCode();
                        DBGPRINT1(EXC, "NmsDbGetDataRecs: Got exception %x",
                                        ExcCode);
                        WINSEVT_LOG_M(ExcCode, WINS_EVT_EXC_RETRIEVE_DATA_RECS);
                        return(WINS_FAILURE);
                }
            }
            else
            {
                //
                // Executed by scavenger thread. pClutter will not be NULL
                // if we are verifying the validity of old replicas
                //
                if (!pClutter)
                {
                  //
                  // The scavenger thread calls this function either to
                  // get all replica tombstones, to get records owned
                  // by the local WINS or verify the validity of old active
                  // replicas. We therefore do not need to call the
                  // RplFindOwnerId function (not calling it lets us avoid a
                  // executing a chunk of code and also saves us from entering
                  // a  critical section)
                  //
                  OwnerId = 0;
                }
                else
                {
                  //
                  // We are just interested in active replicas that are older
                  // than the verify interval
                  //
                  OwnerId = (BYTE)pClutter->OwnerId;
                }
            }
        }
        else
        {
                //
                // Tombstones are to be retrieved.
                //
                // Actually we should enter a critical section prior to
                // retrieving the value of NmsDbNoOfOwners since it
                // can be changed by the Pull thread.  We choose not to
                // do so in order to save some overhead.  Even if we
                // get the wrong value (very low probability), we will
                // know of it when we do the seek.  If we get <=1 when
                // it is actually more than 1, it is still ok since we
                // will get the right value next time (or next to next)
                //
FUTURES("Enter critical section to get NmsDbNoOfOwners.  Raise priority")
FUTURES("before doing so")
                if (NmsDbNoOfOwners > 1)
                {
                        //
                        // We are interested in getting tombstones of
                        // replicas only. Tombstones on entries owned
                        // by the local WINS will be retrieved separately
                        // (every time we check whether owned entries need
                        // to be released or made tombstones)
                        //
                        OwnerId            = 1;
#if 0
                        MinVersNo.LowPart  = 0;
                        MinVersNo.HighPart = 0;
#endif
                        MinVersNo.QuadPart  = 0;
                }
                else
                {
                        DBGPRINT0(FLOW, "NmsDbGetDataRecs: This DB HAS NO REPLICAS IN IT\n");
                        DBGLEAVE("NmsDbGetDataRecs\n");

                        //
                        // The buffer allocated above will get deallocated
                        // in UpdDb (in nmsscv.c)
                        //
                        //*ppRBuf = pStartBuff;
                        return(WINS_SUCCESS);
                }
        }

        /*
        *  start a transaction
        */
        CALL_M( JetBeginTransaction(SesId) );
        fTransCommitted = FALSE;
try {
        /*
         * Use primary index now
        */
        CALL_M( JetSetCurrentIndex(
                                SesId,
                                TblId,
                                NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &MinVersNo,
                                sizeof(VERS_NO_T),
                                0        //0 for grbit since this is not the
                                        //first component of the key
                          )
              );

        JetRetStat = JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekGE
                        );

        if (JetRetStat == JET_errRecordNotFound)
        {
                //
                // This is an error only if the function was called in the
                // PUSH thread (HandleSndEntriesRsp()). If it was called
                // in the Scavenger thread (DoScavenging()), it may not be an
                // error.  This is because when scavenging, we start with
                // the lowest version number possible (1) in specifying a
                // range the size of WinsCnf.ScvChunk. We them make successive
                // calls for getting the next batch of records in equal
                // sized ranges that occur in tandem until we reach the
                // highest version number of owned records as indicated
                // by NmsNmhMyMaxVersNo. It is thus very much possible that
                // the ranges specified at the lower end of the list of
                // ranges are devoid of records
                //
                if (Client_e == WINS_E_RPLPUSH)
                {
                        DBGPRINT5(ERR, "Weird.  Could not locate even one record in the range (%d %d) - (%d %d) of owner with id (%d)\n",
                        MinVersNo.HighPart,
                        MinVersNo.LowPart,
                        MaxVersNo.HighPart,
                        MaxVersNo.LowPart,
                        OwnerId);

                        WINSEVT_LOG_M(
                                        WINS_FAILURE,
                                        WINS_EVT_CANT_FIND_ANY_REC_IN_RANGE
                                     );

                        //
                        // Don't free memory.  It will get freed later by
                        // HandleSndEntriesRsp/DoScavenging.  In case the caller
                        // is HandleSndEntriesRsp(), what will happen is that
                        // it will send a response with 0
                        // records (i.e. no records).  The Pull Pnr will
                        // find this out and will continue to function normally
                        //
                        // The response with 0 records is doing the work of a
                        // negative (error) response.
                        //
                        RetStat = WINS_FAILURE;
                }
#ifdef WINSDBG
                else  // has to be WINS_E_NMSSCV or WINS_E_WINSRPC
                {
                        DBGPRINT0(DET, "NmsDbGetDataRecs: Did not find even one record in the db.  Maybe all got deleted\n");
                }
#endif
        }
        else  //JetSeek did not return JET_errRecordNotFound.
        {
            UINT nLoops = 0;

CHECK("It may be better to count the number of records first and allocate")
CHECK(" a buffer big enough to store all of them (i.e. take a hit once")
CHECK(" than a small hit of an if test in every iteration. ")
           //
           // Do until there are no more records in the database to retrieve
           //

           //
           // We are assured of there being at least one record since the
           // JetSeek succeeded (if not for the owner we are interested in
           // then for the next one).
           // We can therefore safely use the do .. while() construct
           //
           // *NOT REALLY.  It seems that JetSeek can return JET_wrnSeekNE
           // even when there are no records in the db.  In such a case,
           // our JetRetrieveColumn will fail with a CurrencyNot there error
           //
CHECK("Check with IAN JOSE")

#ifdef WINSDBG
           //(void)time(&StartTime);
           StartTime = GetTickCount();
#endif
           do
           {
               //
               // If the number of records has exceeded what can be stored
               // in our buffer, allocate another buffer with space for DefNo (INIT_NO_OF_ENTRIES = 1000) more records
               //
               if (*pNoOfRecs > TmpNoOfEntries.LowPart)
               {
                    UINT_PTR   Offset = (LPBYTE)pRspBuf - pStartBuff;

                    //
                    // Not a bad place to check whether WINS has been
                    // terminated.  Scavenger thread can take a long time
                    // to go through the entire db if it is large and so
                    // a net stop can take a long time to finish.  This
                    // check here should speed up net stop.
                    //
                    if (Client_e == WINS_E_NMSSCV)
                    {
                          WinsMscChkTermEvt(
#ifdef WINSDBG
                              WINS_E_NMSSCV,
#endif
                              TRUE
                                      );

                    }
                    DBGPRINT1(FLOW, "NmsDbGetDataRecs: No of Records (%d) are more than what we can store in our buffer.  We will allocate a new one\n", *pNoOfRecs);

                    TmpNoOfEntries.QuadPart = TmpNoOfEntries.QuadPart + DefNo.QuadPart;
                    ASSERT(!(TmpNoOfEntries.HighPart & 0x80000000));
                    ASSERT(TmpNoOfEntries.LowPart < 0xFFFFFFFF);


                    MemSize = RPL_REC_ENTRY_SIZE * ((DWORD)TmpNoOfEntries.QuadPart + 1);
                    pRspBuf = HeapReAlloc(pTls->HeapHdl,
                                          HEAP_GENERATE_EXCEPTIONS |
                                          HEAP_ZERO_MEMORY,
                                          pStartBuff, MemSize);


                    DBGPRINT1(DET, "NmsDbGetDataRecs: Doing a realloc in thd\n", pTls->ThdName);
                    //
                    // Save the start position of the new buffer
                    //
                    pStartBuff  = (LPBYTE)pRspBuf;

                    *ppRBuf     = pStartBuff;

                    //
                    // Make pRspBuf point to just past the last record
                    // inserted
                    //
                    pRspBuf    =  (PRPL_REC_ENTRY_T)(pStartBuff + Offset);

                    //
                    // Add the length we incremented *pRspBufLen by to
                    // the new memory size
                    //
                    *pRspBufLen = (*pRspBufLen - SaveBufLen) + MemSize;

                    //
                    // Store the new length in SaveBufLen
                    //
                    SaveBufLen  = MemSize;

              }

              JetRetStat = JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &RecordOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                            );

             {
                //
                // check that we don't have some other error here
                //
FUTURES("Yet another hack to workaround jet bugs = 7-11-94")
                if (JetRetStat == JET_errRecordDeleted)
                {
                     DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n",
                                      JetRetStat, __LINE__);
                     goto chkTransaction;

                }
                CALL_M(JetRetStat);
             }
PERF("In case fOnlyReplTomb is true, retrieve the state field first")
              //
              // if only tombstones are required, it means that we need
              // all tombstones irrespective of owner
              //
              if (!fOnlyReplTomb)
              {
                 if (RecordOwnerId != OwnerId )
                 {
                   //
                   // We have exhausted all records for the owner. Break out
                   // of the loop
                   //
                  break;
                 }
              }


              //
              // Retrieve the version number
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                        &(pRspBuf->VersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

              //
              // if only tombstones are required, it means that we need
              // all tombstones irrespective of version number
              //
              if (
                  (!fOnlyReplTomb)
                        &&
                  (!fUpToLimit)
                        &&
                  LiGtr(pRspBuf->VersNo, MaxVersNo)
                 )
              {
                 //
                 // We have acquired records upto MaxVersNo.  Break out
                 // of the loop
                 //
                 break;
              }


              //
              // Retrieve the flags byte
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &(pRspBuf->Flag),
                        sizeof(pRspBuf->Flag),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

              //
              // if we were asked to retrieve only dynamic records and
              // this record is static, skip it.
              //
              if (fOnlyDynRecs && NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
              {
//                        DBGPRINT0(DET, "NmsDbGetDataRecs: Encountered a STATIC record but were asked to retrieve only dynamic records\n");
                        goto chkTransaction;
              }

              //
              // retrieve the name
              //
              CALL_M(JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                        //pRspBuf->Name,
                        Name,
                        NMSDB_MAX_NAM_LEN,
                        &(pRspBuf->NameLen),
                        0,
                        NULL  ) );

             //
             // if name length is > 255, jet is returning an invalid value.
             // Make the length equal to the max. length we can have for
             // a netbios name.  Also, log an event
             //
             if (pRspBuf->NameLen > WINS_MAX_NAME_SZ)
             {
                 WINSEVT_LOG_M(pRspBuf->NameLen, WINS_EVT_NAME_TOO_LONG);
                 DBGPRINT1(ERR, "NmsDbGetDataRecs: Name length is too long = (%x)\n", pRspBuf->NameLen);
                 pRspBuf->NameLen = WINS_MAX_NS_NETBIOS_NAME_LEN;
             }


             //
             // This macro will allocate memory and store the name in it
             //
             NMSDB_STORE_NAME_M(pTls, pRspBuf, Name, pRspBuf->NameLen);

              //
              // We need to retrieve the address field if we are in the
              // PUSH thread or an RPC thread
              //
              if (Client_e != WINS_E_NMSSCV)
              {
                    //
                    // If the record is released, go to the next record
                    //
                    if(
                         (Client_e == WINS_E_RPLPUSH)
                                 &&
                         (NMSDB_ENTRY_REL_M(pRspBuf->Flag))

                      )
                    {
                        DBGPRINT0(DET,
        "NmsDbGetDataRecs: ENCOUNTERED A RECORD IN THE RELEASED STATE\n");

                        goto chkTransaction;
                    }

                   EntTyp = (BYTE)((pRspBuf->Flag & NMSDB_BIT_ENT_TYP));
                   if (
                        (EntTyp == NMSDB_UNIQUE_ENTRY)
                                    ||
                        (EntTyp == NMSDB_NORM_GRP_ENTRY)
                      )
                   {
                      /* It is a unique entry*/
                      pRspBuf->fGrp = (EntTyp == NMSDB_UNIQUE_ENTRY) ?
                                                        FALSE : TRUE;
                      CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRspBuf->NodeAdd,
                                 sizeof(COMM_ADD_T),
                                &ActFldLen,
                                0,
                                NULL
                                        )
                            );

                   }
                   else  // it is a special group or a multihomed entry
                   {


                      //
                      // Even if the entry is a multihomed entry, we set the
                      // fGrp flag to TRUE so that the formatting function
                      // works properly (called by PUSH thread).  The EntTyp
                      // will be used to decipher whether it is a multihomned
                      // entry or not
                      //
FUTURES("Remove this hacky mechanism")
                      pRspBuf->fGrp =
                          (EntTyp == NMSDB_SPEC_GRP_ENTRY) ? TRUE : FALSE;

                     /*
                     *  get member addresses.
                     *
                     * If we are in an RPC thread, we want to get the members
                     * even if they are expired.  We can do that by
                     * passing a TRUE value for the STATIC flag parameter.
                     */
                     StoreGrpMems(
                             pTls,
                             Client_e,
                             pRspBuf->pName,
                             ThdPrLvl,
                             SesId,
                             TblId,
                             (WINS_E_WINSRPC == Client_e ? TRUE
                                                         : NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag)),
                             pRspBuf
                            );


                   //
                   // if the record is active but has no members,
                   // don't send it. It is possible that all
                   // members of the group  expired after the last scavenging
                   // cycle.  This record will be marked RELEASED at the next
                   // scavenging cycle.
                   // For now ignore the record
                   //
                   if (
                        (pRspBuf->NoOfAdds == 0)
                                &&
                        (NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                      )
                   {
                        if (Client_e == WINS_E_RPLPUSH)
                        {
                           DBGPRINT2(FLOW, "NmsDbGetDataRecs: Active Group (Version # %d %d) has no members. So it is not being replicated\n", pRspBuf->VersNo.HighPart, pRspBuf->VersNo.LowPart/*pRspBuf->Name*/);

                          goto chkTransaction;
                        }
                        else
                        {
                             //
                             //Must be an RPC thread.
                             //Change the state to released so that the
                             //record shows up as released when displayed
                             //
                             NMSDB_CLR_STATE_M(pRspBuf->Flag);
                             NMSDB_SET_STATE_M(pRspBuf->Flag, NMSDB_E_RELEASED);

                        }
                   }
                }  // end of else


                //
                // Adjust the size to be passed to the push thread
                //
                if (Client_e == WINS_E_RPLPUSH)
                {
                      *pRspBufLen += pRspBuf->NameLen;
                      if ((EntTyp == NMSDB_MULTIHOMED_ENTRY) ||
                          (EntTyp == NMSDB_SPEC_GRP_ENTRY)
                         )
                      {
                        *pRspBufLen +=
                               (pRspBuf->NoOfAdds * sizeof(COMM_ADD_T) * 2);
                      }
                }

                //
                // If client is the RPC thread, retrieve the timestamp
                //
                if (Client_e == WINS_E_WINSRPC)
                {
                   //
                   // get the timestamp field
                   //
                       CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pRspBuf->TimeStamp),
                        sizeof(pRspBuf->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );
                   if (!fOnlyDynRecs && NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag)
                           && (OwnerId == NMSDB_LOCAL_OWNER_ID) && NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                   {
                          pRspBuf->TimeStamp = MAXLONG;
                   }
                }
              }
              else  //client is the scavenger thread
              {
                 //
                 // If only tombstones are required and this record is not
                 // a tombstone, go to the next record
                 //
                 if (fOnlyReplTomb && !NMSDB_ENTRY_TOMB_M(pRspBuf->Flag))
                 {
                        goto chkTransaction;
                 }

                 //
                 // pClutter will not be NULL if this function was called
                 // by the scavenger thread to either retrieve replica
                 // tombstones or to retrieve replicas  for consistency
                 // checking
                 //
                 if (pClutter && !fOnlyReplTomb)
                 {
                         //
                         // Want all replicas
                         // for consistency checking
                         //
                         if ( !pClutter->fAll)
                         {
                             //
                             // just interested in active records
                             //
                             if (!NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                             {
                                goto chkTransaction;
                             }
                         }
                 }

                 //
                 // get the timestamp field
                 //
                 CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pRspBuf->TimeStamp),
                        sizeof(pRspBuf->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );


                if (pClutter)
                {
                  //
                  // if we are retrieving clutter, check the time stamp
                  // unless this is a static record
                  //
                  if( !fOnlyReplTomb)
                  {
FUTURES("We need to skip this for owned static records only, not for all")
//                    if (!NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
                    {
                      //
                      // if this record is not old enough, we are not interested
                      //
                      if (
                         pClutter->Age  &&
                         (pRspBuf->TimeStamp >  (DWORD)pClutter->CurrentTime)
                         )
                      {
                        goto chkTransaction;
                      }
                   }
                  }
                  else
                  {
                    //
                    // We want replica tombstones.
                    //
                    if (NMSDB_ENTRY_TOMB_M(pRspBuf->Flag))
                    {
                      if (pClutter->CurrentTime < (time_t)pRspBuf->TimeStamp)
                      {
                        goto chkTransaction;
                      }
                    }

                  }
               }

              } // end of else (Client is the scavenger thread)

             //
             // increment the counter and the pointer to past the last record.
             //
             pRspBuf = (PRPL_REC_ENTRY_T)((LPBYTE)pRspBuf + RPL_REC_ENTRY_SIZE);

             (*pNoOfRecs)++;

             if (Client_e == WINS_E_RPLPUSH)
             {
                    if (*pNoOfRecs == RPL_MAX_LIMIT_FOR_RPL)
                    {
                             break;
                    }
             }

             //
             // if we have retrieved the max. number asked for, break out of
             // the loop
             //
             if ((MaxNoOfRecsReqd > 0) && (*pNoOfRecs >= MaxNoOfRecsReqd))
             {
                break;
             }

chkTransaction:
             //
             // If this is the scavenger thread, let us give the version store
             // a breather after a certain number of records have been retrieved
             //
             if (nLoops/CommitCnt >= MAX_RECS_BEFORE_COMMIT)
             {

                //
                // Let us commit the transaction to free up the version store
                //
                CALL_M(
                        JetCommitTransaction(SesId, JET_bitCommitFlush)
                            );
                fTransCommitted = TRUE;
                CommitCnt++;
                CALL_M( JetBeginTransaction(SesId) );
                fTransCommitted = FALSE;

             }
             nLoops++;
          } while(JetMove(SesId, TblId, JET_MoveNext, 0) >= 0);
#ifdef WINSDBG
           EndTime = GetTickCount();
           DBGPRINT2(TM, "NmsDbGetDataRecs: Retrieved %d records in %d secs\n",
                                *pNoOfRecs, StartTime - EndTime);
#endif
     }  // end of else

} // end of try {..}
finally {
                if (AbnormalTermination())
                {
                        DWORD EvtCode;
                        DBGPRINT0(ERR,
                                "NmsDbGetDataRecs: Terminating abnormally\n");
                        if (Client_e == WINS_E_WINSRPC)
                        {
                                EvtCode = WINS_EVT_RPC_EXC;
                        }
                        else
                        {
                                EvtCode = (Client_e == WINS_E_RPLPUSH) ?
                                                WINS_EVT_RPLPUSH_EXC :
                                                WINS_EVT_SCV_EXC;
                        }
                        WINSEVT_LOG_M(WINS_FAILURE, EvtCode);
                        RetStat = WINS_FAILURE;
                }
                //*ppRBuf = pStartBuff;
                DBGPRINT1(FLOW, "NmsDbGetDataRecs:Retrieved %d records\n",
                                        *pNoOfRecs);

                //
                // If the no of records retrieved is 0, log an informational
                // message.  The reason for 0 records being retrieved could
                // be that all records are released
                //
                if (*pNoOfRecs == 0)
                {
                        WINSEVT_STRS_T  EvtStrs;
                        EvtStrs.NoOfStrs = 1;
                        if (Client_e == WINS_E_RPLPUSH)
                        {
                                //EvtStrs.pStr[0] = TEXT("Replicator Push");
                                if (WinsCnf.LogDetailedEvts > 0)
                                {
                                  WinsEvtLogDetEvt(TRUE,
WINS_EVT_NO_RPL_RECS_RETRIEVED, NULL, __LINE__, "ddddd", pWinsAdd != NULL ? pWinsAdd->Add.IPAdd : 0, MinVersNo.LowPart, MinVersNo.HighPart, MaxVersNo.LowPart, MaxVersNo.HighPart);
                                //WINSEVT_LOG_INFO_STR_D_M( WINS_EVT_NO_RPL_RECS_RETRIEVED, &EvtStrs );
                               }
                        }
                        else
                        {
                                // Per bug#339152 remove this.
                                //EvtStrs.pStr[0] = (Client_e == WINS_E_NMSSCV) ?TEXT("Scavenging") : TEXT("Client");
                                //WINSEVT_LOG_INFO_STR_D_M( WINS_EVT_NO_RECS_RETRIEVED, &EvtStrs );
                        }

                }
                //
                // We are done. Let us commit the transaction
                //
                if (!fTransCommitted)
                {
                    JET_ERR JetRetStat;
                    JetRetStat = JetCommitTransaction(SesId, JET_bitCommitFlush);
                    if (RetStat != WINS_FAILURE)
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                        CALL_M(JetRetStat);
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                }
        }

        DBGLEAVE("NmsDbGetDataRecs\n");
        return(RetStat);
}


VOID
StoreGrpMems(
   IN  PWINSTHD_TLS_T       pTls,
   IN  WINS_CLIENT_E        Client_e,
   IN  LPBYTE               pName,
   IN  INT                  ThdPrLvl,
   IN  JET_SESID            SesId,
   IN  JET_TABLEID          TblId,
   IN  BOOL                 fStatic,
   IN  PRPL_REC_ENTRY_T     pRspInfo
        )

/*++

Routine Description:
        This function retrieves all the addresses in the group record
        and stores them in the data structure passed to it

Arguments:
        Client_e - Client (indicates the thread) calling this function
        ThdPrLvl - The normal priority level of thread (is looked at only
                   if the client is WINS_E_NMSSCV (scavenger thread)
        SesId    - Id of this thread's session with the db
        TblId    - Id of the name-address table
        fStatic  - indicates whether the entry is STATIC
        RspInfo  - Contains members of a special group (after this function
                    is done)

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        NmsDbGetDataRecs

Side Effects:

Comments:
        This function assumes that a heap has been created for use by this
        thread.  Currently, this function is called only by NmsDbGetDataRecs
--*/

{
        BOOL                        fIsMem;
        NMSDB_ROW_INFO_T        RowInfo;
        NMSDB_STAT_INFO_T        StatusInfo;
        DWORD                        i;        //for loop counter
        DWORD                        n = 0;        //indexes NodeAdd array
        PNMSDB_WINS_STATE_E        pWinsState_e;
        PCOMM_ADD_T                pWinsAdd;
        PVERS_NO_T              pStartVersNo;
        PWINS_UID_T             pUid;

        //
        // init to 0
        //
        RowInfo.NodeAdds.Mem[0].Add.Add.IPAdd = 0;
        RowInfo.pName = pName;

        //
        // Get and store the current time.
        //
        (void)time(&RowInfo.TimeStamp);

        //
        // get all active group members
        //
        GetGrpMem(
                SesId,
                TblId,
                &RowInfo,
                RowInfo.TimeStamp,
                &StatusInfo,
                fStatic,
                &fIsMem
                  );

        pRspInfo->NoOfAdds = StatusInfo.NodeAdds.NoOfMems;

        //
        // If we are in the scavenger thread, raise our priority level to
        // normal before entering the critical section.
        //
        if (Client_e == WINS_E_NMSSCV)
        {
                    WinsMscSetThreadPriority(
                                        WinsThdPool.ScvThds[0].ThdHdl,
                                        THREAD_PRIORITY_NORMAL
                                        );
        }

        if (pRspInfo->NoOfAdds > 0)
        {
           //
           // Allocate memory to store group members
           //
           pRspInfo->pNodeAdd = WinsMscHeapAlloc(
                               pTls->HeapHdl,
                               StatusInfo.NodeAdds.NoOfMems *
                                        sizeof(COMM_ADD_T) * 2
                               );
        }
        else
        {
           pRspInfo->pNodeAdd = NULL;
        }

        //
        // This critical section guards us against simultaenous updates
        // to the NmsDbOwnAddTbl (accessed by RPL_FIND_ADD_BY_OWNER_ID_M
        // macro) by the PULL thread
        //
        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
try {
        //
        // Store the group members
        //
        for (i=0; i<StatusInfo.NodeAdds.NoOfMems; i++)
        {
                RPL_FIND_ADD_BY_OWNER_ID_M(
                                StatusInfo.NodeAdds.Mem[i].OwnerId,
                                pWinsAdd,
                                pWinsState_e,
                                pStartVersNo
                                          );
                //
                // First address is the address of the owner WINS
                // Second address is the address of the member
                //
                *(pRspInfo->pNodeAdd + n)   = *pWinsAdd;
                n++;
                *(pRspInfo->pNodeAdd + n)   = StatusInfo.NodeAdds.Mem[i].Add;
                n++;
        }
 }
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode =  GetExceptionCode();
        DBGPRINT1(EXC, "StoreGrpMems. Got Exception %x", ExcCode);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_GRP_MEM_PROC_EXC);
        }

        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

        if (Client_e == WINS_E_NMSSCV)
        {
                //
                // revert to old priority level
                //
                    WinsMscSetThreadPriority(
                                        WinsThdPool.ScvThds[0].ThdHdl,
                                        ThdPrLvl
                                        );
        }

        return;
}


STATUS
CreateTbl(
        JET_DBID        DbId,
        JET_SESID        SesId,
        JET_TABLEID        *pTblId,
        NMSDB_TBL_NAM_E        TblNam_e //enumerator value for table to create
        )

/*++

Routine Description:
        This function creates a table.

Arguments:
        DbId    - Database Id.
        SesId   - Session Id.
        pTblId  - Id of the table created
        TblNm_e - Identifies the table to create


Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsDbInit

Side Effects:

Comments:
        None
--*/

{
#define LANGID                 0x0409
#define CP                1252

        BYTE                 TmpCol[MAX_FIXED_FLD_LEN];
        DWORD                FldNo;        /*counter for fields        */
        JET_TABLEID        TblId;  /*id of table created*/
        JET_COLUMNDEF        columndef;

        //
        // Init fields of columndef that do not change between additions of
        // columns
        //
        columndef.cbStruct  = sizeof(columndef);
        columndef.columnid  = 0;
        columndef.cp            = CP;
        columndef.langid    = LANGID;
        columndef.cbMax     = 0;
        columndef.grbit     = 0;

        /*
         Switch on Table Name
        */
        switch(TblNam_e)
        {

            /*
                The Name to Address Mapping table needs to be created
            */
            case(NMSDB_E_NAM_ADD_TBL_NM):

                  /*
                        Create the Nam IP address mapping table
                  */
                  CALL_M( JetCreateTable(
                                SesId,
                                DbId,
                                NMSDB_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_TBL_PGS,
                                NMSDB_NAM_ADD_TBL_DENSITY,
                                &TblId
                                        )
                        );

NOTE("DDL such as AddColumn and CreateIndex on a table in shared access mode")
NOTE("will return an error unless we are at transaction level 0 (i.e no Begin")
NOTE("transaction).  If done on a table in exclusive mode, it is ok -- Ian ")
NOTE("10/16/93")
                 //
                 // In order to open the table with shared access, we need
                 // to close the handle returned from CreateTable (this
                 // one has deny read access flag set) and open the
                 // table for shared access
                 //
                 CALL_M(JetCloseTable(
                                SesId,
                                TblId
                                    )
                       );

                CALL_M(JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_NAM_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &TblId
                                        )
                     );

                  *pTblId = TblId;

                  /*
                        Add columns
                  */
                  for ( FldNo=0 ; FldNo < NO_COLS_NAM_ADD_TBL ; ++FldNo )
                  {

                    columndef.coltyp    = sNamAddTblRow[FldNo].FldTyp;
                    CALL_M( JetAddColumn (
                        SesId,                 // user
                        TblId,                 // table id
                        sNamAddTblRow[FldNo].pName,         // fld name
                        &columndef,                         // columndef
                        NULL,                                    // default value
                        0,                                 // default value length
                        &sNamAddTblRow[FldNo].Fid         // field id
                                        )
                          );
                  }


                  /*
                *   Create clustered index (in ascending order) on the name field.
                *
                *   In NT5.0 (Jet600), we do not create the cluster key.  The
                *   primary index is the one on which Jet clusters.  The primary
                *   key should be smaller, because in Jet600 Jet uses primary key
                *   bookmarks, meaning that the bookmark length will be entirely
                *   dependent on the length of the primary key.Jonathan Liem (1/7/97)
                *
                *   Rule for creating index:
                *
                *   The index key contains a sequence of concatenated
                *   column names, in order of key significance, each
                *   of which is null terminated and prefixed with either
                 *   '+' or '-', indicating ascending or descending.  The
                *   entire sequence must be double null terminated.
                *
               */

                sprintf( TmpCol, "+%s",
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].pName );

                TmpCol[ 2 +
                 strlen( sNamAddTblRow[NAM_ADD_NAME_INDEX].pName )
                      ] = '\0';

                if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
                    CALL_M(
                            JetCreateIndex(
                              SesId,
                              TblId,
                              NMSDB_NAM_ADD_CLUST_INDEX_NAME,  // name of index
                              JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull,
                              TmpCol,
                              3 +
                               strlen( sNamAddTblRow[NAM_ADD_NAME_INDEX].pName),
                              NMSDB_NAM_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                page to  be used*/
                                          )
                           );
                } else {
                    CALL_M(
                            JetCreateIndex(
                              SesId,
                              TblId,
                              NMSDB_NAM_ADD_CLUST_INDEX_NAME,  // name of index
                              JET_bitIndexClustered | JET_bitIndexUnique | JET_bitIndexDisallowNull,
                              TmpCol,
                              3 +
                               strlen( sNamAddTblRow[NAM_ADD_NAME_INDEX].pName),
                              NMSDB_NAM_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                page to  be used*/
                                          )
                           );

                }

CHECK("What exactly does DENSITY argument do for us")

               /*
                 * Create Primary Index using the ownerid and the version cols
               */
               sprintf( TmpCol, "+%s",
                        sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName
                       );

               sprintf(
               &TmpCol[2 + strlen(sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName)],
                          "+%s", sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName
                       );

               TmpCol[ 4 +
                         strlen( sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName ) +
                         strlen(sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName)
                       ] = '\0';


               if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
                   CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_NAM_ADD_PRIM_INDEX_NAME,  // name of index
                            JET_bitIndexUnique, //in jet600 dont need primary index.
                            TmpCol,
                            5 +
                             strlen( sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName) +
                             strlen( sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName),

                            NMSDB_NAM_ADD_PRIM_INDEX_DENSITY /*% space on each
                                                               page to  be used*/
                                        )
                          );

               } else {
                   CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_NAM_ADD_PRIM_INDEX_NAME,  // name of index
                            JET_bitIndexPrimary, //primary index is unique by def.
                            TmpCol,
                            5 +
                             strlen( sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName) +
                             strlen( sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName),

                            NMSDB_NAM_ADD_PRIM_INDEX_DENSITY /*% space on each
                                                               page to  be used*/
                                        )
                          );


               }

               break;


          case(NMSDB_E_OWN_ADD_TBL_NM):

                  /*
                        Create the Owner address mapping table
                  */

                  CALL_M( JetCreateTable(
                        SesId,
                        DbId,
                        NMSDB_OWN_ADD_TBL_NM,
                        NMSDB_OWN_ADD_TBL_PGS,
                        NMSDB_OWN_ADD_TBL_DENSITY,
                        &TblId
                                        )
                        );

                 //
                 // In order to open the table with shared access, we need
                 // to close the handle returned from CreateTable (this
                 // one has deny read access flag set) and open the
                 // table for shared access
                 //
                 CALL_M(JetCloseTable(
                                SesId,
                                TblId
                                    )
                       );

                CALL_M(JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_OWN_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &TblId
                                        )
                        );
                  *pTblId = TblId;

                  /*
                        Add columns
                  */
                  for ( FldNo=0 ; FldNo < NO_COLS_OWN_ADD_TBL ; ++FldNo )
                  {
                    JET_COLUMNDEF        columndef;

                    columndef.cbStruct  = sizeof(columndef);
                    columndef.columnid  = 0;
                    columndef.coltyp    = sOwnAddTblRow[FldNo].FldTyp;
                    columndef.cp        = 1252;
                    columndef.langid        = 0x0409;
                    columndef.cbMax     = 0;
                    columndef.grbit     = 0;

                    CALL_M( JetAddColumn(
                        SesId,                         // user
                        TblId,                 // table id
                        sOwnAddTblRow[FldNo].pName,         // fld name
                        &columndef,                         // columndef
                        NULL,                                    // default value
                        0,                                 // default value lenght
                        &sOwnAddTblRow[FldNo].Fid    // field id.
                                        )
                          );
                  } //end of for loop


                /*


                Insertions into this table will be in the order of increasing
                owner ids. with the owner id. 0 always referring to the local
                WINS.

                The state of an entry in the table can be active or down or
                deleted.

                As an aside (this comment is out of context here, but anyway..)

                deleted entries are removed at boot time. Also, all records
                owned by the WINS of a deleted entry are removed from the
                Name Address table at boot time.i This functionality is a
                future enhancement

                */

               /*
                *   Create clustered index
               */
                sprintf( TmpCol, "+%s",
                        sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName
                       );

                TmpCol[ 2 +
                  strlen( sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName )] = '\0';

                if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
                    CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_OWN_ADD_CLUST_INDEX_NAME,  // name of index
                            JET_bitIndexPrimary | JET_bitIndexUnique,
                            TmpCol,
                            3 +
                             strlen( sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName),
                            NMSDB_OWN_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                 page to alloc
                                                              */
                                        )
                         );
                } else{
                    CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_OWN_ADD_CLUST_INDEX_NAME,  // name of index
                            JET_bitIndexClustered | JET_bitIndexUnique,
                            TmpCol,
                            3 +
                             strlen( sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName),
                            NMSDB_OWN_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                 page to alloc
                                                              */
                                        )
                         );
                }

CHECK("Do we need to set this")
                /*
                *  Set the clustered index as the current index
                */
                       CALL_M(
                        JetSetCurrentIndex( SesId,
                                            TblId,
                                            NMSDB_OWN_ADD_CLUST_INDEX_NAME
                                          )
                      );

                break;
          default:
                        DBGPRINT1(ERR, "CreateTbl: Invalid Tbl id (%d)\n",
                                TblNam_e);
                        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
                        return(WINS_FAILURE);
                        break;
        } //end of switch

        return(WINS_SUCCESS);
}

STATUS
InitColInfo (
        JET_SESID        SesId,
        JET_TABLEID        TblId,
        NMSDB_TBL_NAM_E        TblNam_e
        )

/*++

Routine Description:

        This function is called to get information about the different
        columns of a table

Arguments:
        SesId    - Session Id
        TblId    - Id. of open table
        TblNam_e - Indicator or table


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsDbInit (Main Thread of the process)

Side Effects:

Comments:
        None
--*/
{
        JET_COLUMNDEF        ColumnDef;
        PFLD_T                pRow     = NULL;
        DWORD                FldNo    = 0;
        DWORD                NoOfCols = 0;
        STATUS RetStat = WINS_SUCCESS;

        /*
         Switch on Table Name
        */
        switch(TblNam_e)
        {

            /*
                The Name to Address Mapping table needs to be created
            */
            case(NMSDB_E_NAM_ADD_TBL_NM):

                   pRow     = sNamAddTblRow;
                   NoOfCols = NO_COLS_NAM_ADD_TBL;
                   break;

            case(NMSDB_E_OWN_ADD_TBL_NM):

                   pRow     = sOwnAddTblRow;
                   NoOfCols = NO_COLS_OWN_ADD_TBL;
                   break;

            default:

                DBGPRINT1(ERR, "InitColInfo: Invalid Tbl id (%d)\n",
                                TblNam_e);
                WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
                RetStat = WINS_FATAL_ERR;

                break;
        }



        /*
          Get info about columns
        */
       for ( FldNo=0 ; FldNo < NoOfCols; ++FldNo )
       {

            CALL_M( JetGetTableColumnInfo (
                        SesId,                         // user session
                        TblId,                         // table id
                        pRow[FldNo].pName,         // fld name
                        &ColumnDef,                 // columndef
                        sizeof(ColumnDef),
                        JET_ColInfo                //info level 0
                                     )
                  );


            pRow[FldNo].Fid = ColumnDef.columnid; // field id
       }

       return(RetStat);
}


STATUS
ReadOwnAddTbl(
        JET_SESID          SesId,
        JET_DBID          DbId,
        JET_TABLEID     TblId
        )

/*++

Routine Description:

        This function is called to read all the entries of the Owner - Address
        mapping table into the in-memory data structure

        It is called at init time

Arguments:
        SesId
        DbId
        TblId

Externals Used:
        NmsDbOwnAddTbl

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsDbInit()

Side Effects:

Comments:
        No need to start a transaction in this since it is called only
        by NmsDbInit (at initialization time)
--*/
{


        PNMSDB_ADD_STATE_T        pOwnAddTbl = NULL;
        DWORD                     i, n;
        LONG                      ActFldLen;
        DWORD                     cOwners    = 0;
        JET_ERR                   JetRetStat;
#if NEW_OWID
        DWORD                      OwnerId;
#else
        DWORD                      OwnerId = 0;
#endif

        DWORD                      LastOwnerId = 0;
        BOOL                      fLogged = FALSE;
        STATUS                    RetStat = WINS_SUCCESS;

        DBGENTER("ReadOwnAddTbl\n");


        pOwnAddTbl = pNmsDbOwnAddTbl;

        /*
        * Setting the index will move the database cursor to the first record
        *in the table.
        */
        CALL_M(
                JetSetCurrentIndex(
                        SesId,
                        TblId,
                        NMSDB_OWN_ADD_CLUST_INDEX_NAME
                                  )
              );

        /*
        * Loop until the end of the table is reached. We are retrieving
        * records in the order of increasing owner ids.
        */
        do
        {

             //
             // retrieve the OwnerId column
             //
             JetRetStat =
                   JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].Fid,
                        &OwnerId,
                        OWN_ADD_OWNERID_SIZE,
                        &ActFldLen,
                        0,
                        NULL
                                 );


              if (JetRetStat == JET_errNoCurrentRecord)
              {
                  //
                  // If this is not the first iteration of the loop, then
                  // there is something seriously wrong.  Log an error and
                  // raise exception
                  //
                  if (NmsDbNoOfOwners != 0)
                  {
                        DBGPRINT0(EXC,
                          "There is no current record to retrieve from\n");
                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                  }
                  else
                  {
                        DBGPRINT0(ERR,
                           "ReadOwnAddTbl: There are no records in this table.");
                        WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_NO_RECS_IN_OWN_ADD_TBL);
                  }

                  break;   //break out of the loop
              }
              else
              {
                CALL_M(JetRetStat);
              }

              // the (OwnerId<->Addr) table is not large enough to contain a slot at index OwnerId.
              // the table has to be enlarged in order to cover this index.
              if (NmsDbTotNoOfSlots <= OwnerId)
              {
                  DWORD newNoOfSlots = max(NmsDbTotNoOfSlots*2, OwnerId+1);

                  WINSMSC_REALLOC_M(
                      sizeof(NMSDB_ADD_STATE_T) * newNoOfSlots,
                      &pOwnAddTbl);

                  pNmsDbOwnAddTbl = pOwnAddTbl;
                  NmsDbTotNoOfSlots = newNoOfSlots;

                  // Enlarge the (OwnerId<->VersNo) table if it is not at least as large as (OwnerId<->Addr) table.
                  if (RplPullMaxNoOfWins < NmsDbTotNoOfSlots)
                  {
                      RplPullAllocVersNoArray(&pRplPullOwnerVersNo, NmsDbTotNoOfSlots);
                      RplPullMaxNoOfWins = NmsDbTotNoOfSlots;
                  }

                  DBGPRINT2(
                      DET,
                      "ReadOwnAddTbl: Table sizes updated: (OwnerId<->Addr)[%d]; (OwnerId<->VersNo)[%d]\n",
                      NmsDbTotNoOfSlots,
                      RplPullMaxNoOfWins);
              }

              //
              // If this is the first wins server's owner id then this has
              // to be zero.
              //
              if (cOwners == 0)
              {
                  ASSERT(OwnerId == 0);
                  if (OwnerId > 0)
                  {
                       DBGPRINT1(ERR, "Database error.  The first owner in the owner-add table has owner id of  (%d)\n",  OwnerId);

                        WINSEVT_LOG_M(
                              WINS_FAILURE,
                              WINS_EVT_DB_INCONSISTENT
                             );

                       WINS_RAISE_EXC_M(WINS_EXC_DB_INCONSISTENT);

                  }
              }
              else
              {
                  //
                  // Mark all entries in NmsDbOwnerAddTbl for which we did
                  // not find an owner id as deleted.
                  //
                  for (i = LastOwnerId + 1; i < OwnerId; i++)
                  {
                       (pNmsDbOwnAddTbl + i)->WinsState_e = NMSDB_E_WINS_DELETED;
                  }
              }

              // retrieve the address column
             JetRetStat =
                   JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_ADDRESS_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->WinsAdd),
                        sizeof(COMM_ADD_T),
                        &ActFldLen,
                        0,
                        NULL
                                 );

              DBGPRINT2(INIT, "ReadOwnAddTable: Owner Id (%d) - Address (%x)\n",
                        OwnerId, (pNmsDbOwnAddTbl + OwnerId)->WinsAdd.Add.IPAdd);

              // retrieve the state column
              CALL_M(
                JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_STATE_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->WinsState_e),
                        sizeof(BYTE),
                        &ActFldLen,
                        0,
                        NULL
                                 )
                    );

              // retrieve the version number column
              CALL_M(
                JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_VERSIONNO_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->StartVersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                 )
                    );

              // retrieve the Uid  column
              CALL_M(
                JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_UID_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->Uid),
                        sizeof(WINS_UID_T),
                        &ActFldLen,
                        0,
                        NULL
                                 )
                    );

//                pOwnAddTbl++; //increment ptr to point to next array element
                LastOwnerId = OwnerId;
                cOwners++;

        }  while(
                JetMove(
                        SesId,
                        TblId,
                        JET_MoveNext,
                        0 //grbit - use default (i.e. we want next record
                       ) >= 0
             );

        //
        // Compare the count of owners found in the Owner-Address mapping
        // table with the count we determined from the Name-Address mapping
        // table (see GetMaxVersNos()).  If the count is less
        // the database is in an inconsistent state.  This can
        // mean any of the following:
        //
        //  1) WINS crashed in the middle of replication and recovery was not
        //     done properly prior to this invocation
        //
        //  2) The database got trashed due to some other external factors.
        //
        // This error condition is serious enough to warrant an exception.
        // This should terminate WINS.
        //
        // The  count can be more but not less.  This is because when a
        // WINS comes up, it registers itself in the Owner-Address mapping
        // table.  So it is possible that it might have gone down before
        // registering anything.  Also, it is possible for all records owned
        // by a WINS server to be deleted.
        //
        if (cOwners < NmsDbNoOfOwners)
        {
                DBGPRINT2(ERR, "Database is inconsistent.  The number of owners in the nam-add table (%d) is >  in the own-add table (%d)\n",
                        NmsDbNoOfOwners,
                        cOwners);

                WINSEVT_LOG_M(
                              WINS_FAILURE,
                              WINS_EVT_DB_INCONSISTENT
                             );

                WINS_RAISE_EXC_M(WINS_EXC_DB_INCONSISTENT);
        }

        //
        // Set the global equal to the number of owner records found in
        // the owner-address table. If the global is < Cowners it means that
        // the records owned by one or more WINS servers whose addresses were
        // found in the owner - address mapping table have expired  in our
        // name - address mapping table.
        //
#if 0
FUTURES("Do not include the WINS server that have a non-active state in the")
FUTURES("cOwners count")
        NmsDbNoOfOwners = cOwners;
#endif
        //
        // Set the global to 1 more than the highest owner id found. This
        // is done because we use this global to go over all entries in
        // the NmsDbOwnAddTbl table (at several places - for example,
        // RplFindOwnerId)
        //
        NmsDbNoOfOwners = OwnerId + 1;

        //
        // Do a sanity check.  Make sure that there is no owner id with address
        // same as ours.  If there is such an owner id, mark the state as
        // deleted.
        //
        // If the db at WINS A is used at WINS B and WINS A was and is a
        // a partner of WINS B, we will have this situation.  WINS B will
        // see its records that got replicated to WINS A in the table at
        // a non-zero (i.e. non-local partner) index.  The 0th index is
        // always claimed by the local WINS (WINS B in this example), so
        // we can not have another index with the same address.  Having it
        // will cause clutter and also some unnecessary overhead at replication
        // where a partner that gets the mappings can ask for version numbers
        // that don't exist (if highest version number of records at the
        // non-zero index is > that at 0 index). Admitted that eventually,
        // the prior stated situation will no longer exist since the max.
        // version number at index 0 will become > that at the non-zero index.
        //
        DBGPRINT0(DET, "ReadOwnAddTbl: Do a sanity check on the list of owners\n");
        for (i = 1; i < NmsDbNoOfOwners; i++)
        {
                //
                // If address is same as ours and state is ACTIVE, mark it
                // deleted and get rid of all the database records.
                //
                if (
                        (WINSMSC_COMPARE_MEMORY_M(&(pNmsDbOwnAddTbl+i)->WinsAdd,
                            &NmsLocalAdd, sizeof(COMM_ADD_T))
                                   == sizeof(COMM_ADD_T))
                                        &&
                        ((pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_ACTIVE)
                   )

                {

                      //
                      // Tell the sc. to wait since ObliterateWins can take
                      // a long time.
                      //
                      ENmsWinsUpdateStatus(MSECS_WAIT_WHEN_DEL_WINS);
                      RetStat = ObliterateWins(i, &(pNmsDbOwnAddTbl+i)->WinsAdd);

                }
        }

        //
        // Check for other duplicates
        //
        for (i = 1; i < NmsDbNoOfOwners; i++)
        {
           DWORD OwnerIdToDel;
           for (n = i + 1; n < NmsDbNoOfOwners; n++)
           {
                if ((WINSMSC_COMPARE_MEMORY_M(&(pNmsDbOwnAddTbl+i)->WinsAdd,
                            &(pNmsDbOwnAddTbl+n)->WinsAdd, sizeof(COMM_ADD_T))
                                   == sizeof(COMM_ADD_T))
                                        &&
                        ((pNmsDbOwnAddTbl+i)->WinsState_e ==
                              (pNmsDbOwnAddTbl+n)->WinsState_e)
                    )
                {
                    if ( (pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_ACTIVE)
                    {
                          if (!fLogged)
                          {
                                WINSEVT_LOG_M(WINS_FAILURE,
                                       WINS_EVT_DUP_ENTRY_IN_DB);
                                fLogged = TRUE;

                          }
                          OwnerIdToDel =
                            LiLeq((pRplPullOwnerVersNo+i)->VersNo,
                                    (pRplPullOwnerVersNo+n)->VersNo)  ? i : n;

                          ENmsWinsUpdateStatus(MSECS_WAIT_WHEN_DEL_WINS);
                          RetStat = ObliterateWins(OwnerIdToDel,
                                        &(pNmsDbOwnAddTbl+OwnerIdToDel)->WinsAdd);
                    }
                }
           }
        }
        DBGPRINT1(DET, "ReadOwnAddTbl. No of owners found = (%d)\n", NmsDbNoOfOwners);
        return(RetStat);
}

STATUS
ObliterateWins(
       DWORD        OwnerToDel,
       PCOMM_ADD_T  pWinsAdd
      )

/*++

Routine Description:
     This function gets rid of all information pertaining to a WINS.

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	This function assumes that it is being called at init time. So, when
    calling NmsDbDelDataRecs, it does not request the same to enter a
    critical section
--*/

{
          VERS_NO_T        MinVersNo;
          VERS_NO_T        MaxVersNo;
          WINS_ASSIGN_INT_TO_LI_M(MinVersNo, 0);

          DBGENTER("ObliterateWins\n");
          //
          // Set MaxVersNo to 0 also so that all records get
          // deleted
          //
          MaxVersNo = MinVersNo;

          WinsEvtLogDetEvt(TRUE, WINS_EVT_DUP_ENTRY_DEL, NULL, __LINE__, "ds", OwnerToDel, pWinsAdd->Add.IPAdd);

          (pNmsDbOwnAddTbl+OwnerToDel)->WinsState_e = NMSDB_E_WINS_DELETED;
          NmsDbWriteOwnAddTbl(
                             NMSDB_E_DELETE_REC,
                             OwnerToDel,
                             NULL,
                             NMSDB_E_WINS_DELETED,
                             NULL, NULL
                             );
          //
          // delete all the records in the database.
          //
          if (NmsDbDelDataRecs( OwnerToDel, MinVersNo, MaxVersNo, FALSE, FALSE) != WINS_SUCCESS)          {
               return(WINS_FAILURE);
          }


          WINS_ASSIGN_INT_TO_VERS_NO_M((pRplPullOwnerVersNo+OwnerToDel)->VersNo, 0);
          WINS_ASSIGN_INT_TO_VERS_NO_M((pRplPullOwnerVersNo+OwnerToDel)->StartVersNo, 0);
          //(pRplPullOwnerVersNo+OwnerToDel)->OldUid = 0;

          WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_WINS_ENTRY_DELETED);

          DBGLEAVE("ObliterateWins\n");
          return(WINS_SUCCESS);
}

STATUS
NmsDbWriteOwnAddTbl (
        IN NMSDB_TBL_ACTION_E         TblAct_e,
        IN DWORD                          OwnerId,
        IN PCOMM_ADD_T                  pWinsAdd,
        IN NMSDB_WINS_STATE_E        WinsState_e,
        IN PVERS_NO_T           pStartVersNo,
        IN PWINS_UID_T          pUid
        )

/*++

Routine Description:

        This function is called to insert or modify a record in the
        owner id to address mapping table

Arguments:
        TblAct_e - the action to perform (Insert, delete, modify)
        OwnerId  - id of owner
        pWinsAdd - Address of owner (can be NULL when action is to delete)
        WinsState_e - State of record in the table
        pStartVersNo - version number this WINS started from

Externals Used:
        NmsDbNoOfOwners

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        InitOwnAddTbl() in commapi.c, RplFindOwnerId

Side Effects:

Comments:
        None
--*/
{

        JET_ERR         JetRetStat;
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        STATUS          RetStat = WINS_SUCCESS;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        DBGPRINT2(FLOW, "ENTER: WriteOwnAddTbl. Action = (%d) for Owner id = (%d)\n", TblAct_e, OwnerId);

        TblId  = pTls->OwnAddTblId;
        SesId  = pTls->SesId;

        switch(TblAct_e)
        {
                case(NMSDB_E_INSERT_REC):

                        CALL_M(JetBeginTransaction(SesId));
                try {
                          CALL_M(JetPrepareUpdate(
                                                 SesId,
                                                 TblId,
                                                 JET_prepInsert
                                                 )
                              );


                        // add first column (ownerid field)
                        CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].Fid,
                                      &OwnerId,
                                      OWN_ADD_OWNERID_SIZE,
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            // add 2nd column (this is the address field)
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_ADDRESS_INDEX].Fid,
                                      pWinsAdd,
                                      sizeof(COMM_ADD_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );


                            // add the 3rd column (this is the state byte
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_STATE_INDEX].Fid,
                                      &WinsState_e,
                                      sizeof(BYTE),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            // add the 4th column (this is the Vers. No
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_VERSIONNO_INDEX].Fid,
                                      pStartVersNo,
                                      sizeof(VERS_NO_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            // add the 5th column (this is the Uid)
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_UID_INDEX].Fid,
                                      pUid,
                                      sizeof(WINS_UID_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                        CALL_M( JetUpdate (
                                                SesId,
                                                TblId,
                                                NULL,
                                                0,
                                                NULL
                                              ));
                }
                finally        {
                        if (AbnormalTermination())
                        {
                                DBGPRINT0(ERR,
                                        "NmsDbWriteOwnAddTbl: Could not insert record in  Owner to Address Mapping Tbl\n");
                                WINSEVT_LOG_M(
                                                WINS_FAILURE,
                                                WINS_EVT_CONFLICT_OWN_ADD_TBL
                                             );
                                // if there is an abnormal termination, we already have an error
                                // code here. We shouldn't override it with any other error code.
                                JetRollback(SesId, JET_bitRollbackAll);
                                RetStat = WINS_FAILURE;
                        }
                        else
                        {
                                NmsDbNoOfOwners++;
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                                CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                        }
                  }
                        break;


                //
                // This case will be executed as a result of
                // administrative actions or when the database (owner-address
                // mapping table) shows that it was used earlier by a WINS
                // at a different address (see ReadOwnAddTbl())
                //
                case(NMSDB_E_MODIFY_REC):
                        CALL_M( JetMakeKey(
                                        SesId,
                                        TblId,
                                        &OwnerId,
                                        OWN_ADD_OWNERID_SIZE,
                                        JET_bitNewKey
                                          )
                                      );

                         if ( JetSeek(
                                        SesId,
                                        TblId,
                                        JET_bitSeekEQ
                                         ) ==  JET_errSuccess
                                )
                        {

                           CALL_M(JetBeginTransaction(SesId));

                         try {
                             JetRetStat = JetPrepareUpdate(
                                                 SesId,
                                                 TblId,
                                                 JET_prepReplace
                                                 );
                           if (
                                  (JetRetStat != JET_errSuccess)
                                                &&
                                  (JetRetStat != JET_wrnNoWriteLock)
                              )
                           {
                                RET_M(JetRetStat);
                           }

                                // add 2nd column (this is the address field)
                                CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_ADDRESS_INDEX].Fid,
                                      pWinsAdd,
                                      sizeof(COMM_ADD_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );


                                // add the 3rd column (this is the state byte
                                CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_STATE_INDEX].Fid,
                                      &WinsState_e,
                                      sizeof(BYTE),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                               // add the 4th column (this is the Vers. No
                              CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_VERSIONNO_INDEX].Fid,
                                      pStartVersNo,
                                      sizeof(VERS_NO_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                              // add the 5th column (this is the Uid)
                              CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_UID_INDEX].Fid,
                                      pUid,
                                      sizeof(WINS_UID_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            CALL_M( JetUpdate (
                                                SesId,
                                                TblId,
                                                NULL,
                                                0,
                                                NULL
                                              ));

                            }
                         finally {
                                if (AbnormalTermination())
                                {
                                    DBGPRINT0(ERR,
                                        "NmsDbWriteOwnAddTbl: Could not modify record in  Owner to Address Mapping Tbl\n");
                                WINSEVT_LOG_M(
                                                WINS_FAILURE,
                                                WINS_EVT_CONFLICT_OWN_ADD_TBL
                                             );
                                    // if there is an abnormal termination, we already have an error
                                    // code here. We shouldn't override it with any other error code.
                                    JetRollback(SesId, JET_bitRollbackAll);
                                    RetStat = WINS_FAILURE;
                                }
                                else
                                {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                                        CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)

                                }
                              }
                        }
                        else  //did not find record
                        {
                                DBGPRINT0(EXC, "NmsDbOwnAddTbl: Weird: Could not seek to a record is to be modified\n");
                                WINSEVT_LOG_M(
                                      WINS_FAILURE,
                                      WINS_EVT_SFT_ERR
                                     );
                                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);

                        }
                        break;

                case(NMSDB_E_DELETE_REC):
                        CALL_M( JetMakeKey(
                                        SesId,
                                        TblId,
                                        &OwnerId,
                                        OWN_ADD_OWNERID_SIZE,
                                        JET_bitNewKey
                                          )
                                      );

                         if ( JetSeek(
                                        SesId,
                                        TblId,
                                        JET_bitSeekEQ
                                         ) ==  JET_errSuccess
                                )
                        {
                          try {
                           CALL_M(JetBeginTransaction(SesId));
                           CALL_M(JetDelete(SesId, TblId));
                           DBGPRINT1(SCV, "WriteOwnAddTbl: Deleted owner id = (%d) from table\n", OwnerId);
                             }
                        finally {
                                if (AbnormalTermination())
                                {
                                    DBGPRINT0(ERR,
                                        "NmsDbWriteOwnAddTbl: Could not delete record in  Owner to Address Mapping Tbl\n");
                                WINSEVT_LOG_M(
                                                WINS_FAILURE,
                                                WINS_EVT_CONFLICT_OWN_ADD_TBL
                                             );
                                    // if there is an abnormal termination, we already have an error
                                    // code here. We shouldn't override it with any other error code.
                                    JetRollback(SesId, JET_bitRollbackAll);
                                    RetStat = WINS_FAILURE;
                                }
                                else
                                {
                                        //
                                        // NOTE: Do not decrement
                                        // NmsDbNoOfOwners since that indicates
                                        // the number of WINS owners in the
                                        // in-memory table (in all states)
                                        //
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                                        CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)

                                }
                              } // end of finally
                        }
                        else  //did not find record
                        {
                                DBGPRINT0(EXC, "NmsDbOwnAddTbl: Weird: Could not seek to a record  to be deleted \n");
                                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        }

                        break;

                default:
                   DBGPRINT1(ERR, "Invalid Action Code - (%d)\n", TblAct_e);
                   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                   RetStat = WINS_FAILURE;
                   break;

        }

        DBGLEAVE("WriteOwnAddTbl\n");
        return(RetStat);
}

VOID
NmsDbThdInit(
        WINS_CLIENT_E        Client_e
            )

/*++

Routine Description:
        This function is called by each thread that wishes to init with
        the database.

Arguments:
        Client_e - indicates which thread it is

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        The init functions of the various threads

Side Effects:

Comments:
        This function is not to be called by the manin thread of the process
        That thread calls the NmsDbInit function.
--*/

{
        PWINSTHD_TLS_T        pTls        = NULL;
        DWORD                Error   = 0;
        BOOL                fRetVal = TRUE;

        WinsMscAlloc(sizeof(WINSTHD_TLS_T),  &pTls);
#ifdef WINSDBG
        pTls->Client_e = Client_e;
#endif

        //
        // Start a session.
        //
FUTURES("When security story regarding JET is complete, we might want to")
FUTURES("change the following. Until then, this should do")
        CALL_N_RAISE_EXC_IF_ERR_M( JetBeginSession(
                        sJetInstance,
                        &pTls->SesId,
                        NAMUSR,
                        PASSWD
                                )
              );

        //
        // Open the database
        //
        CALL_N_RAISE_EXC_IF_ERR_M( JetOpenDatabase(
                        pTls->SesId,
                        //NmsDbDatabaseFileName,
                        WinsCnf.pWinsDb,
                        NULL,                   /*the default engine*/
                        &pTls->DbId,
                        0   //shared access
                               )
               );

        /*
         * Let us set the TLS storage
         */
        fRetVal = TlsSetValue(WinsTlsIndex, pTls);

        if (!fRetVal)
        {
                Error   = GetLastError();
                WINSEVT_LOG_M(Error, WINS_EVT_CANT_INIT_W_DB);
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }
        else
        {
                //
                // RPC threads come and go.  Since the count NmsTotalTermThdCnt
                // represents the number of threads that need to be terminated
                // at process termination time we include only those threads
                // that we are guaranteed to have in the process (with active
                // db sessions).
                //
                // Also, the main thread is always accounted for in the
                // NmsTotalTrmThdCnt counter.
                //
                if ((Client_e != WINS_E_WINSRPC) && (Client_e != WINS_E_NMS))
                {
                   //
                   // Increment the count of threads that have initialized
                   // with the db engine.  This count will be used by the
                   // main thread to determine the number of threads that
                   // must wait for prior to terminating the process.
                   //
                   EnterCriticalSection(&NmsTermCrtSec);
                   NmsTotalTrmThdCnt++;
                   LeaveCriticalSection(&NmsTermCrtSec);
                }
        }
        return;
}


JET_ERR
UpdateDb (
   JET_SESID             SesId,
   JET_TABLEID             TblId,
   PNMSDB_ROW_INFO_T pRowInfo,
   ULONG             TypOfUpd
       )

/*++

Routine Description:
        This function is called to insert a record in the name - address
        mapping table of the database

Arguments:
        SesId    - Session Id
        TblId    - Table Id
        pRowInfo - Row to insert
        TypOfUp  - Type of Update (insertion or replacement)

Externals Used:
        None


Return Value:

   Success status codes -- JET_ErrSuccess
   Error status codes   -- Jet error status codes

Error Handling:

Called by:
        NmsDbInsertRowInd,
        NmsDbUpdateRow
Side Effects:

Comments:
        None
--*/

{

        DWORD                      EntryFlag = 0;
        JET_ERR                    JetRetStat;
        //JET_SETINFO                SetInfo;
#ifdef WINSDBG
        BOOL                      fUpd = FALSE;
#endif

        CALL_M(JetBeginTransaction(SesId));
try {
        JetRetStat =  JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 TypOfUpd
                                );

        //
        // Starting from rel118.0, JetPrepareUpdate can return
        // JET_wrnNoWriteLock when called to replace a record at
        // transaction level 0.  We should just ignore it
        //
        if  (JetRetStat != JET_errSuccess)
        {
                if (
                        !((JetRetStat == JET_wrnNoWriteLock)
                                &&
                        (TypOfUpd == JET_prepReplace))
                   )
                {
                     RET_M(JetRetStat);
                }
        }

        // add first column (clustered index)
        if (TypOfUpd != JET_prepReplace)
        {
             JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                pRowInfo->pName,
                                pRowInfo->NameLen,
                                0,
                                NULL /*optional info */
                                )
                    );
        }


PERF("Make check for unique record first. Also, remove the shifting")
PERF("NodeType field for spec. grp.  When we start doing this")
PERF("do not set NodeType to 0 in NmsNmhReplGrpMem in nmsnmh.c")
        if (
                NMSDB_ENTRY_SPEC_GRP_M(pRowInfo->EntTyp)
                                ||
                NMSDB_ENTRY_MULTIHOMED_M(pRowInfo->EntTyp)
           )
        {
                 EntryFlag  = pRowInfo->EntTyp
                                        |
                             (pRowInfo->NodeTyp << NMSDB_SHIFT_NODE_TYP)
                                        |
                              (pRowInfo->fStatic << NMSDB_SHIFT_STATIC)
                                        |
                              (pRowInfo->fLocal ? NMSDB_BIT_LOCAL : 0)
                                        |
                              (pRowInfo->EntryState_e << NMSDB_SHIFT_STATE);

                 JETRET_M( InsertGrpMemsInCol(
                                        SesId,
                                        TblId,
                                        pRowInfo,
                                        TypOfUpd
                                            )
                         );
        }
        else   // it is a unique entry or a normal group entry
        {
                 if (NMSDB_ENTRY_NORM_GRP_M(pRowInfo->EntTyp))
                 {
                         EntryFlag  = pRowInfo->EntTyp
                                        |
                                     (pRowInfo->fStatic << NMSDB_SHIFT_STATIC)
                                        |
                                 (pRowInfo->EntryState_e << NMSDB_SHIFT_STATE);
                 }
                 else  // it is a Unique entry
                 {
                    EntryFlag   =
                         pRowInfo->EntTyp
                                |
                         (pRowInfo->NodeTyp << NMSDB_SHIFT_NODE_TYP)
                                |
                         (pRowInfo->fLocal ? NMSDB_BIT_LOCAL : 0)
                                |
                         (pRowInfo->fStatic << NMSDB_SHIFT_STATIC)
                                |
                         (pRowInfo->EntryState_e << NMSDB_SHIFT_STATE);

                 }
FUTURES("If in the future, we support more than one address for a unique name")
FUTURES("we will check pRowInfo for the number of addresses (another field)")
FUTURES("and then specify the right size to JetSetColumn below")

                //
                // add second column (IP address)
                //
                // Note: Even though for Normal groups there is no need to
                // set the address, we do it anyway.  This is to save
                // an if test which wlll slow down the registrations (inside
                // a critical section) of unique entries (form the bulk
                // of registration traffic).
                //
FUTURES("Don't distinguish between unique and group entries. Store Time stamp")
FUTURES("and owner id along with address in case of unique entry.  This will")
FUTURES("help get rid of some code from this function")

//                JetRetStat =  JetSetColumn(
                   JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                pRowInfo->pNodeAdd,
                                sizeof(COMM_ADD_T),
                                //Grbit,
                                0,
                                //pSetInfo
                                NULL /*optional info */
                                )
                         );

        }

        // add third column (this is the flag byte        */
        JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &EntryFlag,
                                sizeof(EntryFlag),
                                0,
                                NULL /*optional info */
                                )
                              );


        //
        // If the version number is not to be incremented, there is no
        // need to increment the owner id.  It must remain the same.
        //
        if (pRowInfo->fUpdVersNo)
        {
             // add 4th column (this is the owner byte        */
             JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &pRowInfo->OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                0,
                                NULL /*optional info */
                                )
              );


                // add 5th column (this is the version number long(DWORD)
                JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &(pRowInfo->VersNo),
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );

#ifdef WINSDBG
                fUpd = TRUE;
#endif
        }

        //
        // When the conflict is between two internet group entries,
        // (replica -- Tombstone, database entry -- Active), we do
        // not update the timestamp (Check out -- ClashAtReplGrpMems
        // in nmsnmh.c to get a better insight into this).
        //
        if (pRowInfo->fUpdTimeStamp)
        {
                // add 6th column (this is the time stamp)        */
                JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &(pRowInfo->TimeStamp),
                                sizeof(DWORD),
                                0,
                                NULL /*optional info */
                                )
                              );
        }

        JetRetStat = JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                               );
 } // end of try block
 finally {
         if (AbnormalTermination() || JetRetStat != JET_errSuccess)
         {
                // if there is an abnormal termination, we already have an error
                // code here. We shouldn't override it with any other error code.
                JetRollback(SesId, JET_bitRollbackAll);
         }
         else
         {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                CALL_M(JetCommitTransaction(SesId, /*CommitGrBit |*/ JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
         }
    }

#ifdef WINSDBG
       if (JetRetStat == JET_errSuccess)
       {

                NMSNMH_UPD_UPD_CTRS_M(fUpd, TypOfUpd != JET_prepReplace ? FALSE : TRUE, pRowInfo);
       }
#endif

       return(JetRetStat);
}


STATUS
NmsDbUpdateVersNo (
        BOOL                        fAfterClash,
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
       )

/*++

Routine Description:
        This function is called to update a record in the name - address
        mapping table of the database.


Arguments:
        fAfterClash  - indicates whether the update is being done after
                       a conflict resolution.

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        NmsNmhReplRegInd,
Side Effects:

Comments:
        None
--*/

{
        JET_TABLEID     TblId;
        JET_SESID        SesId;
        PWINSTHD_TLS_T        pTls;
        STATUS                 RetStat = WINS_SUCCESS;
        JET_ERR                JetRetStat;
        DWORD                ActFldLen;

        DBGENTER("NmsDbUpdVersNo\n");
        pTls  = TlsGetValue(WinsTlsIndex);

        // No need to check whether pTls is NON-NULL.  It has to be

        TblId = pTls->NamAddTblId;
        SesId  = pTls->SesId;


        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M( JetMakeKey(
                SesId,
                TblId,
                pRowInfo->pName,
                pRowInfo->NameLen,
                JET_bitNewKey
                          )
              );

         if ( (JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                                  )
              ) ==  JET_errRecordNotFound
            )
         {
                if (fAfterClash)
                {
                   /*
                    There is some serious error.
                    This condition should never occur because this thread
                    got a conflict on a record earlier while inside the
                    NmsNmhNamRegCrtSec.  Since the thread never got out of the
                    critical section prior to calling this function, there is
                    no reason why we should now not be able to find the record
                  */
                  DBGPRINT1(ERR,
                        "NmsDbUpdateVersNo: Could not find record (%s) -- WEIRD\n", pRowInfo->pName);
                  WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                  ASSERTMSG(0, "SEEK ERROR");
                  return(WINS_FAILURE);
                }
                else
                {
                  DBGPRINT1(DET,
                        "NmsDbUpdateVersNo: Could not find record (%s). It might have been deleted\n", pRowInfo->pName);
                  WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_CANT_FIND_REC);
                  return(WINS_SUCCESS);
                }
         }
         else
         {
                if (JetRetStat != JET_errSuccess)
                {
                        DBGPRINT1(ERR,
                                "NmsDbRelRow: Seek returned Error (%d)\n",
                                                JetRetStat);

                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_DATABASE_ERR);
                        return(WINS_FAILURE);
                }
        }
        CALL_M(JetBeginTransaction(SesId));
try {
        JetRetStat = JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 JET_prepReplace
                                );
        if ((JetRetStat != JET_errSuccess) && (JetRetStat != JET_wrnNoWriteLock))
        {
                CALL_M(JetRetStat);
        }

FUTURES("Remove adding of name")
#if 0
        // add first column (clusterred index)
        CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                pRowInfo->pName,
                                pRowInfo->NameLen,
                                0,
                                NULL /*optional info */
                                )
                  );
#endif
        //
        // retrieve the owner id field for doing sanity check
        //
#if !NEW_OWID
pStatusInfo->OwnerId = 0;
#endif
               CALL_M(
                   JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &pStatusInfo->OwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                         )
                );

        //
        // If this WINS does not own the record, raise an exception
        //
        // This should never happen since we never left the critical
        // section after the clash.
        //
        if(pStatusInfo->OwnerId != NMSDB_LOCAL_OWNER_ID)
        {
                if (fAfterClash)
                {
                  pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                  WINSEVT_LOG_M(pStatusInfo->OwnerId, WINS_EVT_RECORD_NOT_OWNED);
                  DBGPRINT1(EXC,
        "NmsDbUpdVersNo: Record with name (%s) not owned by this WINS\n",
                        pRowInfo->pName);
                  WINS_RAISE_EXC_M(WINS_EXC_RECORD_NOT_OWNED);
                }
                else
                {
                  DBGPRINT1(DET,
                        "NmsDbUpdateVersNo: The record with name (%s) is no longer owned by this WINS", pRowInfo->pName);
                  WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_RECORD_NOT_OWNED);
                  return(WINS_SUCCESS);
                }
        }

        // add 5th column (this is the version number long(DWORD)        */
        CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &(pRowInfo->VersNo),
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
              );


        //
        // determine if the time stamp needs to be updated
        //
        if (pRowInfo->fUpdTimeStamp)
        {
                // add 6th column (this is the time stamp)        */
                CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &(pRowInfo->TimeStamp),
                                sizeof(DWORD),
                                0,
                                NULL /*optional info */
                                )
                              );
        }
        CALL_M( JetUpdate (
                        SesId,
                        TblId,
                        NULL,
                        0L,
                        NULL
                        )
              );
} // end of try ..
finally {
        if (AbnormalTermination())
        {
                // if there is an abnormal termination, we already have an error
                // code here. We shouldn't override it with any other error code.
                JetRollback(SesId, JET_bitRollbackAll);
        }
        else
        {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
        }
  }


       DBGLEAVE("NmsDbUpdVersNo\n");
       return(RetStat);
}

STATUS
NmsDbEndSession (
        VOID
        )

/*++

Routine Description:

        This function closes the table, the database and ends the session

Arguments:
        None

Externals Used:
        WinsTlsIndex

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --   WINS_FAILURE

Error Handling:
        Errors are logged

Called by:
        WaitUntilSignaled in nms.c (by an nbt thread when it is signaled by
        the main thread for termination purposes)
Side Effects:

Comments:
        None
--*/
{

        PWINSTHD_TLS_T        pTls;
        STATUS                RetStat = WINS_SUCCESS;

        pTls  = TlsGetValue(WinsTlsIndex);
        if (pTls == NULL)
        {
                RetStat = WINS_FAILURE;
        }
        else
        {

                if (pTls->fNamAddTblOpen)
                {
                    CALL_M(JetCloseTable(
                                pTls->SesId,
                                pTls->NamAddTblId
                                    )
                       );
                }

                if (pTls->fOwnAddTblOpen)
                {
                        CALL_M(JetCloseTable(
                                pTls->SesId,
                                pTls->OwnAddTblId
                                    )
                                      );

                }

                CALL_M(JetCloseDatabase(
                                pTls->SesId,
                                pTls->DbId,
                                0  //find out what grbit can be used for
                                    )
                       );


                CALL_M(JetEndSession(
                              pTls->SesId,
                              0   //find out what grbit can be used for
                             )
                      );

        }

        //
        // deallocate the TLS storage
        //
        WinsMscDealloc(pTls);

        return(RetStat);

}


STATUS
GetGrpMem (
        IN JET_SESID              SesId,
        IN JET_TABLEID            TblId,
        IN PNMSDB_ROW_INFO_T      pRowInfo,
        IN DWORD_PTR              CurrentTime,
//        IN OUT PNMSDB_NODE_ADDS_T pNodeAdds,
        IN OUT PNMSDB_STAT_INFO_T pStatInfo,
        IN BOOL                   fStatic,
        OUT LPBOOL                pfIsMem
        )

/*++

Routine Description:
        This function is called to get all the active members of a
        special group

Arguments:
        SesId    - Id of the session started with the db
        TblId    - Id of the name -address mapping table
        pRowInfo - Used to pass current time and address of the client
                   (when the client sends the release request)
        pNodeAdds - group memnbers that are still active
        fStatic   - indicates whether the record is STATIC or not.
        pfIsMem   - indicates whether the client is a member of the group


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
  NmsDbRelRow,  NmsDbInsertRowGrp

Side Effects:

Comments:
        None
--*/

{
        DWORD                      i;
        DWORD                      No = 0;        //needs to be inited here
        JET_RETINFO                RetInfo;
        DWORD                      ActFldLen = 0;
        DWORD                      TimeToExpire;
        NMSDB_GRP_MEM_ENTRY_T      GrpMem;
        JET_ERR                    JetRetStat;

        *pfIsMem = FALSE;        //Assume that the client is not a member
                                 //of the group

        /* retrieve the number of addresses info*/
        RetInfo.itagSequence = 1;
        RetInfo.cbStruct     = sizeof(JET_RETINFO);
        RetInfo.ibLongValue  = 0;

        JetRetStat = JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                        &pStatInfo->NodeAdds.NoOfMems,
                        sizeof(pStatInfo->NodeAdds.NoOfMems),
                        &ActFldLen,
                        0,
                        &RetInfo
                                );

        if (
                (JetRetStat != JET_errSuccess)
                        &&
                (JetRetStat != JET_wrnBufferTruncated)
           )
        {
                   CALL_M(JetRetStat);
        }

        ASSERT(pStatInfo->NodeAdds.NoOfMems <= NMSDB_MAX_MEMS_IN_GRP);

        DBGPRINT1(FLOW, "GetGrpMems: No Of members in group (expired and non-expired) are (%d)\n", pStatInfo->NodeAdds.NoOfMems);

NOTE("Remove this check once JET is error free")
        if (pStatInfo->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
            WINSEVT_STRS_T  EvtStrs;
            WCHAR String[NMSDB_MAX_NAM_LEN];
            EvtStrs.NoOfStrs = 1;
            (VOID)WinsMscConvertAsciiStringToUnicode(
                        pRowInfo->pName,
                        (LPBYTE)String,
                        NMSDB_MAX_NAM_LEN);
            EvtStrs.pStr[0] = String;
            pStatInfo->NodeAdds.NoOfMems = 0;
            WINSEVT_LOG_STR_M(WINS_EVT_DATABASE_CORRUPTION, &EvtStrs);

        }
        RetInfo.ibLongValue  = sizeof(pStatInfo->NodeAdds.NoOfMems);
        for (i=0; i < pStatInfo->NodeAdds.NoOfMems; i++)
        {
           JetRetStat = JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &GrpMem,
                                sizeof(GrpMem),
                                &ActFldLen,
                                0,
                                &RetInfo
                                     );
           if (
                (JetRetStat != JET_errSuccess)
                        &&
                (JetRetStat != JET_wrnBufferTruncated)
              )
           {
                   CALL_M(JetRetStat);
           }



           //
           // If the grp has expired, set TimeToExpire to 0
           //
           if (CurrentTime >= GrpMem.TimeStamp)
           {
                TimeToExpire = 0;
           }
           else
           {
                TimeToExpire = 1;
           }


           //
           // If this is a STATIC record but not a user defined spec. grp or
           // if the member was registered by another WINS or if
           // the member is still active, keep it (i.e. return it
           // in the NodeAdds array.)  We drop all non-owned members which
           // have expired.
           //
           // Note 1C groups are special even if user defines them in the
           // lmhosts file
           //
           if (
                (fStatic &&  (!(NMSDB_ENTRY_USER_SPEC_GRP_M(pRowInfo->pName, pStatInfo->EntTyp))))
                        ||
                  (GrpMem.OwnerId != NMSDB_LOCAL_OWNER_ID)
                        ||
                  TimeToExpire
               )
           {

                   pStatInfo->NodeAdds.Mem[No++] = GrpMem;
                   if (pRowInfo->NodeAdds.Mem[0].Add.Add.IPAdd
                                        == GrpMem.Add.Add.IPAdd)
                   {
                        *pfIsMem = TRUE;
                   }
           }

           if (No == NMSDB_MAX_MEMS_IN_GRP)
           {
               /*
                * Group limit reached
                */
               break;
           }
           RetInfo.ibLongValue  += sizeof(GrpMem);

        } //end of for

        pStatInfo->NodeAdds.NoOfMems = No;

        DBGPRINT1(FLOW, "GetGrpMems: No Of non-expired members in group are (%d)\n", pStatInfo->NodeAdds.NoOfMems);
#ifdef WINSDBG
        if (pStatInfo->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
        DBGPRINT4(SPEC, "GetGrpMems: No Of non-expired members in group %s are (%d). Vers. No to insert is (%d %d)\n", pRowInfo->pName, pStatInfo->NodeAdds.NoOfMems, pRowInfo->VersNo.HighPart, pRowInfo->VersNo.LowPart);
        }
#endif
        return(WINS_SUCCESS);
}
VOID
NmsDbRelRes(
        VOID
        )

/*++

Routine Description:

        This function releases all the resources held by the Database Engine
        (JET)

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsMain

Side Effects:

Comments:
        This function must be called by the thread that did the attach.
    So, it has to be the main thread.
--*/
{
//        PWINSTHD_TLS_T        pTls;
        JET_ERR  JetRetStat = JET_errSuccess;
 //       JET_SESID SesId;
//        BOOL      fOutOfReck;

        DBGENTER("NmsDbRelRes\n");

      //
      // Call JetTerm only if there is no abrupt termination.  Currently,
      // JetTerm will hang if it is called without all sessions being
      // terminated.  Terminating abruptly without calling JetTerm
      // is sort of equivalent to power failure kind of situation.
      // Recovery will happen under the covers the next time WINS server
      // is invoked -- Ian Jose 10/18/93.
      //
      if (!fNmsAbruptTerm /*&& !fOutOfReck*/)
      {
            DBGPRINT0(DET, "NmsDbRelRes: JetTerm being called\n");

#if DYNLOADJET
            if (DynLoadJetVersion >= DYN_LOAD_JET_500)
            {
              (VOID)JetTerm2(sJetInstance, JET_bitTermComplete);//no need to check to the return value
            }
            else
#endif
            {
              (VOID)JetTerm(sJetInstance);//no need to check to the return value
            }
      }
      DBGLEAVE("NmsDbRelRes\n");
      return;
}





STATUS
GetMaxVersNos(
        JET_SESID         SesId,
        JET_TABLEID        TblId
        )

/*++

Routine Description:
        This function is called at initialization time to get the
        max version number for records owned by different WINS servers
        in the database.

Arguments:
        SesId - Jet Session id
        TblId - Table Id of the Name-Address Mapping table

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        NmsDbInit

Side Effects:

Comments:
        This function is called at initialization time.  If in the future,
        it gets called during stable state, we need to have a critical section
        around the update of NmsDbNoOfOwners var.
--*/

{
#if NEW_OWID
        DWORD  OwnerId;
#else
        DWORD   OwnerId = 0;
#endif
        DWORD   ActFldLen;
        JET_ERR        JetRetStat;
        BOOL    fOnlyReplicas = FALSE;
        BOOL        fFirstIter = TRUE;

        WINS_ASSIGN_INT_TO_VERS_NO_M(sHighestVersNoSaved, 0);

        /*
         * Set the primary index as the current index
        */
        CALL_M( JetSetCurrentIndex(
                        SesId,
                        TblId,
                        NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
                      );

PERF("Remove this Move since when we set the index, we are automatically")
PERF("positioned on the first row")
        //
        // Move to the first record in the name - address mapping table
        //
        JetRetStat = JetMove(
                        SesId,
                        TblId,
                        JET_MoveFirst,
                        0                //no grbit
                        );
        //
        // The following error indicates that either our database
        // is empty or has garbage.  I will assume for now that it
        // is empty.  If it contains garbage, we will know soon enough
        //
        if (JetRetStat == JET_errNoCurrentRecord)
        {
FUTURES("Be more robust. Check if db contains garbage")
                DBGPRINT0(ERR,
                        "GetMaxVersNos: There are no records in the db\n");
                WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_NO_RECS_IN_NAM_ADD_TBL);
                NmsDbNoOfOwners = 0;
                return(WINS_SUCCESS);
        }

        CALL_M(JetRetStat);

        //
        // The fact that we are here means that there is atleast one record
        // in our db
        //

        //
        // Get the owner id and max version numbers of all owners in the
        // table
        //
        do
        {

                //
                // Retrieve the owner Id column.
                //
                CALL_M(
                        JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &OwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     0,
                                     NULL
                                       )
                        );

                if (fFirstIter)
                {
                        if (OwnerId != 0)
                        {
                           // The last owner id to be retrieved is not 0 means
                           // that there is no record owned by us
                           //
                           fOnlyReplicas = TRUE;
                        }
                        fFirstIter = FALSE;
                }


                 //
                 // Specify an owner id that is 1 more than what we retrieved
                 //
                 OwnerId += 1;

                 // in case this is not the special record...
                 if ((OwnerId - 1) != OWNER_ID_OF_SPEC_REC)
                 {
                     // ...expand the ownerid - versNo array to at least OwnerId slots
                     if (RplPullMaxNoOfWins < OwnerId)
                     {
                         DWORD newMaxNoOfWins = max(RplPullMaxNoOfWins * 2, OwnerId);

                         RplPullAllocVersNoArray(&pRplPullOwnerVersNo, newMaxNoOfWins);
                         RplPullMaxNoOfWins = newMaxNoOfWins;
                         DBGPRINT1(DET, "ReadOwnAddTbl: No of slots in RPL_OWNER_VERS_NO_ARRAY has been increased to %d\n", RplPullMaxNoOfWins);
                     }
                 }

                 //
                 // Construct a partial key made of owner id.
                 //
                 CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
                        );

                  //
                  // Seek to the record that has a key that is Less than or
                  // Equal to the OwnerId value.
                  //
                  // Since we have specified a partial key (saying in effect
                  // that the other component of the key is NULL), JetSeek
                  // must return wrnSeekNotEqual since it will never find
                  // a record with NULL for the second component of the index
                  // -- Ian 7/13/93
                  //
                  JetRetStat = JetSeek(
                                              SesId,
                                              TblId,
                                              JET_bitSeekLE
                                      );
                  ASSERT(JetRetStat == JET_wrnSeekNotEqual);
#ifdef WINSDBG
                  if (JetRetStat != JET_wrnSeekNotEqual)
                  {
                      DBGPRINT1(ERR, "GetMaxVersNos: JetSeek returned (%d)\n", JetRetStat);
                  }
#endif


                   //
                   // retrieve the version number of the record on which we
                   // are positioned.  This is the max vers. number pertaining
                   // to OwnerId. If the Owner Id is one more than the
                   // owner id. we have assigned to the special record,
                   // then store the version number retrieved into
                   // sHighestVersNoSaved
                   //
                   CALL_M(
                           JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                             ((OwnerId - 1 ) == OWNER_ID_OF_SPEC_REC) ?
                                &sHighestVersNoSaved :
                                &(pRplPullOwnerVersNo+OwnerId - 1)->VersNo,
                             sizeof(VERS_NO_T),
                             &ActFldLen,
                             0,
                             NULL
                                                 )
                          );

                   if ((OwnerId - 1) == OWNER_ID_OF_SPEC_REC )
                   {
                       ASSERT(!sfHighestVersNoRecExists);
                       if (sfHighestVersNoRecExists)
                       {
                          DBGPRINT0(ERR, "GetMaxVersNo: ERROR: SOFTWARE BUG - Found both the old and new spec. owner id records. They are MUTUALLY EXCLUSIVE\n");
                          WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                       }
                       StoreSpecVersNo();
                       DBGPRINT3(INIT, "GetMaxVersNo: Owner Id - (%d) : Vers No. (%d %d)\n", (OwnerId - 1),  sHighestVersNoSaved.HighPart, sHighestVersNoSaved.LowPart);
                       continue;
                   }
                   else
                   {
                      //
                      // If the owner id is == what used to be the owner id.
                      // of the special record, it means that we have a pre-SUR
                      // beta2 db.  We should delete this name to get rid of
                      // clutter.  We should mark the pRplPullOwnerVersNo slot
                      // empty since it was initialized above.
                      //
                      if ((OwnerId - 1) == OWNER_ID_OF_SPEC_REC_OLD )
                      {
                          LPBYTE Name[NMSDB_MAX_NAM_LEN];
                          DWORD  NameLen;

                          //
                          // If the name is == spHighestVersNoRecNameOld, delete
                          // this record.  This is the old special record
                          // we had. Save the vers. no. in a local
                          //
                          // NOTE: the length of the spec. rec. name is < 16
                          // bytes so it is not a valid netbios name
                          //
                          CALL_M( JetRetrieveColumn(
                                        SesId,
                                        TblId,
                                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                        Name,
                                        NMSDB_MAX_NAM_LEN,
                                        &NameLen,
                                        0,
                                        NULL));

                         if ((NameLen == sizeof(spHighestVersNoRecNameOld)) && RtlEqualMemory((PVOID)Name, spHighestVersNoRecNameOld, NameLen))
                         {
                              sHighestVersNoSaved =
                                (pRplPullOwnerVersNo+OwnerId - 1)->VersNo;
                              (pRplPullOwnerVersNo+OwnerId - 1)->VersNo.QuadPart = 0;
                              CALL_M(JetDelete(SesId, TblId));
                              StoreSpecVersNo();
                              DBGPRINT3(INIT, "GetMaxVersNo: Owner Id - (%d) : Vers No. (%d %d)\n", (OwnerId - 1),  sHighestVersNoSaved.HighPart, sHighestVersNoSaved.LowPart);
                              continue;
                         }
                      }
                   }
                   DBGPRINT3(INIT, "GetMaxVersNo: Owner Id - (%d) : Vers No. (%d %d)\n", (OwnerId - 1),  (pRplPullOwnerVersNo+OwnerId - 1)->VersNo.HighPart,
(pRplPullOwnerVersNo+OwnerId - 1)->VersNo.LowPart);


                   NmsDbNoOfOwners++;        //count of owners found in the db

        }  while(
                JetMove(SesId, TblId, JET_MoveNext, 0) == JET_errSuccess
               );



        //
        // Check if the version counter's value is < that of the highest
        // version found for owned records
        // (found when we did the search  in the while loop above. Use
        // whichever is higher as the  version counter)
        //
        if (!fOnlyReplicas)
        {
           //
           // We need to increment the Vers. No. Counter to point to the
           // number to be given to the next record
           //
           if (LiGeq(
                        pRplPullOwnerVersNo->VersNo,
                        NmsNmhMyMaxVersNo
                     )
              )
           {
                //
                // Initialize NmsNmhMyMaxVersNo.  Remember this counter
                // always contains the next version number to be given
                // to a record. So, we must increment the count contained
                // in RplPullOwnerVersNo[0] by 1
                //
                NMSNMH_INC_VERS_NO_M(
                                pRplPullOwnerVersNo->VersNo,
                                NmsNmhMyMaxVersNo
                                  );

               //
               // Since we found records in the db, we take the conservative
               // approach here, and set the Min Scv Vers. no to 1.  If
               // the first record has a very high version no. the scavenger
               // thread will update the NmsScvMinVersNo to that value.
               //
               // We need to scavenge from this version onwards.
               //
               NmsScvMinScvVersNo.QuadPart  = 1;

               return(WINS_SUCCESS);
           }

        }

        //
        // Since we are here it means that when we searched for records
        // belonging to the local WINS, we did not find any record
        // We may or may not have found the special record.  If we did find it
        // it means that all the local records of the WINS were either
        // deleted or replaced by replicas in its previous incarnation.
        //

        //
        // If we found the special record, let us initialize RplPullOwnerVersNo
        // entry for the local WINS
        //
        if (sfHighestVersNoRecExists)
        {
                pRplPullOwnerVersNo->VersNo =  NmsNmhMyMaxVersNo;

                //
                // Increment the counter since it must always have a
                // value to be given to the next local record we insert or
                // update.
                //
CHECK("May not be necessary")
                NMSNMH_INC_VERS_NO_M(
                                NmsNmhMyMaxVersNo,
                                NmsNmhMyMaxVersNo
                                  );

               if (fOnlyReplicas)
               {
                 //
                 // We need to scavenge from this version onwards.
                 //
                 NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;
               }
               else
               {
                 NmsScvMinScvVersNo.QuadPart  = 1;
               }
         }

         return(WINS_SUCCESS);
}

__inline
VOID
StoreSpecVersNo(
   VOID
)

/*++

Routine Description:

 This function conditionally updates NmsNmhMyMaxVersNo to a number that is 1
 more than the version. no. found in the special owner id. record.

Arguments:

      None

Externals Used:

   NmsNmhMyMaxVersNo,
   sfHighestVersNoExists
	
Return Value:

  None

Error Handling:

Called by:
        GetMaxVersNos()

Side Effects:

Comments:
	None
--*/

{
        sfHighestVersNoRecExists = TRUE;

        //
        // If the version counter's value is < that of
        // the special record, update it.
        //
        //
        // NOTE: If the registry specified a number for the
        // version counter, then NmsNmhMyMaxVersNo would be
        // having that value, else it would be 1
        //
        if (LiLtr(NmsNmhMyMaxVersNo, sHighestVersNoSaved))
        {
                NMSNMH_INC_VERS_NO_M( sHighestVersNoSaved, NmsNmhMyMaxVersNo);

        }

       return;
}

JET_ERR
InsertGrpMemsInCol(
        JET_SESID                SesId,
        JET_TABLEID                TblId,
        PNMSDB_ROW_INFO_T        pRowInfo,
        ULONG                    TypOfUpd
         )

/*++

Routine Description:
        This function is called to insert members of a special group
        in the address column field of the name - address mapping table

Arguments:
        SesId            - Session Id.
        TblId       - Table Id.
        pRowInfo    - Contains the member info
        fOverwrite  - Whether members in the list above would overwrite the
                      ones already there


Externals Used:
        sNamAddTblRow


Return Value:

   Success status codes --  JET_errSuccess
   Error status codes   --  Jet error codes

Error Handling:

Called by:
        NmsDbRelRow, UpdateDb

Side Effects:

Comments:
        None
--*/
{

        JET_SETINFO    SetInfo;
        DWORD          i;
        JET_ERR        JetRetStat = JET_errSuccess; //needs to be inited here

        DBGENTER("InsertGrpMemsInCol\n");
        SetInfo.itagSequence = 1;  //has to be 1 always
        SetInfo.ibLongValue  = 0;
        SetInfo.cbStruct     = sizeof(JET_SETINFO);

        ASSERT(pRowInfo->NodeAdds.NoOfMems <= NMSDB_MAX_MEMS_IN_GRP);

#ifdef WINSDBG
        if (NMSDB_ENTRY_MULTIHOMED_M(pRowInfo->EntTyp) && pRowInfo->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
           DBGPRINT4(SPEC, "InsertGrpMemsInCol: Name is (%s); No Of Mems are (%d); Version number is (%d %d)\n", pRowInfo->pName, pRowInfo->NodeAdds.NoOfMems, pRowInfo->VersNo.HighPart, pRowInfo->VersNo.LowPart);
        }
#endif
        //
        // Set the # of Members field.  This is always the first
        // field
        //
        if (TypOfUpd == JET_prepReplace)
        {

//          SetInfo.ibLongValue  = sizeof(pRowInfo->NodeAdds.NoOfMems);
          JETRET_M(JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                NULL,
                                0,
                                JET_bitSetSizeLV,
                                &SetInfo /*optional info */
                                )
                            );
 //         SetInfo.ibLongValue  = 0;
        }
        JETRET_M(JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRowInfo->NodeAdds.NoOfMems,
                                sizeof(pRowInfo->NodeAdds.NoOfMems),
                                JET_bitSetAppendLV,
                                &SetInfo /*optional info */
                                )
                            );
        for (
             i=0;
             i < pRowInfo->NodeAdds.NoOfMems && JetRetStat == JET_errSuccess;
             i++
            )
        {

                DBGPRINT3(DET, "InsertGrpMemsInCol: Inserted member (%d) with address (%X) and owner id (%d)\n", i, pRowInfo->NodeAdds.Mem[i].Add.Add.IPAdd,
                        pRowInfo->NodeAdds.Mem[i].OwnerId
                         );

CHECK("Check this on a MIPS machine")
                //
                // Set the GrpMem
                //
                JetRetStat =  JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRowInfo->NodeAdds.Mem[i],
                                sizeof(NMSDB_GRP_MEM_ENTRY_T),
                                JET_bitSetAppendLV,
//                                TypOfUpd == JET_prepReplace ? JET_bitSetOverwriteLV : JET_bitSetAppendLV,
                                &SetInfo /*optional info */
                                    );

        } // end of for
        DBGLEAVE("InsertGrpMemsInCol\n");
        return(JetRetStat);
}


STATUS
NmsDbSetCurrentIndex(
        IN NMSDB_TBL_NAM_E        TblNm_e,
        IN LPBYTE                pIndexNam
        )
/*++

Routine Description:
        This function is called to set the index on a table

Arguments:
        TblNm_e - Identifies the table whose index needs to be set
        pIndexNm - Name of index to be set

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PWINSTHD_TLS_T        pTls;
        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        /*
         * Use primary index now
        */
               CALL_M( JetSetCurrentIndex(
                                pTls->SesId,
                                TblNm_e == NMSDB_E_NAM_ADD_TBL_NM ?
                                        pTls->NamAddTblId :
                                        pTls->OwnAddTblId,
                                pIndexNam
                                   )
              );

        return(WINS_SUCCESS);
}



STATUS
NmsDbQueryNUpdIfMatch(
        LPVOID                pRecord,
        int                ThdPrLvl,
        BOOL                fChgPrLvl,
        WINS_CLIENT_E        Client_e
                )

/*++

Routine Description:
        This function is called to query a record and then update it only
        if it matches the timestamp of the record supplied

Arguments:
        pRecord      - Record supplied
        ThdPrLvl     - Priority level of the thread
        fChgPrLvl    - TRUE, if priority level of the thread needs to be changed

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        UpdDb in nmsscv.c, WinsRecordAction in winsintf.c

Side Effects:

Comments:
        This function must be called only when the index on the name
        address table has been set to the clustered index column.
--*/
{

        BYTE                     State;
        DWORD                    TimeStamp = 0;
        DWORD                    ActFldLen;
        JET_TABLEID              TblId;
        JET_SESID                SesId;
        PWINSTHD_TLS_T           pTls;
        PRPL_REC_ENTRY_T         pRec = pRecord;
        JET_ERR                  JetRetStat;
        BOOL                     fIncVersNo = FALSE;
#if NEW_OWID
        DWORD                     OwnerId;
#else
        DWORD                    OwnerId = 0;
#endif
        BOOL                     fAbort = FALSE;


        DBGENTER("NmsDbQueryNUpdIfMatch\n");

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        State = (BYTE)NMSDB_ENTRY_STATE_M(pRec->Flag);

#if 0
        NmsDbSetCurrentIndex(
                                NMSDB_E_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
#endif

        //
        // Make sure you enter the critical section
        // prior to deleting a record.  This is because
        // another thread may be seeking to it after
        // conflicting with it.  If we delete the
        // record without entering the critical
        // section, the thread may not
        // find the record.  This would cause it to
        // raise an exception.
        //
        if (fChgPrLvl)
        {
                //
                // Set the priority to NORMAL. We
                // don't want to delay normal
                // priority threads by getting
                // starved of cpu time inside
                // the critical section.
                //
                  WinsMscSetThreadPriority(
                        WinsThdPool.ScvThds[0].ThdHdl,
                        THREAD_PRIORITY_NORMAL
                                );
        }
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
try {

        //
        // Seek to the record
        //
        CALL_M( JetMakeKey(
                        SesId,
                        TblId,
//                        pRec->Name,
                        pRec->pName,
                        pRec->NameLen,
                        JET_bitNewKey
                          )
                        );

        if (JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekEQ
                    ) ==  JET_errSuccess
            )
        {
                BOOL                     fUpdSpecRec = FALSE;
                VERS_NO_T             RecVersNo;
                VERS_NO_T             MyMaxVersNo;

                //
                // If we are doing scavenging, we need to make sure that
                // while we were examining the records, the record that
                // we want to update now, did not get updated.  To check
                // that we retrieve the timestamp of the record
                //
                if (Client_e == WINS_E_NMSSCV)
                {
                    //
                    // retrieve the time stamp
                    //
                        CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &TimeStamp,
                                sizeof(TimeStamp),
                                &ActFldLen,
                                0,
                                NULL
                                     )
                        );
                }

                //
                // if timestamp is the same, we have our record.
                // we don't need to check any other field.  Exception: If we
                // are an RPC thread, whether or not we update the
                // record is independent of the timestamp that the
                // record may have now
                //
                if (
                        (pRec->TimeStamp == TimeStamp)
                                ||
                        (Client_e == WINS_E_WINSRPC)
                       )
                {
                        //
                        // if state of the record is deleted, we need to
                        // delete it from the database.
                        //
                        if (State == NMSDB_E_DELETED)
                        {

                                //
                                // If Client is an RPC thread, first retrieve
                                // the owner id and version number of the
                                // record to delete
                                //

                                if (Client_e == WINS_E_WINSRPC)
                                {

                                         CALL_M( JetRetrieveColumn(
                                        SesId,
                                        TblId,
                                        sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                        &OwnerId,
                                        NAM_ADD_OWNERID_SIZE,
                                        &ActFldLen,
                                        0,
                                        NULL
                                                     )
                                          );

                                   if (OwnerId == NMSDB_LOCAL_OWNER_ID)
                                   {
                                            //
                                            // Retrieve the version number
                                            //
                                            CALL_M( JetRetrieveColumn(
                                                SesId,
                                                TblId,
                                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                                &RecVersNo,
                                                sizeof(VERS_NO_T),
                                                &ActFldLen,
                                                0,
                                                NULL
                                                     )
                                          );

                                      //
                                      // get the highest version number used
                                      // up until now.
                                      //
                                      NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo,
                                                        MyMaxVersNo);

                                      //
                                      // If the record to be deleted has
                                      // the this highest version number we
                                      // must update the special record
                                      //
                                      if(LiEql(RecVersNo, MyMaxVersNo))
                                      {
                                          fUpdSpecRec = TRUE;
                                      }
                                   }
                                }
                                CALL_M(JetDelete(
                                                SesId,
                                                TblId
                                                )
                                        );
#ifdef WINSDBG
                                NmsDbDelQueryNUpdRecs++;
#endif
                                DBGPRINT2(SCV, "NmsDbQueryNUpdIfMatch: Deleted the record with name = (%s);16th char (%X)\n", pRec->pName, *(pRec->pName + 15));

                                //
                                // This can be TRUE only in an RPC thread
                                //
                                if (fUpdSpecRec)
                                {
                                        NmsDbUpdHighestVersNoRec(
                                                        pTls,
                                                        MyMaxVersNo,
                                                        FALSE //don't enter Crt
                                                              //sec
                                                        );
                                }
                        }
                        else    // we need to set the Flag field and in the
                                      //case of a tombstone record update the version
                                      //stamp
                        {
                                CALL_M(JetBeginTransaction(SesId));
                            try {
                                JetRetStat = JetPrepareUpdate(
                                                SesId,
                                                TblId,
                                                JET_prepReplace
                                                           );
                                if (
                                        (JetRetStat != JET_errSuccess)
                                                &&
                                        (JetRetStat != JET_wrnNoWriteLock)
                                      )
                                {
FUTURES("When Jet becomes stable, replace RET_M with a raise_exception")
                                        //
                                        // this should result in the execution
                                        // of the finally clause
                                        //
                                        RET_M(JetRetStat);
                                }

                                if (Client_e == WINS_E_WINSRPC)
                                {

                                        DWORD FlagVal;
                                        BYTE EntryType;
                                        BYTE NewEntryType;

                                        //
                                        // Retrieve the flags byte
                                        //
                                         // retrieve the flags column
                                         CALL_M( JetRetrieveColumn(
                                                        SesId,
                                                        TblId,
                                                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                                        &FlagVal,
                                                        sizeof(FlagVal),
                                                        &ActFldLen,
                                                        0,
                                                        NULL
                                                          )
                                                      );
                                        EntryType = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
                                        NewEntryType = (BYTE)NMSDB_ENTRY_TYPE_M(pRec->Flag);

                                        //
                                        // A unique/normal group record
                                        // can not be changed to a multihomed/
                                        // special group record unless the
                                        // address column too is changed
                                        //
                                        if (
                                            (
                                             (
                                              EntryType == NMSDB_UNIQUE_ENTRY
                                                          ||
                                              EntryType ==
                                                        NMSDB_NORM_GRP_ENTRY
                                             )
                                                        &&
                                             (
                                                 NewEntryType ==
                                                        NMSDB_SPEC_GRP_ENTRY
                                                        ||
                                                 NewEntryType ==
                                                        NMSDB_MULTIHOMED_ENTRY
                                             )
                                           )
                                                        ||
                                           (
                                             (
                                                 EntryType ==
                                                        NMSDB_SPEC_GRP_ENTRY
                                                        ||
                                                 EntryType ==
                                                        NMSDB_MULTIHOMED_ENTRY
                                             )
                                                        &&
                                             (
                                              NewEntryType == NMSDB_UNIQUE_ENTRY
                                                          ||
                                              NewEntryType ==
                                                        NMSDB_NORM_GRP_ENTRY
                                             )
                                          )
                                         )
                                      {

                                          DBGPRINT0(ERR, "NmsDbQueryNUpdIfMatch: SORRY, Can not change to an incompatibe address format record. (Unique/Normal Group) to (Multihomed/Spec. Group) or vice-versa disallowed\n");

PERF("Do not return like this. finally block search is expensive")
                                          fAbort = TRUE;
                                          return(WINS_FAILURE);

                                      }

                                } // end of if (client is RPC)

                                //
                                // Update the flags field
                                //
                                CALL_M( JetSetColumn(
                                                    SesId,
                                                    TblId,
                                                    sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                                 &pRec->Flag,
                                                 sizeof(pRec->Flag),
                                                 0,
                                                 NULL /*optional info */
                                                       )
                                               );

                                  /* Update the timestamp column         */
                                  CALL_M( JetSetColumn(
                                                SesId,
                                                TblId,
                                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                                &(pRec->NewTimeStamp),
                                                sizeof(DWORD),  /*change type
                                                                   *to
                                                                   *TIME_STAMP_T
                                                                   *later
                                                                 */
                                                0,
                                                NULL /*optional info */
                                                     )
                                               );
                                //
                                // If the state of the record is a Tombstone
                                // or ACTIVE, we need to update the version
                                // number.
                                //
                                if (
                                           (State == NMSDB_E_TOMBSTONE)
                                                ||
                                        (State == NMSDB_E_ACTIVE)
                                      )
                                {

                                        VERS_NO_T VersNo;

                                        VersNo = NmsNmhMyMaxVersNo;


                                        //
                                        // Make local WINS the owner if
                                        // we are in an RPC thread.  We
                                        // have to make the local WINS the
                                        // owner in order to update the
                                        // version stamp.  Also, note that if
                                        // this is not the RPC thread then
                                        // this has to be the scavenger thread
                                        // (FYI: A scavenger thread never
                                        // changes a replica into a tombstone)
                                        //
                                        if (Client_e == WINS_E_WINSRPC)
                                        {
                                             DWORD OwnerId=NMSDB_LOCAL_OWNER_ID;

                                             /* Set the owner byte        */
                                             CALL_M( JetSetColumn(
                                                     SesId,
                                                     TblId,
                                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                                     &OwnerId,
                                                     NAM_ADD_OWNERID_SIZE,
                                                     0,
                                                     NULL /*optional info */
                                                         )
                                                       );
                                             //
                                             // Update the version number field
                                             // so that this record gets
                                             // propagated eventually
                                             //
                                             CALL_M( JetSetColumn(
                                                    SesId,
                                                  TblId,
                                                  sNamAddTblRow[
                                                  NAM_ADD_VERSIONNO_INDEX].Fid,
                                                  &VersNo,
                                                  sizeof(VERS_NO_T),
                                                  0,
                                                  NULL /*optional info */
                                                )
                                                    );

                                             fIncVersNo = TRUE;
                                        }
                                        else
                                        {
                                           //
                                           // This is the scavenger thread.
                                           // If the new state is not ACTIVE,
                                           // update the version number since
                                           // the state is TOMBSTONE.
                                           // if the state is ACTIVE, then it
                                           // means that we are doing a
                                           // a revalidation of old replicas
                                           // (i,e, the VerifyClutter() called
                                           // us).
                                           // The version number should stay
                                           // the same.
                                           //
                                           if (State != NMSDB_E_ACTIVE)
                                           {
                                               // if the current record is replica dont touch
                                               // the version #.
                                               CALL_M( JetRetrieveColumn(
                                                          SesId,
                                                          TblId,
                                                          sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                                          &OwnerId,
                                                          NAM_ADD_OWNERID_SIZE,
                                                          &ActFldLen,
                                                          0,
                                                          NULL));

                                               if (NMSDB_LOCAL_OWNER_ID == OwnerId) {
                                                   //
                                                   // Update the version number field
                                                   //
                                                   CALL_M( JetSetColumn(
                                                          SesId,
                                                        TblId,
                                                        sNamAddTblRow[
                                                        NAM_ADD_VERSIONNO_INDEX].Fid,
                                                        &VersNo,
                                                          sizeof(VERS_NO_T),
                                                        0,
                                                        NULL /*optional info */
                                                          )
                                                       );

                                                  fIncVersNo = TRUE;
                                               }

                                           }
                                        }


                                }  // if (state is ACTIVE or TOMBSTONE)

                                //
                                // Update the record
                                //
                                CALL_M(JetUpdate (
                                        SesId,
                                        TblId,
                                        NULL,
                                        0L,
                                        NULL
                                                 )
                                              );
                        } // end of try block
                        finally {
                                if (AbnormalTermination())
                                {
                                   // if there is an abnormal termination, we already have an error
                                   // code here. We shouldn't override it with any other error code.
                                   JetRollback(SesId, JET_bitRollbackAll);
                                }
                                else
                                {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                                   CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                                }
                         }
                                if (fIncVersNo)
                                {
                                        NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                           );

                                        RPL_PUSH_NTF_M(
                                                  RPL_PUSH_NO_PROP, NULL, NULL, NULL);
                                }

                        } // New state is not DELETED

                }  // if (Timestamps equal or client is RPC)
#ifdef WINSDBG
                else
                {

                        DBGPRINT0(FLOW, "NmsDbQueryNUpdIfMatch: TimeStamp of record has changed\n");
                }
#endif
        }
        else  //seek failed
        {
                DBGPRINT3(FLOW, "NmsDbQueryNUpdIfMatch: Could not find record(%s[%x]) whose state has to be changed to (%d)\n",
                   pRec->pName, *(pRec->pName + 15),
                   NMSDB_ENTRY_STATE_M(pRec->Flag));

                //
                // Two different threads (RPC or Scavenger) can be calling
                // this function.  It is possible that either might have
                // deleted the record.  We should not raise an exception
                // here
                //
//                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

        }

} // end of try { ..}

finally {
        if (AbnormalTermination() && !fAbort)
        {
                DBGPRINT0(ERR, "NmsDbQueryNUpdIfMatch: Abnormal Termination\n");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);

        }

        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        if (fChgPrLvl)
        {
                WinsMscSetThreadPriority(
                                        WinsThdPool.ScvThds[0].ThdHdl,
                                        ThdPrLvl
                                        );
        }

  }  //end of finally

        DBGLEAVE("NmsDbQueryNUpdIfMatch\n");
        return(WINS_SUCCESS);

} // NmsDbQueryNUpdIfMatch

STATUS
SetSystemParamsJet600(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --
--*/

{
    JET_ERR         JetRetStat;
    BOOL          fFreeMem = TRUE;
    CHAR        DbFileDir[WINS_MAX_FILENAME_SZ];   //path to database file directory
    DBGENTER("SetSystemParam600\n");
    if (fBeforeInit)
    {
        CHAR    *p;

        // extract the directory path where database file will be created
        strcpy(DbFileDir, WinsCnf.pWinsDb);
        if (p = strrchr(DbFileDir, '\\')) {
            p++ ;
            *p = '\0';
        } else {
            return WINS_FAILURE;
        }

        //
        // set this to enable version checking.
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramCheckFormatWhenOpenFail,
                        1,
                        NULL
                           )
                );

        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramExceptionAction,
                        JET_ExceptionMsgBox,
                        NULL
                           )
                );

        //
        // Path for the checkpoint file jet.chk to be located
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramSystemPath,
                        0,
                        DbFileDir
                           )
                );
        //
        // Basename to use for jet*.log and jet.chk
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramBaseName,
                        0,
                        BASENAME
                           )
                );
        //
        // Max size of the log file in kb.
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramLogFileSize,
                        1024,    //set to one full meg (#96543)
                        NULL    //ignored
                           )
                );
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramTempPath,
                        0,
                        TEMP_DB_PATH        //ignored
                           )
                );
PERF("Check the following two things")
                //
                // We want some aggressive flushing.  The performance impact
                // is very trivial - Ian Jose 7/12/93
                //

                //
                // The max number of buffers for database usage
                //
                // The default number is 500.  600 events are allocated
                // for 500 buffers -- Ian 10/21/93.  Each buffer is
                // 4K.  By keeping the number small, we impact performamce
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramCacheSizeMax,   // JET_paramMaxBuffers,
                                WinsCnf.NoOfDbBuffers,//200,
                                NULL        //ignored
                                   )
                        );

                // Cheen: min cache size should be at-least 4 times the size of no of sessions
                // o/w it can lead to deadlock.
                ASSERT( WinsCnf.NoOfDbBuffers > MAX_NO_SESSIONS*4 );
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramCacheSizeMin,
                                MAX_NO_SESSIONS * 4,
                                NULL        //ignored
                                   )
                        );

                //
                // The max. number of buffers to store old version of a
                // a record (snapshot at the start of a transaction)
                // Each version store is 16k bytes. A version store
                // stores structures that hold information derived from
                // a snapshot of the database prior to an insert (20 bytes
                // roughly) or update (size of the record + 20 bytes).
                //
                // For small transactions (i.e. a transaction around each
                // update), this number should be >= the max. number of
                // sessions that can be updating/inserting at the same time.
                // Each session will have one version bucket. Since 16k of
                // version bucket size can result in a lot of wastage per
                // session (since each record is < .5k, and on the average
                // around 50 bytes), it may be better to specify the
                // max. size of the version bucket (<< 16k).  Ian will
                //provide a system param for this if we absolutely need it
                //
                // 3/4/93
                //16kBytes should be enough for the transactions WINS does,
                //but if all the sessions are in transactions at the same time
                //and they all happen to have their small transactions traverse
                //2 buckets then the peak requirement is 2 buckets per session.
                //We could shorten the buckets to 8kBytes, or 4kBytes, and you
                //could allocate 2 per session?
                //
                // 8/5/99
                // The previous value was 16M (42x15 pages of 16K each ~= 16M).
                // This value seems to be a bit too small so bump it to 32M.
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxVerPages,
                                MAX_NO_SESSIONS * 50, //number of 16K pages
                                NULL        //ignored
                                   )
                        );

                //
                // Set the File Control Block Param
                //
                // This is the max. number of tables that can be open
                // at any time.  If multiple threads open the same table
                // they use the same FCB. FCB is 1 per table/index.
                // Now, for a create database, we need atleast 18 FCBS
                // and 18 IDBS.  However apart from create database and
                // ddl operations, we don't need to have these tables open.
                // Default value is 300. Size of an FCB is 112 bytes.
                //
                // Jonathan Liem (1/6/97)
                // JET_paramMaxOpenTableIndexes is removed. It is merged with
                // JET_paramMaxOpenTables.  So if you used to set JET_paramMaxOpenIndexes
                // to be 2000 and JET_paramMaxOpenTables to be 1000, then for
                // new Jet, you need to set JET_paramMaxOpenTables to 3000.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenTables,
                                112,    //was 56     //18 + 10,
                                NULL        //ignored
                                   )
                        );


                //
                // Set the File Usage Control Block to 100.
                // This parameter indicates the max. number of cursors
                // that can be open at any one time.  This is
                // therefore dependent on the the max. number of sessions
                // that we can have running concurrently.  For each session,
                // there would be 4 cursors (for the two tables) + a certain
                // number of internal cursors.  For good measure we add
                // a pad. Default value is 300. Size of each is 200 bytes.
                // We use MAX_SESSIONS * 4 + pad
                // (around 100)
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxCursors,
                                (MAX_NO_SESSIONS * 8 /*4*/) + 32,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the Sort Control block.
                // This should be 1 per concurrent Create Index.
                // Default value is 20. Size of each is 612 bytes.
                // In the case of WINS, the main thread creates the
                // indices.  We should be setting it to 1. Let us
                // however set it to 3.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxTemporaryTables ,
                                10,         //1 + 2,
                                NULL        //ignored
                                   )
                        );
                //
                // Set the Number for the Database Attribute Blocks
                //
                // This is max. number of Open Databases done.  Since we
                // can have a max of MAX_NO_SESSIONS at one time. This should
                // be equal to that number (since we have just one database)
                // Default number is 100. Size is 14 bytes
                //
                // JET_paramMaxOpenDatabase is removed.   Jonathan Liem (1/6/97)

                // Jonathan Liem (1/6/97)
                // JET_paramBfThrshldLowPrcnt and JET_paramBfThrhldHighPrcnt are changed
                // to JET_paramStartFlushThreshold and JET_paramStopFlushThreshold.  The
                // old ones are percent of given number of buffers (set through JET_paramMaxBuffer),
                // the new ones are absolute value so that we can set low threshold less
                // than 1 percent.
                //
                //
                // The min number of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramStartFlushThreshold,
                                (WinsCnf.NoOfDbBuffers * 1)/100,
                                NULL        //ignored
                                   )
                        );

                //
                // The max number of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramStopFlushThreshold,
                                (WinsCnf.NoOfDbBuffers * 2)/100,
                                NULL        //ignored
                                   )
                        );



                //
                // The max. number of sessions that can be open at any time
                //
                // Note: Jet does not preallocate resources corresponding
                // to the max. value.  It allocates them dynamically upto
                // the limit -- according to Ian Jose 7/12/93
                //
                // When checked with Ian again on 10/21, he said that they are
                // allocated STATICally
                //
CHECK("Make sure the comment above remains true")
FUTURES("Make sure the comment above remains true")
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxSessions,
                                MAX_NO_SESSIONS,
                                NULL        //ignored
                                   )
                        );
                // don't playback old logs upon restore (bug #277816)

                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,
                                JET_paramDeleteOutOfRangeLogs,
                                1,
                                NULL));

                //
                // Turn on logging if not prohibited by administrator
                //
                if (WinsCnf.fLoggingOn)
                {

                        // enable circular logging
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,
                                        JET_paramCircularLog,
                                        1,
                                        NULL));

FUTURES("Internationalize the following when jet is internationalized")
                        //
                        // Turn logging (recovery) on
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramRecovery,
                                        0,        //ignored
                                        "on"
                                                       )
                                        );


                        //
                        // The number of log sectors.  Each sector is
                        // 512 bytes.  We should keep the size more than
                        // the threshold so that if the threshold is reached
                        // and flushing starts, Jet can still continue to
                        // log in the spare sectors.  Point to note is that
                        // if the log rate is faster than the flush rate, then
                        // the Jet engine thread will not be able to log when
                        // the entire buffer is filled up.  It will then wait
                        // until space becomes available.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogBuffers,
                                        30,        //30 sectors
                                        NULL        //ignored
                                               )
                                        );

                        //
                        // Set the number of log buffers dirtied before they
                        // are flushed.  This number should always be less than
                        // the number for LogBuffers so that spare sectors
                        // are there for concurrent logging.  Also, we should
                        // make this number high enough to handle burst of
                        // traffic.
                        //
                        // this is gone in jet600.dll   cheen liao 1/6/96

                        //
                        // Set the wait time (in msecs) to wait prior to
                        // flushing the log on commit transaction to allow
                        // other users (sessions) to share the flush
                        //
                        //
                        // This is the time after which the user (a session)
                        // will ask the log manager to flush.  If we specify
                        // 0 here than it means flush every time a transaction
                        // commits.  In the WINS server case, every insertion
                        // or modification is done under an implicit
                        // transaction.  So, it means that there will be
                        // a flush after every such transaction.  It has
                        // been seen on a 486/66 (Cheen Liao) machine that
                        // it takes roughly 16 msecs to do the flush.  The
                        // time it takes to do the flush is dependent upon
                        // the type of disk (how fast it is), the CPU speed,
                        // the type of file system etc. We can for now
                        // go with the assumption that it is in the range
                        // 15-25 msecs.  I am pushing for this WaitTime to
                        // be made a session specific param so that it can
                        // be changed on the fly if the admin. finds that
                        // the WINS server is slow due to the WaitTime being
                        // very low or if it finds it to be so large that
                        // in case of a crash, there is possibility to loose
                        // a lot of data.
                        //
                        // Making this session specific is also very important
                        // for replication where we do want to set it to
                        // a high value (high enough to ensure that most
                        // of the records that need to be inserted are
                        // inserted before a flush action takes place.  The
                        // wait time would be set every time a bunch of
                        // records are pulled in for replication. It will
                        // be computed based on the number of records pulled
                        // in and the time it takes to insert one record in the
                        // jet buffer. The wait time should preferably be < than
                        // the above computed time (it does not have to be).
                        //
                        // NOTE: In the Pull thread, I will need to start
                        // two sessions, one for updating the OwnerId-Version
                        // number table (0 wait time) and the other to
                        // update the name-address mapping table (wait time
                        // computed based on the factors mentioned above)

                        //
                        // The following will set the WaitLogFlush time for
                        // all sessions.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramWaitLogFlush,
                                        0,        //wait 0 msecs after commit
                                                  //before flushing
                                        NULL      //ignored
                                               )
                                        );

                        //
                        // There does not seem to be any need to set
                        // Log Flush Period.
                        //
                }

                //
                // set the log file path
                //
                if (WinsCnf.pLogFilePath == NULL)
                {
                        //
                        // We should use the same directory as
                        // the one for system.mdb file
                        //
                        WinsCnf.pLogFilePath = LOGFILE_PATH;
                        fFreeMem = FALSE;
                }

                DBGPRINT1(FLOW, "SetSystemParam: LogFilePath = (%s)\n", WinsCnf.pLogFilePath);
                //
                // Set the log file path.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramLogFilePath,
                                0,        //ignored
                                WinsCnf.pLogFilePath
                                //pLogFilePath
                                           )
                                      );

                //
                // Free this memory.  It is not needed any more
                //
                if (fFreeMem)
                {
                   WinsMscDealloc(WinsCnf.pLogFilePath);
                }
    }
    else
    {

                if (!RtlEqualMemory(WinsCnf.pLogFilePath, LOGFILE_PATH, sizeof(LOGFILE_PATH)))
                {
                  DBGPRINT0(DET, "SetSystemParam: Setting Log file path again\n");
                  WinsCnf.pLogFilePath = LOGFILE_PATH;
                  CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath,
                                    0,        //ignored
                                    WinsCnf.pLogFilePath
                                               )
                                          );
                }

    }

    return WINS_SUCCESS;
}

STATUS
SetSystemParamsJet500(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --
--*/

{
    JET_ERR         JetRetStat;
    DBGENTER("SetSystemParam500\n");
    if (fBeforeInit)
    {
        //
        // Path for the checkpoint file jet.chk to be located
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramSystemPath_OLD,
                        0,
                        CHKPOINT_PATH
                           )
                );
        //
        // Basename to use for jet*.log and jet.chk
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramBaseName_OLD,
                        0,
                        BASENAME
                           )
                );

        //
        // Max size of the log file in kb.
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramLogFileSize_OLD,
                        1024,    //set to one full meg (#96543)
                        NULL    //ignored
                           )
                );

        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramTempPath_OLD,
                        0,
                        TEMP_DB_PATH        //ignored
                           )
                );

PERF("Check the following two things")
                //
                // We want some aggressive flushing.  The performance impact
                // is very trivial - Ian Jose 7/12/93
                //

                //
                // The max number of buffers for database usage
                //
                // The default number is 500.  600 events are allocated
                // for 500 buffers -- Ian 10/21/93.  Each buffer is
                // 4K.  By keeping the number small, we impact performamce
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxBuffers_OLD,
                                WinsCnf.NoOfDbBuffers,//200,
                                NULL        //ignored
                                   )
                        );
                //
                // The max. number of buffers to store old version of a
                // a record (snapshot at the start of a transaction)
                // Each version store is 16k bytes. A version store
                // stores structures that hold information derived from
                // a snapshot of the database prior to an insert (20 bytes
                // roughly) or update (size of the record + 20 bytes).
                //
                // For small transactions (i.e. a transaction around each
                // update), this number should be >= the max. number of
                // sessions that can be updating/inserting at the same time.
                // Each session will have one version bucket. Since 16k of
                // version bucket size can result in a lot of wastage per
                // session (since each record is < .5k, and on the average
                // around 50 bytes), it may be better to specify the
                // max. size of the version bucket (<< 16k).  Ian will
                //provide a system param for this if we absolutely need it
                //
                // 3/4/93
                //16kBytes should be enough for the transactions WINS does,
                //but if all the sessions are in transactions at the same time
                //and they all happen to have their small transactions traverse
                //2 buckets then the peak requirement is 2 buckets per session.
                //We could shorten the buckets to 8kBytes, or 4kBytes, and you
                //could allocate 2 per session?
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxVerPages_OLD,
                                MAX_NO_SESSIONS * 6, //10-4-95 Bump it up more
                                //MAX_NO_SESSIONS * 2,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the File Control Block Param
                //
                // This is the max. number of tables that can be open
                // at any time.  If multiple threads open the same table
                // they use the same FCB. FCB is 1 per table/index.
                // Now, for a create database, we need atleast 18 FCBS
                // and 18 IDBS.  However apart from create database and
                // ddl operations, we don't need to have these tables open.
                // Default value is 300. Size of an FCB is 112 bytes.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenTables_OLD,
                                56,     //18 + 10,
                                NULL        //ignored
                                   )
                        );


                //
                // Set the File Usage Control Block to 100.
                // This parameter indicates the max. number of cursors
                // that can be open at any one time.  This is
                // therefore dependent on the the max. number of sessions
                // that we can have running concurrently.  For each session,
                // there would be 4 cursors (for the two tables) + a certain
                // number of internal cursors.  For good measure we add
                // a pad. Default value is 300. Size of each is 200 bytes.
                // We use MAX_SESSIONS * 4 + pad
                // (around 100)
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxCursors_OLD,
                                (MAX_NO_SESSIONS * 8 /*4*/) + 32,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the number of index description blocks
                // This is one per table/index.  We have two tables
                // each with two indices. We use 9 (see comment for
                // FCBs above).  Default value is 300.
                // Size of each is 128 bytes.
                //

                    CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramMaxOpenTableIndexes_OLD,
                                    56,         //18 + 10,
                                    NULL        //ignored
                                       )
                            );

                //
                // Set the Sort Control block.
                // This should be 1 per concurrent Create Index.
                // Default value is 20. Size of each is 612 bytes.
                // In the case of WINS, the main thread creates the
                // indices.  We should be setting it to 1. Let us
                // however set it to 3.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxTemporaryTables_OLD ,
                                10,         //1 + 2,
                                NULL        //ignored
                                   )
                        );
                //
                // Set the Number for the Database Attribute Blocks
                //
                // This is max. number of Open Databases done.  Since we
                // can have a max of MAX_NO_SESSIONS at one time. This should
                // be equal to that number (since we have just one database)
                // Default number is 100. Size is 14 bytes
                //
                // JET_paramMaxOpenDatabase is removed.   Jonathan Liem (1/6/97)
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenDatabases_OLD,
                                MAX_NO_SESSIONS * 4, //*2,
                                NULL        //ignored
                                   )
                        );

                //
                // The min percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldLowPrcnt_OLD,
                                80,
                                NULL        //ignored
                                   )
                        );

                //
                // The max percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldHighPrcnt_OLD,
                                100,
                                NULL        //ignored
                                   )
                        );


                //
                // The max. number of sessions that can be open at any time
                //
                // Note: Jet does not preallocate resources corresponding
                // to the max. value.  It allocates them dynamically upto
                // the limit -- according to Ian Jose 7/12/93
                //
                // When checked with Ian again on 10/21, he said that they are
                // allocated STATICally
                //
CHECK("Make sure the comment above remains true")
FUTURES("Make sure the comment above remains true")
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxSessions_OLD,
                                MAX_NO_SESSIONS,
                                NULL        //ignored
                                   )
                        );

                //
                // Turn on logging if not prohibited by administrator
                //
                if (WinsCnf.fLoggingOn)
                {

FUTURES("Internationalize the following when jet is internationalized")
                        //
                        // Turn logging (recovery) on
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        30, // JET_paramRecovery not available,
                                        0,        //ignored
                                        "on"
                                                       )
                                        );


                        //
                        // The number of log sectors.  Each sector is
                        // 512 bytes.  We should keep the size more than
                        // the threshold so that if the threshold is reached
                        // and flushing starts, Jet can still continue to
                        // log in the spare sectors.  Point to note is that
                        // if the log rate is faster than the flush rate, then
                        // the Jet engine thread will not be able to log when
                        // the entire buffer is filled up.  It will then wait
                        // until space becomes available.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogBuffers_OLD,
                                        30,        //30 sectors
                                        NULL        //ignored
                                               )
                                        );

                        //
                        // Set the number of log buffers dirtied before they
                        // are flushed.  This number should always be less than
                        // the number for LogBuffers so that spare sectors
                        // are there for concurrent logging.  Also, we should
                        // make this number high enough to handle burst of
                        // traffic.
                        //
                            CALL_M(JetSetSystemParameter(
                                            &sJetInstance,
                                            (JET_SESID)0,        //SesId - ignored
                                            18, //JET_paramLogFlushThreshold,
                                            20,        //20 sectors dirtied causes
                                                    //flush
                                            NULL        //ignored
                                                   )
                                            );


                        //
                        // Set the wait time (in msecs) to wait prior to
                        // flushing the log on commit transaction to allow
                        // other users (sessions) to share the flush
                        //
                        //
                        // This is the time after which the user (a session)
                        // will ask the log manager to flush.  If we specify
                        // 0 here than it means flush every time a transaction
                        // commits.  In the WINS server case, every insertion
                        // or modification is done under an implicit
                        // transaction.  So, it means that there will be
                        // a flush after every such transaction.  It has
                        // been seen on a 486/66 (Cheen Liao) machine that
                        // it takes roughly 16 msecs to do the flush.  The
                        // time it takes to do the flush is dependent upon
                        // the type of disk (how fast it is), the CPU speed,
                        // the type of file system etc. We can for now
                        // go with the assumption that it is in the range
                        // 15-25 msecs.  I am pushing for this WaitTime to
                        // be made a session specific param so that it can
                        // be changed on the fly if the admin. finds that
                        // the WINS server is slow due to the WaitTime being
                        // very low or if it finds it to be so large that
                        // in case of a crash, there is possibility to loose
                        // a lot of data.
                        //
                        // Making this session specific is also very important
                        // for replication where we do want to set it to
                        // a high value (high enough to ensure that most
                        // of the records that need to be inserted are
                        // inserted before a flush action takes place.  The
                        // wait time would be set every time a bunch of
                        // records are pulled in for replication. It will
                        // be computed based on the number of records pulled
                        // in and the time it takes to insert one record in the
                        // jet buffer. The wait time should preferably be < than
                        // the above computed time (it does not have to be).
                        //
                        // NOTE: In the Pull thread, I will need to start
                        // two sessions, one for updating the OwnerId-Version
                        // number table (0 wait time) and the other to
                        // update the name-address mapping table (wait time
                        // computed based on the factors mentioned above)

                        //
                        // The following will set the WaitLogFlush time for
                        // all sessions.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramWaitLogFlush_OLD,
                                        0,        //wait 0 msecs after commit
                                                  //before flushing
                                        NULL      //ignored
                                               )
                                        );

                        //
                        // There does not seem to be any need to set
                        // Log Flush Period.
                        //

                        //
                        // set the log file path
                        //
FUTURES("Use DEFAULT_LOG_PATH after putting it in a header file")
                        if (WinsCnf.pLogFilePath == NULL)
                        {
                                //
                                // We should use the same directory as
                                // the one for system.mdb file
                                //

//                                pLogFilePath = ".\\wins";
                                WinsCnf.pLogFilePath = LOGFILE_PATH;
                        }
                        else
                        {
#if 0
#ifdef UNICODE
                                CHAR        AsciiLogFilePath[WINS_MAX_FILENAME_SZ];
                                WinsMscConvertUnicodeStringToAscii(
                                        (LPBYTE)WinsCnf.pLogFilePath,
                                        AsciiLogFilePath,
                                        WINS_MAX_FILENAME_SZ
                                                );
                                pLogFilePath = (LPBYTE)AsciiLogFilePath;
#else
                                pLogFilePath = (LPBYTE)WinsCnf.pLogFilePath;
#endif
#endif
                        }

                        DBGPRINT1(FLOW, "SetSystemParam: LogFilePath = (%s)\n", WinsCnf.pLogFilePath);
                        //
                        // Set the log file path.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogFilePath_OLD,
                                        0,        //ignored
                                        WinsCnf.pLogFilePath
                                        //pLogFilePath
                                                   )
                                              );

                }

    }
    else
    {

                if (!RtlEqualMemory(WinsCnf.pLogFilePath, LOGFILE_PATH, sizeof(LOGFILE_PATH)))
                {
                  DBGPRINT0(DET, "SetSystemParam: Setting Log file path again\n");
                  WinsCnf.pLogFilePath = LOGFILE_PATH;
                  CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath_OLD,
                                    0,        //ignored
                                    WinsCnf.pLogFilePath
                                               )
                                          );
                }

    }

    return WINS_SUCCESS;
}

STATUS
SetSystemParamsJet200(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --
--*/

{
    JET_ERR         JetRetStat;
    BOOL          fFreeMem = TRUE;
    DBGENTER("SetSystemParam200\n");
    if (fBeforeInit)
    {
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramSysDbPath_OLD,
                        0,
                        SYS_DB_PATH        //ignored
                           )
                );

        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramTempPath_OLD,
                        0,
                        TEMP_DB_PATH        //ignored
                           )
                );
PERF("Check the following two things")
                //
                // We want some aggressive flushing.  The performance impact
                // is very trivial - Ian Jose 7/12/93
                //

                //
                // The max number of buffers for database usage
                //
                // The default number is 500.  600 events are allocated
                // for 500 buffers -- Ian 10/21/93.  Each buffer is
                // 4K.  By keeping the number small, we impact performamce
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxBuffers_OLD,
                                WinsCnf.NoOfDbBuffers,//200,
                                NULL        //ignored
                                   )
                        );
                //
                // The max. number of buffers to store old version of a
                // a record (snapshot at the start of a transaction)
                // Each version store is 16k bytes. A version store
                // stores structures that hold information derived from
                // a snapshot of the database prior to an insert (20 bytes
                // roughly) or update (size of the record + 20 bytes).
                //
                // For small transactions (i.e. a transaction around each
                // update), this number should be >= the max. number of
                // sessions that can be updating/inserting at the same time.
                // Each session will have one version bucket. Since 16k of
                // version bucket size can result in a lot of wastage per
                // session (since each record is < .5k, and on the average
                // around 50 bytes), it may be better to specify the
                // max. size of the version bucket (<< 16k).  Ian will
                //provide a system param for this if we absolutely need it
                //
                // 3/4/93
                //16kBytes should be enough for the transactions WINS does,
                //but if all the sessions are in transactions at the same time
                //and they all happen to have their small transactions traverse
                //2 buckets then the peak requirement is 2 buckets per session.
                //We could shorten the buckets to 8kBytes, or 4kBytes, and you
                //could allocate 2 per session?
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxVerPages_OLD,
                                MAX_NO_SESSIONS * 6, //10-4-95 Bump it up more
                                //MAX_NO_SESSIONS * 2,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the File Control Block Param
                //
                // This is the max. number of tables that can be open
                // at any time.  If multiple threads open the same table
                // they use the same FCB. FCB is 1 per table/index.
                // Now, for a create database, we need atleast 18 FCBS
                // and 18 IDBS.  However apart from create database and
                // ddl operations, we don't need to have these tables open.
                // Default value is 300. Size of an FCB is 112 bytes.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenTables_OLD,
                                56,     //18 + 10,
                                NULL        //ignored
                                   )
                        );


                //
                // Set the File Usage Control Block to 100.
                // This parameter indicates the max. number of cursors
                // that can be open at any one time.  This is
                // therefore dependent on the the max. number of sessions
                // that we can have running concurrently.  For each session,
                // there would be 4 cursors (for the two tables) + a certain
                // number of internal cursors.  For good measure we add
                // a pad. Default value is 300. Size of each is 200 bytes.
                // We use MAX_SESSIONS * 4 + pad
                // (around 100)
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxCursors_OLD,
                                (MAX_NO_SESSIONS * 8 /*4*/) + 32,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the number of index description blocks
                // This is one per table/index.  We have two tables
                // each with two indices. We use 9 (see comment for
                // FCBs above).  Default value is 300.
                // Size of each is 128 bytes.
                //

                    CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramMaxOpenTableIndexes_OLD,
                                    56,         //18 + 10,
                                    NULL        //ignored
                                       )
                            );

                //
                // Set the Sort Control block.
                // This should be 1 per concurrent Create Index.
                // Default value is 20. Size of each is 612 bytes.
                // In the case of WINS, the main thread creates the
                // indices.  We should be setting it to 1. Let us
                // however set it to 3.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxTemporaryTables_OLD ,
                                10,         //1 + 2,
                                NULL        //ignored
                                   )
                        );
                //
                // Set the Number for the Database Attribute Blocks
                //
                // This is max. number of Open Databases done.  Since we
                // can have a max of MAX_NO_SESSIONS at one time. This should
                // be equal to that number (since we have just one database)
                // Default number is 100. Size is 14 bytes
                //
                // JET_paramMaxOpenDatabase is removed.   Jonathan Liem (1/6/97)
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenDatabases_OLD,
                                MAX_NO_SESSIONS * 4, //*2,
                                NULL        //ignored
                                   )
                        );

                //
                // The min percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldLowPrcnt_OLD,
                                80,
                                NULL        //ignored
                                   )
                        );

                //
                // The max percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldHighPrcnt_OLD,
                                100,
                                NULL        //ignored
                                   )
                        );


                //
                // The max. number of sessions that can be open at any time
                //
                // Note: Jet does not preallocate resources corresponding
                // to the max. value.  It allocates them dynamically upto
                // the limit -- according to Ian Jose 7/12/93
                //
                // When checked with Ian again on 10/21, he said that they are
                // allocated STATICally
                //
CHECK("Make sure the comment above remains true")
FUTURES("Make sure the comment above remains true")
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxSessions_OLD,
                                MAX_NO_SESSIONS,
                                NULL        //ignored
                                   )
                        );

                //
                // Turn on logging if not prohibited by administrator
                //
                if (WinsCnf.fLoggingOn)
                {

FUTURES("Internationalize the following when jet is internationalized")
                        //
                        // Turn logging (recovery) on
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        30,                 // JET_paramRecovery_OLD not available,
                                        0,        //ignored
                                        "on"
                                                       )
                                        );


                        //
                        // The number of log sectors.  Each sector is
                        // 512 bytes.  We should keep the size more than
                        // the threshold so that if the threshold is reached
                        // and flushing starts, Jet can still continue to
                        // log in the spare sectors.  Point to note is that
                        // if the log rate is faster than the flush rate, then
                        // the Jet engine thread will not be able to log when
                        // the entire buffer is filled up.  It will then wait
                        // until space becomes available.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogBuffers_OLD,
                                        30,        //30 sectors
                                        NULL        //ignored
                                               )
                                        );

                        //
                        // Set the number of log buffers dirtied before they
                        // are flushed.  This number should always be less than
                        // the number for LogBuffers so that spare sectors
                        // are there for concurrent logging.  Also, we should
                        // make this number high enough to handle burst of
                        // traffic.
                        //
                            CALL_M(JetSetSystemParameter(
                                            &sJetInstance,
                                            (JET_SESID)0,        //SesId - ignored
                                            18, // JET_paramLogFlushThreshold,
                                            20,        //20 sectors dirtied causes
                                                    //flush
                                            NULL        //ignored
                                                   )
                                            );


                        //
                        // Set the wait time (in msecs) to wait prior to
                        // flushing the log on commit transaction to allow
                        // other users (sessions) to share the flush
                        //
                        //
                        // This is the time after which the user (a session)
                        // will ask the log manager to flush.  If we specify
                        // 0 here than it means flush every time a transaction
                        // commits.  In the WINS server case, every insertion
                        // or modification is done under an implicit
                        // transaction.  So, it means that there will be
                        // a flush after every such transaction.  It has
                        // been seen on a 486/66 (Cheen Liao) machine that
                        // it takes roughly 16 msecs to do the flush.  The
                        // time it takes to do the flush is dependent upon
                        // the type of disk (how fast it is), the CPU speed,
                        // the type of file system etc. We can for now
                        // go with the assumption that it is in the range
                        // 15-25 msecs.  I am pushing for this WaitTime to
                        // be made a session specific param so that it can
                        // be changed on the fly if the admin. finds that
                        // the WINS server is slow due to the WaitTime being
                        // very low or if it finds it to be so large that
                        // in case of a crash, there is possibility to loose
                        // a lot of data.
                        //
                        // Making this session specific is also very important
                        // for replication where we do want to set it to
                        // a high value (high enough to ensure that most
                        // of the records that need to be inserted are
                        // inserted before a flush action takes place.  The
                        // wait time would be set every time a bunch of
                        // records are pulled in for replication. It will
                        // be computed based on the number of records pulled
                        // in and the time it takes to insert one record in the
                        // jet buffer. The wait time should preferably be < than
                        // the above computed time (it does not have to be).
                        //
                        // NOTE: In the Pull thread, I will need to start
                        // two sessions, one for updating the OwnerId-Version
                        // number table (0 wait time) and the other to
                        // update the name-address mapping table (wait time
                        // computed based on the factors mentioned above)

                        //
                        // The following will set the WaitLogFlush time for
                        // all sessions.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET