CESS)
	{
        CRegistry Reg2 ;
        swprintf(szTemp, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", pszSID) ;
        dwRetCode = Reg2.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ) ;
        if(dwRetCode == ERROR_SUCCESS)
		{

			// Load the user account information
			dwRetCode = UserAccountFromProfile( Reg2, strUserName );
            // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
			Reg2.Close() ;
		}

    }
    else
    {
        // Try to locate user's registry hive
        //===================================

        swprintf(szTemp, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", pszSID) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ) ;
        if(dwRetCode == ERROR_SUCCESS)
		{
			UserAccountFromProfile( Reg, strUserName );

			dwRetCode = Reg.GetCurrentKeyValue(L"ProfileImagePath", sTemp) ;
	        Reg.Close() ;
			if(dwRetCode == ERROR_SUCCESS)
            {

				// NT 4 doesn't include the file name in the registry
				//===================================================

				if(OSInfo.dwMajorVersion >= 4)
                {
					sTemp += _T("\\NTUSER.DAT") ;
				}

				TCHAR szTemp[MAX_PATH];

                ExpandEnvironmentStrings(TOBSTRT(sTemp), szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;
				do
				{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					m_criticalSection.BeginWrite();

                    try
                    {
						dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, TOBSTRT(pszSID), szTemp);
                    }
                    catch ( ... )
                    {
    					m_criticalSection.EndWrite();
                        throw;
                    }
					m_criticalSection.EndWrite();

					if ((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11))
					{
						LogErrorMessage(L"Sharing violation on NTUSER.DAT (LoadProfile)");
						Sleep(20 * nTries);
						bTryTryAgain = true;
					}
					else
                    {
						bTryTryAgain = false;
                    }

				} while (bTryTryAgain);
			}
        }
    }

    if(dwRetCode == ERROR_SUCCESS)
    {
        LONG lRetVal;
        CHString sKey(pszSID);

        sKey += _T("\\Software");
        lRetVal = RegOpenKeyEx(HKEY_USERS, TOBSTRT(sKey), 0, KEY_QUERY_VALUE, &m_hKey);
        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }

    // Restore original privilege level & end self-impersonation
    //==========================================================

#ifdef NTONLY
    RestorePrivilege() ;
#endif

    return dwRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::UserAccountFromProfile
 *
 *  DESCRIPTION : Pulls the PSID out of the registry object, and creates
 *					a DOMAIN\UserName value.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none.
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registry Object must be preloaded to the correct profile
 *					key.
 *
 *****************************************************************************/

DWORD CUserHive::UserAccountFromProfile( CRegistry& reg, CHString& strUserName )
{
	DWORD	dwReturn = ERROR_SUCCESS,
			dwSidSize = 0;

	if ( ( dwReturn = reg.GetCurrentBinaryKeyValue( L"Sid", NULL, &dwSidSize ) ) == ERROR_SUCCESS )
	{
		PSID	psid = new byte [ dwSidSize ];

		if ( NULL != psid )
		{
            try
            {

			    if ( ( dwReturn = reg.GetCurrentBinaryKeyValue( L"Sid", (LPBYTE) psid, &dwSidSize ) ) == ERROR_SUCCESS )
			    {
				    CSid	sid( psid );

				    // The sid account type must be valid and the lookup must have been
				    // successful.

				    if ( sid.IsOK() && sid.IsAccountTypeValid() )
				    {
					    sid.GetDomainAccountName( strUserName );
                    }
                    else
                    {
                        dwReturn = ERROR_NO_SUCH_USER;
                    }
			    }
            }
            catch ( ... )
            {
                delete [] psid;
                throw ;
            }

			delete [] psid;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
	}

	return dwReturn;
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::Unload
 *
 *  DESCRIPTION : Unloads key from HKEY_USERS if present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DWORD CUserHive::Unload(LPCWSTR pszKeyName)
{
    DWORD dwRetCode = ERROR_SUCCESS;

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

#ifdef NTONLY
		dwRetCode = AcquirePrivilege();
#endif

	if(dwRetCode == ERROR_SUCCESS)
    {

        m_criticalSection.BeginWrite();

        try
        {
		    dwRetCode = RegUnLoadKey(HKEY_USERS, TOBSTRT(pszKeyName)) ;
        }
        catch ( ... )
        {
    		m_criticalSection.EndWrite();
            throw;
        }

		m_criticalSection.EndWrite();

#ifdef NTONLY
			RestorePrivilege() ;
#endif

    }

    return dwRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wbempsapi.h ===
//============================================================

//

// WBEMPSAPI.h - PSAPI.DLL access class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#ifndef __WBEMPSAPI__
#define __WBEMPSAPI__

#ifdef NTONLY
#include <psapi.h>

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "ResourceManager.h"
#include "TimedDllResource.h"
extern const GUID guidPSAPI ;


typedef BOOL  (WINAPI *PSAPI_ENUM_PROCESSES) (DWORD    *pdwPIDList,        // Pointer to DWORD array
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef BOOL  (WINAPI *PSAPI_ENUM_DRIVERS)   (LPVOID    pImageBaseList,    // Pointer to void * array
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef BOOL  (WINAPI *PSAPI_ENUM_MODULES)   (HANDLE    hProcess,          // Process to query
                                              HMODULE  *pModuleList,       // Array of HMODULEs
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef DWORD (WINAPI *PSAPI_GET_DRIVER_NAME)(LPVOID    pImageBase,        // Address of driver to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef DWORD (WINAPI *PSAPI_GET_MODULE_NAME)(HANDLE    hProcess,          // Process to query
                                              HMODULE   hModule,           // Module to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef DWORD (WINAPI *PSAPI_GET_DRIVER_EXE) (LPVOID    pImageBase,        // Address of driver to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef DWORD (WINAPI *PSAPI_GET_MODULE_EXE) (HANDLE    hProcess,          // Process to query
                                              HMODULE   hModule,           // Module to query
                                              LPTSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

typedef BOOL  (WINAPI *PSAPI_GET_MEMORY_INFO)(HANDLE    hProcess,          // Process to query
                                              PROCESS_MEMORY_COUNTERS *pMemCtrs,    // Memory counter struct
                                              DWORD     dwByteCount) ;     // Size of buffer

class CPSAPI : public CTimedDllResource
{
    public :

        CPSAPI() ;
       ~CPSAPI() ;
        
        LONG Init() ;

        BOOL EnumProcesses(DWORD *pdwPIDList, DWORD dwListSize, DWORD *pdwByteCount) ;

        BOOL EnumDeviceDrivers(LPVOID pImageBaseList, DWORD dwListSize, DWORD *pdwByteCount) ;

        BOOL EnumProcessModules(HANDLE hProcess, HMODULE *ModuleList, DWORD dwListSize, DWORD *pdwByteCount) ;

        DWORD GetDeviceDriverBaseName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) ;

        DWORD GetModuleBaseName(HANDLE hProcess, HMODULE hModule, LPTSTR pszName, DWORD dwNameSize) ;

        DWORD GetDeviceDriverFileName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) ;

        DWORD GetModuleFileNameEx(HANDLE hProcess, HMODULE hModule, LPTSTR pszName, DWORD dwNameSize) ;

        BOOL  GetProcessMemoryInfo(HANDLE hProcess, PROCESS_MEMORY_COUNTERS *pMemCtrs, DWORD dwByteCount) ;

    private :

        HINSTANCE hLibHandle ;

        PSAPI_ENUM_PROCESSES    pEnumProcesses ;
        PSAPI_ENUM_DRIVERS      pEnumDeviceDrivers ;
        PSAPI_ENUM_MODULES      pEnumProcessModules ;
        PSAPI_GET_DRIVER_NAME   pGetDeviceDriverBaseName ;
        PSAPI_GET_MODULE_NAME   pGetModuleBaseName ;
        PSAPI_GET_DRIVER_EXE    pGetDeviceDriverFileName ;
        PSAPI_GET_MODULE_EXE    pGetModuleFileNameEx ;
        PSAPI_GET_MEMORY_INFO   pGetProcessMemoryInfo ;
} ;
#endif

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\winmmapi.cpp ===
//=================================================================

//

// WinmmApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>

#include <lmuse.h>
#include "DllWrapperBase.h"
#include <mmreg.h>
#include <mmsystem.h>
#include <msacm.h>
#include "WinmmApi.h"
#include "DllWrapperCreatorReg.h"
#include <createmutexasprocess.h>


// {F54DB7BF-0FB4-11d3-910C-00105AA630BE}
static const GUID g_guidWinmmApi =
{ 0xf54db7bf, 0xfb4, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrWinmm [] = _T("Winmm.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWinmmApi, &g_guidWinmmApi, g_tstrWinmm> MyRegisteredWinmmWrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CWinmmApi::CWinmmApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnwaveOutGetNumDevs (NULL),
	m_pfnwaveOutGetDevCaps(NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CWinmmApi::~CWinmmApi()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CWinmmApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
		m_pfnwaveOutGetNumDevs = ( PFN_Winmm_waveOutGetNumDevs ) GetProcAddress ( "waveOutGetNumDevs" ) ;

#ifdef UNICODE
		m_pfnwaveOutGetDevCaps = ( PFN_Winmm_waveOutGetDevCaps ) GetProcAddress ( "waveOutGetDevCapsW" ) ;
#else
		m_pfnwaveOutGetDevCaps = ( PFN_Winmm_waveOutGetDevCaps ) GetProcAddress ( "waveOutGetDevCapsA" ) ;
#endif
    }

    // We require these function for all versions of this dll.

	if ( m_pfnwaveOutGetNumDevs == NULL ||
		 m_pfnwaveOutGetDevCaps == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in winmmapi");
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

UINT CWinmmApi :: WinMMwaveOutGetNumDevs (

	void
)
{
	return m_pfnwaveOutGetNumDevs () ;
}

#ifdef UNICODE
MMRESULT CWinmmApi :: WinmmwaveOutGetDevCaps (

	UINT_PTR uDeviceID,
	LPWAVEOUTCAPSW pwoc,
	UINT cbwoc
)
#else
MMRESULT CWinmmApi :: WinmmwaveOutGetDevCaps (

	UINT_PTR uDeviceID,
	LPWAVEOUTCAPSA pwoc,
	UINT cbwoc
)
#endif
{
	return m_pfnwaveOutGetDevCaps (

		uDeviceID,
		pwoc,
		cbwoc
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\winmmapi.h ===
//=================================================================

//

// WinmmApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WinmmApi_H_
#define	_WinmmApi_H_

#include <mmsystem.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWinmmApi;
extern const TCHAR g_tstrWinmm[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef UINT (WINAPI *PFN_Winmm_waveOutGetNumDevs )
(
	void
) ;

#ifdef UNICODE
typedef MMRESULT (WINAPI *PFN_Winmm_waveOutGetDevCaps )
(
	UINT_PTR uDeviceID, 
	LPWAVEOUTCAPSW pwoc, 
	UINT cbwoc
);
#else
typedef MMRESULT (WINAPI *PFN_Winmm_waveOutGetDevCaps )
(
	UINT_PTR uDeviceID, 
	LPWAVEOUTCAPSA pwoc, 
	UINT cbwoc
);
#endif


/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CWinmmApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_Winmm_waveOutGetNumDevs m_pfnwaveOutGetNumDevs ;
	PFN_Winmm_waveOutGetDevCaps m_pfnwaveOutGetDevCaps ;

public:

    // Constructor and destructor:
    CWinmmApi(LPCTSTR a_tstrWrappedDllName);
    ~CWinmmApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

	UINT WinMMwaveOutGetNumDevs (

		void
	) ;

#ifdef UNICODE
	MMRESULT WinmmwaveOutGetDevCaps (

		UINT_PTR uDeviceID, 
		LPWAVEOUTCAPSW pwoc, 
		UINT cbwoc
	);
#else
	MMRESULT WinmmwaveOutGetDevCaps (

		UINT_PTR uDeviceID, 
		LPWAVEOUTCAPSA pwoc, 
		UINT cbwoc
	);
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\winspoolapi.cpp ===
//=================================================================

//

// WinSpoolApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>

#include "DllWrapperBase.h"
#include "WinSpoolApi.h"
#include "DllWrapperCreatorReg.h"


// {77609C22-CDAA-11d2-911E-0060081A46FD}
static const GUID g_guidWinSpoolApi =
{ 0x3b8515f1, 0xefd, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrWinSpool[] = _T("WinSpool.Drv");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWinSpoolApi, &g_guidWinSpoolApi, g_tstrWinSpool> MyRegisteredWinSpoolWrapper;


/******************************************************************************
 * Constructor
 *****************************************************************************/
CWinSpoolApi::CWinSpoolApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnClosePrinter (NULL),
   m_pfnDeviceCapabilities (NULL),
   m_pfnDocumentProperties (NULL),
   m_pfnEnumJobs (NULL),
   m_pfnEnumPrinterDrivers (NULL),
   m_pfnEnumPrinters (NULL),
   m_pfnEnumPorts (NULL),
   m_pfnGetJob (NULL),
   m_pfnGetPrinter (NULL),
   m_pfnGetPrinterDriver (NULL),
   m_pfnSetPrinter (NULL),
   m_pfnOpenPrinter (NULL),
   m_pfnGetDefaultPrinter(NULL),
   m_hPrintMutex(NULL),
   m_pfnSetJob (NULL),
   m_pfnDeletePrinter (NULL),
   m_pfnSetDefaultPrinter(NULL)
#if NTONLY >= 5
   ,
   m_pfnXcvData(NULL),
   m_pfnAddPrinterConnection(NULL),
   m_pfnDeletePrinterConnection(NULL)
#endif
{
#ifdef WIN9XONLY
	m_hPrintMutex = ::CreateMutex( NULL, FALSE, PRINTER_NAMED_MUTEX ) ;
#endif
}


/******************************************************************************
 * Destructor
 *****************************************************************************/
CWinSpoolApi::~CWinSpoolApi()
{
#ifdef WIN9XONLY
	if( m_hPrintMutex )
	{
		ReleaseMutex( m_hPrintMutex ) ;
	}
#endif
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CWinSpoolApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnClosePrinter       = ( PFN_WinSpool_ClosePrinter )       GetProcAddress ( "ClosePrinter" ) ;
		m_pfnDeviceCapabilities = ( PFN_WinSpool_DeviceCapabilities ) GetProcAddress ( "DeviceCapabilitiesW" ) ;
		m_pfnDocumentProperties = ( PFN_WinSpool_DocumentProperties ) GetProcAddress ( "DocumentPropertiesW" ) ;
		m_pfnEnumJobs           = ( PFN_WinSpool_EnumJobs )           GetProcAddress ( "EnumJobsW" ) ;
		m_pfnEnumPrinterDrivers = ( PFN_WinSpool_EnumPrinterDrivers ) GetProcAddress ( "EnumPrinterDriversW" ) ;
		m_pfnEnumPrinters       = ( PFN_WinSpool_EnumPrinters )       GetProcAddress ( "EnumPrintersW" ) ;
		m_pfnEnumPorts          = ( PFN_WinSpool_EnumPorts )          GetProcAddress ( "EnumPortsW" ) ;
		m_pfnGetJob             = ( PFN_WinSpool_GetJob )             GetProcAddress ( "GetJobW" ) ;
		m_pfnGetPrinter         = ( PFN_WinSpool_GetPrinter )         GetProcAddress ( "GetPrinterW" ) ;
		m_pfnGetPrinterDriver   = ( PFN_WinSpool_GetPrinterDriver )   GetProcAddress ( "GetPrinterDriverW" ) ;
		m_pfnSetPrinter         = ( PFN_WinSpool_SetPrinter )         GetProcAddress ( "SetPrinterW" ) ;
		m_pfnOpenPrinter        = ( PFN_WinSpool_OpenPrinter )        GetProcAddress ( "OpenPrinterW" ) ;
		m_pfnSetJob         	= ( PFN_WinSpool_SetJob )             GetProcAddress ( "SetJobW" );
		m_pfnDeletePrinter  	= ( PFN_WinSpool_DeletePrinter )      GetProcAddress ( "DeletePrinter" );

#if NTONLY == 5
		m_pfnGetDefaultPrinter  = ( PFN_WinSpool_GetDefaultPrinter )  GetProcAddress ( "GetDefaultPrinterW" ) ;
		m_pfnSetDefaultPrinter  = ( PFN_WinSpool_SetDefaultPrinter )  GetProcAddress ( "SetDefaultPrinterW" ) ;
                m_pfnXcvData            = ( PFN_WinSpool_XcvData )            GetProcAddress ( "XcvDataW" ) ;
                m_pfnAddPrinterConnection    = ( PFN_WinSpool_AddPrinterConnection)    GetProcAddress ( "AddPrinterConnectionW" );
                m_pfnDeletePrinterConnection = ( PFN_WinSpool_DeletePrinterConnection) GetProcAddress ( "DeletePrinterConnectionW" );
#endif

#else
		m_pfnClosePrinter       = ( PFN_WinSpool_ClosePrinter )       GetProcAddress ( "ClosePrinter" ) ;
		m_pfnDeviceCapabilities = ( PFN_WinSpool_DeviceCapabilities ) GetProcAddress ( "DeviceCapabilitiesA" ) ;
		m_pfnDocumentProperties = ( PFN_WinSpool_DocumentProperties ) GetProcAddress ( "DocumentPropertiesA" ) ;
		m_pfnEnumJobs           = ( PFN_WinSpool_EnumJobs )           GetProcAddress ( "EnumJobsA" ) ;
		m_pfnEnumPrinterDrivers = ( PFN_WinSpool_EnumPrinterDrivers ) GetProcAddress ( "EnumPrinterDriversA" ) ;
		m_pfnEnumPrinters       = ( PFN_WinSpool_EnumPrinters )       GetProcAddress ( "EnumPrintersA" ) ;
		m_pfnEnumPorts          = ( PFN_WinSpool_EnumPorts )          GetProcAddress ( "EnumPortsA" ) ;
		m_pfnGetJob             = ( PFN_WinSpool_GetJob )             GetProcAddress ( "GetJobA" ) ;
		m_pfnGetPrinter         = ( PFN_WinSpool_GetPrinter )         GetProcAddress ( "GetPrinterA" ) ;
		m_pfnGetPrinterDriver   = ( PFN_WinSpool_GetPrinterDriver )   GetProcAddress ( "GetPrinterDriverA" ) ;
		m_pfnSetPrinter         = ( PFN_WinSpool_SetPrinter )         GetProcAddress ( "SetPrinterA" ) ;
		m_pfnOpenPrinter        = ( PFN_WinSpool_OpenPrinter )        GetProcAddress ( "OpenPrinterA" ) ;
		m_pfnSetJob	            = ( PFN_WinSpool_SetJob )             GetProcAddress ( "SetJobA" );
		m_pfnDeletePrinter	    = ( PFN_WinSpool_DeletePrinter )      GetProcAddress ( "DeletePrinter" );
#endif
    }

    // We require these function for all versions of this dll.

#if NTONLY == 5

   if ( m_pfnClosePrinter == NULL ||
	    m_pfnDeviceCapabilities == NULL ||
	    m_pfnDocumentProperties == NULL ||
	    m_pfnEnumJobs == NULL ||
	    m_pfnEnumPrinterDrivers == NULL ||
	    m_pfnEnumPrinters == NULL ||
		m_pfnEnumPorts == NULL ||
	    m_pfnGetJob == NULL ||
	    m_pfnGetPrinter == NULL ||
		m_pfnGetPrinterDriver == NULL ||
		m_pfnSetPrinter == NULL ||
	    m_pfnOpenPrinter == NULL ||
		m_pfnGetDefaultPrinter == NULL ||
		m_pfnSetJob	== NULL ||
		m_pfnDeletePrinter == NULL ||
		m_pfnSetDefaultPrinter == NULL ||
        m_pfnXcvData == NULL ||
        m_pfnAddPrinterConnection == NULL||
        m_pfnDeletePrinterConnection == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in winspoolapi");
	}

#else
	if ( m_pfnClosePrinter == NULL ||
	    m_pfnDeviceCapabilities == NULL ||
	    m_pfnDocumentProperties == NULL ||
	    m_pfnEnumJobs == NULL ||
	    m_pfnEnumPrinterDrivers == NULL ||
	    m_pfnEnumPrinters == NULL ||
	    m_pfnEnumPorts == NULL ||
	    m_pfnGetJob == NULL ||
	    m_pfnGetPrinter == NULL ||
	    m_pfnGetPrinterDriver == NULL ||
		m_pfnSetPrinter == NULL ||
	    m_pfnOpenPrinter == NULL ||
		m_pfnSetJob == NULL ||
		m_pfnDeletePrinter == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in winspoolapi");
	}
#endif

    return fRet;
}

/******************************************************************************
 * Member functions wrapping WinSpool api functions. Add new functions here
 * as required.
 *****************************************************************************/

BOOL CWinSpoolApi :: ClosePrinter (

	IN HANDLE hPrinter
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnClosePrinter ( hPrinter ) ;
}

#ifdef UNICODE
int CWinSpoolApi :: DeviceCapabilities (

	IN LPCWSTR pDevice ,
	IN LPCWSTR pPort,
	IN WORD fwCapability ,
	OUT LPWSTR pOutput ,
	IN CONST DEVMODEW *pDevMode
)
#else
int CWinSpoolApi :: DeviceCapabilities	(

	IN LPCSTR pDevice ,
	IN LPCSTR pPort,
	IN WORD fwCapability ,
	OUT LPCSTR pOutput,
	IN CONST DEVMODEA *pDevMode
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnDeviceCapabilities (
		
		pDevice ,
		pPort,
		fwCapability ,
		pOutput,
		pDevMode
	) ;
}

#ifdef UNICODE
LONG CWinSpoolApi :: DocumentProperties (

	IN HWND      hWnd,
	IN HANDLE    hPrinter,
	IN LPWSTR   pDeviceName,
	OUT PDEVMODEW pDevModeOutput,
	IN PDEVMODEW pDevModeInput,
	IN DWORD     fMode
)
#else
LONG CWinSpoolApi :: DocumentProperties (

	IN HWND      hWnd,
	IN HANDLE    hPrinter,
	IN LPSTR   pDeviceName,
	OUT PDEVMODEA pDevModeOutput,
	IN PDEVMODEA pDevModeInput,
	IN DWORD     fMode
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return 	m_pfnDocumentProperties (
		
		hWnd,
		hPrinter,
		pDeviceName,
		pDevModeOutput,
		pDevModeInput,
		fMode
	) ;
}

BOOL CWinSpoolApi :: EnumJobs (

	IN HANDLE  hPrinter,
	IN DWORD   FirstJob,
	IN DWORD   NoJobs,
	IN DWORD   Level,
	OUT LPBYTE  pJob,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumJobs (
		
		hPrinter,
		FirstJob,
		NoJobs,
		Level,
		pJob,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: EnumPrinterDrivers (

	IN LPWSTR   pName,
	IN LPWSTR   pEnvironment,
	IN DWORD   Level,
	OUT LPBYTE  pDriverInfo,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#else
BOOL CWinSpoolApi :: EnumPrinterDrivers (

	IN LPSTR   pName,
	IN LPSTR   pEnvironment,
	IN DWORD   Level,
	OUT LPBYTE  pDriverInfo,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumPrinterDrivers (
		
		pName,
		pEnvironment,
		Level,
		pDriverInfo,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: EnumPrinters (

	IN DWORD   Flags,
	IN LPWSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPrinterEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#else
BOOL CWinSpoolApi :: EnumPrinters (

	IN DWORD   Flags,
	IN LPSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPrinterEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumPrinters (

		Flags,
		Name,
		Level,
		pPrinterEnum,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: EnumPorts (

	IN LPWSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPortEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#else
BOOL CWinSpoolApi :: EnumPorts (

	IN LPSTR Name,
	IN DWORD   Level,
	OUT LPBYTE  pPortEnum,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded,
	OUT LPDWORD pcReturned
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnEnumPorts (

		Name,
		Level,
		pPortEnum,
		cbBuf,
		pcbNeeded,
		pcReturned
	) ;
}

BOOL CWinSpoolApi :: GetJob (

	IN HANDLE   hPrinter,
	IN DWORD    JobId,
	IN DWORD    Level,
	OUT LPBYTE   pJob,
	IN DWORD    cbBuf,
	OUT LPDWORD  pcbNeeded
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetJob (

		hPrinter,
		JobId,
		Level,
		pJob,
		cbBuf,
		pcbNeeded
	) ;
}

BOOL CWinSpoolApi :: SetJob (

	IN HANDLE   hPrinter,
	IN DWORD    JobId,
	IN DWORD    Level,
	IN LPBYTE   pJob,
	IN DWORD    cbBuf
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnSetJob (

		hPrinter,
		JobId,
		Level,
		pJob,
		cbBuf
	) ;
}

BOOL CWinSpoolApi :: GetPrinter (

	IN HANDLE  hPrinter,
	IN DWORD   Level,
	OUT LPBYTE  pPrinter,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetPrinter(

		hPrinter,
		Level,
		pPrinter,
		cbBuf,
		pcbNeeded
	) ;
}

BOOL CWinSpoolApi :: GetPrinterDriver (

	IN HANDLE  hPrinter,
	IN LPTSTR  pEnvironment,
	IN DWORD   Level,
	OUT LPBYTE  pPrinter,
	IN DWORD   cbBuf,
	OUT LPDWORD pcbNeeded
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetPrinterDriver(

		hPrinter,
		pEnvironment,
		Level,
		pPrinter,
		cbBuf,
		pcbNeeded
	) ;
}

BOOL CWinSpoolApi :: SetPrinter (

	IN HANDLE  hPrinter,
	IN DWORD   Level,
	IN LPBYTE  pPrinter,
	IN DWORD   cbBuf
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnSetPrinter(

		hPrinter,
		Level,
		pPrinter,
		cbBuf
	) ;
}

BOOL CWinSpoolApi :: DeletePrinter (

	IN HANDLE  hPrinter
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnDeletePrinter(

		hPrinter
	) ;
}

#ifdef UNICODE
BOOL CWinSpoolApi :: OpenPrinter (

	IN LPWSTR pPrinterName,
	OUT LPHANDLE phPrinter,
	IN LPPRINTER_DEFAULTSW pDefault
)
#else
BOOL CWinSpoolApi :: OpenPrinter (

	IN LPSTR pPrinterName,
	OUT LPHANDLE phPrinter,
	IN LPPRINTER_DEFAULTSA pDefault
)
#endif
{
	LOCK_WINSPOOL_9X ;

	return m_pfnOpenPrinter(

		pPrinterName,
		phPrinter,
		pDefault
	) ;
}

BOOL CWinSpoolApi :: GetDefaultPrinter (

    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnGetDefaultPrinter(

		pszBuffer,
		pcchBuffer
	) ;
}

BOOL CWinSpoolApi :: SetDefaultPrinter (

    IN LPTSTR   pszBuffer
)
{
	LOCK_WINSPOOL_9X ;

	return m_pfnSetDefaultPrinter(

		pszBuffer
	) ;
}

#if NTONLY >= 5
BOOL CWinSpoolApi :: XcvData (
    IN  HANDLE  hXcv,
    IN  PCWSTR  pszDataName,
    IN  PBYTE   pInputData,
    IN  DWORD   cbInputData,
    OUT PBYTE   pOutputData,
    IN  DWORD   cbOutputData,
    OUT PDWORD  pcbOutputNeeded,
    OUT PDWORD  pdwStatus
    )
{
    return m_pfnXcvData(hXcv,
                        pszDataName,
                        pInputData,
                        cbInputData,
                        pOutputData,
                        cbOutputData,
                        pcbOutputNeeded,
                        pdwStatus);
}

BOOL CWinSpoolApi :: AddPrinterConnection(
    IN LPWSTR   pszBuffer
    )
{
    return m_pfnAddPrinterConnection(pszBuffer);
}

BOOL CWinSpoolApi :: DeletePrinterConnection(
    IN LPWSTR   pszBuffer
    )
{
    return m_pfnDeletePrinterConnection(pszBuffer);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\winspoolapi.h ===
//=================================================================

//

// WinSpoolApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WinSpoolAPI_H_
#define	_WinSpoolAPI_H_

#include <winspool.h>

// Define a mutex class to single thread Winspool APIs under 9x
#ifdef WIN9XONLY

	#include <winbase.h>

	#define PRINTER_NAMED_MUTEX _T("WMI_Win_PrintSpool_Named_Mutex")

	class CPrintMutex
	{
	private:	

		HANDLE m_hHandle ;

	public:
		CPrintMutex()
		{ 
			if( m_hHandle = ::OpenMutex(MUTEX_ALL_ACCESS, TRUE, PRINTER_NAMED_MUTEX) ) 
			{
				WaitForSingleObject(m_hHandle, INFINITE);
			}
		}	
		~CPrintMutex() 
		{ 
			if( m_hHandle )
			{
				::ReleaseMutex( m_hHandle ) ;
			}
		}
  	};

	#define LOCK_WINSPOOL_9X CPrintMutex t_oWinSpool_abcdefg
#else
	#define LOCK_WINSPOOL_9X
#endif



/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWinSpoolApi;
extern const TCHAR g_tstrWinSpool[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef BOOL (WINAPI *PFN_WinSpool_AddPrinterConnection)
(
	IN LPWSTR pName
);

typedef BOOL (WINAPI *PFN_WinSpool_DeletePrinterConnection)
(
	IN LPWSTR pName
);


typedef BOOL (WINAPI *PFN_WinSpool_ClosePrinter)
(
	IN HANDLE hPrinter
);

#ifdef UNICODE
typedef int ( WINAPI *PFN_WinSpool_DeviceCapabilities )
(
	IN LPCWSTR, 
	IN LPCWSTR, 
	IN WORD,
    OUT LPWSTR, 
	IN CONST DEVMODEW *
);
#else
typedef int ( WINAPI *PFN_WinSpool_DeviceCapabilities)
(
	IN LPCSTR, 
	IN LPCSTR, 
	IN WORD,
    OUT LPCSTR, 
	IN CONST DEVMODEA *
);
#endif

#ifdef UNICODE
typedef LONG ( WINAPI *PFN_WinSpool_DocumentProperties )
(
    IN HWND      hWnd,
    IN HANDLE    hPrinter,
    IN LPWSTR   pDeviceName,
    OUT PDEVMODEW pDevModeOutput,
    IN PDEVMODEW pDevModeInput,
    IN DWORD     fMode
);
#else
typedef LONG ( WINAPI *PFN_WinSpool_DocumentProperties )
(
    IN HWND      hWnd,
    IN HANDLE    hPrinter,
    IN LPSTR   pDeviceName,
    OUT PDEVMODEA pDevModeOutput,
    IN PDEVMODEA pDevModeInput,
    IN DWORD     fMode
);
#endif

typedef BOOL ( WINAPI *PFN_WinSpool_EnumJobs )
(
    IN HANDLE  hPrinter,
    IN DWORD   FirstJob,
    IN DWORD   NoJobs,
    IN DWORD   Level,
    OUT LPBYTE  pJob,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinterDrivers )
(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pDriverInfo,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinterDrivers )
(
    IN LPSTR   pName,
    IN LPSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pDriverInfo,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#endif

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinters )
(
    IN DWORD   Flags,
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPrinters )
(
    IN DWORD   Flags,
    IN LPSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#endif

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPorts )
(
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPortEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_EnumPorts )
(
    IN LPSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPortEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#endif

typedef BOOL ( WINAPI *PFN_WinSpool_GetJob )
(
   IN HANDLE   hPrinter,
   IN DWORD    JobId,
   IN DWORD    Level,
   OUT LPBYTE   pJob,
   IN DWORD    cbBuf,
   OUT LPDWORD  pcbNeeded
);

typedef BOOL ( WINAPI *PFN_WinSpool_SetJob )
(
   IN HANDLE   hPrinter,
   IN DWORD    JobId,
   IN DWORD    Level,
   IN LPBYTE   pJob,
   IN DWORD    cbBuf
);

typedef BOOL ( WINAPI *PFN_WinSpool_GetPrinter )
(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    OUT LPBYTE  pPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
);

typedef BOOL ( WINAPI *PFN_WinSpool_GetPrinterDriver )
(
    IN HANDLE  hPrinter,
	IN LPTSTR  pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
);

typedef BOOL ( WINAPI *PFN_WinSpool_SetPrinter )
(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    IN LPBYTE  pPrinter,
    IN DWORD   cbBuf
);

typedef BOOL ( WINAPI *PFN_WinSpool_DeletePrinter )
(
    IN HANDLE  hPrinter
);

#ifdef UNICODE
typedef BOOL ( WINAPI *PFN_WinSpool_OpenPrinter )
(
   IN LPWSTR    pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSW pDefault
);
#else
typedef BOOL ( WINAPI *PFN_WinSpool_OpenPrinter )
(
   IN LPSTR		pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSA pDefault
);
#endif

typedef BOOL ( WINAPI *PFN_WinSpool_GetDefaultPrinter )
(
    IN LPTSTR   pszBuffer,
    IN LPDWORD  pcchBuffer
) ;

typedef BOOL ( WINAPI *PFN_WinSpool_SetDefaultPrinter )
(
    IN LPTSTR   pszBuffer
) ;

#ifdef UNICODE
#if NTONLY == 5
typedef BOOL ( WINAPI *PFN_WinSpool_XcvData )
(  
    IN  HANDLE  hXcv,
    IN  PCWSTR  pszDataName,
    IN  PBYTE   pInputData,
    IN  DWORD   cbInputData,
    OUT PBYTE   pOutputData,
    IN  DWORD   cbOutputData,
    OUT PDWORD  pcbOutputNeeded,
    OUT PDWORD  pdwStatus
);
#endif
#endif

/******************************************************************************
 * Wrapper class for WinSpool load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CWinSpoolApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to WinSpool functions.
    // Add new functions here as required.

	PFN_WinSpool_ClosePrinter       m_pfnClosePrinter;
	PFN_WinSpool_DeviceCapabilities m_pfnDeviceCapabilities;
	PFN_WinSpool_DocumentProperties m_pfnDocumentProperties;
	PFN_WinSpool_EnumJobs           m_pfnEnumJobs;
	PFN_WinSpool_EnumPrinterDrivers m_pfnEnumPrinterDrivers;
	PFN_WinSpool_EnumPrinters       m_pfnEnumPrinters; 
	PFN_WinSpool_EnumPorts          m_pfnEnumPorts; 
	PFN_WinSpool_GetJob             m_pfnGetJob;
	PFN_WinSpool_GetPrinter         m_pfnGetPrinter;
	PFN_WinSpool_GetPrinterDriver   m_pfnGetPrinterDriver;
	PFN_WinSpool_SetPrinter         m_pfnSetPrinter;
	PFN_WinSpool_OpenPrinter        m_pfnOpenPrinter;
	PFN_WinSpool_GetDefaultPrinter  m_pfnGetDefaultPrinter;
	PFN_WinSpool_SetJob             m_pfnSetJob;
	PFN_WinSpool_DeletePrinter      m_pfnDeletePrinter;
    PFN_WinSpool_SetDefaultPrinter  m_pfnSetDefaultPrinter;
    
    #ifdef UNICODE
    #if NTONLY == 5
    PFN_WinSpool_XcvData                 m_pfnXcvData;
    #endif
    PFN_WinSpool_AddPrinterConnection    m_pfnAddPrinterConnection;
    PFN_WinSpool_DeletePrinterConnection m_pfnDeletePrinterConnection;
    #endif

	HANDLE m_hPrintMutex;

public:

    // Constructor and destructor:
    CWinSpoolApi(LPCTSTR a_tstrWrappedDllName);
    ~CWinSpoolApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping WinSpool functions.
    // Add new functions here as required:

	BOOL ClosePrinter (

		IN HANDLE hPrinter
	);

#ifdef UNICODE
	int DeviceCapabilities (

		IN LPCWSTR pDevice , 
		IN LPCWSTR pPort, 
		IN WORD fwCapability ,
		OUT LPWSTR pOutput , 
		IN CONST DEVMODEW *pDevMode
	);
#else
	int DeviceCapabilities	(

		IN LPCSTR pDevice , 
		IN LPCSTR pPort, 
		IN WORD fwCapability ,
		OUT LPCSTR pOutput, 
		IN CONST DEVMODEA *pDevMode
	);
#endif

#ifdef UNICODE
	LONG DocumentProperties (

		IN HWND      hWnd,
		IN HANDLE    hPrinter,
		IN LPWSTR   pDeviceName,
		OUT PDEVMODEW pDevModeOutput,
		IN PDEVMODEW pDevModeInput,
		IN DWORD     fMode
	);
#else
	LONG DocumentProperties (

		IN HWND      hWnd,
		IN HANDLE    hPrinter,
		IN LPSTR   pDeviceName,
		OUT PDEVMODEA pDevModeOutput,
		IN PDEVMODEA pDevModeInput,
		IN DWORD     fMode
	);
#endif

	BOOL EnumJobs (

		IN HANDLE  hPrinter,
		IN DWORD   FirstJob,
		IN DWORD   NoJobs,
		IN DWORD   Level,
		OUT LPBYTE  pJob,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);

#ifdef UNICODE
	BOOL EnumPrinterDrivers (

		IN LPWSTR   pName,
		IN LPWSTR   pEnvironment,
		IN DWORD   Level,
		OUT LPBYTE  pDriverInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#else
	BOOL EnumPrinterDrivers (

		IN LPSTR   pName,
		IN LPSTR   pEnvironment,
		IN DWORD   Level,
		OUT LPBYTE  pDriverInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#endif

#ifdef UNICODE
	BOOL EnumPrinters (

		IN DWORD   Flags,
		IN LPWSTR Name,
		IN DWORD   Level,
		OUT LPBYTE  pPrinterEnum,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#else
	BOOL EnumPrinters (

		IN DWORD   Flags,
		IN LPSTR Name,
		IN DWORD   Level,
		OUT LPBYTE  pPrinterEnum,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#endif

#ifdef UNICODE
	BOOL EnumPorts (

		IN LPWSTR   pName,
		IN DWORD   Level,
		OUT LPBYTE  pPortInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#else
	BOOL EnumPorts (

		IN LPSTR   pName,
		IN DWORD   Level,
		OUT LPBYTE  pPortInfo,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded,
		OUT LPDWORD pcReturned
	);
#endif

	BOOL GetJob (

		IN HANDLE   hPrinter,
		IN DWORD    JobId,
		IN DWORD    Level,
		OUT LPBYTE   pJob,
		IN DWORD    cbBuf,
		OUT LPDWORD  pcbNeeded
	);

	BOOL SetJob (

		IN HANDLE   hPrinter,
		IN DWORD    JobId,
		IN DWORD    Level,
		IN LPBYTE   pJob,
		IN DWORD    cbBuf
	);


	BOOL GetPrinter (

		IN HANDLE  hPrinter,
		IN DWORD   Level,
		OUT LPBYTE  pPrinter,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded
	);

	BOOL GetPrinterDriver (

		IN HANDLE  hPrinter,
		IN LPTSTR  pEnvironment,
		IN DWORD   Level,
		OUT LPBYTE  pPrinter,
		IN DWORD   cbBuf,
		OUT LPDWORD pcbNeeded
	);


	BOOL SetPrinter (

		IN HANDLE  hPrinter,
		IN DWORD   Level,
		IN LPBYTE  pPrinter,
		IN DWORD   cbBuf
	);

	BOOL DeletePrinter (

		IN HANDLE  hPrinter
	);

    BOOL XcvDataW(
        IN  HANDLE  hXcv,
        IN  PCWSTR  pszDataName,
        IN  PBYTE   pInputData,
        IN  DWORD   cbInputData,
        OUT PBYTE   pOutputData,
        IN  DWORD   cbOutputData,
        OUT PDWORD  pcbOutputNeeded,
        OUT PDWORD  pdwStatus
    );

#ifdef UNICODE
	BOOL OpenPrinter (

		IN LPWSTR pPrinterName,
		OUT LPHANDLE phPrinter,
		IN LPPRINTER_DEFAULTSW pDefault
	);
#else
	BOOL OpenPrinter (

		IN LPSTR pPrinterName,
		OUT LPHANDLE phPrinter,
		IN LPPRINTER_DEFAULTSA pDefault
	);
#endif

   BOOL GetDefaultPrinter (

	    IN LPTSTR   pszBuffer,
	    IN LPDWORD  pcchBuffer
    );

	BOOL SetDefaultPrinter (

	    IN LPTSTR   pszBuffer
    );

#if NTONLY >= 5

    BOOL AddPrinterConnection(

        IN LPTSTR pName

    );

    BOOL DeletePrinterConnection(

        IN LPTSTR pName

    );
#endif

};

class SmartClosePrinter
{
private:

	HANDLE m_h;

public:

	SmartClosePrinter () : m_h ( INVALID_HANDLE_VALUE ) {}
	SmartClosePrinter ( HANDLE h ) : m_h ( h ) {}

	~SmartClosePrinter()
	{
		if (m_h!=INVALID_HANDLE_VALUE) 
		{
			CWinSpoolApi *pWinSpoolApi = ( CWinSpoolApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidWinSpoolApi, NULL ) ;
			if ( pWinSpoolApi )
			{
				pWinSpoolApi->ClosePrinter(m_h);

				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidWinSpoolApi , pWinSpoolApi ) ;
			}
		}
	}

	HANDLE operator =(HANDLE h) 
	{
		if (m_h!=INVALID_HANDLE_VALUE) 
		{
			CWinSpoolApi *pWinSpoolApi = ( CWinSpoolApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidWinSpoolApi, NULL ) ;
			if ( pWinSpoolApi )
			{
				pWinSpoolApi->ClosePrinter(m_h); 

				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidWinSpoolApi , pWinSpoolApi ) ;
			}
		}

		m_h=h; 

		return h;
	}

	operator HANDLE() const {return m_h;}
	HANDLE* operator &()
	{
		if (m_h!=INVALID_HANDLE_VALUE) 
		{
			CWinSpoolApi *pWinSpoolApi = ( CWinSpoolApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidWinSpoolApi, NULL ) ;
			if ( pWinSpoolApi )
			{
				pWinSpoolApi->ClosePrinter(m_h); 

				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidWinSpoolApi , pWinSpoolApi ) ;
			}
		}

		m_h = INVALID_HANDLE_VALUE; 

		return &m_h;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wmiapi.cpp ===
//=================================================================

//

// WmiApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include <assertbreak.h>
#include "WmiApi.h"
#include "DllWrapperCreatorReg.h"


// {DD3B4892-CD0F-11d2-911E-0060081A46FD}
static const GUID g_guidWmiApi =
{0xdd3b4892, 0xcd0f, 0x11d2, {0x91, 0x1e, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrWmi[] = _T("WMI.DLL");



/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWmiApi, &g_guidWmiApi, g_tstrWmi> MyRegisteredWmiWrapper;



/******************************************************************************
 * Constructor
 ******************************************************************************/
CWmiApi::CWmiApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnWmiQueryAllData(NULL),
   m_pfnWmiOpenBlock(NULL),
   m_pfnWmiCloseBlock(NULL),
   m_pfnWmiQuerySingleInstance(NULL),
   m_pfnWmiSetSingleItem(NULL),
   m_pfnWmiSetSingleInstance(NULL),
   m_pfnWmiExecuteMethod(NULL),
   m_pfnWmiNotificationRegistraton(NULL),
   m_pfnWmiFreeBuffer(NULL),
   m_pfnWmiEnumerateGuids(NULL),
   m_pfnWmiMofEnumerateResources(NULL),
   m_pfnWmiFileHandleToInstanceName(NULL),
   m_pfnWmiDevInstToInstanceName(NULL),
   m_pfnWmiQueryGuidInformation(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CWmiApi::~CWmiApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CWmiApi::Init()
{
    bool fRet = LoadLibrary();

    if(fRet)
    {

#ifdef NTONLY

        m_pfnWmiQueryAllData = (PFN_WMI_QUERY_ALL_DATA)
                                            GetProcAddress("WmiQueryAllDataW");

        m_pfnWmiQuerySingleInstance = (PFN_WMI_QUERY_SINGLE_INSTANCE)
                                     GetProcAddress("WmiQuerySingleInstanceW");

        m_pfnWmiSetSingleItem = (PFN_WMI_SET_SINGLE_ITEM)
                                           GetProcAddress("WmiSetSingleItemW");

        m_pfnWmiSetSingleInstance = (PFN_WMI_SET_SINGLE_INSTANCE)
                                       GetProcAddress("WmiSetSingleInstanceW");

        m_pfnWmiExecuteMethod = (PFN_WMI_EXECUTE_METHOD)
                                           GetProcAddress("WmiExecuteMethodW");

        m_pfnWmiNotificationRegistraton = (PFN_WMI_NOTIFICATION_REGRISTRATION)
                                GetProcAddress("WmiNotificationRegistrationW");

        m_pfnWmiMofEnumerateResources = (PFN_WMI_MOF_ENUMERATE_RESOURCES)
                                   GetProcAddress("WmiMofEnumerateResourcesW");

        m_pfnWmiFileHandleToInstanceName = (PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME)
                                GetProcAddress("WmiFileHandleToInstanceNameW");

        m_pfnWmiDevInstToInstanceName = (PFN_WMI_DEV_INST_TO_INSTANCE_NAME)
                                   GetProcAddress("WmiDevInstToInstanceNameW");

        m_pfnWmiQueryGuidInformation = (PFN_WMI_QUERY_GUID_INFORMATION)
                                     GetProcAddress("WmiQueryGuidInformation");

        fRet = (m_pfnWmiQueryAllData != NULL) &&
               (m_pfnWmiQuerySingleInstance != NULL) &&
               (m_pfnWmiSetSingleItem != NULL) &&
               (m_pfnWmiSetSingleInstance != NULL) &&
               (m_pfnWmiExecuteMethod != NULL) &&
               (m_pfnWmiNotificationRegistraton != NULL) &&
               (m_pfnWmiMofEnumerateResources != NULL) &&
               (m_pfnWmiFileHandleToInstanceName != NULL) &&
               (m_pfnWmiDevInstToInstanceName != NULL) &&
               (m_pfnWmiQueryGuidInformation != NULL);


#endif

#ifdef WIN9XONLY

        m_pfnWmiQueryAllData = (PFN_WMI_QUERY_ALL_DATA)
                                            GetProcAddress("WmiQueryAllDataA");

        m_pfnWmiQuerySingleInstance = (PFN_WMI_QUERY_SINGLE_INSTANCE)
                                     GetProcAddress("WmiQuerySingleInstanceA");

        m_pfnWmiSetSingleItem = (PFN_WMI_SET_SINGLE_ITEM)
                                           GetProcAddress("WmiSetSingleItemA");

        m_pfnWmiSetSingleInstance = (PFN_WMI_SET_SINGLE_INSTANCE)
                                       GetProcAddress("WmiSetSingleInstanceA");

        m_pfnWmiExecuteMethod = (PFN_WMI_EXECUTE_METHOD)
                                           GetProcAddress("WmiExecuteMethodA");

        m_pfnWmiNotificationRegistraton = (PFN_WMI_NOTIFICATION_REGRISTRATION)
                                GetProcAddress("WmiNotificationRegistrationA");

        m_pfnWmiMofEnumerateResources = (PFN_WMI_MOF_ENUMERATE_RESOURCES)
                                   GetProcAddress("WmiMofEnumerateResourcesA");

        m_pfnWmiFileHandleToInstanceName = (PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME)
                                GetProcAddress("WmiFileHandleToInstanceNameA");

        fRet = (m_pfnWmiQueryAllData != NULL) &&
               (m_pfnWmiQuerySingleInstance != NULL) &&
               (m_pfnWmiSetSingleItem != NULL) &&
               (m_pfnWmiSetSingleInstance != NULL) &&
               (m_pfnWmiExecuteMethod != NULL) &&
               (m_pfnWmiNotificationRegistraton != NULL) &&
               (m_pfnWmiMofEnumerateResources != NULL) &&
               (m_pfnWmiFileHandleToInstanceName != NULL);

#endif

        m_pfnWmiOpenBlock = (PFN_WMI_OPEN_BLOCK)
                                                GetProcAddress("WmiOpenBlock");

        m_pfnWmiCloseBlock = (PFN_WMI_CLOSE_BLOCK)
                                               GetProcAddress("WmiCloseBlock");

        m_pfnWmiFreeBuffer = (PNF_WMI_FREE_BUFFER)
                                               GetProcAddress("WmiFreeBuffer");

        m_pfnWmiEnumerateGuids = (PFN_WMI_ENUMERATE_GUIDS)
                                           GetProcAddress("WmiEnumerateGuids");

        fRet = fRet &&
               (m_pfnWmiOpenBlock != NULL) &&
               (m_pfnWmiCloseBlock != NULL) &&
               (m_pfnWmiFreeBuffer != NULL) &&
               (m_pfnWmiEnumerateGuids != NULL);

        if (!fRet)
        {
            LogErrorMessage(L"Failed find entrypoint in wmiapi");
        }
    }

    return fRet;
}



/******************************************************************************
 * Member functions wrapping Wmi api functions. Add new functions here
 * as required.
 ******************************************************************************/
ULONG CWmiApi::WmiQueryAllData
(
    IN WMIHANDLE a_h,
    IN OUT ULONG* a_ul,
    OUT PVOID a_pv
)
{
    return m_pfnWmiQueryAllData(a_h, a_ul, a_pv);
}

ULONG CWmiApi::WmiOpenBlock
(
    IN GUID* a_pguid,
    IN ULONG a_ul,
    OUT WMIHANDLE a_wmih
)
{
    return m_pfnWmiOpenBlock(a_pguid, a_ul, a_wmih);
}

ULONG CWmiApi::WmiCloseBlock
(
    IN WMIHANDLE a_wmih
)
{
    return m_pfnWmiCloseBlock(a_wmih);
}

ULONG CWmiApi::WmiQuerySingleInstance
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN LPCTSTR a_tstrInstanceName,
    IN OUT ULONG* a_ulBufferSize,
    OUT PVOID a_pvBuffer
)
{
    return m_pfnWmiQuerySingleInstance(a_wmihDataBlockHandle,
                                       a_tstrInstanceName,
                                       a_ulBufferSize,
                                       a_pvBuffer);
}

ULONG CWmiApi::WmiSetSingleItem
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN LPCTSTR a_tstrInstanceName,
    IN ULONG a_ulDataItemId,
    IN ULONG a_ulReserved,
    IN ULONG a_ulValueBufferSize,
    IN PVOID a_pvValueBuffer
)
{
    return m_pfnWmiSetSingleItem(a_wmihDataBlockHandle,
                                 a_tstrInstanceName,
                                 a_ulDataItemId,
                                 a_ulReserved,
                                 a_ulValueBufferSize,
                                 a_pvValueBuffer);
}

ULONG CWmiApi::WmiSetSingleInstance
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN LPCTSTR a_tstrInstanceName,
    IN ULONG a_ulReserved,
    IN ULONG a_ulValueBufferSize,
    IN PVOID a_pvValueBuffer
)
{
    return m_pfnWmiSetSingleInstance(a_wmihDataBlockHandle,
                                     a_tstrInstanceName,
                                     a_ulReserved,
                                     a_ulValueBufferSize,
                                     a_pvValueBuffer);
}

ULONG CWmiApi::WmiExecuteMethod
(
    IN WMIHANDLE a_wmihMethodDataBlockHandle,
    IN LPCTSTR a_tstrMethodInstanceName,
    IN ULONG a_ulMethodId,
    IN ULONG a_ulInputValueBufferSize,
    IN PVOID a_pvInputValueBuffer,
    IN OUT ULONG* a_ulOutputBufferSize,
    OUT PVOID a_pvOutputBuffer
)
{
    return m_pfnWmiExecuteMethod(a_wmihMethodDataBlockHandle,
                                 a_tstrMethodInstanceName,
                                 a_ulMethodId,
                                 a_ulInputValueBufferSize,
                                 a_pvInputValueBuffer,
                                 a_ulOutputBufferSize,
                                 a_pvOutputBuffer);
}

ULONG CWmiApi::WmiNotificationRegistration
(
    IN LPGUID a_pguidGuid,
    IN BOOLEAN a_blnEnable,
    IN PVOID a_pvDeliveryInfo,
    IN ULONG_PTR a_pulDeliveryContext,
    IN ULONG a_ulFlags
)
{
    return m_pfnWmiNotificationRegistraton(a_pguidGuid,
                                           a_blnEnable,
                                           a_pvDeliveryInfo,
                                           a_pulDeliveryContext,
                                           a_ulFlags);
}

ULONG CWmiApi::WmiMofEnumerateResources
(
    IN MOFHANDLE a_MofResourceHandle,
    OUT ULONG* a_pulMofResourceCount,
    OUT PMOFRESOURCEINFO* a_MofResourceInfo
)
{
    return m_pfnWmiMofEnumerateResources(a_MofResourceHandle,
                                         a_pulMofResourceCount,
                                         a_MofResourceInfo);
}

ULONG CWmiApi::WmiFileHandleToInstanceName
(
    IN WMIHANDLE a_wmihDataBlockHandle,
    IN HANDLE a_hFileHandle,
    IN OUT ULONG* a_pulNumberCharacters,
    OUT TCHAR* a_tcInstanceNames
)
{
    return m_pfnWmiFileHandleToInstanceName(a_wmihDataBlockHandle,
                                            a_hFileHandle,
                                            a_pulNumberCharacters,
                                            a_tcInstanceNames);
}

ULONG CWmiApi::WmiDevInstToInstanceName
(
    OUT TCHAR* a_ptcInstanceName,
    IN ULONG a_ulInstanceNameLength,
    IN TCHAR* a_tcDevInst,
    IN ULONG a_ulInstanceIndex
)
{
    ASSERT_BREAK(m_pfnWmiDevInstToInstanceName);

    if (m_pfnWmiDevInstToInstanceName)
        return m_pfnWmiDevInstToInstanceName(a_ptcInstanceName,
                                             a_ulInstanceNameLength,
                                             a_tcDevInst,
                                             a_ulInstanceIndex);

    return 0xffffffff;
}

void CWmiApi::WmiFreeBuffer
(
    IN PVOID a_pvBuffer
)
{
    m_pfnWmiFreeBuffer(a_pvBuffer);
}

ULONG CWmiApi::WmiEnumerateGuids
(
    OUT LPGUID a_lpguidGuidList,
    IN OUT ULONG* a_pulGuidCount
)
{
    return m_pfnWmiEnumerateGuids(a_lpguidGuidList,
                                  a_pulGuidCount);
}

ULONG CWmiApi::WmiQueryGuidInformation
(
    IN WMIHANDLE a_wmihGuidHandle,
    OUT PWMIGUIDINFORMATION a_GuidInfo
)
{
    ASSERT_BREAK(m_pfnWmiQueryGuidInformation);

    if (m_pfnWmiQueryGuidInformation)
        return m_pfnWmiQueryGuidInformation(a_wmihGuidHandle,
                                            a_GuidInfo);
    return 0xffffffff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wmiapi.h ===
//=================================================================

//

// WmiApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WMIAPI_H_
#define	_WMIAPI_H_

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "DllWrapperBase.h"
#include "wmium.h"
#include "wbemcli.h"



/******************************************************************************
 * Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWmiApi;
extern const TCHAR g_tstrWmi[];



/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef ULONG (WINAPI* PFN_WMI_QUERY_ALL_DATA)
(
    IN WMIHANDLE, 
    IN OUT ULONG*, 
    OUT PVOID
);

typedef ULONG (WINAPI* PFN_WMI_QUERY_SINGLE_INSTANCE)
(
    IN WMIHANDLE DataBlockHandle,
    IN LPCTSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
);

typedef ULONG (WINAPI* PFN_WMI_SET_SINGLE_ITEM)
(
    IN WMIHANDLE DataBlockHandle,
    IN LPCTSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
);

typedef ULONG (WINAPI* PFN_WMI_SET_SINGLE_INSTANCE)
(
    IN WMIHANDLE DataBlockHandle,
    IN LPCTSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
);

typedef ULONG (WINAPI* PFN_WMI_EXECUTE_METHOD)
(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCTSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
);

typedef ULONG (WINAPI* PFN_WMI_NOTIFICATION_REGRISTRATION)
(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
);

typedef ULONG (WINAPI* PFN_WMI_MOF_ENUMERATE_RESOURCES)
(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFO *MofResourceInfo
);

typedef ULONG (WINAPI* PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME)
(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT TCHAR *InstanceNames
);

typedef ULONG (WINAPI* PFN_WMI_DEV_INST_TO_INSTANCE_NAME)
(
    OUT TCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN TCHAR *DevInst,
    IN ULONG InstanceIndex
);

typedef	ULONG (WINAPI* PFN_WMI_OPEN_BLOCK)
(
    IN GUID*, 
    IN ULONG, 
    OUT WMIHANDLE
);

typedef ULONG (WINAPI* PFN_WMI_CLOSE_BLOCK)
(
    IN WMIHANDLE
);

typedef void (WINAPI* PNF_WMI_FREE_BUFFER)
(
    IN PVOID Buffer
);

typedef ULONG (WINAPI* PFN_WMI_ENUMERATE_GUIDS)
(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
);

typedef ULONG (WINAPI* PFN_WMI_QUERY_GUID_INFORMATION)
(
    IN WMIHANDLE GuidHandle, 
    OUT PWMIGUIDINFORMATION GuidInfo
);




/******************************************************************************
 * Wrapper class for Wmi load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CWmiApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Wmi functions.
    // Add new functions here as required.
    PFN_WMI_QUERY_ALL_DATA m_pfnWmiQueryAllData;
    PFN_WMI_OPEN_BLOCK m_pfnWmiOpenBlock;
    PFN_WMI_CLOSE_BLOCK m_pfnWmiCloseBlock;
    PFN_WMI_QUERY_SINGLE_INSTANCE m_pfnWmiQuerySingleInstance;
    PFN_WMI_SET_SINGLE_ITEM m_pfnWmiSetSingleItem;
    PFN_WMI_SET_SINGLE_INSTANCE m_pfnWmiSetSingleInstance;
    PFN_WMI_EXECUTE_METHOD m_pfnWmiExecuteMethod;
    PFN_WMI_NOTIFICATION_REGRISTRATION m_pfnWmiNotificationRegistraton;
    PNF_WMI_FREE_BUFFER m_pfnWmiFreeBuffer;
    PFN_WMI_ENUMERATE_GUIDS m_pfnWmiEnumerateGuids;
    PFN_WMI_MOF_ENUMERATE_RESOURCES m_pfnWmiMofEnumerateResources;
    PFN_WMI_FILE_HANDLE_TO_INSTANCE_NAME m_pfnWmiFileHandleToInstanceName;
    PFN_WMI_DEV_INST_TO_INSTANCE_NAME m_pfnWmiDevInstToInstanceName;
    PFN_WMI_QUERY_GUID_INFORMATION m_pfnWmiQueryGuidInformation;


public:

    // Constructor and destructor:
    CWmiApi(LPCTSTR a_tstrWrappedDllName);
    ~CWmiApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Wmi functions.
    // Add new functions here as required:
    ULONG WmiQueryAllData
    (
        IN WMIHANDLE, 
        IN OUT ULONG*, 
        OUT PVOID
    );

    ULONG WmiOpenBlock
    (
        IN GUID*, 
        IN ULONG, 
        OUT WMIHANDLE
    );

    ULONG WmiCloseBlock
    (
        IN WMIHANDLE
    );

    ULONG WmiQuerySingleInstance
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN OUT ULONG*,
        OUT PVOID
    );

    ULONG WmiSetSingleItem
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN ULONG,
        IN ULONG,
        IN ULONG,
        IN PVOID 
    );

    ULONG WmiSetSingleInstance
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN ULONG,
        IN ULONG,
        IN PVOID 
    );

    ULONG WmiExecuteMethod
    (
        IN WMIHANDLE,
        IN LPCTSTR,
        IN ULONG,
        IN ULONG,
        IN PVOID,
        IN OUT ULONG*,
        OUT PVOID
    );

    ULONG WmiNotificationRegistration
    (
        IN LPGUID,
        IN BOOLEAN,
        IN PVOID,
        IN ULONG_PTR,
        IN ULONG
    );

    ULONG WmiMofEnumerateResources
    (
        IN MOFHANDLE,
        OUT ULONG*,
        OUT PMOFRESOURCEINFO*
    );

    ULONG WmiFileHandleToInstanceName
    (
        IN WMIHANDLE,
        IN HANDLE,
        IN OUT ULONG*,
        OUT TCHAR*
    );

    ULONG WmiDevInstToInstanceName
    (
        OUT TCHAR*,
        IN ULONG,
        IN TCHAR*,
        IN ULONG
    );

    void WmiFreeBuffer
    (
        IN PVOID
    );

    ULONG WmiEnumerateGuids
    (
        OUT LPGUID,
        IN OUT ULONG*
    );

    ULONG WmiQueryGuidInformation
    (
        IN WMIHANDLE, 
        OUT PWMIGUIDINFORMATION
    );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wmi_fileprivateprofile.h ===
/*****************************************************************************/
/*
/*  Copyright (c) 2001 Microsoft Corporation, All Rights Reserved            /
/*
/*****************************************************************************/

#ifndef __WMI_FilePrivateProfile_H__
#define __WMI_FilePrivateProfile_H__

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        );

UINT
APIENTRY
WMI_FILE_GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     );

BOOL
APIENTRY
WMI_FILE_WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          );

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         );
BOOL
APIENTRY
WMI_FILE_WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           );





class CWMI_FILE_IniFileObject
{
public:
    ULONG m_EnvironmentUpdateCount;
    HANDLE m_FileHandle;
    BOOL m_WriteAccess;
    BOOL m_UnicodeFile;
    BOOL m_LockedFile;
    ULONG m_EndOfFile;
    PVOID m_BaseAddress;
    SIZE_T m_CommitSize;
    SIZE_T m_RegionSize;
    ULONG m_UpdateOffset;
    ULONG m_UpdateEndOffset;
    ULONG m_DirectoryInformationLength;
    FILE_STANDARD_INFORMATION m_StandardInformation;

	CWMI_FILE_IniFileObject();
	~CWMI_FILE_IniFileObject();
};

class CWMI_FILE_IniFile
{
public:

	typedef enum _INIFILE_OPERATION {
    Enum_ReadKeyValueOp,
    Enum_WriteKeyValueOp,
    Enum_ReadSectionOp,
    Enum_WriteSectionOp
	} INIFILE_OPERATION;

    INIFILE_OPERATION m_Operation;
    BOOL m_IsWriteOperation;
    CWMI_FILE_IniFileObject m_IniFile;
    LPCWSTR m_FileName;
    ANSI_STRING m_ApplicationName;
    ANSI_STRING m_VariableName;
    UNICODE_STRING m_ApplicationNameU;
    UNICODE_STRING m_VariableNameU;
    BOOL m_IsMultiValueStrings;

    LPSTR m_ValueBuffer;
    ULONG m_ValueLength;
    LPWSTR m_ValueBufferU;
    ULONG m_ValueLengthU;
    ULONG m_ResultChars;
    ULONG m_ResultMaxChars;
    LPWSTR m_ResultBufferU;

    PVOID m_TextCurrent;
    PVOID m_TextStart;
    PVOID m_TextEnd;

    ANSI_STRING m_SectionName;
    ANSI_STRING m_KeywordName;
    ANSI_STRING m_KeywordValue;
    PANSI_STRING m_AnsiSectionName;
    PANSI_STRING m_AnsiKeywordName;
    PANSI_STRING m_AnsiKeywordValue;
    UNICODE_STRING m_SectionNameU;
    UNICODE_STRING m_KeywordNameU;
    UNICODE_STRING m_KeywordValueU;
    PUNICODE_STRING m_UnicodeSectionName;
    PUNICODE_STRING m_UnicodeKeywordName;
    PUNICODE_STRING m_UnicodeKeywordValue;


	CWMI_FILE_IniFile();
	~CWMI_FILE_IniFile();

	static NTSTATUS ReadWriteIniFile(
                       IN BOOL WriteOperation,
                       IN BOOL SectionOperation,
                       IN LPCWSTR FileName,
                       IN LPCWSTR ApplicationName,
                       IN LPCWSTR VariableName,
                       IN OUT LPWSTR VariableValue,
                       IN OUT PULONG VariableValueLength
                       );

	NTSTATUS CaptureIniFileParameters(
                               INIFILE_OPERATION a_Operation,
                               BOOL a_WriteOperation,
                               BOOL a_MultiValueStrings,
                               LPCWSTR a_FileName,
                               LPCWSTR a_ApplicationName,
                               LPCWSTR a_VariableName,
                               LPWSTR a_VariableValue,
                               PULONG a_ResultMaxChars
                               );

	NTSTATUS OpenIniFileOnDisk();

	NTSTATUS ReadWriteIniFileOnDisk();

	NTSTATUS CloseIniFileOnDisk();

	NTSTATUS ReadKeywordValue();

	NTSTATUS ReadSection();

	NTSTATUS AdvanceTextPointer(
						IN ULONG StopAt
						);

	NTSTATUS FindSection();

	NTSTATUS FindKeyword();

	BOOL GetApplicationName(
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         );

	BOOL GetVariableName(
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      );

	BOOL GetVariableValue(
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT LPWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       );

	NTSTATUS  AppendStringToResultBuffer(
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOL IncludeNull
                                 );

	NTSTATUS AppendBufferToResultBuffer(
                                 IN PBYTE Buffer OPTIONAL,
                                 IN LPWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOL IncludeNull
								 );

	NTSTATUS  WriteKeywordValue(
                        IN PUNICODE_STRING VariableName OPTIONAL
                        );

	NTSTATUS ModifyMappedFile(
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       );

	NTSTATUS WriteSection();

	NTSTATUS AppendNullToResultBuffer()
	{
		return AppendBufferToResultBuffer(NULL,
												  NULL,
												  0,
												  TRUE
												);
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ws2_32api.h ===
//=================================================================

//

// Ws2_32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WS2_32API_H_
#define	_WS2_32API_H_



/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidWs2_32Api;
extern const TCHAR g_tstrWs2_32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
// Included through #include<winsock2.h>


/******************************************************************************
 * Wrapper class for Ws2_32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CWs2_32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Ws2_32 functions.
    // Add new functions here as required.
    LPFN_WSASTARTUP			m_pfnWSAStartUp;
	LPFN_WSAENUMPROTOCOLS	m_pfnWSAEnumProtocols;
	LPFN_WSAIOCTL			m_pfnWSAIoctl;
	LPFN_WSASOCKET			m_pfnWSASocket;
	LPFN_BIND				m_pfnBind;
	LPFN_CLOSESOCKET		m_pfnCloseSocket;
	LPFN_WSACLEANUP			m_pfnWSACleanup;
	LPFN_WSAGETLASTERROR	m_pfnWSAGetLastError;

public:

    // Constructor and destructor:
    CWs2_32Api(LPCTSTR a_tstrWrappedDllName);
    ~CWs2_32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Ws2_32 functions.
    // Add new functions here as required:
    int WSAStartUp
    (
        WORD a_wVersionRequested,
        LPWSADATA a_lpWSAData
    );

    int WSAEnumProtocols
    (
        LPINT a_lpiProtocols,
        LPWSAPROTOCOL_INFO a_lpProtocolBuffer,
        LPDWORD a_lpdwBufferLength
    );

    int WSAIoctl
    (
        SOCKET a_s,
        DWORD a_dwIoControlCode,
        LPVOID a_lpvInBuffer,
        DWORD a_cbInBuffer,
        LPVOID a_lpvOutBuffer,
        DWORD a_cbOutBuffer,
        LPDWORD a_lpcbBytesReturned,
        LPWSAOVERLAPPED a_lpOverlapped,
        LPWSAOVERLAPPED_COMPLETION_ROUTINE a_lpCompletionRoutine
    );

    SOCKET WSASocket
    (
        int a_af,
        int a_type,
        int a_protocol,
        LPWSAPROTOCOL_INFO a_lpProtocolInfo,
        GROUP a_g,
        DWORD a_dwFlags
    );

    int Bind
    (
        SOCKET a_s,
        const struct sockaddr FAR * a_name,
        int a_namelen
    );

    int CloseSocket
    (
        SOCKET a_s
    );

    int WSACleanup();

    int WSAGetLastError();

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wmi_fileprivateprofile.cpp ===
/*****************************************************************************/
/*
/*  Copyright (c) 2001 Microsoft Corporation, All Rights Reserved            /
/*
/*****************************************************************************/

#include "precomp.h"
#include "WMI_FilePrivateProfile.h"

#define STOP_AT_SECTION 1
#define STOP_AT_KEYWORD 2
#define STOP_AT_NONSECTION 3

#define BYTE_ORDER_MARK           0xFEFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE

ULONG LockFileKey = 1;

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = L"";
    }

    n = nSize;
    Status = CWMI_FILE_IniFile::ReadWriteIniFile(FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      lpKeyName,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = UNICODE_NULL;
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = wcslen( lpDefault );
        while (n > 0 && lpDefault[n-1] == L' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        wcsncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


UINT
APIENTRY
WMI_FILE_GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    WCHAR ValueBuffer[ 256 ];
    UNICODE_STRING Value;
    ANSI_STRING AnsiString;
    ULONG cb;

    ReturnValue = 0;
    cb = WMI_FILE_GetPrivateProfileStringW(lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ) / sizeof( WCHAR ),
                                   lpFileName
                                 );
    if (cb == 0)
	{
        ReturnValue = nDefault;
    }
	else
	{
        Value.Buffer = ValueBuffer;
        Value.Length = (USHORT)(cb * sizeof( WCHAR ));
        Value.MaximumLength = (USHORT)((cb + 1) * sizeof( WCHAR ));
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &Value,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status ))
		{
            Status = RtlCharToInteger( AnsiString.Buffer, 0, &ReturnValue );
            RtlFreeAnsiString( &AnsiString );
        }

        if (!NT_SUCCESS( Status ))
		{
            SetLastError( Status );
        }
		else
		{
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}



BOOL
APIENTRY
WMI_FILE_WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = CWMI_FILE_IniFile::ReadWriteIniFile(TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      lpKeyName,
                                      (LPWSTR)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( Status );
        }
        return( FALSE );
    }
}

DWORD
APIENTRY
WMI_FILE_GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = CWMI_FILE_IniFile::ReadWriteIniFile(FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      NULL,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = UNICODE_NULL;
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( Status );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


BOOL
APIENTRY
WMI_FILE_WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = CWMI_FILE_IniFile::ReadWriteIniFile(TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      lpFileName,
                                      lpAppName,
                                      NULL,
                                      (LPWSTR)lpString,
                                      NULL
                                    );
    if (NT_SUCCESS( Status ))
	{
        return( TRUE );
    }
	else
	{
        if (Status == STATUS_INVALID_IMAGE_FORMAT)
		{
            SetLastError( ERROR_INVALID_DATA );
        }
		else
		{
            SetLastError( Status );
        }

        return( FALSE );
    }
}



CWMI_FILE_IniFileObject::CWMI_FILE_IniFileObject()
{
    m_EnvironmentUpdateCount = 0;
    m_FileHandle = INVALID_HANDLE_VALUE;
    m_WriteAccess = FALSE;
    m_UnicodeFile = FALSE;
    m_LockedFile = FALSE;
    m_EndOfFile = 0;
    m_BaseAddress = NULL;
    m_CommitSize = 0;
    m_RegionSize = 0;
    m_UpdateOffset = 0;
    m_UpdateEndOffset = 0;
    m_DirectoryInformationLength = 0;
}

CWMI_FILE_IniFileObject::~CWMI_FILE_IniFileObject()
{
	if ((m_FileHandle != INVALID_HANDLE_VALUE) && (m_FileHandle != NULL))
	{
		NtClose(m_FileHandle);
		m_FileHandle = INVALID_HANDLE_VALUE;
	}
}


CWMI_FILE_IniFile::CWMI_FILE_IniFile()
{
    RtlInitAnsiString( &m_VariableName, NULL );
    RtlInitUnicodeString( &m_VariableNameU, NULL );
    RtlInitAnsiString( &m_ApplicationName, NULL );
    RtlInitUnicodeString( &m_ApplicationNameU, NULL );

    m_Operation = Enum_ReadKeyValueOp;
    m_IsWriteOperation = FALSE;
    m_FileName = NULL;
    m_IsMultiValueStrings = FALSE;

    m_ValueBuffer = NULL;
    m_ValueLength = 0;
    m_ValueBufferU = NULL;
    m_ValueLengthU = 0;
    m_ResultChars = 0;
    m_ResultMaxChars = 0;
    m_ResultBufferU = NULL;

    m_TextCurrent = NULL;
    m_TextStart = NULL;
    m_TextEnd = NULL;
}

CWMI_FILE_IniFile::~CWMI_FILE_IniFile()
{
    if (m_VariableName.Buffer)
	{
		delete [] m_VariableName.Buffer;
		m_VariableName.Buffer = NULL;
	}

    if (m_ApplicationName.Buffer)
	{
		delete [] m_ApplicationName.Buffer;
		m_ApplicationName.Buffer = NULL;
	}

    if (m_ValueBuffer)
	{
		delete [] m_ValueBuffer;
		m_ValueBuffer = NULL;
	}
}

NTSTATUS CWMI_FILE_IniFile::ReadWriteIniFile(
                       IN BOOL WriteOperation,
                       IN BOOL SectionOperation,
                       IN LPCWSTR FileName,
                       IN LPCWSTR ApplicationName,
                       IN LPCWSTR VariableName,
                       IN OUT LPWSTR VariableValue,
                       IN OUT PULONG VariableValueLength
                       )
{
    BOOL MultiValueStrings;
    INIFILE_OPERATION Operation;
    NTSTATUS Status;

    if (SectionOperation) {
        VariableName = NULL;
    }

    MultiValueStrings = FALSE;

    if (WriteOperation)
	{
        if (ApplicationName)
		{
            if (VariableName)
			{
                if (VariableValue)
				{
                    Operation = Enum_WriteKeyValueOp;
                }
				else
				{
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
			else
			{
                if (VariableValue)
				{
                    Operation = Enum_WriteSectionOp;
                    MultiValueStrings = TRUE;
                }
				else
				{
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }
		else
		{
			Status = STATUS_INVALID_PARAMETER;
        }
    }
	else
	{
        if (ApplicationName)
		{
            if (!ARGUMENT_PRESENT( VariableValue ))
			{
                Status = STATUS_INVALID_PARAMETER;
            }
			else
			{
                if (VariableName)
				{
					Operation = Enum_ReadKeyValueOp;
				}
				else
				{
					if (SectionOperation)
					{
						Operation = Enum_ReadSectionOp;
						MultiValueStrings = TRUE;
					}
					else
					{
						Status = STATUS_INVALID_PARAMETER;
					}
				}
			}
        }
		else
		{
            Status = STATUS_INVALID_PARAMETER;
		}
    }

	if (NT_SUCCESS( Status ))
	{
		CWMI_FILE_IniFile myIni;
		Status = myIni.CaptureIniFileParameters(Operation,
                                              WriteOperation,
                                              MultiValueStrings,
                                              FileName,
                                              ApplicationName,
                                              VariableName,
                                              VariableValue,
                                              VariableValueLength
                                            );
		if (NT_SUCCESS( Status ))
		{
			Status = myIni.ReadWriteIniFileOnDisk();

			if (NT_SUCCESS( Status ))
			{
				if (myIni.m_Operation == Enum_ReadSectionOp)
				{
					myIni.AppendNullToResultBuffer();
				}
			}

			if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW)
			{
				if (!myIni.m_IsWriteOperation)
				{
					if (ARGUMENT_PRESENT( VariableValueLength ))
					{
						*VariableValueLength = myIni.m_ResultChars;
					}
				}
			}
		}
	}

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::CaptureIniFileParameters(
                               INIFILE_OPERATION a_Operation,
                               BOOL a_WriteOperation,
                               BOOL a_MultiValueStrings,
                               LPCWSTR a_FileName,
                               LPCWSTR a_ApplicationName,
                               LPCWSTR a_VariableName,
                               LPWSTR a_VariableValue,
                               PULONG a_ResultMaxChars
                               )
{
    NTSTATUS Status = STATUS_SUCCESS;

    m_Operation = a_Operation;
    m_IsWriteOperation = a_WriteOperation;
    m_IsMultiValueStrings = a_MultiValueStrings;

    if (a_FileName)
	{
        m_FileName = a_FileName;
    }

    if (a_ApplicationName)
	{
		RtlInitUnicodeString(&m_ApplicationNameU, a_ApplicationName);
    }

    if (a_VariableName)
	{
		RtlInitUnicodeString(&m_VariableNameU, a_VariableName);
    }

	ULONG uVariableValueLength = 0;

    if (a_VariableValue )
	{
        if (!a_ResultMaxChars)
		{
            if (!a_MultiValueStrings)
			{
                uVariableValueLength = wcslen( a_VariableValue );
            }
			else
			{
                LPWSTR p = a_VariableValue;

                while (*p)
				{
                    while (*p++)
					{
                    }
                }

                uVariableValueLength = (ULONG)(p - a_VariableValue);
            }
        }

        if (m_IsWriteOperation)
		{
                m_ValueBufferU = a_VariableValue;
                m_ValueLengthU = uVariableValueLength * sizeof( WCHAR );
                m_ValueBuffer = NULL;
                m_ValueLength = 0;
        }
		else
		{
            if (a_ResultMaxChars)
			{
                m_ResultMaxChars = *a_ResultMaxChars;
            }

            m_ResultChars = 0;
            m_ResultBufferU = a_VariableValue;
        }
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::OpenIniFileOnDisk()
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING FullFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
	LARGE_INTEGER Length;

    m_IniFile.m_WriteAccess = m_IsWriteOperation;
	RtlInitUnicodeString(&FullFileName, NULL);

	if (!RtlDosPathNameToNtPathName_U( m_FileName,
                                          &FullFileName,
                                          NULL,
                                          NULL
                                        )
           )
	{
		return STATUS_OBJECT_PATH_NOT_FOUND;
	}

	try
	{
		InitializeObjectAttributes( &ObjectAttributes,
									&FullFileName,
									OBJ_CASE_INSENSITIVE,
									NULL,
									NULL
								  );
		
		if (m_IniFile.m_WriteAccess)
		{
			Status = NtCreateFile( &m_IniFile.m_FileHandle,
								   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
								   &ObjectAttributes,
								   &IoStatusBlock,
								   0,
								   FILE_ATTRIBUTE_NORMAL,
								   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
								   FILE_OPEN_IF,
								   FILE_SYNCHRONOUS_IO_NONALERT |
								   FILE_NON_DIRECTORY_FILE,
								   NULL,
								   0
								 );
		}
		else
		{
			Status = NtOpenFile( &m_IniFile.m_FileHandle,
								 SYNCHRONIZE | GENERIC_READ,
								 &ObjectAttributes,
								 &IoStatusBlock,
								 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
								 FILE_SYNCHRONOUS_IO_NONALERT |
								 FILE_NON_DIRECTORY_FILE
							   );
		}
	}
	catch(...)
	{
		RtlFreeUnicodeString(&FullFileName);
		RtlInitUnicodeString(&FullFileName, NULL);
		throw;
	}

	RtlFreeUnicodeString( &FullFileName );
	RtlInitUnicodeString(&FullFileName, NULL);


    if (NT_SUCCESS( Status ))
	{
        ByteOffset.QuadPart = 0;
        Length.QuadPart = -1;
        Status = NtLockFile( m_IniFile.m_FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             &ByteOffset,
                             &Length,
                             LockFileKey,
                             FALSE,
                             (BOOLEAN)m_IniFile.m_WriteAccess
                           );

        if (NT_SUCCESS( Status ))
		{
            m_IniFile.m_LockedFile = TRUE;
        }

        if (NT_SUCCESS( Status ))
		{
            Status = NtQueryInformationFile( m_IniFile.m_FileHandle,
                                             &IoStatusBlock,
                                             &m_IniFile.m_StandardInformation,
                                             sizeof( m_IniFile.m_StandardInformation ),
                                             FileStandardInformation
                                           );

            if (Status == STATUS_BUFFER_OVERFLOW)
			{
                Status = STATUS_SUCCESS;
            }
        }
    }

    if (!NT_SUCCESS( Status ))
	{
		if ((m_IniFile.m_FileHandle != INVALID_HANDLE_VALUE) && (m_IniFile.m_FileHandle != NULL))
		{
			if (m_IniFile.m_LockedFile)
			{
				m_IniFile.m_LockedFile = FALSE;
				ByteOffset.QuadPart = 0;
				Length.QuadPart = -1;
				NtUnlockFile( m_IniFile.m_FileHandle,
							  &IoStatusBlock,
							  &ByteOffset,
							  &Length,
							  LockFileKey
							);
			}

			NtClose( m_IniFile.m_FileHandle );
			m_IniFile.m_FileHandle = INVALID_HANDLE_VALUE;
		}

        return Status;
    }
	else
	{
		m_IniFile.m_EndOfFile = m_IniFile.m_StandardInformation.EndOfFile.LowPart;
		m_IniFile.m_CommitSize = m_IniFile.m_EndOfFile + (4 * (m_IniFile.m_UnicodeFile ? sizeof( WCHAR ) : 1));
		m_IniFile.m_RegionSize = m_IniFile.m_CommitSize + 0x100000; // Room for 256KB of growth
		Status = NtAllocateVirtualMemory( NtCurrentProcess(),
										  &m_IniFile.m_BaseAddress,
										  0,
										  &m_IniFile.m_RegionSize,
										  MEM_RESERVE,
										  PAGE_READWRITE
										);
		if (NT_SUCCESS( Status ))
		{
			Status = NtAllocateVirtualMemory( NtCurrentProcess(),
											  &m_IniFile.m_BaseAddress,
											  0,
											  &m_IniFile.m_CommitSize,
											  MEM_COMMIT,
											  PAGE_READWRITE
											);
			if (NT_SUCCESS( Status )) {
				Status = NtReadFile( m_IniFile.m_FileHandle,
									 NULL,
									 NULL,
									 NULL,
									 &IoStatusBlock,
									 m_IniFile.m_BaseAddress,
									 m_IniFile.m_EndOfFile,
									 NULL,
									 &LockFileKey
								   );
				if (NT_SUCCESS( Status ) && IoStatusBlock.Information != m_IniFile.m_EndOfFile) {
					Status = STATUS_END_OF_FILE;
				}
			}
		}
	}

    if (NT_SUCCESS( Status ))
	{
        // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
        INT iResult = ~0x0;
        m_IniFile.m_UpdateOffset = 0xFFFFFFFF;
        m_IniFile.m_UpdateEndOffset = 0;
        m_IniFile.m_UnicodeFile = RtlIsTextUnicode( m_IniFile.m_BaseAddress, m_IniFile.m_EndOfFile, (PULONG)&iResult );

        if (m_IniFile.m_UnicodeFile)
		{
            LPWSTR Src = (LPWSTR)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            while (Src > (LPWSTR)m_IniFile.m_BaseAddress && Src[ -1 ] <= L' ')
			{
                if (Src[-1] == L'\r' || Src[-1] == L'\n')
				{
                    break;
                }

                m_IniFile.m_EndOfFile -= sizeof( WCHAR );
                Src -= 1;
            }

            Src = (LPWSTR)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            if (Src > (LPWSTR)m_IniFile.m_BaseAddress)
			{
                if (Src[-1] != L'\n')
				{
                    *Src++ = L'\r';
                    *Src++ = L'\n';
                    m_IniFile.m_UpdateOffset = m_IniFile.m_EndOfFile;
                    m_IniFile.m_UpdateEndOffset = m_IniFile.m_UpdateOffset + 2 * sizeof( WCHAR );
                    m_IniFile.m_EndOfFile = m_IniFile.m_UpdateEndOffset;
                }
            }
        }
		else
		{
            LPBYTE Src = (PBYTE)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            while (Src > (PBYTE)m_IniFile.m_BaseAddress && Src[ -1 ] <= ' ')
			{
                if (Src[-1] == '\r' || Src[-1] == '\n') {
                    break;
                }

                m_IniFile.m_EndOfFile -= 1;
                Src -= 1;
            }

            Src = (PBYTE)((PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile);

            if (Src > (PBYTE)m_IniFile.m_BaseAddress)
			{
                if (Src[-1] != '\n') {
                    *Src++ = '\r';
                    *Src++ = '\n';
                    m_IniFile.m_UpdateOffset = m_IniFile.m_EndOfFile;
                    m_IniFile.m_UpdateEndOffset = m_IniFile.m_UpdateOffset + 2;
                    m_IniFile.m_EndOfFile = m_IniFile.m_UpdateEndOffset;
                }
            }
        }
    }
	else
	{
		if ((m_IniFile.m_FileHandle != INVALID_HANDLE_VALUE) && (m_IniFile.m_FileHandle != NULL))
		{
			if (m_IniFile.m_LockedFile)
			{
				m_IniFile.m_LockedFile = FALSE;
				ByteOffset.QuadPart = 0;
				Length.QuadPart = -1;
				NtUnlockFile( m_IniFile.m_FileHandle,
							  &IoStatusBlock,
							  &ByteOffset,
							  &Length,
							  LockFileKey
							);
			}

			NtClose( m_IniFile.m_FileHandle );
			m_IniFile.m_FileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return Status;
}


NTSTATUS CWMI_FILE_IniFile::ReadWriteIniFileOnDisk()
{
    NTSTATUS Status;
    ULONG PartialResultChars = 0;

    if (!m_IsWriteOperation) {
        PartialResultChars = m_ResultChars;
    }

    Status = OpenIniFileOnDisk();
    
	if (NT_SUCCESS( Status ))
	{
        try
		{
            m_TextEnd = (PCHAR)m_IniFile.m_BaseAddress + m_IniFile.m_EndOfFile;
            m_TextCurrent = m_IniFile.m_BaseAddress;
            if (m_IniFile.m_UnicodeFile &&
                ((*(PWCHAR)m_TextCurrent == BYTE_ORDER_MARK) ||
                 (*(PWCHAR)m_TextCurrent == REVERSE_BYTE_ORDER_MARK)))
            {
                // Skip past the BOM.
				PWCHAR foo = (PWCHAR)m_TextCurrent;
                foo++;
				m_TextCurrent = (PVOID)foo;
            }

            if (m_Operation == Enum_ReadKeyValueOp)
			{
                Status = ReadKeywordValue();
            }
			else if (m_Operation == Enum_ReadSectionOp)
			{
                Status = ReadSection();
            }
			else if (m_Operation == Enum_WriteKeyValueOp)
			{
                Status = WriteKeywordValue(NULL );
            }
			else if (m_Operation == Enum_WriteSectionOp)
			{
                Status = WriteSection();
            }
			else
			{
                Status = STATUS_INVALID_PARAMETER;
            }

            NTSTATUS CloseStatus;
            CloseStatus = CloseIniFileOnDisk();

            if (NT_SUCCESS( Status ))
			{
                Status = CloseStatus;
            }
        }
        catch (...)
		{
            NTSTATUS CloseStatus;
            CloseStatus = CloseIniFileOnDisk();

            if (NT_SUCCESS( Status ))
			{
                Status = CloseStatus;
            }
        }
    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND &&
        !m_IsWriteOperation &&
        PartialResultChars != 0
       )
	{
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::CloseIniFileOnDisk()
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS CloseStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG UpdateLength = 0;
    LARGE_INTEGER ByteOffset;
	LARGE_INTEGER Length;

    if ((m_IniFile.m_FileHandle != INVALID_HANDLE_VALUE) && (m_IniFile.m_FileHandle != NULL))
	{
        if (m_IniFile.m_BaseAddress != NULL)
		{
            if (m_IniFile.m_UpdateOffset != 0xFFFFFFFF && m_IniFile.m_WriteAccess)
			{
                ByteOffset.HighPart = 0;
                ByteOffset.LowPart = m_IniFile.m_UpdateOffset;
                UpdateLength = m_IniFile.m_UpdateEndOffset - m_IniFile.m_UpdateOffset;
                Status = NtWriteFile( m_IniFile.m_FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      (PCHAR)(m_IniFile.m_BaseAddress) + m_IniFile.m_UpdateOffset,
                                      UpdateLength,
                                      &ByteOffset,
                                      &LockFileKey
                                    );

                if (NT_SUCCESS( Status ))
				{
                    if (IoStatusBlock.Information != UpdateLength)
					{
                        Status = STATUS_DISK_FULL;
                    }
					else
					{
                        Length.QuadPart = m_IniFile.m_EndOfFile;
                        Status = NtSetInformationFile( m_IniFile.m_FileHandle,
                                                       &IoStatusBlock,
                                                       &Length,
                                                       sizeof( Length ),
                                                       FileEndOfFileInformation
                                                     );
                    }
                }
            }

            NtFreeVirtualMemory( NtCurrentProcess(),
                                 &m_IniFile.m_BaseAddress,
                                 &m_IniFile.m_RegionSize,
                                 MEM_RELEASE
                               );
            m_IniFile.m_BaseAddress = NULL;
            m_IniFile.m_CommitSize = 0;
            m_IniFile.m_RegionSize = 0;
        }

        if (m_IniFile.m_LockedFile)
		{
			m_IniFile.m_LockedFile = FALSE;
            ByteOffset.QuadPart = 0;
            Length.QuadPart = -1;
            NtUnlockFile( m_IniFile.m_FileHandle,
                          &IoStatusBlock,
                          &ByteOffset,
                          &Length,
                          LockFileKey
                        );
        }

        CloseStatus = NtClose( m_IniFile.m_FileHandle );
		m_IniFile.m_FileHandle = INVALID_HANDLE_VALUE;

        if (NT_SUCCESS( Status ))
		{
            Status = CloseStatus;
        }
    }

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::ReadKeywordValue()
{
    NTSTATUS Status = FindSection();

    if (!NT_SUCCESS( Status ))
	{
        return Status;
    }

    Status = FindKeyword();

    if (!NT_SUCCESS( Status ))
	{
        return Status;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        LPWSTR Src = (LPWSTR)m_UnicodeKeywordValue->Buffer;

        while (*Src <= L' ' && m_UnicodeKeywordValue->Length)
		{
            Src += 1;
            m_UnicodeKeywordValue->Buffer = Src;
            m_UnicodeKeywordValue->Length -= sizeof( WCHAR );
            m_UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
        }

        if (m_UnicodeKeywordValue->Length >= (2 * sizeof( WCHAR )) &&
            (Src[ 0 ] == Src[ (m_UnicodeKeywordValue->Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
            (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
           ) {
            m_UnicodeKeywordValue->Buffer += 1;
            m_UnicodeKeywordValue->Length -= (2 * sizeof( WCHAR ));
            m_UnicodeKeywordValue->MaximumLength -= (2 * sizeof( WCHAR ));
        }
    }
	else
	{
        PBYTE Src;

        Src = (PBYTE)m_AnsiKeywordValue->Buffer;
        while (*Src <= ' ' && m_AnsiKeywordValue->Length) {
            Src += 1;
            m_AnsiKeywordValue->Buffer = (PCHAR)Src;
            m_AnsiKeywordValue->Length -= sizeof( UCHAR );
            m_AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
        }

        if (m_AnsiKeywordValue->Length >= (2 * sizeof( UCHAR )) &&
            (Src[ 0 ] == Src[ (m_AnsiKeywordValue->Length - sizeof( UCHAR )) / sizeof( UCHAR ) ]) &&
            (Src[ 0 ] == '"' || Src[ 0 ] == '\'')
           ) {
            m_AnsiKeywordValue->Buffer += 1;
            m_AnsiKeywordValue->Length -= (2 * sizeof( UCHAR ));
            m_AnsiKeywordValue->MaximumLength -= (2 * sizeof( UCHAR ));
        }
    }

    return AppendStringToResultBuffer(m_AnsiKeywordValue,
                                              m_UnicodeKeywordValue,
                                              TRUE
                                            );
}


NTSTATUS CWMI_FILE_IniFile::ReadSection()
{
    NTSTATUS Status;

    Status = FindSection();
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        Status = AdvanceTextPointer( STOP_AT_NONSECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            if (m_AnsiKeywordName || m_UnicodeKeywordName) {
                Status = AppendStringToResultBuffer(m_AnsiKeywordName,
                                                            m_UnicodeKeywordName,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }

                Status = AppendBufferToResultBuffer(NULL,
                                                            L"=",
                                                            1,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }
            }

            if (m_IniFile.m_UnicodeFile) {
                LPWSTR Src;

                Src = (LPWSTR)m_UnicodeKeywordValue->Buffer;
                while (*Src <= L' ' && m_UnicodeKeywordValue->Length) {
                    Src += 1;
                    m_UnicodeKeywordValue->Buffer = Src;
                    m_UnicodeKeywordValue->Length -= sizeof( WCHAR );
                    m_UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
                }
            } else {
                PBYTE Src;

                Src = (PBYTE)m_AnsiKeywordValue->Buffer;
                while (*Src <= ' ' && m_AnsiKeywordValue->Length) {
                    Src += 1;
                    m_AnsiKeywordValue->Buffer = (PCHAR)Src;
                    m_AnsiKeywordValue->Length -= sizeof( UCHAR );
                    m_AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
                }
            }

            Status = AppendStringToResultBuffer(m_AnsiKeywordValue,
                                                        m_UnicodeKeywordValue,
                                                        TRUE
                                                      );
            if (!NT_SUCCESS( Status )) {
                return Status;
            }
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            break;
        }
    }

    return Status;
}


NTSTATUS CWMI_FILE_IniFile::FindSection()
{
    NTSTATUS Status;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;

    while (TRUE)
	{
        Status = AdvanceTextPointer(STOP_AT_SECTION );

        if (Status == STATUS_MORE_ENTRIES)
		{
            if (m_AnsiSectionName)
			{
                // Ansi ini file -- get the ansi parm
                if (!GetApplicationName(&AnsiSectionName, NULL ))
				{
                    return STATUS_INVALID_PARAMETER;
                }
            }
			else
			{
                // we just need the unicode section name...
                if (!GetApplicationName(NULL, &UnicodeSectionName ))
				{
                    return STATUS_INVALID_PARAMETER;
                }
			}

            if (m_AnsiSectionName == NULL)
			{
                if (RtlEqualUnicodeString( UnicodeSectionName,
                                           m_UnicodeSectionName,
                                           TRUE
                                         )
                   )
				{
                    Status = STATUS_SUCCESS;
                }
				else
				{
                    Status = STATUS_MORE_ENTRIES;
                }
            }
			else
			{
                if (RtlEqualString( AnsiSectionName, m_AnsiSectionName, TRUE ))
				{
                    Status = STATUS_SUCCESS;
                }
				else
				{
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (Status != STATUS_MORE_ENTRIES)
			{
                return Status;
            }
        }
		else
		{
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS CWMI_FILE_IniFile::FindKeyword()
{
    NTSTATUS Status = STATUS_SUCCESS;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeKeywordName;

    while (TRUE) {
        Status = AdvanceTextPointer(STOP_AT_KEYWORD);
        if (Status == STATUS_MORE_ENTRIES) {

            // Here's the deal.  We don't want to compare in Unicode
            // unless both the ini and the input parm are Unicode,
            // because we want to avoid the round-trip problem (we
            // lose data when we convert Unicode -> Ansi (on disk) ->
            // Unicode; since we don't get back the original Unicode
            // string, lookups of previously stored data fail -- bug
            // 426754).  So if both are Unicode, great! -- use Unicode.
            // Otherwise, use ansi for everything.

            if (m_AnsiKeywordName) {
                // Ansi ini file -- get the ansi parm
                if (!GetVariableName(&AnsiKeywordName, NULL )) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                //great, get the Unicode parm.
                if (!GetVariableName(NULL, &UnicodeKeywordName )) {
                    return STATUS_INVALID_PARAMETER;
                }
            }

            if (m_AnsiKeywordName == NULL) {
                if (RtlEqualUnicodeString( UnicodeKeywordName,
                                           m_UnicodeKeywordName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiKeywordName, m_AnsiKeywordName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS CWMI_FILE_IniFile::AdvanceTextPointer( IN ULONG StopAt )
{
    BOOL AllowNoEquals = FALSE;

    if (StopAt == STOP_AT_NONSECTION)
	{
        StopAt = STOP_AT_KEYWORD;
        AllowNoEquals = TRUE;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        LPWSTR Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) L##quote

        LPWSTR Src = (LPWSTR)m_TextCurrent;
        LPWSTR EndOfFile = (LPWSTR)m_TextEnd;

        while (Src < EndOfFile)
		{
            //
            // Find first non-blank character on a line.  Skip blank lines
            //
            while (Src < EndOfFile && *Src <= INI_TEXT(' '))
			{
                Src++;
            }

            if (Src >= EndOfFile)
			{
                m_TextCurrent = Src;
                break;
            }

            LPWSTR EndOfLine = Src;
            LPWSTR EqualSign = NULL;
            m_TextStart = Src;

            while (EndOfLine < EndOfFile)
			{
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('='))
				{
                    EqualSign = ++EndOfLine;
                }
				else if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n'))
				{
                    if (*EndOfLine == INI_TEXT('\r'))
					{
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n'))
					{
                        EndOfLine++;
                    }

                    break;
                }
				else
				{
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';'))
			{
                if (*Src == INI_TEXT('['))
				{
                    Name = Src + 1;
                    
					while (Name < EndOfLine && *Name <= INI_TEXT(' '))
					{
                        Name++;
                    }
                    
					EndOfName = Name;
                    
					while (EndOfName < EndOfLine && *EndOfName != INI_TEXT(']'))
					{
                        EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfName--;
                    }
                    
					m_SectionNameU.Buffer = Name;
                    m_SectionNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    m_SectionNameU.MaximumLength = m_SectionNameU.Length;
                    m_AnsiSectionName = NULL;
                    m_UnicodeSectionName = &m_SectionNameU;
                    
					if (StopAt == STOP_AT_SECTION)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
					else if (StopAt == STOP_AT_KEYWORD)
					{
                        return STATUS_NO_MORE_ENTRIES;
                    }
                }
				else if (AllowNoEquals || (EqualSign != NULL) )
				{
                    if (EqualSign != NULL)
					{
                        Name = Src;
                        EndOfName = EqualSign - 1;
                    
						while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
						{
                            EndOfName--;
                        }

                        m_KeywordNameU.Buffer = Name;
                        m_KeywordNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        m_KeywordNameU.MaximumLength = m_KeywordNameU.Length;
                        m_AnsiKeywordName = NULL;
                        m_UnicodeKeywordName = &m_KeywordNameU;

                        Value = EqualSign;
                    }
					else
					{
                        Value = Src;
                        m_AnsiKeywordName = NULL;
                        m_UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    
					while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfValue--;
                    }
                    
					m_KeywordValueU.Buffer = Value;
                    m_KeywordValueU.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    m_KeywordValueU.MaximumLength = m_KeywordValueU.Length;
                    m_AnsiKeywordValue = NULL;
                    m_UnicodeKeywordValue = &m_KeywordValueU;
                    
					if (StopAt == STOP_AT_KEYWORD)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }
	else
	{
        PBYTE Src, EndOfLine, EqualSign, EndOfFile;
        PBYTE Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) quote

        Src = (PBYTE)m_TextCurrent;
        EndOfFile = (PBYTE)m_TextEnd;
        while (Src < EndOfFile)
		{
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' '))
			{
                Src++;
            }

            if (Src >= EndOfFile)
			{
                m_TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            m_TextStart = Src;

            while (EndOfLine < EndOfFile)
			{
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('='))
				{
                    EqualSign = ++EndOfLine;
                }
				else if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n'))
				{
                    if (*EndOfLine == INI_TEXT('\r'))
					{
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                }
				else
				{
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';'))
			{
                if (*Src == INI_TEXT('['))
				{
                    Name = Src + 1;
                
					while (Name < EndOfLine && *Name <= INI_TEXT(' '))
					{
                        Name++;
                    }
                    
					EndOfName = Name;
                    
					while (EndOfName < EndOfLine)
					{
                        if (*EndOfName == INI_TEXT(']'))
						{
                            break;
                        }
                        
						if (IsDBCSLeadByte(*EndOfName))
						{
                            EndOfName++;
                        }
                        
						EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfName--;
                    }
                
					m_SectionName.Buffer = (PCHAR)Name;
                    m_SectionName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    m_SectionName.MaximumLength = m_SectionName.Length;
                    m_AnsiSectionName = &m_SectionName;
                    m_UnicodeSectionName = NULL;
                    
					if (StopAt == STOP_AT_SECTION)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
					else if (StopAt == STOP_AT_KEYWORD)
					{
                        return STATUS_NO_MORE_ENTRIES;
                    }
                }
				else if (AllowNoEquals || (EqualSign != NULL))
				{

                    if (EqualSign != NULL)
					{
                        Name = Src;
                        EndOfName = EqualSign - 1;

                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' '))
						{
                            EndOfName--;
                        }

                        m_KeywordName.Buffer = (PCHAR)Name;
                        m_KeywordName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        m_KeywordName.MaximumLength = m_KeywordName.Length;
                        m_AnsiKeywordName = &m_KeywordName;
                        m_UnicodeKeywordName = NULL;

                        Value = EqualSign;
                    }
					else
					{
                        Value = Src;
                        m_AnsiKeywordName = NULL;
                        m_UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    
					while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' '))
					{
                        EndOfValue--;
                    }
                    
					m_KeywordValue.Buffer = (PCHAR)Value;
                    m_KeywordValue.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    m_KeywordValue.MaximumLength = m_KeywordValue.Length;
                    m_AnsiKeywordValue = &m_KeywordValue;
                    m_UnicodeKeywordValue = NULL;
                    
					if (StopAt == STOP_AT_KEYWORD)
					{
                        m_TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }

    return STATUS_NO_MORE_ENTRIES;
}


BOOL CWMI_FILE_IniFile::GetApplicationName(
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         )
{
    NTSTATUS Status;

    if (ApplicationName)
	{
        if (m_ApplicationName.Length == 0)
		{
			m_ApplicationName.Buffer = new char[(m_ApplicationNameU.Length * sizeof(WORD)) + 1]; //MBCS strings
			m_ApplicationName.MaximumLength = (m_ApplicationNameU.Length * sizeof(WORD)) + 1; 
            Status = RtlUnicodeStringToAnsiString( &m_ApplicationName, &m_ApplicationNameU, FALSE );
        
			if (!NT_SUCCESS( Status ))
			{
                return FALSE;
            }
        }

        *ApplicationName = &m_ApplicationName;
        return TRUE;
    }

    if (ApplicationNameU)
	{
        if (m_ApplicationNameU.Length == 0)
		{
            return FALSE;
        }

        *ApplicationNameU = &m_ApplicationNameU;
        return TRUE;
    }

    return FALSE;
}

BOOL CWMI_FILE_IniFile::GetVariableName(
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( VariableName ))
	{
        if (m_VariableName.Length == 0)
		{
			m_VariableName.Buffer = new char[(m_VariableNameU.Length * sizeof(WORD)) + 1]; //MBCS strings
			m_VariableName.MaximumLength = (m_VariableNameU.Length * sizeof(WORD)) + 1;
            Status = RtlUnicodeStringToAnsiString( &m_VariableName, &m_VariableNameU, FALSE );

            if (!NT_SUCCESS( Status ))
			{
                return FALSE;
            }
        }

        *VariableName = &m_VariableName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableNameU ))
	{
        if (m_VariableNameU.Length == 0)
		{
		   return FALSE;
        }

        *VariableNameU = &m_VariableNameU;
        return TRUE;
    }

    return FALSE;
}

BOOL CWMI_FILE_IniFile::GetVariableValue(
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT LPWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       )
{
    NTSTATUS Status;
    ULONG Index;

    if (VariableValue)
	{
        if (m_ValueLength == 0)
		{
            if (m_ValueBufferU == NULL || m_ValueLengthU == 0)
			{
                *VariableValue = '\0';
                *VariableValueLength = 1;
                return TRUE;
            }

			m_ValueBuffer = new char[m_ValueLengthU + 1]; //DBCS
            m_ValueLength = m_ValueLengthU;
            Status = RtlUnicodeToMultiByteN( (PCHAR)m_ValueBuffer,
                                             m_ValueLength,
                                             &Index,
                                             m_ValueBufferU,
                                             m_ValueLengthU
                                           );

            if (!NT_SUCCESS( Status ))
			{
                return FALSE;
            }

            // Set real converted size
            m_ValueLength = Index;
            m_ValueBuffer[ Index ] = '\0';       // Null terminate converted value
        }
		else
		{
            Index = m_ValueLength;
        }

        *VariableValue = (PBYTE)m_ValueBuffer;
        *VariableValueLength = Index + 1;
        return TRUE;
    }

    if (VariableValueU)
	{
        if (m_ValueLengthU == 0)
		{
            if (m_ValueBuffer == NULL || m_ValueLength == 0)
			{
                *VariableValueU = L"";
                *VariableValueLength = sizeof( L'\0' );
                return TRUE;
            }
            else
			{
                return FALSE;
            }

        }
		else
		{
            Index = m_ValueLengthU / sizeof( WCHAR );
        }

        *VariableValueU = m_ValueBufferU;
        *VariableValueLength = (Index + 1) * sizeof( WCHAR );
        return TRUE;
    }

    return FALSE;
}


NTSTATUS  CWMI_FILE_IniFile::AppendStringToResultBuffer(
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOL IncludeNull
                                 )
{
    if (String)
	{
        if (StringU)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            return AppendBufferToResultBuffer((PBYTE)String->Buffer,
                                                      NULL,
                                                      String->Length,
                                                      IncludeNull
                                                    );
        }
    }
	else if (StringU)
	{
        if (String)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            return AppendBufferToResultBuffer(NULL,
                                                      StringU->Buffer,
                                                      StringU->Length / sizeof( WCHAR ),
                                                      IncludeNull
                                                    );
        }
    }
	else
	{
        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS CWMI_FILE_IniFile::AppendBufferToResultBuffer(
                                 IN PBYTE Buffer OPTIONAL,
                                 IN LPWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOL IncludeNull
                                 )
{
    NTSTATUS Status, OverflowStatus;
    ULONG Index;

    OverflowStatus = STATUS_SUCCESS;

    if (Buffer)
	{
        if (BufferU)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            ULONG CharsMbcs = Chars;
            //
            // In this point, Chars does not contains proper value for Unicode.
            // because. Chars was computed based on DBCS string length,
            // This is correct, sources string is DBCS, then
            // if the source is not DBCS. we just adjust it here.
            //
            Status = RtlMultiByteToUnicodeSize(&Chars,(PCSTR)Buffer,Chars);
            
			if (!NT_SUCCESS( Status ))
			{
                return Status;
            }

			Chars /= sizeof(WCHAR);

            if (m_ResultChars + Chars >= m_ResultMaxChars)
			{
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = m_ResultMaxChars - m_ResultChars;
            
				if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars)
			{
                Status = RtlMultiByteToUnicodeN( (PWSTR)(m_ResultBufferU + m_ResultChars),
                                                 Chars * sizeof( WCHAR ),
                                                 &Index,
                                                 (PCSTR)Buffer,
                                                 CharsMbcs
                                               );
                if (!NT_SUCCESS( Status ))
				{
                    return Status;
                }

                m_ResultChars += Chars;
            }
        }
    }
	else if (BufferU)
	{
        if (Buffer)
		{
            return STATUS_INVALID_PARAMETER;
        }
		else
		{
            ULONG CharsUnicode = Chars;

            if (m_ResultChars + Chars >= m_ResultMaxChars)
			{
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = m_ResultMaxChars - m_ResultChars;
                
				if (Chars)
				{
                    Chars -= 1;
                }
            }

            if (Chars)
			{
                memcpy( (LPVOID)(m_ResultBufferU + m_ResultChars), BufferU, Chars * sizeof( WCHAR ) );

                m_ResultChars += Chars;
            }
        }
    }

    if (IncludeNull)
	{
        if (m_ResultChars + 1 >= m_ResultMaxChars)
		{
            return STATUS_BUFFER_OVERFLOW;
        }

        m_ResultBufferU[ m_ResultChars ] = L'\0';
        m_ResultChars += 1;
    }

    return OverflowStatus;
}

NTSTATUS  CWMI_FILE_IniFile::WriteKeywordValue(
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    BOOL InsertSectionName;
    BOOL InsertKeywordName;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PBYTE AnsiKeywordValue;
    LPWSTR UnicodeKeywordValue;
    ULONG ValueLength;
    ULONG DeleteLength;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = FindSection( );

    if (!NT_SUCCESS( Status ))
	{
        AddressInFile = m_TextEnd;
     
		if (m_IniFile.m_UnicodeFile)
		{
            if (!GetApplicationName(NULL, &UnicodeSectionName ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        }
		else
		{
            if (!GetApplicationName(&AnsiSectionName, NULL ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
    }
	else
	{
        InsertSectionName = FALSE;
        Status = FindKeyword( );
    }

    if (!NT_SUCCESS( Status ))
	{
        if (!InsertSectionName)
		{
            AddressInFile = m_TextCurrent;
        }

        if (m_IniFile.m_UnicodeFile)
		{
            if (!GetVariableName(NULL, &UnicodeKeywordName ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeKeywordName->Length;
        }
		else
		{
            if (!GetVariableName(&AnsiKeywordName, NULL ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiKeywordName->Length;
        }

        InsertKeywordName = TRUE;
    }
	else
	{
        if (m_IniFile.m_UnicodeFile)
		{
                AddressInFile = m_UnicodeKeywordValue->Buffer;
        }
		else
		{
            AddressInFile = m_AnsiKeywordValue->Buffer;
        }
        InsertKeywordName = FALSE;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        if (!GetVariableValue( NULL, &UnicodeKeywordValue, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( WCHAR );

        if (InsertAmount == 0)
		{
            return ModifyMappedFile(m_UnicodeKeywordValue->Buffer,
                                            m_UnicodeKeywordValue->Length,
                                            UnicodeKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }
	else
	{
        if (!GetVariableValue(&AnsiKeywordValue, NULL, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( UCHAR );

        if (InsertAmount == 0)
		{
            return ModifyMappedFile(m_AnsiKeywordValue->Buffer,
                                            m_AnsiKeywordValue->Length,
                                            AnsiKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }
	
	PVOID InsertBuffer = NULL;
    InsertBuffer = (PVOID) new BYTE[InsertAmount  + sizeof( L'\0' )];

	try
	{
		if (m_IniFile.m_UnicodeFile)
		{
			LPWSTR Src, Dst;

			Dst = (LPWSTR)InsertBuffer;
    
			if (InsertSectionName)
			{
				*Dst++ = L'[';
				Src = UnicodeSectionName->Buffer;
				n = UnicodeSectionName->Length / sizeof( WCHAR );
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = L']';
				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}

			if (InsertKeywordName)
			{
				Src = UnicodeKeywordName->Buffer;
				n = UnicodeKeywordName->Length / sizeof( WCHAR );
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = L'=';
			}

			Src = UnicodeKeywordValue;
			n = ValueLength / sizeof( WCHAR );
        
			while (n--)
			{
				*Dst++ = *Src++;
			}

			if (InsertKeywordName)
			{
				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}
		}
		else
		{
			PBYTE Src, Dst;

			Dst = (PBYTE)InsertBuffer;
        
			if (InsertSectionName)
			{
				*Dst++ = '[';
				Src = (PBYTE)AnsiSectionName->Buffer;
				n = AnsiSectionName->Length;
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = ']';
				*Dst++ = '\r';
				*Dst++ = '\n';
			}

			if (InsertKeywordName)
			{
				Src = (PBYTE)AnsiKeywordName->Buffer;
				n = AnsiKeywordName->Length;
        
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = '=';
			}

			Src = AnsiKeywordValue;
			n = ValueLength;

			while (n--)
			{
				*Dst++ = *Src++;
			}

			if (InsertKeywordName)
			{
				*Dst++ = '\r';
				*Dst++ = '\n';
			}
		}

		Status = ModifyMappedFile(AddressInFile,
										  0,
										  InsertBuffer,
										  InsertAmount
										);
		delete [] ((BYTE*) InsertBuffer);
		InsertBuffer = NULL;
	}
	catch(...)
	{
		if (InsertBuffer)
		{
			delete [] ((BYTE*) InsertBuffer);
			InsertBuffer = NULL;
		}

		throw;
	}

    return Status;
}

NTSTATUS CWMI_FILE_IniFile::ModifyMappedFile(
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       )
{
    NTSTATUS Status;
    ULONG NewEndOfFile, UpdateOffset, UpdateLength;

    NewEndOfFile = m_IniFile.m_EndOfFile - SizeToRemove + InsertAmount;
    
	if (NewEndOfFile > m_IniFile.m_CommitSize)
	{
        if (NewEndOfFile > m_IniFile.m_RegionSize)
		{
            return STATUS_BUFFER_OVERFLOW;
        }

        m_IniFile.m_CommitSize = NewEndOfFile;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &m_IniFile.m_BaseAddress,
                                          0,
                                          &m_IniFile.m_CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        m_IniFile.m_EndOfFile = NewEndOfFile;
    }

    UpdateOffset = (ULONG)((PCHAR)AddressInFile - (PCHAR)(m_IniFile.m_BaseAddress)),
                   UpdateLength = (ULONG)((PCHAR)m_TextEnd - (PCHAR)AddressInFile) + InsertAmount - SizeToRemove;
    //
    // Are we deleting more than we are inserting?
    //
    if (SizeToRemove > InsertAmount)
	{
        //
        // Yes copy over insert string.
        //
        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );

        //
        // Delete remaining text after insertion string by moving it
        // up
        //

        RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount,
                       (PCHAR)AddressInFile + SizeToRemove,
                       UpdateLength - InsertAmount
                     );
    }
	else if (InsertAmount > 0)
	{
        //
        // Are we deleting less than we are inserting?
        //
        if (SizeToRemove < InsertAmount)
		{
            //
            // Move text down to make room for insertion
            //

            RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount - SizeToRemove,
                           (PCHAR)AddressInFile,
                           UpdateLength - InsertAmount + SizeToRemove
                         );
        }
		else
		{
            //
            // Deleting and inserting same amount, update just that text as
            // no shifting was done.
            //

            UpdateLength = InsertAmount;
        }

        //
        // Copy over insert string
        //

        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );
    }
	else
	{
        //
        // Nothing to change, as InsertAmount and SizeToRemove are zero
        //
        return STATUS_SUCCESS;
    }

    if (m_IniFile.m_EndOfFile != NewEndOfFile)
	{
        m_IniFile.m_EndOfFile = NewEndOfFile;
    }

    if (UpdateOffset < m_IniFile.m_UpdateOffset)
	{
        m_IniFile.m_UpdateOffset = UpdateOffset;
    }

    if ((UpdateOffset + UpdateLength) > m_IniFile.m_UpdateEndOffset)
	{
        m_IniFile.m_UpdateEndOffset = UpdateOffset + UpdateLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS CWMI_FILE_IniFile::WriteSection()
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    PBYTE AnsiKeywordValue, s;
    PWSTR UnicodeKeywordValue, w;
    ULONG ValueLength, SizeToRemove;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = FindSection();

    if (!NT_SUCCESS( Status ))
	{
        AddressInFile = m_TextEnd;
        if (m_IniFile.m_UnicodeFile)
		{
            if (!GetApplicationName(NULL, &UnicodeSectionName ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        }
		else
		{
            if (!GetApplicationName(&AnsiSectionName, NULL ))
			{
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
        SizeToRemove = 0;
    }
	else
	{
		AddressInFile = m_TextCurrent;
        
		while (TRUE)
		{
            //
            // For delete operations need to iterate all lines in section,
            // not just those that have an = on them. Otherwise sections like
            // [foo]
            // a
            // b = c
            // d
            //
            // don't get deleted properly.
            //
            Status = AdvanceTextPointer(STOP_AT_KEYWORD);

            if (Status == STATUS_MORE_ENTRIES)
			{
            }
			else if (Status == STATUS_NO_MORE_ENTRIES)
			{
                SizeToRemove = (ULONG)((PCHAR)m_TextCurrent - (PCHAR)AddressInFile);
                break;
            }
			else
			{
                return Status;
            }
        }

        InsertSectionName = FALSE;
    }

    if (m_IniFile.m_UnicodeFile)
	{
        if (!GetVariableValue(NULL, &UnicodeKeywordValue, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( WCHAR );

        //
        // Add in size of value, + \r\n for each line
        //

        w = UnicodeKeywordValue;
        InsertAmount += ValueLength;
        
		while (*w)
		{
            while (*w++)
			{
            }
            
			InsertAmount += (2-1) * sizeof( WCHAR );    // Subtract out NULL byte already in ValueLength
        }
    }
	else
	{
        if (!GetVariableValue(&AnsiKeywordValue, NULL, &ValueLength ))
		{
            return STATUS_INVALID_PARAMETER;
        }
        
		ValueLength -= sizeof( UCHAR );

        //
        // Add in size of value, + \r\n for each line
        //

        s = AnsiKeywordValue;
        InsertAmount += ValueLength;
        
		while (*s)
		{
            while (*s++)
			{
            }
            InsertAmount += 2 - 1;      // Subtract out NULL byte already in ValueLength
        }
    }

	PVOID InsertBuffer = NULL;
    InsertBuffer = (PVOID) new BYTE[InsertAmount + sizeof( L'\0' )];

	try
	{
		if (m_IniFile.m_UnicodeFile)
		{
			PWSTR Src, Dst;

			Dst = (PWSTR)InsertBuffer;
        
			if (InsertSectionName)
			{
				*Dst++ = L'[';
				Src = UnicodeSectionName->Buffer;
				n = UnicodeSectionName->Length / sizeof( WCHAR );
            
				while (n--)
				{
					*Dst++ = *Src++;
				}
            
				*Dst++ = L']';
				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}

			Src = UnicodeKeywordValue;
        
			while (*Src)
			{
				while (*Dst = *Src++)
				{
					Dst += 1;
				}

				*Dst++ = L'\r';
				*Dst++ = L'\n';
			}
		}
		else
		{
			PBYTE Src, Dst;

			Dst = (PBYTE)InsertBuffer;
			if (InsertSectionName) {
				*Dst++ = '[';
				Src = (PBYTE)AnsiSectionName->Buffer;
				n = AnsiSectionName->Length;
				while (n--) {
					*Dst++ = *Src++;
				}
				*Dst++ = ']';
				*Dst++ = '\r';
				*Dst++ = '\n';
			}

			Src = AnsiKeywordValue;
    
			while (*Src)
			{
				while (*Dst = *Src++)
				{
					Dst += 1;
				}

				*Dst++ = '\r';
				*Dst++ = '\n';
			}
		}

		Status = ModifyMappedFile(AddressInFile,
										  SizeToRemove,
										  InsertBuffer,
										  InsertAmount
										);
		delete [] ((BYTE*) InsertBuffer);
		InsertBuffer = NULL;
	}
	catch(...)
	{
		if (InsertBuffer)
		{
			delete [] ((BYTE*) InsertBuffer);
			InsertBuffer = NULL;
		}

		throw;
	}

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wsock32api.h ===
//=================================================================

//

// Wsock32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_WSOCK32API_H_
#define	_WSOCK32API_H_

#include <winsock.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <tdistat.h>
#include <ipinfo.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidWsock32Api;
extern const TCHAR g_tstrWsock32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef DWORD (CALLBACK *PFN_WSOCK32_WSCONTROL)
( 
    DWORD, 
    DWORD, 
    LPVOID, 
    LPDWORD, 
    LPVOID, 
    LPDWORD 
);

typedef INT (APIENTRY *PFN_WSOCK32_ENUMPROTOCOLS) 
(
	LPINT lpiProtocols,
	LPVOID lpProtocolBuffer,
	LPDWORD lpdwBufferLength
) ;

typedef INT (APIENTRY *PFN_WSOCK32_STARTUP)
( 
	IN WORD wVersionRequired,
    OUT LPWSADATA lpWSAData
) ;

typedef INT (APIENTRY *PFN_WSOCK32_CLEANUP)
( 
) ;
 
typedef INT (APIENTRY *PFN_WSOCK32_CLOSESOCKET)
( 
	SOCKET s
) ;

typedef int ( PASCAL FAR *PFN_WSOCK32_GETSOCKOPT )
(
	SOCKET s,
	int level,
	int optname,
	char FAR * optval,
	int FAR *optlen
);

typedef int ( PASCAL FAR *PFN_WSOCK32_BIND ) 
(
	SOCKET s,
	const struct sockaddr FAR *addr,
	int namelen
);

typedef SOCKET ( PASCAL FAR *PFN_WSOCK32_SOCKET )
(
	int af,
	int type,
	int protocol
);

typedef int ( PASCAL FAR *PFN_WSOCK32_WSAGETLASTERROR ) (void);

typedef char * ( PASCAL FAR *PFN_WSOCK32_INET_NTOA )
(
	IN struct in_addr in
);

/******************************************************************************
 * Wrapper class for Wsock32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CWsock32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_WSOCK32_WSCONTROL m_pfnWsControl;
	PFN_WSOCK32_ENUMPROTOCOLS m_pfnWsEnumProtocols;
	PFN_WSOCK32_STARTUP m_pfnWsStartup;
	PFN_WSOCK32_CLEANUP m_pfnWsCleanup;
	PFN_WSOCK32_CLOSESOCKET m_pfnWsCloseSocket;
	PFN_WSOCK32_GETSOCKOPT m_pfnWsGetSockopt ;
	PFN_WSOCK32_BIND m_pfnWsBind ;
	PFN_WSOCK32_SOCKET m_pfnWsSocket ;
	PFN_WSOCK32_WSAGETLASTERROR m_pfnWsWSAGetLastError ;
	PFN_WSOCK32_INET_NTOA m_pfnWsInet_NtoA ;

public:

    // Constructor and destructor:
    CWsock32Api(LPCTSTR a_tstrWrappedDllName);
    ~CWsock32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Wsock32 functions.
    // Add new functions here as required:
    bool WsControl
    (
        DWORD a_dw1, 
        DWORD a_dw2, 
        LPVOID a_lpv1, 
        LPDWORD a_lpdw1, 
        LPVOID a_lpv2, 
        LPDWORD a_lpdw2,
        DWORD *a_pdwRetval
    );

	INT WsEnumProtocols (

		LPINT lpiProtocols,
		LPVOID lpProtocolBuffer,
		LPDWORD lpdwBufferLength
	);

	INT WsWSAStartup ( 

		IN WORD wVersionRequired,
		OUT LPWSADATA lpWSAData
	) ;

	INT WsWSACleanup () ;
 
	INT Wsclosesocket ( SOCKET s ) ;

	int Wsbind (

		SOCKET s,
        const struct sockaddr FAR *addr,
        int namelen
	);

	int Wsgetsockopt (

       SOCKET s,
       int level,
       int optname,
       char FAR * optval,
       int FAR *optlen
	);

	SOCKET Wssocket (

      int af,
      int type,
      int protocol
	);

	int WsWSAGetLastError(void);

	char * Wsinet_ntoa (

		struct in_addr in
    ) ;

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\dfsjnpt.cpp ===
/******************************************************************

   DfsJnPt.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  
   Description: Win32 Dfs Provider
  
******************************************************************/

#include "precomp.h"

CDfsJnPt MyDfsTable ( 

    PROVIDER_NAME_DFSJNPT , 
    Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::CDfsJnPt
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CDfsJnPt :: CDfsJnPt (

    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
    m_ComputerName = GetLocalComputerName();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::~CDfsJnPt
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CDfsJnPt :: ~CDfsJnPt ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsJnPt::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CDfsJnPt :: EnumerateInstances (

    MethodContext *pMethodContext, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    DWORD dwPropertiesReq   = DFSJNPT_ALL_PROPS;

    hRes = EnumerateAllJnPts ( pMethodContext, dwPropertiesReq );

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsJnPt::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CDfsJnPt :: GetObject (

    CInstance *pInstance, 
    long lFlags ,
    CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Key ;
    
    if  ( pInstance->GetCHString ( DFSNAME , t_Key ) == FALSE )
    {
        hRes = WBEM_E_INVALID_PARAMETER ;
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( Query.AllPropertiesAreRequired() )
        {
            dwPropertiesReq = DFSJNPT_ALL_PROPS;
        }
        else
        {
            SetRequiredProperties ( Query, dwPropertiesReq );
        }

        hRes = FindAndSetDfsEntry ( t_Key, dwPropertiesReq, pInstance, eGet );
    }

    return hRes ;
}



/*****************************************************************************
*
*  FUNCTION    : CDfsJnPt::PutInstance
*
*  DESCRIPTION : Adding a Instance if it already doesnt exist, or modify it 
*                if it already exists, based on the kind of operation requested
*
*****************************************************************************/

HRESULT CDfsJnPt :: PutInstance  (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_E_FAILED ;

    CHString t_Key ;
    DWORD dwOperation;

    if ( Instance.GetCHString ( DFSNAME , t_Key ) )
    {
        hRes = WBEM_S_NO_ERROR;

        DWORD dwPossibleOperations = 0;

        dwPossibleOperations = (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_ONLY);

        switch ( lFlags & dwPossibleOperations )
        {
            case WBEM_FLAG_CREATE_OR_UPDATE:
            {
                dwOperation = eUpdate;
                break;
            }

            case WBEM_FLAG_UPDATE_ONLY:
            {
                dwOperation = eModify;
                break;
            }

            case WBEM_FLAG_CREATE_ONLY:
            {
                hRes = WBEM_E_INVALID_PARAMETER;
                break;
            }
        }
    }

    if ( SUCCEEDED ( hRes ) )
    {
        // This call is made with 2nd parameter 0, indicating that it should not load an instance 
        // with any parameter, it should simple search.
        hRes = FindAndSetDfsEntry ( t_Key, 0, NULL, eGet );

        if ( SUCCEEDED ( hRes ) || ( hRes == WBEM_E_NOT_FOUND ) )
        {
            switch ( dwOperation )
            {
                case eModify:
                {
                    if ( SUCCEEDED ( hRes ) )
                    {
                        hRes = UpdateDfsJnPt ( Instance, eModify );
                        break;
                    }
                }

                case eAdd:
                {
                    hRes = WBEM_E_INVALID_PARAMETER;
                    break;  // Create not currently supported
                }

                case eUpdate:
                {
                    if ( hRes == WBEM_E_NOT_FOUND )
                    {
                        hRes = WBEM_E_INVALID_PARAMETER; // Create not currently supported
                    }
                    else
                    {
                        hRes = UpdateDfsJnPt ( Instance, eModify );
                    }
                    break;
                }
            }
        }
    }

   return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::CheckParameters
 *
 *  DESCRIPTION :   Performs the validity checks of the parameters to add/modify
 *                  the Dfs Jn Pts.
 *
 *****************************************************************************/
HRESULT CDfsJnPt :: CheckParameters ( 

    const CInstance &a_Instance ,
    int a_State 
)
{
    // Getall the Properties from the Instance to Verify
    bool t_Exists ;
    VARTYPE t_Type ;
    HRESULT hr = WBEM_S_NO_ERROR ;

    if ( a_State != WBEM_E_ALREADY_EXISTS ) 
    {
        // need to validate the dfsEntryPath, if it already exists, means it was already verified and was in DFS tree and 
        // hence need not verify
        if ( a_Instance.GetStatus ( DFSNAME , t_Exists , t_Type ) )
        {
            if ( t_Exists && ( t_Type == VT_BSTR ) )
            {
                CHString t_DfsEntryPath;

                if ( a_Instance.GetCHString ( DFSNAME , t_DfsEntryPath ) && ! t_DfsEntryPath.IsEmpty () )
                {
                }
                else
                {
                    // Zero Length string
                    hr = WBEM_E_INVALID_PARAMETER ;
                }
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER ;
            }
        }   
    }

    if ( SUCCEEDED ( hr ) )
    {
        if ( a_Instance.GetStatus ( STATE , t_Exists , t_Type ) )
        {
            if ( t_Exists && ( t_Type == VT_I4 ) )
            {
                DWORD dwState;
                if ( a_Instance.GetDWORD ( STATE, dwState ) )
                {
                    if (( dwState != 0 ) && ( dwState != 1 ) && ( dwState != 2 ) && ( dwState != 3 ) )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                    }
                }
            }
        }
    }

    if ( SUCCEEDED ( hr ) )
    {
        if ( a_Instance.GetStatus ( TIMEOUT , t_Exists , t_Type ) )
        {
            if ( t_Exists )
            { 
                if ( t_Type != VT_I4 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }
            }
        }   
    }

    return hr;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsJnPt:: DeleteInstance
*
*  DESCRIPTION :    Deleting a Dfs Jn Pt if it exists
*
*****************************************************************************/

HRESULT CDfsJnPt :: DeleteInstance (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    CHString t_Key ;
    NET_API_STATUS t_Status = NERR_Success;

    if ( Instance.GetCHString ( DFSNAME , t_Key ) == FALSE )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }

    if ( SUCCEEDED ( hRes ) )
    {
        hRes = FindAndSetDfsEntry ( t_Key, 0, NULL, eDelete );
    }

    return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::EnumerateAllJnPts
 *
 *  DESCRIPTION :   Enumerates all the Junction points and calls the method to load 
 *                  Instance and then commit
 *
 ******************************************************************************/
HRESULT CDfsJnPt::EnumerateAllJnPts ( MethodContext *pMethodContext, DWORD dwPropertiesReq )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    PDFS_INFO_4 pData, p;
    DWORD er=0, tr=0, res = NERR_Success;

    // Call the NetDfsEnum function, specifying level 4.
    res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 4, -1, (LPBYTE *) &pData, &er, &tr);

    // If no error occurred,
    if(res==NERR_Success)
    {
        if ( pData != NULL )
        {
            try
            {
                p = pData;
                CInstancePtr pInstance;

                for ( int i = 0; i < er; i++, p++ )
                {
                    pInstance.Attach(CreateNewInstance( pMethodContext ));

                    hRes = LoadDfsJnPt ( dwPropertiesReq, pInstance, p, p == pData );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        hRes = pInstance->Commit();

                        if ( FAILED ( hRes ) )
                        {
                            break;
                        }
                    }
                }
            }
            catch ( ... )
            {
                NetApiBufferFree(pData);
                throw;
            }
            NetApiBufferFree(pData);
        }
    }
    else if ( (res != ERROR_NO_MORE_ITEMS) && (res != ERROR_NO_SUCH_DOMAIN) && (res != ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
    {
        hRes = WBEM_E_FAILED;
    }
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::FindAndSetDfsEntry
 *
 *  DESCRIPTION :   Finds an entry matching the dfsEntryPath and loads the
 *                  Instance if found or acts based on the Operation passed
 *
 ******************************************************************************/
HRESULT CDfsJnPt::FindAndSetDfsEntry ( LPCWSTR a_Key, DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    PDFS_INFO_4 pData, p;
    DWORD er=0, tr=0, res = NERR_Success;

    // Call the NetDfsEnum function, specifying level 4.
    res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 4, -1, (LPBYTE *) &pData, &er, &tr);

    // If no error occurred,
    if(res==NERR_Success)
    {
        if ( pData != NULL )
        {
            try
            {
                BOOL bFound = FALSE;
                p = pData;
                for ( int i = 0; i < er; i++, p++ )
                {
                    if ( _wcsicmp (a_Key, p->EntryPath ) == 0 )
                    {
                        bFound = TRUE;
                        break;
                    }
                }

                if ( bFound )
                {

                    switch ( eOperation )
                    {
                        case eGet :
                        {
                            if ( SUCCEEDED ( hRes ) )
                            {
                                hRes = LoadDfsJnPt ( dwPropertiesReq, pInstance, p, p == pData );
                            }
                            break;
                        }

                        case eDelete:
                        {
                            if ( SUCCEEDED ( hRes ) )
                            {
                                hRes = DeleteDfsJnPt ( p );
                            }
                            break;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_NOT_FOUND;
                }

            }
            catch ( ... )
            {
                NetApiBufferFree(pData);
                throw;
            }
            NetApiBufferFree(pData);
        }
        else
        {
            hRes = WBEM_E_NOT_FOUND;
        }
    }
    else if ( (res == ERROR_NO_MORE_ITEMS) || (res == ERROR_NO_SUCH_DOMAIN) || (res == ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
    {
        hRes = WBEM_E_NOT_FOUND;
    }
    else
    {
        hRes = WBEM_E_FAILED;
    }
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::LoadDfsJnPt
 *
 *  DESCRIPTION :   Loads a Dfs Junction point entry into the instance 
 *
 ******************************************************************************/

HRESULT CDfsJnPt::LoadDfsJnPt ( DWORD dwPropertiesReq, CInstance *pInstance, PDFS_INFO_4 pJnPtBuf, bool bRoot )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	if (NULL != pInstance)
	{
		if  ( dwPropertiesReq & DFSJNPT_PROP_DfsEntryPath )  
		{
			if ( pInstance->SetWCHARSplat ( DFSNAME, pJnPtBuf->EntryPath ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if ( pInstance->Setbool ( L"Root", bRoot ) == FALSE )
		{
			hRes = WBEM_E_FAILED;
		}

		if ( dwPropertiesReq & DFSJNPT_PROP_State ) 
		{
			// need to check the state and then valuemap
				DWORD dwState = 0;
				switch ( pJnPtBuf->State )
				{
					case DFS_VOLUME_STATE_OK :
					{
						dwState = 0;
						break;
					}

					case DFS_VOLUME_STATE_INCONSISTENT : 
					{
						dwState = 1;
						break;
					}

					case DFS_VOLUME_STATE_ONLINE : 
					{
						dwState = 2;
						break;
					}

					case DFS_VOLUME_STATE_OFFLINE :
					{
						dwState = 3;
						break;
					}
				}

			if ( pInstance->SetDWORD ( STATE, dwState ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if  ( dwPropertiesReq & DFSJNPT_PROP_Comment )
		{
			if ( pInstance->SetWCHARSplat ( COMMENT, pJnPtBuf->Comment ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if  ( dwPropertiesReq & DFSJNPT_PROP_Caption )
		{
			if ( pInstance->SetWCHARSplat ( CAPTION, pJnPtBuf->Comment ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}

		if  ( dwPropertiesReq & DFSJNPT_PROP_Timeout ) 
		{
			if ( pInstance->SetDWORD ( TIMEOUT, pJnPtBuf->Timeout ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}
	}
	else
	{
		if (0 != dwPropertiesReq)
		{
			hRes = WBEM_E_FAILED;
		}
	}

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::DeleteDfsJnPt
 *
 *  DESCRIPTION :   Deletes a Junction Pt if it exists
 *
 ******************************************************************************/
HRESULT CDfsJnPt::DeleteDfsJnPt ( PDFS_INFO_4 pDfsJnPt )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    NET_API_STATUS t_Status = NERR_Success;

    if ( IsDfsRoot ( pDfsJnPt->EntryPath ) )
    {
		if ((wcslen(pDfsJnPt->EntryPath) > 4) &&
			(pDfsJnPt->EntryPath[0] == pDfsJnPt->EntryPath[1]) &&
			(pDfsJnPt->EntryPath[0] == L'\\'))
		{
			wchar_t *pSlash = wcschr(&(pDfsJnPt->EntryPath[2]), L'\\');

			if (pSlash > &(pDfsJnPt->EntryPath[2]))
			{
				wchar_t *pServer = new wchar_t[pSlash - &(pDfsJnPt->EntryPath[2]) + 1];
				BOOL bRemove = FALSE;

				try
				{
					wcsncpy(pServer, &(pDfsJnPt->EntryPath[2]), pSlash - &(pDfsJnPt->EntryPath[2]));
					pServer[pSlash - &(pDfsJnPt->EntryPath[2])] = L'\0';

					if (0 == m_ComputerName.CompareNoCase(pServer))
					{
						bRemove = TRUE;
					}
					else
					{
						DWORD dwDnsName = 256;
						DWORD dwDnsNameSize = 256;
						wchar_t *pDnsName = new wchar_t[dwDnsName];

						try
						{
							while (!GetComputerNameEx(ComputerNamePhysicalDnsHostname, pDnsName, &dwDnsName))
							{
								if (GetLastError() != ERROR_MORE_DATA)
								{
									delete [] pDnsName;
									pDnsName = NULL;
									break;
								}
								else
								{
									delete [] pDnsName;
									pDnsName = NULL;
									dwDnsName = dwDnsNameSize * 2;
									dwDnsNameSize = dwDnsName;
									pDnsName = new wchar_t[dwDnsName];
								}
							}
						}
						catch (...)
						{
							if (pDnsName)
							{
								delete [] pDnsName;
								pDnsName = NULL;
							}

							throw;
						}

						if (pDnsName)
						{
							if (_wcsicmp(pDnsName, pServer) == 0)
							{
								bRemove = TRUE;
							}

							delete [] pDnsName;
							pDnsName = NULL;
						}
					}
				}
				catch(...)
				{
					if (pServer)
					{
						delete [] pServer;
					}

					throw;
				}

				if (bRemove)
				{
					t_Status = NetDfsRemoveStdRoot ( pDfsJnPt->Storage->ServerName, 
													pDfsJnPt->Storage->ShareName,
													0
													);
					if ( t_Status != NERR_Success )
					{
						hRes = WBEM_E_FAILED;
					}
				}
				else
				{
					//can't delete roots not on this machine
					hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
				}

				delete [] pServer;
			}
			else
			{
				hRes = WBEM_E_FAILED;
			}
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
    }
    else
    {
        // Apparently there is no way to explicitly remove a link.  However, if
        // you remove all the replicas, the link gets deleted automatically.
        for ( int StorageNo = 0; StorageNo < pDfsJnPt->NumberOfStorages; StorageNo++ )
        {       
            t_Status = NetDfsRemove ( 
                
                        pDfsJnPt->EntryPath,
                        pDfsJnPt->Storage[StorageNo].ServerName,
                        pDfsJnPt->Storage[StorageNo].ShareName
                  );

            if ( t_Status != NERR_Success ) 
            {
                hRes = WBEM_E_FAILED;
                break;
            }
        }
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::UpdateDfsJnPt
 *
 *  DESCRIPTION :   Adds / Modifies the Dfs Jn Pt
 *
 ******************************************************************************/
HRESULT CDfsJnPt::UpdateDfsJnPt ( const CInstance &Instance, DWORD dwOperation )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    NET_API_STATUS t_Status = NERR_Success;
        
    if ( SUCCEEDED ( hRes ) )
    {
        NET_API_STATUS t_Status = NERR_Success;
        CHString t_EntryPath;

        Instance.GetCHString ( DFSNAME, t_EntryPath );
        
        if ( dwOperation == eAdd )
        {
            hRes = WBEM_E_INVALID_PARAMETER;
        }
        else
        if ( dwOperation == eModify )
        {
            if ( t_Status == NERR_Success )
            {
                DWORD t_state;
                DFS_INFO_101 t_dfsStateData;

                if (Instance.GetDWORD ( STATE, t_state ))
                {
					switch ( t_state )
					{
						case 0 :
						{
							t_dfsStateData.State = DFS_STORAGE_STATE_ACTIVE;
							t_state = 1;
							break;
						}

						case 2 : 
						{
							t_dfsStateData.State = DFS_STORAGE_STATE_ONLINE;
							t_state = 1;
							break;
						}

						case 3 :
						{
							t_dfsStateData.State = DFS_STORAGE_STATE_OFFLINE;
							t_state = 1;
							break;
						}

						default :
						{
							hRes = WBEM_E_INVALID_PARAMETER ;
							t_state = 0;
							t_Status = ERROR_INVALID_PARAMETER;
						}
					}

					if (t_state)
					{
						t_Status = NetDfsSetInfo ( t_EntryPath.GetBuffer ( 0 ),
                                          NULL,
                                          NULL,
                                          101,
                                          (LPBYTE) &t_dfsStateData
                          );
					}
                }
            }

            CHString t_Comment;

            if (( t_Status == NERR_Success ) && (Instance.GetCHString ( COMMENT, t_Comment )))
            {
                DFS_INFO_100 t_dfsCommentData;
        
                t_dfsCommentData.Comment = t_Comment.GetBuffer( 0 );

                t_Status = NetDfsSetInfo ( t_EntryPath.GetBuffer ( 0 ),
                                      NULL,
                                      NULL,
                                      100,
                                      (LPBYTE) &t_dfsCommentData
                      );
            }

            if ( t_Status == NERR_Success )
            {
                DFS_INFO_102 t_dfsTimeoutData;

                if (Instance.GetDWORD ( TIMEOUT, t_dfsTimeoutData.Timeout))
                {
                    t_Status = NetDfsSetInfo ( t_EntryPath.GetBuffer ( 0 ),
                                              NULL,
                                              NULL,
                                              102,
                                              (LPBYTE) &t_dfsTimeoutData
                              );
                }
            }
        }

        if ((SUCCEEDED(hRes)) && ( t_Status != NERR_Success ))
        {
            hRes = WBEM_E_FAILED ;
        }
    }
    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::AddDfsJnPt
 *
 *  DESCRIPTION :   Adds the New Dfs Jn Pt 
 *
 ******************************************************************************/
NET_API_STATUS CDfsJnPt :: AddDfsJnPt ( 

    LPWSTR a_DfsEntry,
    LPWSTR a_ServerName,
    LPWSTR a_ShareName,
    LPWSTR a_Comment
)
{
    NET_API_STATUS t_Status = NERR_Success;
	wchar_t *t_slash = NULL;

	//simple analysis on the parameters...
	if ((a_ServerName == NULL) ||
		(a_ShareName == NULL) ||
		(a_ServerName[0] == L'\0') ||
		(a_ShareName[0] == L'\0') ||
		(a_DfsEntry == NULL) ||
		(wcslen(a_DfsEntry) < 5) ||
		(wcsncmp(a_DfsEntry, L"\\\\", 2) != 0))
	{
		t_Status = ERROR_INVALID_PARAMETER;
	}
	else
	{
		t_slash = wcschr((const wchar_t*)(&(a_DfsEntry[2])), L'\\');

		if ((t_slash == NULL) || (t_slash == &(a_DfsEntry[2])))
		{
			t_Status = ERROR_INVALID_PARAMETER;
		}
		else
		{
			//let's find the next slash if there is one...
			t_slash++;

			if ((*t_slash == L'\0') || (*t_slash == L'\\'))
			{
				t_Status = ERROR_INVALID_PARAMETER;
			}
			else
			{
				//if t_slash is null we have a root
				t_slash = wcschr(t_slash, L'\\');
			}
		}
	}

	if (t_Status == NERR_Success)
	{
		if ( t_slash )
		{
			// this is a a junction point other than the root
			t_Status = NetDfsAdd ( a_DfsEntry,
							  a_ServerName,
							  a_ShareName,
							  a_Comment,
							  DFS_ADD_VOLUME
				  );
		}
		else
		{
			// it is  DFSRoot
			DWORD dwErr = GetFileAttributes ( a_DfsEntry );

			if ( dwErr != 0xffffffff )
			{
				t_Status = NetDfsAddStdRoot ( a_ServerName,
							   a_ShareName,
							   a_Comment,
							   0
				  );
			}
			else
			{
				t_Status = GetLastError();
			}
		}
	}

    return t_Status;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::SetRequiredProperties
 *
 *  DESCRIPTION :   Sets the bitmap for the required properties
 *
 ******************************************************************************/
void CDfsJnPt::SetRequiredProperties ( CFrameworkQuery &Query, DWORD &dwPropertiesReq )
{
    dwPropertiesReq = 0;

    if ( Query.IsPropertyRequired  ( DFSNAME ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_DfsEntryPath;
    }

    if ( Query.IsPropertyRequired  ( STATE ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_State;
    }

    if ( Query.IsPropertyRequired  ( COMMENT ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_Comment;
    }

    if ( Query.IsPropertyRequired  ( TIMEOUT ) )
    {
        dwPropertiesReq |= DFSJNPT_PROP_Timeout;
    }
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPt::DfsRoot
 *
 *  DESCRIPTION :   Checks if the Dfs Jn Pt is a root.
 *
 ******************************************************************************/
BOOL CDfsJnPt::IsDfsRoot ( LPCWSTR lpKey )
{
    BOOL bRetVal = TRUE;
    int i = 0;

    if ( lpKey [ i ] == L'\\' )
    {
        i++;
    }

    if ( lpKey [ i ] == L'\\' )
    {
        i++;
    }

    while ( lpKey [ i ] != L'\\' )
    {
        i++;
    }

    i++;
    while ( lpKey [ i ] != L'\0' )
    {
        if ( lpKey [ i ] == L'\\' )
        {
            bRetVal = FALSE;
            break;
        }
        i++;
    }

    return bRetVal;
}

/*****************************************************************************
 *
 *  FUNCTION    : CDfsJnPt::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CDfsJnPt::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	long a_Flags
)
{
    HRESULT hr = WBEM_E_INVALID_METHOD;

    if (_wcsicmp(a_MethodName, L"Create") == 0)
    {
        CHString sDfsEntry, sServerName, sShareName, sDescription;

        if (a_InParams->GetCHString(DFSENTRYPATH, sDfsEntry) && sDfsEntry.GetLength() &&
            a_InParams->GetCHString(SERVERNAME, sServerName) && sServerName.GetLength() &&
            a_InParams->GetCHString(SHARENAME, sShareName) && sShareName.GetLength())
        {
			// At the point, the *wmi* method call has succeeded.  All that
			// remains is to determine the *class's* return code
			hr = WBEM_S_NO_ERROR;

            a_InParams->GetCHString(COMMENT, sDescription);

            NET_API_STATUS status = AddDfsJnPt ( 

                sDfsEntry.GetBuffer(0),
                sServerName.GetBuffer(0),
                sShareName.GetBuffer(0),
                sDescription.GetLength() > 0 ? sDescription.GetBuffer(0) : NULL
				);

            a_OutParams->SetDWORD(L"ReturnValue", status);            
        }
        else
        {
            hr = WBEM_E_INVALID_METHOD_PARAMETERS;
        }
   }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ws2_32api.cpp ===
//=================================================================

//

// Ws2_32Api.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>

#define INCL_WINSOCK_API_TYPEDEFS	1
#include <winsock2.h>

#include "DllWrapperBase.h"
#include "Ws2_32Api.h"
#include "DllWrapperCreatorReg.h"



// {643966A2-D19F-11d2-9120-0060081A46FD}
static const GUID g_guidWs2_32Api =
{0x643966a2, 0xd19f, 0x11d2, { 0x91, 0x20, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrWs2_32[] = _T("WS2_32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWs2_32Api, &g_guidWs2_32Api, g_tstrWs2_32> MyRegisteredWs2_32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CWs2_32Api::CWs2_32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnWSAStartUp(NULL),
   m_pfnWSAEnumProtocols(NULL),
   m_pfnWSAIoctl(NULL),
   m_pfnWSASocket(NULL),
   m_pfnBind(NULL),
   m_pfnCloseSocket(NULL),
   m_pfnWSACleanup(NULL),
   m_pfnWSAGetLastError(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CWs2_32Api::~CWs2_32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CWs2_32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnWSAStartUp = (LPFN_WSASTARTUP) GetProcAddress("WSAStartup");

        m_pfnWSAIoctl = (LPFN_WSAIOCTL) GetProcAddress("WSAIoctl");

        m_pfnBind = (LPFN_BIND) GetProcAddress("bind");

        m_pfnCloseSocket = (LPFN_CLOSESOCKET) GetProcAddress("closesocket");

        m_pfnWSACleanup = (LPFN_WSACLEANUP) GetProcAddress("WSACleanup");

        m_pfnWSAGetLastError = (LPFN_WSAGETLASTERROR)
                                        GetProcAddress("WSAGetLastError");

#ifdef NTONLY

        m_pfnWSAEnumProtocols = (LPFN_WSAENUMPROTOCOLS)
                                      GetProcAddress("WSAEnumProtocolsW");

        m_pfnWSASocket = (LPFN_WSASOCKET) GetProcAddress("WSASocketW");
#endif

#ifdef WIN9XONLY

        m_pfnWSAEnumProtocols = (LPFN_WSAENUMPROTOCOLS) GetProcAddress(
                                                    "WSAEnumProtocolsA");

        m_pfnWSASocket = (LPFN_WSASOCKET) GetProcAddress("WSASocketA");

#endif


        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        if(m_pfnWSAStartUp == NULL ||
           m_pfnWSAIoctl == NULL ||
           m_pfnBind == NULL ||
           m_pfnCloseSocket == NULL ||
           m_pfnWSACleanup == NULL ||
           m_pfnWSAGetLastError == NULL ||
           m_pfnWSAEnumProtocols == NULL ||
           m_pfnWSASocket == NULL)
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in ws2_32api");
        }
		else
		{
			fRet = true;
		}
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Ws2_32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
int CWs2_32Api::WSAStartUp
(
    WORD a_wVersionRequested,
    LPWSADATA a_lpWSAData
)
{
    return m_pfnWSAStartUp(a_wVersionRequested, a_lpWSAData);
}

int CWs2_32Api::WSAEnumProtocols
(
    LPINT a_lpiProtocols,
    LPWSAPROTOCOL_INFO a_lpProtocolBuffer,
    LPDWORD a_lpdwBufferLength
)
{
    return m_pfnWSAEnumProtocols(a_lpiProtocols, a_lpProtocolBuffer,
                                 a_lpdwBufferLength);
}

int CWs2_32Api::WSAIoctl
(
    SOCKET a_s,
    DWORD a_dwIoControlCode,
    LPVOID a_lpvInBuffer,
    DWORD a_cbInBuffer,
    LPVOID a_lpvOutBuffer,
    DWORD a_cbOutBuffer,
    LPDWORD a_lpcbBytesReturned,
    LPWSAOVERLAPPED a_lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE a_lpCompletionRoutine
)
{
    return m_pfnWSAIoctl(a_s,
                         a_dwIoControlCode,
                         a_lpvInBuffer,
                         a_cbInBuffer,
                         a_lpvOutBuffer,
                         a_cbOutBuffer,
                         a_lpcbBytesReturned,
                         a_lpOverlapped,
                         a_lpCompletionRoutine);
}

SOCKET CWs2_32Api::WSASocket
(
    int a_af,
    int a_type,
    int a_protocol,
    LPWSAPROTOCOL_INFO a_lpProtocolInfo,
    GROUP a_g,
    DWORD a_dwFlags
)
{
    return m_pfnWSASocket(a_af,
                          a_type,
                          a_protocol,
                          a_lpProtocolInfo,
                          a_g,
                          a_dwFlags);
}

int CWs2_32Api::Bind
(
    SOCKET a_s,
    const struct sockaddr FAR * a_name,
    int a_namelen
)
{
    return m_pfnBind(a_s, a_name, a_namelen);
}

int CWs2_32Api::CloseSocket
(
    SOCKET a_s
)
{
    return m_pfnCloseSocket(a_s);
}

int CWs2_32Api::WSACleanup()
{
    return m_pfnWSACleanup();
}

int CWs2_32Api::WSAGetLastError()
{
    return m_pfnWSAGetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wsock32api.cpp ===
//=================================================================

//

// Wsock32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "Wsock32Api.h"
#include "DllWrapperCreatorReg.h"

// {D60E9C22-D127-11d2-911F-0060081A46FD}
static const GUID g_guidWsock32Api =
{0xd60e9c22, 0xd127, 0x11d2, {0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrWsock32[] = _T("WSOCK32.DLL");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CWsock32Api, &g_guidWsock32Api, g_tstrWsock32> MyRegisteredWsock32Wrapper;

/******************************************************************************
 * Constructor
 ******************************************************************************/
CWsock32Api::CWsock32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnWsControl(NULL),
   m_pfnWsEnumProtocols(NULL),
   m_pfnWsCloseSocket(NULL),
   m_pfnWsStartup(NULL),
   m_pfnWsCleanup(NULL) ,
   m_pfnWsGetSockopt(NULL) ,
   m_pfnWsBind(NULL),
   m_pfnWsSocket(NULL),
   m_pfnWsWSAGetLastError(NULL),
   m_pfnWsInet_NtoA(NULL)
{
}

/******************************************************************************
 * Destructor
 ******************************************************************************/
CWsock32Api::~CWsock32Api()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CWsock32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef WIN9XONLY
        m_pfnWsControl = (PFN_WSOCK32_WSCONTROL) GetProcAddress("WsControl");
		m_pfnWsEnumProtocols = (PFN_WSOCK32_ENUMPROTOCOLS) GetProcAddress("EnumProtocolsA");
		m_pfnWsStartup = (PFN_WSOCK32_STARTUP) GetProcAddress("WSAStartup");
		m_pfnWsCleanup = (PFN_WSOCK32_CLEANUP) GetProcAddress("WSACleanup");
		m_pfnWsCloseSocket = (PFN_WSOCK32_CLOSESOCKET) GetProcAddress("closesocket");
		m_pfnWsGetSockopt = ( PFN_WSOCK32_GETSOCKOPT ) GetProcAddress("getsockopt");
		m_pfnWsBind = ( PFN_WSOCK32_BIND ) GetProcAddress("bind");
		m_pfnWsSocket = ( PFN_WSOCK32_SOCKET )GetProcAddress("socket");;
		m_pfnWsWSAGetLastError = ( PFN_WSOCK32_WSAGETLASTERROR )GetProcAddress("WSAGetLastError"); ;
		m_pfnWsInet_NtoA = ( PFN_WSOCK32_INET_NTOA )GetProcAddress("inet_ntoa"); ;

	    // Check that we have function pointers to functions that should be
        // present...

        if ( m_pfnWsControl == NULL ||
			 m_pfnWsEnumProtocols == NULL ||
			 m_pfnWsStartup == NULL ||
			 m_pfnWsCleanup == NULL ||
			 m_pfnWsCloseSocket == NULL ||
			 m_pfnWsGetSockopt == NULL ||
			 m_pfnWsBind == NULL ||
			 m_pfnWsSocket == NULL ||
			 m_pfnWsWSAGetLastError == NULL ||
			 m_pfnWsInet_NtoA == NULL )
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in wsock32api");
        }
#else
		m_pfnWsEnumProtocols = (PFN_WSOCK32_ENUMPROTOCOLS) GetProcAddress("EnumProtocolsW");
		m_pfnWsStartup = (PFN_WSOCK32_STARTUP) GetProcAddress("WSAStartup");
		m_pfnWsCleanup = (PFN_WSOCK32_CLEANUP) GetProcAddress("WSACleanup");
		m_pfnWsCloseSocket = (PFN_WSOCK32_CLOSESOCKET) GetProcAddress("closesocket");
		m_pfnWsGetSockopt = ( PFN_WSOCK32_GETSOCKOPT ) GetProcAddress("getsockopt");
		m_pfnWsBind = ( PFN_WSOCK32_BIND ) GetProcAddress("bind");
		m_pfnWsSocket = ( PFN_WSOCK32_SOCKET )GetProcAddress("socket");;
		m_pfnWsWSAGetLastError = ( PFN_WSOCK32_WSAGETLASTERROR )GetProcAddress("WSAGetLastError"); ;
		m_pfnWsInet_NtoA = ( PFN_WSOCK32_INET_NTOA )GetProcAddress("inet_ntoa"); ;

        if ( m_pfnWsEnumProtocols == NULL ||
			 m_pfnWsStartup == NULL ||
			 m_pfnWsCleanup == NULL ||
			 m_pfnWsCloseSocket == NULL ||
	 		 m_pfnWsGetSockopt == NULL ||
			 m_pfnWsBind == NULL ||
			 m_pfnWsSocket == NULL ||
			 m_pfnWsWSAGetLastError == NULL ||
			 m_pfnWsInet_NtoA == NULL )
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in wsock32api");
        }

#endif

    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Wsock32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
bool CWsock32Api::WsControl
(
    DWORD a_dw1,
    DWORD a_dw2,
    LPVOID a_lpv1,
    LPDWORD a_lpdw1,
    LPVOID a_lpv2,
    LPDWORD a_lpdw2,
    DWORD *a_pdwRetval
)
{
    bool t_fExists = false;
    if(m_pfnWsControl != NULL)
    {
        DWORD t_dwTemp = m_pfnWsControl(a_dw1, a_dw2, a_lpv1,
                                        a_lpdw1, a_lpv2, a_lpdw2);

        t_fExists = true;

        if(a_pdwRetval != NULL)
        {
            *a_pdwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

INT CWsock32Api::WsEnumProtocols (

	LPINT lpiProtocols,
	LPVOID lpProtocolBuffer,
	LPDWORD lpdwBufferLength
)
{
	return 	m_pfnWsEnumProtocols (

		lpiProtocols,
		lpProtocolBuffer,
		lpdwBufferLength
	) ;
}

INT CWsock32Api :: WsWSAStartup (

	IN WORD wVersionRequired,
	OUT LPWSADATA lpWSAData
)
{
	return m_pfnWsStartup (

		wVersionRequired ,
		lpWSAData
	) ;
}

INT CWsock32Api :: WsWSACleanup ()
{
	return m_pfnWsCleanup () ;
}

INT CWsock32Api :: Wsclosesocket ( SOCKET s )
{
	return m_pfnWsCloseSocket ( s ) ;
}

int CWsock32Api :: Wsbind (

	SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
)
{
	return m_pfnWsBind (

		s,
		addr,
		namelen
	) ;
}

int CWsock32Api :: Wsgetsockopt (

   SOCKET s,
   int level,
   int optname,
   char FAR * optval,
   int FAR *optlen
)
{
	return m_pfnWsGetSockopt (

		s,
		level,
		optname,
		optval,
		optlen
	) ;
}

SOCKET CWsock32Api :: Wssocket (

	int af,
	int type,
	int protocol
)
{
	return m_pfnWsSocket (

		af,
		type,
		protocol
	) ;
}

int CWsock32Api :: WsWSAGetLastError(void)
{
	return m_pfnWsWSAGetLastError () ;
}

char *CWsock32Api :: Wsinet_ntoa (

	struct in_addr in
)
{
	return m_pfnWsInet_NtoA (

		in
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <initguid.h>
#include <fwcommon.h>
#include <smartptr.h>
#include <objpath.h>

// for dfs structures
#include <lm.h>
#include <lmdfs.h>

#include "Dfscommon.h"
#include "DFSJnPtReplicaAsso.h"
#include "DfsReplica.h"
#include "DfsJnPt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\dfsreplica.cpp ===
/******************************************************************

   DfsReplica.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   DESCRIPTION DFS Provider
  
******************************************************************/

#include "precomp.h"

CDfsReplica MyCDFSReplicaSet ( 

    PROVIDER_NAME_DFSREPLICA , 
    Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::CDfsReplica
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CDfsReplica :: CDfsReplica (

    LPCWSTR lpwszName, 
    LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{   
    m_ComputerName = GetLocalComputerName();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::~CDfsReplica
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CDfsReplica :: ~CDfsReplica ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsReplica::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CDfsReplica :: EnumerateInstances (

    MethodContext *pMethodContext, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    DWORD dwPropertiesReq = DFSREPLICA_ALL_PROPS;

    hRes = EnumerateAllReplicas ( pMethodContext, dwPropertiesReq );

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsReplica::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CDfsReplica :: GetObject (

    CInstance *pInstance, 
    long lFlags,
    CFrameworkQuery& Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Link ;
    CHString t_Server;
    CHString t_Share;

    hRes = GetKeys(pInstance, t_Link, t_Server, t_Share);

    if ( SUCCEEDED ( hRes ) )
    {
        if ( Query.AllPropertiesAreRequired() )
        {
            dwPropertiesReq = DFSREPLICA_ALL_PROPS;
        }
        else
        {
            if ( Query.IsPropertyRequired  ( LINKNAME ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_LinkName;
            }

            if ( Query.IsPropertyRequired  ( SERVERNAME ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_ServerName;
            }

            if ( Query.IsPropertyRequired  ( SHARENAME ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_ShareName;
            }

            if ( Query.IsPropertyRequired  ( STATE ) )
            {
                dwPropertiesReq |= DFSREPLICA_PROP_State;
            }
        }

        bool bRoot = false;

        hRes = FindAndSetDfsReplica ( t_Link, t_Server, t_Share, dwPropertiesReq, pInstance, eGet, bRoot );
    }

    return hRes ;
}


/*****************************************************************************
*
*  FUNCTION    : CDfsReplica::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*****************************************************************************/

HRESULT CDfsReplica :: PutInstance  (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Link ;
    CHString t_Server;
    CHString t_Share;
    bool bRoot = false;

    // Get the Compound Key
    hRes = GetKeys(&Instance, t_Link, t_Server, t_Share);

    if ( SUCCEEDED ( hRes ) )
    {
        hRes = FindAndSetDfsReplica ( t_Link, t_Server, t_Share, dwPropertiesReq, NULL, eAdd, bRoot );
    }

    bool bFound;
    
    if (SUCCEEDED(hRes))
    {
        bFound = true;
    }
    else if (hRes == WBEM_E_NOT_FOUND)
    {
        bFound = false;
        hRes = WBEM_S_NO_ERROR;
    }

    if (SUCCEEDED(hRes))
    {
        DWORD dwOperationsReq = (WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY);

        switch ( lFlags & dwOperationsReq )
        {
            case WBEM_FLAG_CREATE_OR_UPDATE:
            {
                if (bFound)
                {
                    DFS_INFO_101 dfs101;

                    // If the Get fails, assume it is NULL
                    DWORD dwState;

                    if (Instance.GetDWORD(STATE, dwState))
                    {
                        NET_API_STATUS t_Status = NERR_Success;

                        switch (dwState)
                        {
                            case 0:
                            {
                                dfs101.State = DFS_STORAGE_STATE_OFFLINE;
                                break;                                    
                            }

                            case 1:
                            {
                                dfs101.State = DFS_STORAGE_STATE_ONLINE;
                                break;                                    
                            }
                        }

                        t_Status = NetDfsSetInfo ( 
                                    t_Link.GetBuffer ( 0 ),
                                    t_Server.GetBuffer ( 0 ),
                                    t_Share.GetBuffer ( 0 ),
                                    101,
                                    (LPBYTE)&dfs101
                                );

                        if (t_Status == NERR_Success)
                        {
                            hRes = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            hRes = WBEM_E_FAILED;
                        }
                    }
                    else
                    {
                        hRes = WBEM_S_NO_ERROR;
                    }
                }
                else
                {
                    if (NetDfsAdd ( 
                                    t_Link.GetBuffer ( 0 ),
                                    t_Server.GetBuffer ( 0 ),
                                    t_Share.GetBuffer ( 0 ),
                                    L"",
                                    0
                                ) == NERR_Success)
                    {
                        hRes = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }

                break;
            }

            case WBEM_FLAG_CREATE_ONLY:
            {
                if (!bFound)
                {
                    if (NetDfsAdd ( 
                                    t_Link.GetBuffer ( 0 ),
                                    t_Server.GetBuffer ( 0 ),
                                    t_Share.GetBuffer ( 0 ),
                                    L"",
                                    0
                                ) == NERR_Success)
                    {
                        hRes = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }
                else
                {
                    hRes = WBEM_E_ALREADY_EXISTS;
                }

                break;
            }

            case WBEM_FLAG_UPDATE_ONLY:
            {
                if (bFound)
                {
                    DFS_INFO_101 dfs101;

                    // If the Get fails, assume it is NULL
                    DWORD dwState;

                    if (Instance.GetDWORD(STATE, dwState))
                    {
                        NET_API_STATUS t_Status = NERR_Success;

                        switch (dwState)
                        {
                            case 0:
                            {
                                dfs101.State = DFS_STORAGE_STATE_OFFLINE;
                                break;                                    
                            }

                            case 1:
                            {
                                dfs101.State = DFS_STORAGE_STATE_ONLINE;
                                break;                                    
                            }
                        }

                        t_Status = NetDfsSetInfo ( 
                                    t_Link.GetBuffer ( 0 ),
                                    t_Server.GetBuffer ( 0 ),
                                    t_Share.GetBuffer ( 0 ),
                                    101,
                                    (LPBYTE)&dfs101
                                );

                        if (t_Status == NERR_Success)
                        {
                            hRes = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            hRes = WBEM_E_FAILED;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_NOT_FOUND;
                }

                break;
            }
        }
    }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CDfsReplica::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*****************************************************************************/

HRESULT CDfsReplica :: DeleteInstance (

    const CInstance &Instance, 
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq = 0;
    CHString t_Link ;
    CHString t_Server;
    CHString t_Share;
    bool bRoot = false;

    // Get the Compound Key
    hRes = GetKeys(&Instance, t_Link, t_Server, t_Share);

    if ( SUCCEEDED ( hRes ) )
    {
        hRes = FindAndSetDfsReplica ( t_Link, t_Server, t_Share, dwPropertiesReq, NULL, eDelete, bRoot );
    }

    if ( SUCCEEDED ( hRes ) )
    {
        NET_API_STATUS t_Status = NERR_Success;

        if (!bRoot)
        {
            t_Status = NetDfsRemove(
                    t_Link.GetBuffer(0),
                    t_Server.GetBuffer(0),
                    t_Share.GetBuffer(0)
                );

			if ( t_Status != NERR_Success )
			{
				hRes = WBEM_E_FAILED;
			}
        }
        else
        {
			wchar_t *pEntryPath = t_Link.GetBuffer(0);

			if ((wcslen(pEntryPath) > 4) &&
				(pEntryPath[0] == pEntryPath[1]) &&
				(pEntryPath[0] == L'\\'))
			{
				wchar_t *pSlash = wcschr(&(pEntryPath[2]), L'\\');

				if (pSlash > &(pEntryPath[2]))
				{
					wchar_t *pServer = new wchar_t[pSlash - &(pEntryPath[2]) + 1];
					BOOL bRemove = FALSE;

					try
					{
						wcsncpy(pServer, &(pEntryPath[2]), pSlash - &(pEntryPath[2]));
						pServer[pSlash - &(pEntryPath[2])] = L'\0';

						if (0 == m_ComputerName.CompareNoCase(pServer))
						{
							bRemove = TRUE;
						}
						else
						{
							DWORD dwDnsName = 256;
							DWORD dwDnsNameSize = 256;
							wchar_t *pDnsName = new wchar_t[dwDnsName];

							try
							{
								while (!GetComputerNameEx(ComputerNamePhysicalDnsHostname, pDnsName, &dwDnsName))
								{
									if (GetLastError() != ERROR_MORE_DATA)
									{
										delete [] pDnsName;
										pDnsName = NULL;
										break;
									}
									else
									{
										delete [] pDnsName;
										pDnsName = NULL;
										dwDnsName = dwDnsNameSize * 2;
										dwDnsNameSize = dwDnsName;
										pDnsName = new wchar_t[dwDnsName];
									}
								}
							}
							catch (...)
							{
								if (pDnsName)
								{
									delete [] pDnsName;
									pDnsName = NULL;
								}

								throw;
							}

							if (pDnsName)
							{
								if (_wcsicmp(pDnsName, pServer) == 0)
								{
									bRemove = TRUE;
								}

								delete [] pDnsName;
								pDnsName = NULL;
							}
						}
					}
					catch(...)
					{
						if (pServer)
						{
							delete [] pServer;
						}

						throw;
					}

					if (bRemove)
					{
						t_Status = NetDfsRemoveStdRoot(
								t_Server.GetBuffer(0),
								t_Share.GetBuffer(0),
								0
							);

						if ( t_Status != NERR_Success )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					else
					{
						//can't delete roots not on this machine
						hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
					}

					delete [] pServer;
				}
				else
				{
					hRes = WBEM_E_FAILED;
				}
			}
			else
			{
				hRes = WBEM_E_FAILED;
			}
        }
    }

    return hRes ;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::EnumerateAllReplicas
 *
 *  DESCRIPTION :   Enumerates all the Dfs Replicas of all junction points
 *
 ******************************************************************************/
HRESULT CDfsReplica::EnumerateAllReplicas ( MethodContext *pMethodContext, DWORD dwPropertiesReq )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    PDFS_INFO_4 pData, p;
    DWORD er=0, tr=0, res = NERR_Success;
    PDFS_STORAGE_INFO pRepBuf;

    // Call the NetDfsEnum function, specifying level 4.
    res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 4, 0xFFFFFFFF, (LPBYTE *) &pData, &er, &tr);

    BOOL bLoadReplicaFailure = FALSE;
    // If no error occurred,
    if(res==NERR_Success)
    {
        if ( pData != NULL )
        {
            try
            {
                p = pData;

                CInstancePtr pInstance;

                // Walk each link
                for ( int i = 0; i < er; i++, p++ )
                {
                    // Walk all the replicas on each link
                    pRepBuf = p->Storage;
                    for ( int j = 0; j <  p->NumberOfStorages; j++, pRepBuf++ )
                    {
                        pInstance.Attach(CreateNewInstance( pMethodContext ));

                        hRes = LoadDfsReplica ( dwPropertiesReq, pInstance, p->EntryPath, pRepBuf );
                        if ( SUCCEEDED ( hRes ) )
                        {
                            hRes = pInstance->Commit();
                            if ( FAILED ( hRes ) )
                            {
                                break;
                            }
                        }
                        else
                        {
                            bLoadReplicaFailure = TRUE;
                        }
                    }

                    if ( FAILED ( hRes ) )
                    {
                        break;
                    }
                }
            }
            catch ( ... )
            {
                NetApiBufferFree(pData);
                throw;
            }
            NetApiBufferFree(pData);
        }
    }
    else
    {
        if ( (res != ERROR_NO_MORE_ITEMS) && (res != ERROR_NO_SUCH_DOMAIN) && (res != ERROR_NOT_FOUND) ) // Check to see if there are ANY roots
        {
            hRes = WBEM_E_FAILED;
        }
        // No replicas
        else if (res == ERROR_NO_MORE_ITEMS)
        {
            hRes = WBEM_S_NO_ERROR;
        }
    }

    if ( bLoadReplicaFailure )
    {
        hRes = WBEM_E_PROVIDER_FAILURE;
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::FindAndSetDfsReplica
 *
 *  DESCRIPTION :   Finds an entry matching the dfsEntryPath and loads the
 *                  Instance if found or acts based on the Operation passed
 *
 ******************************************************************************/
HRESULT CDfsReplica::FindAndSetDfsReplica ( LPCWSTR a_EntryPath, LPCWSTR a_ServerName, LPCWSTR a_ShareName, 
                                             DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation, bool &bRoot )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    PDFS_INFO_4 pData, p;
    DWORD er=0, tr=0, res = NERR_Success;
    PDFS_STORAGE_INFO pRepBuf;

    // Call the NetDfsEnum function, specifying level 4.
    res = NetDfsEnum( m_ComputerName.GetBuffer ( 0 ), 4, 0xFFFFFFFF, (LPBYTE *) &pData, &er, &tr);

    // If no error occurred,
    if(res==NERR_Success)
    {
        if ( pData != NULL )
        {
            try
            {
                BOOL bFound = FALSE;
                p = pData;
                for ( int i = 0; i < er; i++, p++ )
                {
                    if ( _wcsicmp ( a_EntryPath, p->EntryPath ) == 0 )
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                
                if ( bFound  )
                {
                    bFound = FALSE;
                    pRepBuf = p->Storage;
                    for ( int j = 0; j < p->NumberOfStorages;  j++, pRepBuf++ )
                    {
                        if ( ( _wcsicmp(a_ServerName, pRepBuf->ServerName ) == 0 ) && 
                            ( _wcsicmp(a_ShareName, pRepBuf->ShareName ) == 0 ) )
                        {
                            bFound = TRUE;
                            bRoot = (pData == p);
                            break;
                        }
                    }
                }

                if ( bFound == FALSE )
                {
                    hRes = WBEM_E_NOT_FOUND;
                }

                switch ( eOperation )
                {
                    case eGet :     
                    {
                        if ( SUCCEEDED ( hRes ) )
                        {
                            hRes = LoadDfsReplica ( dwPropertiesReq, pInstance, p->EntryPath, pRepBuf );
                        }
                        break;
                    }

                    case eDelete:   
                    {
                        break;
                    }

                    case eAdd:      
                    {
                        break;
                    }
                } 
            }
            catch ( ... )
            {
                NetApiBufferFree(pData);
                throw;
            }
            NetApiBufferFree(pData);
        }
        else
        {
            hRes = WBEM_E_NOT_FOUND;
        }
    }
    else
    {
        // No replicas
        if ((res == ERROR_NO_MORE_ITEMS) || (res == ERROR_NOT_FOUND) || (res == ERROR_NO_SUCH_DOMAIN))
        {
            hRes = WBEM_E_NOT_FOUND;
        }
        else
        {
            hRes = WBEM_E_FAILED;
        }
    }

    return hRes;
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsReplica::LoadDfsReplica
 *
 *  DESCRIPTION :   Loads a Dfs Replica into the instance 
 *
 ******************************************************************************/

HRESULT CDfsReplica::LoadDfsReplica ( DWORD dwPropertiesReq, CInstance *pInstance, LPWSTR  lpLinkName, PDFS_STORAGE_INFO pRepBuf )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if  ( dwPropertiesReq & DFSREPLICA_PROP_LinkName )
    {
        if ( pInstance->SetCHString ( LINKNAME, lpLinkName ) == FALSE )
        {
            hRes = WBEM_E_FAILED;
        }
    }

    if  ( dwPropertiesReq & DFSREPLICA_PROP_ServerName )
    {
        if ( pInstance->SetCHString ( SERVERNAME, pRepBuf->ServerName ) == FALSE )
        {
            hRes = WBEM_E_FAILED;
        }
    }

    if  ( dwPropertiesReq & DFSREPLICA_PROP_ShareName )
    {
        if ( pInstance->SetCHString ( SHARENAME, pRepBuf->ShareName ) == FALSE )
        {
            hRes = WBEM_E_FAILED;
        }
    }

    if  ( dwPropertiesReq & DFSREPLICA_PROP_State )
    {
        // need to check the state and then valuemap
        DWORD dwState = 0xffff;
        switch ( pRepBuf->State )
        {
            case DFS_STORAGE_STATE_OFFLINE : 
            {
                dwState = 0;
                break;
            }

            case DFS_STORAGE_STATE_ONLINE : 
            {
                dwState = 1;
                break;
            }

            case DFS_STORAGE_STATE_ACTIVE : 
            {
                dwState = 2;
                break;
            }
        }

        if ( !pInstance->SetDWORD ( STATE, dwState ) )
        {
            hRes = WBEM_E_FAILED;
        }
    }       
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDfsReplica::GetKeys
*
*  DESCRIPTION :    Get the multi part key
*
*****************************************************************************/

HRESULT CDfsReplica::GetKeys(const CInstance *pInstance, CHString &sLink, CHString &sServer, CHString &sShare)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get the Compound Key
    if ( !pInstance->GetCHString ( LINKNAME , sLink ) ||
         !pInstance->GetCHString ( SERVERNAME , sServer ) ||
         !pInstance->GetCHString ( SHARENAME , sShare ) )
    {
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <brodcast.h>

HMODULE ghModule;

// {7F72CC7A-74A0-45b4-909C-14FB8186DD7E}
DEFINE_GUID(CLSID_CIPDFSTABLE,
0x7f72cc7a, 0x74a0, 0x45b4, 0x90, 0x9c, 0x14, 0xfb, 0x81, 0x86, 0xdd, 0x7e);

#define PROVIDER_NAME L"WMIPDFS"

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_CIPDFSTABLE == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    SCODE sc = S_FALSE;

    try
    {
        sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM IP DFS Provider"), CLSID_CIPDFSTABLE ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CIPDFSTABLE ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;
    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet ;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DFS.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <binding.h>

CBinding MyDFSJnptReplica(
    PROVIDER_NAME_DFSJNPTREPLICA,
    Namespace,
    PROVIDER_NAME_DFSJNPT,
    PROVIDER_NAME_DFSREPLICA,
    L"Dependent",
    L"Antecedent",
    L"Name",
    L"LinkName");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfsjnpt.h ===
/******************************************************************



   DFSJnPt.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Class definition of DFS Junction Point/Links provider
			    Class
   
*******************************************************************/

#ifndef  _CDFSJNPT_H_
#define  _CDFSJNPT_H_

// Bitmaps for the properties
#define DFSJNPT_ALL_PROPS					0xFFFFFFFF
#define DFSJNPT_PROP_DfsEntryPath			0x00000001
//#define DFSJNPT_PROP_NoOfStorages			0x00000002
//#define DFSJNPT_PROP_ServerName				0x00000004
//#define DFSJNPT_PROP_ShareName				0x00000008
#define DFSJNPT_PROP_State					0x00000010
#define DFSJNPT_PROP_Comment				0x00000020
#define DFSJNPT_PROP_Timeout				0x00000040
#define DFSJNPT_PROP_Caption				0x00000080

// #defines for the property names	
#define DFSNAME         					L"Name"
#define DFSENTRYPATH						L"DFSENTRYPATH"
#define SERVERNAME							L"SERVERNAME"
#define SHARENAME							L"SHARENAME"
#define STATE								L"STATE"
#define COMMENT								L"Description"
#define TIMEOUT								L"TIMEOUT"
#define LINKNAME							L"LinkName"
#define CAPTION								L"Caption"

class CDfsJnPt : public Provider 
{
private:

	HRESULT EnumerateAllJnPts ( MethodContext *pMethodContext, DWORD dwPropertiesReq );
	HRESULT FindAndSetDfsEntry ( LPCWSTR a_Key, DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation  );
	HRESULT DeleteDfsJnPt ( PDFS_INFO_4 pJnPtBuf );
	HRESULT UpdateDfsJnPt ( const CInstance &Instance, DWORD dwOperation );
	NET_API_STATUS AddDfsJnPt ( LPWSTR a_DfsEntry, LPWSTR a_ServerName, LPWSTR a_ShareName, LPWSTR a_Comment );
	HRESULT LoadDfsJnPt ( DWORD dwPropertiesReq, CInstance *pInstance, PDFS_INFO_4 pJnPtBuf, bool bRoot );
	void SetRequiredProperties ( CFrameworkQuery &Query, DWORD &dwPropertiesReq );

	HRESULT CheckParameters ( const CInstance &a_Instance ,int iStatus ) ;
	BOOL IsDfsRoot ( LPCWSTR lpKey );

protected:

    HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
    HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &Query ) ;

    HRESULT PutInstance ( const CInstance& Instance, long lFlags = 0L ) ;
    HRESULT DeleteInstance ( const CInstance& Instance, long lFlags = 0L) ;

    HRESULT ExecMethod (

	    const CInstance& a_Instance,
	    const BSTR a_MethodName ,
	    CInstance *a_InParams ,
	    CInstance *a_OutParams ,
	    long a_Flags
    );

public:

    CDfsJnPt ( LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace ) ;
    virtual ~CDfsJnPt () ;

private:

	CHString m_ComputerName;
	enum { eGet, eDelete, eModify, eAdd, eUpdate };
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\dskquotacommon.cpp ===
/******************************************************************

   DskCommonRoutines.CPP -- 



   Description: Common routines that are used by all the three 

				classes of Disk Quota Provider

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
#include "precomp.h"
#include "DskQuotaCommon.h"

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: GetVolume
*
*  DESCRIPTION :    This method Parses the key and gets the Volume from
*					the Object Path. The input of this method could be 
*					Logical Disk key which is on the form "D:" or could 
*					receive volume Path which is in the form "D:\"
*                   
*****************************************************************************/
HRESULT DskCommonRoutines::GetVolume ( 
									   
	LPCWSTR a_Key, 
	WCHAR &a_Drive
)
{
	HRESULT hRes = WBEM_E_INVALID_PARAMETER;
	CObjectPathParser t_PathParser;
	ParsedObjectPath  *t_ObjPath = NULL;

    if ( t_PathParser.Parse( a_Key, &t_ObjPath )  == t_PathParser.NoError )
	{
		try
		{
			CHString t_KeyString = t_ObjPath->GetKeyString();	
			// checking for the validity of the path
			if ( ( t_KeyString.GetLength() == 3 )  || (t_KeyString.GetLength() == 2 ) )
			{
				if ( (( t_KeyString.GetAt(0) >= L'A') && ( t_KeyString.GetAt(0) <= L'Z')) || (( t_KeyString.GetAt(0) >= L'a') && ( t_KeyString.GetAt(0) <= L'z') ) )	
				{
					if ( t_KeyString.GetAt(1)  == L':' ) 
					{
						if ( t_KeyString.GetLength() == 3 )
						{
							if ( t_KeyString.GetAt(2)  == L'\\' )
							{
								hRes = WBEM_S_NO_ERROR;
							}
						}
						else
						{
							hRes = WBEM_S_NO_ERROR;
						}
						a_Drive = t_KeyString.GetAt(0);
					}
				}
			}
		}
		catch ( ... )
		{
			t_PathParser.Free ( t_ObjPath );
			throw;
		}
		t_PathParser.Free ( t_ObjPath );
	}						
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: SearchLogicalDisk
*
*  DESCRIPTION :    This method Searches whether a given Logical disks exists
*					in the logicaldisks strings of the system
*                   
*****************************************************************************/
HRESULT DskCommonRoutines::SearchLogicalDisk ( 
											  
	WCHAR a_Drive, 
	LPCWSTR a_DriveStrings 
)
{
	int iLen = 0;
	LPCWSTR lpTempDriveString = a_DriveStrings;
	HRESULT hRes = WBEM_S_NO_ERROR;
    a_Drive = (WCHAR)toupper(a_Drive);

	while ( true )
	{
		iLen = lstrlen ( lpTempDriveString );
		if ( iLen == 0 )
		{
			hRes = WBEM_E_NOT_FOUND;
			break;
		}

		if ( lpTempDriveString [ 0 ] == a_Drive )
			break;

		lpTempDriveString = &lpTempDriveString [ iLen + 1 ]; 		
	}
	
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: GetVolumeDrive
*
*  DESCRIPTION :    Gets the Volume Drive from the Given Path
*                   
*****************************************************************************/
void DskCommonRoutines::GetVolumeDrive ( 
				
	LPCWSTR a_VolumePath, 
	LPCWSTR a_DriveStrings,
	CHString &a_DriveName
)
{
	int iLen = 0;
    WCHAR w_Drive[ 4 ];
	LPCWSTR lpTempDriveString = a_DriveStrings;
	WCHAR t_TempVolumeName [ MAX_PATH + 1 ];

	while ( true )
	{
		iLen = lstrlen ( lpTempDriveString );
		if ( iLen == 0 )
			break;

		lstrcpy ( w_Drive, lpTempDriveString );

		BOOL bVol = GetVolumeNameForVolumeMountPoint(
						w_Drive,
						t_TempVolumeName,
						MAX_PATH
					);

		if ( lstrcmp ( t_TempVolumeName, a_VolumePath ) == 0 )
		{
			a_DriveName = w_Drive;
			break;
		}
		
		lpTempDriveString = &lpTempDriveString [ iLen + 1 ]; 	
	}
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: InitializeInterfacePointer
*
*  DESCRIPTION :    This method Initializes the DiskQuotaInterface pointer for a 
*					given volume
*                   
*****************************************************************************/

HRESULT DskCommonRoutines::InitializeInterfacePointer ( 

	IDiskQuotaControl* pIQuotaControl, 
	LPCWSTR a_VolumeName 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	BOOL bRetVal = TRUE;

	WCHAR w_VolumePathName [ MAX_PATH + 1 ];

	bRetVal = GetVolumePathName(
							a_VolumeName,           // file path
							w_VolumePathName,     // volume mount point
							MAX_PATH		  // Size of the Buffer
					 );
	if ( bRetVal )
	{
		if ( FAILED ( pIQuotaControl->Initialize (  w_VolumePathName, TRUE ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}
	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: VolumeSupportsDiskQuota
*
*  DESCRIPTION :    This method checks if the volume supports Disk Quotas, 
*
*****************************************************************************/
HRESULT DskCommonRoutines::VolumeSupportsDiskQuota ( 
												 
	LPCWSTR a_VolumeName,  
	CHString &a_QuotaVolumeName 
)
{
	// Get the name of the Volume Name Property
	LPWSTR  t_VolumeNameBuffer = a_QuotaVolumeName.GetBuffer(MAX_PATH + 1);
	DWORD dwMaximumComponentLength = 0;
	DWORD dwFileSystemFlags = 0;
	HRESULT hRes = WBEM_S_NO_ERROR;

	BOOL bRetVal =  GetVolumeInformation(
						 a_VolumeName,				// root directory
						 t_VolumeNameBuffer,        // volume name buffer
						 MAX_PATH,            // length of name buffer
						 NULL,					// volume serial number
						 &dwMaximumComponentLength, // maximum file name length
						 &dwFileSystemFlags,        // file system options
						 NULL,					// file system name buffer
						 0					 // length of file system name buffer
					);

	if ( ( bRetVal ) && ( ( dwFileSystemFlags & FILE_VOLUME_QUOTAS) == FILE_VOLUME_QUOTAS ))
	{
		a_QuotaVolumeName = t_VolumeNameBuffer;
	}
	else
	{
		hRes = WBEM_E_NOT_FOUND;
	}

    a_QuotaVolumeName.ReleaseBuffer();

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: MakeObjectPath
*
*  DESCRIPTION :    This method Adds a keyvalue for a given key property
*					into the Object Path and gives the Object Path
*                   
*****************************************************************************/
void DskCommonRoutines::MakeObjectPath (
										   
	 LPWSTR &a_ObjPathString,  
	 LPWSTR a_ClassName, 
	 LPCWSTR a_AttributeName, 
	 LPCWSTR  a_AttributeVal 
)
{
	ParsedObjectPath t_ObjPath;
	variant_t t_Path(a_AttributeVal);

	t_ObjPath.SetClassName ( a_ClassName );
	t_ObjPath.AddKeyRef ( a_AttributeName, &t_Path );

	CObjectPathParser t_PathParser;

	if ( t_PathParser.Unparse( &t_ObjPath, &a_ObjPathString  ) != t_PathParser.NoError )
	{
		throw;
	}
}

/*****************************************************************************
*
*  FUNCTION    :    DskCommonRoutines:: AddToObjectPath
*
*  DESCRIPTION :    This method Adds a keyvalue for a given key property
*					into the existing Object Path.
*                   
*****************************************************************************/
void DskCommonRoutines::AddToObjectPath ( 

	 LPWSTR &a_ObjPathString,  
	 LPCWSTR a_AttributeName, 
	 LPCWSTR  a_AttributeVal 
)
{
	CObjectPathParser t_PathParser;
	ParsedObjectPath *t_ObjPath;

    if (  t_PathParser.Parse( a_ObjPathString, &t_ObjPath ) ==  t_PathParser.NoError )
	{
		try
		{

			variant_t t_Path(a_AttributeVal);
			t_ObjPath->AddKeyRef ( a_AttributeName, &t_Path );
			LPWSTR t_ObjPathString = NULL;

			if ( t_PathParser.Unparse( t_ObjPath, &t_ObjPathString ) != t_PathParser.NoError )
			{
				throw;
			}

			delete [] a_ObjPathString;
			a_ObjPathString = t_ObjPathString;
		}
		catch ( ... )
		{
			t_PathParser.Free (t_ObjPath);
			throw;
		}
		t_PathParser.Free (t_ObjPath);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfscommon.h ===
/******************************************************************



   DFSCommon.H -- common defines for DFS classse



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef _DFS_COMMON_H
#define _DFS_COMMON_H

// Namespace
#define Namespace							L"root\\cimv2"

// Provider names
#define PROVIDER_NAME_DFSJNPT				L"Win32_DfsNode"
#define PROVIDER_NAME_DFSREPLICA			L"Win32_DfsTarget"
#define PROVIDER_NAME_DFSJNPTREPLICA		L"Win32_DfsNodeTarget"

// Definef for the DFS Type
#define DFS_TYPE_STANDALONE		0
#define DFS_TYPE_FTDFS			1


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfsreplica.h ===
/******************************************************************



   DFSReplica.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   Description: Win32 Dfs Replica Provider
   
*******************************************************************/


#ifndef _CDFSREPLICA_H_
#define _CDFSREPLICA_H_

#define DFSREPLICA_ALL_PROPS				0xFFFFFFFF
#define DFSREPLICA_PROP_LinkName			0x00000001
#define DFSREPLICA_PROP_ServerName			0x00000002
#define DFSREPLICA_PROP_ShareName			0x00000004
#define DFSREPLICA_PROP_State				0x00000008

class CDfsReplica : public Provider 
{
private:

		HRESULT EnumerateAllReplicas ( MethodContext *pMethodContext, DWORD dwPropertiesReq );
		HRESULT LoadDfsReplica ( DWORD dwPropertiesReq, CInstance *pInstance, LPWSTR  lpLinkName, PDFS_STORAGE_INFO pRepBuf );
		HRESULT FindAndSetDfsReplica ( LPCWSTR a_EntryPath, LPCWSTR a_ServerName, LPCWSTR a_ShareName, 
						   DWORD dwPropertiesReq, CInstance *pInstance, DWORD eOperation, bool &bRoot );

        HRESULT GetKeys(const CInstance *pInstance, CHString &sKey1, CHString &sKey2, CHString &sKey3);

protected:

        HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
        HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery& Query ) ;
 
        HRESULT PutInstance ( const CInstance& Instance, long lFlags = 0L ) ;
        HRESULT DeleteInstance ( const CInstance& Instance, long lFlags = 0L ) ;

public:

        CDfsReplica ( LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace );
        virtual ~CDfsReplica () ;

private:

		CHString m_ComputerName;
		enum { eGet,eDelete,eAdd };

        enum DFS_REPLICA_STATE	{	DFS_REPLICA_STATE_UNASSIGNED = 0,
							DFS_REPLICA_STATE_ONLINE,
							DFS_REPLICA_STATE_OFFLINE,
							DFS_REPLICA_STATE_UNREACHABLE
						};
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WMI Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <brodcast.h>

#include "FactoryRouter.h"
#include "ResourceManager.h"
#include "timerqueue.h"


HMODULE ghModule ;

// {4AF3F4A4-06C8-4b79-A523-633CC65CE297}
DEFINE_GUID(CLSID_DISKQUOTAVOLUME,
0x4af3f4a4, 0x6c8, 0x4b79, 0xa5, 0x23, 0x63, 0x3c, 0xc6, 0x5c, 0xe2, 0x97);

#define PROVIDER_NAME L"WMIPDSKQ"

// Globals from using ciwin32 library
CFactoryRouterData     g_FactoryRouterData;
CTimerQueue CTimerQueue :: s_TimerQueue ;
CResourceManager CResourceManager::sm_TheResourceManager ;


//Count number of objects and number of locks.
long g_cLock = 0 ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    
    try
    {
        if ( CLSID_DISKQUOTAVOLUME == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    SCODE sc = S_FALSE;

    try
    {
        sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM Disk Quota Volume Provider"), CLSID_DISKQUOTAVOLUME ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_DISKQUOTAVOLUME ) ;
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet ;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\precomp.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#include <fwcommon.h>
#include <initguid.h>
#include <smartptr.h>
#include "DskQuotaCommon.h"
#include <dskquota.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\diskquota.cpp ===
/******************************************************************

   DskQuota.CPP -- WMI provider class implementation



   Description:  Disk Quota Provider



  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

******************************************************************/

#include "precomp.h"
// #include for DiskQuota Provider Class
#include "DiskQuota.h"
#include "dllutils.h"

CDiskQuota MyCDiskQuota (

    IDS_DiskQuotaClass ,
    NameSpace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDiskQuota::CDiskQuota
 *
 *  DESCRIPTION :   Constructor
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CDiskQuota :: CDiskQuota (

    LPCWSTR lpwszName,
    LPCWSTR lpwszNameSpace
) : Provider ( lpwszName , lpwszNameSpace )
{
    m_ComputerName = GetLocalComputerName();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDiskQuota::~CDiskQuota
 *
 *  DESCRIPTION :   Destructor
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CDiskQuota :: ~CDiskQuota ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  COMMENTS    :    All instances of Disk Quota users on all Logical Disks that
*                   supports disk quota on a machine  with all the properties of
*                   DiskQuota users should be  returned here.
*
*****************************************************************************/
HRESULT CDiskQuota :: EnumerateInstances (

    MethodContext *pMethodContext,
    long lFlags
)
{
    DWORD dwPropertiesReq = DSKQUOTA_ALL_PROPS;
    HRESULT hRes = WBEM_S_NO_ERROR;

    hRes = EnumerateUsersOfAllVolumes ( pMethodContext, dwPropertiesReq );

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class.
*
*****************************************************************************/
HRESULT CDiskQuota :: GetObject (

    CInstance *pInstance,
    long lFlags ,
    CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;

    // Obtain the keys.
    if  ( pInstance->GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes )  )
    {
        if  ( pInstance->GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if ( SUCCEEDED ( hRes )  )
    {
        CHString t_DiskPropVolumePath;

        GetKeyValue ( t_DiskPropVolumePath,t_Key1  );

        // verify this logical drives actually exists
        WCHAR lpDriveStrings[(MAX_PATH * 2) + 1];
        DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

        hRes = m_CommonRoutine.SearchLogicalDisk ( t_DiskPropVolumePath.GetAt ( 0 ), lpDriveStrings );
        if ( SUCCEEDED ( hRes ) )
        {
            WCHAR w_VolumePathName [ MAX_PATH + 1 ];

            t_DiskPropVolumePath += L"\\";

            if ( GetVolumeNameForVolumeMountPoint(
                            t_DiskPropVolumePath,
                            w_VolumePathName,
                            MAX_PATH
                       ))
            {
                // Get the key values, which will be the object path.
                // Now from the Volume Object path, parse out the volumename
                // from the User object path extract out the user Id.
                // for the volume specified  check whether the given volume Supports Disk Quotas
                CHString t_VolumeName;
                hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( w_VolumePathName,  t_VolumeName );
                if ( SUCCEEDED ( hRes ) )
                {
                    // Get IDIskQuotaCOntrol  for this interface pointer
                    IDiskQuotaControlPtr pIQuotaControl;;

                    if (  SUCCEEDED ( CoCreateInstance(
                                        CLSID_DiskQuotaControl,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IDiskQuotaControl,
                                        (void **)&pIQuotaControl ) ) )
                    {
                        // Initialise the pIQuotaControl with the given volume
                        hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, w_VolumePathName );
                        if ( SUCCEEDED ( hRes ) )
                        {
                            IDiskQuotaUserPtr pIQuotaUser;
                            CHString t_UserLogName;

                            GetKeyValue ( t_UserLogName, t_Key2 );
                            HRESULT hrTemp = WBEM_E_NOT_FOUND;
                            hrTemp = pIQuotaControl->FindUserName(
                                                         t_UserLogName,
                                                         &pIQuotaUser);

                            // Certain Win32_Account instances report
                            // the Domain as computername instead of
                            // builtin, so change domain to builtin and
                            // try again.
							CHString chstrBuiltIn;

                            if(FAILED(hrTemp) && GetLocalizedBuiltInString(chstrBuiltIn))
                            {
                                int iWhackPos = t_UserLogName.Find(L"\\");
                                CHString chstrDomain = t_UserLogName.Left(iWhackPos);
                                if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
                                {
                                    CHString chstrUNameOnly = t_UserLogName.Mid(iWhackPos);
                                    CHString chstrDomWhackName = chstrBuiltIn;
                                    chstrDomWhackName += chstrUNameOnly;

                                    hrTemp = pIQuotaControl->FindUserName(
                                                                 chstrDomWhackName,
                                                                 &pIQuotaUser);
                                }
                            }

                            // Certain Win32_Account instances report
                            // the Domain as computername instead of
                            // NT AUTHORITY, so change domain to NT AUTHORITY and
                            // try again.
                            if(FAILED(hrTemp))
                            {
                                int iWhackPos = t_UserLogName.Find(L"\\");
                                CHString chstrDomain = t_UserLogName.Left(iWhackPos);
                                if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
                                {
                                    CHString chstrUNameOnly = t_UserLogName.Mid(iWhackPos);
                                    CHString chstrNT_AUTHORITY;
                                    CHString chstrDomWhackName;
                                    if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY))
                                    {
                                        chstrDomWhackName = chstrNT_AUTHORITY;
                                    } 
                                    else
                                    {
                                        chstrDomWhackName = L"NT AUTHORITY";
                                    }
                                    chstrDomWhackName += chstrUNameOnly;

                                    hrTemp = pIQuotaControl->FindUserName(
                                                                 chstrDomWhackName,
                                                                 &pIQuotaUser);
                                }
                            }

                            if(SUCCEEDED(hrTemp))
                            {
                                // Put this Instance
                                DWORD dwPropertiesReq;
                                if ( Query.AllPropertiesAreRequired() )
                                {
                                    dwPropertiesReq = DSKQUOTA_ALL_PROPS;
                                }
                                else
                                {
                                    SetPropertiesReq ( &Query, dwPropertiesReq );
                                }

                                hRes = LoadDiskQuotaUserProperties ( pIQuotaUser, pInstance, dwPropertiesReq );
                            }
                            else
                            {
                                hRes = WBEM_E_NOT_FOUND;
                            }
                        }
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }
            }
            else
            {
                hRes = WBEM_E_NOT_FOUND;
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of
*                   instances that satisfy the query, and a CFrameworkQuery
*                   which describes the query.  Create and populate all
*                   instances which satisfy the query.
*                   a) Queries involving Properties other than Win32_LogicalDisk
*                      are not optimized. Since that would involve enumerating
*                      every user on all volumes
*
*****************************************************************************/

HRESULT CDiskQuota :: ExecQuery (

    MethodContext *pMethodContext,
    CFrameworkQuery &Query,
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwPropertiesReq;
    CHStringArray t_Values;

    // Now a check for the attribute which if present in where clause the query optimization is supported
    // We need not care for the other attributes for which Optimization is not supported, winmgmt will take
    // care of those.
    hRes = Query.GetValuesForProp(
             IDS_LogicalDiskObjectPath,
             t_Values
           );

    if ( Query.AllPropertiesAreRequired() )
    {
        dwPropertiesReq = DSKQUOTA_ALL_PROPS;
    }
    else
    {
        SetPropertiesReq ( &Query, dwPropertiesReq );
    }

    if ( SUCCEEDED ( hRes ) )
    {
        if ( t_Values.GetSize() == 0 )
        {
            hRes = EnumerateUsersOfAllVolumes ( pMethodContext, dwPropertiesReq );
        }
        else
        {
            // Only Volume in QuotaVolume properties are needed to be enumerated
            int iSize = t_Values.GetSize ();
            // verify this logical drives actually exists
            WCHAR lpDriveStrings [(MAX_PATH * 2) + 1];

            DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

            for ( int i = 0; i < iSize; i++ )
            {
                CHString t_VolumePath;
                //Here we need to parse the VolumeObject path and extract VolumePath from it.
                GetKeyValue ( t_VolumePath, t_Values.GetAt(i) );

                if (( t_VolumePath.GetLength() == 2 ) && ( t_VolumePath.GetAt ( 1 ) == _L(':') ) )
                {
                    hRes = m_CommonRoutine.SearchLogicalDisk ( t_VolumePath.GetAt ( 0 ), lpDriveStrings );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        t_VolumePath += L"\\";
                        hRes = EnumerateUsers ( pMethodContext, t_VolumePath,  dwPropertiesReq );
                    }
                }
                else
                {
                    hRes = WBEM_E_INVALID_PARAMETER;
                }
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::PutInstance
*
*  DESCRIPTION : If the instance is already existing, we only modify the instance
*                if it doesnt exist, we will add the instance based on the flags.
*
*****************************************************************************/

HRESULT CDiskQuota :: PutInstance  (

    const CInstance &Instance,
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;
    BOOL bFound = TRUE;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes )  )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if (  SUCCEEDED ( hRes )  )
    {
        // verify this logical drives actually exists
        WCHAR lpDriveStrings [(MAX_PATH * 2) + 1];

        DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

        WCHAR t_VolumePathName[MAX_PATH + 1];
        CHString t_UserLogonName;
        CHString t_VolumePath;
        GetKeyValue ( t_VolumePath,t_Key1  );

        hRes = m_CommonRoutine.SearchLogicalDisk ( t_VolumePath.GetAt ( 0 ), lpDriveStrings );
        if ( SUCCEEDED ( hRes ) )
        {
            t_VolumePath += L"\\";

            GetKeyValue ( t_UserLogonName, t_Key2 );


            if ( GetVolumeNameForVolumeMountPoint(
                            t_VolumePath,
                            t_VolumePathName,
                            MAX_PATH
                        ))
            {
                // Check if the user already exists
                hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName,  t_VolumePath );
                if ( SUCCEEDED ( hRes ) )
                {
                    // Get IDIskQuotaCOntrol  for this interface pointer
                    IDiskQuotaControlPtr pIQuotaControl;
                    if (  SUCCEEDED ( CoCreateInstance(
                                        CLSID_DiskQuotaControl,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IDiskQuotaControl,
                                        (void **)&pIQuotaControl ) ) )
                    {
                        // Initialise the pIQuotaControl with the given volume
                        hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, t_VolumePathName );
                        if ( SUCCEEDED ( hRes ) )
                        {
                            IDiskQuotaUserPtr pIQuotaUser;
                            hRes = pIQuotaControl->FindUserName(
                                                    t_UserLogonName,
                                                    &pIQuotaUser
                                                );

                            // Certain Win32_Account instances report
                            // the Domain as computername instead of
                            // builtin, so change domain to builtin and
                            // try again.
							CHString chstrBuiltIn;

                            if(FAILED(hRes) && GetLocalizedBuiltInString(chstrBuiltIn))
                            {
                                int iWhackPos = t_UserLogonName.Find(L"\\");
                                CHString chstrDomain = t_UserLogonName.Left(iWhackPos);
                                if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
                                {
                                    CHString chstrUNameOnly = t_UserLogonName.Mid(iWhackPos);
                                    CHString chstrDomWhackName = chstrBuiltIn;
                                    chstrDomWhackName += chstrUNameOnly;

                                    hRes = pIQuotaControl->FindUserName(
                                                                 chstrDomWhackName,
                                                                 &pIQuotaUser);

                                    if(SUCCEEDED(hRes))
                                    {
                                        t_UserLogonName = chstrDomWhackName;
                                    }
                                    else
                                    {
                                        CHString chstrNT_AUTHORITY;
                                        CHString chstrDomWhackName;
                                        if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY))
                                        {
                                            chstrDomWhackName = chstrNT_AUTHORITY;
                                        } 
                                        else
                                        {
                                            chstrDomWhackName = L"NT AUTHORITY";
                                        }
                                        chstrDomWhackName += chstrUNameOnly;
                                        hRes = pIQuotaControl->FindUserName(
                                                                 chstrDomWhackName,
                                                                 &pIQuotaUser);
                                        if(SUCCEEDED(hRes))
                                        {
                                            t_UserLogonName = chstrDomWhackName;
                                        }
                                    }
                                }
                            }

                            if ( FAILED ( hRes ) )
                            {
                                hRes = WBEM_E_NOT_FOUND;
                            }
                        }
                    }
                    else
                    {
                        hRes = WBEM_E_FAILED;
                    }
                }
            }
            else
            {
                hRes = WBEM_E_NOT_FOUND;
            }
        }

        if ( SUCCEEDED ( hRes ) || ( hRes == WBEM_E_NOT_FOUND ) )
        {

            BOOL bCreate = FALSE;
            BOOL bUpdate = FALSE;

            switch ( lFlags & 3 )
            {
                case WBEM_FLAG_CREATE_OR_UPDATE:
                {
                    if ( hRes == WBEM_E_NOT_FOUND )
					{
                        bCreate = TRUE;
						hRes = WBEM_S_NO_ERROR;
					}
                    else
                        bUpdate = TRUE;
                }
                break;

                case WBEM_FLAG_UPDATE_ONLY:
                {
                    bUpdate = TRUE;
                }
                break;

                case WBEM_FLAG_CREATE_ONLY:
                {
                    if ( hRes  ==  WBEM_E_NOT_FOUND )
                    {
                        bCreate = TRUE;
						hRes = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hRes = WBEM_E_ALREADY_EXISTS ;
                    }
                }
                break;

                default:
                    {
                        hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
                    }
            }

			if (SUCCEEDED(hRes))
			{
				if ( bCreate )
				{
					hRes = AddUserOnVolume ( Instance,
									t_VolumePathName,
									t_UserLogonName );
				}
				else
				if ( bUpdate )
				{
					hRes = UpdateUserQuotaProperties ( Instance,
										t_VolumePathName,
										t_UserLogonName);
				}
			}
        }
    }
    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CDiskQuota:: DeleteInstance
*
*  DESCRIPTION :    If the given instance of a user exists on the Volume,
*                   the user is deleted, meaning diskquota properties
*                   will no t be applicable to this user.
*
*****************************************************************************/
HRESULT CDiskQuota :: DeleteInstance (

    const CInstance &Instance,
    long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes ) )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if (  SUCCEEDED ( hRes )  )
    {
        CHString t_VolumePath;

        GetKeyValue ( t_VolumePath,t_Key1  );

        // verify this logical drives actually exists
        WCHAR lpDriveStrings [ (MAX_PATH * 2) + 1 ];

        DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

        if ( ( t_VolumePath.GetLength()  == 2 ) && ( t_VolumePath.GetAt ( 1 ) == L':') )
        {
            hRes = m_CommonRoutine.SearchLogicalDisk ( t_VolumePath.GetAt ( 0 ), lpDriveStrings );
            if ( SUCCEEDED ( hRes ) )
            {
                t_VolumePath += L"\\";

                CHString t_UserLogonName;
                GetKeyValue ( t_UserLogonName, t_Key2 );

                WCHAR t_VolumePathName[MAX_PATH + 1];

                if ( GetVolumeNameForVolumeMountPoint(
                                t_VolumePath,
                                t_VolumePathName,
                                MAX_PATH
                            ) )
                {
                    // for the volume specified  check whether the given volume Supports Disk Quotas
                    CHString t_TempVolumeName;
                    hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName, t_TempVolumeName );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        // Get IDIskQuotaCOntrol  for this interface pointer
                        IDiskQuotaControlPtr pIQuotaControl;
                        if (  SUCCEEDED ( CoCreateInstance(
                                            CLSID_DiskQuotaControl,
                                            NULL,
                                            CLSCTX_INPROC_SERVER,
                                            IID_IDiskQuotaControl,
                                            (void **)&pIQuotaControl ) ) )
                        {
                            // Initialise the pIQuotaControl with the given volume
                            hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, t_VolumePathName );
                            if ( SUCCEEDED ( hRes ) )
                            {
                                IDiskQuotaUserPtr pIQuotaUser;
                                hRes = pIQuotaControl->FindUserName(
                                                        t_UserLogonName,
                                                        &pIQuotaUser
                                                    );

                                // Certain Win32_Account instances report
                                // the Domain as computername instead of
                                // builtin, so change domain to builtin and
                                // try again.
								CHString chstrBuiltIn;

                                if(FAILED(hRes) && GetLocalizedBuiltInString(chstrBuiltIn))
                                {
                                    int iWhackPos = t_UserLogonName.Find(L"\\");
                                    CHString chstrDomain = t_UserLogonName.Left(iWhackPos);
                                    if(chstrDomain.CompareNoCase(GetLocalComputerName()) == 0)
                                    {
                                        CHString chstrUNameOnly = t_UserLogonName.Mid(iWhackPos);
                                        CHString chstrDomWhackName = chstrBuiltIn;
                                        chstrDomWhackName += chstrUNameOnly;

                                        hRes = pIQuotaControl->FindUserName(
                                                                     chstrDomWhackName,
                                                                     &pIQuotaUser);
                                    }
                                }

                                // Get the user properties
                                if (  SUCCEEDED ( hRes )  )
                                {
                                    // Since the user is found delete the user.
                                    hRes = pIQuotaControl->DeleteUser ( pIQuotaUser );

                                    if (FAILED(hRes))
                                    {
                                        if (SCODE_CODE(hRes) == ERROR_ACCESS_DENIED)
                                        {
                                            hRes = WBEM_E_ACCESS_DENIED;
                                        }
                                        else
                                        {
                                            hRes = WBEM_E_FAILED;
                                        }
                                    }
                                }
                                else
                                {
                                    hRes = WBEM_E_NOT_FOUND;
                                }
                            }
                        }
                        else
                        {
                            hRes = WBEM_E_FAILED;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_NOT_FOUND;
                }
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::EnumerateUsersOfAllVolumes
*
*  DESCRIPTION : In this method enumerating volumes and calling enumerate users
*                for that volume
*
*****************************************************************************/

HRESULT CDiskQuota :: EnumerateUsersOfAllVolumes (

    MethodContext *pMethodContext,
    DWORD a_PropertiesReq
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    WCHAR t_VolumeName[MAX_PATH + 1];
    SmartCloseVolumeHandle hVol;

    hVol =  FindFirstVolume(
                t_VolumeName,      // output buffer
                MAX_PATH    // size of output buffer
            );

    if ( hVol  != INVALID_HANDLE_VALUE )
    {
        BOOL bNextVol = TRUE;
        // verify this logical drives actually exists
        WCHAR lpDriveStrings[(MAX_PATH * 2) + 1];

        DWORD dwDLength = GetLogicalDriveStrings ( (MAX_PATH * 2), lpDriveStrings );

        CHString t_VolumePath;

        while ( bNextVol )
        {
            m_CommonRoutine.GetVolumeDrive ( t_VolumeName, lpDriveStrings, t_VolumePath );

            EnumerateUsers ( pMethodContext, t_VolumePath, a_PropertiesReq );

            bNextVol =  FindNextVolume(
                         hVol,             // volume search handle
                         t_VolumeName,     // output buffer
                         MAX_PATH      // size of output buffer
                    );

        }
    }
    else
    {
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::EnumerateUsers
*
*  DESCRIPTION : In this method Enumerating all the users of a given volume that
*                Supports DiskQuotas
*
*****************************************************************************/

HRESULT CDiskQuota :: EnumerateUsers (

    MethodContext *pMethodContext,
    LPCWSTR a_VolumeName,
    DWORD a_PropertiesReq
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // checking whether the given volume supports disk quotas, and getting the Volume name which is readable to the
    // user, i.e. not containing the GUID.
    CHString t_VolumeName;

    hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumeName, t_VolumeName );
    if ( SUCCEEDED ( hRes ) )
    {
        // Get the QuotaInterface Pointer
        IDiskQuotaControlPtr pIQuotaControl;

        if (  SUCCEEDED ( CoCreateInstance(
                            CLSID_DiskQuotaControl,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IDiskQuotaControl,
                            (void **)&pIQuotaControl ) ) )
        {
            // initializing the Interface pointer for a particular volume
            hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumeName );
            if ( SUCCEEDED ( hRes ) )
            {
                IEnumDiskQuotaUsersPtr  pIEnumDiskQuotaUsers;

                if ( SUCCEEDED ( pIQuotaControl->CreateEnumUsers(
                                            NULL, //All the users will be enumerated
                                            0,    // Ignored for enumerating all users
                                            DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                            &pIEnumDiskQuotaUsers
                                     ) ) )
                {
                    if ( pIEnumDiskQuotaUsers != NULL )
                    {
                        hRes = pIEnumDiskQuotaUsers->Reset();

                        if ( SUCCEEDED(hRes))
                        {
                            IDiskQuotaUserPtr pIQuotaUser;
                            DWORD dwNoOfUsers = 0;
                            HRESULT hRes = S_OK;

                            hRes = pIEnumDiskQuotaUsers->Next(
                                            1,
                                            &pIQuotaUser,
                                            &dwNoOfUsers
                                        );

                            CInstancePtr pInstance;

                            while (  SUCCEEDED ( hRes )  )
                            {
                                if ( dwNoOfUsers == 0 )
                                {
                                    break;
                                }

                                if ( pIQuotaUser != NULL )
                                {
                                    pInstance.Attach(CreateNewInstance ( pMethodContext ));

                                    hRes = LoadDiskQuotaUserProperties ( pIQuotaUser, pInstance, a_PropertiesReq );
                                    if ( SUCCEEDED ( hRes ) )
                                    {
                                        if(SUCCEEDED(SetKeys( pInstance, a_VolumeName[0], a_PropertiesReq, pIQuotaUser )))
                                        {
                                            hRes = pInstance->Commit ();
                                        }

                                        if (SUCCEEDED(hRes))
                                        {
                                            dwNoOfUsers = 0;
                                            hRes = pIEnumDiskQuotaUsers->Next(
                                                                1,
                                                                &pIQuotaUser,
                                                                &dwNoOfUsers
                                                            );
                                        }
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    // No more Users
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_FAILED;
                }
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::LoadDiskQuotaUserProperties
*
*  DESCRIPTION : In this method Getting the User properties into a Given Structure
*
*****************************************************************************/

HRESULT CDiskQuota :: LoadDiskQuotaUserProperties (

    IDiskQuotaUser* pIQuotaUser,
    CInstance* pInstance,
    DWORD a_PropertiesReq
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( ( ( a_PropertiesReq & DSKQUOTA_PROP_Status ) == DSKQUOTA_PROP_Status  )
         || ( ( a_PropertiesReq & DSKQUOTA_PROP_WarningLimit ) == DSKQUOTA_PROP_WarningLimit  )
         || ( ( a_PropertiesReq & DSKQUOTA_PROP_Limit ) == DSKQUOTA_PROP_Limit  )
         || ( ( a_PropertiesReq & DSKQUOTA_PROP_DiskSpaceUsed ) == DSKQUOTA_PROP_DiskSpaceUsed  ) )
    {
        DISKQUOTA_USER_INFORMATION t_QuotaInformation;
        if ( SUCCEEDED ( pIQuotaUser->GetQuotaInformation ( &t_QuotaInformation, sizeof ( DISKQUOTA_USER_INFORMATION ) ) ) )
        {
            LONGLONG llLimit = -1;
            LONGLONG llWarningLimit = -1;
            UINT64 ullDiskSpaceUsed = 0;
            DWORD dwStatus;

            if (  t_QuotaInformation.QuotaLimit >= 0 )
            {
                llLimit = t_QuotaInformation.QuotaLimit;
            }

            if ( t_QuotaInformation.QuotaThreshold >= 0 )
            {
                llWarningLimit = t_QuotaInformation.QuotaThreshold;
            }

            ullDiskSpaceUsed = t_QuotaInformation.QuotaUsed;

            if ( t_QuotaInformation.QuotaThreshold > -1 )
            {
                // Since -1 means no Warning limit is set for the user, the deault is the complete Volume Space
                if ( t_QuotaInformation.QuotaUsed < t_QuotaInformation.QuotaThreshold )
                {
                    dwStatus =  0;
                }
            }
            else
            {
                dwStatus = 0;
            }

            if ( t_QuotaInformation.QuotaThreshold > -1 )
            {
                // Since -1 means no Warning limit is set for the user, the deault is the complete Volume Space
                if ( t_QuotaInformation.QuotaUsed >= t_QuotaInformation.QuotaThreshold )
                {
                    dwStatus = 1;
                }
            }

            if ( t_QuotaInformation.QuotaLimit > -1 )
            {
                if ( t_QuotaInformation.QuotaUsed >= t_QuotaInformation.QuotaLimit )
                {
                    dwStatus =  2;
                }
            }

            if (  ( a_PropertiesReq & DSKQUOTA_PROP_Status ) == DSKQUOTA_PROP_Status  )
            {
                if ( pInstance->SetDWORD ( IDS_QuotaStatus, dwStatus ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }

            if ( ( a_PropertiesReq & DSKQUOTA_PROP_WarningLimit ) == DSKQUOTA_PROP_WarningLimit )
            {
                if ( pInstance->SetWBEMINT64 ( IDS_QuotaWarningLimit, (ULONGLONG)llWarningLimit ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }

            if ( ( a_PropertiesReq & DSKQUOTA_PROP_Limit ) == DSKQUOTA_PROP_Limit  )
            {
                if ( pInstance->SetWBEMINT64 ( IDS_QuotaLimit, (ULONGLONG)llLimit ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }

            if ( ( a_PropertiesReq & DSKQUOTA_PROP_DiskSpaceUsed ) == DSKQUOTA_PROP_DiskSpaceUsed  )
            {
                if ( pInstance->SetWBEMINT64 ( IDS_DiskSpaceUsed, ullDiskSpaceUsed ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }
        }
        else
        {
            hRes = WBEM_E_FAILED;
        }
    }

    return hRes;
}
/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::SetKeys
*
*  DESCRIPTION : In this method Setting the User properties in a Given Instance
*
*****************************************************************************/
HRESULT CDiskQuota :: SetKeys(

    CInstance* pInstance,
    WCHAR w_Drive,
    DWORD a_PropertiesReq,
    IDiskQuotaUser* pIQuotaUser
)
{
    LPWSTR lpLogicalDiskObjectPath;
    LPWSTR lpUserObjectPath;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( ( a_PropertiesReq & DSKQUOTA_PROP_LogicalDiskObjectPath )  == DSKQUOTA_PROP_LogicalDiskObjectPath )
    {
        LPWSTR lpLogicalDiskObjectPath;
        WCHAR t_DeviceId[3];

        t_DeviceId[0] = w_Drive;
        t_DeviceId[1] = L':';
        t_DeviceId[2] = L'\0';

        m_CommonRoutine.MakeObjectPath ( lpLogicalDiskObjectPath,  IDS_LogicalDiskClass, IDS_DeviceID, t_DeviceId );

        if ( lpLogicalDiskObjectPath != NULL )
        {
            try
            {
                if ( pInstance->SetWCHARSplat ( IDS_LogicalDiskObjectPath, lpLogicalDiskObjectPath ) == FALSE )
                {
                    hRes = WBEM_E_FAILED;
                }
            }
            catch ( ... )
            {
                delete [] lpLogicalDiskObjectPath;
                throw;
            }
            delete [] lpLogicalDiskObjectPath;
        }
    }

    if (SUCCEEDED(hRes) && (( a_PropertiesReq & DSKQUOTA_PROP_UserObjectPath )  == DSKQUOTA_PROP_UserObjectPath) )
    {

        // Obtaining the users logon Name
        CHString t_LogonName;

        WCHAR w_AccountContainer [ MAX_PATH + 1 ];
        WCHAR w_DisplayName [ MAX_PATH + 1 ];
        LPWSTR t_LogonNamePtr = t_LogonName.GetBuffer(MAX_PATH + 1);

        if ( SUCCEEDED ( pIQuotaUser->GetName (
                            w_AccountContainer,
                            MAX_PATH,
                            t_LogonNamePtr,
                            MAX_PATH,
                            w_DisplayName,
                            MAX_PATH
                            ) ) )
        {
            t_LogonName.ReleaseBuffer();

            // Have seen cases where GetName succeeds, but
            // the t_LogonName variable contains an empty string.
            if(t_LogonName.GetLength() > 0)
            {
                CHString t_DomainName;
                ExtractUserLogOnName ( t_LogonName, t_DomainName );

                // BUILTIN and NT AUTHORITY accounts are represented
                // by Win32_Account and its children with the domain
                // name being the name of the machine, instead of
                // either of these strings.  Hence the change below:
                CHString chstrNT_AUTHORITY;
                CHString chstrBuiltIn;
                if(!GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) || !GetLocalizedBuiltInString(chstrBuiltIn))
                {
                    hRes = WBEM_E_FAILED;
                } 

                if(SUCCEEDED(hRes))
                {
                    if(t_DomainName.CompareNoCase(chstrBuiltIn) == 0 ||
                       t_DomainName.CompareNoCase(chstrNT_AUTHORITY) == 0)
                    {
                        t_DomainName = m_ComputerName;
                    }

                    m_CommonRoutine.MakeObjectPath ( lpUserObjectPath, IDS_AccountClass, IDS_Domain, t_DomainName );
                    m_CommonRoutine.AddToObjectPath ( lpUserObjectPath, IDS_Name, t_LogonName );
                    if ( lpUserObjectPath != NULL )
                    {
                        try
                        {
                            if ( pInstance->SetWCHARSplat ( IDS_UserObjectPath, lpUserObjectPath ) == FALSE )
                            {
                                hRes = WBEM_E_FAILED;
                            }
                        }
                        catch ( ... )
                        {
                            delete [] lpUserObjectPath;
                            throw;
                        }
                        delete [] lpUserObjectPath;
                    }
                }
            }
            else
            {
                hRes = WBEM_E_FAILED;
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::AddUserOnVolume
*
*  DESCRIPTION : In this method Adding a user on a volume that supports disk quota
*
*****************************************************************************/
HRESULT CDiskQuota :: AddUserOnVolume (

    const CInstance &Instance,
    LPCWSTR a_VolumePathName,
    LPCWSTR a_UserLogonName
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Get all the properties and check for their validity.
    // all the properties should be provided
    // if the properties like limit and warning limit are not supplied
    // then they should be taken as default values specified on that volume.
    // Also disk space used will not be defined, only the user logon name will be given that will include
    // the domain name so that the logon name would be uniquely defined.

    CHString t_Key1;
    CHString t_Key2;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes ) )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if (  SUCCEEDED ( hRes )  )
    {
        CHString t_VolumePath;
        GetKeyValue ( t_VolumePath,t_Key1  );

        hRes = CheckParameters (
                    Instance
               );

        if (  SUCCEEDED ( hRes )  )
        {
            CHString t_VolumeName;
            // Get the key values, which will be the object path.
            // Now from the Volume Object path, parse out the volumename
            // from the User object path extract out the user Id.
            // for the volume specified  check whether the given volume Supports Disk Quota
            if ( SUCCEEDED(m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumePathName,  t_VolumeName ) ) )
            {
                // Get IDIskQuotaCOntrol  for this interface pointer
                IDiskQuotaControlPtr pIQuotaControl;
                if (  SUCCEEDED ( CoCreateInstance(
                                    CLSID_DiskQuotaControl,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDiskQuotaControl,
                                    (void **)&pIQuotaControl ) ) )
                {
                    // Initialise the pIQuotaControl with the given volume
                    hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumePathName );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        IDiskQuotaUserPtr pIQuotaUser = NULL;
                        hRes = pIQuotaControl->AddUserName(
                                    a_UserLogonName ,
                                    DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                    &pIQuotaUser
                                );

                        if (  SUCCEEDED ( hRes )  )
                        {
                            LONGLONG llLimit;
                            Instance.GetWBEMINT64 ( IDS_QuotaLimit, llLimit );
                            hRes = pIQuotaUser->SetQuotaLimit ( llLimit, TRUE);

                            if (SUCCEEDED(hRes))
                            {
                                // Set the User Warning Limit
                                Instance.GetWBEMINT64 ( IDS_QuotaWarningLimit, llLimit );
                                hRes = pIQuotaUser->SetQuotaThreshold ( llLimit, TRUE );
                            }
                        }
                        else
                            if ( hRes == S_FALSE )
                            {
                                hRes = WBEM_E_ALREADY_EXISTS ;
                            }
                            else
                            {
                                hRes = WBEM_E_INVALID_PARAMETER;
                            }
                    }
                }
				else
				{
					hRes = WBEM_E_FAILED;
				}
            }
            else
            {
                hRes = WBEM_E_FAILED;
            }
        }
        else
        {
            hRes = WBEM_E_FAILED;
        }

    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::UpdateUserQuotaProperties
*
*  DESCRIPTION : In this method modifying a disk quota properties of a given user
*                on a given volume that supports disk quota
*
*****************************************************************************/
HRESULT CDiskQuota :: UpdateUserQuotaProperties (
    const CInstance &Instance,
    LPCWSTR a_VolumePathName,
    LPCWSTR a_UserLogonName
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key1;
    CHString t_Key2;

    if  ( Instance.GetCHString ( IDS_LogicalDiskObjectPath , t_Key1 ) == FALSE )
    {
        hRes = WBEM_E_FAILED ;
    }

    if (  SUCCEEDED ( hRes )  )
    {
        if  ( Instance.GetCHString ( IDS_UserObjectPath , t_Key2 ) == FALSE )
        {
            hRes = WBEM_E_FAILED ;
        }
    }

    if ( SUCCEEDED ( hRes )  )
    {
        CHString t_VolumePath;
        GetKeyValue ( t_VolumePath ,t_Key1  );

        hRes = CheckParameters (

                    Instance
               );

        if ( SUCCEEDED ( hRes ) )
        {
            CHString t_VolumeName;
            if ( SUCCEEDED(m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumePathName,  t_VolumeName )) )
            {
                // Get IDIskQuotaCOntrol  for this interface pointer
                IDiskQuotaControlPtr pIQuotaControl;
                if (  SUCCEEDED ( CoCreateInstance(
                                    CLSID_DiskQuotaControl,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDiskQuotaControl,
                                    (void **)&pIQuotaControl ) ) )
                {
                    // Initialise the pIQuotaControl with the given volume
                    hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumePathName );
                    if ( SUCCEEDED ( hRes ) )
                    {
                        IDiskQuotaUserPtr pIQuotaUser;
                        hRes = pIQuotaControl->FindUserName(
                                    a_UserLogonName ,
                                    &pIQuotaUser
                                );
                        if (  SUCCEEDED ( hRes )  )
                        {
                            LONGLONG llLimit;

                            if (Instance.GetWBEMINT64 ( IDS_QuotaLimit, llLimit ))
                            {
                                hRes = pIQuotaUser->SetQuotaLimit ( llLimit, TRUE);
                            }

                            // Set the User Warning Limit
                            if (SUCCEEDED(hRes) && Instance.GetWBEMINT64 ( IDS_QuotaWarningLimit, llLimit ))
                            {
                                hRes = pIQuotaUser->SetQuotaThreshold ( llLimit, TRUE );
                            }
                        }
                        else
                        {
                            hRes = WBEM_E_NOT_FOUND;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_FAILED;
                }
            }
            else
            {
                hRes = WBEM_E_FAILED;
            }
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::CheckParameters
*
*  DESCRIPTION : In this method verifying the validity of the parameters
*                which are supplied in PutInstance by the user.
*
*****************************************************************************/
HRESULT CDiskQuota :: CheckParameters (

    const CInstance &a_Instance
)
{
    // Get all the Properties from the Instance to Verify
    HRESULT hRes = WBEM_S_NO_ERROR ;
    bool t_Exists ;
    VARTYPE t_Type ;

    if ( a_Instance.GetStatus ( IDS_QuotaLimit , t_Exists , t_Type ) )
    {
        if ( t_Exists && ( t_Type == VT_BSTR ) )
        {
            LONGLONG llLimit;
            if ( a_Instance.GetWBEMINT64 ( IDS_QuotaLimit , llLimit ) == FALSE )
            {
                hRes = WBEM_E_INVALID_PARAMETER ;
            }
        }
        else
        if ( t_Exists == false )
        {
                hRes = WBEM_E_INVALID_PARAMETER ;
        }
    }

    if ( a_Instance.GetStatus ( IDS_QuotaWarningLimit , t_Exists , t_Type ) )
    {
        if ( t_Exists && ( t_Type == VT_BSTR ) )
        {
            LONGLONG llLimit;
            if ( a_Instance.GetWBEMINT64 ( IDS_QuotaWarningLimit , llLimit ) == FALSE )
            {
                hRes = WBEM_E_INVALID_PARAMETER ;
            }
        }
        else
        if (  t_Exists == false )
        {
            hRes = WBEM_E_INVALID_PARAMETER ;
        }
    }
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::SetPropertiesReq
*
*  DESCRIPTION : In this method setting the properties required requested
*                by the user.
*
*****************************************************************************/
void CDiskQuota :: SetPropertiesReq (

    CFrameworkQuery *Query,
    DWORD &a_PropertiesReq
)
{
    a_PropertiesReq = 0;
    // being key this property needs to be delivered
    if ( Query->IsPropertyRequired ( IDS_LogicalDiskObjectPath ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_LogicalDiskObjectPath;
    }

    if ( Query->IsPropertyRequired ( IDS_UserObjectPath ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_UserObjectPath;
    }

    if ( Query->IsPropertyRequired ( IDS_QuotaStatus ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_Status;
    }

    if ( Query->IsPropertyRequired ( IDS_QuotaWarningLimit ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_WarningLimit;
    }

    if ( Query->IsPropertyRequired ( IDS_QuotaLimit ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_Limit;
    }

    if ( Query->IsPropertyRequired ( IDS_DiskSpaceUsed ) )
    {
        a_PropertiesReq |= DSKQUOTA_PROP_DiskSpaceUsed;
    }
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::ExtractUserLogOnName
*
*  DESCRIPTION : Here the user logon name is in the form
*                ComputerName\userlogonname or Domainname\Userlogonname
*                or eg like
*                   builtin\adminitrator, where buildin is treated as a
*                   domain name by the Win32_UserAccount class. Hence
*                   we need to seperate the userlogon name and a domain name,
*                   so that the keys will match the Win32_UserAccount class.
*
*****************************************************************************/
void CDiskQuota :: ExtractUserLogOnName ( CHString &a_UserLogonName, CHString &a_DomainName )
{
    // Need the string "NT AUTHORITY".  However, on non-english
    // builds, this is something else.  Hence, get if from the
    // sid.
    PSID pSidNTAuthority = NULL;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    CHString cstrAuthorityDomain;
	if (AllocateAndInitializeSid (&sia ,1,SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,&pSidNTAuthority))
	{
		try
        {
            CHString cstrName;
            GetDomainAndNameFromSid(pSidNTAuthority, cstrAuthorityDomain, cstrName);
        }
        catch(...)
        {
            FreeSid(pSidNTAuthority);
            throw;
        }
		FreeSid(pSidNTAuthority);
    }
    
    int iPos = a_UserLogonName.Find ( L'\\');

    if ( iPos != -1 )
    {
        a_DomainName = a_UserLogonName.Left ( iPos );

        // Win32_SystemAccount domain names are always the computer
        // name, never BUILTIN.  The string BUILTIN is not localized.
		CHString chstrBuiltIn;

        if (GetLocalizedBuiltInString(chstrBuiltIn) &&
			(a_DomainName.CompareNoCase(chstrBuiltIn) == 0))
        {
            a_DomainName = m_ComputerName;
        }

        if(a_DomainName.CompareNoCase(cstrAuthorityDomain) == 0)
        {
            a_DomainName = m_ComputerName;
        }

        a_UserLogonName = a_UserLogonName.Right ( a_UserLogonName.GetLength() - (iPos + 1) );
    }
    else
    {
        a_DomainName = m_ComputerName;
    }
}

/*****************************************************************************
*
*  FUNCTION    : CDiskQuota::GetKeyValue
*
*  DESCRIPTION : From the object path we extract the key value
*
*****************************************************************************/
void CDiskQuota::GetKeyValue (

    CHString &a_VolumePath,
    LPCWSTR a_ObjectPath
)
{
    ParsedObjectPath *t_ObjPath;
    CObjectPathParser t_PathParser;

    if ( ( t_PathParser.Parse( a_ObjectPath, &t_ObjPath ) ) == CObjectPathParser::NoError )
    {
        try
        {
            if(V_VT(&t_ObjPath->m_paKeys [ 0 ]->m_vValue) == VT_BSTR)
            {
                a_VolumePath = t_ObjPath->m_paKeys [ 0 ]->m_vValue.bstrVal;
                if ( t_ObjPath->m_dwNumKeys > 1 )
                {
                    a_VolumePath.Format ( L"%s%s%s", t_ObjPath->m_paKeys [ 0 ]->m_vValue.bstrVal, L"\\", t_ObjPath->m_paKeys [ 1 ]->m_vValue.bstrVal );
                }
            }
        }
        catch ( ... )
        {
            t_PathParser.Free( t_ObjPath );
            throw;
        }
        t_PathParser.Free( t_ObjPath );
    }
}

BOOL CDiskQuota::GetDomainAndNameFromSid(
    PSID pSid,
    CHString& chstrDomain,
    CHString& chstrName)
{
    BOOL fRet = FALSE;
    
    // Initialize account name and domain name
	LPTSTR pszAccountName = NULL;
	LPTSTR pszDomainName = NULL;
	DWORD dwAccountNameSize = 0;
	DWORD dwDomainNameSize = 0;
    SID_NAME_USE snuAccountType;
	try
    {
		// This call should fail
		fRet = ::LookupAccountSid(NULL,
			pSid,
			pszAccountName,
			&dwAccountNameSize,
			pszDomainName,
			&dwDomainNameSize,
			&snuAccountType );

		if(fRet && (ERROR_INSUFFICIENT_BUFFER == ::GetLastError()))
		{
			// Allocate buffers
			if ( dwAccountNameSize != 0 )
            {
				pszAccountName = (LPTSTR) malloc( dwAccountNameSize * sizeof(TCHAR));
                if (pszAccountName == NULL)
                {
            		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

			if ( dwDomainNameSize != 0 )
            {
				pszDomainName = (LPTSTR) malloc( dwDomainNameSize * sizeof(TCHAR));
                if (pszDomainName == NULL)
                {
            		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

			// Make second call
			fRet = ::LookupAccountSid(
                NULL,
				pSid,
				pszAccountName,
				&dwAccountNameSize,
				pszDomainName,
				&dwDomainNameSize,
				&snuAccountType );

			if ( fRet == TRUE )
			{
				chstrName = pszAccountName;
				chstrDomain = pszDomainName;
			}

			if ( NULL != pszAccountName )
			{
				free ( pszAccountName );
                pszAccountName = NULL;
			}

			if ( NULL != pszDomainName )
			{
				free ( pszDomainName );
                pszDomainName = NULL;
			}

		}	// If ERROR_INSUFFICIENT_BUFFER
    } // try
    catch(...)
    {
        if ( NULL != pszAccountName )
		{
			free ( pszAccountName );
            pszAccountName = NULL;
		}

		if ( NULL != pszDomainName )
		{
			free ( pszDomainName );
            pszDomainName = NULL;
		}
        throw;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dfsprovider\inc\dfsjnptreplicaasso.h ===
/******************************************************************



   DssJnPtReplica.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef _CDFSJNPTREPLICA_H_
#define _CDFSJNPTREPLICA_H_

#define DFSLINKNAME							L"Dependent"
#define REPLICANAME							L"Antecedent"

class CDfsJnPtReplica : public Provider 
{
private:
	HRESULT EnumerateAllDfsJnPtReplicas ( MethodContext *pMethodContext );
	HRESULT FindDfsJnPtReplica ( LPWSTR lpEntryPath, LPWSTR lpServerName, LPWSTR lpShareName );
	void MakeObjectPath ( LPWSTR lpReplicaName, LPWSTR lpServerName, LPWSTR lpShareName, LPWSTR &lpJnPtReplicaObject );

protected:

    HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
    HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &Query ) ;

public:

    CDfsJnPtReplica ( LPCWSTR lpwszClassName,  LPCWSTR lpwszNameSpace ) ;
    virtual ~CDfsJnPtReplica () ;

private:

	CHString m_ComputerName;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\dskquotacommon.h ===
/******************************************************************

   DskCommonRoutines.CPP -- 



   Description: Common Headers and Smart pointers

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/

#ifndef  _CDSKQUOTACOMMON_H_
#define  _CDSKQUOTACOMMON_H_

#include "precomp.h"
_COM_SMARTPTR_TYPEDEF(IEnumDiskQuotaUsers, IID_IEnumDiskQuotaUsers);
_COM_SMARTPTR_TYPEDEF(IDiskQuotaUser, IID_IDiskQuotaUser );
_COM_SMARTPTR_TYPEDEF(IDiskQuotaControl, IID_IDiskQuotaControl );



// Provider Namespace
#define	NameSpace								L"root\\cimv2"

// Provider Classes
#define IDS_DiskVolumeClass						L"Win32_QuotaSetting"
#define IDS_LogicalDiskClass					L"Win32_LogicalDisk"
#define IDS_DiskQuotaClass						L"Win32_DiskQuota"
#define IDS_AccountClass						L"Win32_Account"
#define IDS_LogicalDiskClass					L"Win32_LogicalDisk"
#define IDS_VolumeQuotaSetting					L"Win32_VolumeQuotaSetting"


// #defines required for setting the properties in Instances.
#define IDS_VolumePath							L"VolumePath"
#define IDS_Caption                             L"Caption"
#define IDS_DeviceID							L"DeviceID"
#define IDS_LogicalDiskObjectPath				L"QuotaVolume"
#define IDS_UserObjectPath						L"User"
#define IDS_QuotaStatus							L"Status"
#define IDS_QuotaWarningLimit					L"WarningLimit"
#define IDS_QuotaLimit							L"Limit"
#define IDS_DiskSpaceUsed						L"DiskSpaceUsed"

#define IDS_QuotasDefaultLimit                  L"DefaultLimit"
#define IDS_QuotasDefaultWarningLimit           L"DefaultWarningLimit"
#define IDS_QuotasWarningExceededNotification   L"WarningExceededNotification"
#define IDS_QuotaExceededNotification           L"ExceededNotification"
#define IDS_QuotaState                          L"State"

#define IDS_Domain								L"Domain"
#define IDS_Name								L"Name"
#define IDS_Setting								L"Setting"
#define IDS_LogicalDisk							L"Element"

// Smart pointer for closing volume handles
class SmartCloseVolumeHandle
{
private:
	HANDLE m_h;

public:
	SmartCloseVolumeHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseVolumeHandle(HANDLE h):m_h(h){}
   	~SmartCloseVolumeHandle(){if (m_h!=INVALID_HANDLE_VALUE) FindVolumeClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindVolumeClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindVolumeClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

// Common routines required for Disk Quota Provider
struct DskCommonRoutines
{
	public:

		HRESULT InitializeInterfacePointer ( IDiskQuotaControl* pIQuotaControl, LPCWSTR a_VolumeName );
		HRESULT VolumeSupportsDiskQuota ( LPCWSTR a_VolumeName,  CHString &a_QuotaVolumeName );
		void GetVolumeDrive ( LPCWSTR a_VolumePath, LPCWSTR a_DriveStrings, CHString &a_DriveName );
		HRESULT GetVolume ( LPCWSTR t_Key1, WCHAR &w_Drive1 );
		HRESULT SearchLogicalDisk ( WCHAR a_Drive, LPCWSTR lpDriveStrings );
		void MakeObjectPath ( LPWSTR& lpObjPath, LPWSTR lpClassName, LPCWSTR lpAttributeName, LPCWSTR lpAttributeVal );
		void AddToObjectPath ( LPWSTR  &a_ObjPathString, LPCWSTR a_AttributeName, LPCWSTR  a_AttributeVal );
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <binding.h>
#include <dskquotacommon.h>

CBinding MyVolumeQuotaSetting(
    IDS_VolumeQuotaSetting,
    NameSpace,
    IDS_DiskVolumeClass,
    IDS_LogicalDiskClass,
    IDS_Setting,
    IDS_LogicalDisk,
    IDS_Caption,
    IDS_DeviceID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\diskquota.h ===
/******************************************************************



   DskQuota.H -- WMI provider class definition



   Description: Header for Quotasettings class 



  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

*******************************************************************/

// Property set identification
//============================


#ifndef  _CDISKQUOTA_H_
#define  _CDISKQUOTA_H_
#include "precomp.h"
#include  "DskQuotaCommon.h"

// Defining bit values for the property, which will be used for defining the bitmap of properties required.
#define DSKQUOTA_ALL_PROPS							0xFFFFFFFF
#define DSKQUOTA_PROP_LogicalDiskObjectPath			0x00000001
#define DSKQUOTA_PROP_UserObjectPath				0x00000002
#define DSKQUOTA_PROP_Status						0x00000004
#define DSKQUOTA_PROP_WarningLimit					0x00000008
#define DSKQUOTA_PROP_Limit							0x00000010
#define DSKQUOTA_PROP_DiskSpaceUsed					0x00000020

class CDiskQuota : public Provider 
{
private:

		HRESULT EnumerateUsersOfAllVolumes ( 
			
			MethodContext *pMethodContext,
			DWORD dwPropertiesReq
		);

		HRESULT EnumerateUsers ( 
			
			MethodContext *pMethodContext, 
			LPCWSTR a_VolumeName,
			DWORD dwPropertiesReq
		);

		HRESULT LoadDiskQuotaUserProperties ( 
			
			IDiskQuotaUser* pIQuotaUser, 
			CInstance *pInstance,
			DWORD dwPropertiesReq
		);

		HRESULT SetKeys ( 
			
			CInstance *pInstance, 
			WCHAR w_Drive,
			DWORD dwPropertiesReq,
			IDiskQuotaUser* pIQuotaUser
		);

		HRESULT AddUserOnVolume ( 

			const CInstance &Instance, 
			LPCWSTR a_VolumePathName, 
			LPCWSTR a_UserLogonName 
		);

		HRESULT  UpdateUserQuotaProperties ( 
			
			const CInstance &Instance, 			
			LPCWSTR a_VolumePathName, 
			LPCWSTR a_UserLogonName 
		);

		HRESULT CheckParameters ( 

			const CInstance &a_Instance
		);

		void SetPropertiesReq ( 
												  
			CFrameworkQuery *Query, 
			DWORD &dwPropertiesReq
		);

		void ExtractUserLogOnName ( 
			
			CHString &a_UserLogonName,
			CHString &a_DomainName
		);

		void GetKeyValue ( 
			
			CHString &a_VolumePath, 
			LPCWSTR a_VolumeObjectPath
		);

        BOOL GetDomainAndNameFromSid(
            PSID pSid,
            CHString& chstrDomain,
            CHString& chstrName);

protected:

        // Reading Functions
        //============================

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;

        // Writing Functions
        //============================

        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

        HRESULT DeleteInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

public:

        // Constructor/destructor
        //=======================

        CDiskQuota(

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CDiskQuota () ;
private:

	CHString			m_ComputerName;
	DskCommonRoutines   m_CommonRoutine;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\volumequotasetting.cpp ===
/******************************************************************

   VolumeQuotaSettings.CPP -- WMI provider class implementation



   Description: Implementation of the methods of an association class 

				Between QuotaSettings and LogicalDisk

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
#include "precomp.h"
#include "VolumeQuotaSetting.h"

CVolumeQuotaSetting MyCVolumeQuotaSetting ( 

	IDS_VolumeQuotaSetting , 
	NameSpace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CVolumeQuotaSetting::CVolumeQuotaSetting
 *
 *  DESCRIPTION :   Constructor
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/

CVolumeQuotaSetting :: CVolumeQuotaSetting (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CVolumeQuotaSetting::~CVolumeQuotaSetting
 *
 *  DESCRIPTION :   Destructor
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/

CVolumeQuotaSetting :: ~CVolumeQuotaSetting ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/
HRESULT CVolumeQuotaSetting :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	hRes = EnumerateAllVolumeQuotas ( pMethodContext );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/
HRESULT CVolumeQuotaSetting :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	// Not doing anything here, since the two properties which are in the object

	CHString t_Key1;
	CHString t_Key2;

 	if ( pInstance->GetCHString ( IDS_Setting, t_Key1 ) == FALSE )
		hRes = WBEM_E_FAILED;

	if ( SUCCEEDED ( hRes ) )
	{
		if ( pInstance->GetCHString ( IDS_LogicalDisk, t_Key2 ) == FALSE )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		// If the Drive is not as Logical Disks then GetVolume Method will return False;
		WCHAR w_Drive1;
		WCHAR w_Drive2;

		hRes = m_CommonRoutine.GetVolume ( t_Key1, w_Drive1 );
		if (SUCCEEDED ( hRes ) )
		{
			hRes = m_CommonRoutine.GetVolume ( t_Key2, w_Drive2 );
			if (SUCCEEDED ( hRes ) )
			{
				if ( w_Drive1 == w_Drive2 )
				{
					// verify this logical drives actually exists
					CHString t_DriveStrings1;
					CHString t_DriveStrings2;
					
					LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );

					DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );

					if ( dwDLength > MAX_PATH )
					{
						lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
						dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
					}

					hRes = m_CommonRoutine.SearchLogicalDisk ( w_Drive1, lpDriveStrings );
				}
				else
				{
					hRes = WBEM_E_INVALID_PARAMETER;
				}
			}
		}			
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*****************************************************************************/

HRESULT CVolumeQuotaSetting :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	// Queries involving only one Keyvalue  VolumeObjectPath is implemented. Query involving the UserObjectPath is not
	// implemented. Since for this we will have to  have to enumerate all the volumes until a user is found.

	HRESULT hRes = WBEM_S_NO_ERROR;
	CHStringArray t_Values;

	// Now a check for the LogicalDIsk attribute which if present in where clause the query optimization is supported

	hRes = Query.GetValuesForProp(
			 IDS_Setting,
			 t_Values
		   );

	if ( SUCCEEDED ( hRes ) )
	{
		if ( t_Values.GetSize() == 0 )
		{
			hRes = Query.GetValuesForProp(
					 IDS_LogicalDisk,
					 t_Values
				   );

			if ( SUCCEEDED ( hRes ) )
			{
				if ( t_Values.GetSize() == 0 )
				{
					//Let Winmgmt handle this, since anyway all the volumes will be enumerated.
					hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
				}
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		int iSize = t_Values.GetSize ();

		// In this loop picking up one by one the VolumePath, getting the properties of those volumepath
		for ( int i = 0; i < iSize; i++ )
		{
			WCHAR w_Drive;

			hRes = m_CommonRoutine.GetVolume ( t_Values.GetAt(i), w_Drive );

			if ( SUCCEEDED ( hRes ) )
			{
				CHString t_VolumePath;
				CHString t_DeviceId;
				// In this loop I need to parse the object path 

				t_VolumePath.Format ( L"%c%s", w_Drive, L":\\" );

				// Forming a Logical Disk Key Value
				t_DeviceId.Format( L"%c%c", w_Drive, _L(':') );

				hRes = PutNewInstance ( t_DeviceId.GetBuffer ( t_DeviceId.GetLength() + 1) , 
								 t_VolumePath.GetBuffer( t_VolumePath.GetLength() + 1), 
								 pMethodContext );

				if ( FAILED (hRes) )
				{
					break;
				}
			}
			// otherwise continue with thenext drive
		}
	}
	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::EnumerateAllVolumeQuotas
*
*  DESCRIPTION :    Enumerates all the volumes that supports disk Quotas
*
*****************************************************************************/

HRESULT CVolumeQuotaSetting::EnumerateAllVolumeQuotas ( 
			
	MethodContext *pMethodContext
) 
{
	HRESULT hRes = WBEM_S_NO_ERROR;
		// verify this logical drives actually exists
	CHString t_DriveStrings1;
	CHString t_DriveStrings2;
	
	LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );

	DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );

	if ( dwDLength > MAX_PATH )
	{
		lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
		dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
	}

	// Here for every drive, getting a volumePath for Win32_DiskVolume Class and DeviceId for Logical Disk Class
	LPWSTR lpTempDriveStrings;
	CHString t_VolumePath;
	CHString t_DeviceId;

	lpTempDriveStrings = lpDriveStrings;

	int iLen = lstrlen ( lpTempDriveStrings );

	while ( iLen > 0 )
	{
		t_VolumePath = lpTempDriveStrings;
		t_DeviceId = lpTempDriveStrings;

		lpTempDriveStrings = &lpTempDriveStrings [ iLen + 1];

		t_DeviceId.SetAt ( t_DeviceId.GetLength() - 1,L'\0' );
		iLen = lstrlen ( lpTempDriveStrings );

		hRes = PutNewInstance ( t_DeviceId.GetBuffer ( t_DeviceId.GetLength() + 1), 
						 t_VolumePath.GetBuffer ( t_VolumePath.GetLength() + 1), 
						 pMethodContext);

		if ( FAILED ( hRes ) )
			break;
	}

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CVolumeQuotaSetting::PutNewInstance
*
*  DESCRIPTION :    Sets the properties into a new instance
*
*****************************************************************************/

HRESULT CVolumeQuotaSetting::PutNewInstance ( 
										  
	LPWSTR a_DeviceId,
	LPWSTR a_VolumePath,
	MethodContext *pMethodContext
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	LPWSTR lpTempVolumePath;
	LPWSTR lpTempDeviceID;

	m_CommonRoutine.MakeObjectPath ( lpTempVolumePath, IDS_DiskVolumeClass, IDS_VolumePath, a_VolumePath );
	m_CommonRoutine.MakeObjectPath ( lpTempDeviceID, IDS_LogicalDiskClass, IDS_DeviceID, a_DeviceId );	

	if ( ( lpTempVolumePath != NULL ) && ( lpTempDeviceID != NULL ) )
	{
		try
		{
			CInstancePtr pInstance = CreateNewInstance ( pMethodContext ) ;

			if ( pInstance->SetCHString ( IDS_LogicalDisk, lpTempDeviceID ) )
			{
				if ( pInstance->SetCHString ( IDS_Setting, lpTempVolumePath ) )
				{
					hRes = pInstance->Commit ();
				}
				else
				{
				   hRes = WBEM_E_FAILED;
				}
			}
			else
			{
				hRes = WBEM_E_FAILED;
			}
		}
		catch ( ... )
		{
			delete lpTempVolumePath;
			delete lpTempDeviceID;
			throw;
		}
		if ( lpTempVolumePath != NULL )
			delete lpTempVolumePath;
		if ( lpTempDeviceID != NULL )
			delete lpTempDeviceID;
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\quotasettings.h ===
/******************************************************************

   QuotaSettings.H -- WMI provider class definition



   Description: Quota Settings Provider for the volumes that Supports

                Disk Quotas,  class Definition

 

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/

#ifndef  _CQUOTASETTINGS_H_
#define  _CQUOTASETTINGS_H_

// Defining bit values for the property, which will be used for defining the bitmap of properties required.
#define QUOTASETTINGS_ALL_PROPS								0xFFFFFFFF
#define QUOTASETTINGS_PROP_VolumePath						0x00000001
#define QUOTASETTINGS_PROP_State							0x00000002
#define QUOTASETTINGS_PROP_DefaultLimit						0x00000004
#define QUOTASETTINGS_PROP_DefaultWarningLimit				0x00000008
#define QUOTASETTINGS_PROP_QuotaExceededNotification		0x00000010
#define QUOTASETTINGS_PROP_WarningExceededNotification		0x00000020
#define QUOTASETTINGS_PROP_Caption                  		0x00000040

class CQuotaSettings : public Provider 
{
private:

	HRESULT EnumerateAllVolumes ( 

		MethodContext *pMethodContext,
		DWORD &PropertiesReq
	);

	HRESULT LoadDiskQuotaVolumeProperties ( 
		
		LPCWSTR a_VolumeName, 
        LPCWSTR a_Caption,
		DWORD dwPropertiesReq,
		CInstancePtr pInstance
	);
	
	HRESULT SetDiskQuotaVolumeProperties ( 
		
		const CInstance &Instance,
		IDiskQuotaControlPtr pIQuotaControl
	);

	HRESULT CheckParameters ( 

		const CInstance &a_Instance
	);

	void SetRequiredProperties ( 
		
		CFrameworkQuery *Query,
		DWORD &dwPropertiesReq
	);

	HRESULT PutVolumeDetails ( 
		
		LPCWSTR a_VolumeName, 
		MethodContext *pMethodContext, 
		DWORD dwPropertiesReq 
	);

protected:

        // Reading Functions
        //============================
        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;

        // Writing Functions
        //============================
        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;
public:

        // Constructor/destructor
        //=======================
        CQuotaSettings (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CQuotaSettings () ;

private:
	DskCommonRoutines   m_CommonRoutine;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\dll\quotasettings.cpp ===
/******************************************************************

   QuotaSettings.CPP -- WMI provider class implementation



   Description: Quota Settings class implementation. Quota settings

				are available only on those volumes that support 

				Disk Quotas. It is supported only on Win2k.

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/
#include "precomp.h"
#include "QuotaSettings.h"

CQuotaSettings MyQuotaSettings ( 

	IDS_DiskVolumeClass , 
	NameSpace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CQuotaSettings::CQuotaSettings
 *
 *  DESCRIPTION :   Constructor
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CQuotaSettings :: CQuotaSettings (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CQuotaSettings::~CQuotaSettings
 *
 *  DESCRIPTION :   Destructor
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CQuotaSettings :: ~CQuotaSettings ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/
HRESULT CQuotaSettings :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes =  WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;

	dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;

	// This method enumerates all volumes on the 
	hRes = EnumerateAllVolumes ( pMethodContext, dwPropertiesReq );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/
HRESULT CQuotaSettings :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHString t_Key ; // VolumePath;

    if  ( pInstance->GetCHString ( IDS_VolumePath , t_Key ) == FALSE )
	{
		hRes = WBEM_E_FAILED ;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		// verify this logical drives actually exists
		CHString t_DriveStrings1;
		CHString t_DriveStrings2;
		
		LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );

		DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );

		if ( dwDLength > MAX_PATH )
		{
			lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
			dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
		}	

		hRes = m_CommonRoutine.SearchLogicalDisk ( t_Key.GetAt ( 0 ) , lpDriveStrings );
		if ( SUCCEEDED ( hRes ) )
		{
			WCHAR t_VolumePathName[MAX_PATH + 1];

			if ( GetVolumeNameForVolumeMountPoint(
							t_Key,
							t_VolumePathName,
							MAX_PATH
						) )
			{
                CHString t_VolumeName;

				hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName,  t_VolumeName );
				{
					DWORD dwPropertiesReq;

					if ( Query.AllPropertiesAreRequired() )
					{
						dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;
					}
					else
					{
						SetRequiredProperties ( &Query, dwPropertiesReq );
					}
						// put the instance with the requested properties only as in Query.
					// Get the Properties of the requested volume
					hRes = LoadDiskQuotaVolumeProperties ( t_VolumePathName, t_Key, dwPropertiesReq, pInstance );
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings::ExecQuery
*
*  DESCRIPTION :    Optimization of Queries involving only the key attribute 
*				    is supported.
*
*****************************************************************************/
HRESULT CQuotaSettings :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwPropertiesReq;
	CHStringArray t_Values;

	hRes = Query.GetValuesForProp(
			 IDS_VolumePath,
			 t_Values
		   );

	if ( t_Values.GetSize() == 0 )
    {
	    hRes = Query.GetValuesForProp(
			     IDS_Caption,
			     t_Values
		       );

        if (SUCCEEDED(hRes))
        {
            DWORD dwSize = t_Values.GetSize();
            for (DWORD x = 0; x < dwSize; x++)
            {
                t_Values[x] += L'\\';
            }
        }
    }

	if ( Query.AllPropertiesAreRequired() )
	{
		dwPropertiesReq = QUOTASETTINGS_ALL_PROPS;
	}
	else
	{
		SetRequiredProperties ( &Query, dwPropertiesReq );
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( t_Values.GetSize() == 0 )
		{
			// This method is called when there is no where clause just to filter 
			// the required properties
			hRes = EnumerateAllVolumes ( pMethodContext, dwPropertiesReq );
		}
		else
		{
			// Only Volume in VolumePath properties are needed to be enumerated
			WCHAR t_VolumePathName[MAX_PATH + 1];
            CHString t_VolumeName;

			int iSize = t_Values.GetSize ();

			for ( int i = 0; i < iSize; i++ )
			{
				if ( GetVolumeNameForVolumeMountPoint(
								t_Values[i],
								t_VolumePathName,
								MAX_PATH ) )
				{
					hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_VolumePathName,  t_VolumeName );
					if ( SUCCEEDED ( hRes ) )
					{
						// Get and Set the Properties of the requested volume
						hRes = PutVolumeDetails ( t_VolumePathName, 
														   pMethodContext, 
														   dwPropertiesReq );
					}		
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CQuotaSettings::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*****************************************************************************/

HRESULT CQuotaSettings :: PutInstance  (

	const CInstance &Instance, 
	long lFlags
)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
	CHString t_Key;
	
	if ( Instance.GetCHString ( IDS_VolumePath , t_Key ) == FALSE )
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED ( hRes ) )
	{
		WCHAR t_VolumePathName[MAX_PATH + 1];

		if ( GetVolumeNameForVolumeMountPoint(
						t_Key,
						t_VolumePathName,
						MAX_PATH ) )
		{
			// Only changing certain properties of volumes is allowed and not adding a new DIskQuota Volume.
			// Hence creating a new instance is not supported, but changing instance properties is supported.
			switch ( lFlags & 3)
			{
				case WBEM_FLAG_CREATE_OR_UPDATE:
				case WBEM_FLAG_UPDATE_ONLY:
				{
					hRes = CheckParameters ( Instance);
					if ( SUCCEEDED ( hRes ) )
					{
                        CHString t_VolumePathName2;
						hRes = m_CommonRoutine.VolumeSupportsDiskQuota ( t_Key,  t_VolumePathName2 );
						if ( SUCCEEDED ( hRes ) )
						{
							// Get the QuotaInterface Pointer
							IDiskQuotaControlPtr pIQuotaControl = NULL;

							if (  SUCCEEDED ( CoCreateInstance(
												CLSID_DiskQuotaControl,
												NULL,
												CLSCTX_INPROC_SERVER,
												IID_IDiskQuotaControl,
												(void **)&pIQuotaControl ) ) )
							{
								hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, t_Key );
								if ( SUCCEEDED ( hRes ) )
								{
									hRes = SetDiskQuotaVolumeProperties ( Instance,  pIQuotaControl );
								}
							}
							else
							{
								hRes = WBEM_E_FAILED;
							}
						}
					}

					break ;
				}
				default:
				{
					hRes = WBEM_E_PROVIDER_NOT_CAPABLE ;
				}
				break ;
			}
		}
		else
		{
			hRes = WBEM_E_NOT_FOUND;
		}
	}
    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: EnumerateAllVolumes
*
*  DESCRIPTION :    This method Enumerates all the volumes by making use of Disk
*                   Quotas Interfaces, gets all the required properties and deliveres
*                   the instances to WMI, which will be postfiltered by WMI
*                   
*****************************************************************************/
HRESULT CQuotaSettings :: EnumerateAllVolumes (

	MethodContext *pMethodContext,
	DWORD &a_PropertiesReq
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	BOOL bNextVol = TRUE;
	WCHAR t_VolumeName[MAX_PATH + 1];
	
	// Initializing and getting the first volume on the computer
	SmartCloseVolumeHandle hVol;

	hVol =  FindFirstVolume(
				t_VolumeName,
				MAX_PATH    // size of output buffer
			);

	if ( hVol  != INVALID_HANDLE_VALUE )
	{
		while ( bNextVol )
		{
			hRes = PutVolumeDetails ( t_VolumeName, pMethodContext, a_PropertiesReq );
			// Continue for next volume, even if the retval for this volume is false;
			bNextVol =  FindNextVolume(
						 hVol,										// volume search handle
						 t_VolumeName,   // output buffer
						 MAX_PATH									// size of output buffer
					);
			if ( bNextVol == FALSE )
				break;
		}
	}
	else
		hRes = WBEM_E_FAILED;

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: LoadDiskQuotaVolumeProperties
*
*  DESCRIPTION :    This method checks if the volume enumerated supports Disk Quotas
*                   If the Volume Supposrts DIskQuotas, it fills up all the properties
*                   of the volume and returns otherwise it just returns FALSE
*                   indicating properties of this volume were not filled. and hence
*					intsnace should not be delivered to WMI
*
*****************************************************************************/
HRESULT CQuotaSettings :: LoadDiskQuotaVolumeProperties ( 
													 
	LPCWSTR a_VolumeName, 
    LPCWSTR a_Caption,
	DWORD dwPropertiesReq,
	CInstancePtr pInstance
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwLogFlags;
	DWORD dwQuotaState;
	CHString t_Temp;

	// checks to see if the volume supports Disk Quotas
	hRes =  m_CommonRoutine.VolumeSupportsDiskQuota ( a_VolumeName,  t_Temp );
	if ( SUCCEEDED ( hRes ) )
	{
		if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_Caption ) )
		{
            t_Temp = a_Caption;
            pInstance->SetCHString(IDS_Caption, t_Temp.Left(2));
        }

		IDiskQuotaControlPtr pIQuotaControl;

		if (  SUCCEEDED ( CoCreateInstance(
							CLSID_DiskQuotaControl,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IDiskQuotaControl,
							(void **)&pIQuotaControl ) ) )
		{
			// Initializing the QuotaCOntrol Interface pointer for this Volume
			hRes = m_CommonRoutine.InitializeInterfacePointer (  pIQuotaControl, a_VolumeName );
			if ( SUCCEEDED ( hRes ) )
			{
				// Get all the Volume Properties
				LONGLONG lQuotaLimit = 0;
				if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_DefaultLimit ) )
				{
					if ( SUCCEEDED ( pIQuotaControl->GetDefaultQuotaLimit( &lQuotaLimit ) ) )
					{
						if ( pInstance->SetWBEMINT64 ( IDS_QuotasDefaultLimit, (ULONGLONG)lQuotaLimit ) == FALSE )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_DefaultWarningLimit )  )
				{
					if ( SUCCEEDED ( pIQuotaControl->GetDefaultQuotaThreshold ( &lQuotaLimit ) ) )
					{
						if ( pInstance->SetWBEMINT64 ( IDS_QuotasDefaultWarningLimit, (ULONGLONG)lQuotaLimit ) == FALSE )
						{
							hRes = WBEM_E_FAILED;
						}
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				if ( ( ( dwPropertiesReq & QUOTASETTINGS_PROP_QuotaExceededNotification ) ) 
						|| ( ( dwPropertiesReq & QUOTASETTINGS_PROP_WarningExceededNotification ) ) )
						
				{
					if ( SUCCEEDED ( pIQuotaControl->GetQuotaLogFlags( &dwLogFlags ) ) )
					{
						if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_QuotaExceededNotification ) )
						{
							if ( pInstance->Setbool ( IDS_QuotaExceededNotification, DISKQUOTA_IS_LOGGED_USER_THRESHOLD ( dwLogFlags ) ) == FALSE )
							{
								hRes = WBEM_E_FAILED;
							}
						}

						if ( ( dwPropertiesReq & QUOTASETTINGS_PROP_WarningExceededNotification ) )
						{
							if ( pInstance->Setbool ( IDS_QuotasWarningExceededNotification, DISKQUOTA_IS_LOGGED_USER_LIMIT ( dwLogFlags) ) == FALSE )
							{
								hRes = WBEM_E_FAILED;
							}
						}				
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}

				if  ( ( dwPropertiesReq & QUOTASETTINGS_PROP_State ) ) 
				{
					if ( SUCCEEDED (pIQuotaControl->GetQuotaState( &dwQuotaState ) ) )
					{
						DWORD State = 0;

						if  ( DISKQUOTA_IS_DISABLED ( dwQuotaState ) )
							State = 0;
						else
						if  ( DISKQUOTA_IS_ENFORCED ( dwQuotaState)  )
							State = 2;
						else
						if  ( DISKQUOTA_IS_TRACKED ( dwQuotaState)  )
							State = 1;

						pInstance->SetDWORD ( IDS_QuotaState, State );
						
					}
					else
					{
						hRes = WBEM_E_FAILED;
					}
				}
			}
		}
	}
	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: SetDiskQuotaVolumeProperties
*
*  DESCRIPTION :    This method Sets the DskQuota Volume Properties
*
*****************************************************************************/
HRESULT CQuotaSettings :: SetDiskQuotaVolumeProperties ( 
													  
	const CInstance &Instance,
	IDiskQuotaControlPtr pIQuotaControl
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwLogFlags = 0;
	DWORD dwQuotaState = 0;
	bool bExceededNotn = false;
	bool bWarningNotn = false;
	DWORD dwState = 0;
	UINT64 ullDefaultLimit = 0;
	UINT64 ullWarningLimit = 0;
	bool bSetState = false;

	if (Instance.Getbool ( IDS_QuotaExceededNotification, bExceededNotn ))
	{
		if ( bExceededNotn )
			DISKQUOTA_SET_LOG_USER_LIMIT ( dwLogFlags, TRUE );
		else
			DISKQUOTA_SET_LOG_USER_LIMIT ( dwLogFlags, FALSE );

		bSetState = true;
	}

	if (Instance.Getbool ( IDS_QuotasWarningExceededNotification, bWarningNotn ))
	{
		if ( bWarningNotn )
			DISKQUOTA_SET_LOG_USER_THRESHOLD ( dwLogFlags, TRUE );
		else
			DISKQUOTA_SET_LOG_USER_THRESHOLD ( dwLogFlags, FALSE );

		bSetState = true;
	}

	if (bSetState)
	{
		if ( FAILED ( pIQuotaControl->SetQuotaLogFlags ( dwLogFlags ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (Instance.GetWBEMINT64 ( IDS_QuotasDefaultLimit, ullDefaultLimit ))
	{
		if ( FAILED ( pIQuotaControl->SetDefaultQuotaLimit ( ullDefaultLimit ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (Instance.GetWBEMINT64 ( IDS_QuotasDefaultWarningLimit, ullWarningLimit ))
	{
		if ( FAILED ( pIQuotaControl->SetDefaultQuotaThreshold ( ullWarningLimit ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (Instance.GetDWORD ( IDS_QuotaState, dwState ))
	{
		if ( dwState == 0 )
			DISKQUOTA_SET_DISABLED ( dwQuotaState );
		
		if ( dwState == 1 )
			DISKQUOTA_SET_TRACKED ( dwQuotaState );

		if ( dwState == 2 )
			DISKQUOTA_SET_ENFORCED ( dwQuotaState );

		if ( FAILED ( pIQuotaControl->SetQuotaState( dwQuotaState ) ) )
		{
			hRes = WBEM_E_FAILED;
		}
	}

	return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: CheckParameters
*
*  DESCRIPTION :    Checks for the validity of the input parameters while 
*					Updating an instance
*
*****************************************************************************/
HRESULT CQuotaSettings :: CheckParameters ( 

	const CInstance &a_Instance
)
{
	// Getall the Properties from the Instance to Verify
	HRESULT hRes = WBEM_S_NO_ERROR ;
	bool t_Exists ;
	VARTYPE t_Type ;

	if ( a_Instance.GetStatus ( IDS_QuotaState, t_Exists , t_Type ) )
	{
		DWORD t_State;
		if ( t_Exists && ( t_Type == VT_I4 ) )
		{
			if ( a_Instance.GetDWORD ( IDS_QuotaState , t_State ) )
			{
				if ( ( t_State != 1 )  && ( t_State != 0 ) && ( t_State != 2 ))
				{
					hRes = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotaExceededNotification, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BOOL ) )
		{
			bool bQuotaState;

			if ( a_Instance.Getbool ( IDS_QuotaExceededNotification , bQuotaState ) == false )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotasWarningExceededNotification, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BOOL ) )
		{
			bool bQuotaState;

			if ( a_Instance.Getbool ( IDS_QuotasWarningExceededNotification , bQuotaState ) == false )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotasDefaultLimit, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			LONGLONG lDefaultLimit;
			if ( a_Instance.GetWBEMINT64 ( IDS_QuotasDefaultLimit , lDefaultLimit ) == FALSE )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( a_Instance.GetStatus ( IDS_QuotasDefaultWarningLimit, t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			LONGLONG lDefaultWarningLimit;

			if ( a_Instance.GetWBEMINT64 ( IDS_QuotasDefaultWarningLimit , lDefaultWarningLimit ) == FALSE  )
			{
				hRes = WBEM_E_INVALID_PARAMETER ;
			}
		}
		else
		{
			hRes = WBEM_E_INVALID_PARAMETER ;
		}
	}
	return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: SetRequiredProperties
*
*  DESCRIPTION :    This method sets the required properties for the instances 
*					requested by the user
*
*****************************************************************************/
void CQuotaSettings :: SetRequiredProperties ( 
	
	CFrameworkQuery *Query,
	DWORD &a_PropertiesReq
)
{
	a_PropertiesReq = 0;

	if ( Query->IsPropertyRequired ( IDS_VolumePath ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_VolumePath;

	if ( Query->IsPropertyRequired ( IDS_QuotasDefaultLimit ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_DefaultLimit;

	if ( Query->IsPropertyRequired ( IDS_Caption ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_Caption;

	if ( Query->IsPropertyRequired ( IDS_QuotasDefaultWarningLimit ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_DefaultWarningLimit;

	if ( Query->IsPropertyRequired ( IDS_QuotaExceededNotification ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_QuotaExceededNotification;

	if ( Query->IsPropertyRequired ( IDS_QuotasWarningExceededNotification ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_WarningExceededNotification;

	if ( Query->IsPropertyRequired ( IDS_QuotaState ) )
		a_PropertiesReq |= QUOTASETTINGS_PROP_State;

}

/*****************************************************************************
*
*  FUNCTION    :    CQuotaSettings:: PutVolumeDetails
*
*  DESCRIPTION :    Putting the volume properties
*
*****************************************************************************/
HRESULT CQuotaSettings :: PutVolumeDetails ( 
										 
	LPCWSTR a_VolumeName, 
	MethodContext *pMethodContext, 
	DWORD a_PropertiesReq 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	CHString t_DriveName ;
	// verify this logical drives actually exists
	CHString t_DriveStrings1;
	CHString t_DriveStrings2;

	LPWSTR lpDriveStrings = t_DriveStrings1.GetBuffer ( MAX_PATH + 1 );
	DWORD dwDLength = GetLogicalDriveStrings ( MAX_PATH, lpDriveStrings );
	if ( dwDLength > MAX_PATH )
	{
		lpDriveStrings = t_DriveStrings2.GetBuffer ( dwDLength + 1 );
		dwDLength = GetLogicalDriveStrings ( dwDLength, lpDriveStrings );
	}

	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

	m_CommonRoutine.GetVolumeDrive ( a_VolumeName, lpDriveStrings, t_DriveName );

	hRes = LoadDiskQuotaVolumeProperties ( a_VolumeName,  t_DriveName, a_PropertiesReq, pInstance );
	if ( SUCCEEDED ( hRes ) )
	{

		if ( ( a_PropertiesReq & QUOTASETTINGS_PROP_VolumePath ) )
		{
			if ( pInstance->SetCHString ( IDS_VolumePath, t_DriveName ) == FALSE )
			{
				hRes = WBEM_E_FAILED;
			}
		}	
			
		if ( FAILED ( pInstance->Commit() ) )
		{
			hRes = WBEM_E_FAILED;
		}		
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpprox\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\cfactory.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

///////////////////////////////////////////////////////////
//
// CFactory
//   - Base class for reusing a single class factory for
//     all components in a DLL
//
#include <objbase.h>

#include "Registry.h"
#include "CFactory.h"

///////////////////////////////////////////////////////////
//
// Static variables
//
LONG CFactory::s_cServerLocks = 0 ;    // Count of locks

HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

#ifdef _OUTPROC_SERVER_
DWORD CFactory::s_dwThreadID = 0 ;
#endif

///////////////////////////////////////////////////////////
//
// CFactory implementation
//

CFactory::CFactory(
    const CFactoryData* pFactoryData)
: m_cRef(1)
{
	m_pFactoryData = pFactoryData ;
}

//
// IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(
    REFIID iid, 
    void** ppv)
{ 	
	IUnknown* pI ;
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		pI = this ; 
	}
	else
	{
	   *ppv = NULL;
		return E_NOINTERFACE;
	}
	pI->AddRef() ;
	*ppv = pI ;
	return S_OK;
}

ULONG __stdcall CFactory::AddRef() 
{ 
	return ::InterlockedIncrement(&m_cRef) ; 
}

ULONG __stdcall CFactory::Release() 
{
	if (::InterlockedDecrement(&m_cRef) == 0) 
	{
		delete this; 
		return 0 ;
	}   
	return m_cRef;
}

//
// IClassFactory implementation
//

HRESULT __stdcall CFactory::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv) 
{

	// Aggregate only if the requested IID is IID_IUnknown.
	if ((pUnknownOuter != NULL) && (iid != IID_IUnknown))
	{
		return CLASS_E_NOAGGREGATION ;
	}

	// Create the component.
	CUnknown* pNewComponent ;
	HRESULT hr = m_pFactoryData->CreateInstance(pUnknownOuter,
	                                            &pNewComponent) ;
	if (FAILED(hr))
	{
		return hr ;
	}

	// Initialize the component.
	hr = pNewComponent->Init();
	if (FAILED(hr))
	{
		// Initialization failed.  Release the component.
		pNewComponent->NondelegatingRelease() ;
		return hr ;
	}
	
	// Get the requested interface.
	hr = pNewComponent->NondelegatingQueryInterface(iid, ppv) ;

	// Release the reference held by the class factory.
	pNewComponent->NondelegatingRelease() ;
	return hr ;   
}

// LockServer
HRESULT __stdcall CFactory::LockServer(
    BOOL bLock) 
{
	if (bLock) 
	{
		::InterlockedIncrement(&s_cServerLocks) ; 
	}
	else
	{
		::InterlockedDecrement(&s_cServerLocks) ;
	}
	// If this is an out-of-proc server, check to see
	// whether we should shut down.
	CloseExe() ;  //@local

	return S_OK ;
}


///////////////////////////////////////////////////////////
//
// GetClassObject
//   - Create a class factory based on a CLSID.
//
HRESULT CFactory::GetClassObject(
    const CLSID& clsid, 
    const IID& iid, 
    void** ppv)
{
	if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
	{
		return E_NOINTERFACE ;
	}

	// Traverse the array of data looking for this class ID.
	for (int i = 0; i < g_cFactoryDataEntries; i++)
	{
		const CFactoryData* pData = &g_FactoryDataArray[i] ;
		if (pData->IsClassID(clsid))
		{

			// Found the ClassID in the array of components we can
			// create. So create a class factory for this component.
			// Pass the CFactoryData structure to the class factory
			// so that it knows what kind of components to create.
			*ppv = (IUnknown*) new CFactory(pData) ;
			if (*ppv == NULL)
			{
				return E_OUTOFMEMORY ;
			}
			return NOERROR ;
		}
	}
	return CLASS_E_CLASSNOTAVAILABLE ;
}

//
// Determine if the component can be unloaded.
//
HRESULT CFactory::CanUnloadNow()
{
	if (CUnknown::ActiveComponents() || IsLocked())
	{
		return S_FALSE ;
	}
	else
	{
		return S_OK ;
	}
}

//
// Register all components.
//
HRESULT CFactory::RegisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
	{
		RegisterServer(s_hModule,
		               *(g_FactoryDataArray[i].m_pCLSID),
		               g_FactoryDataArray[i].m_RegistryName,
		               g_FactoryDataArray[i].m_szVerIndProgID, 
		               g_FactoryDataArray[i].m_szProgID) ;
	}
	return S_OK ;
}   
	
HRESULT CFactory::UnregisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)   
	{
		UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
		                 g_FactoryDataArray[i].m_szVerIndProgID, 
		                 g_FactoryDataArray[i].m_szProgID) ;
	}
	return S_OK ;
}

#ifndef _OUTPROC_SERVER_
//////////////////////////////////////////////////////////
//
// Exported functions
//

STDAPI DllCanUnloadNow()
{
	return CFactory::CanUnloadNow() ; 
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
	return CFactory::GetClassObject(clsid, iid, ppv) ;
}

//
// Server registration
//
STDAPI DllRegisterServer()
{
	return CFactory::RegisterAll() ;
}


STDAPI DllUnregisterServer()
{
	return CFactory::UnregisterAll() ;
}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule, 
                      DWORD dwReason, 
                      void* lpReserved )
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CFactory::s_hModule = hModule ;
		DisableThreadLibraryCalls(CFactory::s_hModule);		// 158024
	}
	return TRUE ;
}

#else
//////////////////////////////////////////////////////////
//
// Out of process Server support
//

//
// Start factories
//
BOOL CFactory::StartFactories()
{
	CFactoryData* pStart = &g_FactoryDataArray[0] ;
	const CFactoryData* pEnd =
		&g_FactoryDataArray[g_cFactoryDataEntries - 1] ;

	for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
	{
		// Initialize the class factory pointer and cookie.
		pData->m_pIClassFactory = NULL ;
		pData->m_dwRegister = NULL ;

		// Create the class factory for this component.
		IClassFactory* pIFactory = new CFactory(pData) ;

		// Register the class factory.
		DWORD dwRegister ;
		HRESULT hr = ::CoRegisterClassObject(
		                  *pData->m_pCLSID,
		                  static_cast<IUnknown*>(pIFactory),
		                  CLSCTX_LOCAL_SERVER,
		                  REGCLS_MULTIPLEUSE,
		                  // REGCLS_MULTI_SEPARATE, //@Multi
		                  &dwRegister) ;
		if (FAILED(hr))
		{
			pIFactory->Release() ;
			return FALSE ;
		}

		// Set the data.
		pData->m_pIClassFactory = pIFactory ;
		pData->m_dwRegister = dwRegister ;
	}
	return TRUE ;
}

//
// Stop factories
//
void CFactory::StopFactories()
{
	CFactoryData* pStart = &g_FactoryDataArray[0] ;
	const CFactoryData* pEnd =
		&g_FactoryDataArray[g_cFactoryDataEntries - 1] ;

	for (CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
	{
		// Get the magic cookie and stop the factory from running.
		DWORD dwRegister = pData->m_dwRegister ;
		if (dwRegister != 0) 
		{
			::CoRevokeClassObject(dwRegister) ;
		}

		// Release the class factory.
		IClassFactory* pIFactory  = pData->m_pIClassFactory ;
		if (pIFactory != NULL) 
		{
			pIFactory->Release() ;
		}
	}
}

#endif //_OUTPROC_SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\cunknown.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#pragma once

#include <objbase.h>

///////////////////////////////////////////////////////////
//
// Nondelegating IUnknown interface
//   - Nondelegating version of IUnknown
//
interface INondelegatingUnknown
{
	virtual HRESULT __stdcall NondelegatingQueryInterface(
        const IID& iid, 
        void** ppv) = 0;
	virtual ULONG   __stdcall NondelegatingAddRef() = 0;
	virtual ULONG   __stdcall NondelegatingRelease() = 0;
};


///////////////////////////////////////////////////////////
//
// Declaration of CUnknown 
//   - Base class for implementing IUnknown
//

class CUnknown : public INondelegatingUnknown
{
public:
	// Nondelegating IUnknown implementation
	virtual HRESULT __stdcall NondelegatingQueryInterface(
        const IID&,
	    void**);

	virtual ULONG   __stdcall NondelegatingAddRef();

	virtual ULONG   __stdcall NondelegatingRelease();

	// Constructor
	CUnknown(IUnknown* pUnknownOuter);

	// Destructor
	virtual ~CUnknown();

	// Initialization (especially for aggregates)
	virtual HRESULT Init() { return S_OK ;}

	// Notification to derived classes that we are releasing
	virtual void FinalRelease();

	// Count of currently active components
	static long ActiveComponents() 
		{ return s_cActiveComponents;}
	
	// Helper function
	HRESULT FinishQI(IUnknown* pI, void** ppv);

protected:
	// Support for delegation
	IUnknown* GetOuterUnknown() const
		{ return m_pUnknownOuter;}

private:
	// Reference count for this object
	long m_cRef ;
	
	// Pointer to (external) outer IUnknown
	IUnknown* m_pUnknownOuter;

	// Count of all active instances
	static long s_cActiveComponents; 
} ;


///////////////////////////////////////////////////////////
//
// Delegating IUnknown
//   - Delegates to the nondelegating IUnknown, or to the
//     outer IUnknown if the component is aggregated.
//
#define DECLARE_IUNKNOWN		                             \
	virtual HRESULT __stdcall	                             \
		QueryInterface(const IID& iid, void** ppv)           \
	{	                                                     \
		return GetOuterUnknown()->QueryInterface(iid,ppv) ;  \
	};	                                                     \
	virtual ULONG __stdcall AddRef()	                     \
	{	                                                     \
		return GetOuterUnknown()->AddRef() ;                 \
	};	                                                     \
	virtual ULONG __stdcall Release()	                     \
	{	                                                     \
		return GetOuterUnknown()->Release() ;                \
	};


///////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\cfactory.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#pragma once

#include "CUnknown.h"
///////////////////////////////////////////////////////////
 
// Forward reference
class CFactoryData ;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

//////////////////////////////////////////////////////////
//
//  Component creation function
//
class CUnknown ;

typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**) ;

///////////////////////////////////////////////////////////
//
// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
//
class CFactoryData
{
public:
	// The class ID for the component
	const CLSID* m_pCLSID ;

	// Pointer to the function that creates it
	FPCREATEINSTANCE CreateInstance ;

	// Name of the component to register in the registry
	const char* m_RegistryName ;

	// ProgID
	const char* m_szProgID ;

	// Version-independent ProgID
	const char* m_szVerIndProgID ;

	// Helper function for finding the class ID
	BOOL IsClassID(const CLSID& clsid) const
		{ return (*m_pCLSID == clsid) ;}

	//
	// Out of process server support
	//

	// Pointer to running class factory for this component
	IClassFactory* m_pIClassFactory ;

	// Magic cookie to identify running object
	DWORD m_dwRegister ;
} ;


///////////////////////////////////////////////////////////
//
// Class Factory
//
class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
	                                         void** ppv) ;
	virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor - Pass pointer to data of component to create.
	CFactory(const CFactoryData* pFactoryData) ;

	// Destructor
	~CFactory() { }

	//
	// Static FactoryData support functions
	//

	// DllGetClassObject support
	static HRESULT GetClassObject(const CLSID& clsid, 
	                              const IID& iid, 
	                              void** ppv) ;

	// Helper function for DllCanUnloadNow 
 	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
	static HRESULT RegisterAll() ;
	static HRESULT UnregisterAll() ;

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;


#ifdef _OUTPROC_SERVER_
	//
	// Out-of-process server support
	//

	static BOOL StartFactories() ;
	static void StopFactories() ;

	static DWORD s_dwThreadID ;

	// Shut down the application.
	static void CloseExe()
	{
		if (CanUnloadNow() == S_OK)
		{
			::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
		}
	}
#else
	// CloseExe doesn't do anything if we are in process.
	static void CloseExe() { /*Empty*/ } 
#endif

public:
	// Reference Count
	LONG m_cRef ;

	// Pointer to information about class this factory creates
	const CFactoryData* m_pFactoryData ;

	// Count of locks
	static LONG s_cServerLocks ;   

	// Module handle
	static HMODULE s_hModule ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\cmpnt1.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// Cmpnt1.cpp - Component 1
//

#pragma once


//#include "Iface.h"
#include "CUnknown.h" // Base class for IUnknown
#include <stack>

///////////////////////////////////////////////////////////
//
// Component PSH
//
class CMDH : public CUnknown,
             public IMDH
{
public:	
	// Creation
	static HRESULT CreateInstance(
        IUnknown* pUnknownOuter,
	    CUnknown** ppNewComponent) ;

	// Declare the delegating IUnknown.
	DECLARE_IUNKNOWN

	// IUnknown
	virtual HRESULT __stdcall NondelegatingQueryInterface( 
        const IID& iid, 
        void** ppv) ;			
	
    // Interfact IMDH
    STDMETHOD(GetMDData)(
        /* in */ DWORD dwReqProps,
        /* out, retval */VARIANT* pvarData);

    STDMETHOD(GetOneMDData)(
		/* [in] */ BSTR bstrDrive,
		/* [in] */ DWORD dwReqProps, 
		/* [out,retval] */ VARIANT* pvData);

	// Initialization
 	virtual HRESULT Init();

	// Notify derived classes that we are releasing.
	virtual void FinalRelease();

	// Constructor
	CMDH(IUnknown* pUnknownOuter);

	// Destructor
	~CMDH();

	 // Pointer to inner object being aggregated.
	IUnknown* m_pUnknownInner;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\cunknown.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

///////////////////////////////////////////////////////////
//
// CUnknown.cpp 
//
// Implementation of IUnknown Base class
//
#include "CUnknown.h"
#include "CFactory.h"
#include <strstrea.h>
#include <vector>
#include <objbase.h>
#include <comdef.h>
#include <DskQuota.h>
#include "Util.h"


///////////////////////////////////////////////////////////
//
// Count of active objects
//   - Use to determine if we can unload the DLL.
//
long CUnknown::s_cActiveComponents = 0 ;


///////////////////////////////////////////////////////////
//
// Constructor
//
CUnknown::CUnknown(
    IUnknown* pUnknownOuter)
: m_cRef(1)
{
	// Set m_pUnknownOuter pointer.
	if (pUnknownOuter == NULL)
	{
		m_pUnknownOuter = reinterpret_cast<IUnknown*>
		                     (static_cast<INondelegatingUnknown*>
		                     (this)) ;  // notice cast
	}
	else
	{
		m_pUnknownOuter = pUnknownOuter ;
	}

	// Increment count of active components.
	::InterlockedIncrement(&s_cActiveComponents) ;
}

//
// Destructor
//
CUnknown::~CUnknown()
{
	::InterlockedDecrement(&s_cActiveComponents) ;

	// If this is an EXE server, shut it down.
	CFactory::CloseExe() ;
}

//
// FinalRelease - called by Release before it deletes the component
//
void CUnknown::FinalRelease()
{
	m_cRef = 1 ;
}

//
// Nondelegating IUnknown
//   - Override to handle custom interfaces.
//
HRESULT __stdcall CUnknown::NondelegatingQueryInterface(
    const IID& iid, void** ppv)
{
	// CUnknown supports only IUnknown.
	if (iid == IID_IUnknown)
	{
		return FinishQI(
            reinterpret_cast<IUnknown*>
		        (static_cast<INondelegatingUnknown*>(this)),
		         ppv) ;
	}	
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
}

//
// AddRef
//
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}

//
// Release
//
ULONG __stdcall CUnknown::NondelegatingRelease()
{
	InterlockedDecrement(&m_cRef) ;
	if (m_cRef == 0)
	{
		FinalRelease() ;
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}

//
// FinishQI
//   - Helper function to simplify overriding
//     NondelegatingQueryInterface
//
HRESULT CUnknown::FinishQI(
    IUnknown* pI, 
    void** ppv) 
{
	*ppv = pI ;
	pI->AddRef() ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\dskquotaprovider\inc\volumequotasetting.h ===
/******************************************************************

   VolumeQuotaSettings.CPP -- WMI provider class Definition



   Description: 

   

  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
  
******************************************************************/


#ifndef  _CVOLUME_QUOTA_SETTINGS_H
#define  _CVOLUME_QUOTA_SETTINGS_H

#include "precomp.h"
#include  "DskQuotaCommon.h"

class CVolumeQuotaSetting : public Provider 
{
private:
	HRESULT EnumerateAllVolumeQuotas ( 
				
		MethodContext *pMethodContext
	);

	HRESULT PutNewInstance ( 
										  
		LPWSTR lpDeviceId, 
		LPWSTR lpVolumePath,
		MethodContext *pMethodContext
	);
	
protected:
        // Reading Functions
        //============================
        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT ExecQuery ( 

			MethodContext *pMethodContext, 
			CFrameworkQuery& Query, 
			long lFlags = 0
		) ;
public:
        // Constructor/destructor
        //=======================
        CVolumeQuotaSetting(

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;
        virtual ~CVolumeQuotaSetting () ;

private:
		DskCommonRoutines   m_CommonRoutine;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\cmpnt1.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#pragma warning (disable: 4786)


#include <objbase.h>
#include <comdef.h>
#include "MD.h"
#include <strstrea.h>
#include <vector>
#include <DskQuota.h>
#include "Util.h"
#include "CUnknown.h" 
#include "Cmpnt1.h"




///////////////////////////////////////////////////////////
//
// Interface IPSH
//

STDMETHODIMP CMDH::GetMDData(
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = S_OK;
    
    if(!pvarData) return E_POINTER;
    
    // Someone could have grabbed our thread
    // between the point we started and now,
    // so make sure we impersonate the caller
    // before doing any work.
    //hr = ::CoImpersonateClient();

    if(SUCCEEDED(hr))
    {
        hr = GetMappedDisksAndData(
            dwReqProps,
            pvarData);
    }

    return hr;
}

STDMETHODIMP CMDH::GetOneMDData(
	BSTR bstrDrive,
	DWORD dwReqProps, 
	VARIANT* pvarData)
{
    HRESULT hr = S_OK;

    if(!pvarData) return E_POINTER;
    
    // Someone could have grabbed our thread
    // between the point we started and now,
    // so make sure we impersonate the caller
    // before doing any work.
    //hr = ::CoImpersonateClient();

    if(SUCCEEDED(hr))
    {
        hr = GetSingleMappedDiskAndData(
            bstrDrive,
            dwReqProps,
            pvarData);
    }
    return hr;
}




//
// Constructor
//
CMDH::CMDH(IUnknown* pUnknownOuter)
: CUnknown(pUnknownOuter),
  m_pUnknownInner(NULL)
{
	// Empty
}

//
// Destructor
//
CMDH::~CMDH()
{
}

//
// NondelegatingQueryInterface implementation
//
HRESULT __stdcall CMDH::NondelegatingQueryInterface(
    const IID& iid,
    void** ppv)
{ 	
	if (iid == IID_IMDH)
	{
		return FinishQI((IMDH*)this, ppv) ;
	}
	else if (iid == IID_IMarshal)
	{
		// We don't implement IMarshal.
		return CUnknown::NondelegatingQueryInterface(iid, ppv) ;
	}
	else
	{
		return CUnknown::NondelegatingQueryInterface(iid, ppv) ;
	}
}


//
// Initialize the component by creating the contained component.
//
HRESULT CMDH::Init()
{
/*
	trace("Create Component 2, which is aggregated.") ;
	HRESULT hr = CoCreateInstance(CLSID_Component2, 
	                              GetOuterUnknown(), 
	                              CLSCTX_INPROC_SERVER,
	                              //CLSCTX_ALL, //@Multi
	                              IID_IUnknown,
	                              (void**)&m_pUnknownInner) ;
	if (FAILED(hr))
	{
		trace("Could not create inner component.", hr) ;
		return E_FAIL ;
	}

	trace("Get pointer to interface IZ to cache.") ;
	hr = m_pUnknownInner->QueryInterface(IID_IZ, (void**)&m_pIZ) ;
	if (FAILED(hr))
	{
		trace("Inner component does not support IZ.", hr) ;
		m_pUnknownInner->Release() ;
		m_pUnknownInner = NULL ;
		return E_FAIL ;
	}

	// Decrement the reference count caused by the QI call.
	trace("Got IZ interface pointer. Release reference.") ;
	GetOuterUnknown()->Release() ;
*/
	return S_OK ;
}

//
// FinalRelease - called by Release before it deletes the component
//
void CMDH::FinalRelease()
{
	// Call base class to incremement m_cRef to prevent recusion.
	CUnknown::FinalRelease() ;

	// Counter the GetOuterUnknown()->Release in the Init method.
	GetOuterUnknown()->AddRef() ;	

	// Properly release the pointer; there may be per-interface
	// reference counts.
	//m_pIZ->Release() ;

	// Release the aggregated component.
	if (m_pUnknownInner != NULL)
	{
		m_pUnknownInner->Release();
	}
}



///////////////////////////////////////////////////////////
//
// Creation function used by CFactory
//
HRESULT CMDH::CreateInstance(
    IUnknown* pUnknownOuter,
    CUnknown** ppNewComponent)
{
	if (pUnknownOuter != NULL)
	{
		// Don't allow aggregation.
		return CLASS_E_NOAGGREGATION ;
	}
	
    *ppNewComponent = new CMDH(pUnknownOuter);
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\util.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// util.cpp - Common utilities for printing out messages
//
//


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above


#pragma warning (disable: 4786)
#pragma warning (disable: 4284)


#include <objbase.h>
#include <comdef.h>
#include <stdio.h>    //sprintf
#include <stdlib.h>
#include <assert.h>
#include <strstrea.h>
#include <vector>
#include <DskQuota.h>


#include <ntioapi.h>
#include "util.h"







// This function does pretty much all of the
// work this com server was constructed to do -
// it obtains, for the process space that this
// server is running in, the set of mapped
// drives, and for each of these, the following
// information as well:
// 
HRESULT GetMappedDisksAndData(
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = S_OK;
    ::SetLastError(ERROR_SUCCESS);
    DWORD dwError = ERROR_SUCCESS;

    ::VariantInit(pvarData);
	V_VT(pvarData) = VT_EMPTY;

    // Get list of drives...
    DWORD dwBuffLen = 0L;
    
    if((dwBuffLen = ::GetLogicalDriveStrings(
        0,
        NULL)) != 0)
    {
        LPWSTR wstrDrives = NULL;
        try
        {
            wstrDrives = new WCHAR[dwBuffLen];
            if(wstrDrives)
            {
                DWORD dwTmp;
                ::ZeroMemory((LPVOID)wstrDrives, dwBuffLen*sizeof(WCHAR));
                ::SetLastError(ERROR_SUCCESS);
                
                dwTmp = ::GetLogicalDriveStrings(
                    dwBuffLen,
                    wstrDrives);
                if(dwTmp <= dwBuffLen)
                {
                    // O.K, we now have the drive strings.
                    // Put only the mapped drives into a vector...
                    std::vector<_bstr_t> vecMappedDrives;
                    GetMappedDriveList(
                        wstrDrives,
                        vecMappedDrives);

                    // Now allocate the two dimensional
                    // safearray that will hold the properties
                    // for each mapped drive...
                    SAFEARRAY* saDriveProps = NULL;
                    SAFEARRAYBOUND rgsabound[2];
                    
                    rgsabound[0].cElements = PROP_COUNT;
	                rgsabound[0].lLbound = 0; 

                    rgsabound[1].cElements = vecMappedDrives.size();
	                rgsabound[1].lLbound = 0;

                    saDriveProps = ::SafeArrayCreate(
                        VT_BSTR, 
                        2, 
                        rgsabound);

                    if(saDriveProps)
                    {
                        // For each mapped drive, obtain its
                        // properties and store in the safearray...
                        for(long m = 0;
                            m < vecMappedDrives.size() && SUCCEEDED(hr);
                            m++)
                        {
                            hr = GetMappedDriveInfo(
                                vecMappedDrives[m],
                                m,
                                saDriveProps,
                                dwReqProps);
                        }

                        // And finally package the safearray
                        // into the outgoing variant.
                        if(SUCCEEDED(hr))
                        {
                            ::VariantInit(pvarData);
	                        V_VT(pvarData) = VT_BSTR | VT_ARRAY; 
                            V_ARRAY(pvarData) = saDriveProps;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    dwError = ::GetLastError();
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete wstrDrives; wstrDrives = NULL;
        }
        catch(...)
        {
            if(wstrDrives)
            {
                delete wstrDrives; wstrDrives = NULL;
            }
            throw;
        }
    }
    else if(dwBuffLen == 0 &&
        (dwError = ::GetLastError()) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


// Similar to GetMappedDisksAndData, but only
// retrieves info for a single disk.
HRESULT GetSingleMappedDiskAndData(
    BSTR bstrDrive,
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = S_OK;
    ::SetLastError(ERROR_SUCCESS);
    DWORD dwError = ERROR_SUCCESS;

    ::VariantInit(pvarData);
	V_VT(pvarData) = VT_EMPTY;

    // Get list of drives...
    DWORD dwBuffLen = 0L;
    
    if((dwBuffLen = ::GetLogicalDriveStrings(
        0,
        NULL)) != 0)
    {
        LPWSTR wstrDrives = NULL;
        try
        {
            wstrDrives = new WCHAR[dwBuffLen];
            if(wstrDrives)
            {
                DWORD dwTmp;
                ::ZeroMemory((LPVOID)wstrDrives, dwBuffLen*sizeof(WCHAR));
                ::SetLastError(ERROR_SUCCESS);
                
                dwTmp = ::GetLogicalDriveStrings(
                    dwBuffLen,
                    wstrDrives);
                if(dwTmp <= dwBuffLen)
                {
                    // O.K, we now have the drive strings.
                    // Put only the mapped drives into a vector...
                    std::vector<_bstr_t> vecMappedDrives;
                    GetMappedDriveList(
                        wstrDrives,
                        vecMappedDrives);

                    // Now allocate the two dimensional
                    // safearray that will hold the properties
                    // for each mapped drive...
                    // Note: in this routine, it is really
                    // only a one dimensional array, but,
                    // for code reuse, we'll treat it as a
                    // two dimensional array with only one
                    // element in one of the dimensions.
                    SAFEARRAY* saDriveProps = NULL;
                    SAFEARRAYBOUND rgsabound[2];
                    
                    rgsabound[0].cElements = PROP_COUNT; 
	                rgsabound[0].lLbound = 0; 

                    rgsabound[1].cElements = 1; // for code reuse
	                rgsabound[1].lLbound = 0;

                    saDriveProps = ::SafeArrayCreate(
                        VT_BSTR, 
                        2, 
                        rgsabound);

                    if(saDriveProps)
                    {
                        // See if the drive specified is a member
                        // of the vector.
                        _bstr_t bstrtTmp = bstrDrive;
                        bstrtTmp += L"\\";
                        bool fFoundIt = false;

                        for(long n = 0;
                            n < vecMappedDrives.size() && !fFoundIt;
                            n++)
                        {
                            if(_wcsicmp(bstrtTmp, vecMappedDrives[n]) == 0)
                            {
                                fFoundIt = true;
                                n--;
                            }
                        }
                        // For the mapped drive, obtain its
                        // properties and store in the safearray...
                        if(fFoundIt)
                        {
                            hr = GetMappedDriveInfo(
                                vecMappedDrives[n],
                                0,   // for code reuse
                                saDriveProps,
                                dwReqProps);

                            // And finally package the safearray
                            // into the outgoing variant.
                            ::VariantInit(pvarData);
	                        V_VT(pvarData) = VT_BSTR | VT_ARRAY; 
                            V_ARRAY(pvarData) = saDriveProps;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    dwError = ::GetLastError();
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete wstrDrives; wstrDrives = NULL;
        }
        catch(...)
        {
            if(wstrDrives)
            {
                delete wstrDrives; wstrDrives = NULL;
            }
            throw;
        }
    }
    else if(dwBuffLen == 0 &&
        (dwError = ::GetLastError()) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}



void GetMappedDriveList(
    LPWSTR wstrDrives,
    std::vector<_bstr_t>& vecMappedDrives)
{
    for(LPWSTR wstrCurrentDrive = wstrDrives;
		*wstrCurrentDrive;
		wstrCurrentDrive += (wcslen(wstrCurrentDrive) + 1))
    {
        _wcsupr(wstrCurrentDrive);
        if(::GetDriveType(wstrCurrentDrive) == DRIVE_REMOTE)
        {
            vecMappedDrives.push_back(wstrCurrentDrive);
        }
    }
}


HRESULT GetMappedDriveInfo(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps,
    DWORD dwReqProps)
{
    HRESULT hr = S_OK;

    // Right away we can set the device id prop...
    hr = SetProperty(
        lDrivePropArrayDriveIndex,
        PROP_DEVICEID,
        wstrDriveName,
        saDriveProps);

    // If we couldn't even set the device id, it is
    // a problem.  Otherwise, continue.
    if(SUCCEEDED(hr))
    {
        // Set the other properties if they
        // were requested...
        // Get Expensive properties now if appropriate.
	    if(dwReqProps &
            (SPIN_DISK |
            GET_PROVIDER_NAME))
        {
			if(dwReqProps & GET_PROVIDER_NAME)
			{   
                GetProviderName(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
            }

            if(dwReqProps & GET_VOL_INFO)
			{
				// Obtain volume information
				GetDriveVolumeInformation(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
			}

			
			if ( dwReqProps &
				(PROP_SIZE |
				 PROP_FREE_SPACE) )
			{
				GetDriveFreeSpace(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
			}
        }

    }

    return hr;
}



HRESULT GetProviderName(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;

    WCHAR wstrTempDrive[_MAX_PATH] ;
	wsprintf(
        wstrTempDrive, 
        L"%c%c", 
        wstrDriveName[0], 
        wstrDriveName[1]);

	WCHAR wstrProvName[_MAX_PATH];
	DWORD dwProvName = sizeof(wstrProvName ) ;

	DWORD dwRetCode = WNetGetConnection(
        wstrTempDrive, 
        wstrProvName, 
        &dwProvName);

	if(dwRetCode == NO_ERROR)
	{
		hr = SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_PROVIDER_NAME,
            wstrProvName,
            saDriveProps);
	}
	else
	{
		dwRetCode = GetLastError();

		if((dwRetCode == ERROR_MORE_DATA) && 
            (dwProvName > _MAX_PATH))
		{
			WCHAR* wstrNewProvName = NULL;
            try
            {
                wstrNewProvName = new WCHAR[dwProvName];
			    if(wstrNewProvName != NULL)
			    {
					dwRetCode = WNetGetConnection(
                        wstrTempDrive, 
                        wstrNewProvName, 
                        &dwProvName);

					if(dwRetCode == NO_ERROR)
					{
						hr = SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_PROVIDER_NAME,
                            wstrNewProvName,
                            saDriveProps);
					}
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwRetCode);
                    }

				    delete wstrNewProvName;
                }
                else
			    {
				    hr = E_OUTOFMEMORY;
			    }
            }
            catch( ... )
			{
				delete wstrNewProvName;
				throw;
			}
		}
        else
        {
            hr = HRESULT_FROM_WIN32(dwRetCode);
        }
	}

    return hr;
}



HRESULT GetDriveVolumeInformation(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;
    DWORD dwResult = ERROR_SUCCESS;

	WCHAR wstrVolumeName[_MAX_PATH];
	WCHAR wstrFileSystem[_MAX_PATH];
    WCHAR wstrTmp[_MAX_PATH];
    DWORD dwSerialNumber;
	DWORD dwMaxComponentLength;
	DWORD dwFSFlags;

	BOOL fReturn = ::GetVolumeInformation(
		wstrDriveName,
		wstrVolumeName,
		sizeof(wstrVolumeName)/sizeof(WCHAR),
		&dwSerialNumber,
		&dwMaxComponentLength,
		&dwFSFlags,
		wstrFileSystem,
		sizeof(wstrFileSystem)/sizeof(WCHAR)
	);

    if(fReturn)
	{
	    // Win32 API will return volume information for all drive types.
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_VOLUME_NAME,
            wstrVolumeName,
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_FILE_SYSTEM,
            wstrFileSystem,
            saDriveProps);

        if (dwSerialNumber != 0)
        {
	        WCHAR wstrSerialNumber[_MAX_PATH];
            wsprintf(wstrSerialNumber, 
                L"%.8X", 
                dwSerialNumber);

            SetProperty(
                lDrivePropArrayDriveIndex,
                PROP_VOLUME_SERIAL_NUMBER,
                wstrSerialNumber,
                saDriveProps);
        }

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_COMPRESSED,
            STR_FROM_bool(dwFSFlags & FS_VOL_IS_COMPRESSED),
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SUPPORTS_FILE_BASED_COMPRESSION,
            STR_FROM_bool(dwFSFlags & FS_FILE_COMPRESSION),
            saDriveProps);

        _ultow(dwMaxComponentLength,
            wstrTmp,
            10);
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_MAXIMUM_COMPONENT_LENGTH,
            wstrTmp,
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SUPPORTS_DISK_QUOTAS,
            STR_FROM_bool(dwFSFlags & FILE_VOLUME_QUOTAS),
            saDriveProps);

		

		// To get the state of the volume, 
        // we need to get the Interface pointer...
        IDiskQuotaControlPtr pIQuotaControl;
        ::SetLastError(ERROR_SUCCESS);

		if(SUCCEEDED(CoCreateInstance(
		    CLSID_DiskQuotaControl,
		    NULL,
		    CLSCTX_INPROC_SERVER,
		    IID_IDiskQuotaControl,
		    (void **)&pIQuotaControl)))
		{
			WCHAR wstrVolumePathName[MAX_PATH + 1];
            ::SetLastError(ERROR_SUCCESS);

			BOOL fRetVal = ::GetVolumePathName(
			    wstrDriveName,    
			    wstrVolumePathName, 
			    MAX_PATH);

			if(fRetVal)
			{
				::SetLastError(ERROR_SUCCESS);
                if(SUCCEEDED(pIQuotaControl->Initialize(
                    wstrVolumePathName, 
                    TRUE)))
				{
					DWORD dwQuotaState;
                    ::SetLastError(ERROR_SUCCESS);

					hr = pIQuotaControl->GetQuotaState(&dwQuotaState);
					if(SUCCEEDED(hr))
					{
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_INCOMPLETE,
                            STR_FROM_bool(DISKQUOTA_FILE_INCOMPLETE(dwQuotaState)),
                            saDriveProps);
					
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_REBUILDING,
                            STR_FROM_bool(DISKQUOTA_FILE_REBUILDING(dwQuotaState)),
                            saDriveProps);
				
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_DISABLED,
                            STR_FROM_bool(DISKQUOTA_STATE_DISABLED & dwQuotaState),
                            saDriveProps);
					}
					else
					{
						dwResult = GetLastError();
					}
				}
				else
				{
					dwResult = GetLastError();
				}
			}
		}
		else
		{
			dwResult = GetLastError();
		}
    }
    else
    {
        dwResult = GetLastError();
    }

    // for chkdsk VolumeDirty Property
	BOOLEAN fVolumeDirty = FALSE;
	BOOL fSuccess = FALSE;

	_bstr_t bstrtDosDrive(wstrDriveName);
	UNICODE_STRING string;

	RtlDosPathNameToNtPathName_U(
        (LPCWSTR)bstrtDosDrive, 
        &string, 
        NULL, 
        NULL);

	string.Buffer[string.Length/sizeof(WCHAR) - 1] = 0;
	_bstr_t nt_drive_name(string.Buffer);

    ::SetLastError(ERROR_SUCCESS);
	fSuccess = IsVolumeDirty(
        nt_drive_name, 
        &fVolumeDirty );

	if(fSuccess)
	{
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_PERFORM_AUTOCHECK,
            STR_FROM_bool(!fVolumeDirty),
            saDriveProps);
	}

    if(dwResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }

    return hr;
}




BOOLEAN IsVolumeDirty(
    _bstr_t &bstrtNtDriveName,
    BOOLEAN *Result)
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h;
    ULONG               r;
	BOOLEAN				bRetVal = FALSE;
    WCHAR               wstrNtDriveName[_MAX_PATH];

    wcscpy(wstrNtDriveName, bstrtNtDriveName);
    u.Length = (USHORT) wcslen(wstrNtDriveName) * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = wstrNtDriveName;

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    status = NtOpenFile(
        &h,
        SYNCHRONIZE | FILE_READ_DATA,
        &obj,
        &iosb,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        FILE_SYNCHRONOUS_IO_ALERT);

    if(NT_SUCCESS(status)) 
	{
		status = NtFsControlFile(
            h, NULL, NULL, NULL,
            &iosb,
            FSCTL_IS_VOLUME_DIRTY,
            NULL, 0,
            &r, sizeof(r));

		if(NT_SUCCESS(status)) 
		{

#if(_WIN32_WINNT >= 0x0500)
			*Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
			*Result = (BOOLEAN)r;
#endif
			bRetVal = TRUE;
		}

		NtClose(h);
	}

	return bRetVal;
}



HRESULT GetDriveFreeSpace(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
	HRESULT hr = S_OK;

	ULARGE_INTEGER uliTotalBytes;
	ULARGE_INTEGER uliUserFreeBytes;
	ULARGE_INTEGER uliTotalFreeBytes;

    ::SetLastError(ERROR_SUCCESS);
	if(::GetDiskFreeSpaceEx(
        wstrDriveName, 
        &uliUserFreeBytes, 
        &uliTotalBytes, 
        &uliTotalFreeBytes))
	{
		WCHAR wstrTmp[128] = { L'\0' };
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SIZE,
            _ui64tow(
                uliTotalBytes.QuadPart,
                wstrTmp,
                10),
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_FREE_SPACE,
            _ui64tow(
                uliTotalFreeBytes.QuadPart,
                wstrTmp,
                10),
            saDriveProps);

	}
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());    
    }

    return hr;
}



// Sets a property for a given drive
// in the drive safearray.
HRESULT SetProperty(
    long lDrivePropArrayDriveIndex,
    long lDrivePropArrayPropIndex,
    LPCWSTR wstrPropValue,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;

    BSTR bstrTmp = NULL;
    try
    {
        bstrTmp = ::SysAllocString(wstrPropValue);
        long ix[2];
        ix[0] = lDrivePropArrayPropIndex;
        ix[1] = lDrivePropArrayDriveIndex;

        hr = ::SafeArrayPutElement(
            saDriveProps, 
            ix, 
            bstrTmp);
    }
    catch(...)
    {
        if(bstrTmp != NULL)
        {
            ::SysFreeString(bstrTmp);
            bstrTmp = NULL;
        }
        throw;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\outproc.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#include <windows.h>
#include <stdlib.h>

#include "CUnknown.h"
#include "CFactory.h"
#include "MD.h"
//#include "Resource.h"

///////////////////////////////////////////////////////////
//
// Outproc.cpp
//   - the component server
//
HWND g_hWndListBox = NULL;

BOOL InitWindow(int nCmdShow);
extern "C" LONG APIENTRY MainWndProc(
    HWND hWnd,
    UINT message,
    UINT wParam,
    LONG lParam);


extern "C" int WINAPI WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, 
    int nCmdShow)
{
	// Controls whether UI is shown or not
	BOOL bUI = TRUE ;

	// If TRUE, don't loop.
	BOOL bExit = FALSE ;

	// Initialize the COM Library.

    HRESULT hr = CoInitializeEx(
		0, 
		COINIT_MULTITHREADED);

	if(FAILED(hr))
	{
		return 0;
	}
    /*
	hr = CoInitializeSecurity(
		NULL, 
		-1, 
		NULL, 
		NULL,
		RPC_C_AUTHN_LEVEL_CONNECT,
		RPC_C_IMP_LEVEL_IMPERSONATE, 
		NULL, 
		EOAC_DYNAMIC_CLOAKING, 
		0);
    */
    hr = CoInitializeSecurity(
		(PVOID)&CLSID_MDHComp, 
		NULL, 
		NULL, 
		NULL,
		NULL,
		NULL, 
		NULL, 
		EOAC_APPID, 
		NULL);
	if (FAILED(hr))
	{
    	CoUninitialize();
		return 0;
	}
    
	// Get Thread ID.
	CFactory::s_dwThreadID = ::GetCurrentThreadId() ;
	CFactory::s_hModule = hInstance ;

	// Read the command line.
	char szTokens[] = "-/" ;

	char* szToken = strtok(lpCmdLine, szTokens) ; 
	while (szToken != NULL)
	{
		if (_stricmp(szToken, "UnregServer") == 0)
		{
			CFactory::UnregisterAll() ;
			// We are done, so exit.
			bExit = TRUE ;
			bUI = FALSE ;
            //MessageBox(NULL,L"PSH un-registration successful",L"MDH", MB_OK);
		}
		else if (_stricmp(szToken, "RegServer") == 0)
		{
			CFactory::RegisterAll() ;
			// We are done, so exit.
			bExit = TRUE ;
			bUI = FALSE ;
            //MessageBox(NULL,L"PSH registration successful",L"MDH", MB_OK);
		}
		else if (_stricmp(szToken, "Embedding") == 0)
		{
			// Don't display a window if we are embedded.
			bUI = FALSE ;
			break ;
		}
		szToken = strtok(NULL, szTokens) ;
	}

	// If the user started us, then show UI.
	if (bUI)
	{
		if (!InitWindow(nCmdShow))
		{
			// Exit since we can't show UI.
			bExit = TRUE ;
		}
		else
		{
			::InterlockedIncrement(&CFactory::s_cServerLocks) ;
		}
	}

	if (!bExit)
	{
		// Register all of the class factories.
		CFactory::StartFactories() ;

		// Wait for shutdown.
		MSG msg ;
		while (::GetMessage(&msg, 0, 0, 0))
		{
			::DispatchMessage(&msg) ;
		}

		// Unregister the class factories.
		CFactory::StopFactories() ;
	}

	// Uninitialize the COM Library.
	CoUninitialize() ;
	return 0 ;
}


//
// Initialize window
//
BOOL InitWindow(int nCmdShow) 
{
	// Fill in window class structure with parameters
	// that describe the main window.
	WNDCLASS wcListview ;
	wcListview.style = 0 ;                     
	wcListview.lpfnWndProc = (WNDPROC)MainWndProc ; 
	wcListview.cbClsExtra = 0 ;              
	wcListview.cbWndExtra = 0 ;              
	wcListview.hInstance = CFactory::s_hModule ;
	wcListview.hIcon = ::LoadIcon(CFactory::s_hModule,
	                              MAKEINTRESOURCE(IDC_ICON)) ;
	wcListview.hCursor = ::LoadCursor(NULL, IDC_ARROW) ;
	wcListview.hbrBackground = static_cast<HBRUSH>(::GetStockObject(WHITE_BRUSH)); 
	wcListview.lpszMenuName = NULL ;  
	wcListview.lpszClassName = L"MyServerWinClass" ;

	BOOL bResult = ::RegisterClass(&wcListview) ;
	if (!bResult)
	{
		return bResult ;
	}

	HWND hWndMain ;

	hWndMain = ::CreateWindow(
		L"MyServerWinClass",
		L"Component Server", 
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT,
		CW_USEDEFAULT, CW_USEDEFAULT,
		NULL,               
		NULL,               
		CFactory::s_hModule,          
		NULL) ;

	// If window could not be created, return "failure".
	if (!hWndMain)
	{
		return FALSE ;
	}

	// Make the window visible; update its client area;
	// and return "success".
	::ShowWindow(hWndMain, nCmdShow) ;
	::UpdateWindow(hWndMain) ;
	return TRUE ;
}

//
// Main window procedure
//
extern "C" LONG APIENTRY MainWndProc(
	HWND hWnd,                // window handle
	UINT message,             // type of message
	UINT wParam,              // additional information
	LONG lParam)              // additional information
{
	//DWORD dwStyle ;

	switch (message) 
	{
	case WM_CREATE:
		{
			// Get size of main window
			CREATESTRUCT* pcs = (CREATESTRUCT*) lParam ;

			// Create a listbox for output.
			g_hWndListBox = ::CreateWindow(
				L"LISTBOX",
				NULL, 
				WS_CHILD | WS_VISIBLE | LBS_USETABSTOPS
					| WS_VSCROLL | LBS_NOINTEGRALHEIGHT,
				0, 0, pcs->cx, pcs->cy,
				hWnd,               
				NULL,               
				CFactory::s_hModule,          
				NULL) ;
			if (g_hWndListBox  == NULL)
			{
				// Listbox not created.
				//::MessageBox(NULL,
				//             "Listbox not created!",
				//             NULL,
				//             MB_OK) ;
				return -1 ;
			}
		}
		break ;

	case WM_SIZE:
		::MoveWindow(g_hWndListBox, 0, 0,
			LOWORD(lParam), HIWORD(lParam), TRUE) ;
		break;

	case WM_DESTROY:          // message: window being destroyed
		if (CFactory::CanUnloadNow() == S_OK)
		{
			// Only post the quit message, if there is
			// no one using the program.
			::PostQuitMessage(0) ;
		}
		break ;

	case WM_CLOSE:
		// Decrement the lock count.
		::InterlockedDecrement(&CFactory::s_cServerLocks) ;

		// The list box is going away.
		g_hWndListBox = NULL ;

		//Fall through      LRESULT
	default:
		return ((LONG)DefWindowProc(hWnd, message, wParam, lParam)) ;
	}
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\util.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#pragma once

//
// Util.h - Shared utilities
//





#define STR_FROM_bool(x) ( x ? L"TRUE" : L"FALSE" )



_COM_SMARTPTR_TYPEDEF(IDiskQuotaControl, IID_IDiskQuotaControl);


#define GET_NOTHING                             0x00000000
#define GET_ALL_PROPERTIES                      0xFFFFFFFF
#define GET_DEVICEID                            0x00000001
#define GET_PROVIDER_NAME                       0x00000002
#define GET_VOLUME_NAME                         0x00000004
#define GET_FILE_SYSTEM                         0x00000008
#define GET_VOLUME_SERIAL_NUMBER                0x00000010
#define GET_COMPRESSED                          0x00000020
#define GET_SUPPORTS_FILE_BASED_COMPRESSION     0x00000040
#define GET_MAXIMUM_COMPONENT_LENGTH            0x00000080
#define GET_SUPPORTS_DISK_QUOTAS                0x00000100
#define GET_QUOTAS_INCOMPLETE                   0x00000200
#define GET_QUOTAS_REBUILDING                   0x00000400
#define GET_QUOTAS_DISABLED                     0x00000800
#define GET_PERFORM_AUTOCHECK                   0x00001000
#define GET_FREE_SPACE                          0x00002000
#define GET_SIZE                                0x00004000

#define GET_VOL_INFO        (GET_VOLUME_NAME | \
                             GET_FILE_SYSTEM | \
                             GET_VOLUME_SERIAL_NUMBER | \
                             GET_COMPRESSED | \
                             GET_SUPPORTS_FILE_BASED_COMPRESSION | \
                             GET_MAXIMUM_COMPONENT_LENGTH | \
                             GET_SUPPORTS_DISK_QUOTAS | \
                             GET_QUOTAS_INCOMPLETE | \
                             GET_QUOTAS_REBUILDING | \
                             GET_QUOTAS_DISABLED | \
                             GET_PERFORM_AUTOCHECK)

#define SPIN_DISK           (GET_VOL_INFO | \
                             GET_FREE_SPACE | \
                             GET_SIZE)


enum 
{
    PROP_DEVICEID                          = 0,
    PROP_PROVIDER_NAME                     = 1,                   	
    PROP_VOLUME_NAME                       = 2,
    PROP_FILE_SYSTEM                       = 3,
    PROP_VOLUME_SERIAL_NUMBER              = 4,
    PROP_COMPRESSED                        = 5,
    PROP_SUPPORTS_FILE_BASED_COMPRESSION   = 6,
    PROP_MAXIMUM_COMPONENT_LENGTH          = 7,
    PROP_SUPPORTS_DISK_QUOTAS              = 8,
    PROP_QUOTAS_INCOMPLETE                 = 9,
    PROP_QUOTAS_REBUILDING                 = 10,
    PROP_QUOTAS_DISABLED                   = 11,
    PROP_PERFORM_AUTOCHECK                 = 12,
    PROP_FREE_SPACE                        = 13,
    PROP_SIZE                              = 14,

    PROP_COUNT                             = 15

};



// Principal function of this server.
HRESULT GetMappedDisksAndData(
    DWORD dwReqProps,
    VARIANT* pvarData);

HRESULT GetSingleMappedDiskAndData(
    BSTR bstrDrive,
    DWORD dwReqProps,
    VARIANT* pvarData);

void GetMappedDriveList(
    LPWSTR wstrDrives,
    std::vector<_bstr_t>& vecMappedDrives);

HRESULT GetMappedDriveInfo(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps,
    DWORD dwReqProps);

HRESULT GetProviderName(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps);

HRESULT GetDriveVolumeInformation(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps);

HRESULT GetDriveFreeSpace(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps);    

BOOLEAN IsVolumeDirty(
    _bstr_t &bstrtNtDriveName,
    BOOLEAN *Result);

HRESULT SetProperty(
    long lDrivePropArrayDriveIndex,
    long lDrivePropArrayPropIndex,
    LPCWSTR wstrPropValue, 
    SAFEARRAY* saDriveProps);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\server.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#pragma warning (disable: 4786)


#include <objbase.h>
#include "CFactory.h"
//#include "Iface.h"
#include "MD.h"
#include "Cmpnt1.h"
//#include "Cmpnt2.h"
//#include "Cmpnt3.h"

///////////////////////////////////////////////////////////
//
// Server.cpp
//
// This file contains the component server code.
// The FactoryDataArray contains the components that 
// can be served.
//

// Each component derived from CUnknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(IUnknown* pUnknownOuter, 
//                        CUnknown** ppNewComponent) ;
// This function is used to create the component.
//

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
	{
        &CLSID_MDHComp, 
        CMDH::CreateInstance, 
		"Mapped Logical Disk Helper",        // Friendly Name
		"MDHelp.MDHelp.1",                   // ProgID
		"MDHelp.MDHelp",                     // Version-independent ProgID
		NULL, 0
    }
} ;
int g_cFactoryDataEntries
	= sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\registry.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

#pragma once
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(
    HMODULE hModule, 
    const CLSID& clsid, 
    const char* szFriendlyName,
    const char* szVerIndProgID,
    const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(
    const CLSID& clsid,
    const char* szVerIndProgID,
    const char* szProgID) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\md_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for md.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMDH,0x89B231CE,0xB97B,0x41a4,0x9B,0x22,0x88,0xD3,0x56,0x4B,0x49,0x27);


MIDL_DEFINE_GUID(IID, LIBID_ServerLib,0xEF574A06,0x440D,0x47db,0xA6,0x7A,0x4B,0x15,0x2B,0xDD,0x7A,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_MDHComp,0x020E2BE2,0xF1CA,0x4322,0x8C,0x49,0x78,0x7B,0xF1,0x0E,0x3E,0x5E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for md.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMDH,0x89B231CE,0xB97B,0x41a4,0x9B,0x22,0x88,0xD3,0x56,0x4B,0x49,0x27);


MIDL_DEFINE_GUID(IID, LIBID_ServerLib,0xEF574A06,0x440D,0x47db,0xA6,0x7A,0x4B,0x15,0x2B,0xDD,0x7A,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_MDHComp,0x020E2BE2,0xF1CA,0x4322,0x8C,0x49,0x78,0x7B,0xF1,0x0E,0x3E,0x5E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\1394.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  1394.cpp
//
//  Purpose: 1394 Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include <cregcls.h>

#include "1394.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_1394 L"1394"

CWin32_1394Controller s_1394Controller ( PROPSET_NAME_1394CONTROLLER, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::CWin32_1394Controller
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_1394Controller :: CWin32_1394Controller (

	const CHString &a_Name ,
	LPCWSTR a_Namespace

) : Provider( a_Name, a_Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::~CWin32_1394Controller
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_1394Controller :: ~CWin32_1394Controller ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_1394Controller::GetObject
//
//  Inputs:     CInstance*      a_Instance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_1394Controller :: GetObject ( CInstance *a_Instance , long a_Flags, CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;

    // Let's see if config manager recognizes this device at all

    CHString t_DeviceID;
    a_Instance->GetCHString ( IDS_DeviceID , t_DeviceID ) ;

    CConfigManager t_ConfigurationManager ;
    CConfigMgrDevicePtr t_Device;

    if ( t_ConfigurationManager.LocateDevice ( t_DeviceID , &t_Device ) )
    {
        // Ok, it knows about it.  Is it a InfraRed device?

		if ( Is1394Controller ( t_Device ) )
		{
			// Yup, it must be one of ours.

			CHString t_Key ;
			a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

            DWORD t_SpecifiedProperties = GetBitMask(a_Query);

			t_Result = LoadPropertyValues ( a_Instance , t_Device , t_Key , t_SpecifiedProperties ) ;
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_1394Controller::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_1394Controller :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result ;
	t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_1394Controller :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask(a_Query);

	//if ( t_SpecifiedProperties )  //removed since would result in no query being executed if no special properties were selected.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

HRESULT CWin32_1394Controller :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report InfraRed info if we do it this way.

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_1394 ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
			try
			{
				CConfigMgrDevicePtr t_Device;

				t_Result = WBEM_S_NO_ERROR ;

				// Walk the list
                for (t_Device.Attach( t_DeviceList.GetNext ( t_Position ) );
                     SUCCEEDED( t_Result ) && (t_Device != NULL);
                     t_Device.Attach( t_DeviceList.GetNext ( t_Position ) ))
				{
					// Now to find out if this is the infrared controller

					if ( Is1394Controller ( t_Device ) )
					{
						CHString t_Key ;
						if ( t_Device->GetDeviceID ( t_Key ) )
						{
							CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
							if ( ( t_Result = LoadPropertyValues ( t_Instance , t_Device , t_Key , a_SpecifiedProperties ) ) == WBEM_S_NO_ERROR )
							{
								t_Result = t_Instance->Commit (  ) ;
							}
						}
					}

					// GetNext() AddRefs

				}

			}
			catch ( ... )
			{
				t_DeviceList.EndEnum () ;
                throw;
			}

			// Always call EndEnum().  For all Beginnings, there must be an End

			t_DeviceList.EndEnum () ;
        }
    }

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* a_Instance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_1394Controller :: LoadPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 12 ) ;
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_1394Controller::Is1394Controller
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of InfraRed device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid InfraRed class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32_1394Controller :: Is1394Controller ( CConfigMgrDevice *a_Device )
{
    BOOL t_Status = a_Device->IsClass(CONFIG_MANAGER_CLASS_1394) ;

    return t_Status ;
}

DWORD CWin32_1394Controller :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\mdhelp\mdhelpsvr\registry.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// Registry.cpp
//

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Determine if a particular subkey exists.
BOOL SubkeyExists(const char* pszPath,
                  const char* szSubkey) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(
    HMODULE hModule,            // DLL module handle
    const CLSID& clsid,         // Class ID
    const char* szFriendlyName, // Friendly Name
    const char* szVerIndProgID, // Programmatic
    const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileNameA(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
#ifdef _OUTPROC_SERVER_
	setKeyAndValue(szKey, "LocalServer32", szModule) ;
#else
	setKeyAndValue(szKey, "InprocServer32", szModule) ;
#endif

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(
    const CLSID& clsid,         // Class ID
    const char* szVerIndProgID, // Programmatic
    const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[80] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Check for a another server for this component.
#ifdef _OUTPROC_SERVER_
	if (SubkeyExists(szKey, "InprocServer32"))
#else
	if (SubkeyExists(szKey, "LocalServer32"))
#endif
	{
		// Delete only the path for this server.
#ifdef _OUTPROC_SERVER_
		strcat(szKey, "\\LocalServer32") ;
#else
		strcat(szKey, "\\InprocServer32") ;
#endif
		LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
		assert(lResult == ERROR_SUCCESS) ;
	}
	else
	{
		// Delete all related keys.
		// Delete the CLSID Key - CLSID\{...}
		LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

		// Delete the version-independent ProgID Key.
		lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

		// Delete the ProgID key.
		lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
	}
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(
    const CLSID& clsid,
    char* szCLSID,
    int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(
    HKEY hKeyParent,           // Parent of key to delete
    const char* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyExA(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyExA(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKeyA(hKeyParent, lpszKeyChild) ;
}

//
// Determine if a particular subkey exists.
//
BOOL SubkeyExists(
    const char* pszPath,    // Path of key to check
    const char* szSubkey)   // Key to check
{
	HKEY hKey ;
	char szKeyBuf[80] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, pszPath) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Determine if key exists by trying to open it.
	LONG lResult = ::RegOpenKeyExA(HKEY_CLASSES_ROOT, 
	                              szKeyBuf,
	                              0,
	                              KEY_ALL_ACCESS,
	                              &hKey) ;
	if (lResult == ERROR_SUCCESS)
	{
		RegCloseKey(hKey) ;
		return TRUE ;
	}
	return FALSE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(
    const char* szKey,
    const char* szSubkey,
    const char* szValue)
{
	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyExA(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExA(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\autochksetting.h ===
/******************************************************************



   AutoChkSetting.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef  _CAUTOCHKSETTING_H_
#define  _CAUTOCHKSETTING_H_

class CAutoChkSetting : public Provider 
{
private:
#ifdef NTONLY
		BOOLEAN QueryTimeOutValue(

			OUT PULONG  pulTimeOut
		);

		BOOLEAN SetTimeOutValue (

			IN  ULONG  ulTimeOut
		);
#endif

		HRESULT GetOSNameKey ( 

			CHString &a_OSName, 
            MethodContext *pContext
		);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;

        HRESULT PutInstance (

			const CInstance& Instance, 
			long lFlags = 0L
		) ;

public:
        
		CAutoChkSetting (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CAutoChkSetting () ;
private:
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\battery.h ===
//=================================================================

//

// Battery.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

// Property set identification
//=============================

#define PROPSET_NAME_BATTERY L"Win32_Battery"

class CBattery:public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        CBattery(const CHString& name, LPCWSTR pszNamespace) ;
       ~CBattery() ;

        // Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

        // Utility function(s)
        //====================
#ifdef NTONLY
		HRESULT GetNTBattery(MethodContext * pMethodContext, CHString & chsKey, CInstance * pInst);
		HRESULT GetBatteryProperties(CInstance * pInstance, BATTERY_INFORMATION & bi, BATTERY_QUERY_INFORMATION & bqi, HANDLE & hBattery );
		HRESULT GetHardCodedInfo(CInstance * pInst);
		HRESULT GetQueryBatteryInformation(CInstance * pInst, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi);
		HRESULT GetBatteryKey( HANDLE & hBattery, CHString & chsKey, BATTERY_QUERY_INFORMATION & bqi);
		HRESULT SetChemistry(CInstance * pInst, UCHAR * Type);
		HRESULT SetPowerManagementCapabilities(CInstance * pInst, ULONG Capabilities);
		HRESULT GetBatteryStatusInfo(CInstance * pInst, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi);
		HRESULT GetBatteryInformation(CInstance * pInstance, BATTERY_INFORMATION & bi );
#endif
        HRESULT GetBattery(CInstance *pInstance);

	private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bios.cpp ===
//=================================================================

//

// BIOS.CPP --BIOS property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/01/96    a-jmoon         Created
//              10/23/97	a-sanjes        Ported to new project
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "bios.h"

#include "smbios.h"
#include "smbstruc.h"

void FormatWBEMDate(WBEMTime &wbemdate, LPTSTR datestr);

BOOL ValidDate(int iMonth, int iDay)
{
	BOOL bRet = FALSE;

	if ((iMonth > 0) && (iMonth < 13) && (iDay > 0))
	{
		int iDays[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

		if (iDay <= iDays [iMonth - 1])
		{
			bRet = TRUE;
		}
	}

	return bRet;
}

// Property set declaration
//=========================

CWin32BIOS	biosSet(PROPSET_NAME_BIOS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32BIOS::CWin32BIOS
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32BIOS::CWin32BIOS(
	LPCWSTR szName,
	LPCWSTR szNamespace) :
    Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32BIOS::~CWin32BIOS
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32BIOS::~CWin32BIOS()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32BIOS::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32BIOS::GetObject(
	CInstance *pInstance,
	long lFlags)
{

    // Get the previous __RELPATH

	CHString strPathBefore;
    GetLocalInstancePath(pInstance, strPathBefore);

    HRESULT hr = LoadPropertyValues(pInstance);
	if (SUCCEEDED(hr))
	{
        // If we were able to get the BIOS properties but the new __RELPATH doesn't
        // match the old __RELPATH, return WBEM_E_NOT_FOUND.

		CHString strPathAfter;
		if (!GetLocalInstancePath(pInstance, strPathAfter) ||
            strPathAfter.CompareNoCase(strPathBefore) != 0)
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32BIOS::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32BIOS::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags)
{
	HRESULT	hr = S_OK;

	CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
	if ((hr = LoadPropertyValues(pInstance)) == WBEM_S_NO_ERROR)
	{
		hr = pInstance->Commit();
	}

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32BIOS::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance*	pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT		error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32BIOS::SetBiosDate(CInstance *pInstance, CHString &strDate)
{
    int iSlash1 = strDate.Find('/'),
	    iSlash2 = strDate.ReverseFind('/');

    if (iSlash1 != -1 && iSlash2 != -1 && iSlash1 != iSlash2)
	{
	    int iMonth,
            iDay,
            iYear;

		iMonth  = _wtoi(strDate.Left(iSlash1));
		iYear = _wtoi(strDate.Mid(iSlash2 + 1));
        
        // Up until the year 2080 we will treat the two
        // digit year as 19xx if it was >= 80, and 20xx
        // if it was < 80.  After 2080, we will always
        // treat the year as being 20xx.
        SYSTEMTIME st;
        GetLocalTime(&st);

        WORD wYearToday = st.wYear;

        // If the bios gave us a four digit year, we
        // don't need to make any special adjustments.
        if(iYear < 1000)
        {
            if(wYearToday < 2080)
            {
                if (iYear >= 80 && iYear < 100)
                {
                    iYear += 1900;
                }
                else
                {
                    if(iYear < 100)
                    {
                        iYear += 2000;
                    }
                    else
                    {
                        iYear += 1900;
                    }
                }
            }
            else
            {
                iYear += 2000;
            }
        }

        iDay = _wtoi(strDate.Mid(iSlash1 + 1, iSlash2 - iSlash1 - 1));

		if (ValidDate(iMonth, iDay))
		{
			// Convert to the DMTF format and send it in
			WCHAR szDate[100];

			swprintf(
				szDate,
				L"%d%02d%02d******.******+***",
				iYear,
				iMonth,
				iDay);

			pInstance->SetCharSplat(IDS_ReleaseDate, szDate);
		}
	}
}

HRESULT CWin32BIOS::LoadPropertyValues(CInstance *pInstance)
{
	// Assign dummy name in case we can't get the real one
	//====================================================

	pInstance->SetCHString(IDS_Name, IDS_BIOS_NAME_VALUE);

#ifdef _IA64_
	BOOL bUsedDefault = FALSE;
#endif

	// Fill in 'of-course' properties
	//===============================
	// okay - I'm making a wild assumption here.  I'm assuming that
	// if the BIOS is broken, then we won't be here!

	pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

#ifdef NTONLY

	CRegistry reg;

	DWORD dwErr = reg.Open( HKEY_LOCAL_MACHINE, IDS_RegBiosSystem,  KEY_READ);
	if (dwErr == ERROR_SUCCESS)
	{
		CHString sDate;

		dwErr = reg.GetCurrentKeyValue( IDS_RegSystemBiosDate,sDate);
		if (dwErr != ERROR_SUCCESS)
		{
            // hardcode and go on
			// return WinErrorToWBEMhResult(dwErr);
            sDate = ""; 
		}

		SetBiosDate(pInstance, sDate);

		// Need to retrieve a REG_MULTI_SZ -- can't use registry class
		//============================================================

		HKEY hKey = reg.GethKey();

		WCHAR szTemp[MAX_PATH * 2];
		DWORD dwType = 0;
		DWORD dwSize = sizeof(szTemp);

		// Clear this in case it doesn't have a double '\0' at the end
        // (which is the case on some Alphas).
        memset(szTemp, 0, sizeof(szTemp));

        dwErr =  RegQueryValueEx(hKey,	IDS_RegSystemBiosVersion,	NULL,	&dwType,(LPBYTE) szTemp,&dwSize);

		// If the call succeeded and there was data in the value, use it.
        if (dwErr == ERROR_SUCCESS && *szTemp)
		{
			//this only uses the first element of the array
			pInstance->SetCHString(IDS_Version, szTemp);

			//now use them all...
			wchar_t* szTemptmp = szTemp;
            int x = 0;

            while (*szTemptmp != L'\0')
            {
				x++;
                szTemptmp += wcslen(szTemptmp) + 1;
            }

			if (0 != x)
			{
				SAFEARRAYBOUND rgsabound[1];
				SAFEARRAY* psa = NULL;
				BSTR* pBstr = NULL;
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = x;
				psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);

				try
				{
					if (NULL != psa)
					{
						if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
						{
							try
							{
								szTemptmp = szTemp;

								for (LONG i = 0; i < x; i++)
								{
									pBstr[i] = SysAllocString(szTemptmp);
									szTemptmp += wcslen(szTemptmp) + 1;
								}
							}
							catch(...)
							{
								SafeArrayUnaccessData(psa);
								throw;
							}

							SafeArrayUnaccessData(psa);
							pInstance->SetStringArray(L"BIOSVersion", *psa);
						}
					}
				}
				catch(...)
				{
					SafeArrayDestroy(psa);
					throw;
				}

				SafeArrayDestroy(psa);
			}

			TCHAR *c = _tcschr(szTemp, 0); // L10N OK
			if (c != NULL && *(++c))
			{
				pInstance->SetCHString(IDS_Name, c);
			}
		}
		else
		{
			// Version is part of the key and cannot be null

            // If we don't have a version in the registry, use the date.  Compaq
            // does this on purpose(the date is the version).  This seems better
            // anyway than setting Version to "".
            sDate = IDS_Unknown; 

            pInstance->SetCHString(IDS_Version, sDate);

#ifdef _IA64_
			bUsedDefault = TRUE;
#endif
		}

	}
	else
	{
		return WinErrorToWBEMhResult(dwErr);
	}

#endif

#ifdef WIN9XONLY

	CRegistry reg;

	DWORD dwErr =
        reg.Open(
		    HKEY_LOCAL_MACHINE,
		    IDS_RegEnumRootBios,
		    KEY_READ);

    if (dwErr == ERROR_SUCCESS)
    {
		CHString sTemp;

		dwErr =
            reg.GetCurrentKeyValue(
			    IDS_RegBIOSName,
			    sTemp);

		if (!dwErr)
		{
			pInstance->SetCHString(IDS_Name, sTemp);
		}

		dwErr =
            reg.GetCurrentKeyValue(
    			IDS_RegBIOSDate,
	    		sTemp);

		if (!dwErr)
		{

//
// HKEY_USERS\.DEFAULT\Control Panel\International
//      sDate
//      sShortDate
//
//=======================================================

			SetBiosDate(pInstance, sTemp);
		}

		dwErr =
            reg.GetCurrentKeyValue(
    			IDS_RegBIOSVersion,
	    		sTemp);

		if (!dwErr)
		{
			pInstance->SetCHString(IDS_Version, sTemp);
		}
		else
		{
			// Version is part of the key and cannot be null
			pInstance->SetCHString(IDS_Version, L"");
		}

    }
#endif

	// set descr & caption to same as name

	CHString sTemp;

	if (pInstance->GetCHString(IDS_Name, sTemp))
	{
		pInstance->SetCHString(IDS_Caption, sTemp);
		pInstance->SetCHString(L"SoftwareElementID", sTemp);
		pInstance->SetCHString(IDS_Description, sTemp);
	}

    pInstance->SetWBEMINT16(L"SoftwareElementState", 3);

    // 0 is unknown, since we don't know what OS the BIOS was targeted for.
    pInstance->SetWBEMINT16(L"TargetOperatingSystem", 0);

    pInstance->Setbool(L"PrimaryBIOS", true);

    CSMBios smbios;
    if (smbios.Init())
    {
        CHString strSerial;

		DWORD dwVersion = smbios.GetVersion();

		pInstance->Setbool(L"SMBIOSPresent", true);
		pInstance->SetDWORD(L"SMBIOSMajorVersion", HIWORD(dwVersion));
		pInstance->SetDWORD(L"SMBIOSMinorVersion", LOWORD(dwVersion));

        PSTLIST	pstl = smbios.GetStructList(1);
        if (pstl)
        {
            PSYSTEMINFO psi = (PSYSTEMINFO) pstl->pshf;

            smbios.GetStringAtOffset(
				(PSHF) psi,
				strSerial.GetBuffer(256),
                psi->Serial_Number);

            strSerial.ReleaseBuffer();
            if (!strSerial.IsEmpty())
			{
                pInstance->SetCHString(L"SerialNumber", strSerial);
			}
        }

		// Get BIOS characteristics from BIOS info structure.

        pstl = smbios.GetStructList(0);
		if (pstl)
		{
			PBIOSINFO pbi = (PBIOSINFO) pstl->pshf;
            WCHAR     szTemp[256];

			if (smbios.GetStringAtOffset((PSHF) pbi, szTemp, pbi->Vendor))
			{
				pInstance->SetCHString(L"Manufacturer", szTemp);
			}

			//use SMBIOS release date in preference...
			if(!smbios.GetStringAtOffset((PSHF) pbi, sTemp.GetBuffer(256), pbi->BIOS_Release_Date))
			{
				sTemp.ReleaseBuffer();
				sTemp.Empty();
			}
			else
			{
				sTemp.ReleaseBuffer();

				if(!sTemp.IsEmpty())
				{
					SetBiosDate(pInstance, sTemp);
				}
			}

			if (smbios.GetStringAtOffset((PSHF) pbi, szTemp, pbi->BIOS_Version))
			{
			 	pInstance->SetCHString(L"SMBIOSBIOSVersion", szTemp);

#ifdef _IA64_
				//behavior change, IA64 only!
				if (bUsedDefault)
				{
					pInstance->SetCHString(IDS_Version, szTemp);
				}
#endif
			}

            // find out how many items to initialize safe array for...

			SAFEARRAYBOUND sab;
			sab.lLbound = 0;
			sab.cElements = 0;

			// get the first 32 bits
            DWORD biosbits = 0;
            memcpy( &biosbits, pbi->BIOS_Characteristics, sizeof(DWORD));

			DWORD extbytes = 0;

			// gather the # of extention bytes
			if (smbios.GetVersion() > 0x00020000 && pbi->Length >= sizeof(BIOSINFO))
			{
				extbytes = pbi->Length - 0x12;
			}

			// figure out how many array items are needed
			while(biosbits)
			{
				if (biosbits & 0x00000001)
				{
					sab.cElements++;
				}
				biosbits >>= 1;
			}

			// check for stuff in the extension byte/s
			for (DWORD i = 0; i < extbytes; i++)
			{
				biosbits = (DWORD) pbi->BIOS_Characteristics_Ext[i];
				while(biosbits)
				{
					if (biosbits & 0x00000001)
					{
						sab.cElements++;
					}

					biosbits >>= 1;
				}
			}

			// create array and set the characteristics values
            variant_t v;

			v.parray = SafeArrayCreate(VT_I4, 1, &sab);;
			if (v.parray)
			{
                // This is done here so the v destructor won't destruct
                // unless there is something to destruct
    			v.vt = VT_ARRAY | VT_I4;

		        memcpy( &biosbits, pbi->BIOS_Characteristics, sizeof(DWORD));

				long index = 0;

				for (i = 0; i < 32 && biosbits; i++)
				{
					if (biosbits & 0x00000001)
					{
						HRESULT t_Result = SafeArrayPutElement(v.parray, & index, & i);
						if (t_Result == E_OUTOFMEMORY)
						{
							throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
						}

						index++;
					}
					biosbits >>= 1;
				}

				DWORD baseval = 32;
				DWORD setval = 0;

				// tack on the extended characteristics
				for (i = 0; i < extbytes; i++)
				{
					biosbits = (DWORD) pbi->BIOS_Characteristics_Ext[i];

					DWORD j;

					for (j = 0; j < 8 && biosbits; j++)
					{
						if (biosbits & 0x00000001)
						{
							setval = j + baseval;
							HRESULT t_Result = SafeArrayPutElement(v.parray, &index, &setval);
							if (t_Result == E_OUTOFMEMORY)
							{
								throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}

							index++;
						}

						biosbits >>= 1;
					}

					baseval += 8;
				}

				if (sab.cElements > 0)
				{
					pInstance->SetVariant(L"BiosCharacteristics", v);
				}

			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}

        pstl = smbios.GetStructList(13);
		if (pstl)
		{
			PBIOSLANGINFO pbli = (PBIOSLANGINFO) pstl->pshf;
            pInstance->SetDWORD(L"InstallableLanguages", pbli->Installable_Languages);

			WCHAR szTemp[MAX_PATH];
			smbios.GetStringAtOffset((PSHF) pbli, szTemp, pbli->Current_Language);

			pInstance->SetCHString(L"CurrentLanguage", szTemp);

	 		SAFEARRAYBOUND sab;
			sab.lLbound = 0;
			sab.cElements = pbli->Installable_Languages;

			SAFEARRAY *psa = SafeArrayCreate(VT_BSTR, 1, &sab);
			if (psa)
			{
				for (DWORD i = 0; i < pbli->Installable_Languages; i++)
				{
					int len = smbios.GetStringAtOffset((PSHF) pbli, szTemp, i + 1);
					SafeArrayPutElement(psa,(long *) & i,(BSTR) _bstr_t(szTemp));
				}

				pInstance->SetStringArray(L"ListOfLanguages", *psa);

				SafeArrayDestroy(psa);
			}
			else
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
    }
	else	// indicate that no SMBIOS is found
	{
		pInstance->Setbool(L"SMBIOSPresent", false);
	}

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\battery.cpp ===
//=================================================================

//

// Battery.cpp

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "resource.h"
#include <batclass.h>
#include <setupapi.h>
#include "Battery.h"

// Property set declaration
//=========================


CBattery MyBattery(PROPSET_NAME_BATTERY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CBattery::CBattery
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CBattery :: CBattery (

	const CHString &name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CBattery::~CBattery
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CBattery::~CBattery()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : CBattery::GetObject
 *
 *  DESCRIPTION : Assigns values to properties in our set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CBattery :: GetObject (

	CInstance* pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRetCode = WBEM_E_NOT_FOUND;
    CHString sDeviceID;

    pInstance->GetCHString(IDS_DeviceID, sDeviceID);

#ifdef NTONLY
	hRetCode = GetNTBattery(NULL, sDeviceID, pInstance );

#endif

#ifdef WIN9XONLY
    // There is only one (hardcoded) instance of this class.  See
    // if that's what they're asking for.
    if (sDeviceID.CompareNoCase(IDS_BatteryName)  == 0)
	{
        hRetCode = GetBattery(pInstance);
    }
#endif

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CBattery::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of power supplies (1 if successful)
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CBattery::EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
   HRESULT hRetCode = WBEM_S_NO_ERROR;

#ifdef NTONLY

   CHString sTmp;
   hRetCode = GetNTBattery(pMethodContext, sTmp, NULL );

#endif

#ifdef WIN9XONLY

    CInstancePtr pInstance;
    pInstance.Attach(CreateNewInstance(pMethodContext));
	if (pInstance != NULL)
	{
	// Check for a battery (no UPS on 9x).

		hRetCode = GetBattery(pInstance);
		if (SUCCEEDED(hRetCode))
		{
			hRetCode = pInstance->Commit();
		}
    }

#endif

   return hRetCode;
}

/*****************************************************************************
 *
  *  DESCRIPTION :
 *
 *  INPUTS      : CInstance* pInstance
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful
 *
 *  COMMENTS    : This is specific to NT
 *
 *****************************************************************************/

#ifdef NTONLY
#define ID_Other	  1 	
#define ID_Unknown    2 
#define ID_Running    3
#define ID_Critical   5  
#define ID_Charging   6
#define ID_Degraded   10
//////////////////////////////////////////////////////////////////////////////////////////////
#define SPSAC_ONLINE        1
//
//  Values for SYSTEM_POWER_STATUS.BatteryFlag
//
#define SPSBF_NOBATTERY     128
#define OTHER_BATTERY        1
#define UNKNOWN_BATTERY      2
#define LEAD_ACID            3
#define NICKEL_CADMIUM       4
#define NICKEL_METAL_HYDRIDE 5
#define LITHIUM_ION          6
#define ZINC_AIR             7
#define LITHIUM_POLYMER      8
#define IDS_BatteryStatus L"BatteryStatus"
#define IDS_STATUS_Service L"Service"
#define IDS_STATUS_PredFail L"Failure"
const GUID GUID_DEVICE_BATTERY = { 0x72631e54L, 0x78A4, 0x11d0, { 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a } };

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryStatusInfo(CInstance * pInstance, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//==========================================================
    //  And then query the battery status.
	//==========================================================
    BATTERY_WAIT_STATUS bws;
    BATTERY_STATUS bs;
    ZeroMemory(&bws, sizeof(bws));
    bws.BatteryTag = bqi.BatteryTag;
	DWORD dwOut;
    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_STATUS, &bws, sizeof(bws), &bs,  sizeof(bs),  &dwOut, NULL)) 
	{
		//==========================================================
		// Design Voltage
		//==========================================================
		pInstance->SetDWORD ( L"DesignVoltage",bs.Voltage) ;

		//==========================================================
		//Availability, Status and BatteryStatus
		//==========================================================
        if (bs.PowerState & BATTERY_POWER_ON_LINE) 
		{
			//==========================================================
			//  BATTERY_POWER_ON_LINE Indicates that the system has 
			//  access to AC power, so no batteries are being discharged. 
			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK ) ;
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Unknown );
			pInstance->SetWBEMINT16(IDS_Availability,ID_Unknown);
		}
		else if( bs.PowerState & BATTERY_DISCHARGING )
		{
			//==========================================================
			//  BATTERY_DISCHARGING Indicates that the battery is 
			//  currently discharging. 
			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK );
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Other);
			pInstance->SetWBEMINT16(IDS_Availability,ID_Running);
		}
		else if( bs.PowerState & BATTERY_CHARGING )
		{
			//==========================================================
			//  BATTERY_CHARGING Indicates that the battery is currently
			//  charging. 
			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_Service );
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Charging );
			pInstance->SetWBEMINT16(IDS_Availability,ID_Other);
		}
		else if( bs.PowerState & BATTERY_CRITICAL )
		{
			//==========================================================
			//  BATTERY_CRITICAL Indicates that battery failure is
			// imminent. 
   			//==========================================================
			pInstance->SetCharSplat(IDS_Status, IDS_STATUS_PredFail );
			pInstance->SetWBEMINT16(IDS_BatteryStatus, ID_Critical );
			pInstance->SetWBEMINT16(IDS_Availability,ID_Degraded);
		}
	}
   	//==========================================================
	//  Need a valid way to determine this
   	//==========================================================
	// pInstance->SetWBEMINT16 ( L"EstimatedChargeRemaining" , Info.BatteryLifePercent ) ;
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::SetPowerManagementCapabilities(CInstance * pInst, ULONG Capabilities)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	//set the PowerManagementCapabilities to not supported...don't really match here yet
	variant_t      vCaps;
    SAFEARRAYBOUND rgsabound;
	long           ix;
    int iPowerCapabilities = 1; // not supported

    ix = 0;
	rgsabound.cElements = 1;
	rgsabound.lLbound   = 0;

	V_ARRAY(&vCaps) = SafeArrayCreate(VT_I2, 1, &rgsabound);
    V_VT(&vCaps) = VT_I2 | VT_ARRAY;

	if (V_ARRAY(&vCaps))
	{
        if (S_OK == SafeArrayPutElement(V_ARRAY(&vCaps), &ix, &iPowerCapabilities))
		{
			pInst->SetVariant(IDS_PowerManagementCapabilities, vCaps);
		}
	}
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::SetChemistry(CInstance * pInstance, UCHAR * Type)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //=========================================================
    //  These are the battery types            What we need to
    //  returned by our query                  Convert it to
    // ------------------------------          ---------------
    //  PbAc Lead Acid                              LEAD_ACID
    //  LION Lithium Ion                            LITHIUM_ION
    //  NiCd Nickel Cadmium                         NICKEL_CADMIUM
    //  NiMH Nickel Metal Hydride                   NICKEL_METAL_HYDRIDE
    //  NiZn Nickel Zinc                            OTHER   
    //  RAM Rechargeable Alkaline-Manganese         OTHER
    //  else Unknown                                UNKNOWN
    //=========================================================
    WBEMINT16 Chemistry = UNKNOWN_BATTERY;

    if( memcmp( "PbAc", Type, 4 ) == 0 )
    {
        Chemistry = LEAD_ACID;
    }
    else if( memcmp( "LION", Type, 4) == 0 )
    {
        Chemistry = LITHIUM_ION;
    }
    else if( memcmp( "NiCd", Type, 4) == 0 )
    {
        Chemistry = NICKEL_CADMIUM;
    }
    else if( memcmp( "NiMH",Type, 4) == 0 )
    {
        Chemistry = NICKEL_METAL_HYDRIDE;
    }
    else if( memcmp( "NiZn", Type, 4) == 0 )
    {
        Chemistry = OTHER_BATTERY;
    }
    else if(memcmp( "RAM", Type, 4) == 0 )
    {
        Chemistry = OTHER_BATTERY;
    }

    pInstance->SetWBEMINT16( L"Chemistry", Chemistry );

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryInformation(CInstance * pInstance, BATTERY_INFORMATION & bi )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	//============================================
	// Property:  
	//		DeviceID
	//		Name
	//============================================
//	pInstance->SetDWORD ( L"FullChargeCapacity", bi.FullChargeCapacity ) ;

	//============================================
	// Property:  Powermanagementcapabilities
	//============================================
    hr = SetPowerManagementCapabilities(pInstance, bi.Capabilities);
    if ( WBEM_S_NO_ERROR == hr )
    {
		//============================================
		// Property:  Chemistry
		//============================================
		hr = SetChemistry( pInstance, bi.Chemistry );
	}
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryKey( HANDLE & hBattery, CHString & chsKey, BATTERY_QUERY_INFORMATION & bqi)
{
	HRESULT hr = WBEM_E_FAILED;
   //================================================
	//  With the tag, you can query the battery info.
	//  Get the Unique Id
	//================================================
	WCHAR bi[MAX_PATH*2];
	DWORD dwOut = MAX_PATH*2;
	memset( bi, NULL, MAX_PATH*2 );
	bqi.InformationLevel = BatteryUniqueID;
	if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi), &bi,  sizeof(bi), &dwOut, NULL)) 
	{
		//====================================
		//  Device ID
		//====================================
		chsKey = bi;
		hr = WBEM_S_NO_ERROR;
	}
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetQueryBatteryInformation(CInstance * pInstance, HANDLE & hBattery, BATTERY_QUERY_INFORMATION & bqi)
{
	HRESULT hr = WBEM_E_FAILED;
    //================================================
    //  Get the Name of the battery
    //================================================
    WCHAR bi[MAX_PATH*2];
	DWORD dwOut;
    bqi.InformationLevel = BatteryDeviceName;
    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi),  &bi,  sizeof(bi), &dwOut, NULL)) 
    {
		pInstance->SetCHString( IDS_Name, bi ) ;
		hr = WBEM_S_NO_ERROR;
    }
	//================================================
	//  Get the Estimated Run Time
	//================================================
	bqi.InformationLevel = BatteryEstimatedTime;
	ULONG dwBi = 0;
	if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi),  &dwBi,  sizeof(ULONG), &dwOut, NULL)) 
	{
		//====================================
		//  EstimatedRunTime
		//====================================
		pInstance->SetDWORD ( L"EstimatedRunTime", (dwBi/60) ) ;
		hr = WBEM_S_NO_ERROR;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetHardCodedInfo(CInstance * pInstance)
{
	HRESULT hr = WBEM_S_NO_ERROR;

    CHString sTemp2;
    LoadStringW(sTemp2, IDR_BatteryName);

	pInstance->SetCHString ( IDS_Caption , sTemp2 ) ;
	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () );
	SetCreationClassName   ( pInstance ) ;
	pInstance->SetCharSplat( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

    //=========================================================================
    // PowerManagementSupported
    //=========================================================================
	pInstance->Setbool(IDS_PowerManagementSupported, FALSE);
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBatteryProperties(CInstance * pInstance, BATTERY_INFORMATION & bi, BATTERY_QUERY_INFORMATION & bqi, HANDLE & hBattery )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//=========================================================================
	//  Set the following properties:
	//		Caption
	//		Description
	//		SystemName
	//		CreationClassName
	//		SystemCreationClassName
	//		PowerManagementSupported
	//=========================================================================
	hr = GetHardCodedInfo( pInstance );
	if( WBEM_S_NO_ERROR == hr )
	{

		//============================================
		// Property: 
		//		FullChargeCapacity
		//      Powermanagementcapabilities
		//      Chemistry
		//============================================
		hr = GetBatteryInformation(pInstance, bi);
		if ( WBEM_S_NO_ERROR == hr )
		{
			//============================================
			// Property: 
			//		BatteryEstimatedTime/60
			//		DeviceID
			//		Name
			//============================================
			hr = GetQueryBatteryInformation(pInstance, hBattery, bqi );
			if ( WBEM_S_NO_ERROR == hr )
			{
				//============================================
				// Property:  
				//		Status
				//		BatteryStatus
				//		Availability
				//============================================
				hr = GetBatteryStatusInfo( pInstance, hBattery, bqi );
			}
		}
	}
	return hr;                                         
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetNTBattery(MethodContext * pMethodContext, CHString & chsObject, CInstance * pInstance)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	BOOL fContinue = TRUE;
	BOOL fResetHr = TRUE;

    //=========================================================================
    //  Enumerate the batteries and ask each one for info.
    //=========================================================================

    HDEVINFO hdev = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    if (hdev != INVALID_HANDLE_VALUE) 
    {
        SP_DEVICE_INTERFACE_DATA did;
        did.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        //======================================================================
        // Enumerate the battery
        //======================================================================
		int nWhich = 0;
		while( fContinue )
		{
            if (SetupDiEnumDeviceInterfaces(hdev, 0, &GUID_DEVICE_BATTERY, nWhich++, &did)) 
            {
                DWORD cbRequired = 0;
                //==============================================================
                //
                //  Ask for the required size then allocate it then fill it.
                //
                //==============================================================
                if (SetupDiGetDeviceInterfaceDetail(hdev, &did, 0, 0, &cbRequired, 0) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
                {
                    
					PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LPTR, cbRequired);					
                    if (pdidd) 
                    {

                        pdidd->cbSize = sizeof(*pdidd);
                        if (SetupDiGetDeviceInterfaceDetail(hdev, &did, pdidd, cbRequired, &cbRequired, 0)) 
                        {
                            //===================================================
                            //  Finally enumerated a battery.  
                            //  Ask it for information.
                            //===================================================
                            HANDLE hBattery = CreateFile(pdidd->DevicePath,  GENERIC_READ | GENERIC_WRITE,
														 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                         NULL, OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL, NULL);
                            if (hBattery != INVALID_HANDLE_VALUE) 
                            {
                                //===================================================
                                //  Now you have to ask the battery for its tag.
                                //===================================================
                                BATTERY_QUERY_INFORMATION bqi;
								memset( &bqi, NULL, sizeof(BATTERY_QUERY_INFORMATION));
                                DWORD dwWait = 0;
                                DWORD dwOut = 0;
                                bqi.BatteryTag = 0;

                                if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_TAG, &dwWait, sizeof(DWORD),
                                                    &bqi.BatteryTag, sizeof(ULONG),&dwOut, NULL) && bqi.BatteryTag) 
                                {

                                    //================================================
                                    //  With the tag, you can query the battery info.
                                    //================================================
                                    BATTERY_INFORMATION bi;
									memset( &bi, NULL, sizeof(BATTERY_INFORMATION));
                                    bqi.InformationLevel = BatteryInformation;
                                    bqi.AtRate = 0;
                                    if (DeviceIoControl(hBattery, IOCTL_BATTERY_QUERY_INFORMATION, &bqi, sizeof(bqi),
                                                        &bi,  sizeof(bi), &dwOut, NULL)) 
                                    {
                                        //============================================
                                        // Only system batteries count
                                        //============================================
                                        if (bi.Capabilities & BATTERY_SYSTEM_BATTERY)  
										{
											//================================================
											//  Get the Name of the battery - this is the key
											//================================================
											CHString chsKey;
											hr = GetBatteryKey( hBattery, chsKey, bqi );
											if( WBEM_S_NO_ERROR == hr )
											{
												//============================================
												//  if we are working with a specific object 
												//  here, then get its info and bail out, if
												//  it is the one we want, otherwise continue
												//  to find it
												//============================================
												if( !chsObject.IsEmpty() )
												{
													if( chsObject.CompareNoCase(chsKey) == 0 )
													{
														fContinue = FALSE;
													}
													else
													{
														continue;
													}
													hr = GetBatteryProperties(pInstance, bi, bqi, hBattery);
													if( hr == WBEM_S_NO_ERROR )
													{
														hr = pInstance->Commit ();
														fResetHr = FALSE;
													}
													break;
												}
												else
												{
												    CInstancePtr pInstance;
													pInstance.Attach(CreateNewInstance(pMethodContext));

													//====================================
													//  We are working with enumeration
													//  Get a new instance and set the key
													//====================================
													pInstance->SetCHString( IDS_DeviceID,chsKey) ;
													hr = GetBatteryProperties(pInstance, bi, bqi, hBattery);
													if( hr == WBEM_S_NO_ERROR )
													{
														hr = pInstance->Commit ();
														fResetHr = TRUE;
													}
												}
											}
                                        }
                                    }
                                } 
                                CloseHandle(hBattery);
                            } 
						} 
						LocalFree(pdidd);
                    }
                }
            } 
			else 
			{
                // Enumeration failed - perhaps we're out of items
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
				{
					if( fResetHr )
					{
						hr = WBEM_S_NO_ERROR;
					}
				}
				fContinue = FALSE;
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }
    return hr;
}


#endif

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CBattery::GetBattery ( CInstance *pInstance )
{
	HRESULT hr;

	SYSTEM_POWER_STATUS Info ;

	BOOL bRetCode = GetSystemPowerStatus(&Info) ;
	if ( ( bRetCode ) && ( ( Info.BatteryFlag & 128 ) == 0 ) )
	{
		pInstance->SetCharSplat(IDS_Status,  Info.ACLineStatus == 0 ? IDS_STATUS_OK :Info.ACLineStatus == 1 ? IDS_STATUS_OK : IDS_STATUS_Unknown		);
		pInstance->SetWBEMINT16(IDS_Availability, 3);

		DWORD dwStatus;

		// The cim status values don't map exactly to the win32 api's.

		if ( Info.BatteryFlag == 255 )
		{
			dwStatus = 2;
		}
		else if ((Info.BatteryFlag & (0x8 | 0x1)) == (0x8 | 0x1))
		{
			dwStatus = 7;
		}
		else if ((Info.BatteryFlag & (0x8 | 0x2)) == (0x8 | 0x2))
		{
			dwStatus = 8;
		}
		else if ((Info.BatteryFlag & (0x8 | 0x4)) == (0x8 | 0x4))
		{
			dwStatus = 9;
		}
		else if (Info.BatteryFlag & 1)
		{
			dwStatus = 3;
		}
		else if (Info.BatteryFlag & 2)
		{
			dwStatus = 4;
		}
		else if (Info.BatteryFlag & 4)
		{
			dwStatus = 5;
		}
		else if (Info.BatteryFlag & 8)
		{
			dwStatus = 6;
		}
		else
		{
			dwStatus = 2;
		}

		pInstance->SetWBEMINT16 ( L"BatteryStatus", dwStatus ) ;
		if (Info.BatteryLifeTime != 0xFFFFFFFF)		//0xFFFFFFFF means that actual value is unknown
		{
			pInstance->SetDWORD ( L"EstimatedRunTime", (Info.BatteryLifeTime/60) ) ;	//EstimatedRunTime is in minutes but Info.BatteryLifeTime is in seconds, so converted into minutes
		}
		pInstance->SetWBEMINT16 ( L"EstimatedChargeRemaining" , Info.BatteryLifePercent ) ;

        CHString sTemp2;
        LoadStringW(sTemp2, IDR_BatteryName);

		pInstance->SetCHString ( IDS_Name ,sTemp2 ) ;
		pInstance->SetCharSplat ( IDS_DeviceID , IDS_BatteryName ) ;
		pInstance->SetCHString ( IDS_Caption , sTemp2 ) ;
		pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
		pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () );
		SetCreationClassName ( pInstance ) ;
		pInstance->SetCharSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

		hr = WBEM_S_NO_ERROR ;

	}
	else
	{
		hr = WBEM_E_NOT_FOUND ;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\autochksetting.cpp ===
/******************************************************************

   AutoChkSetting.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

******************************************************************/

#include "Precomp.h"
#include "AutoChkSetting.h"

// Provider classes 
#define PROVIDER_NAME_AUTOCHKSETTING	L"Win32_AutoChkSetting"

//Properties names
#define SettingID						L"SettingID"
#define UserInputDelay						L"UserInputDelay"

#define OSName							L"Name"

#define TIME_OUT_VALUE           L"AutoChkTimeOut"
#define SESSION_MANAGER_KEY      L"Session Manager"

CAutoChkSetting MyAutoDiskSettings ( 

	PROVIDER_NAME_AUTOCHKSETTING, 
	IDS_CimWin32Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CAutoChkSetting::CAutoChkSetting
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CAutoChkSetting :: CAutoChkSetting (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{	
}

/*****************************************************************************
 *
 *  FUNCTION    :   CAutoChkSetting::~CAutoChkSetting
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CAutoChkSetting :: ~CAutoChkSetting ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CAutoChkSetting :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
#ifdef NTONLY
	HRESULT hRes = WBEM_E_PROVIDER_FAILURE;
	CHString t_OSName;
	DWORD dwUserInputDelay;

    hRes = GetOSNameKey(t_OSName, pMethodContext);

    if (SUCCEEDED(hRes))
    {
	    if ( QueryTimeOutValue ( &dwUserInputDelay ) )
	    {
		    CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ), FALSE );
	    
		    if ( pInstance->SetCHString ( SettingID, t_OSName ) )
		    {
			    if ( pInstance->SetDWORD ( UserInputDelay, dwUserInputDelay ) )
			    {
				    hRes = pInstance->Commit ();
			    }	
		    }
	    }
    }

	return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CAutoChkSetting :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
#ifdef NTONLY
    HRESULT hRes = WBEM_S_NO_ERROR;
	CHString t_OSName;
	CHString t_Key;
	// Get the Key Value

	MethodContext *pMethodContext = pInstance->GetMethodContext();

 	if ( pInstance->GetCHString ( SettingID, t_Key ) )
	{
        hRes = GetOSNameKey(t_OSName, pMethodContext);

        if (SUCCEEDED(hRes))
        {
		    // Check if this Key Value exists  matches with the OS
		    if ( _wcsicmp ( t_Key, t_OSName ) == 0 )
		    {	
			    DWORD dwUserInputDelay;
			    if ( QueryTimeOutValue ( &dwUserInputDelay ) )
			    {
				    if ( pInstance->SetDWORD ( UserInputDelay, dwUserInputDelay ) == FALSE )
				    {
					    hRes = WBEM_E_FAILED;
				    }
			    }
			    else
			    {
				    hRes = WBEM_E_NOT_FOUND;
			    }
		    }
		    else
		    {
			    hRes = WBEM_E_NOT_FOUND;
		    }
        }
	}
	else
	{
		hRes = WBEM_E_FAILED;
	}

	return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}


/*****************************************************************************
*
*  FUNCTION    : CAutoChkSetting::PutInstance
*
*  DESCRIPTION : Sets the UserInput delay ( Modifies ) 
*
*****************************************************************************/

HRESULT CAutoChkSetting :: PutInstance  (

	const CInstance &Instance, 
	long lFlags
)
{
#ifdef NTONLY
    HRESULT hRes = WBEM_S_NO_ERROR ;
	// We cannot add a new instance, however we can change the UserInputDelay Property here.
	CHString t_OSName;
	CHString t_Key;
	// Get the Key Value
	MethodContext *pMethodContext = Instance.GetMethodContext();

 	if ( Instance.GetCHString ( SettingID, t_Key ) )
	{
		// This is a Single Instance	
        hRes = GetOSNameKey(t_OSName, pMethodContext);

        if (SUCCEEDED(hRes))
        {
		    // Check if this Key Value exists matches the OS 
		    if ( _wcsicmp ( t_Key, t_OSName ) == 0 )
		    {
			    switch ( lFlags & 3)
			    {
				    case WBEM_FLAG_CREATE_OR_UPDATE:
				    case WBEM_FLAG_UPDATE_ONLY:
				    {
					    // Verify the validity of parameters
					    bool t_Exists ;
					    VARTYPE t_Type ;
					    DWORD dwUserInputDelay;

					    if ( Instance.GetStatus ( UserInputDelay , t_Exists , t_Type ) && (t_Type != VT_NULL) )
					    {
						    if ( t_Exists && ( t_Type == VT_I4 ) )
						    {
							    if ( Instance.GetDWORD ( UserInputDelay , dwUserInputDelay ) )
							    {
								    // Set this user inputDelay
								    if ( ! SetTimeOutValue ( dwUserInputDelay ) )
								    {
									    hRes = WBEM_E_FAILED;
								    }
							    }
							    else
							    {
								    hRes = WBEM_E_PROVIDER_FAILURE;
							    }
						    }
						    else
						    {
							    hRes = WBEM_E_FAILED;
						    }
					    }
    				    break;
				    }
				    default:
				    {
					    hRes = WBEM_E_PROVIDER_NOT_CAPABLE ;
    				    break ;
				    }
			    }
		    }
		    else
            {
			    hRes = WBEM_E_NOT_FOUND;
            }
        }
	}
	
    return hRes ;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::QueryTimeOutValue
*
*  DESCRIPTION :    This function reads the AutoChkTimeOut value of the Session
*					Manager key.
*
*****************************************************************************/
#ifdef NTONLY
BOOLEAN CAutoChkSetting ::QueryTimeOutValue(

    OUT PULONG  a_ulTimeOut
)
{

   RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
   NTSTATUS                    t_Status;

    // Set up the query table:
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = TIME_OUT_VALUE;
    QueryTable[0].EntryContext = a_ulTimeOut;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    QueryTable[1].EntryContext = NULL;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    t_Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     SESSION_MANAGER_KEY,
                                     QueryTable,
                                     NULL,
                                     NULL );

    if (t_Status == 0xC0000034) // Key not found
    {
        *a_ulTimeOut = 10;
        t_Status = 0;
    }

    return( NT_SUCCESS( t_Status ) );

}

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::EnumerateInstances
*
*  DESCRIPTION :    This function sets the AutoChkTimeOut value of the Session
*					Manager key.
*
*****************************************************************************/

BOOLEAN CAutoChkSetting :: SetTimeOutValue (

    IN  ULONG  a_ulTimeOut
)
{
    NTSTATUS                    t_Status;

    t_Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                    SESSION_MANAGER_KEY,
                                    TIME_OUT_VALUE,
                                    REG_DWORD,
                                    &a_ulTimeOut,
                                    sizeof(a_ulTimeOut) );

    return( NT_SUCCESS( t_Status ) );


}
#endif

/*****************************************************************************
*
*  FUNCTION    :    CAutoChkSetting::GetOSNameKey
*
*  DESCRIPTION :    Getting an OSName using the Existing Win32_Operating System 
*					Class
*
*****************************************************************************/
HRESULT CAutoChkSetting::GetOSNameKey ( CHString &a_OSName, MethodContext *pMethodContext )
{
#ifdef NTONLY
	HRESULT hRes = WBEM_S_NO_ERROR;

	TRefPointerCollection<CInstance>	serviceList;

	hRes = CWbemProviderGlue::GetInstancesByQuery(L"Select Name From Win32_OperatingSystem", &serviceList, pMethodContext, GetNamespace());

	if ( SUCCEEDED ( hRes ) )
	{
		REFPTRCOLLECTION_POSITION	pos;
		CInstancePtr				pService;

		if ( serviceList.BeginEnum( pos ) )
		{
			pService.Attach(serviceList.GetNext( pos ));
			pService->GetCHString ( OSName, a_OSName );
			serviceList.EndEnum();
		}	
		// IF BeginEnum
	}	// IF GetAllDerived

    return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\1394.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  1394.h
//
//  Purpose: 1394 Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_1394CONTROLLER	L"Win32_1394Controller"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

class CWin32_1394Controller : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32_1394Controller ( const CHString &a_Name , LPCWSTR a_Namespace ) ;

       ~CWin32_1394Controller() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject ( CInstance *a_Instance , long lFlags , CFrameworkQuery &a_Query ) ;
		HRESULT ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags ) ;
        virtual HRESULT EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags = 0L ) ;

    private:

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

        HRESULT LoadPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

        BOOL Is1394Controller ( CConfigMgrDevice *a_Device ) ;

        DWORD GetBitMask ( CFrameworkQuery &a_Query );
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bios.h ===
//=================================================================

//

// BIOS.h -- BIOS property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   08/01/96    a-jmoon         Created
//              10/23/97	a-sanjes        Ported to new project
//
//=================================================================

// Property set identification
//============================

#define	PROPSET_NAME_BIOS	L"Win32_BIOS"

class CWin32BIOS : public Provider
{
public:

    // Constructor/destructor
    CWin32BIOS(LPCWSTR strName, LPCWSTR pszNamespace);
    ~CWin32BIOS();

    // Functions provide properties with current values
    virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
    virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, long lFlags = 0L);

    // Utility function(s)
    HRESULT LoadPropertyValues(CInstance *pInstance);
    void SetBiosDate(CInstance *pInstance, CHString &strDate);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bootconfig.cpp ===
//=================================================================

//

// BootConfig.CPP --BootConfig property set provider (Windows NT only)

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/24/95	 a-hhance		ported to new framework
//
//=================================================================

#include "precomp.h"
#include "BootConfig.h"
#include "resource.h"
#include "os.h"
#include "WMI_FilePrivateProfile.h"
// Property set declaration
//=========================

BootConfig MyBootConfigSet(PROPSET_NAME_BOOTCONFIG, IDS_CimWin32Namespace) ;

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::BootConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

BootConfig :: BootConfig (

	const CHString &name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::~BootConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

BootConfig::~BootConfig()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT BootConfig :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString name;
	pInstance->GetCHString(IDS_Name, name);

	if ( name.CompareNoCase ( IDS_BOOT_CONFIG_NAME ) == 0 )
	{
		hr =  LoadPropertyValues(pInstance) ;
	}

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT BootConfig :: EnumerateInstances (

	MethodContext *pMethodContext ,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

	CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
	hr = LoadPropertyValues ( pInstance ) ;
	if ( SUCCEEDED ( hr ) )
	{
		hr = pInstance->Commit (  ) ;
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : BootConfig::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT BootConfig::LoadPropertyValues (

	CInstance *pInstance
)
{
	pInstance->SetCHString ( IDS_Name , IDS_BOOT_CONFIG_NAME ) ;

	TCHAR szBootDir[_MAX_PATH +1] ;
	lstrcpy ( szBootDir , _T("Unknown") ) ;

#ifdef NTONLY

	WCHAR szTemp[_MAX_PATH + 1] = L"";

	if ( GetWindowsDirectory ( szTemp , (sizeof ( szTemp ) / sizeof(TCHAR)) - 1 ) )
	{
		wcscat ( szTemp , IDS_RegSetupLog ) ;

		WMI_FILE_GetPrivateProfileStringW (

			IDS_Paths ,
			IDS_TargetDirectory ,
			IDS_Unknown ,
			szBootDir ,
			(sizeof ( szBootDir )/sizeof(WCHAR)) - 1,
			szTemp
		) ;

		WCHAR t_szSystemPartition[_MAX_PATH +1] ;
	    if ( WMI_FILE_GetPrivateProfileStringW (

			IDS_Paths ,
			L"SystemPartition",
			L"",
			t_szSystemPartition,
			sizeof(t_szSystemPartition)/sizeof(WCHAR)-1,
			szTemp
		) != 0 )
		{
			pInstance->SetCharSplat ( L"Description" , ( PWCHAR ) _bstr_t ( t_szSystemPartition ) ) ;
			pInstance->SetCharSplat ( L"Caption" , ( PWCHAR ) _bstr_t ( t_szSystemPartition ) ) ;
		}
	}
#endif

#ifdef WIN9XONLY

	if ( GetEnvironmentVariable( _T("WinBootDir") , szBootDir , sizeof ( szBootDir ) / sizeof(TCHAR) ) )
	{
		TCHAR t_chTemp = szBootDir[0] ;
		CHString t_chsSystemPartition ;
		if( CWin32OS::GetWin95BootDevice((char)toupper ( t_chTemp ) , t_chsSystemPartition ) )
		{
			pInstance->SetCHString(L"Description", t_chsSystemPartition );
			pInstance->SetCHString(L"Caption", t_chsSystemPartition );
		}
	}
#endif

	pInstance->SetCharSplat ( IDS_BootDirectory , szBootDir ) ;

	// Configuration Path
	pInstance->SetCharSplat ( IDS_ConfigurationPath , szBootDir ) ;

#ifdef WIN9XONLY

	TCHAR szTempDir[_MAX_PATH +1] = _T("");

	if ( GetTempPath ( sizeof(szTempDir) / sizeof(TCHAR) , szTempDir ) != 0 )
	{
		pInstance->SetCharSplat ( IDS_ScratchDirectory, szTempDir ) ;
		pInstance->SetCharSplat ( IDS_TempDirectory , szTempDir ) ;
	}

#endif

/*
 *  Walk all the logical drives
 */
	TCHAR t_strDrive[3] ;
	DWORD t_dwDrives = GetLogicalDrives () ;
	for ( int t_x = 26; ( t_x >= 0 ); t_x-- )
    {
        // If the bit is set, the drive letter is active
        if ( t_dwDrives & ( 1<<t_x ) )
        {
			t_strDrive[0] = t_x + _T('A') ;
            t_strDrive[1] = _T(':') ;
            t_strDrive[2] = _T('\0') ;

			DWORD t_dwDriveType = GetDriveType ( t_strDrive ) ;
/*
 * Check if it's a valid drive
 */
			if ( t_dwDriveType == DRIVE_REMOTE	||
				 t_dwDriveType == DRIVE_FIXED		||
				 t_dwDriveType == DRIVE_REMOVABLE ||
				 t_dwDriveType == DRIVE_CDROM		||
				 t_dwDriveType == DRIVE_RAMDISK
				)
			{
				pInstance->SetCharSplat ( IDS_LastDrive , t_strDrive ) ;
				break ;
			}
		}
	}


#ifdef NTONLY



	CRegistry RegInfo;

	DWORD dwRet = RegInfo.OpenCurrentUser(

		IDS_Environment,
		KEY_READ
	) ;

	if ( dwRet == ERROR_SUCCESS )
	{
		try
		{
			CHString tempDir;

			dwRet = RegInfo.GetCurrentKeyValue (

				IDS_Temp,
				tempDir
			) ;

			if ( dwRet == ERROR_SUCCESS )
			{
				TCHAR szTempDir[_MAX_PATH +1] = _T("");

				if ( ExpandEnvironmentStrings ( (LPCTSTR) tempDir , szTempDir, _MAX_PATH ) )
				{
					pInstance->SetCharSplat ( IDS_ScratchDirectory , szTempDir ) ;
					pInstance->SetCharSplat ( IDS_TempDirectory , szTempDir ) ;
				}
			}

		}
		catch ( ... )
		{
			RegInfo.Close () ;

			throw ;
		}
		RegInfo.Close();
	}


#endif

	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bus.h ===
//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

//                            

//                         All Rights Reserved

//

// This software is furnished under a license and may be used and copied

// only in accordance with the terms of such license and with the inclusion

// of the above copyright notice.  This software or any other copies thereof

// may not be provided or otherwise  made available to any other person.  No

// title to and ownership of the software is hereby transferred.





//=================================================================

//

// bus.h -- Bus property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/98    a-kevhu         Created
//
//=================================================================
#ifndef _BUS_H_
#define _BUS_H_

class CWin32Bus;
class CBusList;


class CBusInfo
{
public:
    CHString chstrBusDeviceID,
             chstrBusPNPDeviceID;
};

class CBusList
{
public:

    CBusList()
    {
        GenerateBusList();
    }
        
    ~CBusList()
    {
    }

    BOOL FoundPCMCIABus();
    BOOL AlreadyAddedToList(LPCWSTR szItem);
    LONG GetListSize() { return m_vecpchstrList.size(); }

    BOOL GetListMemberDeviceID(LONG lPos, CHString& chstrMember)
    {
        if (lPos >= 0L && lPos < m_vecpchstrList.size())
        {
            chstrMember = m_vecpchstrList[lPos].chstrBusDeviceID;
            return TRUE;
        }

        return FALSE;
    }

    BOOL GetListMemberPNPDeviceID(LONG lPos, CHString& chstrMember)
    {
        if (lPos >= 0L && lPos < m_vecpchstrList.size() &&
            !m_vecpchstrList[lPos].chstrBusPNPDeviceID.IsEmpty())
        {
            chstrMember = m_vecpchstrList[lPos].chstrBusPNPDeviceID;
            
            return TRUE;
        }

        return FALSE;
    }

    LONG GetIndexInListFromDeviceID(LPCWSTR szDeviceID)
    {
        LONG lRet = -1L;
        
        for (LONG m = 0L; m < m_vecpchstrList.size(); m++)
        {
            if (m_vecpchstrList[m].chstrBusDeviceID.CompareNoCase(szDeviceID) == 0L)
            {
               lRet = m;
               break;
            }
        }

        return lRet;
    }

protected:

    void GenerateBusList(); 
    void AddBusToList(LPCWSTR szDeviceID, LPCWSTR szPNPID);

    std::vector<CBusInfo> m_vecpchstrList;
};



class CWin32Bus : public Provider 
{
public:
    // Constructor/destructor
    CWin32Bus(LPCWSTR name, LPCWSTR pszNamespace);
    ~CWin32Bus() ;

    // Functions provide properties with current values
    virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
    virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0);

private:
    // Utility function(s)
    HRESULT SetCommonInstance(CInstance* pInstance, BOOL fEnum);
    BOOL GetBusTypeNumFromStr(LPCWSTR szType, DWORD* pdwTypeNum);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bservice.cpp ===
//=================================================================
//
// Service.CPP --Service property set provider (Windows NT only)
//
//  Copyright (c) 1996-2002 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

#include "precomp.h"

#include "bservice.h"
#include "computersystem.h"

#define IMP_DOMAIN NULL
#define IMP_USER NULL
#define IMP_PASSWORD NULL

Win32_BaseService BaseService (PROPSET_NAME_BASESERVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Win32_BaseService::Win32_BaseService
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Win32_BaseService::Win32_BaseService (

	const CHString &name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Win32_BaseService::~Win32_BaseService
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework, deletes cache if
 *                present
 *
 *****************************************************************************/

Win32_BaseService::~Win32_BaseService()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process ::DeleteInstance
 *
 *  DESCRIPTION : Deletes an instance of a class
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_BaseService:: DeleteInstance (

	const CInstance &a_Instance,
	long a_Flags /*= 0L*/
)
{
#ifdef WIN9XONLY
	return WBEM_E_NOT_SUPPORTED;
#endif

#ifdef NTONLY
	HRESULT t_Result = S_OK ;

	CHString t_Name ;
	if ( a_Instance.GetCHString ( IDS_Name, t_Name ) && ! t_Name.IsEmpty () )
	{
		SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
		if ( t_ServiceControlManager )
		{
			SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , DELETE ) ;
			if ( t_Service )
			{
				BOOL t_ReturnCode = DeleteService ( t_Service ) ;

				if ( !t_ReturnCode )
				{
					t_Result = GetServiceResultCode () ;
				}
			}
			else
			{
				t_Result = GetServiceResultCode() ;
			}
		}
		else
		{
			t_Result = GetServiceResultCode () ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Win32_BaseService::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long a_Flags /*= 0L*/
)
{
#ifdef WIN9XONLY
    return WBEM_E_NOT_SUPPORTED;
#endif

#ifdef NTONLY
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

   // Do we recognize the method?

	if ( _wcsicmp ( a_MethodName , METHOD_NAME_START ) == 0 )
	{
		return ExecStart ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_STOP ) == 0 )
	{
		return ExecStop ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_PAUSE ) == 0 )
	{
		return ExecPause ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_RESUME ) == 0 )
	{
		return ExecResume ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_INTERROGATE ) == 0 )
	{
		return ExecInterrogate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_USERCONTROLSERVICE ) == 0)
	{
		return ExecUserControlService ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0)
	{
		return ExecCreate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_CHANGE ) == 0)
	{
		return ExecChange ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_CHANGESTARTMODE ) == 0)
	{
		return ExecChangeStartMode ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_DELETE ) == 0)
	{
		return ExecDelete ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else
	{
		return WBEM_E_INVALID_METHOD;
	}
#endif
}


#ifdef NTONLY
HRESULT Win32_BaseService :: GetServiceStatus (

	const CInstance& a_Instance,
	CHString &a_Name ,
	DWORD &a_State ,
	bool &a_AcceptPause ,
	bool &a_AcceptStop
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Path ;
	CHString t_Prop ( L"__RELPATH" ) ;

	if ( a_Instance.GetCHString ( t_Prop ,  t_Path ) )
	{
		CHString strNamespace ( IDS_CimWin32Namespace ) ;

		DWORD t_BuffSize = MAX_COMPUTERNAME_LENGTH + 1 ;
		TCHAR t_ComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] ;

		GetComputerName ( t_ComputerName , &t_BuffSize ) ;

		CHString ComputerName ( t_ComputerName ) ;
		CHString t_AbsPath = L"\\\\" + ComputerName + L"\\" + strNamespace + L":" + t_Path ;

		CInstancePtr t_ObjectInstance;
		if ( SUCCEEDED ( CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath, &t_ObjectInstance, a_Instance.GetMethodContext() ) ) )
		{
			CHString t_State ;
			t_ObjectInstance->GetCHString ( IDS_Name, a_Name ) ;
			t_ObjectInstance->GetCHString ( PROPERTY_NAME_STATE , t_State ) ;
			t_ObjectInstance->Getbool ( PROPERTY_NAME_ACCEPTPAUSE , a_AcceptPause ) ;
			t_ObjectInstance->Getbool ( PROPERTY_NAME_ACCEPTSTOP , a_AcceptStop ) ;
            t_ObjectInstance.Release();

			if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_STOPPED) == 0 )
			{
				a_State = SERVICE_STOPPED ;
            }
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_STARTPENDING) == 0 )
			{
				a_State = SERVICE_START_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_STOPPENDING) == 0 )
			{
				a_State = SERVICE_STOP_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_RUNNING) == 0 )
			{
				a_State = SERVICE_RUNNING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_CONTINUEPENDING) == 0 )
			{
				a_State = SERVICE_CONTINUE_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_PAUSEPENDING) == 0 )
			{
		        a_State = SERVICE_PAUSE_PENDING ;
			}
			else if ( t_State.CompareNoCase (PROPERTY_VALUE_STATE_PAUSED) == 0 )
			{
				a_State = SERVICE_PAUSED ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: GetServiceResultCode ()
{
	HRESULT t_Result ;
	DWORD t_Error = GetLastError() ;
	switch ( t_Error )
	{
		case ERROR_INVALID_NAME:
		case ERROR_SERVICE_DOES_NOT_EXIST:
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
		break;

		case ERROR_ACCESS_DENIED:
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			t_Result = WBEM_S_PENDING ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
DWORD Win32_BaseService :: GetServiceErrorCode ()
{
	DWORD t_Status ;
	DWORD t_Error = GetLastError() ;
	switch ( t_Error )
	{
		case ERROR_INVALID_HANDLE:
		{
			t_Status = STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case ERROR_PATH_NOT_FOUND:
		{
			t_Status = STATUS_PATH_NOT_FOUND ;
		}
		break ;

		case ERROR_SERVICE_ALREADY_RUNNING:
		{
			t_Status = STATUS_SERVICE_ALREADY_RUNNING ;
		}
		break ;

		case ERROR_SERVICE_DATABASE_LOCKED:
		{
			t_Status = STATUS_SERVICE_DATABASE_LOCKED ;
		}
		break ;

		case ERROR_SERVICE_DEPENDENCY_DELETED:
		{
			t_Status = STATUS_SERVICE_DEPENDENCY_DELETED ;
		}
		break ;

		case ERROR_SERVICE_DEPENDENCY_FAIL:
		{
			t_Status = STATUS_SERVICE_DEPENDENCY_FAIL ;
		}
		break ;

		case ERROR_SERVICE_DISABLED:
		{
			t_Status = STATUS_SERVICE_DISABLED ;
		}
		break ;

		case ERROR_SERVICE_LOGON_FAILED:
		{
			t_Status = STATUS_SERVICE_LOGON_FAILED ;
		}
		break ;

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			t_Status = STATUS_SERVICE_MARKED_FOR_DELETE ;
		}
		break ;

		case ERROR_SERVICE_NO_THREAD:
		{
			t_Status = STATUS_SERVICE_NO_THREAD ;
		}
		break ;

		case ERROR_SERVICE_REQUEST_TIMEOUT:
		{
			t_Status = STATUS_SERVICE_REQUEST_TIMEOUT ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			t_Status = STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_DEPENDENT_SERVICES_RUNNING:
		{
			t_Status = STATUS_DEPENDENT_SERVICES_RUNNING ;
		}
		break ;

		case ERROR_INVALID_SERVICE_CONTROL:
		{
			t_Status = STATUS_INVALID_SERVICE_CONTROL ;
		}
		break ;

		case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
		{
			t_Status = STATUS_SERVICE_CANNOT_ACCEPT_CTRL ;
		}
		break ;

		case ERROR_SERVICE_NOT_ACTIVE:
		{
			t_Status = STATUS_SERVICE_NOT_ACTIVE ;
		}
		break ;

		case ERROR_CIRCULAR_DEPENDENCY:
		{
			t_Status = STATUS_CIRCULAR_DEPENDENCY ;
		}
		break ;

		case ERROR_DUP_NAME:
		{
			t_Status = STATUS_DUP_NAME ;
		}
		break ;

		case ERROR_INVALID_NAME:
		{
			t_Status = STATUS_INVALID_NAME ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Status = STATUS_INVALID_PARAMETER ;
		}
		break;

		case ERROR_INVALID_SERVICE_ACCOUNT:
		{
			t_Status = STATUS_INVALID_SERVICE_ACCOUNT ;
		}
		break ;

		case ERROR_SERVICE_EXISTS:
		{
			t_Status = STATUS_SERVICE_EXISTS ;
		}
		break ;

		default:
		{
			t_Status = STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return t_Status ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecStart (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case SERVICE_STOPPED:
			{
				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_START ) ;
					if ( t_Service )
					{
						DWORD t_ReturnCode = StartService ( t_Service , 0 , NULL ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE, STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;

			default:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_ALREADY_RUNNING ) ;
			}
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecStop (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_AcceptStop )
		{
			switch ( t_State )
			{
				case 0xFFFFFFFF:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
				}
				break ;

				case SERVICE_STOP_PENDING:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
				}
				break ;

				case SERVICE_STOPPED:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
				}
				break ;

				default:
				{
					SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
					if ( t_ServiceControlManager )
					{
						SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_STOP ) ;
						if ( t_Service )
						{
							SERVICE_STATUS t_ServiceStatus ;
							DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_STOP , & t_ServiceStatus ) ;
							if ( t_ReturnCode )
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
							}
							else
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}

					}
					else
					{
						t_Result = GetServiceErrorCode () ;
					}
				}
				break ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_CANNOT_ACCEPT_CTRL ) ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecPause (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_AcceptPause )
		{
			switch ( t_State )
			{
				case 0xFFFFFFFF:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
				}
				break ;

				case SERVICE_START_PENDING:
				case SERVICE_STOP_PENDING:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
				}
				break ;

				case SERVICE_PAUSED:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_ALREADY_PAUSED ) ;
				}
				break ;

				case SERVICE_STOPPED:
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
				}
				break ;

				default:
				{
					SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
					if ( t_ServiceControlManager )
					{
						SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_PAUSE_CONTINUE ) ;
						if ( t_Service )
						{
							SERVICE_STATUS t_ServiceStatus ;
							DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_PAUSE , & t_ServiceStatus ) ;
							if ( t_ReturnCode )
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
							}
							else
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						t_Result = GetServiceErrorCode () ;
					}
				}
				break ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_CANNOT_ACCEPT_CTRL ) ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecResume (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString  t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case 0xFFFFFFFF:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
			}
			break ;

			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
			}
			break ;

			case SERVICE_STOPPED:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
			}
			break ;

			case SERVICE_RUNNING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_ALREADY_RUNNING ) ;
			}
			break ;

			default:
			{
				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_PAUSE_CONTINUE ) ;
					if ( t_Service )
					{
						SERVICE_STATUS t_ServiceStatus ;
						DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_CONTINUE , & t_ServiceStatus ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecInterrogate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString  t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case 0xFFFFFFFF:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
			}
			break ;

			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
			}
			break ;

			case SERVICE_STOPPED:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
			}
			break ;

			default:
			{
				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_INTERROGATE ) ;
					if ( t_Service )
					{
						SERVICE_STATUS t_ServiceStatus ;
						DWORD t_ReturnCode = ControlService ( t_Service , SERVICE_CONTROL_INTERROGATE , & t_ServiceStatus ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecUserControlService (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	DWORD t_State ;
	CHString t_Name ;
	bool t_AcceptPause ;
	bool t_AcceptStop ;

	t_Result = GetServiceStatus (

		a_Instance ,
		t_Name ,
		t_State ,
		t_AcceptPause ,
		t_AcceptStop
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		switch ( t_State )
		{
			case 0xFFFFFFFF:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_UNKNOWN_FAILURE ) ;
			}
			break ;

			case SERVICE_START_PENDING:
			case SERVICE_STOP_PENDING:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_SERVICE_CONTROL ) ;
			}
			break ;

			case SERVICE_STOPPED:
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SERVICE_NOT_ACTIVE ) ;
			}
			break ;

			default:
			{
				bool t_Exists ;
				VARTYPE t_Type ;

				UCHAR t_Control = 0 ;

				if ( a_InParams )
				{
					if ( a_InParams->GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
					{
						if ( t_Exists && ( t_Type == VT_UI1 ) )
						{
							if ( ! a_InParams->GetByte ( METHOD_ARG_NAME_CONTROLCODE , t_Control ) )
							{
								return WBEM_E_INVALID_PARAMETER ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER  ) ;

							return S_OK ;
						}
					}
					else
					{
						return WBEM_E_INVALID_PARAMETER ;
					}
				}
				else
				{
					return WBEM_E_INVALID_PARAMETER ;
				}

				SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
				if ( t_ServiceControlManager )
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , SERVICE_USER_DEFINED_CONTROL ) ;
					if ( t_Service )
					{
						SERVICE_STATUS t_ServiceStatus ;
						DWORD t_ReturnCode = ControlService ( t_Service , t_Control , & t_ServiceStatus ) ;
						if ( t_ReturnCode )
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
                    }
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				else
				{
					t_Result = GetServiceErrorCode () ;
				}
			}
			break ;
		}
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecDelete (

	const CInstance& a_Instance ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;
	if ( a_Instance.GetCHString ( IDS_Name, t_Name ) && ! t_Name.IsEmpty () )
	{
		SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
		if ( t_ServiceControlManager )
		{
			SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_Name , DELETE ) ;
			if ( t_Service )
			{
				BOOL t_ReturnCode = DeleteService ( t_Service ) ;
				if ( t_ReturnCode )
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
				}
				else
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
				}
			}
			else
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
			}
		}
		else
		{
			t_Result = GetServiceErrorCode () ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
DWORD Win32_BaseService :: CheckParameters (

	const CInstance& a_Instance ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status ,
	BOOL a_Create
)
{
	HRESULT t_Result = S_OK ;

	a_Status = STATUS_SUCCESS ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_ServiceName ;

	if ( a_Create )
	{
		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_NAME , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
			{
				if ( t_Type == VT_BSTR )
				{
					if ( a_InParams->GetCHString ( METHOD_ARG_NAME_NAME , t_ServiceName ) && ! t_ServiceName.IsEmpty () )
					{
					}
					else
					{
// Zero Length string

						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else //  t_Type == VT_NULL
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		DWORD t_State ;
		bool t_AcceptPause ;
		bool t_AcceptStop ;

		t_Result = GetServiceStatus (

			a_Instance ,
			t_ServiceName ,
			t_State ,
			t_AcceptPause ,
			t_AcceptStop
		) ;

		if ( FAILED ( t_Result ) )
		{
			a_Status = STATUS_UNKNOWN_FAILURE ;
			return t_Result ;
		}
	}

	bool t_DisplayNameSpecified = false ;
	CHString t_DisplayName ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_DISPLAYNAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
				else
				{
					t_DisplayNameSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_DISPLAYNAME , t_DisplayName ) && ! t_DisplayName.IsEmpty () )
				{
					t_DisplayNameSpecified = true ;
				}
				else
				{
// Zero Length string

					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_PathNameSpecified = false ;
	CHString t_PathName ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PATHNAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_PATHNAME , t_PathName ) && ! t_PathName.IsEmpty () )
				{
					t_PathNameSpecified = true ;
				}
				else
				{
// Zero Length string

					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_ServiceTypeSpecified = true ;

	DWORD t_ServiceType = SERVICE_WIN32_OWN_PROCESS ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_SERVICETYPE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UI1 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_ServiceTypeSpecified = false ;
				}
			}
			else
			{
				BYTE t_TempSerType ;
				if ( a_InParams->GetByte ( METHOD_ARG_NAME_SERVICETYPE, t_TempSerType ) )
				{
					switch ( t_TempSerType )
					{
						case PROPERTY_VALUE_SERVICE_TYPE_KERNAL_DRIVER:
						{
							t_ServiceType = SERVICE_KERNEL_DRIVER ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_FILE_SYSTEM_DRIVER:
						{
							t_ServiceType = SERVICE_FILE_SYSTEM_DRIVER ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_RECOGNIZER_DRIVER:
						{
							t_ServiceType = SERVICE_RECOGNIZER_DRIVER ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_ADAPTER:
						{
							t_ServiceType = SERVICE_ADAPTER;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_OWN_PROCESS:
						{
							t_ServiceType = SERVICE_WIN32_OWN_PROCESS ;
						}
						break ;

						case PROPERTY_VALUE_SERVICE_TYPE_SHARE_PROCESS:
						{
							t_ServiceType = SERVICE_WIN32_SHARE_PROCESS ;
						}
						break ;

						default:
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
						break ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_ServiceErrorControlSpecified = true ;
	UCHAR t_ErrorControl ;
	DWORD t_ServiceErrorControl = SERVICE_ERROR_IGNORE ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_ERRORCONTROL , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UI1 || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_ServiceErrorControlSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetByte ( METHOD_ARG_NAME_ERRORCONTROL , t_ErrorControl ) )
				{
					switch ( t_ErrorControl )
					{
						case PROPERTY_VALUE_ERROR_CONTROL_IGNORE:
						{
							t_ServiceErrorControl = SERVICE_ERROR_IGNORE ;
						}
						break ;

						case PROPERTY_VALUE_ERROR_CONTROL_NORMAL:
						{
							t_ServiceErrorControl = SERVICE_ERROR_NORMAL ;
						}
						break ;

						case PROPERTY_VALUE_ERROR_CONTROL_SEVERE:
						{
							t_ServiceErrorControl = SERVICE_ERROR_SEVERE ;
						}
						break ;

						case PROPERTY_VALUE_ERROR_CONTROL_CRITICAL:
						{
							t_ServiceErrorControl = SERVICE_ERROR_CRITICAL;
						}
						break ;

						default:
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
						break ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_ServiceStartModeSpecified = true ;
	CHString t_StartMode ;
	DWORD t_ServiceStartMode = SERVICE_AUTO_START ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTMODE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_ServiceStartModeSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTMODE , t_StartMode ) )
				{
					if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_BOOT ) == 0 )
					{
						t_ServiceStartMode = SERVICE_BOOT_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_SYSTEM ) == 0 )
					{
						t_ServiceStartMode = SERVICE_SYSTEM_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_AUTOMATIC ) == 0 )
					{
						t_ServiceStartMode = SERVICE_AUTO_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_MANUAL ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DEMAND_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_DISABLE ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DISABLED ;
					}
					else
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_StartNameSpecified = false ;
	CHString t_StartName ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTNAME , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				if ( a_Create )
				{
				}
				else
				{
					t_StartNameSpecified = false ;
				}
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTNAME , t_StartName ) && ! t_StartName.IsEmpty () )
				{
					t_StartNameSpecified = true ;
				}
				else
				{
					if ( a_Create )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else
					{
						t_StartNameSpecified = true ;
					}
				}
			}

			if ( t_StartNameSpecified )
			{
				switch ( t_ServiceType )
				{
					case SERVICE_WIN32_SHARE_PROCESS:
					{
						if ( t_StartName.CompareNoCase ( PROPERTY_VALUE_STARTNAME_LOCAL_SYSTEM ) != 0 )
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_StartPasswordSpecified = false ;
	CHString t_StartPassword ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTPASSWORD , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTPASSWORD , t_StartPassword ) )
				{
					t_StartPasswordSpecified = true ;
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_DesktopInteract = false ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_DESKTOPINTERACT , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BOOL || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( ! t_ServiceTypeSpecified )
				{
					if ( a_Create )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else
					{
						t_ServiceTypeSpecified = true ;

						SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , SC_MANAGER_CREATE_SERVICE | SC_MANAGER_LOCK ) ;
						if ( t_ServiceControlManager )
						{
							SC_LOCK t_Lock = LockServiceDatabase ( t_ServiceControlManager ) ;
							if ( t_Lock )
							{
								try
								{
									SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_ServiceName , SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ) ;
									if ( t_Service )
									{
										DWORD t_SizeNeeded = 0 ;
										QUERY_SERVICE_CONFIG *t_ServiceConfig = NULL ;
										BOOL t_Status = QueryServiceConfig ( t_Service , NULL , 0 ,  & t_SizeNeeded ) ;
										if ( ! t_Status )
										{
											if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
											{
												t_ServiceConfig = ( QUERY_SERVICE_CONFIG * ) new char [ t_SizeNeeded ] ;
												if ( t_ServiceConfig )
												{
													try
													{
														t_Status = QueryServiceConfig ( t_Service , t_ServiceConfig , t_SizeNeeded ,  & t_SizeNeeded ) ;
														if ( t_Status )
														{
														}
													}
													catch ( ... )
													{
														delete [] t_ServiceConfig ;

														throw ;
													}
												}
												else
												{
													throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
												}
											}
										}

										if ( t_Status )
										{
											t_ServiceType = t_ServiceConfig->dwServiceType ;
										}
										else
										{
											a_Status = GetServiceErrorCode () ;
										}

										delete [] ( UCHAR * ) t_ServiceConfig ;

									}
									else
									{
										a_Status = GetServiceErrorCode () ;
									}

								}
								catch ( ... )
								{
									UnlockServiceDatabase ( t_Lock ) ;

									throw ;
								}

								UnlockServiceDatabase ( t_Lock ) ;
							}
							else
							{
								a_Status = GetServiceErrorCode () ;
							}

							if ( a_Status != STATUS_SUCCESS )
							{
								return t_Result ;
							}
						}
						else
						{
							if ( a_OutParams )
								a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
						}
					}
				}

				if ( a_InParams->Getbool ( METHOD_ARG_NAME_DESKTOPINTERACT , t_DesktopInteract ) )
				{
					DWORD t_PlainServiceType = t_ServiceType & ( ~ SERVICE_INTERACTIVE_PROCESS );
					switch ( t_PlainServiceType )
					{
						case SERVICE_WIN32_OWN_PROCESS:
						case SERVICE_WIN32_SHARE_PROCESS:
						{
							if ( t_DesktopInteract )
							{
								t_ServiceType = t_ServiceType | SERVICE_INTERACTIVE_PROCESS ;
							}
							else
							{
								t_ServiceType = t_PlainServiceType ;
							}
						}
						break ;

						default:
						{
							a_Status = STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
						break ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_LoadOrderGroupSpecified = false ;
	CHString t_LoadOrderGroup ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_LOADORDERGROUP , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_LOADORDERGROUP , t_LoadOrderGroup ) && ! t_LoadOrderGroup.IsEmpty () )
				{
					t_LoadOrderGroupSpecified = true ;
				}
				else
				{
					if ( a_Create )
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
					else
					{
						t_LoadOrderGroupSpecified = true ;
					}
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	LONG t_LoadOrderBufferLength = 0 ;
	SAFEARRAY *t_LoadOrderGroupDependancies = NULL ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_LOADORDERGROUPDEPENDENCIES , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == ( VT_BSTR | VT_ARRAY ) || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetStringArray ( METHOD_ARG_NAME_LOADORDERGROUPDEPENDENCIES , t_LoadOrderGroupDependancies ) )
				{
					if ( t_LoadOrderGroupDependancies )
					{
						try
						{
							if ( SafeArrayGetDim ( t_LoadOrderGroupDependancies ) == 1 )
							{
								LONG t_Dimension = 1 ;
								LONG t_LowerBound ;
								SafeArrayGetLBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_LowerBound ) ;
								LONG t_UpperBound ;
								SafeArrayGetUBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_UpperBound ) ;

								t_LoadOrderBufferLength = 0 ;

								for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
								{
									BSTR t_Element ;
									HRESULT t_Status = SafeArrayGetElement ( t_LoadOrderGroupDependancies , &t_Index , & t_Element ) ;
									if ( t_Status == S_OK )
									{
										try {

											CHString t_String ( t_Element ) ;

											t_LoadOrderBufferLength += _tcslen ( t_String ) + 2 ;

										}
										catch ( ... )
										{
											SysFreeString ( t_Element ) ;

											throw ;
										}

										SysFreeString ( t_Element ) ;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}
							else
							{
								a_Status = STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						catch ( ... )
						{
							SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;

							throw ;
						}
					}
					else
					{
						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else
				{
					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}


	LONG t_ServiceBufferLength = 0 ;
	SAFEARRAY *t_ServiceDependancies = NULL ;

	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_SERVICEDEPENDENCIES , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == ( VT_BSTR | VT_ARRAY ) || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
			}
			else
			{
				if ( a_InParams->GetStringArray ( METHOD_ARG_NAME_SERVICEDEPENDENCIES , t_ServiceDependancies ) )
				{
					if ( t_ServiceDependancies )
					{
						try
						{
							if ( SafeArrayGetDim ( t_ServiceDependancies ) == 1 )
							{
								LONG t_Dimension = 1 ;
								LONG t_LowerBound ;
								SafeArrayGetLBound ( t_ServiceDependancies , t_Dimension , & t_LowerBound ) ;
								LONG t_UpperBound ;
								SafeArrayGetUBound ( t_ServiceDependancies , t_Dimension , & t_UpperBound ) ;

								t_ServiceBufferLength = 0 ;

								for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
								{
									BSTR t_Element ;
									HRESULT t_Status = SafeArrayGetElement ( t_ServiceDependancies , &t_Index , & t_Element ) ;
									if ( t_Status == S_OK )
									{
										try
										{
											CHString t_String ( t_Element ) ;
											t_ServiceBufferLength += _tcslen ( t_String ) + 1 ;

										}
										catch ( ... )
										{
											SysFreeString ( t_Element ) ;

											throw ;
										}
										SysFreeString ( t_Element ) ;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}
							else
							{
								SafeArrayDestroy ( t_ServiceDependancies ) ;
								if ( t_LoadOrderGroupDependancies )
								{
									SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
								}

								a_Status = STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						catch ( ... )
						{
							SafeArrayDestroy ( t_ServiceDependancies ) ;

							if ( t_LoadOrderGroupDependancies )
							{
								SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
							}

							throw ;
						}
					}
					else
					{
						if ( t_LoadOrderGroupDependancies )
						{
							SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
						}

						a_Status = STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
				else
				{
					if ( t_LoadOrderGroupDependancies )
					{
						SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
					}

					a_Status = STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			if ( t_LoadOrderGroupDependancies )
			{
				SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
			}

			a_Status = STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		if ( t_LoadOrderGroupDependancies )
		{
			SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;
		}

		a_Status = STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	TCHAR *t_DependancyList = NULL ;

	try
	{
		LONG t_TotalLength = t_LoadOrderBufferLength + t_ServiceBufferLength ;
		if ( t_TotalLength )
		{
			t_DependancyList = new TCHAR [ t_TotalLength + 1 ] ;
			if ( t_DependancyList )
			{
				try
				{
					LONG t_BufferLength = 0 ;
					if ( t_LoadOrderBufferLength )
					{
						LONG t_Dimension = 1 ;
						LONG t_LowerBound ;
						SafeArrayGetLBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_LowerBound ) ;
						LONG t_UpperBound ;
						SafeArrayGetUBound ( t_LoadOrderGroupDependancies , t_Dimension , & t_UpperBound ) ;

						for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
						{
							BSTR t_Element ;
							HRESULT t_Status = SafeArrayGetElement ( t_LoadOrderGroupDependancies , &t_Index , & t_Element ) ;
							if ( t_Status == S_OK )
							{
								try
								{
									t_DependancyList [ t_BufferLength ] = SC_GROUP_IDENTIFIER ;

									CHString t_String ( t_Element ) ;
									_tcscpy ( & t_DependancyList [ t_BufferLength + 1 ] , t_String ) ;

									t_BufferLength += _tcslen ( t_String ) + 2 ;
								}
								catch ( ... )
								{
									SysFreeString ( t_Element ) ;

									throw ;
								}

								SysFreeString ( t_Element ) ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
					}

					if ( t_ServiceBufferLength )
					{
						LONG t_Dimension = 1 ;
						LONG t_LowerBound ;
						SafeArrayGetLBound ( t_ServiceDependancies , t_Dimension , & t_LowerBound ) ;
						LONG t_UpperBound ;
						SafeArrayGetUBound ( t_ServiceDependancies , t_Dimension , & t_UpperBound ) ;

						for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
						{
							BSTR t_Element ;

							HRESULT t_Status = SafeArrayGetElement ( t_ServiceDependancies , &t_Index , & t_Element ) ;
							if ( t_Status == S_OK )
							{
								try
								{
									CHString t_String ( t_Element ) ;
									_tcscpy ( & t_DependancyList [ t_BufferLength ] , t_String ) ;

									t_BufferLength += _tcslen ( t_String ) + 1 ;
								}
								catch ( ... )
								{
									SysFreeString ( t_Element ) ;

									throw ;
								}

								SysFreeString ( t_Element ) ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}
						}
					}

					t_DependancyList [ t_TotalLength ] = 0 ;
				}
				catch ( ... )
				{
					delete [] t_DependancyList ;

					throw ;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

	}
	catch ( ... )
	{
		if ( t_LoadOrderGroupDependancies )
			SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;

		if ( t_ServiceDependancies )
			SafeArrayDestroy ( t_ServiceDependancies ) ;

		throw ;
	}

	if ( t_LoadOrderGroupDependancies )
		SafeArrayDestroy ( t_LoadOrderGroupDependancies ) ;

	if ( t_ServiceDependancies )
		SafeArrayDestroy ( t_ServiceDependancies ) ;


	SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , SC_MANAGER_CREATE_SERVICE | SC_MANAGER_LOCK ) ;
	if ( t_ServiceControlManager )
	{
		SC_LOCK t_Lock = LockServiceDatabase ( t_ServiceControlManager ) ;
		if ( t_Lock )
		{
			try
			{
				if ( a_Create )
				{
					DWORD t_TagId = 0 ;

					LPCTSTR t_SN = (LPCTSTR) t_ServiceName ;
					LPCTSTR t_DN = (LPCTSTR) t_DisplayName ;
					LPCTSTR t_PN = (LPCTSTR) t_PathName ;
					LPCTSTR t_LO = t_LoadOrderGroupSpecified ? (LPCTSTR) t_LoadOrderGroup : NULL ;
					LPCTSTR t_STN = t_StartNameSpecified ? (LPCTSTR) t_StartName : NULL ;
					LPCTSTR t_SP = t_StartPasswordSpecified ? (LPCTSTR) t_StartPassword : NULL ;

					SmartCloseServiceHandle t_Service = CreateService (

						t_ServiceControlManager ,
						t_SN ,
						t_DN ,
						SERVICE_ALL_ACCESS ,
						t_ServiceType,
						t_ServiceStartMode ,
						t_ServiceErrorControl ,
						t_PN ,
						t_LO ,
						( t_ServiceType & SERVICE_BOOT_START || t_ServiceType & SERVICE_SYSTEM_START ) ? &t_TagId : NULL ,
						t_DependancyList ,
						t_STN ,
						t_SP
					) ;

					if ( t_Service )
					{
						a_Status = STATUS_SUCCESS ;
					}
					else
					{
						a_Status = GetServiceErrorCode () ;
					}
				}
				else
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_ServiceName , SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ) ;
					if ( t_Service )
					{
						DWORD t_SizeNeeded = 0 ;
						QUERY_SERVICE_CONFIG *t_ServiceConfig = NULL ;
						BOOL t_Status = QueryServiceConfig ( t_Service , NULL , 0 ,  & t_SizeNeeded ) ;
						if ( ! t_Status )
						{
							if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
							{
								t_ServiceConfig = ( QUERY_SERVICE_CONFIG * ) new char [ t_SizeNeeded ] ;
								t_Status = QueryServiceConfig ( t_Service , t_ServiceConfig , t_SizeNeeded ,  & t_SizeNeeded ) ;
								if ( t_Status )
								{
								}
							}
						}

						if ( t_Status )
						{
							LPCTSTR t_DN = t_DisplayNameSpecified ? (LPCTSTR) t_DisplayName : NULL ;
							LPCTSTR t_PN = t_PathNameSpecified ? (LPCTSTR) t_PathName : NULL ;
							LPCTSTR t_LO = t_LoadOrderGroupSpecified ? (LPCTSTR) t_LoadOrderGroup : NULL ;
							LPCTSTR t_STN = t_StartNameSpecified ? (LPCTSTR) t_StartName : NULL ;
							LPCTSTR t_SP = t_StartPasswordSpecified ? (LPCTSTR) t_StartPassword : NULL ;

							DWORD t_TagId = 0 ;
							t_Status = ChangeServiceConfig (

								t_Service ,
								t_ServiceTypeSpecified ? t_ServiceType : t_ServiceConfig->dwServiceType ,
								t_ServiceStartModeSpecified ? t_ServiceStartMode : t_ServiceConfig->dwStartType ,
								t_ServiceErrorControlSpecified ? t_ServiceErrorControl : t_ServiceConfig->dwErrorControl ,
								t_PN ,
								t_LO ,
								NULL ,
								t_DependancyList ,
								t_STN ,
								t_SP ,
								t_DN
							) ;

							if ( t_Status )
							{
								a_Status = STATUS_SUCCESS ;
							}
							else
							{
								a_Status = GetServiceErrorCode () ;
							}
						}
						else
						{
							a_Status = GetServiceErrorCode () ;
						}

					}
					else
					{
						a_Status = GetServiceErrorCode () ;
					}
				}

			}
			catch ( ... )
			{
				UnlockServiceDatabase ( t_Lock ) ;

				throw ;
			}

			UnlockServiceDatabase ( t_Lock ) ;
		}
		else
		{
			a_Status = GetServiceErrorCode () ;
		}
	}
	else
	{
		a_Status = GetServiceErrorCode () ;
	}

	delete [] t_DependancyList ;

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecCreate (

	const CInstance& a_Class ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;

	if ( a_InParams && a_OutParams )
	{
		DWORD t_Status = STATUS_SUCCESS ;

		t_Result = CheckParameters ( a_Class , a_InParams , a_OutParams , t_Status , TRUE ) ;
		if ( a_OutParams )
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecChange (

	const CInstance& a_Instance ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;

	if ( a_InParams && a_OutParams )
	{
		DWORD t_Status = STATUS_SUCCESS ;

		t_Result = CheckParameters ( a_Instance , a_InParams , a_OutParams , t_Status , FALSE ) ;
		if ( a_OutParams )
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif

#ifdef NTONLY
HRESULT Win32_BaseService :: ExecChangeStartMode (

	const CInstance& a_Instance ,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Name ;

	if ( a_InParams && a_OutParams )
	{
		CHString t_ServiceName ;

		DWORD t_State ;
		bool t_AcceptPause ;
		bool t_AcceptStop ;

		HRESULT t_Result = GetServiceStatus (

			a_Instance ,
			t_ServiceName ,
			t_State ,
			t_AcceptPause ,
			t_AcceptStop
		) ;

		if ( FAILED ( t_Result ) )
		{
			return WBEM_E_PROVIDER_FAILURE ;
		}


		CHString t_StartMode ;
		DWORD t_ServiceStartMode ;

		bool t_Exists ;
		VARTYPE t_Type ;

		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_STARTMODE , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_STARTMODE , t_StartMode ) && ! t_StartMode.IsEmpty () )
				{
					if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_BOOT ) == 0 )
					{
						t_ServiceStartMode = SERVICE_BOOT_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_SYSTEM ) == 0 )
					{
						t_ServiceStartMode = SERVICE_SYSTEM_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_AUTOMATIC ) == 0 )
					{
						t_ServiceStartMode = SERVICE_AUTO_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_MANUAL ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DEMAND_START ;
					}
					else if ( t_StartMode.CompareNoCase ( PROPERTY_VALUE_START_TYPE_DISABLE ) == 0 )
					{
						t_ServiceStartMode = SERVICE_DISABLED ;
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
						return t_Result ;
					}
				}
				else
				{
					if ( a_OutParams )
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
					return t_Result ;
				}
			}
			else
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
				return t_Result ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_INVALID_PARAMETER ) ;
			return WBEM_E_PROVIDER_FAILURE ;
		}

		SmartCloseServiceHandle t_ServiceControlManager = OpenSCManager ( NULL , NULL , SC_MANAGER_CREATE_SERVICE | SC_MANAGER_LOCK ) ;
		if ( t_ServiceControlManager )
		{
			SC_LOCK t_Lock = LockServiceDatabase ( t_ServiceControlManager ) ;
			if ( t_Lock )
			{
				try
				{
					SmartCloseServiceHandle t_Service = OpenService ( t_ServiceControlManager , t_ServiceName , SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ) ;
					if ( t_Service )
					{
						DWORD t_SizeNeeded = 0 ;
						QUERY_SERVICE_CONFIG *t_ServiceConfig = NULL ;
						try
						{
							BOOL t_Status = QueryServiceConfig ( t_Service , NULL , 0 ,  & t_SizeNeeded ) ;
							if ( ! t_Status )
							{
								if ( GetLastError () == ERROR_INSUFFICIENT_BUFFER )
								{
									t_ServiceConfig = ( QUERY_SERVICE_CONFIG * ) new char [ t_SizeNeeded ] ;
									if ( t_ServiceConfig )
									{
										t_Status = QueryServiceConfig ( t_Service , t_ServiceConfig , t_SizeNeeded ,  & t_SizeNeeded ) ;
										if ( t_Status )
										{
										}
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}

							if ( t_Status )
							{
								BOOL t_Status = ChangeServiceConfig (

									t_Service ,
									t_ServiceConfig->dwServiceType ,
									t_ServiceStartMode ,
									t_ServiceConfig->dwErrorControl ,
									NULL ,
									NULL ,
									NULL ,
									NULL ,
									NULL ,
									NULL ,
									t_ServiceConfig->lpDisplayName
								) ;

								if ( t_Status )
								{
									if ( a_OutParams )
										a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , STATUS_SUCCESS ) ;
								}
								else
								{
									if ( a_OutParams )
										a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
								}
							}
							else
							{
								if ( a_OutParams )
									a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
							}

						}
						catch ( ... )
						{
							delete [] t_ServiceConfig ;

							throw ;
						}

						delete [] t_ServiceConfig ;
					}
					else
					{
						if ( a_OutParams )
							a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
					}
				}
				catch ( ... )
				{
					UnlockServiceDatabase ( t_Lock ) ;

					throw ;
				}

				UnlockServiceDatabase ( t_Lock ) ;
			}
			else
			{
				if ( a_OutParams )
					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
			}
		}
		else
		{
			if ( a_OutParams )
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , GetServiceErrorCode () ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bus.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// bus.h -- Bus property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/98    a-kevhu         Created
//
//============================================================================


#include "precomp.h"
#include <cregcls.h>
#include <comdef.h>
#include <vector>
#include <assertbreak.h>
#include "bus.h"
#include "resource.h"

// Property set declaration
CWin32Bus MyBusSet(IDS_Win32_Bus, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::CWin32Bus
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Bus::CWin32Bus(
	LPCWSTR setName,
	LPCWSTR pszNamespace) :
    Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::~CWin32Bus
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Bus::~CWin32Bus()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Bus::GetObject(

	CInstance *pInstance,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chsDeviceID;
	pInstance->GetCHString(IDS_DeviceID, chsDeviceID);
	chsDeviceID.MakeUpper();

    CBusList cbl;
    if (cbl.AlreadyAddedToList(chsDeviceID))
    {
        // It is a bus that really does exist, so...
        // Get instance data that is not platform specific.
        hr = SetCommonInstance(pInstance, FALSE);
        if (SUCCEEDED(hr))
        {
            // Set instance specific info:
            LONG lPos = cbl.GetIndexInListFromDeviceID(chsDeviceID);

            if (lPos != -1)
            {
	            CHString chstrTmp;

                // Set the PNPDeviceID if we have one:

                if (cbl.GetListMemberPNPDeviceID(lPos, chstrTmp))
                {
                    pInstance->SetCHString(IDS_PNPDeviceID, chstrTmp);
                }
            }
        }
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::EnumerateInstances
 *
 *  DESCRIPTION : Supplies all instances of CWin32Bus
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Bus::EnumerateInstances(

	MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<CHString*> vecchsBusList;

    // Make a list of buses:
    CBusList cbl;
    LONG     lSize = cbl.GetListSize();

    // Set all the data for each bus
    for (LONG m = 0L;(m < lSize && SUCCEEDED(hr)); m ++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
		CHString     chstrTmp;

        // Set bus data
		if (cbl.GetListMemberDeviceID(m, chstrTmp))
		{
			pInstance->SetCHString(IDS_DeviceID, chstrTmp);

            // Set the PNPDeviceID if we have one:
			if (cbl.GetListMemberPNPDeviceID(m, chstrTmp))
			{
				pInstance->SetCHString(IDS_PNPDeviceID, chstrTmp);
			}

			hr = SetCommonInstance(pInstance, TRUE);
			if (SUCCEEDED(hr))
			{
				hr = pInstance->Commit();
			}
        }
    }

    // Machine must have at least one bus, or something is seriously wrong
    if (lSize == 0)
    {
        hr = WBEM_E_FAILED;
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::GetCommonInstance
 *
 *  DESCRIPTION : Assigns instance values common to all platforms
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32Bus::SetCommonInstance(

	CInstance *pInstance,
	BOOL fEnum
)
{
    // Only do so if it really exists, however!
    CHString chsTemp;

    pInstance->GetCHString(IDS_DeviceID, chsTemp);
	chsTemp.MakeUpper();

    if (!fEnum) // redundant to check the following if this is an enum
    {
        CBusList cbl;

        if (!cbl.AlreadyAddedToList(chsTemp))
        {
            return WBEM_E_NOT_FOUND;
        }
    }

    // Set properties inherited from CIM_LogicalDevice
    CHString sTemp2;
    LoadStringW(sTemp2, IDR_Bus);

    pInstance->SetCHString(IDS_Caption, sTemp2);
    SetCreationClassName(pInstance);  // Method of Provider class
    pInstance->SetCHString(IDS_Description, sTemp2);
    pInstance->SetCHString(IDS_Name, sTemp2);
    pInstance->SetCharSplat(
		IDS_SystemCreationClassName,
        IDS_Win32ComputerSystem);

    pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());

    // Set properties of this class(not derived from CIM_LogicalDevice)
    if (chsTemp.Find(IDS_BUS_DEVICEID_TAG) != -1)
    {
        CHString chsNum =
                    chsTemp.Right(chsTemp.GetLength() - chsTemp.Find(IDS_BUS_DEVICEID_TAG) -
                        (sizeof(IDS_BUS_DEVICEID_TAG) / sizeof(TCHAR) - 1));
		DWORD    dwNum = _wtol(chsNum);

        pInstance->SetDWORD(IDS_BusNum, dwNum);

        CHString chsType = chsTemp.Left(chsTemp.Find(L"_"));

	    DWORD dwBusTypeNum;

        if (!GetBusTypeNumFromStr(chsType, &dwBusTypeNum))
        {
            return WBEM_E_NOT_FOUND;
        }

        pInstance->SetDWORD(IDS_BusType, dwBusTypeNum);
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION    : CBusList::GenerateBusList
 *
 *  DESCRIPTION : helper to generate a list of busses.
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// This was added because some old 9x machines only have one of the last two
// buses.
static LPWSTR GetBusTypeFromString(LPCWSTR szDescription)
{
    if (!_wcsicmp(szDescription, L"PCI BUS"))
        return szBusType[5];
    else if (!_wcsicmp(szDescription, L"EISA BUS"))
        return szBusType[2];
    else if (!_wcsicmp(szDescription, L"ISA PLUG AND PLAY BUS"))
        return szBusType[1];
    else
        return NULL;
}


void CBusList::AddBusToList(LPCWSTR szDeviceID, LPCWSTR szPNPID)
{
    ASSERT_BREAK(szDeviceID != NULL);

    // Then check if the bus is in our list yet,
    if (!AlreadyAddedToList(szDeviceID))
    {
        CBusInfo bus;

        bus.chstrBusDeviceID = szDeviceID;

        if (szPNPID)
            bus.chstrBusPNPDeviceID = szPNPID;

        // and add it if not.
        m_vecpchstrList.push_back(bus);
    }
}

void CBusList::GenerateBusList()
{
	CConfigManager cfgmgr;
	CDeviceCollection devlist;

    if (cfgmgr.GetDeviceList(devlist))
    {
        REFPTR_POSITION pos;

        if (devlist.BeginEnum(pos))
        {
            CConfigMgrDevicePtr pDevice;

            for (pDevice.Attach(devlist.GetNext(pos));
                pDevice != NULL;
                pDevice.Attach(devlist.GetNext(pos)))
            {
                // First check to see whether this was a PCI bus connected to
				// another bus.
				// Look at the name of pDevice.  If the name is found via
                // GetBusTypeFromString set pDevice's DeviceID with
                // pcbi->chstrBusPNPDeviceID.  Set the DeviceID for win32_bus
                // as PCI_BUS_n, where n is the last number of the
                // config manager device id.

				CHString chstrName;

                if (pDevice->GetDeviceDesc(chstrName))
				{
				    LPWSTR szBusName = GetBusTypeFromString(chstrName);

                    if (szBusName)
					{
						CHString strPNPID;

						if (pDevice->GetDeviceID(strPNPID))
						{
							LONG m = strPNPID.ReverseFind('\\');

							if (m != -1 && m != strPNPID.GetLength() - 1) // in case the last char was a '/'
							{
								CHString chstrBusNum = strPNPID.Mid(m + 1),
                                         strDeviceID;

    							strDeviceID.Format(
									L"%s%s%s",
									szBusName,
									IDS_BUS_DEVICEID_TAG,
									(LPCWSTR) chstrBusNum);

								AddBusToList(strDeviceID, strPNPID);
                            }
						}
					}
                }

				// Then continue generating the rest of the bus list by looking
				// at devices hanging off of busses:

				INTERFACE_TYPE itBusType;  //chwres.h

				// Initialize variables

				DWORD dwBusNumber = 0xFFFFFFFF;

				// For each device, need its bus info.

				if (pDevice->GetBusInfo(& itBusType, & dwBusNumber))
				{
					if (dwBusNumber == 0xFFFFFFFF || itBusType < 0 ||
                        itBusType >= KNOWN_BUS_TYPES)
					{
						// We didn't get the bus number, or it was
						// out of range.
						continue;
					}

					// Make what will be the DeviceID:

					CHString chsBusType;

					if (StringFromInterfaceType(itBusType, chsBusType))
					{
					    CHString strDeviceID;

                        strDeviceID.Format(
							L"%s%s%d",
							(LPCWSTR) chsBusType,
							IDS_BUS_DEVICEID_TAG,
							dwBusNumber);

						AddBusToList(strDeviceID, NULL);
					}
				}

                devlist.EndEnum();
            }
        }
    }

#ifdef NTONLY
    // Have seen some machines with PCMCIA busses that don't get picked up
    // via the method above(using ConfigMgr) on NT4 and NT5.  Therefore, we
    // need to examine the registry.  However, it a PCMCIA bus has been
    // added to the list at this point, don't bother with this hacked approach.

	if (!FoundPCMCIABus())
	{
	    CRegistry reg;

		// If the key below exists, we assume a PCMCIA bus exist.

		DWORD dwErr = reg.Open(
        		HKEY_LOCAL_MACHINE,
				L"HARDWARE\\DESCRIPTION\\System\\PCMCIA PCCARDS",
				KEY_READ);

		if (dwErr == ERROR_SUCCESS)
		{
			// A PCMCIA bus exists.
			// Make what will be the DeviceID(hardwired in this case):
            CHString strDeviceID;

		    strDeviceID.Format(
				L"%s%s%d",
				L"PCMCIA",
				IDS_BUS_DEVICEID_TAG,
				0);

    		AddBusToList(strDeviceID, NULL);
        }
    }
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::GetBusTypeNumFromStr
 *
 *  DESCRIPTION : Assigns instance values common to all platforms
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32Bus::GetBusTypeNumFromStr(
	LPCWSTR szType,
	DWORD *pdwTypeNum)
{
	// March through list of possibilities and return appropriate value:

	for (DWORD m = 0; m < KNOWN_BUS_TYPES; m++)
	{
        if (!_wcsicmp(szType, szBusType[m]))
		{
			*pdwTypeNum = m;
			return TRUE;
		}
	}

    return FALSE;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::AlreadyAddedToList
 *
 *  DESCRIPTION : Internal helper to check if item was added to list
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CBusList::AlreadyAddedToList(LPCWSTR szItem)
{
    for (LONG m = 0; m < m_vecpchstrList.size(); m ++)
    {
        if (!_wcsicmp(m_vecpchstrList[m].chstrBusDeviceID, szItem))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Bus::FoundPCMCIABus
 *
 *  DESCRIPTION : Internal helper to see if we have a PCMCIA bus
 *
 *  INPUTS      : pInstance, pointer to instance of interest
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CBusList::FoundPCMCIABus()
{
    // Need to look through our list of busses and see if any start with
    // the text PCMCIA.  If so, return true.
    for (LONG m = 0; m < m_vecpchstrList.size(); m ++)
    {
        if (wcsstr(m_vecpchstrList[m].chstrBusDeviceID, L"PCMCIA"))
        {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bservice.h ===
//=================================================================

//

// Service.h -- Service property set provider (Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               10/27/97    davwoh         Moved to curly
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_BASESERVICE		L"Win32_BaseService"
#define PROPERTY_NAME_STATE				L"State"
#define PROPERTY_NAME_ACCEPTSTOP		L"AcceptStop"
#define PROPERTY_NAME_ACCEPTPAUSE		L"AcceptPause"

#define PROPERTY_VALUE_STATE_STOPPED			L"Stopped"
#define PROPERTY_VALUE_STATE_STARTPENDING		L"Start Pending"
#define PROPERTY_VALUE_STATE_STOPPENDING		L"Stop Pending"
#define PROPERTY_VALUE_STATE_RUNNING			L"Running"
#define PROPERTY_VALUE_STATE_CONTINUEPENDING	L"Continue Pending"
#define PROPERTY_VALUE_STATE_PAUSEPENDING		L"Pause Pending"
#define PROPERTY_VALUE_STATE_PAUSED				L"Paused"

#define METHOD_NAME_START				L"StartService"
#define METHOD_NAME_STOP				L"StopService"
#define METHOD_NAME_PAUSE				L"PauseService"
#define METHOD_NAME_RESUME				L"ResumeService"
#define METHOD_NAME_USERCONTROLSERVICE	L"UserControlService"
#define METHOD_NAME_INTERROGATE			L"InterrogateService"
#define METHOD_NAME_CREATE				L"Create"
#define METHOD_NAME_CHANGESTARTMODE		L"ChangeStartMode"
#define METHOD_NAME_DELETE				L"Delete"
#define METHOD_NAME_CHANGE				L"Change"
#define METHOD_ARG_NAME_CONTROLCODE		L"ControlCode"

#define METHOD_NAME_INDEX_START					0
#define METHOD_NAME_INDEX_STOP					1
#define METHOD_NAME_INDEX_PAUSE					2
#define METHOD_NAME_INDEX_RESUME				3
#define METHOD_NAME_INDEX_USERCONTROLSERVICE	4
#define METHOD_NAME_INDEX_INTERROGATE			5
#define METHOD_ARG_NAME_CONTROLCODE		L"ControlCode"
#define METHOD_ARG_NAME_RETURNVALUE		L"ReturnValue"


#define METHOD_ARG_CLASS_WIN32_BASESERVICE				L"Win32_BaseService"
#define METHOD_ARG_CLASS_WIN32_LOADORDERGROUP			L"Win32_LoadOrderGroup"

#define METHOD_ARG_NAME_LOADORDERGROUPDEPENDENCIES	L"LoadOrderGroupDependencies"
#define METHOD_ARG_NAME_SERVICEDEPENDENCIES			L"ServiceDependencies"

#define METHOD_ARG_NAME_DESKTOPINTERACT			L"DesktopInteract"
#define METHOD_ARG_NAME_NAME					L"Name"
#define METHOD_ARG_NAME_DISPLAYNAME				L"DisplayName"
#define METHOD_ARG_NAME_ERRORCONTROL			L"ErrorControl"
#define METHOD_ARG_NAME_PATHNAME				L"PathName"
#define METHOD_ARG_NAME_SERVICETYPE				L"ServiceType"
#define METHOD_ARG_NAME_STARTMODE				L"StartMode"
#define METHOD_ARG_NAME_STARTNAME				L"StartName"
#define METHOD_ARG_NAME_STARTPASSWORD			L"StartPassword"
#define METHOD_ARG_NAME_LOADORDERGROUP			L"LoadOrderGroup"

#define PROPERTY_VALUE_STARTNAME_LOCAL_SYSTEM		L"LocalSystem"

#define PROPERTY_VALUE_START_TYPE_BOOT				L"Boot"
#define PROPERTY_VALUE_START_TYPE_SYSTEM			L"System"
#define PROPERTY_VALUE_START_TYPE_AUTOMATIC			L"Automatic"
#define PROPERTY_VALUE_START_TYPE_MANUAL			L"Manual"
#define PROPERTY_VALUE_START_TYPE_DISABLE			L"Disabled"

#define PROPERTY_VALUE_SERVICE_TYPE_KERNAL_DRIVER		1
#define PROPERTY_VALUE_SERVICE_TYPE_FILE_SYSTEM_DRIVER	2
#define PROPERTY_VALUE_SERVICE_TYPE_ADAPTER				4
#define PROPERTY_VALUE_SERVICE_TYPE_RECOGNIZER_DRIVER	8
#define PROPERTY_VALUE_SERVICE_TYPE_OWN_PROCESS			16
#define PROPERTY_VALUE_SERVICE_TYPE_SHARE_PROCESS		32

#define PROPERTY_VALUE_ERROR_CONTROL_IGNORE		0
#define PROPERTY_VALUE_ERROR_CONTROL_NORMAL		1
#define PROPERTY_VALUE_ERROR_CONTROL_SEVERE		2
#define PROPERTY_VALUE_ERROR_CONTROL_CRITICAL	3

// Common
#undef STATUS_SUCCESS
#define STATUS_SUCCESS							0
#undef STATUS_NOT_SUPPORTED					
#define STATUS_NOT_SUPPORTED					1

// Control
#undef STATUS_ACCESS_DENIED				
#define STATUS_ACCESS_DENIED					2
#define STATUS_DEPENDENT_SERVICES_RUNNING		3
#define STATUS_INVALID_SERVICE_CONTROL			4
#define STATUS_SERVICE_CANNOT_ACCEPT_CTRL		5
#define STATUS_SERVICE_NOT_ACTIVE				6
#define STATUS_SERVICE_REQUEST_TIMEOUT			7
#define STATUS_UNKNOWN_FAILURE					8

// Start
#define STATUS_PATH_NOT_FOUND					9
#define STATUS_SERVICE_ALREADY_RUNNING			10
#define STATUS_SERVICE_DATABASE_LOCKED			11
#define STATUS_SERVICE_DEPENDENCY_DELETED		12
#define STATUS_SERVICE_DEPENDENCY_FAIL			13
#define STATUS_SERVICE_DISABLED					14
#define STATUS_SERVICE_LOGON_FAILED				15
#define STATUS_SERVICE_MARKED_FOR_DELETE		16
#define STATUS_SERVICE_NO_THREAD				17
#define STATUS_SERVICE_ALREADY_PAUSED			24

// Create
#define STATUS_CIRCULAR_DEPENDENCY				18
#define STATUS_DUP_NAME							19
#define STATUS_INVALID_NAME						20
#undef STATUS_INVALID_PARAMETER			
#define STATUS_INVALID_PARAMETER				21
#define STATUS_INVALID_SERVICE_ACCOUNT			22
#define STATUS_SERVICE_EXISTS					23

// Get/set function protos
//========================

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

class Win32_BaseService :public Provider
{
public:

        // Constructor/destructor
        //=======================

        Win32_BaseService (

			const CHString &a_Name,
			LPCWSTR a_Namespace
		) ;

       ~Win32_BaseService () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject(CInstance *pInstance, long lFlags = 0L) { return WBEM_E_NOT_AVAILABLE ; }

        HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L) { return WBEM_E_NOT_AVAILABLE ; }

		HRESULT ExecMethod (

			const CInstance &a_Instance,
			const BSTR a_MethodName,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags = 0L
		) ;

		HRESULT DeleteInstance (

			const CInstance& a_Instance,
			long a_Flags = 0L
		) ;

    protected:

        // Utility
        //========

        // Utility function(s)
        //====================

#ifdef NTONLY
		HRESULT GetServiceStatus (

			const CInstance& a_Instance,
			CHString &a_Name ,
			DWORD &a_State ,
			bool &a_AcceptPause ,
			bool &a_AcceptStop
		) ;

		DWORD GetServiceErrorCode () ;
		HRESULT GetServiceResultCode () ;

		DWORD CheckParameters (

			const CInstance& a_Instance,
			CInstance *a_InParams ,
			CInstance *a_OutParams ,
			DWORD &a_Status ,
			BOOL a_Create
		) ;

		HRESULT ExecStart (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecStop (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecPause (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecResume (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecInterrogate (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecUserControlService (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecCreate (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecChange (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecDelete (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;

		HRESULT ExecChangeStartMode (

			const CInstance& a_Instance,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long lFlags
		) ;
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cadapters.cpp ===
//=================================================================

//

// CAdapters.CPP -- adapter configuration retrieval

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//
// Revisions:	09/15/98	        Created
//
//				03/03/99    		Added graceful exit on SEH and memory failures,
//											syntactic clean up

//=================================================================
#include "precomp.h"

#ifndef MAX_INTERFACE_NAME_LEN
#define MAX_INTERFACE_NAME_LEN  256
#endif

#include <iphlpapi.h>
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <devioctl.h>
#include "wsock32api.h"

#include "ntddtcp.h"
#include "CAdapters.h"
#include <..\..\framework\provexpt\include\provexpt.h>


#define MAX_TDI_ENTITIES_	512
#define INV_INADDR_LOOPBACK 0x0100007f

/*******************************************************************
    NAME:       CAdapters

    SYNOPSIS:   construction and cleanup for this class

	ENTRY:

    HISTORY:
                  03-sep-1998     Created
********************************************************************/
CAdapters::CAdapters() :	m_fSocketsAlive( 0 ), m_dwStartupError( ERROR_SUCCESS ), m_hTcpipDriverHandle ( INVALID_HANDLE_VALUE )
{
	m_pwsock32api	= (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
	if ( m_pwsock32api )
	{
		WSADATA		t_wsaData ;
		m_fSocketsAlive			= ( m_pwsock32api->WsWSAStartup(0x0101, &t_wsaData ) == 0 ) ;

#ifdef NTONLY
		m_hTcpipDriverHandle = m_oDriverIO.Open( (PWSTR) DD_TCP_DEVICE_NAME );
#endif

		GetAdapterInstances() ;
	}
	else
	{
		m_dwStartupError = ::GetLastError();
	}
}

//
CAdapters::~CAdapters()
{
	_ADAPTER_INFO *t_pchsDel;

	for( int t_iar = 0; t_iar < GetSize(); t_iar++ )
	{
		if( t_pchsDel = (_ADAPTER_INFO*) GetAt( t_iar ) )
		{
			delete t_pchsDel ;
		}
	}

#ifdef NTONLY
	if( INVALID_HANDLE_VALUE != m_hTcpipDriverHandle )
	{
		m_oDriverIO.Close( m_hTcpipDriverHandle ) ;
	}
#endif

	if( m_fSocketsAlive )
	{
		m_pwsock32api->WsWSACleanup() ;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, m_pwsock32api);
}

// Socket entry point
DWORD CAdapters::wsControl(	DWORD a_dwProto,
							DWORD a_dwAction,
							LPVOID a_pIn,
							LPDWORD a_pdwInLen,
							LPVOID a_pOut,
							LPDWORD a_pdwOutLen )
{
	// NT
    DWORD t_dw = ERROR_PROC_NOT_FOUND ;

#ifdef NTONLY
	if( INVALID_HANDLE_VALUE != m_hTcpipDriverHandle )
	{
		DWORD t_dwBytesReturned ;
		if( !DeviceIoControl(	m_hTcpipDriverHandle,
								IOCTL_TCP_QUERY_INFORMATION_EX,
								a_pIn,
								*a_pdwInLen,
								a_pOut,
								*a_pdwOutLen,
								&t_dwBytesReturned,
								NULL
								) )
		{
			  return GetLastError();
		}
		*a_pdwOutLen = t_dwBytesReturned ;

		return TDI_SUCCESS ;
	}
	return ERROR_INVALID_HANDLE ;
#endif

#ifdef WIN9XONLY

	// Win9x
	m_pwsock32api->WsControl( a_dwProto, a_dwAction, a_pIn, a_pdwInLen, a_pOut, a_pdwOutLen, &t_dw );

   return t_dw ;

#endif

	return ERROR_APP_WRONG_OS ;	// can't get here
}

/*******************************************************************
    NAME:       GetAdapterInstances

    SYNOPSIS:   retrives information on adapters present in the system

    HISTORY:
                  03-sep-1998     Created
********************************************************************/
void CAdapters::GetAdapterInstances()
{
	_ADAPTER_INFO *t_pAdapterInfo  = NULL ;

	while( TRUE )
	{
		// Add the IP bound adapters to our list
		if( !( t_pAdapterInfo = new _ADAPTER_INFO ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}
        try
        {
		    if( !GetTCPAdapter( GetSize(), (_ADAPTER_INFO*)t_pAdapterInfo ) )
		    {
			    break;
		    }
        }
        catch(...)
        {
            if(t_pAdapterInfo)
            {
                delete t_pAdapterInfo;
                t_pAdapterInfo = NULL;
            }
            throw;
        }

		Add( t_pAdapterInfo );
	}

	// Now find the IPX bindings. Only one instance will be available under win9x
	DWORD t_dwAdapter = 0 ;
	DWORD t_dwAdapterCount = GetSize() ;

	do
	{
		if( !GetIPXMACAddress( t_dwAdapter, t_pAdapterInfo ) )
		{
			break ;
		}

		// test to see if this IPX bound adapter has been bound by IP also
		for( DWORD t_dw1 = 0; t_dw1 < t_dwAdapterCount; t_dw1++ )
		{
			_ADAPTER_INFO *t_pAdapterTest = (_ADAPTER_INFO*) GetAt( t_dw1 ) ;

			BOOL t_fMatch = TRUE ;
			for( int t_i = 0; t_i < 6; t_i++ )
			{
				if( t_pAdapterInfo->Address[ t_i ] != t_pAdapterTest->Address[ t_i ] )
				{
					t_fMatch = FALSE ;
					break ;
				}
			}
			if( t_fMatch )
			{
				// this existing adapter bound to IPX as well
				t_pAdapterTest->IPXEnabled = t_pAdapterInfo->IPXEnabled;
				t_pAdapterTest->IPXAddress = t_pAdapterInfo->IPXAddress;

				goto Next_adapter;
			}
		}

		// new adapter
		Add( t_pAdapterInfo );

		if( !( t_pAdapterInfo = new _ADAPTER_INFO ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

Next_adapter:;

	}	while ( ++t_dwAdapter ) ;

	if( t_pAdapterInfo )
	{
		delete t_pAdapterInfo ;
	}

	return ;
}


/*******************************************************************
    NAME:       GetTCPAdapter

    SYNOPSIS:   populates an _ADAPTER_INFO class with information about the specified adapter
				This function utilizes the WsControl entry point of the wsock32

	ENTRY:      DWORD dwIndex	:
				_ADAPTER_INFO* pAdapterInfo 	:



    HISTORY:
                  03-sep-1998     Created
********************************************************************/
BOOL CAdapters::GetTCPAdapter( DWORD a_dwIndex, _ADAPTER_INFO *a_pAdapterInfo )
{
	BOOL			t_fRes = FALSE ;
	DWORD			t_dwAdapterCount = 0 ;
	UINT			t_uEntityCount ;
	TDIEntityID*	t_entityList = NULL;
	TCP_REQUEST_QUERY_INFORMATION_EX t_req ;
	TDIObjectID		t_id ;
	DWORD			t_status ;
    DWORD			t_inputLen ;
    DWORD			t_outputLen ;

	// guarded resources
	TDIEntityID*	t_pEntity		= NULL ;
	IPAddrEntry*	t_pIPAddrTable	= NULL ;
	BYTE*			t_pRouteTable	= NULL ;

#if NTONLY >= 5
    PBYTE pbBuff = NULL;
    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;
#endif

	try
	{
		if( !a_pAdapterInfo )
		{
			return FALSE ;
		}

		if( !( t_entityList = GetEntityList( &t_uEntityCount ) ) || !t_uEntityCount )
		{
			return t_fRes;
		}

    DWORD dwErrGetIPForwardTable = -1L;

#if NTONLY >= 5
        DWORD dwRoutTableBufSize = 0L;
        PMIB_IPFORWARDTABLE pmibft = NULL;
        dwErrGetIPForwardTable = ::GetIpForwardTable(
            NULL,
            &dwRoutTableBufSize,
            TRUE);

        if(dwErrGetIPForwardTable == ERROR_INSUFFICIENT_BUFFER)
        {
            pbBuff = new BYTE[dwRoutTableBufSize];
            pmibft = (PMIB_IPFORWARDTABLE) pbBuff;

            dwErrGetIPForwardTable = ::GetIpForwardTable(
                pmibft,
                &dwRoutTableBufSize,
                TRUE);
        }
#endif


		int t_i;
		for( t_i = 0, t_pEntity = t_entityList; t_i < t_uEntityCount; ++t_i, ++t_pEntity )
		{
			if( IF_ENTITY != t_pEntity->tei_entity )
			{
				continue;
			}

			// IF_ENTITY: this entity/instance describes an adapter
			DWORD	t_isMib;
			BYTE	t_info[ sizeof( IFEntry ) + ( MAX_ADAPTER_DESCRIPTION_LENGTH * 2 ) + 2 ];
			IFEntry	*t_pIfEntry = ( IFEntry* ) t_info;

			// find out if this entity supports MIB requests
			memset( &t_req, 0, sizeof( t_req ) ) ;

			t_id.toi_entity	= *t_pEntity ;
			t_id.toi_class	= INFO_CLASS_GENERIC ;
			t_id.toi_type	= INFO_TYPE_PROVIDER ;
			t_id.toi_id		= ENTITY_TYPE_ID ;

			t_req.ID = t_id ;

			t_inputLen = sizeof( t_req ) ;
			t_outputLen = sizeof( t_isMib ) ;

			t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
									&t_req, &t_inputLen, &t_isMib, &t_outputLen );

			if( TDI_SUCCESS != t_status )
			{
				goto error_exit ;
			}

			// entity doesn't support MIB requests - try another
			if ( t_isMib != IF_MIB )
			{
				continue ;
			}

			// MIB requests supported - query the adapter info
			t_id.toi_class	= INFO_CLASS_PROTOCOL ;
			t_id.toi_id		= IF_MIB_STATS_ID ;

			memset( &t_req, 0, sizeof( t_req ) ) ;
			t_req.ID = t_id ;

			t_inputLen = sizeof( t_req ) ;
			t_outputLen = sizeof(t_info ) ;

			t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
									&t_req, &t_inputLen, &t_info, &t_outputLen );

			if ( t_status != TDI_SUCCESS )
			{
				goto error_exit;
			}

			// we only want physical adapters
			if ( !IS_INTERESTING_ADAPTER( t_pIfEntry ) )
			{
				continue ;
			}

			// looking for the right adapter
			if( a_dwIndex != t_dwAdapterCount++ )
			{
				continue;
			}

			a_pAdapterInfo->IPEnabled = TRUE ;

			// Adapter description
			uchar t_ucDesc[ MAX_ADAPTER_DESCRIPTION_LENGTH + 1 ] ;

			int t_iDescLen = min( MAX_ADAPTER_DESCRIPTION_LENGTH, t_pIfEntry->if_descrlen ) ;

			memcpy( &t_ucDesc, t_pIfEntry->if_descr, t_iDescLen );
			t_ucDesc[ t_iDescLen ] = NULL ;

			a_pAdapterInfo->Description = t_ucDesc ;

			a_pAdapterInfo->AddressLength =
				min( MAX_ADAPTER_ADDRESS_LENGTH, (size_t) t_pIfEntry->if_physaddrlen ) ;
			memcpy( &a_pAdapterInfo->Address, t_pIfEntry->if_physaddr, a_pAdapterInfo->AddressLength ) ;

			a_pAdapterInfo->Index = (UINT)t_pIfEntry->if_index ;
			a_pAdapterInfo->Type = (UINT)t_pIfEntry->if_type ;


			// Now that we have ID'd the adapter get the IP info
			for( t_i = 0, t_pEntity = t_entityList; t_i < t_uEntityCount; ++t_i, ++t_pEntity )
			{
				if( CL_NL_ENTITY != t_pEntity->tei_entity )
				{
					continue;
				}

				IPSNMPInfo t_info;
				DWORD t_type;

				// See if this network layer entity supports IP
				memset( &t_req, 0, sizeof( t_req ) ) ;

				t_id.toi_entity	= *t_pEntity ;
				t_id.toi_class	= INFO_CLASS_GENERIC ;
				t_id.toi_type	= INFO_TYPE_PROVIDER ;
				t_id.toi_id		= ENTITY_TYPE_ID ;

				t_req.ID = t_id ;

				t_inputLen = sizeof( t_req );
				t_outputLen = sizeof( t_type );

				t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
									&t_req, &t_inputLen, &t_type, &t_outputLen );

				if ( TDI_SUCCESS != t_status || CL_NL_IP != t_type )
				{
					continue;
				}

				// okay, this NL provider supports IP. Let's get them addresses:
				// First we find out how many by getting the SNMP stats and looking
				// at the number of addresses supported by this interface

				memset( &t_req, 0, sizeof( t_req ) ) ;

				t_id.toi_class	= INFO_CLASS_PROTOCOL ;
				t_id.toi_id		= IP_MIB_STATS_ID ;

				t_req.ID = t_id ;

				t_inputLen = sizeof( t_req ) ;
				t_outputLen = sizeof( t_info ) ;

				t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
									&t_req, &t_inputLen, &t_info, &t_outputLen ) ;

				if( ( t_status != TDI_SUCCESS ) || ( t_outputLen != sizeof( t_info ) ) )
				{
					continue ;
				}

				// Get the IP addresses & subnet masks
				if( t_info.ipsi_numaddr )
				{
					// this interface has some addresses. What are they?
					UINT t_numberOfAddresses ;
					UINT t_i ;

					if( t_pIPAddrTable )
					{
						delete[] t_pIPAddrTable ;
					}

					if( !( t_pIPAddrTable = (IPAddrEntry*) new IPAddrEntry[ t_info.ipsi_numaddr ] ) )
					{
						throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
					}

					memset( &t_req, 0, sizeof( t_req ) ) ;

					t_id.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID ;

					t_req.ID = t_id ;

					t_inputLen  = sizeof( t_req ) ;
					t_outputLen = t_info.ipsi_numaddr * sizeof( IPAddrEntry ) ;

					t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
									&t_req, &t_inputLen, t_pIPAddrTable, &t_outputLen ) ;

					if( t_status != TDI_SUCCESS )
					{
						continue;
					}

					// now loop through this list of IP addresses, applying them
					// to the correct adapter
					t_numberOfAddresses = min( (UINT)( t_outputLen / sizeof( IPAddrEntry ) ),
											(UINT) t_info.ipsi_numaddr ) ;

					IPAddrEntry *t_pIPAddr = t_pIPAddrTable ;

                    DWORD dwMetric = 0xFFFFFFFFL;

					for( t_i = 0; t_i < t_numberOfAddresses; ++t_i, ++t_pIPAddr )
					{
						if( a_pAdapterInfo->Index == (UINT) t_pIPAddr->iae_index )
						{
                            dwMetric = 0xFFFFFFFFL;
#if NTONLY >= 5
                            if(dwErrGetIPForwardTable == ERROR_SUCCESS)
                            {
                                GetRouteCostMetric(
                                    t_pIPAddr->iae_addr, 
                                    pmibft, 
                                    &dwMetric);
                            }
#endif                            
                            _IP_INFO *t_pIPInfo = pAddIPInfo(	t_pIPAddr->iae_addr,
																t_pIPAddr->iae_mask,
																t_pIPAddr->iae_context,
                                                                dwMetric ) ;
							if( !t_pIPInfo )
							{
								goto error_exit ;
							}

							// add to the IP array for this adapter
							a_pAdapterInfo->aIPInfo.Add( t_pIPInfo ) ;
						}
					}
				}

				// Get the gateway server IP address(es)
				if( t_info.ipsi_numroutes )
				{
					memset( &t_req, 0, sizeof( t_req ) ) ;

					t_id.toi_id = IP_MIB_RTTABLE_ENTRY_ID;

					t_req.ID = t_id ;

					t_inputLen = sizeof( t_req ) ;

					//
					// Warning: platform specifics; Win95 structure size is different
					// than NT 4.0
					//
					int t_structLength ;

		#ifdef WIN9XONLY
					t_structLength = sizeof( IPRouteEntry ) ;
		#endif
		#ifdef NTONLY
					t_structLength = sizeof( IPRouteEntryNT ) ;
		#endif

					t_outputLen = t_structLength * t_info.ipsi_numroutes ;

					UINT	t_numberOfRoutes;
					DWORD	t_previousOutputLen = t_outputLen ;

					// the route table may have grown since we got the SNMP stats
					do {

						t_numberOfRoutes = (UINT)( t_outputLen / t_structLength ) ;

						if( t_pRouteTable )
						{
							delete[] t_pRouteTable ;
						}

						if( !( t_pRouteTable = new BYTE[ t_structLength * t_numberOfRoutes ] ) )
						{
							throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
						}

						t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
									&t_req, &t_inputLen, t_pRouteTable, &t_outputLen ) ;

						if ( t_status != TDI_SUCCESS )
						{
							continue;
						}

					} while( t_outputLen > t_previousOutputLen ) ;



#if NTONLY >= 5
                    if(dwErrGetIPForwardTable == ERROR_SUCCESS)
                    {    
                        for(int x = 0; x < pmibft->dwNumEntries; x++)
                        {
                            if(pmibft->table[x].dwForwardMask == INADDR_ANY)
						    {
							    if(a_pAdapterInfo->Index == (UINT) pmibft->table[x].dwForwardIfIndex)
							    {
								    if(MIB_IPROUTE_TYPE_INVALID !=
                                        pmibft->table[x].dwForwardType)
                                    {
                                        _IP_INFO *pGateway = pAddIPInfo(
                                            pmibft->table[x].dwForwardNextHop,
											INADDR_ANY,
											0,
											pmibft->table[x].dwForwardMetric1);

								        if(!pGateway)
								        {
									        goto error_exit;
								        }
                                        else
                                        {
                                            // add to the gateway array
								            a_pAdapterInfo->aGatewayInfo.Add(pGateway);
                                        }					            
                                    }
							    }
						    }    
                        }    
                    }
#endif
				}
			}	// end for IP info

			t_fRes = TRUE ;
			break ;
		}
#if NTONLY >= 5
        if(pbBuff)
        {
            delete pbBuff;
            pbBuff = NULL;
        }
#endif

	}
#if NTONLY >= 5
    catch(Structured_Exception se)
    {
        if(pbBuff)
        {
            delete pbBuff;
            pbBuff = NULL;
        }
        goto error_exit;
    }
#endif
	catch( ... )
	{
		if( t_entityList )
		{
			delete[] t_entityList;
		}
		if( t_pIPAddrTable )
		{
			delete[] t_pIPAddrTable;
		}
		if( t_pRouteTable )
		{
			delete[] t_pRouteTable;
		}
#if NTONLY >= 5
        if(pbBuff)
        {
            delete pbBuff;
            pbBuff = NULL;
        }
#endif
		throw ;
	}

	error_exit:

		if( t_entityList )
		{
			delete[] t_entityList;
		}
		if( t_pIPAddrTable )
		{
			delete[] t_pIPAddrTable;
		}
		if( t_pRouteTable )
		{
			delete[] t_pRouteTable;
		}
#if NTONLY >= 5
        if(pbBuff)
        {
            delete pbBuff;
            pbBuff = NULL;
        }
#endif
		return t_fRes ;
}

/*******************************************************************
    NAME:       pAddIPInfo

    SYNOPSIS:   Allocates a _IP_INFO class, and populates it with the input parameters

	ENTRY:      DWORD dwIPAddr	:
				DWORD dwIPMask	:
				DWORD dwContext	:

	EXIT    _IP_INFO* - the created IPInfo class

    RETURNS Success - pointer to allocated class
            Failure - NULL

    HISTORY:
                  14-sep-1998     Created
********************************************************************/
_IP_INFO* CAdapters::pAddIPInfo( DWORD a_dwIPAddr, DWORD a_dwIPMask, DWORD a_dwContext, DWORD a_dwCostMetric )
{
	_IP_INFO *t_pIPInfo = new _IP_INFO;

	if( !t_pIPInfo )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	// IP address
	t_pIPInfo->dwIPAddress = a_dwIPAddr;
	t_pIPInfo->chsIPAddress.Format( L"%d.%d.%d.%d",
		t_pIPInfo->bIPAddress[ 0 ], t_pIPInfo->bIPAddress[ 1 ],
		t_pIPInfo->bIPAddress[ 2 ], t_pIPInfo->bIPAddress[ 3 ] );

	// IP mask
	t_pIPInfo->dwIPMask = a_dwIPMask;
	t_pIPInfo->chsIPMask.Format( L"%d.%d.%d.%d",
		t_pIPInfo->bIPMask[ 0 ], t_pIPInfo->bIPMask[ 1 ],
		t_pIPInfo->bIPMask[ 2 ], t_pIPInfo->bIPMask[ 3 ] );

	// hold on to the context ID
	t_pIPInfo->dwContext = a_dwContext;

	// hold on to the context ID
	t_pIPInfo->dwCostMetric = a_dwCostMetric;

	return t_pIPInfo ;
}
/*******************************************************************
    NAME:       GetEntityList

    SYNOPSIS:   Allocates a buffer for, and retrieves, the list of entities supported by the
				TCP/IP device driver

	ENTRY:      unsigned int* EntityCount	:

	EXIT    EntityCount - number of entities in the buffer

    RETURNS Success - pointer to allocated buffer containing list of entities
            Failure - NULL

    HISTORY:
                  03-sep-1998     Created
********************************************************************/
TDIEntityID* CAdapters::GetEntityList(unsigned int *a_EntityCount )
{
 	TCP_REQUEST_QUERY_INFORMATION_EX t_req ;
    DWORD		t_status ;
    DWORD		t_inputLen ;
    DWORD		t_outputLen ;
	TDIEntityID	*t_pEntity = NULL ;
    int			t_moreEntities = TRUE ;

    memset( &t_req, 0, sizeof( t_req ) ) ;

    t_req.ID.toi_entity.tei_entity		= GENERIC_ENTITY ;
    t_req.ID.toi_entity.tei_instance	= 0 ;
    t_req.ID.toi_class					= INFO_CLASS_GENERIC ;
    t_req.ID.toi_type					= INFO_TYPE_PROVIDER ;
    t_req.ID.toi_id						= ENTITY_LIST_ID ;

    t_inputLen = sizeof( t_req ) ;
    t_outputLen = sizeof(TDIEntityID) * MAX_TDI_ENTITIES_ ;

	do {

        DWORD t_previousOutputLen ;

        t_previousOutputLen = t_outputLen ;

		if ( t_pEntity )
		{
            delete[] t_pEntity ;
        }

		if( !( t_pEntity = (TDIEntityID*) new TDIEntityID[ t_outputLen / sizeof(TDIEntityID) ] ) )
        {
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

        t_status = wsControl( IPPROTO_TCP, WSCNTL_TCPIP_QUERY_INFO,
								&t_req, &t_inputLen, t_pEntity, &t_outputLen ) ;

		if ( t_status != TDI_SUCCESS )
		{
            delete[] t_pEntity ;
            return NULL ;
        }

        if ( t_outputLen <= t_previousOutputLen )
		{
            t_moreEntities = FALSE ;
        }
    } while ( t_moreEntities ) ;

    *a_EntityCount = (UINT)( t_outputLen / sizeof( TDIEntityID ) );

	return t_pEntity ;
}

/*******************************************************************
    NAME:       GetIPXMACAddress

    SYNOPSIS:   Retrieves the mac address for an adapter via the IPX sockets interface

    ENTRY:      DWORD dwIndex	:
				_ADAPTER_INFO* a_pAdapterInfo	:

    HISTORY:
                  03-sep-1998     Created
********************************************************************/
BOOL CAdapters::GetIPXMACAddress( DWORD a_dwIndex, _ADAPTER_INFO *a_pAdapterInfo )
{
	BOOL t_fRet = FALSE;

	if( !a_pAdapterInfo )
	{
		return t_fRet;
	}

	CHString t_chsAddress ;
	CHString t_chsNum ;

	WSADATA	t_wsaData ;
	int		t_cAdapter = a_dwIndex ;
	int		t_res ;
	int		t_cbOpt  = sizeof( t_cAdapter ) ;
	int		t_cbAddr = sizeof( SOCKADDR_IPX ) ;
	SOCKADDR_IPX   t_Addr ;

	if ( m_pwsock32api->WsWSAStartup( 0x0101, &t_wsaData ) )
	{
		return t_fRet;
	}

	// guarded resource
	SOCKET	t_s = INVALID_SOCKET ;

	try
	{
		// Create IPX socket.
		t_s = m_pwsock32api->Wssocket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX ) ;

		// Socket must be bound prior to calling IPX_MAX_ADAPTER_NUM.
		memset( &t_Addr, 0, sizeof( t_Addr ) ) ;
		t_Addr.sa_family = AF_IPX ;

		t_res = m_pwsock32api->Wsbind( t_s, (SOCKADDR*) &t_Addr, t_cbAddr ) ;

		IPX_ADDRESS_DATA  t_IpxData ;

		memset( &t_IpxData, 0, sizeof( t_IpxData ) ) ;

		// Specify which adapter to check.
		t_IpxData.adapternum = t_cAdapter ;
		t_cbOpt = sizeof( t_IpxData ) ;

		// Get information for the current adapter.
		t_res = m_pwsock32api->Wsgetsockopt(	t_s,
							NSPROTO_IPX,
							IPX_ADDRESS,
							(char*) &t_IpxData,
							&t_cbOpt ) ;

		// end of adapter array
		if( ( 0 == t_res ) && ( t_IpxData.adapternum == t_cAdapter ) )
		{
			a_pAdapterInfo->AddressLength = 6 ;
			memcpy( &a_pAdapterInfo->Address, &t_IpxData.nodenum, 6 ) ;

			// IpxData contains the address for the current adapter.
			int t_i ;
			for ( t_i = 0; t_i < 4; t_i++ )
			{
				t_chsNum.Format( L"%02X", t_IpxData.netnum[t_i] ) ;
				t_chsAddress = t_chsAddress + t_chsNum ;
			}
			t_chsAddress = t_chsAddress + L":" ;

			for ( t_i = 0; t_i < 5; t_i++ )
			{
				t_chsNum.Format(L"%02X", t_IpxData.nodenum[ t_i ] ) ;
				t_chsAddress = t_chsAddress + t_chsNum ;
			}
			t_chsNum.Format(L"%02X", t_IpxData.nodenum[ t_i ] ) ;
			t_chsAddress = t_chsAddress + t_chsNum;

			a_pAdapterInfo->IPXAddress = t_chsAddress ;
			a_pAdapterInfo->IPXEnabled = TRUE ;

			t_fRet = TRUE ;
		}
	}
	catch( ... )
	{
		if( INVALID_SOCKET != t_s )
		{
			m_pwsock32api->Wsclosesocket( t_s ) ;
		}
		m_pwsock32api->WsWSACleanup() ;

		throw ;
	}

	if ( t_s != INVALID_SOCKET )
	{
		m_pwsock32api->Wsclosesocket( t_s ) ;
		t_s = INVALID_SOCKET ;
	}

	m_pwsock32api->WsWSACleanup();

	return t_fRet ;
}



/*******************************************************************
    NAME:       GetTCPAdapter

    SYNOPSIS:   Looks up the cost metric associated with using a 
                particular ipaddress associated with an adapter.
                We obtain this by examining the ip forward table,
                and following the following rules:

                1) For entries in the table for which the
                   dwForwardDest matches dwIPAddr, we try to
                   find a loopback route to that address.  We 
                   identify such routes by their having a 
                   dwForwardNextHop value of INADDR_LOOPBACK.

                2) As we identify metrics in 1, if the metric is
                   less than any previously identified metric,
                   we save the new metric.  At the end we will
                   have the smallest metric.

	ENTRY:      DWORD dwIPAddr	:  ip address for which to find the 
                                   cost metric.
				PMIB_IPFORWARDTABLE pmibft 	:  ip forward table used 
                                   to find the metric.
                PDWORD pdwMetric  :  out parameter that will contain 
                                   the metric, or 0 if not found.


    HISTORY:    06-April-2001     KHughes Created
********************************************************************/
#if NTONLY >= 5
void CAdapters::GetRouteCostMetric(
    DWORD dwIPAddr, 
    PMIB_IPFORWARDTABLE pmibft, 
    PDWORD pdwMetric)
{
    DWORD dwMin = 0xFFFFFFFF;

    for(int x = 0; x < pmibft->dwNumEntries; x++)
    {
		if(dwIPAddr == (UINT) pmibft->table[x].dwForwardDest)
        {
            if(pmibft->table[x].dwForwardNextHop == INV_INADDR_LOOPBACK)
			{  
				if(MIB_IPROUTE_TYPE_INVALID !=
                    pmibft->table[x].dwForwardType)
                {
					if(pmibft->table[x].dwForwardMetric1 <
                        dwMin)
                    {
                        dwMin = pmibft->table[x].dwForwardMetric1;
                    }
                }
            }
        }
    }

    *pdwMetric = dwMin;    
}
#endif

/*******************************************************************
    NAME:       _ADAPTER_INFO

    SYNOPSIS:   cleanup for this class

	ENTRY:

    HISTORY:
                  15-sep-1998     Created
********************************************************************/
_ADAPTER_INFO::_ADAPTER_INFO()
{
	AddressLength	= 0;
	memset( &Address, 0, MAX_ADAPTER_ADDRESS_LENGTH ) ;
	Index			= 0 ;
	Type			= 0 ;
	IPEnabled		= FALSE ;
	IPXEnabled	= FALSE ;
	Marked		= FALSE ;
}

_ADAPTER_INFO::~_ADAPTER_INFO()
{
	_IP_INFO *t_pchsDel ;

	for( int t_iar = 0; t_iar < aIPInfo.GetSize(); t_iar++ )
		if( ( t_pchsDel = (_IP_INFO*)aIPInfo.GetAt( t_iar ) ) )
			delete t_pchsDel ;

	for( t_iar = 0; t_iar < aGatewayInfo.GetSize(); t_iar++ )
	{
		if( ( t_pchsDel = (_IP_INFO*)aGatewayInfo.GetAt( t_iar ) ) )
		{
			delete t_pchsDel ;
		}
	}
}

/*******************************************************************
    NAME:       vMark, fIsMarked

    SYNOPSIS:   marks or reports on an instance of the adapter for tracking purposes

    HISTORY:
                  30-sep-1998     Created
********************************************************************/
void _ADAPTER_INFO::Mark()
{ Marked = TRUE; }

BOOL _ADAPTER_INFO::IsMarked()
{ return Marked; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\bootconfig.h ===
//=================================================================

//

// BootConfig.h -- Win32 boot configuration property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_BOOTCONFIG L"Win32_BootConfiguration"
//#define  PROPSET_UUID_BOOTCONFIG "{B745D28E-09C5-11d1-A29F-00C04FC2A120}"

class BootConfig:public Provider {

    public:

        // Constructor/destructor
        //=======================

        BootConfig(const CHString& name, LPCWSTR pszNameSpace) ;
       ~BootConfig() ;

        // Functions provide properties with current values
        //=================================================
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);



        HRESULT LoadPropertyValues(CInstance* pInstance) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cadapters.h ===
//=================================================================

//

// CAdapters.CPP -- Win9x adapter configuration retrieval

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/15/98	        Created
//
//				03/03/99    		Added graceful exit on SEH and memory failures,
//											syntactic clean up		 
//
//=================================================================
#ifndef _CADAPTERS_H_
#define _CADAPTERS_H_


#include <tdiinfo.h>
#include <llinfo.h>
#include <tdistat.h>
#include <ipinfo.h>
#include "NTDriverIO.h"
#include <ipifcons.h>



// wsock32 wsControl 
//#define WSOCK_DLL		_T("wsock32.dll")
//#define WSCONTROL		"WsControl"
//typedef DWORD (CALLBACK* LPWSCONTROL)( DWORD, DWORD, LPVOID, LPDWORD, LPVOID, LPDWORD );
#define WSCNTL_TCPIP_QUERY_INFO 0


// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == MIB_IF_TYPE_LOOPBACK))

// from: index1/nt/private/inc/ipinfo.h 
// This version is specific to NT and is defined locally to
// to differentiate this structure from Win9x.
// If we move to dual binary we should #ifdef *ire_context
// for NT and rename IPRouteEntryNT to IPRouteEntry.  
//  
typedef struct IPRouteEntryNT { 
	ulong           ire_dest;
	ulong           ire_index; 
	ulong           ire_metric1;
	ulong           ire_metric2; 
	ulong           ire_metric3;
	ulong           ire_metric4; 
	ulong           ire_nexthop;
	ulong           ire_type;   
	ulong           ire_proto;
	ulong           ire_age;  
	ulong           ire_mask;
	ulong           ire_metric5;  
	void            *ire_context;
} IPRouteEntryNT;


class _IP_INFO
{
public:
	CHString chsIPAddress;
	CHString chsIPMask;
	union {
		DWORD dwIPAddress;
		BYTE bIPAddress[4];
	};
	union {
		DWORD dwIPMask;
		BYTE bIPMask[4];
	};
	DWORD	 dwContext;
	DWORD	 dwCostMetric;
};

//#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 
//#define MAX_ADAPTER_ADDRESS_LENGTH      8   

class _ADAPTER_INFO
{
public:
	CHString	Description;
	CHString	IPXAddress;
	CHPtrArray	aIPInfo;		// _IP_INFO array
	CHPtrArray	aGatewayInfo;	// _IP_INFO array
	UINT		AddressLength;
	BYTE		Address[MAX_ADAPTER_ADDRESS_LENGTH];
	UINT		Index;
	UINT		Type;
	BOOL		IPEnabled;
	BOOL		IPXEnabled;
	BOOL		Marked;

	_ADAPTER_INFO();
	~_ADAPTER_INFO();

	void Mark();
	BOOL IsMarked();
};

// _ADAPTER_INFO array class
class CAdapters : public CHPtrArray
{
private:
	
#ifdef NTONLY
	NTDriverIO					m_oDriverIO;
#endif

	CWsock32Api *m_pwsock32api ;
	HANDLE		m_hTcpipDriverHandle;
	BOOL		m_fSocketsAlive ;
    DWORD       m_dwStartupError ;

	DWORD wsControl (
		
		DWORD dwProto, 
		DWORD dwAction, 
		LPVOID pIn, 
		LPDWORD pdwInLen, 
		LPVOID pOut, 
		LPDWORD pdwOutLen
	);

	void GetAdapterInstances();
	BOOL GetIPXMACAddress( DWORD dwIndex, _ADAPTER_INFO* pAdapterInfo );
	BOOL GetTCPAdapter( DWORD dwIndex, _ADAPTER_INFO* pAdapterInfo );
	TDIEntityID* GetEntityList(unsigned int* EntityCount);
	_IP_INFO* pAddIPInfo( DWORD dwIPAddr, DWORD dwIPMask, DWORD dwContext, DWORD a_dwCostMetric = 0 );

#if NTONLY >= 5
    void GetRouteCostMetric(
        DWORD dwIPAddr, 
        PMIB_IPFORWARDTABLE pmibft, 
        PDWORD pdwMetric);
#endif

public:
	        
	//=================================================
	// Constructor/destructor
	//=================================================
	CAdapters();
	~CAdapters();
    DWORD GetStartupError() { return m_dwStartupError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cdrom.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  CDROM.CPP
//
//  Purpose: CDROM property set provider
//
//***************************************************************************

#include "precomp.h"
#include <frqueryex.h>
#include <cregcls.h>

#include <winioctl.h>
#include <ntddscsi.h>
#include <comdef.h>

#include "CDROM.h"

#include "MSINFO_cdrom.h"

#define CONFIG_MANAGER_CLASS_CDROM L"CDROM"

// Property set declaration
//=========================

CWin32CDROM MyCDROMSet ( PROPSET_NAME_CDROM, IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::CWin32CDROM
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32CDROM :: CWin32CDROM (

	LPCWSTR setName,
	LPCWSTR pszNamespace

) : Provider ( setName, pszNamespace )
{
    m_ptrProperties.SetSize(30);

    m_ptrProperties[0] = ((LPVOID) IDS_DriveIntegrity);
    m_ptrProperties[1] = ((LPVOID) IDS_TransferRate);
    m_ptrProperties[2] = ((LPVOID) IDS_Status);
    m_ptrProperties[3] = ((LPVOID) IDS_DeviceID);  // This one can drop out if need be
    m_ptrProperties[4] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[6] = ((LPVOID) IDS_Description);
    m_ptrProperties[7] = ((LPVOID) IDS_Caption);
    m_ptrProperties[8] = ((LPVOID) IDS_Name);
    m_ptrProperties[9] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[10] = ((LPVOID) IDS_ProtocolSupported);
    m_ptrProperties[11] = ((LPVOID) IDS_SCSITargetId);
    m_ptrProperties[12] = ((LPVOID) IDS_Drive);
    m_ptrProperties[13] = ((LPVOID) IDS_Id);
    m_ptrProperties[14] = ((LPVOID) IDS_Capabilities);
    m_ptrProperties[15] = ((LPVOID) IDS_MediaType);
    m_ptrProperties[16] = ((LPVOID) IDS_VolumeName);
    m_ptrProperties[17] = ((LPVOID) IDS_MaximumComponentLength);
    m_ptrProperties[18] = ((LPVOID) IDS_FileSystemFlags);
    m_ptrProperties[19] = ((LPVOID) IDS_VolumeSerialNumber);
    m_ptrProperties[20] = ((LPVOID) IDS_Size);
    m_ptrProperties[21] = ((LPVOID) IDS_MediaLoaded);
    m_ptrProperties[22] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[23] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[24] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[25] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[26] = ((LPVOID) IDS_SCSILogicalUnit);
    m_ptrProperties[27] = ((LPVOID) IDS_SCSIBus);
    m_ptrProperties[28] = ((LPVOID) IDS_SCSIPort);
    m_ptrProperties[29] = ((LPVOID) IDS_FileSystemFlagsEx);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::~CWin32CDROM
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32CDROM::~CWin32CDROM()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString sDeviceID ;
    if (pInstance->GetCHString ( IDS_DeviceID, sDeviceID ))
    {
#ifdef WIN9XONLY

        // 9x uses the pnpid as the key
	    CConfigManager configMgr;
        CConfigMgrDevicePtr pDevice;

	    if ( configMgr.LocateDevice ( sDeviceID, &pDevice ) )
	    {
		    if	( pDevice->IsClass ( CONFIG_MANAGER_CLASS_CDROM ) )
            {
                CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

                DWORD dwProperties;
                pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

            	hr = LoadPropertyValuesWin95 ( pInstance, pDevice, dwProperties ) ;
            }
        }

#else
    STRING2STRING::iterator      mapIter;
    STRING2STRING DriveArray;

    LoadDriveLetters(DriveArray);
    sDeviceID.MakeUpper();

    if( ( mapIter = DriveArray.find( sDeviceID ) ) != DriveArray.end() )
    {
        CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

        DWORD dwProperties;
        pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

        hr = LoadPropertyValuesNT ( pInstance, sDeviceID, (LPCWSTR) (*mapIter).second, dwProperties ) ;
    }

#endif

    }

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: ExecQuery (

	MethodContext *pMethodContext,
	CFrameworkQuery &pQuery,
	long lFlags /* = 0L */
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    hr = Enumerate(pMethodContext, dwProperties);

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, SPECIAL_PROPS_ALL_REQUIRED);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::Enumerate
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CDROM :: Enumerate (
	MethodContext *a_MethodContext,
    DWORD a_dwRequiredProperties
)
{
    HRESULT t_Result = WBEM_E_FAILED;

#ifdef WIN9XONLY
	CConfigManager t_ConfigManager ;
	CDeviceCollection t_DeviceList ;

    // Get the list of cdrom devices
	if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_CDROM ) )
	{
		REFPTR_POSITION t_Position ;

		if ( t_DeviceList.BeginEnum ( t_Position ) )
		{
			CConfigMgrDevicePtr t_Device;

			t_Result = WBEM_S_NO_ERROR ;

			// Walk the list
            for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
                 SUCCEEDED(t_Result) && (t_Device != NULL);
                 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
			{
				CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
            	t_Result = LoadPropertyValuesWin95 ( t_Instance, t_Device, a_dwRequiredProperties ) ;

    			if (SUCCEEDED(t_Result))
                {
                    t_Result = t_Instance->Commit ( ) ;
                }
            }
        }
    }

#else
    STRING2STRING::iterator      mapIter;
    STRING2STRING DriveArray;

    LoadDriveLetters(DriveArray);

    mapIter = DriveArray.begin();
    while ( mapIter != DriveArray.end() )
    {
        CInstancePtr pInstance (CreateNewInstance ( a_MethodContext ), false) ;

        t_Result = LoadPropertyValuesNT ( pInstance, (LPCWSTR) (*mapIter).first, (LPCWSTR) (*mapIter).second, a_dwRequiredProperties ) ;

        if (SUCCEEDED(t_Result))
        {
			t_Result = pInstance->Commit ( ) ;
        }
        mapIter++;
    }

    t_Result = WBEM_S_NO_ERROR;

#endif

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadPropertyValuesNT
 *
 *  DESCRIPTION : Assigns values to NT-specific properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32CDROM :: LoadPropertyValuesNT (

	CInstance *pInstance,
    LPCWSTR pszDeviceID,
	LPCWSTR pszDriveSpec,
    DWORD dwSpecReqProps
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString t_VolumeName;
    if (pszDriveSpec[0] != 0)
    {
	    t_VolumeName = pszDriveSpec;
        t_VolumeName += L'\\';
    }

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	pInstance->SetWBEMINT16(IDS_Availability, 3 ) ;
	SetCreationClassName ( pInstance ) ;


    // Now let's do the PNP ID.  This is pretty kludgy, but it's the best way I've found
    // to turn a drive letter into a pnp on nt4.

    CHString sDeviceID;
    DWORD dwDeviceNum = _wtoi(&pszDeviceID[13]);
    sDeviceID.Format(L"ROOT\\LEGACY_CDROM\\%04d", dwDeviceNum);

	CConfigManager cfgManager;
	CConfigMgrDevicePtr pDevice;

	// Retrieve the device and set the properties.
	if ( cfgManager.LocateDevice ( sDeviceID, &pDevice ) )
	{
		SetConfigMgrProperties ( pDevice , pInstance ) ;
        pInstance->SetNull(IDS_PNPDeviceID);

        CHString t_sTemp;
	    if ( pDevice->GetDeviceDesc ( t_sTemp ) )
	    {
		    pInstance->SetCHString( IDS_Description, t_sTemp ) ;
    	    pInstance->SetCHString( IDS_Caption, t_sTemp ) ;
            pInstance->SetCHString( IDS_Name, t_sTemp ) ;
        }

	    if (pDevice->GetFriendlyName ( t_sTemp ) )
        {
    	    pInstance->SetCHString( IDS_Name, t_sTemp ) ;
    	    pInstance->SetCHString( IDS_Caption, t_sTemp ) ;
        }

	    if ( pDevice->GetMfg ( t_sTemp ) )
        {
            pInstance->SetCHString( IDS_Manufacturer, t_sTemp ) ;
        }
	}

    if (pszDriveSpec[0] != 0)
    {
        pInstance->SetWCHARSplat ( IDS_Drive ,  pszDriveSpec ) ;
	    pInstance->SetWCHARSplat ( IDS_Id , pszDriveSpec ) ;
    }

    pInstance->SetWCHARSplat ( IDS_DeviceID, pszDeviceID);

    pInstance->SetCharSplat ( IDS_MediaType , IDS_MDT_CD ) ;

    // Create a safearray for the Capabilities information

	SAFEARRAYBOUND rgsabound [ 1 ] ;
	variant_t vValue;

    rgsabound[0].cElements = 2 ;
    rgsabound[0].lLbound = 0 ;
    V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
	if ( V_ARRAY(&vValue) )
	{
		V_VT(&vValue) = VT_I2 | VT_ARRAY ;
		long ix[1];

		ix[0] = 0;
		DWORD dwVal = 3 ;
		HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , &dwVal ) ;
		if ( t_Result == E_OUTOFMEMORY )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		ix[0] = 1;
		dwVal = 7;
		t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , &dwVal ) ;
		if ( t_Result == E_OUTOFMEMORY )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

		pInstance->SetVariant ( IDS_Capabilities , vValue ) ;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

    // Keep track of whether we had problems reading the VolumeInfo
    BOOL t_Status = TRUE;

    if (dwSpecReqProps &
        (SPECIAL_PROPS_MEDIALOADED |
         SPECIAL_PROPS_STATUS |
         SPECIAL_PROPS_VOLUMENAME |
         SPECIAL_PROPS_MAXCOMPONENTLENGTH |
         SPECIAL_PROPS_FILESYSTEMFLAGS |
         SPECIAL_PROPS_FILESYSTEMFLAGSEX |
         SPECIAL_PROPS_SERIALNUMBER))
    {

        WCHAR szFileSystemName[_MAX_PATH] = L"Unknown file system";
        WCHAR szVolumeName[_MAX_PATH] ;

        DWORD dwVolumeSerialNumber ;
	    DWORD dwMaxComponentLength ;
        DWORD dwFileSystemFlags ;

	    t_Status = GetVolumeInformation (

		    t_VolumeName,
		    szVolumeName,
		    sizeof(szVolumeName) / sizeof(WCHAR),
		    &dwVolumeSerialNumber,
		    &dwMaxComponentLength,
		    &dwFileSystemFlags,
		    szFileSystemName,
		    sizeof(szFileSystemName) / sizeof(WCHAR)
    	) ;

	    if ( t_Status )
	    {
		    // There's a disk in -- set disk-related props
		    //============================================

            pInstance->Setbool ( IDS_MediaLoaded , true ) ;
		    pInstance->SetCharSplat ( IDS_Status , IDS_OK ) ;
		    pInstance->SetCharSplat ( IDS_VolumeName , szVolumeName ) ;
		    pInstance->SetDWORD ( IDS_MaximumComponentLength , dwMaxComponentLength ) ;
		    pInstance->SetWORD ( IDS_FileSystemFlags , dwFileSystemFlags & 0xffff ) ;
		    pInstance->SetDWORD ( IDS_FileSystemFlagsEx , dwFileSystemFlags ) ;

		    TCHAR szTemp[_MAX_PATH] ;
		    swprintf ( szTemp, L"%X", dwVolumeSerialNumber) ;

		    pInstance->SetCharSplat ( IDS_VolumeSerialNumber , szTemp ) ;
        }
        else
        {
		    pInstance->SetCharSplat ( IDS_Status , IDS_STATUS_Unknown ) ;
            pInstance->Setbool ( IDS_MediaLoaded , false ) ;
	    }
    }

    // If we couldn't read the VolumeInfo, size ain't gonna work either
    if ((t_Status) && (dwSpecReqProps & SPECIAL_PROPS_SIZE))
    {
		DWORD dwSectorsPerCluster ;
		DWORD dwBytesPerSector ;
		DWORD dwFreeClusters ;
		DWORD dwTotalClusters ;

		t_Status = GetDiskFreeSpace (

			t_VolumeName,
			& dwSectorsPerCluster,
			& dwBytesPerSector,
			& dwFreeClusters,
			& dwTotalClusters
		) ;

		if ( t_Status )
		{
			unsigned __int64 ui64TotalBytes = (DWORDLONG) dwBytesPerSector    *
									 (DWORDLONG) dwSectorsPerCluster *
									 (DWORDLONG) dwTotalClusters     ;

			pInstance->SetWBEMINT64 ( IDS_Size, ui64TotalBytes ) ;
		}

	}

    // Set the DriveIntegrity and TransferRate properties:
    if ( (t_Status) && (dwSpecReqProps & SPECIAL_PROPS_TEST_TRANSFERRATE) )
    {
        DOUBLE d = ProfileDrive ( t_VolumeName );
        if ( d != -1 )
        {
            pInstance->SetDOUBLE ( IDS_TransferRate , d ) ;
        }
    }

    if ( (t_Status) && (dwSpecReqProps & SPECIAL_PROPS_TEST_INTEGRITY) )
    {
        CHString t_IntegrityFile;

        BOOL b = TestDriveIntegrity ( t_VolumeName, t_IntegrityFile ) ;
        if (!t_IntegrityFile.IsEmpty())
        {
            pInstance->Setbool ( IDS_DriveIntegrity , b) ;
        }
    }

    // Check for the scsi info
    if (dwSpecReqProps &
        (SPECIAL_PROPS_SCSITARGETID |
         SPECIAL_PROPS_SCSILUN |
         SPECIAL_PROPS_SCSIPORT |
         SPECIAL_PROPS_SCSIBUS |
         SPECIAL_PROPS_DESCRIPTION |
         SPECIAL_PROPS_MANUFACTURER
         ))
    {

	    // Open the drive up as a device
        //==============================

        CHString sDeviceName;
        sDeviceName.Format(L"\\\\.\\%s", pszDriveSpec);

        SmartCloseHandle hDiskHandle = CreateFile (
		    sDeviceName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            0
	    ) ;

        if ( hDiskHandle != INVALID_HANDLE_VALUE )
	    {
		    // Get SCSI information (IDE drives are still
		    // controlled by subset of SCSI miniport)
		    //===========================================

		    SCSI_ADDRESS    SCSIAddress ;
		    DWORD           dwByteCount = 0 ;
            CRegistry       RegInfo ;


		    BOOL t_Status = DeviceIoControl (

			    hDiskHandle,
			    IOCTL_SCSI_GET_ADDRESS,
			    NULL,
			    0,
			    &SCSIAddress,
			    sizeof(SCSI_ADDRESS),
			    &dwByteCount,
			    NULL
		    ) ;

		    if ( t_Status )
		    {
			    // Assign SCSI props
			    //==================

			    pInstance->SetDWORD ( IDS_SCSITargetId, DWORD ( SCSIAddress.TargetId ) ) ;
			    pInstance->SetDWORD ( IDS_SCSILogicalUnit, DWORD ( SCSIAddress.Lun ) ) ;
			    pInstance->SetDWORD ( IDS_SCSIPort, DWORD ( SCSIAddress.PortNumber ) ) ;
				pInstance->SetWBEMINT16 ( IDS_SCSIBus, DWORD ( SCSIAddress.PathId ) ) ;

                if (dwSpecReqProps & (SPECIAL_PROPS_DESCRIPTION | SPECIAL_PROPS_MANUFACTURER))
                {
                    CHString sSCSIKey, sTemp;
                    CRegistry cReg;

                    sSCSIKey.Format(L"Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                        SCSIAddress.PortNumber,
                        SCSIAddress.PathId,
                        SCSIAddress.TargetId,
                        SCSIAddress.Lun);

                    if (cReg.Open(HKEY_LOCAL_MACHINE, sSCSIKey, KEY_QUERY_VALUE) == ERROR_SUCCESS)
                    {
                        if (cReg.GetCurrentKeyValue(L"Identifier", sTemp) == ERROR_SUCCESS)
                        {
                            if (dwSpecReqProps & SPECIAL_PROPS_MANUFACTURER)
                            {
                                CHString sMfg(sTemp.Left(8));
                                sMfg.TrimRight();

                                pInstance->SetCHString(IDS_Manufacturer, sMfg);
                            }
                            if (dwSpecReqProps & SPECIAL_PROPS_DESCRIPTION)
                            {
                                CHString sDesc(sTemp.Mid(8,16));
                                sDesc.TrimRight();

                                pInstance->SetCHString(IDS_Description, sDesc);
                            }
                        }
                    }
                }

		    }
        }
    }

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadPropertyValuesWin95
 *
 *  DESCRIPTION : Assigns values to Win95-specific properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32CDROM :: LoadPropertyValuesWin95 (

	CInstance *pInstance,
	CConfigMgrDevice *a_pDevice,
    DWORD dwSpecReqProps
)
{
    CHString t_sDeviceID, t_DriveLetter, sTemp;
    CRegistry RegInfo;

    HRESULT hr = WBEM_S_NO_ERROR;

    // Set common drive properties
    //=============================

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName, L"Win32_ComputerSystem" ) ;
	pInstance->SetCHString ( IDS_SystemName, GetLocalComputerName () ) ;
	pInstance->SetWBEMINT16(IDS_Availability, 3 ) ;
    pInstance->SetCharSplat ( IDS_MediaType, IDS_MDT_CD ) ;

	SetCreationClassName ( pInstance ) ;

    a_pDevice->GetDeviceID(t_sDeviceID);
    a_pDevice->GetRegistryKeyName(sTemp);

    DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sTemp, KEY_QUERY_VALUE);
    if (dwRet == ERROR_SUCCESS)
    {
        if ( RegInfo.GetCurrentKeyValue ( IDS_RegRevisionLevelKey, sTemp ) == ERROR_SUCCESS )
        {
            pInstance->SetCharSplat ( IDS_RevisionLevel, sTemp ) ;
        }

        if ( RegInfo.GetCurrentKeyValue ( IDS_RegSCSITargetIDKey, sTemp ) == ERROR_SUCCESS )
        {
            pInstance->SetDWORD ( IDS_SCSITargetId, _wtol( sTemp ) ) ;
        }
        if ( RegInfo.GetCurrentKeyValue ( L"SCSILUN", sTemp ) == ERROR_SUCCESS )
        {
            pInstance->SetDWORD ( IDS_SCSILogicalUnit, _wtol( sTemp ) ) ;
        }

        dwRet = RegInfo.GetCurrentKeyValue(L"CurrentDriveLetterAssignment", t_DriveLetter);
    }

    CHString t_Drive(t_DriveLetter + ':');

    if (dwRet == ERROR_SUCCESS)
    {
        pInstance->SetCHString ( IDS_Drive, t_Drive ) ;
        pInstance->SetCHString ( IDS_Drive, t_Drive ) ;
    	pInstance->SetCHString ( IDS_Id, t_Drive ) ;
        pInstance->SetCHString ( IDS_Name, t_Drive ) ;
    	pInstance->SetCHString ( IDS_Caption, t_Drive ) ;

    }
    else
    {
        pInstance->SetCHString ( IDS_Name, t_sDeviceID ) ;
    	pInstance->SetCHString ( IDS_Caption, t_sDeviceID ) ;
    }

	// create key for CDRomDrive
    pInstance->SetCHString(IDS_DeviceID, t_sDeviceID);

    // Set some common CM props
    SetConfigMgrProperties(a_pDevice, pInstance);

    if (a_pDevice->GetMfg(sTemp))
    {
        pInstance->SetCHString(IDS_Manufacturer, sTemp);
    }

    if (a_pDevice->GetDeviceDesc(sTemp))
    {
        pInstance->SetCHString(IDS_Description, sTemp);
    }

    // Set the DriveIntegrity and TransferRate properties:
    if ( dwSpecReqProps & SPECIAL_PROPS_TEST_TRANSFERRATE )
    {
        DOUBLE d = ProfileDrive ( t_Drive );
        if ( d != -1 )
        {
            pInstance->SetDOUBLE ( IDS_TransferRate, d ) ;
        }
    }

    if ( dwSpecReqProps & SPECIAL_PROPS_TEST_INTEGRITY )
    {
        CHString t_IntegrityFile;

        BOOL b = TestDriveIntegrity ( t_Drive, t_IntegrityFile ) ;
        if (!t_IntegrityFile.IsEmpty())
        {
            pInstance->Setbool ( IDS_DriveIntegrity, b) ;
        }
    }

    // Create a safearray for the Capabilities information
	SAFEARRAYBOUND rgsabound [ 1 ] ;
	variant_t vValue;

    rgsabound[0].cElements = 2 ;
    rgsabound[0].lLbound = 0 ;
    V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2, 1, rgsabound ) ;
	if ( V_ARRAY(&vValue) )
	{
		V_VT(&vValue) = VT_I2 | VT_ARRAY ;
		long ix[1];

		ix[0] = 0;
		DWORD dwVal = 3 ;
		HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue), ix, &dwVal ) ;

		ix[0] = 1;
		dwVal = 7;
		t_Result = SafeArrayPutElement ( V_ARRAY(&vValue), ix, &dwVal ) ;

		pInstance->SetVariant ( IDS_Capabilities, vValue ) ;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

    // Keep track of whether we had problems reading the VolumeInfo
    BOOL t_Status = TRUE;

    if (dwSpecReqProps &
        (SPECIAL_PROPS_MEDIALOADED |
         SPECIAL_PROPS_STATUS |
         SPECIAL_PROPS_VOLUMENAME |
         SPECIAL_PROPS_MAXCOMPONENTLENGTH |
         SPECIAL_PROPS_FILESYSTEMFLAGS |
         SPECIAL_PROPS_FILESYSTEMFLAGSEX |
         SPECIAL_PROPS_SERIALNUMBER))
    {
        TCHAR szFileSystemName[_MAX_PATH] = _T("Unknown file system");
        TCHAR szVolumeName[_MAX_PATH] ;

        DWORD dwVolumeSerialNumber ;
	    DWORD dwMaxComponentLength ;
        DWORD dwFileSystemFlags ;

	    t_Status = GetVolumeInformation (

		    TOBSTRT(t_Drive),
		    szVolumeName,
		    sizeof(szVolumeName) / sizeof(WCHAR),
		    &dwVolumeSerialNumber,
		    &dwMaxComponentLength,
		    &dwFileSystemFlags,
		    szFileSystemName,
		    sizeof(szFileSystemName) / sizeof(WCHAR)
	    ) ;

	    if ( t_Status )
	    {
		    // There's a disk in -- set disk-related props
		    //============================================

            pInstance->Setbool ( IDS_MediaLoaded, true ) ;
		    pInstance->SetCharSplat ( IDS_Status, IDS_OK ) ;
		    pInstance->SetCharSplat ( IDS_VolumeName, szVolumeName ) ;
		    pInstance->SetDWORD ( IDS_MaximumComponentLength, dwMaxComponentLength ) ;
		    pInstance->SetWORD ( IDS_FileSystemFlags, dwFileSystemFlags & 0xffff ) ;
		    pInstance->SetDWORD ( IDS_FileSystemFlagsEx, dwFileSystemFlags ) ;

            CHString sSerial;
            sSerial.Format(L"%X", dwVolumeSerialNumber);

		    pInstance->SetCHString ( IDS_VolumeSerialNumber, sSerial ) ;
        }
        else
        {
		    pInstance->SetCharSplat ( IDS_Status, IDS_STATUS_Unknown ) ;
            pInstance->Setbool ( IDS_MediaLoaded, false ) ;
	    }
    }

    // If we couldn't read the VolumeInfo, size ain't gonna work either
    if ((t_Status) && (dwSpecReqProps & SPECIAL_PROPS_SIZE))
    {
		DWORD dwSectorsPerCluster ;
		DWORD dwBytesPerSector ;
		DWORD dwFreeClusters ;
		DWORD dwTotalClusters ;

		t_Status = GetDiskFreeSpace (

			TOBSTRT(t_Drive),
			&dwSectorsPerCluster,
			&dwBytesPerSector,
			&dwFreeClusters,
			&dwTotalClusters
		) ;

		if ( t_Status )
		{
			unsigned __int64 ui64TotalBytes = (DWORDLONG) dwBytesPerSector    *
									 (DWORDLONG) dwSectorsPerCluster *
									 (DWORDLONG) dwTotalClusters     ;

			pInstance->SetWBEMINT64 ( IDS_Size, ui64TotalBytes ) ;
		}
	}

    return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ProfileDrive
 *
 *  DESCRIPTION : Determines how fast a drive can be read, in Kilobytes/second.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : KBPS/sec read
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

DOUBLE CWin32CDROM :: ProfileDrive ( CHString &a_VolumeName )
{
    DOUBLE t_TransferRate = -1;

    // Need to find a file of adequate size for use in profiling:

    TCHAR       t_szVolumeString[100];

    W2A(a_VolumeName, t_szVolumeString, sizeof(t_szVolumeString));
    CHString t_TransferFile = GetTransferFile ( t_szVolumeString ) ;

    if ( ! t_TransferFile.IsEmpty () )
    {
	    TCHAR t_szTransferFile[MAX_PATH];

        W2A(t_TransferFile, t_szTransferFile, sizeof(t_szTransferFile));

	    CCdTest t_Cd ;

        if ( t_Cd.ProfileDrive ( t_szTransferFile ) )
        {
            t_TransferRate = t_Cd.GetTransferRate();
        }
    }

    return t_TransferRate ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::TestDriveIntegrity
 *
 *  DESCRIPTION : Confirms that data can be read from the drive reliably
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32CDROM::TestDriveIntegrity ( CHString &a_VolumeName, CHString &a_IntegrityFile )
{
    TCHAR       t_szVolumeString[100];

    W2A(a_VolumeName, t_szVolumeString, sizeof(t_szVolumeString));

    a_IntegrityFile = GetTransferFile ( t_szVolumeString ) ;

    if ( ! a_IntegrityFile.IsEmpty () )
    {
	    TCHAR t_szTransferFile[MAX_PATH];

        W2A(a_IntegrityFile, t_szTransferFile, sizeof(t_szTransferFile));

	    CCdTest t_Cd ;

        return t_Cd.TestDriveIntegrity(t_szTransferFile);
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::LoadDriveLetters
 *
 *  DESCRIPTION : Confirms that data can be read from the drive reliably
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

void CWin32CDROM::LoadDriveLetters(STRING2STRING &DriveArray)
{
    WCHAR wszDrives[_MAX_PATH] ;
    LPWSTR pPath;
    CHString sPath;

    if (GetLogicalDriveStrings(sizeof(wszDrives)/sizeof(WCHAR), wszDrives))
    {

        for ( WCHAR *pszDrive = wszDrives ;
              *pszDrive ;
              pszDrive += (wcslen(pszDrive)+2))
        {
            pszDrive[2] = 0;
            if ( GetDriveType ( pszDrive ) == DRIVE_CDROM )
            {
                pPath = sPath.GetBuffer(_MAX_PATH);
                if (QueryDosDevice( pszDrive, pPath, _MAX_PATH ) > 0)
                {
                    sPath.MakeUpper();
                    DriveArray[sPath] = pszDrive;
                }
            }
        }
    }

    CHString sDriveName;
    CRegistry RegInfo;

    // Drives don't get added to this key until they have been mucked with in disk administrator.
    // However, since they can't be without a drive letter unless they've been to disk administrator...
    if (RegInfo.Open(HKEY_LOCAL_MACHINE, L"SYSTEM\\Disk", KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS) == ERROR_SUCCESS)
    {
        STRING2STRING::iterator      mapIter;

        WCHAR *pPropertyName;
        BYTE *pPropertyValue;

        for (DWORD x=0;
             RegInfo.EnumerateAndGetValues(x, pPropertyName, pPropertyValue) == ERROR_SUCCESS;
             x++)
        {
            try
            {
                if ( (wcscmp((LPCWSTR)pPropertyValue, L"%:") == 0) &&
                    (_wcsnicmp(pPropertyName, L"\\device\\cdrom", 13) == 0) )
                {
                    sPath = pPropertyName;
                    sPath.MakeUpper();

                    DriveArray[sPath] = L"";
                }
            }
            catch ( ... )
            {
                delete [] pPropertyName;
                delete [] pPropertyValue;
                throw;
            }

            delete [] pPropertyName;
            delete [] pPropertyValue;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cimdatafile.h ===
//=================================================================

//

// CIMDataFile.h -- CIMDataFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_CIMDATAFILE L"CIM_DataFile"


class CCIMDataFile;

class CCIMDataFile : public CImplement_LogicalFile
{

    public:

        // Constructor/destructor
        //=======================

        CCIMDataFile(const CHString& name, LPCWSTR pszNamespace);
       ~CCIMDataFile() ;

    protected:

        // Overridable function inherrited from CImplement_LogicalFile
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);
#endif

        // Overridable function inherrited from CProvider
        virtual void GetExtendedProperties(CInstance* pInstance, long lFlags = 0L);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cdrom.h ===
//=================================================================

//

// Cdrom.h -- Cdrom property set provider

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:  
//
//=================================================================
#ifndef _CDROM_H
#define _CDROM_H

// Property set identification
//============================
#if NTONLY >= 5
#else
	typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (LPCTSTR lpDirectoryName,
													  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
													  PULARGE_INTEGER lpTotalNumberOfBytes,
													  PULARGE_INTEGER lpTotalNumberOfFreeBytes) ;

    typedef std::map<CHString, CHString> STRING2STRING;

#endif	

#define PROPSET_NAME_CDROM				L"Win32_CDROMDrive"

#define METHOD_NAME_PROFILEDRIVE		L"ProfileDrive"
#define METHOD_NAME_TESTDRIVEINTEGRITY	L"TestDriveIntegrity"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_TEST_INTEGRITY        0x00000001
#define SPECIAL_PROPS_TEST_TRANSFERRATE     0x00000002
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_SCSITARGETID			0x00000800
#define SPECIAL_PROPS_DRIVE					0x00001000
#define SPECIAL_PROPS_ID					0x00002000
#define SPECIAL_PROPS_CAPABILITY			0x00004000
#define SPECIAL_PROPS_MEDIATYPE				0x00008000
#define SPECIAL_PROPS_VOLUMENAME			0x00010000
#define SPECIAL_PROPS_MAXCOMPONENTLENGTH	0x00020000
#define SPECIAL_PROPS_FILESYSTEMFLAGS		0x00040000
#define SPECIAL_PROPS_SERIALNUMBER			0x00080000
#define SPECIAL_PROPS_SIZE					0x00100000
#define SPECIAL_PROPS_MEDIALOADED			0x00200000
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000
#define SPECIAL_PROPS_SCSILUN				0x04000000
#define SPECIAL_PROPS_SCSIBUS				0x08000000
#define SPECIAL_PROPS_SCSIPORT				0x10000000
#define SPECIAL_PROPS_FILESYSTEMFLAGSEX		0x20000000
#define SPECIAL_PROPS_MFRREVISIONLEVEL		0x40000000

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_MEDIA				( SPECIAL_PROPS_TEST_INTEGRITY | \
									SPECIAL_PROPS_TEST_TRANSFERRATE | \
									SPECIAL_SCSIINFO | \
									SPECIAL_PROPS_DRIVE | \
									SPECIAL_PROPS_ID | \
									SPECIAL_PROPS_CAPABILITY | \
									SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
                                    SPECIAL_PROPS_FILESYSTEMFLAGSEX |  \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )

#define SPECIAL_SCSIINFO			( SPECIAL_PROPS_SCSITARGETID | \
									SPECIAL_PROPS_SCSIBUS | \
									SPECIAL_PROPS_SCSILUN | \
									SPECIAL_PROPS_SCSIPORT )

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_VOLUMEINFORMATION	( SPECIAL_PROPS_TEST_INTEGRITY | \
									SPECIAL_PROPS_TEST_TRANSFERRATE | \
									SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
                                    SPECIAL_PROPS_FILESYSTEMFLAGSEX | \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )
	

#define SPECIAL_VOLUMESPACE			( SPECIAL_PROPS_SIZE )
	
class CWin32CDROM : public Provider
{

	private:

        // Utility function(s)
        //====================
	#if ( defined(WIN9XONLY) || NTONLY == 4 )	
		
        CHPtrArray m_ptrProperties;

        HRESULT Enumerate (MethodContext *pMethodContext,  DWORD dwRequiredProperties);
		#ifdef WIN9XONLY
			HRESULT LoadPropertyValuesWin95(
	            CInstance *pInstance,
	            CConfigMgrDevice *a_pDevice , 
                DWORD dwSpecReqProps);
		#endif
    
		#if NTONLY == 4	
			HRESULT LoadPropertyValuesNT(
	            CInstance *pInstance,
	            LPCWSTR pszDeviceID , 
	            LPCWSTR pszDriveSpec , 
                DWORD dwSpecReqProps);

        void LoadDriveLetters(STRING2STRING &DriveArray);
		#endif
	#endif
	
	protected:
		
		// ExecMethod methods
		//===================
		DOUBLE ProfileDrive ( CHString &a_VolumeName ) ;
		BOOL TestDriveIntegrity ( CHString &a_VolumeName, CHString &a_IntegrityFile ) ;

	#if NTONLY >= 5	
		CRITICAL_SECTION m_CriticalSection ;


        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			DWORD a_SpecifiedPropertied 
		) ;

        DWORD CWin32CDROM::GetBitMask(CFrameworkQuery &a_Query);

	#endif

	public:

        // Constructor/destructor
        //=======================

        CWin32CDROM ( LPCWSTR a_pszName, LPCWSTR a_pszNamespace ) ;
       ~CWin32CDROM () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
            CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

        HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cimlogicaldevice_cimdatafile.h ===
//=================================================================

//

// CIMLogicalDevice_CIMDataFile.h -- cim_logicaldevice to CIM_DataFile

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/20/98    a-kevhu         Created
//
// Comment: Relationship between logical device and datafile
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_DEVICEDATAFILE L"Win32_CIMLogicalDeviceCIMDataFile"

class CCIMDeviceCIMDF;
class CNT5DevDrvMap;
class CSubDirList;
VOID OutputDebugInfo(CHString chstr);
VOID WBEMizePathName(CHString& chstrNormalPathname,
                     CHString& chstrWBEMizedPathname);


class CCIMDeviceCIMDF : virtual public CWin32PNPEntity {

    public:

        // Constructor/destructor
        //=======================

        CCIMDeviceCIMDF(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CCIMDeviceCIMDF() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long Flags = 0L);

    protected:
        // Functions inherrited from CWin32PNPDevice:
        virtual HRESULT LoadPropertyValues(void* pv);
        virtual bool ShouldBaseCommit(void* pvData);

    private:
        VOID SetPurposeDescription(CInstance *pInstance, const CHString& a_chstrFileName);

#ifdef NTONLY
        BOOL GenerateDriverFileListNT4(std::vector<CHString*>& vecpchsDriverFileList, 
                                       CHString& chstrPNPDeviceID,
                                       BOOL fGetAssociatedDevicesDrivers);

        BOOL GenerateDriverFileListNT5(std::vector<CHString*>& vecpchsDriverFileList, 
                                       CHString& chstrPNPDeviceID,
                                       std::vector<CNT5DevDrvMap*>& vecpNT5DDM,
                                       BOOL fGetAssociatedDevicesDrivers);

        VOID GenerateNT5DeviceDriverMappings(std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        VOID GenerateNT5ServiceDriverMap(const CHString& chstrDevSvcName,
                                         std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        VOID CleanPNT5DevDrvMapVector(std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        BOOL AlreadyInDeviceTable(CHString& chstrPNPDeviceID,
                                  std::vector<CNT5DevDrvMap*>& vecpNT5DDM);

        VOID AddDriver(CHString& chstrPNPDeviceID, 
                       CHString& chstrDriverPathName,
                       std::vector<CNT5DevDrvMap*>& vecpNT5DDM);
		
#endif
#ifdef WIN9XONLY
        BOOL GenerateDriverFileListW98(CSubDirList& sdl,
                                       std::vector<CHString*>& vecpchsDriverFileList, 
                                       CHString& chstrPNPDeviceID,
                                       BOOL fGetAssociatedDevicesDrivers);
        VOID ProcessDeviceVxDsFilesToList(CHString& chstrDeviceVxDsValue, 
                                    std::vector<CHString*>& vecpchsDriverFileList);
        VOID CreateVmm32vxdFileList(std::vector<CHString*>& vecpchsVmm32vxdFileList);
        VOID ProcessDevLoaderFilesToList(CSubDirList& sdl,
                                         CHString& chstrDevLoaderValue, 
                                         std::vector<CHString*>& vecpchsDriverFileList);
#endif
        bool ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH);
        bool DeviceExists(const CHString& chstrDevice,
                          CConfigMgrDevice** ppDevice);
        HRESULT CreateAssociations(MethodContext* pMethodContext, 
                                   std::vector<CHString*>& vecpchsDriverFileLise, 
                                   CHString& chstrDevicePath,
                                   DWORD dwReqProps);

        VOID CleanPCHSTRVector(std::vector<CHString*>& vecpchsDriverFileList);
        BOOL AlreadyAddedToList(std::vector<CHString*>& vecchsList, CHString& chsItem);

        // Keep the enum a private member of this class to prevent any scope conflicts
        enum Purpose
        {
            Unknown, 
            Other, 
            Driver, 
            Configuration_Software, 
            Application_Software, 
            Instrumentation, 
            Firmware
        };
};

// This derived class commits here, not in the base.
inline bool CCIMDeviceCIMDF::ShouldBaseCommit(void* pvData) { return false; }



#ifdef NTONLY
class CNT5DevDrvMap
{
    public:
        CNT5DevDrvMap() {}

        ~CNT5DevDrvMap()
        {
            for(LONG m = 0L; m < m_vecpchstrDrivers.size(); m++)
            {
                delete m_vecpchstrDrivers[m];
            }
        }

        VOID AddDriver(CHString& chstrDriver)
        {
            if(!AlreadyAddedToList(m_vecpchstrDrivers, chstrDriver))
            {
                CHString* pchstrTemp = new CHString;
                if(pchstrTemp != NULL)
                {
                    try
                    {
                        *pchstrTemp = chstrDriver;
                        m_vecpchstrDrivers.push_back(pchstrTemp);
                    }
                    catch ( ... )
                    {
                        delete pchstrTemp;
                        throw;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }

        BOOL AlreadyAddedToList(std::vector<CHString*>& vecchsList, 
                                   CHString& chsItem)
        {
            for(LONG m = 0; m < vecchsList.size(); m++)
            {
                if(vecchsList[m]->CompareNoCase(chsItem) == 0)
                {
                    return TRUE;
                }
            }
            return FALSE;
        }

        CHString m_chstrDevicePNPID;
        std::vector<CHString*> m_vecpchstrDrivers;
    private:
};
#endif


class CSubDirList
{
    public:
        CSubDirList(MethodContext* pMethodContext, CHString& chstrParentDir) 
        {
            CHString chstrWbemizedParentDir;
            m_chstrRawParentDir = chstrParentDir;
            WBEMizePathName(chstrParentDir, chstrWbemizedParentDir);
            m_pMethodContext = pMethodContext;
            m_chstrParentDir = chstrWbemizedParentDir + _T("\\\\");
            m_chstrParentDrive = m_chstrParentDir.Left(2);
            m_chstrParentPath = m_chstrParentDir.Mid(2);

            CHString chstrQuery;
            chstrQuery.Format(L"SELECT name FROM Win32_Directory WHERE drive = \"%s\" and path = \"%s\"", m_chstrParentDrive, m_chstrParentPath);
            m_hrQuery = CWbemProviderGlue::GetInstancesByQuery(chstrQuery, &m_lSubDirs, pMethodContext, IDS_CimWin32Namespace);   
        }
        
        ~CSubDirList() {}
         
        HRESULT FindFileInDirList(CHString& chstrFileNameIn, CHString& chstrFullPathNameOut)
        {
            HRESULT hr = WBEM_S_NO_ERROR;
            if(FAILED(m_hrQuery))
            {
                hr = m_hrQuery;
            }
            else
            {
                CHString chstrFileNameInCopy = chstrFileNameIn;
                chstrFileNameInCopy.MakeUpper();
                BOOL fRet = FALSE;
                LPTSTR lptstrFilePart = NULL;
                TCHAR tstrPathName[_MAX_PATH];
                ZeroMemory(tstrPathName,sizeof(tstrPathName));
                {
                    // First look for it in the directory itself, then in its sub-directories:
                    if(SearchPath(TOBSTRT(m_chstrRawParentDir), TOBSTRT(chstrFileNameInCopy), NULL, _MAX_PATH, tstrPathName, &lptstrFilePart) != 0)
                    {
                        chstrFullPathNameOut = _tcsupr(tstrPathName);
                        fRet = true;
                    }
                    if(!fRet)
                    {
                        REFPTRCOLLECTION_POSITION pos;
                        CInstancePtr pDir;
                        if(m_lSubDirs.BeginEnum(pos)) 
                        {
                            while(pDir.Attach(m_lSubDirs.GetNext(pos), false), (pDir != NULL) && !fRet)
                            {
                                CHString chstrPath;
                                pDir->GetCHString(IDS_Name, chstrPath);
                                chstrPath.MakeUpper();
                                // Only interested in this path if it is on the correct dirve:
                                CHString chstrTempDrive = chstrPath.Left(2);
                                if(chstrTempDrive.CompareNoCase(m_chstrParentDrive) == 0)
                                {
                                    if(SearchPath(TOBSTRT(chstrPath), TOBSTRT(chstrFileNameIn), NULL, _MAX_PATH, tstrPathName, &lptstrFilePart) != 0)
                                    {
                                        chstrFullPathNameOut = _tcsupr(tstrPathName);
                                        fRet = true;
                                    }
                                }
                            }
                            m_lSubDirs.EndEnum();   
                        }
                    }
                }
            }
            return hr;
        }

        LONG GetCount()
        {
            return m_lSubDirs.GetSize();
        }

    private:
        TRefPointerCollection<CInstance> m_lSubDirs;
        CHString m_chstrParentDir;
        CHString m_chstrParentDrive;
        CHString m_chstrParentPath;
        CHString m_chstrRawParentDir;
        MethodContext* m_pMethodContext;
        HRESULT m_hrQuery;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cimdatafile.cpp ===
//=================================================================

//

// CIMDataFile.CPP -- CIMDataFile property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "CIMDataFile.h"
// Property set declaration
//=========================

CCIMDataFile MyCIMDataFileSet(PROPSET_NAME_CIMDATAFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::CCIMDataFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMDataFile :: CCIMDataFile (

	const CHString &setName,
	LPCWSTR pszNamespace

) : CImplement_LogicalFile ( setName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::~CCIMDataFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMDataFile :: ~CCIMDataFile ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::IsOneOfMe
 *
 *  DESCRIPTION : The guts of this class, actually.  IsOneOfMe is inherrited
 *                from CIM_LogicalFile.  That class returns files or
 *                directories where this one should only return directories,
 *                in response to queries, getobject commands, etc.  It is
 *                overridden here to return TRUE only if the file (the
 *                information for which is contained in the function arguement
 *                pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CCIMDataFile :: IsOneOfMe (

	LPWIN32_FIND_DATAW pstFindData,
    const WCHAR *wstrFullPathName
)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.

    if ( pstFindData == NULL )
    {
        return FALSE ;
    }
    else
    {
        return ( ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE ) ;
    }
}
#endif

#ifdef WIN9XONLY
BOOL CCIMDataFile::IsOneOfMe (

	LPWIN32_FIND_DATAA pstFindData,
    const char *strFullPathName
)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if ( pstFindData == NULL )
    {
        return FALSE ;
    }
    else
    {
        return ( ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE ) ;
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::GetExtendedProperties
 *
 *  DESCRIPTION : Sets properties unique to this provider (not common to all
 *                CIM_LogicalFile derived classes).
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/

 void CCIMDataFile :: GetExtendedProperties(CInstance *pInstance,
                                            long lFlags)
{
    // First, get the name of the file (we should have it by now):

    CHString chstrFileName;
    if(pInstance->GetCHString(IDS_Name, chstrFileName))
    {
        CHString chstrVerStrBuf ;

        // First get the version number string, if required...
        if(lFlags & PROP_VERSION || lFlags & PROP_MANUFACTURER)
        {
            LPVOID pInfo = NULL;
            try
            {
                if(GetFileInfoBlock(TOBSTRT(chstrFileName), &pInfo) && (pInfo != NULL))
                {
                    if(lFlags & PROP_VERSION)
                    {
			            bool t_Status = GetVarFromInfoBlock(pInfo,                   // Name of file to get ver info about
                                                            _T("FileVersion"),       // String identifying resource of interest
                                                            chstrVerStrBuf);         // Buffer to hold version string


                        if(t_Status)
                        {
                            pInstance->SetCHString(IDS_Version, chstrVerStrBuf);
                        }
                    }

                    // Second, get the company name string, if required...

                    if(lFlags & PROP_MANUFACTURER)
                    {
                        bool t_Status = GetVarFromInfoBlock(pInfo,                   // Name of file to get ver info about
                                                            _T("CompanyName"),       // String identifying resource of interest
                                                            chstrVerStrBuf);         // Buffer to hold company name string


                        if(t_Status)
                        {
                            pInstance->SetCHString(IDS_Manufacturer, chstrVerStrBuf);
                        }
                    }
                }
            }
            catch(...)
            {
                if(pInfo != NULL)
                {
                    delete pInfo;
                    pInfo = NULL;
                }
                throw;
            }

            delete pInfo;
            pInfo = NULL;
        }

        // Set the FileSize property, if required...
        if(lFlags & PROP_FILESIZE)
        {
            WIN32_FIND_DATA stFindData;
            ZeroMemory(&stFindData, sizeof(stFindData));

            SmartFindClose hFind = FindFirstFile(TOBSTRT(chstrFileName), &stFindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
				__int64 LoDW = (__int64)(stFindData.nFileSizeLow);
				__int64 HiDW = (__int64)(stFindData.nFileSizeHigh);
				__int64 FileSize = (HiDW * MAXDWORD) + LoDW;

				CHString chstrSize;
				chstrSize.Format(L"%d", FileSize);
				pInstance->SetWBEMINT64(IDS_Filesize, chstrSize );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cimlogicaldevice_cimdatafile.cpp ===
//=================================================================

//

// CIMLogicalDevice_CIMDataFile.cpp -- cim_logicaldevice to CIM_DataFile

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/20/98    a-kevhu         Created
//
// Comment: Relationship between logical device and datafile
//
//=================================================================

#include "precomp.h"
#include <vector>
#include <cregcls.h>
#include <comdef.h>
#include "PNPEntity.h"
#include "LPVParams.h"
#include <io.h>

#ifdef TEST
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#endif

#include "CIMLogicalDevice_CIMDataFile.h"

// Property set declaration
//=========================

CCIMDeviceCIMDF MyDevBus(PROPSET_NAME_DEVICEDATAFILE, IDS_CimWin32Namespace);

//#define TEST
#ifdef TEST
LONG g_lDepth = 0L;
#endif





VOID OutputDebugInfo(CHString chstr)
{
#ifdef TEST
    FILE* fp;
    fp = fopen("d:\\temp\\cld-cdf.txt", "at");
    for(LONG n = 0L; n < g_lDepth; n++) fputs("    ",fp);
    fputs(chstr,fp);
    fputs("\n",fp);
    fclose(fp);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CCIMDeviceCIMDF
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMDeviceCIMDF::CCIMDeviceCIMDF(LPCWSTR setName, LPCWSTR pszNamespace)
    : CWin32PNPEntity(setName, pszNamespace),
      Provider(setName, pszNamespace) // required since we inherit virtually
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::~CCIMDeviceCIMDF
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMDeviceCIMDF::~CCIMDeviceCIMDF()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMDeviceCIMDF::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrDevice;
    CHString chstrDataFile;
    HRESULT hr = WBEM_E_NOT_FOUND;
    std::vector<CHString*> vecpchsDriverFileList;
    CHString chstrPNPDeviceID;
    CHString chstrFilePathName;
    BOOL fFoundDriverFiles = FALSE;


#ifdef NTONLY
    std::vector<CNT5DevDrvMap*> vecpNT5DDM;
#endif

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, chstrDevice);
    pInstance->GetCHString(IDS_Dependent, chstrDataFile);

    // See if the datafile instance exists (object name is valid and file actually exists).
    if(ObjNameValid(chstrDataFile,L"CIM_DataFile",L"Name",chstrFilePathName) && (_taccess(TOBSTRT(chstrFilePathName),0) != -1))
    {
        // Datafile exists.  Now check if device instance exists (object name valid and device actually exists)
        CConfigMgrDevicePtr pDevice(NULL);
        if(ObjNameValid(chstrDevice, L"Win32_PnPEntity", L"DeviceID", chstrPNPDeviceID) &&
           (DeviceExists(chstrPNPDeviceID, &pDevice)))
        {
            // So both ends exist.  Now need to Make sure the the device is really associated with the file.
            // First, get a file list for the device:
#ifdef NTONLY
            if(IsWinNT4())
            {
                fFoundDriverFiles = GenerateDriverFileListNT4(vecpchsDriverFileList,
                                                              chstrPNPDeviceID,
                                                              FALSE);
            }
            else if(IsWinNT5())
            {
                // If NT5, generate device/driver file mappings once
                //GenerateNT5DeviceDriverMappings(vecpNT5DDM);
                CHString chstrDevSvcName;
                if(pDevice->GetService(chstrDevSvcName))
                {
                    GenerateNT5ServiceDriverMap(chstrDevSvcName, vecpNT5DDM);

                    try
                    {
                        fFoundDriverFiles = GenerateDriverFileListNT5(vecpchsDriverFileList,
                                                                      chstrPNPDeviceID,
                                                                      vecpNT5DDM,
                                                                      FALSE);
                    }
                    catch ( ... )
                    {
#ifdef NTONLY
                        CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif
                        throw;
                    }

                }
            }
#endif
#ifdef WIN9XONLY
            {
                TCHAR tstrSystemDir[_MAX_PATH+1];
                ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
                GetSystemDirectory(tstrSystemDir,_MAX_PATH);
                MethodContext* pMethodContext = pInstance->GetMethodContext();
                // Need list of subdirs under system directory:
                CSubDirList sdl(pMethodContext, CHString(tstrSystemDir));
                fFoundDriverFiles = GenerateDriverFileListW98(sdl,
                                                              vecpchsDriverFileList,
                                                              chstrPNPDeviceID,
                                                              FALSE);
            }
#endif
        }

        try
        {
            // Second, see if the file is a member of the list:
            if(fFoundDriverFiles)
            {
                if(AlreadyAddedToList(vecpchsDriverFileList,chstrFilePathName))
                {
                    pInstance->SetWBEMINT16(IDS_Purpose, Driver);
					SetPurposeDescription(pInstance, chstrFilePathName);  // whether they need it or not since this is GetObject

                    // this means the file is associated with the device
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
        catch ( ... )
        {
            // Free pointers in the vector:
            CleanPCHSTRVector(vecpchsDriverFileList);
#ifdef NTONLY
            CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif
            throw ;
        }
    }
    // Free pointers in the vector:
    CleanPCHSTRVector(vecpchsDriverFileList);

#ifdef NTONLY
    CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif

    return hr;
}



// Enumeration for this class can utilize the base class's Enumeration routine.


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::ExecQuery
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *  RETURNS     :
 *
 *  COMMENTS    : Only optimizes based on specified antecedents, not dependents.
 *
 *****************************************************************************/
HRESULT CCIMDeviceCIMDF::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long Flags)
{
    // Get the name(s) of the specified dependents, if any.  If none, we will
    // enumerate.
    HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<_bstr_t> vecAnt;
    pQuery.GetValuesForProp(IDS_Antecedent, vecAnt);
    DWORD dwNumAnt = vecAnt.size();

    if(dwNumAnt > 0)
    {
        // We have one or more dependents (devices) specified.  Confirm that
        // each is a valid, existing instance, then load prop values.
        for(int i = 0; i < dwNumAnt; i++)
        {
            CHString chstrPNPDeviceID;
            CConfigMgrDevicePtr pDevice(NULL);

            if(ObjNameValid((LPCWSTR) (LPWSTR) vecAnt[i], L"Win32_PnPEntity", L"DeviceID", chstrPNPDeviceID) &&
               (DeviceExists(chstrPNPDeviceID, &pDevice)))
            {
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                if(SUCCEEDED(hr = LoadPropertyValues(&CLPVParams(pInstance , pDevice, -1L))))
				{
                    hr = pInstance->Commit();
				}
            }
        }
    }
    else
    {
        // We don't optimize on the specified query, so do an enum via the base
        hr = EnumerateInstances(pMethodContext, Flags);
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::LoadPropertyValues
 *
 *  DESCRIPTION :
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMDeviceCIMDF::LoadPropertyValues(void* pvData)
{
    CHString chstrPNPDeviceID;
    CHString chstrDevicePath;
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL fFoundDriverFiles = FALSE;
    BOOL bRecurse = TRUE;
    std::vector<CHString*> vecpchsDriverFileList;

    CLPVParams* pParams = (CLPVParams*)pvData;
    CInstance* pInstance = (CInstance*)(pParams->m_pInstance);  // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pParams->m_pDevice);
    DWORD dwReqProps = (DWORD)(pParams->m_dwReqProps);

    if(pDevice == NULL || pInstance == NULL) return hr;

    MethodContext* pMethodContext = pInstance->GetMethodContext();
    if(pMethodContext == NULL) return hr;

    // Don't even bother if on nt 3.51
#ifdef NTONLY
    std::vector<CNT5DevDrvMap*> vecpNT5DDM;

    if(GetPlatformMajorVersion() <= 3)   // i.e., we're on NT3 something or less
    {
        return hr;
    }

    // If NT5, generate device/driver file mappings once
    if(IsWinNT5())
    {
        // Call the version that gets a map just for that device's service
        CHString chstrDevSvcName;
        if(pDevice->GetService(chstrDevSvcName))
        {
            GenerateNT5ServiceDriverMap(chstrDevSvcName, vecpNT5DDM);
        }
        else
        {
            return hr;
        }
    }
#endif

     // The first step is to build up a list of driver files the device
     // and all of its children use.  How this is done is platform specific.

    pDevice->GetDeviceID(chstrPNPDeviceID);
    CHString chstrPNPDeviceIDAdj;
    EscapeBackslashes(chstrPNPDeviceID, chstrPNPDeviceIDAdj);
    chstrDevicePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                           (LPCWSTR)GetLocalComputerName(),
                           IDS_CimWin32Namespace,
                           PROPSET_NAME_PNPEntity,
                           IDS_DeviceID,
                           (LPCWSTR)chstrPNPDeviceIDAdj);

#ifdef NTONLY
    if(IsWinNT4())
    {
        fFoundDriverFiles = GenerateDriverFileListNT4(vecpchsDriverFileList,
                                                      chstrPNPDeviceID,
                                                      FALSE);

        // For each device (antecedent) we need to create an association
        // between it and its driver files (presuming we found some).
        if(fFoundDriverFiles)
        {
            hr = CreateAssociations(pMethodContext, vecpchsDriverFileList, chstrDevicePath, dwReqProps);
        }

        // Free pointers in the vector:
        CleanPCHSTRVector(vecpchsDriverFileList); // empty vector out for use next go round
        fFoundDriverFiles = FALSE;  // reset flag for next loop
    }
    else if(IsWinNT5())
    {
        fFoundDriverFiles = GenerateDriverFileListNT5(vecpchsDriverFileList,
                                                      chstrPNPDeviceID,
                                                      vecpNT5DDM,
                                                      FALSE);

        // For each device (antecedent) we need to create an association
        // between it and its driver files (presuming we found some).
        if(fFoundDriverFiles)
        {
            hr = CreateAssociations(pMethodContext, vecpchsDriverFileList, chstrDevicePath, dwReqProps);
        }

        // Free pointers in the vector:
        CleanPCHSTRVector(vecpchsDriverFileList); // empty vector out for use next go round
        fFoundDriverFiles = FALSE;  // reset flag for next loop
    }
#endif
#ifdef WIN9XONLY
    {
        TCHAR tstrSystemDir[_MAX_PATH+1];
        ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
        if(GetSystemDirectory(tstrSystemDir,_MAX_PATH))
        {
            // Need list of subdirs under system directory:
            CSubDirList sdl(pMethodContext, CHString(tstrSystemDir));
            // Get the id (to send to cfgmgr) and the path (to send back in 'Dependent')
            fFoundDriverFiles = GenerateDriverFileListW98(sdl,
                                                          vecpchsDriverFileList,
                                                          chstrPNPDeviceID,
                                                          FALSE);

            // For each device (antecedent) we need to create an association
            // between it and its driver files (presuming we found some).
            if(fFoundDriverFiles)
            {
                hr = CreateAssociations(pMethodContext, vecpchsDriverFileList, chstrDevicePath, dwReqProps);
            }

            // Free pointers in the vector:
            CleanPCHSTRVector(vecpchsDriverFileList); // empty vector out for use next go round
            fFoundDriverFiles = FALSE;  // reset flag for next loop
        }
    }
#endif

#ifdef NTONLY
    CleanPNT5DevDrvMapVector(vecpNT5DDM);
#endif
    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CreateAssociations
 *
 *  DESCRIPTION : Creates a list of drivers used by a particular device
 *
 *  INPUTS      : pMethodContext;
 *                vecpchsDriverFileList, a list of files to try to associate
 *                   to the device;
 *                chstrDevicePath, the __PATH of the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CCIMDeviceCIMDF::CreateAssociations(MethodContext* pMethodContext,
                               std::vector<CHString*>& vecpchsDriverFileList,
                               CHString& chstrDevicePath,
                               DWORD dwReqProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    for(LONG m = 0L; (m < vecpchsDriverFileList.size()) && (SUCCEEDED(hr)); m++)
    {
        // create the __PATH of the file instance:
        // Since the file pathname will be part of the wbem __PATH property,
        // it must contain double backslashes rather than single ones.
        // Hence the call to the following function.
        CHString chstrTweekedPathName;
        WBEMizePathName(*vecpchsDriverFileList[m],chstrTweekedPathName);
        CHString chstrDriverPath;
        chstrDriverPath = _T("\\\\") + GetLocalComputerName() + _T("\\") +
                          IDS_CimWin32Namespace + _T(":") + IDS_CIMDataFile +
                          _T(".") + IDS_Name + _T("=\"") +
                          chstrTweekedPathName + _T("\"");

        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            // Need to find an instance of the file
            pInstance->SetCHString(IDS_Antecedent, chstrDevicePath);
            pInstance->SetCHString(IDS_Dependent, chstrDriverPath);
            pInstance->SetWBEMINT16(IDS_Purpose, Driver);
			if(dwReqProps & PNP_PROP_PurposeDescription)
            {
                SetPurposeDescription(pInstance, *vecpchsDriverFileList[m]);
            }
            hr = pInstance->Commit();
        }
    }

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GenerateDriverFileList
 *
 *  DESCRIPTION : Creates a list of drivers used by a particular device
 *
 *  INPUTS      : vecpchsDriverFileList, an stl array of CHString pointers
 *                (or, in the NT5 case, a pointer to such an array);
 *                chstrPNPDeviceID, a CHString containing the PNPDeviceID
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : void
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL CCIMDeviceCIMDF::GenerateDriverFileListNT4(
                             std::vector<CHString*>& vecpchsDriverFileList,
                             CHString& chstrPNPDeviceID,
                             BOOL fGetAssociatedDevicesDrivers)
{
    CConfigManager	cfgManager;
//    CDeviceCollection	deviceList;
    CConfigMgrDevicePtr pDevice(NULL);

    // Find the device
    if(cfgManager.LocateDevice(chstrPNPDeviceID, &pDevice))
    {
        // The first order of business is to get the driver files associated
        // with this device.  Later we'll add to the list by getting driver
        // files its children use (presuming they are not already in the list).

        // In NT4, the registry key HKLM\\System\\CurrentControlSet\\Enum
        // contains subkeys that are the PNPDeviceID's returned from the query
        // (passed into this function as chstrPNPDeviceID).

        // Those subkeys have an entry "Service", the value of which is the name
        // of a subkey under HKLM\\System\\CurrentControlSet\\Services.  That
        // subkey may have an entry called ImagePath, which contains the name
        // of the driver file in the <SystemRoot>\\System32\\Drivers subdirectory.
        // If ImagePath is missing, the name of the subkey itself matches the
        // filename (minus any path and extension) of the driver file (which will
        // have a .sys extension and be in the <SystemRoot>\\System32\\Drivers
        // subdirectory).

        CRegistry reg;
        CHString chstrSubKey = IDS_NT_CurCtlSetEnum + chstrPNPDeviceID;
        if(reg.Open(HKEY_LOCAL_MACHINE,chstrSubKey,KEY_READ) == ERROR_SUCCESS)
        {
            CHString chstrServiceValue;
            // Get the "Service" entry's value:
            if(reg.GetCurrentKeyValue(IDS_Service, chstrServiceValue) == ERROR_SUCCESS)
            {
                reg.Close();
                chstrSubKey = IDS_NT_CurCtlSetSvcs + chstrServiceValue;
                if(reg.Open(HKEY_LOCAL_MACHINE,chstrSubKey,KEY_READ) == ERROR_SUCCESS)
                {
                    CHString chstrImagePathValue;
                    TCHAR tstrSystemDir[_MAX_PATH+1];
                    ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
                    GetSystemDirectory(tstrSystemDir,_MAX_PATH);
                    CHString chstrPathName = tstrSystemDir;
                    // Now need to check for an ImagePath entry:
                    if(reg.GetCurrentKeyValue(IDS_ImagePath, chstrImagePathValue) == ERROR_SUCCESS)
                    {
                        if(chstrImagePathValue.GetLength() > 0)
                        {
                            // This value contains some of the path, plus the driver
                            // filename and extension.  We only want the latter two
                            // components.
                            int lLastBackSlash = -1;
                            lLastBackSlash = chstrImagePathValue.ReverseFind(_T('\\'));
                            if(lLastBackSlash != -1)
                            {
                                chstrImagePathValue = chstrImagePathValue.Right(
                                                       chstrImagePathValue.GetLength()
                                                       - lLastBackSlash - 1);
                            }
                        }
                    }
                    else // In this case, the key itself is the name of the driver
                    {    // Assume a .sys extension.
                        chstrImagePathValue = chstrServiceValue + IDS_Extension_sys;
                    }
                    // Now build the full pathname:
                    chstrPathName = chstrPathName + _T("\\") + IDS_DriversSubdir
                                      + _T("\\") + chstrImagePathValue;

                    // Now that we finally have a driver file, need to add it to
                    // the list of driver files we are building.  However, don't
                    // add it if it is already in the list:
                    if(!AlreadyAddedToList(vecpchsDriverFileList, chstrPathName))
                    {
                        CHString* pchstrTemp = NULL;
                        pchstrTemp = (CHString*) new CHString();
                        if(pchstrTemp != NULL)
                        {
                            try
                            {
                                *pchstrTemp = chstrPathName;
                                vecpchsDriverFileList.push_back(pchstrTemp);
                            }
                            catch ( ... )
                            {
                                delete pchstrTemp;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                        // Note: the pointer allocated here gets freed up in
                        // the call to CleanPCHSTRVector made by the function
                        // that called this one.
                    }
                }
            }
        }
    }


    if(fGetAssociatedDevicesDrivers && pDevice != NULL)
    {
        // OkelyDokeleyDoodeley! We did that one just fine, now the second order of
        // business is to do all the kids! And their kids! And so on!
        CConfigMgrDevicePtr pDeviceChild(NULL);

        if(pDevice->GetChild(&pDeviceChild))
        {
            // Do this child first:
            // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                GenerateDriverFileListNT4(vecpchsDriverFileList,
                                          chstrChildPNPDeviceID,
                                          fGetAssociatedDevicesDrivers);

                // Now call its brothers and sisters until none left (GetSibling
                // call will return FALSE):
                CConfigMgrDevicePtr pDeviceSibling(NULL);
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext(NULL);
                    CHString chstrSiblingPNPDeviceID;
                    BOOL fContinue = TRUE;
                    while(fContinue)
                    {
                        // Do the sibling now:
                        // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            GenerateDriverFileListNT4(vecpchsDriverFileList,
                                                      chstrSiblingPNPDeviceID,
                                                      fGetAssociatedDevicesDrivers);
                        }
                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling.Attach(pDeviceSiblingNext);
                    }
                }
            }
        }
    }

    return( (vecpchsDriverFileList.size() > 0) ? TRUE : FALSE );
}
#endif




#ifdef NTONLY
BOOL CCIMDeviceCIMDF::GenerateDriverFileListNT5(
                             std::vector<CHString*>& vecpchsDriverFileList,
                             CHString& chstrPNPDeviceID,
                             std::vector<CNT5DevDrvMap*>& vecpNT5DDM,
                             BOOL fGetAssociatedDevicesDrivers)
{
    // Due to the marvelous fact that we have a table of devices
    // and their associated drivers already (if this is running
    // on NT5) courtesy of the function GenerateNT5DeviceDriverMappings,
    // run upon this class's construction, the work here is minimal.

    // We just need to get the drivers for the given PNPDeviceID and
    // return them in a vector.

    CConfigManager	cfgManager;
//    CDeviceCollection	deviceList;
    CConfigMgrDevicePtr pDevice(NULL);

    // Find the device
    if(cfgManager.LocateDevice(chstrPNPDeviceID, &pDevice))
    {
        // Go through the table looking for the PNPDeviceID:
        for(LONG k = 0L; k < vecpNT5DDM.size(); k++)
        {
            if((vecpNT5DDM[k]->m_chstrDevicePNPID).CompareNoCase(chstrPNPDeviceID) == 0)
            {
                // Add each of the device's driver files to the outgoing vector
                for(LONG m = 0L; m < (vecpNT5DDM[k]->m_vecpchstrDrivers).size(); m++)
                {
                    if(!AlreadyAddedToList(vecpchsDriverFileList,
                                           *(vecpNT5DDM[k]->m_vecpchstrDrivers[m])))
                    {
                        CHString* pchstrTemp = NULL;
                        pchstrTemp = (CHString*) new CHString();
                        if(pchstrTemp != NULL)
                        {
                            try
                            {
                                *pchstrTemp = *(vecpNT5DDM[k]->m_vecpchstrDrivers[m]);
                                vecpchsDriverFileList.push_back(pchstrTemp);
                            }
                            catch ( ... )
                            {
                                delete pchstrTemp;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                }
                break; // each device is in the table only once, so no need to continue
            }
        }
    }

    if(fGetAssociatedDevicesDrivers && pDevice != NULL)
    {
        // OkelyDokeleyDoodeley! We did that one just fine, now the second order of
        // business is to do all the kids! And their kids! And so on!
        CConfigMgrDevicePtr pDeviceChild(NULL);

        if(pDevice->GetChild(&pDeviceChild))
        {
            // Do this child first:
            // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
                GenerateDriverFileListNT5(vecpchsDriverFileList,
                                          chstrChildPNPDeviceID,
                                          vecpNT5DDM,
                                          fGetAssociatedDevicesDrivers);

                // Now call its brothers and sisters until none left (GetSibling
                // call will return FALSE):
                CConfigMgrDevicePtr pDeviceSibling(NULL);
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext(NULL);
                    CHString chstrSiblingPNPDeviceID;
                    BOOL fContinue = TRUE;
                    while(fContinue)
                    {
                        // Do the sibling now:
                        // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
                            GenerateDriverFileListNT5(vecpchsDriverFileList,
                                                      chstrSiblingPNPDeviceID,
                                                      vecpNT5DDM,
                                                      fGetAssociatedDevicesDrivers);
                        }

                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        pDeviceSibling.Attach(pDeviceSiblingNext);
                    }
                }
            }
        }
    }

    return( (vecpchsDriverFileList.size() > 0) ? TRUE : FALSE );
}
#endif



#ifdef WIN9XONLY
BOOL CCIMDeviceCIMDF::GenerateDriverFileListW98(
                             CSubDirList& sdl,
                             std::vector<CHString*>& vecpchsDriverFileList,
                             CHString& chstrPNPDeviceID,
                             BOOL fGetAssociatedDevicesDrivers)
{
    CConfigManager	cfgManager;
//    CDeviceCollection	deviceList;
    CConfigMgrDevicePtr pDevice(NULL);

    // Find the device
    if(cfgManager.LocateDevice(chstrPNPDeviceID, &pDevice))
    {
        // The first order of business is to get the driver files associated
        // with this device.  Later we'll add to the list by getting driver
        // files its children use (presuming they are not already in the list).

        // In Windows 98, calling GetDriver on a device yields something like
        // "Net\\0003", which is a registry key under
        // HKLM\\System\\CurrentControlSet\\Services\\Class.  This key contains
        // two values of interest: DeviceVxDs and DevLoader.  These values may
        // or may not be present, and may or may not contain entries.  The
        // entries can consist of one or more files separated by commas if
        // they are present.
        //
        // The entries for DeviceVxDs are a full filename.
        // This file exists only if it is not one of the files listed under
        // the registry key HKLM\\System\\CurrentControlSet\\Control\\Vmm32Files,
        // the registry key listing virtual device drivers handled by vmm32.vxd
        // instead.
        //
        // The entries for DevLoader are just the filename (no extension), and
        // may have a leading asterisk.  They are the filenames for files
        // with .vxd extensions in the windows\\system directory.  These files
        // similarly exist only if they are not listed under the registry key
        // for vmm32.vxd.

        // So, first we need to get the \\Class registry key:
        CRegistry reg;
        CHString chstrCfgMgrDriver;
        if(pDevice->GetDriver(chstrCfgMgrDriver))
        {
#ifdef TEST
            OutputDebugInfo(chstrCfgMgrDriver);
#endif
            CHString chstrSubKey = IDS_98_CurCtlSetSvcCls + chstrCfgMgrDriver;
            if(reg.Open(HKEY_LOCAL_MACHINE,chstrSubKey,KEY_READ) == ERROR_SUCCESS)
            {
                CHString chstrDevLoaderValue;
                // Get the "DevLoader" entry's value:
                if(reg.GetCurrentKeyValue(IDS_DevLoader, chstrDevLoaderValue) == ERROR_SUCCESS)
                {
                    // Parse out the filenames and add them to the list if
                    // they aren't handled by vmm32.vxd instead.
                    ProcessDevLoaderFilesToList(sdl, chstrDevLoaderValue, vecpchsDriverFileList);
                }
                // Now get the DeviceVxDs entry's value:
                if(reg.GetCurrentKeyValue(IDS_DeviceVxDs, chstrDevLoaderValue) == ERROR_SUCCESS)
                {
                    // Parse out the filenames and add them to the list if
                    // they aren't handled by vmm32.vxd instead.
                    ProcessDeviceVxDsFilesToList(chstrDevLoaderValue, vecpchsDriverFileList);
                }
            }
        }
    }

    if(fGetAssociatedDevicesDrivers && pDevice != NULL)
    {

        // OkelyDokeleyDoodeley! We did that one just fine, now the second order of
        // business is to do all the kids! And their kids! And so on!
        CConfigMgrDevicePtr pDeviceChild(NULL);

        if(pDevice->GetChild(&pDeviceChild))
        {

#ifdef TEST
            g_lDepth++;
#endif
            // Do this child first:
            // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
            CHString chstrChildPNPDeviceID;
            if(pDeviceChild->GetDeviceID(chstrChildPNPDeviceID))
            {
#ifdef TEST
                OutputDebugInfo(CHString("Making recursive call to child"));
#endif

                GenerateDriverFileListW98(sdl,
                                          vecpchsDriverFileList,
                                          chstrChildPNPDeviceID,
                                          fGetAssociatedDevicesDrivers);

#ifdef TEST
                OutputDebugInfo(CHString("back from recursive call to child"));
#endif

                // Now call its brothers and sisters until none left (GetSibling
                // call will return FALSE):
                CConfigMgrDevicePtr pDeviceSibling(NULL);
                if(pDeviceChild->GetSibling(&pDeviceSibling))
                {
                    CConfigMgrDevicePtr pDeviceSiblingNext(NULL);
                    CHString chstrSiblingPNPDeviceID;
                    BOOL fContinue = TRUE;

                    while(fContinue)
                    {
                        // Do the sibling now:
                        // Need its PNPDeviceID (known to CnfgMgr as its DeviceID)
                        if(pDeviceSibling->GetDeviceID(chstrSiblingPNPDeviceID))
                        {
#ifdef TEST
                            OutputDebugInfo(CHString("Making recursive call to sibling"));
#endif

                            GenerateDriverFileListW98(sdl,
                                                      vecpchsDriverFileList,
                                                      chstrSiblingPNPDeviceID,
                                                      fGetAssociatedDevicesDrivers);

#ifdef TEST
                            OutputDebugInfo(CHString("back from recursive call to sibling"));
#endif
                        }

                        fContinue = pDeviceSibling->GetSibling(&pDeviceSiblingNext);

                        // Reassign pointers
                        pDeviceSibling = pDeviceSiblingNext;
                    }
                }
            }
#ifdef TEST
            g_lDepth--;
#endif
        }
    }  // end if(fGetAssociatedDevicesDrivers)

    return( (vecpchsDriverFileList.size() > 0) ? TRUE : FALSE );
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::ProcessDevLoaderFilesToList
 *
 *  DESCRIPTION : Internal helper to add files from the DevLoader entry to
 *                the list of driver files.
 *
 *  INPUTS      : chstrDevLoaderValue, the DevLoader registry entry;
 *                vecpchsDriverFileList, regerence to a CHString* stl vector
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : void
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
VOID CCIMDeviceCIMDF::ProcessDevLoaderFilesToList(CSubDirList& sdl,
                             CHString& chstrDevLoaderValue,
                             std::vector<CHString*>& vecpchsDriverFileList)
{
    // The entry we will process looks like this:
    // "*ndis,*ntkern,*ndis" (without the double quotes).  We need to
    // parse this list first.  Then remove the leading asterisk and tack on
    // ".vxd".  We then need to determine if the file is a member of the
    // vmm32.vxd set of files.  If not, we proceed.  We append the filename.ext
    // to the system directory.  Then, if that file is not already in our
    // list, we add it.  Finally, clean up our temporary list.

    std::vector<CHString*> vecDevLoaderList;
    CHString chstrSubString;
    CHString chstrRemainder;
    LONG lGetThisManyCharacters = 0L;
    std::vector<CHString*> vecpchsVmm32vxdFileList;

    // Parse the list
    chstrRemainder = chstrDevLoaderValue;
    for(;;)
    {
        chstrSubString = chstrRemainder.SpanExcluding(L",");
        lGetThisManyCharacters = chstrRemainder.GetLength() -
                                      chstrSubString.GetLength() - 1;

        if(!AlreadyAddedToList(vecDevLoaderList, chstrSubString))
        {
            CHString* pchstrTemp = NULL;
            pchstrTemp = (CHString*) new CHString;
            if(pchstrTemp != NULL)
            {
                try
                {
                    chstrSubString.MakeUpper();
                    *pchstrTemp = chstrSubString;
                    vecDevLoaderList.push_back(pchstrTemp);
                }
                catch ( ... )
                {
                    delete pchstrTemp;
                    throw ;
                }
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        if(lGetThisManyCharacters <= 0L)
        {
            break;
        }
        chstrRemainder = chstrRemainder.Right(lGetThisManyCharacters);
    }

    // Create a list of vmm32.vxd files if we haven't already
    if(vecpchsVmm32vxdFileList.size() == 0)
    {
        CreateVmm32vxdFileList(vecpchsVmm32vxdFileList);
    }

    // Remove leading asterisk if present; tack on ".vxd"
    TCHAR tstrSysDir[_MAX_PATH];
    ZeroMemory(tstrSysDir,sizeof(tstrSysDir));
    GetSystemDirectory(tstrSysDir,_MAX_PATH);
    for(LONG m = 0; m < vecDevLoaderList.size(); m++)
    {
        if(vecDevLoaderList[m]->GetAt(0) == _T('*'))
        {
            *(vecDevLoaderList[m]) = vecDevLoaderList[m]->Right(
                                       vecDevLoaderList[m]->GetLength() - 1);
        }
        // In some rare cases, the filename already has a .vxd extension,
		// so in those cases, don't append it again:
		if(vecDevLoaderList[m]->Find(L".VXD") == -1)
		{
		    *(vecDevLoaderList[m]) = *(vecDevLoaderList[m]) + _T(".VXD");
		}
        // Use addedtolist function to see if the file is handled
        // by vmm32.vxd instead:
        if(!AlreadyAddedToList(vecpchsVmm32vxdFileList, *(vecDevLoaderList[m])))
        {
            // This is a file we may want.
            // Rather than just assume that the file is in the system directory
            // as 99% of them are, we really need to find the file on the system,
            // then use its known directory, rather than just guessing...
            CHString chstrFullPathName;
            if(SUCCEEDED(sdl.FindFileInDirList(*(vecDevLoaderList[m]), chstrFullPathName)))
            {
                // See if that file is in our device driver file list; add it if not:
                if(!AlreadyAddedToList(vecpchsDriverFileList, chstrFullPathName))
                {
                    CHString* pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString;
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            chstrFullPathName.MakeUpper();
                            *pchstrTemp = chstrFullPathName;
                            vecpchsDriverFileList.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            throw ;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
            }
        }
        else
        {
            // The file is handled by vmm32.vxd.  We have to therefore make
            // sure that vmm32.vxd is in the list of files for the device.
            CHString chstrVmm32vxd = tstrSysDir;
            chstrVmm32vxd += _T("\\");
            chstrVmm32vxd += _T("VMM32.VXD");
            if(!AlreadyAddedToList(vecpchsDriverFileList, chstrVmm32vxd))
            {
                CHString* pchstrTemp = NULL;
                pchstrTemp = (CHString*) new CHString;
                if(pchstrTemp != NULL)
                {
                    try
                    {
                        chstrVmm32vxd.MakeUpper();
                        *pchstrTemp = chstrVmm32vxd;
                        vecpchsDriverFileList.push_back(pchstrTemp);
                    }
                    catch ( ... )
                    {
                        delete pchstrTemp;
                        throw ;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
    }

    // Clean up the DevLoader list:
    CleanPCHSTRVector(vecDevLoaderList);
    CleanPCHSTRVector(vecpchsVmm32vxdFileList);
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::ProcessDeviceVxDsFilesToList
 *
 *  DESCRIPTION : Internal helper to add files from the DeciveVxDs entry to
 *                the list of driver files.
 *
 *  INPUTS      : chstrDevLoaderValue, the DevLoader registry entry;
 *                vecpchsDriverFileList, regerence to a CHString* stl vector
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : void
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
VOID CCIMDeviceCIMDF::ProcessDeviceVxDsFilesToList(CHString& chstrDeviceVxDsValue,
                             std::vector<CHString*>& vecpchsDriverFileList)
{
    // The entry we will process looks like this:
    // "el90xnd3.sys, xxx.sys" (without the double quotes).
    // We then need to determine if the file is a member of the
    // vmm32.vxd set of files, if it has a vxd extension.
    // If not, we proceed.  We append the filename.ext
    // to the system directory.  Then, if that file is not already in our
    // list, we add it.  Finally, clean up our temporary list.

    std::vector<CHString*> vecDeviceVxDsList;
    CHString chstrSubString;
    CHString chstrRemainder;
    LONG lGetThisManyCharacters = 0L;
    std::vector<CHString*> vecpchsVmm32vxdFileList;

    // Parse the list
    chstrRemainder = chstrDeviceVxDsValue;
    for(;;)
    {
        chstrSubString = chstrRemainder.SpanExcluding(L",");
        lGetThisManyCharacters = chstrRemainder.GetLength() -
                                      chstrSubString.GetLength() - 1;

        if(!AlreadyAddedToList(vecDeviceVxDsList, chstrSubString))
        {
            CHString* pchstrTemp = NULL;
            pchstrTemp = (CHString*) new CHString;
            if(pchstrTemp != NULL)
            {
                try
                {
                    chstrSubString.MakeUpper();
                    *pchstrTemp = chstrSubString;
                    vecDeviceVxDsList.push_back(pchstrTemp);
                }
                catch ( ... )
                {
                    delete pchstrTemp;
                    throw ;
                }
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }
        if(lGetThisManyCharacters <= 0L)
        {
            break;
        }
        chstrRemainder = chstrRemainder.Right(lGetThisManyCharacters);
    }

    // Create a list of vmm32.vxd files if we haven't already
    if(vecpchsVmm32vxdFileList.size() == 0)
    {
        CreateVmm32vxdFileList(vecpchsVmm32vxdFileList);
    }

    // See if we should add it; do so if yes
    TCHAR tstrSysDir[_MAX_PATH];
    ZeroMemory(tstrSysDir,sizeof(tstrSysDir));
    GetSystemDirectory(tstrSysDir,_MAX_PATH);
    for(LONG m = 0; m < vecDeviceVxDsList.size(); m++)
    {
        // Use addedtolist function to see if the file is handled
        // by vmm32.vxd instead:
        if(!AlreadyAddedToList(vecpchsVmm32vxdFileList, *(vecDeviceVxDsList[m])))
        {
            // This is a file we may want.  Append it to the system directory:
            CHString chstrFullPathName = tstrSysDir;
            chstrFullPathName += _T("\\");
            chstrFullPathName += *(vecDeviceVxDsList[m]);

            // See if that file is in our device driver file list; add it if not:
            if(!AlreadyAddedToList(vecpchsDriverFileList, chstrFullPathName))
            {
                CHString* pchstrTemp = NULL;
                pchstrTemp = (CHString*) new CHString;
                if(pchstrTemp != NULL)
                {
                    try
                    {
                        chstrFullPathName.MakeUpper();
                        *pchstrTemp = chstrFullPathName;
                        vecpchsDriverFileList.push_back(pchstrTemp);
                    }
                    catch ( ... )
                    {
                        delete pchstrTemp;
                        throw;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
        else
        {
            // The file is handled by vmm32.vxd.  We have to therefore make
            // sure that vmm32.vxd is in the list of files for the device.
            CHString chstrVmm32vxd = tstrSysDir;
            chstrVmm32vxd += _T("\\");
            chstrVmm32vxd += _T("VMM32.VXD");
            if (!AlreadyAddedToList(vecpchsDriverFileList, chstrVmm32vxd))
            {
                CHString* pchstrTemp = NULL;
                pchstrTemp = (CHString*) new CHString;
                if (pchstrTemp != NULL)
                {
                    try
                    {
                        chstrVmm32vxd.MakeUpper();
                        *pchstrTemp = chstrVmm32vxd;
                        vecpchsDriverFileList.push_back(pchstrTemp);
                    }
                    catch ( ... )
                    {
                        delete pchstrTemp;
                        throw;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
        }
    }

    // Clean up the DeviceVxDs list:
    CleanPCHSTRVector(vecDeviceVxDsList);
    CleanPCHSTRVector(vecpchsVmm32vxdFileList);
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CreateVmm32vxdFileList
 *
 *  DESCRIPTION : Internal helper to generate a list of the files listed under
 *                the HKLM\\System\\CurrentControlSet\\Control\\VMM32Files
 *                registry key.
 *
 *  INPUTS      : vector of CHString pointers
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : void
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
VOID CCIMDeviceCIMDF::CreateVmm32vxdFileList(std::vector<CHString*>& vecpchsVmm32vxdFileList)
{
    // The registry key HKLM\\System\\CurrentControlSet\\Control\\VMM32Files
    // contains values, the value name of which is a file that vmm32.vxd
    // handles instead.  We need to populate an array of CHString pointers
    // to these names.
    if(vecpchsVmm32vxdFileList.size() == 0)
    {
        CRegistry reg;
        CHString chstrSubKey = IDS_98_Vmm32Files;

        if(reg.Open(HKEY_LOCAL_MACHINE,chstrSubKey,KEY_READ) == ERROR_SUCCESS)
        {
            BOOL fContinue = TRUE;
            WCHAR* pchValueName = NULL;
            unsigned char* puchValueData = NULL;
            for(DWORD dw = 0; fContinue; dw++)
            {
                if(reg.EnumerateAndGetValues(dw,pchValueName,puchValueData) ==
                                               ERROR_NO_MORE_ITEMS)
                {
                    fContinue = FALSE;
                }

                if(pchValueName != NULL)
                {
                    // Want to add the valuename to our list.
                    CHString* pchstrTemp = NULL;
                    pchstrTemp = (CHString*) new CHString;
                    if(pchstrTemp != NULL)
                    {
                        try
                        {
                            _wcsupr(pchValueName);
                            *pchstrTemp = pchValueName;
                            vecpchsVmm32vxdFileList.push_back(pchstrTemp);
                        }
                        catch ( ... )
                        {
                            delete pchstrTemp;
                            throw;
                        }
                    }
                    delete pchValueName;
                }

                if(puchValueData != NULL)
                {
                    delete puchValueData;
                }
            }
        }
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GenerateNT5DeviceDriverMappings
 *
 *  DESCRIPTION : Runs through the nt5 registry keys under
 *                HKLM\\SYSTEM\\CurrentControlSet\\Services and assembles
 *                a table of devices and their associated drivers.
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
VOID CCIMDeviceCIMDF::GenerateNT5DeviceDriverMappings(std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    // The information concerning devices and their associated drivers on NT5
    // can be found under the registry key
    // HKLM\\SYSTEM\\CurrentControlSet\\Services.  Subkeys under this key
    // include such items as Serial.  The data for the value ImagePath (in this
    // case, System32\\Drivers\\serial.sys) contains the location of the driver
    // for a device.  Which devices that is the driver for are found in the
    // Enum subkey under the aformentioned subkey (Serial in this case).  The
    // Enum subkey contains the value Count, the data for which is the number
    // of values (with a numeric based naming scheme starting at zero) also
    // found under this subkey that contain the PNPDeviceIDs of devices
    // associated with this driver.  For instance, the Enum key under Serial
    // might contain the Count value containing the data 2.  This means that
    // there are also values under this subkey called 0 and 1.  The value for
    // the data of 0 is, for example, Root\\*PNP0501\\PnPBIOS_0; the value for
    // the data of 1 is, for example, Root\\*PNP0501\\PnPBIOS_1.

    // Open up the key HKLM\\SYSTEM\\CurrentControlSet\\Services
    CRegistry reg;
    if(reg.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                IDS_NT_CurCtlSetSvcs,
                                KEY_READ) == ERROR_SUCCESS)
    {
        for(;;)
        {
            CHString chstrSubKey;
            // Get the name of a subkey (a device, such as Serial)
            if(reg.GetCurrentSubKeyName(chstrSubKey) != ERROR_NO_MORE_ITEMS)
            {
                CRegistry regDevice;
                // Construct a new key name to open
                CHString chstrDeviceKey = IDS_NT_CurCtlSetSvcs + chstrSubKey;
                // Open the key
                if(regDevice.Open(HKEY_LOCAL_MACHINE, chstrDeviceKey, KEY_READ)
                                       == ERROR_SUCCESS)
                {
                    // Get the name of the driver file, in ImagePath
                    CHString chstrImagePathValue;
                    TCHAR tstrSystemDir[_MAX_PATH+1];
                    ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
                    GetSystemDirectory(tstrSystemDir,_MAX_PATH);
                    CHString chstrDriverPathName = tstrSystemDir;
                    // Now need to check for an ImagePath entry:
                    if(regDevice.GetCurrentKeyValue(IDS_ImagePath, chstrImagePathValue)
                                       == ERROR_SUCCESS)
                    {
                        if(chstrImagePathValue.GetLength() > 0)
                        {
                            // This value contains some of the path, plus the driver
                            // filename and extension.  We only want the latter two
                            // components.
                            int lLastBackSlash = -1;
                            lLastBackSlash = chstrImagePathValue.ReverseFind(_T('\\'));
                            if(lLastBackSlash != -1)
                            {
                                chstrImagePathValue = chstrImagePathValue.Right(
                                                      chstrImagePathValue.GetLength()
                                                      - lLastBackSlash - 1);
                            }

                            // Now build the full pathname:
                            chstrDriverPathName = chstrDriverPathName + _T("\\") +
                                       IDS_DriversSubdir + _T("\\") + chstrImagePathValue;

                            // OK, now we have the driver file ready for later use.
                            // Now we need to see how many devices are listed under
                            // the enum key, which we have to open first.
                            CRegistry regEnum;
                            // Construct a new key name to open
                            CHString chstrEnumKey = chstrDeviceKey + _T("\\") + IDS_Enum;
                            if(regEnum.Open(HKEY_LOCAL_MACHINE, chstrEnumKey, KEY_READ)
                                       == ERROR_SUCCESS)
                            {
                                // Open the Count value:
                                DWORD dwCount;
                                if(regEnum.GetCurrentKeyValue(IDS_Count, dwCount)
                                       == ERROR_SUCCESS)
                                {
                                    // Now we know how many values there are, the
                                    // names of which are, imagine this, "0", "1",
                                    // etc.  For each one of them, we need to get
                                    // its value data, which is a PNPDeviceID of
                                    // a device using the driver whose name is now
                                    // stored in the variable chstrDriverPathName.
                                    CHString chstrPNPDeviceID;
                                    for(LONG n = 0L; n < dwCount; n++)
                                    {
                                        CHString chstrTemp;
                                        chstrTemp.Format(_T("%d"),n);
                                        if(regEnum.GetCurrentKeyValue(chstrTemp,
                                                                      chstrPNPDeviceID)
                                               == ERROR_SUCCESS)
                                        {
                                            // If this device is not already in our
                                            // table of devices, add it.
                                            if(!AlreadyInDeviceTable(chstrPNPDeviceID, vecpNT5DDM))
                                            {
                                                CNT5DevDrvMap* pNT5DDM = NULL;
                                                pNT5DDM = (CNT5DevDrvMap*) new CNT5DevDrvMap;
                                                if(pNT5DDM != NULL)
                                                {
                                                    try
                                                    {
                                                        chstrPNPDeviceID.MakeUpper();
                                                        pNT5DDM->m_chstrDevicePNPID = chstrPNPDeviceID;
                                                        vecpNT5DDM.push_back(pNT5DDM);
                                                    }
                                                    catch ( ... )
                                                    {
                                                        delete pNT5DDM;
                                                        throw ;
                                                    }
                                                }
                                                else
                                                {
                                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                                }
                                            }
                                            // Now that we know the device is in the
                                            // table, associate this driver with it
                                            // (AddDriver only adds it if the driver
                                            // is not already in the list of drivers.)
                                            AddDriver(chstrPNPDeviceID, chstrDriverPathName, vecpNT5DDM);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                break;
            }
            // Move to the next subkey:
            if(reg.NextSubKey() != ERROR_SUCCESS)
            {
                break;
            }
        }
    }
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::GenerateNT5DeviceDriverMap
 *
 *  DESCRIPTION : This flavor of GenerateNT5DeviceDriverMappings generates a
 *                "table" with only one device in it.
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
VOID CCIMDeviceCIMDF::GenerateNT5ServiceDriverMap(const CHString& chstrDevSvcName,
                                                  std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    // The information concerning devices and their associated drivers on NT5
    // can be found under the registry key
    // HKLM\\SYSTEM\\CurrentControlSet\\Services.  Subkeys under this key
    // include such items as Serial.  The data for the value ImagePath (in this
    // case, System32\\Drivers\\serial.sys) contains the location of the driver
    // for a device.  Which devices that is the driver for are found in the
    // Enum subkey under the aformentioned subkey (Serial in this case).  The
    // Enum subkey contains the value Count, the data for which is the number
    // of values (with a numeric based naming scheme starting at zero) also
    // found under this subkey that contain the PNPDeviceIDs of devices
    // associated with this driver.  For instance, the Enum key under Serial
    // might contain the Count value containing the data 2.  This means that
    // there are also values under this subkey called 0 and 1.  The value for
    // the data of 0 is, for example, Root\\*PNP0501\\PnPBIOS_0; the value for
    // the data of 1 is, for example, Root\\*PNP0501\\PnPBIOS_1.
    //
    // In this abbreviated version of the function GenerateNT5DeviceDriverMappings,
    // we are given the service name of the device of interest.  The service name
    // is what we were enumerating above (via OpenAndEnumerateSubKeys), so
    // here we can go directly to the correct registry entry and get what we
    // want.

    CRegistry regDevice;
    // Construct a new key name to open
    //CHString chstrDeviceKey = IDS_NT_CurCtlSetSvcs + chstrSubKey;
    CHString chstrDeviceKey = IDS_NT_CurCtlSetSvcs + chstrDevSvcName;
    // Open the key
    if(regDevice.Open(HKEY_LOCAL_MACHINE, chstrDeviceKey, KEY_READ)
                           == ERROR_SUCCESS)
    {
        // Get the name of the driver file, in ImagePath
        CHString chstrImagePathValue;
        TCHAR tstrSystemDir[_MAX_PATH+1];
        ZeroMemory(tstrSystemDir,sizeof(tstrSystemDir));
        GetSystemDirectory(tstrSystemDir,_MAX_PATH);
        CHString chstrDriverPathName = tstrSystemDir;
        // Now need to check for an ImagePath entry:
        if(regDevice.GetCurrentKeyValue(IDS_ImagePath, chstrImagePathValue)
                           == ERROR_SUCCESS)
        {
            if(chstrImagePathValue.GetLength() > 0)
            {
                // This value contains some of the path, plus the driver
                // filename and extension.  We only want the latter two
                // components.
                int lLastBackSlash = -1;
                lLastBackSlash = chstrImagePathValue.ReverseFind(_T('\\'));
                if(lLastBackSlash != -1)
                {
                    chstrImagePathValue = chstrImagePathValue.Right(
                                          chstrImagePathValue.GetLength()
                                          - lLastBackSlash - 1);
                }

                // Now build the full pathname:
                chstrDriverPathName = chstrDriverPathName + _T("\\") +
                           IDS_DriversSubdir + _T("\\") + chstrImagePathValue;
                chstrDriverPathName.MakeUpper();
                // OK, now we have the driver file ready for later use.
                // Now we need to see how many devices are listed under
                // the enum key, which we have to open first.
                CRegistry regEnum;
                // Construct a new key name to open
                CHString chstrEnumKey = chstrDeviceKey + _T("\\") + IDS_Enum;
                if(regEnum.Open(HKEY_LOCAL_MACHINE, chstrEnumKey, KEY_READ)
                           == ERROR_SUCCESS)
                {
                    // Open the Count value:
                    DWORD dwCount;
                    if(regEnum.GetCurrentKeyValue(IDS_Count, dwCount)
                           == ERROR_SUCCESS)
                    {
                        // Now we know how many values there are, the
                        // names of which are, imagine this, "0", "1",
                        // etc.  For each one of them, we need to get
                        // its value data, which is a PNPDeviceID of
                        // a device using the driver whose name is now
                        // stored in the variable chstrDriverPathName.
                        CHString chstrPNPDeviceID;
                        for(LONG n = 0L; n < dwCount; n++)
                        {
                            CHString chstrTemp;
                            chstrTemp.Format(_T("%d"),n);
                            if(regEnum.GetCurrentKeyValue(chstrTemp,
                                                          chstrPNPDeviceID)
                                   == ERROR_SUCCESS)
                            {
                                chstrPNPDeviceID.MakeUpper();
                                // If this device is not already in our
                                // table of devices, add it.
                                if(!AlreadyInDeviceTable(chstrPNPDeviceID, vecpNT5DDM))
                                {
                                    CNT5DevDrvMap* pNT5DDM = NULL;
                                    pNT5DDM = (CNT5DevDrvMap*) new CNT5DevDrvMap;
                                    if(pNT5DDM != NULL)
                                    {
                                        try
                                        {
                                            pNT5DDM->m_chstrDevicePNPID = chstrPNPDeviceID;
                                            vecpNT5DDM.push_back(pNT5DDM);
                                        }
                                        catch ( ... )
                                        {
                                            delete pNT5DDM;
                                            throw ;
                                        }
                                    }
                                    else
                                    {
                                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                    }
                                }
                                // Now that we know the device is in the
                                // table, associate this driver with it
                                // (AddDriver only adds it if the driver
                                // is not already in the list of drivers.)
                                AddDriver(chstrPNPDeviceID, chstrDriverPathName, vecpNT5DDM);
                            }
                        }
                    }
                }
            }
        }
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CleanPCHSTRVector
 *
 *  DESCRIPTION : deletes each element of a vector of CHString pointers, then
 *                clears the vector.
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID CCIMDeviceCIMDF::CleanPCHSTRVector(std::vector<CHString*>& vecpchsList)
{
    for(LONG m = 0L; m < vecpchsList.size(); m++)
    {
        delete vecpchsList[m];
    }
    vecpchsList.clear();
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::CleanPNT5DevDrvMapVector
 *
 *  DESCRIPTION : deletes each element of a vector of CNT5DevDrvMap pointers, then
 *                clears the vector.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
VOID CCIMDeviceCIMDF::CleanPNT5DevDrvMapVector(std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    for(LONG m = 0L; m < vecpNT5DDM.size(); m++)
    {
        delete vecpNT5DDM[m];
    }
    vecpNT5DDM.clear();
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::AlreadyAddedToList
 *
 *  DESCRIPTION : Internal helper to check if item was added to list
 *
 *  INPUTS      : CHString vector (the list), CHString to see if in list
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
BOOL CCIMDeviceCIMDF::AlreadyAddedToList(std::vector<CHString*>& vecchsList,
                                   CHString& chsItem)
{
    for(LONG m = 0; m < vecchsList.size(); m++)
    {
        if(vecchsList[m]->CompareNoCase(chsItem) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::AlreadyInDeviceTable
 *
 *  DESCRIPTION : Internal helper to check if item was added to list
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CCIMDeviceCIMDF::AlreadyInDeviceTable(CHString& chstrPNPDeviceID,
                                           std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    for(LONG m = 0; m < vecpNT5DDM.size(); m++)
    {
        if((vecpNT5DDM[m]->m_chstrDevicePNPID).CompareNoCase(chstrPNPDeviceID) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDeviceCIMDF::AddDriver
 *
 *  DESCRIPTION : Internal helper to add a driver to the member vector of
 *                devices.
 *
 *  INPUTS      : chstrPNPDeviceID, the device the driver belongs to;
 *                chstrDriverPathName, the driver for the device
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
VOID CCIMDeviceCIMDF::AddDriver(CHString& chstrPNPDeviceID, CHString& chstrDriverPathName,
                                std::vector<CNT5DevDrvMap*>& vecpNT5DDM)
{
    for(LONG m = 0; m < vecpNT5DDM.size(); m++)
    {
        if((vecpNT5DDM[m]->m_chstrDevicePNPID).CompareNoCase(chstrPNPDeviceID) == 0)
        {
            // The member CNT5DevDrvMap's function AddDriver only adds the
            // driver to that devices driver list if it is not already there.
            chstrDriverPathName.MakeUpper();
            vecpNT5DDM[m]->AddDriver(chstrDriverPathName);
            break;
        }
    }
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : WBEMizePathName
 *
 *  DESCRIPTION : Internal helper to change all single backslashes to double
 *                backslashes.
 *
 *  INPUTS      : chstrNormalPathname, containing string with single backslashes;
 *
 *  OUTPUTS     : chstrWBEMizedPathname, containing string with double backslashes
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID WBEMizePathName(CHString& chstrNormalPathname,
                     CHString& chstrWBEMizedPathname)
{
    CHString chstrCpyNormPathname = chstrNormalPathname;
    LONG lNext = -1L;

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrWBEMizedPathname += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrWBEMizedPathname += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrWBEMizedPathname += chstrCpyNormPathname;
    }
}



/*****************************************************************************
 *
 *  FUNCTION    : ObjNameValid
 *
 *  DESCRIPTION : Internal helper to check if the given object exists.
 *
 *  INPUTS      : chstrObject - name of prospecitive object.
 *
 *  OUTPUTS     : chstrPATH, the path of the provided object
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CCIMDeviceCIMDF::ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH)
{
    bool fRet = false;

    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( bstr_t(wstrObject),  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if (( 0 == nStatus ) &&                                                 // Did the parse succeed?
        (pParsedPath->IsInstance()) &&                                      // Is the parsed object an instance?
        (_wcsicmp(pParsedPath->m_pClass, wstrObjName) == 0) &&              // Is this the class we expect (no, cimom didn't check)
        (pParsedPath->m_dwNumKeys == 1) &&                                  // Does it have exactly one key
        (pParsedPath->m_paKeys[0]) &&                                       // Is the keys pointer null (shouldn't happen)
        ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                      // Key name not specified or
        (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, wstrKeyName) == 0)) &&  // key name is the right value
                                                                            // (no, cimom doesn't do this for us).
        (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_BSTR) &&           // Check the variant type (no, cimom doesn't check this either)
        (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )             // And is there a value in it?
    {
        chstrPATH = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
        fRet = true;
    }

    if (pParsedPath)
        // Clean up the Parsed Path
        objpathParser.Free(pParsedPath);

    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : DeviceExists
 *
 *  DESCRIPTION : Internal helper to check if the given device exists.
 *
 *  INPUTS      : chstrDevice - name of prospecitive device.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CCIMDeviceCIMDF::DeviceExists(const CHString& chstrDevice,
                                   CConfigMgrDevice** ppDevice)
{
    bool fRet = false;
    CConfigManager cfgmgr;

    if(cfgmgr.LocateDevice(chstrDevice, ppDevice))
    {
        fRet = true;
    }
    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : SetPurposeDescription
 *
 *  DESCRIPTION : Internal helper to set the PurposeDescription property.
 *
 *  INPUTS      : pInstance - instance pointer.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID CCIMDeviceCIMDF::SetPurposeDescription(CInstance *a_pInstance, const CHString& a_chstrFileName)
{
	if(a_pInstance != NULL)
    {
        CHString chstrVerStrBuf;

        // Get the file description property...
        LPVOID pInfo = NULL;
        try
        {
            if(GetFileInfoBlock(TOBSTRT(a_chstrFileName), &pInfo) && (pInfo != NULL))
            {
                bool t_Status = GetVarFromInfoBlock(pInfo,                    // Name of file to get ver info about
                                                    _T("FileDescription"),	  // String identifying resource of interest
                                                    chstrVerStrBuf);          // Buffer to hold version string
                if(t_Status)
                {
                    a_pInstance->SetCHString(IDS_PurposeDescription, chstrVerStrBuf);
                }
            }
        }
        catch(...)
        {
            if(pInfo != NULL)
            {
                delete pInfo;
                pInfo = NULL;
            }
            throw;
        }
		delete pInfo;
        pInfo = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cnetconn.h ===
//=================================================================

//

// cnetconn.h -- Persistent network connection property set provider

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//			  a-peterc 5/25/99 Reworked...	
//
//=================================================================
#ifndef __CNETCONN_H__
#define __CNETCONN_H__

#define NETCONN_FIRST  0
#define NETCONN_NEXT   1
#define NETCONN_CLOSE  2

#include <deque>

class CConnection
{
public:
	enum eConnectionScope{ e_Connected, e_Remembered, e_IPC } ;

	DWORD		dwScope ;
    DWORD		dwType ;
    DWORD		dwDisplayType ;
    DWORD		dwUsage ;
    CHString	chsLocalName ;
    CHString	chsRemoteName ;
    CHString	chsComment ;
    CHString	chsProvider ;

	eConnectionScope	eScope ;
	CHString			strKeyName ;
	CHString			strUserName ;
	DWORD				dwStatus ;
};

class CNetConnection
{
private:

	CMprApi *m_MprApi ;

	typedef std::deque<CConnection*>  Connection_Ptr_List ;
	Connection_Ptr_List				m_oConnectionList; 
	Connection_Ptr_List::iterator	m_ConnectionIter ;

	BOOL			AddConnectionToList( 

						NETRESOURCE *a_pNetResource,
						CConnection::eConnectionScope a_eScope,
                        short shStatus
						) ;

	BOOL			FillInConnection( 

						NETRESOURCE *a_pNetResource, 
						CConnection *a_pConnection,
						CConnection::eConnectionScope a_eScope
						) ;

	void			ClearConnectionList() ;
	
	DWORD			GetStatus( LPNETRESOURCE a_pNetResource ) ;
#ifdef WIN9XONLY
    DWORD			GetStatusLightly( LPNETRESOURCE a_pNetResource ) ;
#endif
	void			GetUser( LPNETRESOURCE a_pNetResource, CConnection *a_pConnection ) ;

	void			CreateNameKey (
					
						LPNETRESOURCE a_lpNetResource, 
						CHString &a_strName
						) ;

public:

					CNetConnection() ;
					~CNetConnection() ;

	BOOL			GetConnection( 
						
						CHString &a_rstrFind, 
						CConnection &a_rConnection
						) ; 
	
	BOOL			LoadConnections() ;
	void			BeginConnectionEnum() ;
	BOOL			GetNextConnection( CConnection **a_pConnection ) ;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cnetconn.cpp ===
//=================================================================

//

// cnetconn.CPP -- Persistent network connection property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions: jennymc 1/19/98  consolidating code
//							   Still needs rework, but better than it was
//
//			  a-peterc 5/25/99 Reworked...
//
//=================================================================
#include "precomp.h"
#include "wbemnetapi32.h"
#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include "cnetconn.h"
#include <CreateMutexAsProcess.h>
#include <assertbreak.h>

#define ENUM_BUFF_SIZE	1024
#define ENUM_ARRAY_SIZE 20

#define IPC_PROVIDER "Microsoft Network"

/*=================================================================
 Function:  CNetConnection(),~CNetConnection()

 Description: contructor and destructor

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  25-May-1999     Created
=================================================================*/
CNetConnection :: CNetConnection ()
{
   	m_MprApi = ( CMprApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidMprApi, NULL ) ;

	// validate connection iterator
	m_ConnectionIter = m_oConnectionList.end() ;
}

//
CNetConnection :: ~CNetConnection ()
{
	CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidMprApi , m_MprApi ) ;

	ClearConnectionList() ;
}


/*=================================================================
 Functions:  BeginConnectionEnum(), GetNextConnection( CConnection **a_pConnection )

 Description: Provides for network connection enumeration.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
void CNetConnection::BeginConnectionEnum()
{
	LoadConnections() ;

	m_ConnectionIter = m_oConnectionList.begin() ;
}

//
BOOL CNetConnection::GetNextConnection( CConnection **a_pConnection )
{
	if ( m_ConnectionIter == m_oConnectionList.end() )
	{
		*a_pConnection = NULL ;
		return FALSE ;
	}
	else
	{
		*a_pConnection = *m_ConnectionIter ;

		++m_ConnectionIter ;
		return TRUE ;
	}
}

/*=================================================================
 Functions:  GetConnection( CHString &a_rstrFind, CConnection &a_rConnection )

 Description: Provides single extraction of a network connection.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
BOOL CNetConnection ::GetConnection( CHString &a_rstrFind, CConnection &a_rConnection )
{
	BOOL		t_fFound		= FALSE ;
	HANDLE		t_hEnumHandle	= NULL ;
	DWORD		t_dwEntryCount	= 1 ;
	DWORD		t_dwBufferSize  = 0 ;

	BYTE		t_bTempBuffer[ ENUM_BUFF_SIZE ] ;
	DWORD		t_dwRetCode ;

	LPNETRESOURCE t_pNetResource = reinterpret_cast<LPNETRESOURCE>( &t_bTempBuffer ) ;

	//
	if( !m_MprApi )
	{
		return FALSE ;
	}

	try
	{
		// scan the "remembered" resources first

		// Enum open
		t_dwRetCode = m_MprApi->WNetOpenEnum(RESOURCE_REMEMBERED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

		if( NO_ERROR == t_dwRetCode )
		{
			while( true )
			{
				t_dwEntryCount = 1 ;
				t_dwBufferSize = ENUM_BUFF_SIZE ;

				memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

				if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
															&t_dwEntryCount,
															&t_bTempBuffer,
															&t_dwBufferSize ) &&

															1 == t_dwEntryCount )
				{
					// build a key name
					CHString t_chsTempKeyName ;
					CreateNameKey( t_pNetResource, t_chsTempKeyName ) ;

					// hit test
					if( 0 == t_chsTempKeyName.CompareNoCase( a_rstrFind ) )
					{
						if( FillInConnection(	t_pNetResource,
												&a_rConnection,
												CConnection::e_Remembered  ) )
						{
							t_fFound = TRUE ;

							break ;
						}
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

	try
	{
		// else scan the "currently connected" connections
		if( !t_fFound )
		{
			// Enum open
			t_dwRetCode = m_MprApi->WNetOpenEnum( RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

			if( NO_ERROR == t_dwRetCode )
			{
				while( true )
				{
					t_dwEntryCount = 1 ;
					t_dwBufferSize = ENUM_BUFF_SIZE ;

					memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

					if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
																&t_dwEntryCount,
																&t_bTempBuffer,
																&t_dwBufferSize ) &&

																1 == t_dwEntryCount )
					{
						// build a key name
						CHString t_chsTempKeyName ;
						CreateNameKey( t_pNetResource, t_chsTempKeyName ) ;

						// hit test
						if( 0 == t_chsTempKeyName.CompareNoCase( a_rstrFind ) )
						{
							if( FillInConnection(	t_pNetResource,
													&a_rConnection,
													CConnection::e_Connected ) )
							{
								t_fFound = TRUE ;

								break ;
							}
						}
					}
					else
					{
						break;
					}
				}
			}
		}
	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

#if WIN9XONLY
// Win9x doesn't return IPC$ connections from the previous two calls.  So we
// have to look for them special.

	if( !t_fFound )
	{
        CCim32NetApi* t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();

        if(t_pCim32Net != NULL)
        {
            try
            {
                DWORD dwSize = sizeof(use_info_1Out) * ENUM_ARRAY_SIZE;
                char *pBuff = new char[dwSize];
                use_info_1Out *pBuff2 = new use_info_1Out[ENUM_ARRAY_SIZE];

                if (pBuff && pBuff2)
                {
                    try
                    {
                        unsigned short pcEntriesRead, pcTotalAvail;

                        DWORD dwRet = t_pCim32Net->GetWin9XNetUseEnum(
                            NULL,
                            1,
                            (char *)pBuff,
                            pBuff2,
                            dwSize,
                            &pcEntriesRead,
                            &pcTotalAvail);

                        if (dwRet == ERROR_MORE_DATA)
                        {
                            delete [] pBuff;
                            delete [] pBuff2;

                            pBuff = NULL;
                            pBuff2 = NULL;

                            dwSize = pcTotalAvail * sizeof(use_info_1Out);

                            pBuff = new char[dwSize];
                            pBuff2 = new use_info_1Out[pcTotalAvail];
                            if (pBuff && pBuff2)
                            {
                                dwRet = t_pCim32Net->GetWin9XNetUseEnum(
                                    NULL,
                                    1,
                                    (char *)pBuff,
                                    pBuff2,
                                    dwSize,
                                    &pcEntriesRead,
                                    &pcTotalAvail);
                            }
                            else
                            {
                                if (pBuff)
                                {
                                    delete [] pBuff;
                                }

                                if (pBuff2)
                                {
                                    delete [] pBuff2;
                                }

                                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }
                        }

                        if (dwRet == NERR_Success)
                        {
                            NETRESOURCE t_NetResource;

                            // These are 'by definition' for ipc$
                            t_NetResource.dwScope = RESOURCE_CONNECTED;
                            t_NetResource.dwType = RESOURCETYPE_ANY;
                            t_NetResource.dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
                            t_NetResource.lpRemoteName = NULL ;
							t_NetResource.lpLocalName = NULL;
                            t_NetResource.lpComment = NULL;
                            t_NetResource.lpProvider = IPC_PROVIDER;

					        CHString t_chsTempKeyName ;

                            for (DWORD x=0; x < pcTotalAvail; x++)
                            {
                                if (pBuff2[x].ui1_asg_type == USE_IPC)
                                {
                                    // Since all the existing code works with NETRESOURCE
                                    // structs, we shall adapt.

                                    // And grab the remote name
                                    t_NetResource.lpRemoteName = pBuff2[x].ui1_remote;

 					                // build a key name
					                CreateNameKey( &t_NetResource, t_chsTempKeyName ) ;

					                if ( 0 == t_chsTempKeyName.CompareNoCase( a_rstrFind ) )
					                {
						                if( FillInConnection(	&t_NetResource,
												                &a_rConnection,
												                CConnection::e_IPC ) )
						                {
                                            a_rConnection.dwStatus = pBuff2[x].ui1_status;
							                t_fFound = TRUE ;

							                break ;
						                }
                                    }
                                }
                            }
                        }
                    }
                    catch ( ... )
                    {
                        delete [] pBuff;
                        delete [] pBuff2;
                        throw;
                    }

                    delete [] pBuff;
                    delete [] pBuff2;
                }
                else
                {
                    if (pBuff)
                    {
                        delete [] pBuff;
                    }

                    if (pBuff2)
                    {
                        delete [] pBuff2;
                    }

    		        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            catch (...)
            {
                CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
                throw;
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
            t_pCim32Net = NULL;
        }
    }
#endif

	return t_fFound ;
}

/*=================================================================
 Functions:  LoadConnections()

 Description: Buffers all connections for use in enumeration

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
BOOL CNetConnection :: LoadConnections()
{
	HANDLE		t_hEnumHandle	= NULL ;
	DWORD		t_dwEntryCount	= 1 ;
	DWORD		t_dwBufferSize  = 0 ;
	DWORD		t_dwRetCode ;

	BYTE		t_bTempBuffer[ ENUM_BUFF_SIZE ] ;

	LPNETRESOURCE t_pNetResource = reinterpret_cast<LPNETRESOURCE>( &t_bTempBuffer ) ;

	//
	ClearConnectionList() ;

	if( !m_MprApi )
	{
		return FALSE ;
	}

	try
	{
		// scan the "remembered" resources first

		// Enum open
		t_dwRetCode = m_MprApi->WNetOpenEnum( RESOURCE_REMEMBERED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

		if( NO_ERROR == t_dwRetCode )
		{
			while( true )
			{
				t_dwEntryCount = 1 ;
				t_dwBufferSize = ENUM_BUFF_SIZE ;

				memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

				if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
															&t_dwEntryCount,
															&t_bTempBuffer,
															&t_dwBufferSize ) &&

															1 == t_dwEntryCount )
				{
					AddConnectionToList( t_pNetResource, CConnection::e_Remembered, 0 ) ;
				}
				else
				{
					break;
				}
			}
		}
	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		ClearConnectionList() ;

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

	try
	{
		// Add to the list "currently connected" resources

		// Enum open
		t_dwRetCode = m_MprApi->WNetOpenEnum(RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &t_hEnumHandle ) ;

		if( NO_ERROR == t_dwRetCode )
		{
			while( true )
			{
				t_dwEntryCount = 1 ;
				t_dwBufferSize = ENUM_BUFF_SIZE ;

				memset( &t_bTempBuffer, 0, ENUM_BUFF_SIZE ) ;

				if( NO_ERROR == m_MprApi->WNetEnumResource( t_hEnumHandle,
															&t_dwEntryCount,
															&t_bTempBuffer,
															&t_dwBufferSize ) &&

															1 == t_dwEntryCount )
				{
					// build a key name
					CHString t_chsTempKeyName ;
					CreateNameKey( t_pNetResource, t_chsTempKeyName ) ;

					BOOL t_fInserted = FALSE ;

					// add to the list only if it's not "remembered"
					for( m_ConnectionIter  = m_oConnectionList.begin();
						 m_ConnectionIter != m_oConnectionList.end();
						 m_ConnectionIter++ )
					{
						// test for duplicate
						if(0 == t_chsTempKeyName.CompareNoCase( (*m_ConnectionIter)->strKeyName ) )
						{
							t_fInserted = TRUE ;
							break ;
						}
					}

					// new entry
					if( !t_fInserted )
					{
						AddConnectionToList( t_pNetResource, CConnection::e_Connected, 0 ) ;
					}
				}
				else
				{
					break;
				}
			}
		}

	}
	catch( ... )
	{
		if( t_hEnumHandle )
		{
			m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		}

		ClearConnectionList() ;

		throw ;
	}

	if( t_hEnumHandle )
	{
		m_MprApi->WNetCloseEnum( t_hEnumHandle ) ;
		t_hEnumHandle = NULL ;
	}

#if WIN9XONLY

// Win9x doesn't return IPC$ connections from the previous two calls.  So we
// have to look for them special.

    CCim32NetApi* t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();

    if(t_pCim32Net != NULL)
    {
        try
        {
            DWORD dwSize = sizeof(use_info_1Out) * ENUM_ARRAY_SIZE;
            char *pBuff = new char[dwSize];
            use_info_1Out *pBuff2 = new use_info_1Out[ENUM_ARRAY_SIZE];

            if (pBuff && pBuff2)
            {
                try
                {
                    unsigned short pcEntriesRead, pcTotalAvail;

                    DWORD dwRet = t_pCim32Net->GetWin9XNetUseEnum(
                        NULL,
                        1,
                        pBuff,
                        pBuff2,
                        dwSize,
                        &pcEntriesRead,
                        &pcTotalAvail);

                    if (dwRet == ERROR_MORE_DATA)
                    {
                        delete [] pBuff;
                        delete [] pBuff2;

                        pBuff = NULL;
                        pBuff2 = NULL;

                        dwSize = pcTotalAvail * sizeof(use_info_1Out);

                        pBuff = new char[dwSize];
                        pBuff2 = new use_info_1Out[pcTotalAvail];
                        if (pBuff && pBuff2)
                        {
                            dwRet = t_pCim32Net->GetWin9XNetUseEnum(
                                NULL,
                                1,
                                pBuff,
                                pBuff2,
                                dwSize,
                                &pcEntriesRead,
                                &pcTotalAvail);
                        }
                        else
                        {
                            if (pBuff)
                            {
                                delete [] pBuff;
                            }

                            if (pBuff2)
                            {
                                delete [] pBuff2;
                            }
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }

                    if (dwRet == NERR_Success)
                    {
					    CHString t_chsTempKeyName ;

                        NETRESOURCE t_NetResource;

                        t_NetResource.dwScope = RESOURCE_CONNECTED;
                        t_NetResource.dwType = RESOURCETYPE_ANY;
                        t_NetResource.dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
                        t_NetResource.lpRemoteName = NULL ;
						t_NetResource.lpLocalName = NULL; // IPC$ has no local name
                        t_NetResource.lpComment = NULL;
                        t_NetResource.lpProvider = IPC_PROVIDER;

                        for (DWORD x=0; x < pcTotalAvail; x++)
                        {
                            // In theory, we have ALL the connections in this structure, and
                            // don't need the WNetEnumResource stuff above, but those routines
                            // are there and working.
                            if ( (pBuff2[x].ui1_asg_type == USE_IPC) )
                            {
                                t_NetResource.lpRemoteName = pBuff2[x].ui1_remote;

 					            // build a key name
					            CreateNameKey( &t_NetResource, t_chsTempKeyName ) ;

                                // Note that we DON'T check for dupes, since since if the other approaches
                                // returned IPC$ connections, we wouldn't be going through all this kaka.

						        AddConnectionToList( &t_NetResource, CConnection::e_IPC, pBuff2[x].ui1_status ) ;
                            }
                        }
                    }
                }
                catch ( ... )
                {
                    delete [] pBuff;
                    delete [] pBuff2;
                    throw;
                }

                delete [] pBuff;
                delete [] pBuff2;
            }
            else
            {
                if (pBuff)
                {
                    delete [] pBuff;
                }

                if (pBuff2)
                {
                    delete [] pBuff2;
                }
    		    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

	    }
	    catch( ... )
	    {

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
		    ClearConnectionList() ;

		    throw ;
	    }

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
        t_pCim32Net = NULL;
    }
#endif


	return !m_oConnectionList.empty() ;
}

/*=================================================================
 Utility function:  ClearConnectionList()


 History:					a-peterc  21-May-1999     Created
=================================================================*/

//
void CNetConnection ::ClearConnectionList()
{
	while( !m_oConnectionList.empty() )
	{
		delete m_oConnectionList.front() ;

		m_oConnectionList.pop_front() ;
	}
}


/*=================================================================
 Utility function:  CreateNameKey (

						LPNETRESOURCE a_pNetResource,
						CHString &a_strName
					)


 History:					a-peterc  21-May-1999     Created
=================================================================*/
void CNetConnection :: CreateNameKey (

	LPNETRESOURCE a_pNetResource,
	CHString &a_strName
)
{
	if ( a_pNetResource )
	{
		if( a_pNetResource->lpRemoteName )
		{
			a_strName = a_pNetResource->lpRemoteName ;
		}
		else
		{
			a_strName = _T("") ;	// bad key
		}

	    if( ( a_pNetResource->lpLocalName != NULL ) && ( a_pNetResource->lpLocalName[0] ) )
		{
	        a_strName += _T(" (") ;
	        a_strName += a_pNetResource->lpLocalName ;
	        a_strName += _T(")") ;
	    }
	}
}

/*=================================================================
 Utility function:  AddConnectionToList(

						NETRESOURCE *a_pNetResource,
						CConnection::eConnectionScope a_eScope
						)


 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
BOOL CNetConnection :: AddConnectionToList(

NETRESOURCE *a_pNetResource,
CConnection::eConnectionScope a_eScope,
short shStatus
)
{
	BOOL t_fReturn = FALSE ;

	CConnection *t_pConnection = NULL ;
	t_pConnection = new CConnection ;
	
	try
	{
		if( FillInConnection( a_pNetResource, t_pConnection, a_eScope ) )
		{
            if (a_eScope == CConnection::e_IPC)
            {
                t_pConnection->dwStatus = shStatus;
            }

			// and add to the list
			m_oConnectionList.push_back( t_pConnection ) ;

			t_fReturn = TRUE ;
		}
		else
		{
			delete t_pConnection ;
			t_pConnection = NULL ;
		}
	}
	catch(...)
	{
		delete t_pConnection ;
		t_pConnection = NULL ;
		throw;
	}

	return t_fReturn ;
}

/*=================================================================
 Utility function:  FillInConnection(

						NETRESOURCE *a_pNetResource,
						CConnection *a_pConnection,
						CConnection::eConnectionScope a_eScope
						)


 History:					a-peterc  21-May-1999     Created
=================================================================*/
BOOL CNetConnection :: FillInConnection(

NETRESOURCE *a_pNetResource,
CConnection *a_pConnection,
CConnection::eConnectionScope a_eScope
)
{
	if( !a_pNetResource || !a_pConnection )
	{
		return FALSE ;
	}

	a_pConnection->dwScope			= a_pNetResource->dwScope ;
    a_pConnection->dwType			= a_pNetResource->dwType ;
    a_pConnection->dwDisplayType	= a_pNetResource->dwDisplayType ;
    a_pConnection->dwUsage			= a_pNetResource->dwUsage;
    a_pConnection->chsLocalName		= a_pNetResource->lpLocalName ;
    a_pConnection->chsRemoteName	= a_pNetResource->lpRemoteName ;
    a_pConnection->chsComment		= a_pNetResource->lpComment ;
    a_pConnection->chsProvider		= a_pNetResource->lpProvider ;

	// build a key name
	CreateNameKey( a_pNetResource, a_pConnection->strKeyName ) ;

	// note the connection scope
	a_pConnection->eScope = a_eScope ;

	// connection status
	a_pConnection->dwStatus = GetStatus( a_pNetResource ) ;

	GetUser( a_pNetResource, a_pConnection ) ;

	return TRUE ;
}

/*=================================================================
 Utility function:  GetStatus( LPNETRESOURCE a_pNetResource )


 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
DWORD CNetConnection :: GetStatus( LPNETRESOURCE a_pNetResource )
{
   // Find the status of the network connection.
    DWORD dwStatus = USE_NETERR ;

    // We must have either the local name or the remote name.
    if ( a_pNetResource->lpLocalName || a_pNetResource->lpRemoteName )
    {
#ifdef NTONLY
        {
            _bstr_t     bstrUseName( a_pNetResource->lpLocalName ?
									a_pNetResource->lpLocalName :
									a_pNetResource->lpRemoteName ) ;

			CNetAPI32   t_NetAPI;
			USE_INFO_1  *pInfo;

			try
			{
				if( t_NetAPI.Init() == ERROR_SUCCESS )
				{
					if ((dwStatus = t_NetAPI.NetUseGetInfo(NULL, bstrUseName, 1, (LPBYTE *) &pInfo)) == NERR_Success )
					{
						dwStatus = pInfo->ui1_status;
						t_NetAPI.NetApiBufferFree( pInfo );
						pInfo = NULL;
					}
				}
			}
			catch( ... )
			{
				if( pInfo )
				{
					t_NetAPI.NetApiBufferFree(pInfo);
				}
			}
        }
#endif
#ifdef WIN9XONLY
        {
            // If we don't have a local name the 16-bit GetUseInfo
            // won't work.  So, we will assume the status is OK
            // until we find a way to find out for sure.
            if ( !a_pNetResource->lpLocalName )
			{
                //dwStatus = USE_OK;
                // This is grim, but the only way to get the status without changing
                // the status is to use NetUseEnum.  Calling NetUseGetInfo and specifying
                // the remote name changes the status from disconnected to OK if the status
                // had been disconnected.
                dwStatus = GetStatusLightly(a_pNetResource);
			}
            else
            {
                // On 9x we have to thunk down to 16-bit to find the
                // connection status.
                CCim32NetApi* t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();

                if(t_pCim32Net != NULL)
                {
                    char    szLocal[256],
                            szRemote[256],
                            szPassword[256];

                    DWORD   dwType,
                            dwStat,
                            dwRefCount,
                            dwUseCount;

                    if (t_pCim32Net->GetWin9XUseInfo1(
                            a_pNetResource->lpLocalName,
                            szLocal,
                            szRemote,
                            szPassword,
                            &dwStat,
                            &dwType,
                            &dwRefCount,
                            &dwUseCount ) == NERR_Success )
					{
                        dwStatus = dwStat;
					}

                    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
                    t_pCim32Net = NULL;
                }
            }
        }
#endif
    }

	return dwStatus ;
}

#ifdef WIN9XONLY
DWORD CNetConnection::GetStatusLightly(LPNETRESOURCE a_pNetResource)
{
    DWORD dwResult = USE_NETERR;

    CCim32NetApi* t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
    if(t_pCim32Net != NULL)
    {
        char *pBuff = NULL;
        use_info_1Out *pBuff2 = NULL;

        try
        {
            DWORD dwSize = sizeof(use_info_1Out) * ENUM_ARRAY_SIZE;
			pBuff = new char[dwSize];
			pBuff2 = new use_info_1Out[ENUM_ARRAY_SIZE];

            try
            {
                unsigned short pcEntriesRead, pcTotalAvail;

                DWORD dwRet = t_pCim32Net->GetWin9XNetUseEnum(
                    NULL,
                    1,
                    (char *)pBuff,
                    pBuff2,
                    dwSize,
                    &pcEntriesRead,
                    &pcTotalAvail);

                if (dwRet == ERROR_MORE_DATA)
                {
                    delete [] pBuff;
                    delete [] pBuff2;

                    pBuff = NULL;
                    pBuff2 = NULL;

                    dwSize = pcTotalAvail * sizeof(use_info_1Out);

                    pBuff = new char[dwSize];
                    pBuff2 = new use_info_1Out[pcTotalAvail];
                    if (pBuff && pBuff2)
                    {
                        dwRet = t_pCim32Net->GetWin9XNetUseEnum(
                            NULL,
                            1,
                            (char *)pBuff,
                            pBuff2,
                            dwSize,
                            &pcEntriesRead,
                            &pcTotalAvail);
                    }
                    else
                    {
                        if (pBuff)
                        {
                            delete [] pBuff;
                        }

                        if (pBuff2)
                        {
                            delete [] pBuff2;
                        }

                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }

                if (dwRet == NERR_Success)
                {
					ASSERT_BREAK(a_pNetResource->lpRemoteName != NULL);

                    if(a_pNetResource->lpRemoteName != NULL)
                    {
                        CHString t_chstrInName(a_pNetResource->lpRemoteName);

                        for (DWORD x=0; x < pcTotalAvail; x++)
                        {
                            if(pBuff2[x].ui1_remote != NULL)
                            {
                                CHString t_chstrTempName(pBuff2[x].ui1_remote);
                                // Only concerned with the one matching our in-parm
                                if (t_chstrTempName.CompareNoCase(t_chstrInName)==0)
                                {
                                    dwResult = pBuff2[x].ui1_status;
							        break ;
                                }
                            }
                        }
                    }
                }
            }
            catch ( ... )
            {
                delete [] pBuff;
                delete [] pBuff2;
                throw;
            }

            delete [] pBuff;
			pBuff = NULL;
            delete [] pBuff2;
			pBuff2 = NULL;

        }
        catch (...)
        {
            if (pBuff)
            {
                delete [] pBuff;
            }

            if (pBuff2)
            {
                delete [] pBuff2;
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
            throw;
        }

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net ) ;
        t_pCim32Net = NULL;
    }
    return dwResult;
}
#endif




/*=================================================================
 Utility function:  GetUser( LPNETRESOURCE a_pNetResource, CConnection *a_pConnection )


 History:					a-peterc  21-May-1999     Created
=================================================================*/
//
void CNetConnection :: GetUser( LPNETRESOURCE a_pNetResource, CConnection *a_pConnection )
{
	DWORD t_dwBufferSize = _MAX_PATH ;
    TCHAR t_szTemp[_MAX_PATH + 2] ;

    LPCTSTR t_pName = a_pNetResource->lpLocalName ;

	if( !t_pName )
	{
		t_pName = a_pNetResource->lpRemoteName ;
	}

	// Protect the LSA call with a mutex.  Not our bug, but we have to protect ourselves.
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		if( NO_ERROR == m_MprApi->WNetGetUser( t_pName, (LPTSTR)t_szTemp, &t_dwBufferSize ) )
		{
			a_pConnection->strUserName = t_szTemp ;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\codecfile.h ===
//=================================================================

//

// CodecFile.h -- CWin32CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/29/98    sotteson         Created
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_CODECFILE L"Win32_CodecFile"

typedef struct _DRIVERINFO
{
	CHString	strName,
				strDesc;
	BOOL		bAudio;
} DRIVERINFO;

typedef std::list<DRIVERINFO*>::iterator	DRIVERLIST_ITERATOR;

class DRIVERLIST : public std::list<DRIVERINFO*>
{
public:

	~DRIVERLIST ()
	{
		while ( size () )
		{
			DRIVERINFO *pInfo = front () ;
			
			delete pInfo ;

			pop_front () ;
		}
	}

    void EliminateDups()
    {
        sort();
        unique();
    }

} ;

class CWin32CodecFile : public CCIMDataFile
{
public:
	// Constructor/destructor
	//=======================
	CWin32CodecFile(LPCWSTR szName, LPCWSTR szNamespace);
	~CWin32CodecFile();

	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
		long lFlags = 0);
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);

    virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);


protected:
	// Overridable function inherrited from CCIMLogicalFile
	// NEED TO IMPLEMENT THESE HERE SINCE THIS CLASS IS DERIVED FROM
    // CCimDataFile (BOTH C++ AND MOF DERIVATION).  
    // THAT CLASS CALLS IsOneOfMe.  THE MOST DERIVED (IN CIMOM)
    // INSTANCE GETS CALLED.  IF NOT IMPLEMENTED HERE, THE IMPLEMENTATION
    // IN CCimDataFile WOULD BE USED, WHICH WILL COMMIT FOR DATAFILES.
    // HOWEVER, IF CWin32CodecFile DOES NOT RETURN FALSE FROM ITS IsOneOfMe,
    // WHICH IT WON'T DO IF NOT IMPLEMENTED HERE, CIMOM WILL ASSIGN ALL
    // DATAFILES TO THIS CLASS SINCE IT PUTS INSTANCES FROM THE MOST
    // DERIVED (CIMOM DERIVED THAT IS) CLASS.
#ifdef WIN9XONLY
    virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
		                   LPCSTR strFullPathName);
#endif

#ifdef NTONLY
	virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
		                   const WCHAR* wstrFullPathName);
#endif

	// Overridable function inherrited from CProvider
	virtual void GetExtendedProperties(CInstance* pInstance, long lFlags = 0L);

#ifdef NTONLY
	HRESULT BuildDriverListNT(DRIVERLIST *pList);
#endif
#ifdef WIN9XONLY
	HRESULT BuildDriverList9x(DRIVERLIST *pList);
#endif
	void SetInstanceInfo(CInstance *pInstance, DRIVERINFO *pInfo, 
		LPCTSTR szSysDir);
private:
    DRIVERINFO* GetDriverInfoFromList(DRIVERLIST *plist, LPCWSTR strName);	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\comobjsecregkey.h ===
//=============================================================================================================

//

// COMObjSecRegKey.h -- header file for CCOMObjectSecurityRegistryKey class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//				 
//==============================================================================================================

#if !defined __CCOMObjectSecurityRegistryKey_H__
#define __CCOMObjectSecurityRegistryKey_H__

#include "SecurityDescriptor.h"			


////////////////////////////////////////////////////////////////
//
//	Class:	CCOMObjectSecurityRegistryKey
//
//	This class is intended to encapsulate the security of a
//	COM object.Launch/Access Security Information for a COM 
//	object is located under AppID/{appid}[LaunchPermission] &
//	AppID/{appid}[LaunchPermission]. The class inherits off of 
//	CSecurityDescriptor	and it is that class to which it passes 
//	Security Descriptors it obtains, and from which it receives 
//	previously built security descriptors to apply.  
////////////////////////////////////////////////////////////////

#ifdef NTONLY
class CCOMObjectSecurityRegistryKey : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CCOMObjectSecurityRegistryKey();
		CCOMObjectSecurityRegistryKey(PSECURITY_DESCRIPTOR a_pSD);
		~CCOMObjectSecurityRegistryKey();

		virtual DWORD AllAccessMask( void );

	protected:

		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR a_pAbsoluteSD);
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR a_pAbsoluteSD , SECURITY_INFORMATION a_securityinfo  );
	private:

};
#endif

#endif // __CCOMObjectSecurityRegistryKey_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\codecfile.cpp ===
//=================================================================

//

// CodecFile.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/29/98    sotteson         Created
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msacm.h>
#include <list>
#include "file.h"
#include "Implement_LogicalFile.h"
#include "cimdatafile.h"
#include "CodecFile.h"
#include "DllWrapperBase.h"
#include "MsAcm32Api.h"
#include "sid.h"
#include "ImpLogonUser.h"

// Property set declaration
//=========================

CWin32CodecFile codecFile(L"Win32_CodecFile", IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::CWin32CodecFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32CodecFile::CWin32CodecFile (

	LPCWSTR szName,
	LPCWSTR szNamespace

) : CCIMDataFile(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::~CWin32CodecFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32CodecFile::~CWin32CodecFile ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::ExecQuery
 *
 *  DESCRIPTION : The REAL reason this function is here, given that it only
 *                throws us into this class's EnumerateInstances function, is
 *                that without a local version of the function, the parent's
 *                (CImplement_LogicalFile) exec query is called.  Because one
 *                might want to do a query on this class like
 *                "select * from win32_codecfile where group = "Audio"",
 *                which would throw the parent's query into an enumeration instead
 *                (as group isn't a property it optimizes on), we want to instead
 *                get thrown into THIS class's enumerateinstances, as it does
 *                a much tighter search, since it knows it is only looking for
 *                codec files, and it knows where to look for them.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32CodecFile::ExecQuery(MethodContext* pMethodContext,
                                  CFrameworkQuery& pQuery,
                                  long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;


// DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



    hr = EnumerateInstances(pMethodContext, lFlags);



#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif



    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CodecFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32CodecFile :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


	DRIVERLIST list ;

#ifdef NTONLY
	HRESULT hres = BuildDriverListNT ( & list ) ;
#endif
#ifdef WIN9XONLY
	HRESULT hres = BuildDriverList9x ( & list ) ;
#endif

    if(SUCCEEDED(hres))
    {
        list.EliminateDups();

	    TCHAR szDir[MAX_PATH];

	    GetSystemDirectory ( szDir , sizeof ( szDir ) / sizeof(TCHAR) ) ;
        CHString sQualifiedName(L' ', MAX_PATH);

	    while ( list.size () && SUCCEEDED ( hres ) )
	    {
		    CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
            if ( pInstance )
            {
			    DRIVERINFO *pInfo = list.front () ;
                sQualifiedName = szDir;
                sQualifiedName += L'\\';
                sQualifiedName += pInfo->strName;

                // As a final sanity check, prior to commiting, we should
                // confirm that the file really exists (right now all we
                // have is the registry's word on it).
                if(GetFileAttributes(TOBSTRT(sQualifiedName)) != -1L)
                {
			        SetInstanceInfo ( pInstance , pInfo , szDir ) ;
			        hres = pInstance->Commit (  ) ;
                }
			    delete pInfo;
			    list.pop_front () ;
            }
            else
		    {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }
	    }

#ifdef NTONLY
        if(fImp)
        {
            icu.End();
            fImp = false;
        }
#endif
    }

	return hres;
}

HRESULT CWin32CodecFile::GetObject (CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
    HRESULT hrFoundIt = WBEM_E_NOT_FOUND;

#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif



	// Build a list of all drivers.
	DRIVERLIST list;

#ifdef NTONLY
	HRESULT hres = BuildDriverListNT ( &list ) ;
#endif
#ifdef WIN9XONLY
	HRESULT hres = BuildDriverList9x ( &list ) ;
#endif

    if(SUCCEEDED(hres))
    {
	    list.EliminateDups();
        CHString strName ;
	    pInstance->GetCHString ( IDS_Name , strName ) ;

	    TCHAR szDir[MAX_PATH];
	    GetSystemDirectory ( szDir , sizeof ( szDir ) / sizeof(TCHAR) ) ;

	    // Try to find the instance in the list of drivers.

	    while ( list.size () )
	    {
		    DRIVERINFO *pInfo = list.front () ;

		    CHString strPath ;
		    strPath.Format ( L"%s\\%s" , (LPCWSTR)TOBSTRT(szDir) , (LPCWSTR)TOBSTRT(pInfo->strName) ) ;

		    if ( ! strPath.CompareNoCase ( strName ) )
		    {
			    if(GetFileAttributes(TOBSTRT(strName)) != -1L)
                {
                    SetInstanceInfo ( pInstance , pInfo , szDir ) ;

			        delete pInfo ;
    		        list.pop_front () ;

			        hrFoundIt = WBEM_S_NO_ERROR ;
                    break;
                }
		    }

		    delete pInfo ;
		    list.pop_front () ;
	    }
    }
    else
    {
        hrFoundIt = hres;
    }

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif

	return hrFoundIt;
}

// I thought about putting szSysDir into a member var, but this way we'll save
// a little memory at the expense of a (very) slight degredation in performance.

void CWin32CodecFile::SetInstanceInfo (

	CInstance *pInstance,
	DRIVERINFO *pInfo,
	LPCTSTR szSysDir
)
{
	CHString strPath;
	strPath.Format ( L"%s\\%s", (LPCWSTR) TOBSTRT(szSysDir) , (LPCWSTR) TOBSTRT(pInfo->strName) ) ;

	pInstance->SetCHString ( IDS_Name , strPath ) ;
	pInstance->SetCHString ( IDS_Description , pInfo->strDesc ) ;
	pInstance->SetWCHARSplat ( IDS_Group , pInfo->bAudio ? L"Audio" : L"Video" ) ;
	pInstance->SetWCHARSplat ( IDS_CreationClassName , PROPSET_NAME_CODECFILE ) ;
}


BOOL AlreadyInList (

	DRIVERLIST *pList,
	LPCTSTR szName
)
{
	CHString chstrTmp;
    chstrTmp = szName;
    chstrTmp.MakeUpper();
    for ( DRIVERLIST_ITERATOR i = pList->begin() ; i != pList->end() ; ++ i )
	{
		DRIVERINFO *pInfo = *i ;

		if ( pInfo->strName == chstrTmp )
		{
			return TRUE ;
		}
	}

	return FALSE ;
}

#ifdef NTONLY
HRESULT CWin32CodecFile :: BuildDriverListNT ( DRIVERLIST *pList )
{
	CRegistry regDrivers32 ;

	LONG lRet = regDrivers32.Open (

		HKEY_LOCAL_MACHINE ,
		_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32") ,
		KEY_READ
	) ;

	if ( lRet != ERROR_SUCCESS )
	{
		return WinErrorToWBEMhResult ( lRet ) ;
	}

	// We won't fail if we can't get the description.

	CRegistry regDriversDesc ;

	regDriversDesc.Open (

		HKEY_LOCAL_MACHINE,
		_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc"),
		KEY_READ
	);

	int	nKeys = regDrivers32.GetValueCount();

	// A DWORD thanks to EnumerateAndGetValues using a
	// DWORD& even though it doesn't change the value!!!
	CHString strValueName ;
    CHString strValue ;
    CHString chstrTmp ;

	for ( DWORD iKey = 0; iKey < nKeys ; iKey ++ )
	{
		TCHAR *szValueName ;
		BYTE *szValue ;

		if ( regDrivers32.EnumerateAndGetValues ( iKey , szValueName , szValue ) != ERROR_SUCCESS )
		{
			continue ;
		}

		// Get rid of szValue and szValue.

		try
		{
			strValueName = szValueName ;
		}
		catch ( ... )
		{
	        delete [] szValueName ;

			throw ;
		}

        delete [] szValueName;

		try
		{
			strValue = (LPCTSTR) szValue ;
		}
		catch ( ... )
		{
	        delete [] szValue ;

			throw ;
		}

	    delete [] szValue ;

        if ( AlreadyInList ( pList , ( LPCTSTR ) strValue ) )
		{
            continue ;
		}

		DRIVERINFO *pInfo = new DRIVERINFO ;
		if ( pInfo )
		{
			try
			{

	// Name has to start with MSACM. (audio) or VIDC. (video) to be a codec.

				strValueName.MakeUpper();
				if ( strValueName.Find ( _T("MSACM.") ) == 0 )
				{
					pInfo->bAudio = TRUE ;
				}
				else if ( strValueName.Find ( _T("VIDC.") ) == 0 )
				{
					pInfo->bAudio = FALSE ;
				}
				else
				{
					delete pInfo ;

					continue ;
				}

	// Sometimes the path appears before the driver name; skip that portion

				chstrTmp = strValue ;
				LONG lLastSlash ;

				if ( ( lLastSlash = chstrTmp.ReverseFind ( _T('\\') ) ) != -1 )
				{
					chstrTmp = chstrTmp.Right ( chstrTmp.GetLength () - lLastSlash - 1 ) ;
				}

                chstrTmp.MakeUpper() ;
				pInfo->strName = chstrTmp ;

				regDriversDesc.GetCurrentKeyValue ( ( LPCTSTR ) strValue , pInfo->strDesc ) ;

			}
			catch ( ... )
			{
				delete pInfo ;

				throw ;
			}

			pList->push_front ( pInfo ) ;
         
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	return WBEM_S_NO_ERROR ;
}
#endif

#ifdef WIN9XONLY
typedef struct _DRIVERLIST_ENUM
{
	DRIVERLIST *pList;
	DRIVERLIST_ITERATOR	iterator;

} DRIVERLIST_ENUM;

BOOL CALLBACK AcmDriverEnumCallback (

	HACMDRIVERID hadid,
	DWORD dwInstance,
	DWORD fdwSupport
)
{
	BOOL t_Continue = FALSE ;

	CMsAcm32Api *pMsAcm32Api = ( CMsAcm32Api * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidMsAcm32Api, NULL ) ;
	if ( pMsAcm32Api )
	{
		// The cast is to get rid of 64-bit compilation warning.
		// Even on 64-bit machines the signature of this function takes a DWORD argument.
		DRIVERLIST_ENUM	*pData = (DRIVERLIST_ENUM *) (DWORD_PTR)dwInstance;
		DRIVERINFO *pDriver = *pData->iterator;

		ACMDRIVERDETAILS info;
		info.cbStruct = sizeof(info);

		MMRESULT res = pMsAcm32Api->MsAcm32acmDriverDetails ( hadid , & info, 0 ) ;

	// Skip if the name is "Microsoft PCM Converter" since it doesn't have
	// a file.

		if ( res == 0 && lstrcmpi ( info.szLongName, _T("Microsoft PCM Converter") ) )
		{
			pDriver->strDesc = info.szLongName ;
			pData->iterator ++ ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidMsAcm32Api , pMsAcm32Api ) ;

		t_Continue = pData->iterator != pData->pList->end () ;
	}

	// We return FALSE if we're at the end of the list so we don't keep
	// enuming.

	return t_Continue ;
}

HRESULT CWin32CodecFile :: BuildDriverList9x ( DRIVERLIST *pList )
{
	CRegistry regDrivers ;

	LONG lRet = regDrivers.OpenCurrentUser (

		L"Software\\Microsoft\\Multimedia\\Audio Compression Manager\\Priority v4.00",
		KEY_READ
	) ;

// First do the audio codecs.

	if ( lRet != ERROR_SUCCESS )
	{
		return WinErrorToWBEMhResult(lRet);
	}

// First try to get these out of the registry.  If we don't find any,
// we'll look in system.ini.

	for ( int iPriority = 1 ; ; iPriority ++ )
	{
		CHString strName ;
		strName.Format( L"Priority%d" , iPriority ) ;

		CHString strValue ;
		if ( regDrivers.GetCurrentKeyValue ( strName , strValue ) != ERROR_SUCCESS )
		{
			break;
		}

// Get past "#, "

		strValue = strValue.Mid(3);

// The internal PCM converter doesn't have a filename, so skip it.

		if ( ! _wcsicmp( strValue , L"Internal PCM Converter" ) )
		{
			continue;
		}

// Get the filename of the driver.

		TCHAR szDLL [ MAX_PATH ] ;

		GetPrivateProfileString (

			_T("drivers32") ,
			TOBSTRT(strValue) ,
			_T("") ,
			szDLL ,
			sizeof ( szDLL ) / sizeof(TCHAR) ,
			_T("system.ini")
		) ;

		// Some drivers are dumb and put in c:\windows\system before
		// their filename.

		TCHAR *pszFilename = _tcsrchr(szDLL, '\\') ;

		if ( ! pszFilename )
		{
			pszFilename = szDLL ;
		}
		else
		{
			pszFilename ++ ;
		}

		if ( ! * pszFilename || (AlreadyInList ( pList, pszFilename ) ) )
		{
			continue ;
		}

		DRIVERINFO *pInfo = new DRIVERINFO ;
		if ( pInfo )
		{
			try
			{
				_tcsupr(pszFilename);
                pInfo->strName = pszFilename ;
				pInfo->bAudio = TRUE ;
			}
			catch ( ... )
			{
				delete pInfo ;

				throw ;
			}

			pList->push_back ( pInfo ) ;
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	// If we didn't find any, look in system.ini.

	if ( ! pList->size () )
	{
		TCHAR szKeys [ 1024 ];

		GetPrivateProfileString (

			_T("Drivers32"),
			NULL,
			_T(""),
			szKeys,
			sizeof(szKeys) / sizeof(TCHAR),
			_T("system.ini")
		);

		TCHAR *pszCurrentKey = szKeys ;

		while ( *pszCurrentKey )
		{
			_tcsupr ( pszCurrentKey ) ;

			// Make sure it's an audio codec.

			if ( _tcsstr ( pszCurrentKey , _T("MSACM.") ) == pszCurrentKey )
			{
				TCHAR szDLL [ MAX_PATH ] ;

				// Get the filename of the driver.

				GetPrivateProfileString (

					_T("drivers32") ,
					pszCurrentKey ,
					_T("") ,
					szDLL ,
					sizeof(szDLL) / sizeof(TCHAR) ,
					_T("system.ini")
				) ;

				// Some drivers are dumb and put in c:\windows\system before
				// their filename.

				TCHAR *pszFilename = _tcsrchr ( szDLL , '\\' ) ;
				if ( ! pszFilename )
				{
					pszFilename = szDLL ;
				}
				else
				{
					pszFilename ++ ;
				}

				if ( ! * pszFilename || (AlreadyInList( pList , pszFilename ) ) )
				{
					continue;
				}

				DRIVERINFO *pInfo = new DRIVERINFO;
				if ( pInfo )
				{
					try
					{
						pInfo->strName = pszFilename;
						pInfo->bAudio = TRUE;

					}
					catch ( ... )
					{
						delete pInfo ;

						throw ;
					}

					pList->push_back(pInfo);
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}

			pszCurrentKey += lstrlen(pszCurrentKey) + 1;
		}

	}

// Only match up the descriptions with the list if there's anything in the
// list.

	if ( pList->size() )
	{
// Now get the audio codec descriptions.

		DRIVERLIST_ENUM data;

		data.pList = pList;
		data.iterator = pList->begin();

// We don't care if this succeeds or not since it's just the codec
// descriptions.

		CMsAcm32Api *pMsAcm32Api = ( CMsAcm32Api * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidMsAcm32Api, NULL ) ;
		if ( pMsAcm32Api )
		{
			pMsAcm32Api->MsAcm32acmDriverEnum (

				AcmDriverEnumCallback,
				(DWORD) &data,
				ACM_DRIVERENUMF_DISABLED
			) ;

			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidMsAcm32Api , pMsAcm32Api ) ;
		}
	}

	lRet = regDrivers.Open (

		HKEY_LOCAL_MACHINE,
		L"System\\CurrentControlSet\\control\\MediaResources\\icm",
		KEY_READ
	) ;

	// Do the video codecs.
	if ( lRet != ERROR_SUCCESS )
	{
		return WinErrorToWBEMhResult ( lRet ) ;
	}

	do
	{
		CHString strDriver ;
		regDrivers.GetCurrentSubKeyValue ( L"Driver" , strDriver ) ;

		CHString strDescription ;
		regDrivers.GetCurrentSubKeyValue ( L"Description" , strDescription ) ;

		if ( ! strDriver.IsEmpty () &&  (!AlreadyInList ( pList, TOBSTRT ( strDriver ) ) ) )
		{
			DRIVERINFO *pInfo = new DRIVERINFO ;
			if ( pInfo )
			{
				try
				{
					pInfo->strName = strDriver ;
					pInfo->strDesc = strDescription ;
				}
				catch ( ... )
				{
					delete pInfo ;

					throw ;
				}

				pList->push_front ( pInfo ) ;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

	} while ( regDrivers.NextSubKey () == ERROR_SUCCESS ) ;

	return WBEM_S_NO_ERROR ;
}
#endif

#ifdef WIN9XONLY
BOOL CWin32CodecFile::IsOneOfMe (

	LPWIN32_FIND_DATAA pstFindData ,
	LPCSTR strFullPathName
)
{
    DRIVERLIST list ;

    BuildDriverList9x ( & list ) ;
    list.EliminateDups();
#ifndef _UNICODE

    // If it is in the list, it is a codec file, so it is one of us.
    // strFullPathName will contain a full pathname, but the strName
    // that AlreadInList compares it to is only a filename.ext.  So
    // we need to find the last final \ in the pathname, and take
    // everything after that as the second arg to AlreadyInList.

    char strTemp[MAX_PATH];
    char *pc = NULL;
    pc = strrchr(strFullPathName, '\\');
    if(pc != NULL)
    {
        strcpy(strTemp, pc+1);
    }
    else
    {
        strcpy(strTemp, strFullPathName);
    }

    if(AlreadyInList(&list, strTemp) )
    {
        return TRUE ;
    }
#endif

    return FALSE ;
}
#endif


#ifdef NTONLY
BOOL CWin32CodecFile::IsOneOfMe (

	LPWIN32_FIND_DATAW pstFindData,
	const WCHAR* wstrFullPathName
)
{
    DRIVERLIST list ;

    if(SUCCEEDED(BuildDriverListNT ( & list ) ) )
    {
        list.EliminateDups();

        // If it is in the list, it is a codec file, so it is one of us.
        // strFullPathName will contain a full pathname, but the strName
        // that AlreadInList compares it to is only a filename.ext.  So
        // we need to find the last final \ in the pathname, and take
        // everything after that as the second arg to AlreadyInList.

        WCHAR strTemp[MAX_PATH];
        WCHAR *pwc = NULL;
        pwc = wcsrchr(wstrFullPathName, L'\\');
        if(pwc != NULL)
        {
            wcscpy(strTemp, pwc+1);
        }
        else
        {
            wcscpy(strTemp, wstrFullPathName);
        }

        if(AlreadyInList(&list, strTemp))
        {
            return TRUE ;
        }
    }

    return FALSE ;
}

#endif

// When one does a query of this class, the query in implement_logicalfile.cpp
// runs.  It calls IsOneOfMe.  If that function returns true, LoadPropertyValues
// out of implement_logicalfile is called.  It loads logical file properties, but
// not properties specific to this class.  It does, however, before returning,
// make a call to GetExtendedProperties (a virtual), which will come in here.
void CWin32CodecFile::GetExtendedProperties(CInstance* a_pInst,
                                            long a_lFlags)
{
    DRIVERLIST list;
    TCHAR szTemp[MAX_PATH];
    LONG lPos = -1;
	CHString chstrFilePathName;
    TCHAR szFilePathName[_MAX_PATH];
    HRESULT hr = E_FAIL;
    if(a_pInst->GetCHString(IDS_Name, chstrFilePathName))
    {
#ifdef NTONLY
        hr = BuildDriverListNT(&list);
#endif
#ifdef WIN9XONLY
        hr = BuildDriverList9x(&list);
#endif
        if(SUCCEEDED(hr))
        {
            list.EliminateDups();
            _tcscpy(szFilePathName, TOBSTRT(chstrFilePathName));
            // need the position in the list of the driver we are interested in.
            // pInfo (used below) only contains filename.exe...
            TCHAR *ptc = NULL;
            ptc = _tcsrchr(szFilePathName, L'\\');
            if(ptc != NULL)
            {
                _tcscpy(szTemp, ptc+1);
            }
            else
            {
                _tcscpy(szTemp, szFilePathName);
            }

            DRIVERINFO *pInfo = NULL;
            if((pInfo = GetDriverInfoFromList(&list, TOBSTRT(szTemp))) != NULL)
            {
                TCHAR szDir[MAX_PATH];
	            GetSystemDirectory(szDir, sizeof(szDir)/sizeof(TCHAR));
                SetInstanceInfo(a_pInst, pInfo, szDir);
            }
            // pInfo points to a member of list (which may, after the call
            // to GetDriverInfoFromList, be shorter than it was).  list gets
            // cleaned up/deleted via the DRIVERLIST class's destructor, so
            // we don't leak here.
        }
    }
}

DRIVERINFO* CWin32CodecFile::GetDriverInfoFromList(DRIVERLIST *plist, LPCWSTR strName)
{
    DRIVERINFO *pInfo = NULL;
    while(plist->size())
	{
        pInfo = plist->front();
        CHString chstrTemp((LPCWSTR)TOBSTRT(pInfo->strName));
		if(!chstrTemp.CompareNoCase(strName))
		{
            break;
		}
        else
        {
            delete pInfo;
            pInfo = NULL;
    		plist->pop_front();
        }
	}
    return pInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\computersystem.h ===
//=================================================================

//

// ComputerSystem.h -- Computer System property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
// 				 09/12/97	a-sanjes		GetCompSysInfo takes param.
//               10/23/97   jennymc         Moved to new framework
//
//=================================================================


#include "ServerDefs0.h"
#include "sid.h"


// Property set identification
//============================
#define PROPSET_NAME_COMPSYS  L"Win32_ComputerSystem"

#define	NTCS_PERF_DATA_SYSTEM_INDEX_STR		_T("2")
#define	NTCS_PERF_DATA_SYSTEM_INDEX			2
#define	NTCS_PERF_DATA_SYSTEMUPTIME_INDEX	674

typedef struct _SV_ROLES {
    
    LPCWSTR		pwStrRole;
    DWORD	    dwRoleMask ;
    
} SV_ROLES ;

class CWin32ComputerSystem : public Provider 
{
public:

        // Constructor/destructor
        //=======================

	CWin32ComputerSystem(const CHString& name, LPCWSTR pszNamespace);
	~CWin32ComputerSystem() ;

        // Functions provide properties with current values
        //=================================================

	virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &pQuery
);
	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );
	virtual HRESULT ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName,
								CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/);

        // Utility function(s)
        //====================
    HRESULT GetCompSysInfo( CInstance *pInstance) ;
#ifdef NTONLY
    HRESULT GetCompSysInfoNT(CInstance *pInstance) ;
#endif
#if NTONLY >= 5
    void SetUserName(
        CInstance* pInstance);
    bool GetUserOnThread(
        CSid& sidUserOnThread);
    bool GetLoggedOnUserViaTS(
        CSid& sidLoggedOnUser);
    bool GetLoggedOnUserViaImpersonation(
        CSid& sidLoggedOnUser);
#endif
#ifdef WIN9XONLY
    HRESULT GetCompSysInfoWin95(CInstance *pInstance) ;
#endif

	void GetTimeZoneInfo(CInstance *pInstance);

	HRESULT GetAccount ( HANDLE a_TokenHandle , CHString &a_Domain , CHString &a_User ) ;
	HRESULT GetUserAccount ( CHString &a_Domain , CHString &a_User ) ;

private:

		// Helper time conversion function
    HRESULT GetStartupOptions(CInstance *pInstance);
    void GetOEMInfo(CInstance *pInstance);
    DWORD LoadOperatingSystems(LPCTSTR szIniFile, SAFEARRAY **saNames, SAFEARRAY **saDirs);
    HRESULT PutInstance(const CInstance &pInstance, long lFlags = 0L);
    
	void	SetRoles(CInstance *pInstance, DWORD dwType);
	HRESULT GetRoles (

		const CInstance &a_rInstance, 
		DWORD *a_pdwRoleType
		) ;

	HRESULT SetTimeZoneInfo ( const CInstance &a_rInstance ) ;

	void InitializePropertiestoUnknown ( CInstance *a_pInstance ) ;

    bool UpdatingSystemStartupOptions(
        const CInstance &pInstance);

    HRESULT UpdateSystemStartupOptions(
        const CInstance& pInstance,
        const CHString& chstrFilename);
    
    HRESULT WriteOptionsToIniFile(
        const CHStringArray& rgchstrOptions,
        const CHString& chstrFilename);

	HRESULT CheckPasswordAndUserName(
		const CInstance& pInstance,
		CInstance *pInParams,
		CHString &a_passwd,
		CHString &a_username);

	HRESULT ExecJoinDomain(
		const CInstance& pInstance,
		CInstance *pInParams,
		CInstance *pOutParams,
		long lFlags /*= 0L*/);
	
	HRESULT ExecRename(
		const CInstance& pInstance,
		CInstance *pInParams,
		CInstance *pOutParams,
		long lFlags /*= 0L*/);
	
	HRESULT ExecUnjoinDomain(
		const CInstance& pInstance,
		CInstance *pInParams,
		CInstance *pOutParams,
		long lFlags /*= 0L*/); 
} ;


#ifdef WIN9XONLY
DWORD GetPrivateProfileSection98(
    LPCTSTR cszSection, 
    TCHAR* buf, 
    DWORD dwSize, 
    LPCTSTR szIniFile);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\computersystem.cpp ===
//=================================================================

//

// ComputerSystem.CPP --Computer system property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//              09/12/97    a-sanjes        GetCompSysInfo takes param.
//              10/23/97    jennymc         Changed to new framework
//
//=================================================================

#include "precomp.h"

#include "perfdata.h"
#include "wbemnetapi32.h"
#include <lmwksta.h>
#include <smartptr.h>
#include "ComputerSystem.h"
#include "implogonuser.h"
#include <comdef.h>
#include "CreateMutexAsProcess.h"
#include <lmcons.h>
#include <lmwksta.h>
#include <lm.h>
#include "Kernel32Api.h"
#include <cominit.h>
#include "WMI_FilePrivateProfile.h"


//#include <srvapi.h>

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
#include <ntexapi.h>
#include "NVRam.h"
#endif

#include "smbios.h"
#include "smbstruc.h"

#include "KUserdata.h"

#include <fileattributes.h>

#include <wtsapi32.h>
#include <..\..\framework\provexpt\include\provexpt.h>


#define PROF_SECT_SIZE 3000



const DWORD SM_BIOS_HARDWARE_SECURITY_UNKNOWN = 3 ;
#define GFS_NEARESTMEGRAMSIZE   0x1794

#define REGKEY_TIMEZONE_INFO    L"System\\CurrentControlSet\\Control\\TimeZoneInformation"
#define REGVAL_TZNOAUTOTIME     L"DisableAutoDaylightTimeSet"


//
static SV_ROLES g_SvRoles[] =  {
    
    { IDS_LM_Workstation,           SV_TYPE_WORKSTATION },
    { IDS_LM_Server,                SV_TYPE_SERVER  },
    { IDS_SQLServer,                SV_TYPE_SQLSERVER   },
    { IDS_Domain_Controller,        SV_TYPE_DOMAIN_CTRL     },
    { IDS_Domain_Backup_Controller, SV_TYPE_DOMAIN_BAKCTRL  },
    { IDS_Timesource,               SV_TYPE_TIME_SOURCE },
    { IDS_AFP,                      SV_TYPE_AFP },
    { IDS_Novell,                   SV_TYPE_NOVELL  },
    { IDS_Domain_Member,            SV_TYPE_DOMAIN_MEMBER   },
    { IDS_Local_List_Only,          SV_TYPE_LOCAL_LIST_ONLY },
    { IDS_Print,                    SV_TYPE_PRINTQ_SERVER   },
    { IDS_DialIn,                   SV_TYPE_DIALIN_SERVER   },
    { IDS_Xenix_Server,             SV_TYPE_XENIX_SERVER    },
    { IDS_MFPN,                     SV_TYPE_SERVER_MFPN },
    { IDS_NT,                       SV_TYPE_NT  },
    { IDS_WFW,                      SV_TYPE_WFW },
    { IDS_Server_NT,                SV_TYPE_SERVER_NT   },
    { IDS_Potential_Browser,        SV_TYPE_POTENTIAL_BROWSER   },
    { IDS_Backup_Browser,           SV_TYPE_BACKUP_BROWSER  },
    { IDS_Master_Browser,           SV_TYPE_MASTER_BROWSER  },
    { IDS_Domain_Master,            SV_TYPE_DOMAIN_MASTER   },
    { IDS_Domain_Enum,              SV_TYPE_DOMAIN_ENUM },
    { IDS_Windows_9x,               SV_TYPE_WINDOWS },
    { IDS_DFS,                      SV_TYPE_DFS }
} ;


CWin32ComputerSystem MyCWin32ComputerSystemSet(PROPSET_NAME_COMPSYS, IDS_CimWin32Namespace);
/*****************************************************************************
*
*  FUNCTION    : GetAllocatedProfileString ()
*
*  DESCRIPTION : Gets a profile string allocated on heap
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

TCHAR *GetAllocatedProfileString (
                                  
                                  const CHString &a_Section ,
                                  const CHString &a_Key ,
                                  const CHString &a_FileName
                                  )
{
    TCHAR *szDefault = NULL ;
    DWORD dwRet ;
    DWORD dwSize = 1024 ;
    
    do
    {
        if ( szDefault != NULL )
        {
            delete [] szDefault ;
        }
        
        dwSize *= 2 ;
        
        szDefault = new TCHAR [ dwSize ] ;
        if ( szDefault )
        {
#ifdef NTONLY
            dwRet = WMI_FILE_GetPrivateProfileStringW (
                
                a_Section,
                a_Key,
                L"~~~",
                szDefault,
                dwSize/sizeof(WCHAR),  // GPPS works in chars, not bytes
                a_FileName
                ) ;
#else
            dwRet = GetPrivateProfileString (
                
                TOBSTRT(a_Section),
                TOBSTRT(a_Key),
                _T("~~~"),
                szDefault,
                dwSize/sizeof(TCHAR),  // GPPS works in chars, not bytes
                TOBSTRT(a_FileName)
                ) ;
#endif
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
    } while ( dwRet == dwSize - 1 ) ;
    
    return szDefault ;
}

/*****************************************************************************
*
*  FUNCTION    : GetAllocatedProfileSection ()
*
*  DESCRIPTION : Gets a profile section allocated on heap
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

TCHAR *GetAllocatedProfileSection (
                                   
                                   const CHString &a_Section ,
                                   const CHString &a_FileName ,
                                   DWORD &a_dwSize
                                   )
{
    DWORD dwSize = 1024 ;
    TCHAR *szOptions = NULL ;
    
    do {
        
        dwSize *= 2;
        
        if ( szOptions != NULL )
        {
            delete [] szOptions ;
        }
        
        szOptions = new TCHAR [ dwSize ] ;
        
        if ( szOptions != NULL )
        {
            
            ZeroMemory ( szOptions , dwSize ) ;
            // Win98 GetPrivateProfileSection broken as of 6/15/98, so hack around it (Win98 only)
            
#ifdef WIN9XONLY
            
            if ( IsWin98 () )
            {
                a_dwSize = GetPrivateProfileSection98 ( TOBSTRT(a_Section), szOptions , dwSize/sizeof(TCHAR), TOBSTRT(a_FileName));
            }
            else
#endif
            {
                a_dwSize = WMI_FILE_GetPrivateProfileSectionW ( a_Section, szOptions, dwSize/sizeof(WCHAR) , a_FileName) ;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
    } while ( a_dwSize == dwSize - 2 ) ;
    
    return szOptions ;
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::CWin32ComputerSystem
*
*  DESCRIPTION : Constructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Registers property set with framework
*
*****************************************************************************/

CWin32ComputerSystem :: CWin32ComputerSystem (
                                              
                                              const CHString &name ,
                                              LPCWSTR pszNamespace
                                              
                                              ) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::~CWin32ComputerSystem
*
*  DESCRIPTION : Destructor
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Deregisters property set from framework
*
*****************************************************************************/
CWin32ComputerSystem :: ~CWin32ComputerSystem()
{
    // Because of performance issues with HKEY_PERFORMANCE_DATA, we close in the
    // destructor so we don't force all the performance counter dlls to get
    // unloaded from memory, and also to prevent an apparent memory leak
    // caused by calling RegCloseKey( HKEY_PERFORMANCE_DATA ).  We use the
    // class since it has its own internal synchronization.  Also, since
    // we are forcing synchronization, we get rid of the chance of an apparent
    // deadlock caused by one thread loading the performance counter dlls
    // and another thread unloading the performance counter dlls
    
    // Per raid 48395, we aren't going to shut this at all.
    
#ifdef NTONLY
    //  CPerformanceData perfdata ;
    
    //  perfdata.Close() ;
#endif
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::ExecQuery
*
*  DESCRIPTION : Query support
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem :: ExecQuery (
                                           
                                           MethodContext *pMethodContext,
                                           CFrameworkQuery& pQuery,
                                           long lFlags /*= 0L*/
                                           )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // If all they want is the name, we'll give it to them, else let them call enum.
    
    if ( pQuery.KeysOnly () )
    {
        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
        
        pInstance->SetCHString ( IDS_Name , GetLocalComputerName () ) ;
        hr = pInstance->Commit (  ) ;
    }
    else
    {
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    }
    
    return hr;
}

/*****************************************************************************
*
*  FUNCTION    : GetObject
*
*  DESCRIPTION : Assigns values to property set according to key value
*                already set by framework
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem::GetObject (
                                         
                                         CInstance *pInstance ,
                                         long lFlags,
                                         CFrameworkQuery &pQuery
                                         )
{
    HRESULT hr = WBEM_S_NO_ERROR ;
    
    CHString sComputerName = GetLocalComputerName () ;
    
    CHString sReqName ;
    pInstance->GetCHString ( IDS_Name , sReqName ) ;
    
    if ( sReqName.CompareNoCase ( sComputerName ) != 0 )
    {
        hr = WBEM_E_NOT_FOUND ;
    }
    else
    {
        if ( !pQuery.KeysOnly () )
        {
            hr = GetCompSysInfo ( pInstance ) ;
        }
    }
    
    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::EnumerateInstances
*
*  DESCRIPTION : Creates instance of property set for each logical disk
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     :
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem :: EnumerateInstances (
                                                    
                                                    MethodContext *pMethodContext ,
                                                    long lFlags /*= 0L*/
                                                    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
    
    CHString sComputerName ;
    sComputerName = GetLocalComputerName () ;
    
    pInstance->SetCHString ( IDS_Name, sComputerName ) ;
    
    if ( SUCCEEDED ( hr = GetCompSysInfo ( pInstance ) ) )
    {
        HRESULT t_hr = pInstance->Commit ( ) ;
        if ( FAILED ( t_hr ) )
        {
            hr = t_hr ;
        }
    }
    else
    {
        hr = WBEM_E_FAILED ;
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////

HRESULT CWin32ComputerSystem::GetCompSysInfo ( CInstance *pInstance )
{
    HRESULT t_hr = WBEM_S_NO_ERROR ;
    InitializePropertiestoUnknown ( pInstance ) ;
    
    SYSTEM_INFO SysInfo ;
    
    pInstance->SetCharSplat ( IDS_CreationClassName , PROPSET_NAME_COMPSYS ) ;
    
    pInstance->SetCHString ( IDS_Caption , GetLocalComputerName () ) ;
    
    // a few properties that come under the heading of "well, duh"
    
    pInstance->Setbool ( IDS_BootRomSupported , true ) ;
    pInstance->SetCHString ( IDS_Status , IDS_CfgMgrDeviceStatus_OK ) ;
    
    //============================================================
    // Get common properties first
    //============================================================
    CHString t_UserName ;
    CHString t_DomainName ;
    CHString t_UserDomain ;
#if NTONLY >= 5
SetUserName(pInstance);    
#endif
    
#ifdef WIN9XONLY
    if ( SUCCEEDED ( GetUserAccount ( t_DomainName , t_UserName ) ) )
    {
        if ( ! t_DomainName.IsEmpty () )
        {
            t_UserDomain = t_DomainName + _TEXT ( "\\" ) + t_UserName ;
        }
        else
        {
            t_UserDomain = t_UserName ;
        }
        
        pInstance->SetCHString ( IDS_UserName , t_UserDomain ) ;
    }
#endif
    
    // Get the amount of physical memory
    //==================================
#ifdef NTONLY
    if( IsWinNT5() )
    {
        CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
        if(pKernel32 != NULL)
        {
            
            MEMORYSTATUSEX  stMemoryVLM;
            stMemoryVLM.dwLength = sizeof( MEMORYSTATUSEX );
            
            BOOL bRetCode;
            if(pKernel32->GlobalMemoryStatusEx(&stMemoryVLM, &bRetCode) && bRetCode)
            {
                pInstance->SetWBEMINT64 ( IDS_TotalPhysicalMemory, (const __int64) stMemoryVLM.ullTotalPhys );
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
            pKernel32 = NULL;
        }
    }
    else
    {
        MEMORYSTATUS stMemory;
        stMemory.dwLength = sizeof ( MEMORYSTATUS ) ;
        
        GlobalMemoryStatus(&stMemory);
        pInstance->SetWBEMINT64 ( IDS_TotalPhysicalMemory, (const __int64) stMemory.dwTotalPhys );
    }
    
#else
    {
        CCim32NetApi *t_pCim32NetApi = HoldSingleCim32NetPtr :: GetCim32NetApiPtr () ;
        try
        {
            if ( t_pCim32NetApi )
            {
                DWORD t_dwMemorySize = t_pCim32NetApi->GetWin9XGetFreeSpace ( GFS_NEARESTMEGRAMSIZE ) ;
                pInstance->SetWBEMINT64 ( IDS_TotalPhysicalMemory, (const __int64) t_dwMemorySize );
            }
        }
        catch ( ... )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
            t_pCim32NetApi = NULL ;
            throw ;
        }
        
        if ( t_pCim32NetApi )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
            t_pCim32NetApi = NULL ;
        }
    }
#endif
    
    // Timezone
    
    GetTimeZoneInfo ( pInstance ) ;
    
    // Infra red
    
    CConfigManager cfgManager ;
    CDeviceCollection deviceList ;
    BOOL bInfrared = FALSE ;
    
    if ( cfgManager.GetDeviceListFilterByClass ( deviceList , L"Infrared" ) )
    {
        REFPTR_POSITION pos ;
        
        deviceList.BeginEnum ( pos ) ;
        
        if ( deviceList.GetSize () )
        {
            bInfrared = TRUE ;
        }
        
        deviceList.EndEnum () ;
    }
    
    pInstance->SetDWORD ( IDS_InfraredSupported , bInfrared ) ;
    
    GetSystemInfo ( & SysInfo ) ;
    CHString SystemType;
    
#ifdef NTONLY
    KUserdata ku ;
    
    if(( SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) && ku.IsNec98() )
    {
        SystemType = IDS_ProcessorX86Nec98;
    }
    else
#endif
        
    {
        switch ( SysInfo.wProcessorArchitecture )
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            {
                SystemType = IDS_ProcessorX86 ;
            }
            break ;
            
            
        case PROCESSOR_ARCHITECTURE_MIPS:
            {
                SystemType = IDS_ProcessorMIPS ;
            }
            break ;
            
            
        case PROCESSOR_ARCHITECTURE_ALPHA:
            {
                SystemType = IDS_ProcessorALPHA ;
            }
            break ;
            
            
        case PROCESSOR_ARCHITECTURE_PPC:
            {
                SystemType = IDS_ProcessorPowerPC ;
            }
            break ;
            
        case PROCESSOR_ARCHITECTURE_IA64:
            {
                SystemType = IDS_ProcessorIA64 ;
            }
            break ;

        case PROCESSOR_ARCHITECTURE_AMD64:
            {
                SystemType = IDS_ProcessorAMD64 ;
            }
            break;

        default:
            {
                SystemType = IDS_ProcessorUnknown ;
            }
            break ;
        }
    }
    
    pInstance->SetDWORD ( IDS_NumberOfProcessors , SysInfo.dwNumberOfProcessors ) ;
    pInstance->SetCHString ( IDS_SystemType , SystemType ) ;
    
    //============================================================
    // Get the system bootup info to see if we're in a clean state
    // or not
    //============================================================
    switch ( GetSystemMetrics ( SM_CLEANBOOT ) )
    {
    case 0:
        {
            pInstance->SetCHString ( IDS_BootupState , IDS_BootupStateNormal ) ;
        }
        break ;
        
    case 1:
        {
            pInstance->SetCHString ( IDS_BootupState , IDS_BootupStateFailSafe ) ;
        }
        break ;
        
    case 2:
        {
            pInstance->SetCHString ( IDS_BootupState , IDS_BootupStateFailSafeWithNetBoot ) ;
        }
        break ;
    };
    
    // SMBIOS qualified properties for this class
    {
        CSMBios smbios;
        
        if ( smbios.Init () )
        {
            int i ;
            WCHAR tempstr[ MIF_STRING_LENGTH + 1];
            
            //PSYSTEMINFO   psi = (PSYSTEMINFO) smbios.GetFirstStruct( 1 );
            PSTLIST pstl = smbios.GetStructList(1);
            
            if (pstl)
            {
                PSYSTEMINFO psi = (PSYSTEMINFO) pstl->pshf;
                
                smbios.GetStringAtOffset( (PSHF) psi, tempstr, psi->Manufacturer );
                if ( *tempstr && *tempstr != 0x20 )
                {
                    pInstance->SetCHString( L"Manufacturer", tempstr );
                }
                
                smbios.GetStringAtOffset( (PSHF) psi, tempstr, psi->Product_Name );
                if ( *tempstr && *tempstr != 0x20 )
                {
                    pInstance->SetCHString( IDS_Model, tempstr );
                }
                
                if ( smbios.GetVersion( ) > 0x00020000 && psi->Length >= sizeof( SYSTEMINFO ) )
                {
                    pInstance->SetByte( L"WakeUpType", psi->Wakeup_Type );
                }
                else
                {
                    pInstance->SetByte( L"WakeUpType", 2 ); // Unknown
                }
            }
            
            //POEMSTRINGS   pos = (POEMSTRINGS) smbios.GetFirstStruct( 11 );
            pstl = smbios.GetStructList(11);
            
            if (pstl)
            {
                POEMSTRINGS pos = (POEMSTRINGS) pstl->pshf;
                SAFEARRAYBOUND sab ;
                variant_t vValue;
                sab.lLbound = 0 ;
                sab.cElements = pos->Count ;
                
                
                V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR, 1, &sab );
                if ( V_ARRAY(&vValue) )
                {
                    vValue.vt = VT_BSTR | VT_ARRAY;
                    for ( i = 0 ; i < pos->Count ; i++ )
                    {
                        int len = smbios.GetStringAtOffset ( ( PSHF ) pos , tempstr , i + 1 );
                        SafeArrayPutElement ( V_ARRAY(&vValue), (long *) & i, ( BSTR ) _bstr_t ( tempstr ) ) ;
                    }
                    
                    pInstance->SetVariant ( L"OEMStringArray", vValue ) ;
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            
            //PSYSTEMRESET psr = (PSYSTEMRESET) smbios.GetFirstStruct( 23 );
            pstl = smbios.GetStructList(23);
            
            if (pstl)
            {
                PSYSTEMRESET psr = (PSYSTEMRESET) pstl->pshf;
                __int64 pause;
                
                pInstance->SetDWORD( L"BootOptionOnLimit", ( psr->Capabilities & 0x18 ) >> 3 );
                pInstance->SetDWORD( L"BootOptionOnWatchDog", ( psr->Capabilities & 0x06 ) >> 1 );
                pInstance->SetWBEMINT16( L"ResetCount", psr->ResetCount );
                pInstance->SetWBEMINT16( L"ResetLimit", psr->ResetLimit );
                pause = psr->Timeout;
                if ( pause != -1 )
                {
                    pause *= 60000; // change minutes to milliseconds
                }
                
                pInstance->SetWBEMINT64( L"PauseAfterReset", pause );
            }
            
            //PHARDWARESECURITY phs = (PHARDWARESECURITY) smbios.GetFirstStruct( 24 );
            pstl = smbios.GetStructList(24);
            if (pstl)
            {
                PHARDWARESECURITY phs = (PHARDWARESECURITY) pstl->pshf;
                
                pInstance->SetDWORD( L"PowerOnPasswordStatus",      ( phs->SecuritySettings & 0xc0 ) >> 6 );
                pInstance->SetDWORD( L"KeyboardPasswordStatus",     ( phs->SecuritySettings & 0x30 ) >> 4 );
                pInstance->SetDWORD( L"AdminPasswordStatus",        ( phs->SecuritySettings & 0x0c ) >> 2 );
                pInstance->SetDWORD( L"FrontPanelResetStatus",      ( phs->SecuritySettings & 0x03 ) );
            }
            
            //PENCLOSURE pe = (PENCLOSURE) smbios.GetFirstStruct( 3 );
            pstl = smbios.GetStructList(3);
            if (pstl)
            {
                PENCLOSURE pe = (PENCLOSURE) pstl->pshf;
                
                if ( smbios.GetVersion () > 0x00020000 && pe->Length >= 13 )
                {
                    pInstance->SetByte ( L"ChassisBootupState", pe->Bootup_State );
                    pInstance->SetByte ( L"PowerSupplyState", pe->Power_Supply_State );
                    pInstance->SetByte ( L"ThermalState", pe->Thermal_State );
                }
            }
        }
    }
    
    // If these aren't set from SMBIOS then try ACPI reg entry
    
    if ( pInstance->IsNull ( L"Manufacturer" ) || pInstance->IsNull ( IDS_Model ) )
    {
        TCHAR szAcpiOem[MIF_STRING_LENGTH + 1];
        TCHAR szAcpiProduct[MIF_STRING_LENGTH + 1];
        static const TCHAR szRSDT[] = _T("Hardware\\ACPI\\DSDT");
        HKEY hkeyTable = NULL;
        
        if (ERROR_SUCCESS == RegOpenKeyEx ( HKEY_LOCAL_MACHINE , szRSDT , 0 , MAXIMUM_ALLOWED , & hkeyTable ) &&
            ERROR_SUCCESS == RegEnumKey ( hkeyTable , 0 , szAcpiOem , sizeof ( szAcpiOem ) / sizeof(TCHAR) ) )
        {
            HKEY hkeyOEM = 0 ;
            if ( pInstance->IsNull ( L"Manufacturer" ) )
            {
                pInstance->SetCHString( L"Manufacturer", szAcpiOem ) ;
            }
            if ( pInstance->IsNull ( IDS_Model ) )
            {
                if (ERROR_SUCCESS == RegOpenKeyEx ( hkeyTable , szAcpiOem , 0 , MAXIMUM_ALLOWED , & hkeyOEM ) &&
                    ERROR_SUCCESS == RegEnumKey ( hkeyOEM , 0 , szAcpiProduct , sizeof ( szAcpiProduct ) / sizeof(TCHAR) ) )
                {
                    pInstance->SetCHString ( IDS_Model , szAcpiProduct );
                }
                
                if ( hkeyOEM )
                {
                    RegCloseKey ( hkeyOEM ) ;
                }
            }
        }
        
        if ( hkeyTable )
        {
            RegCloseKey ( hkeyTable ) ;
        }
    }
    
    // Get OS-specific properties
    //===========================
    
#ifdef NTONLY
    
    t_hr = GetCompSysInfoNT ( pInstance ) ;
    
#endif
    
#ifdef WIN9XONLY
    
    t_hr = GetCompSysInfoWin95 ( pInstance ) ;
    
#endif
    
    return t_hr ;
}

//////////////////////////////////////////////////////////////////////
#ifdef NTONLY
HRESULT CWin32ComputerSystem::GetCompSysInfoNT(CInstance *pInstance)
{
    HRESULT t_hr = WBEM_S_NO_ERROR ;
    // no power management in any NTs <= 4
    if (GetPlatformMajorVersion() <= 4)
    {
        pInstance->Setbool(IDS_PowerManagementSupported, false);
        //      pInstance->Setbool(IDS_PowerManagementEnabled, false);
    }
    else
    {
        // dunno yet.
        LogMessage(IDS_LogNoAPMForNT5);
    }
    
    // auto reset - My computer, properties, start up tab, "automatic reboot"
    // I guess...
    // note that this doesn't seem to appear under HKEY_CURRENT_CONTROL
    pInstance->Setbool(IDS_AutomaticResetCapability, true);
    
    CRegistry RegInfo ;
    
    DWORD dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCrashControl,
        KEY_READ
        ) ;
    
    if ( dwRet == ERROR_SUCCESS )
    {
        DWORD duhWord;
        if (RegInfo.GetCurrentKeyValue(IDS_RegAutoRebootKey, duhWord) == ERROR_SUCCESS)
        {
            pInstance->Setbool(IDS_AutomaticResetBootOption, (bool)duhWord);
        }
        else
        {
            pInstance->Setbool(IDS_AutomaticResetBootOption, false);
        }
        
        RegInfo.Close();
    }
    else
    {
        pInstance->Setbool(IDS_AutomaticResetBootOption, false);
    }
    
    // best guess for "Primary Owner" - it shows up under "My Computer"
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCurrentNTVersion,
        KEY_READ
        ) ;
    
    if ( dwRet == ERROR_SUCCESS )
    {
        CHString sTemp ;
        
        if ( RegInfo.GetCurrentKeyValue(IDS_RegRegisteredOwnerKey, sTemp) == ERROR_SUCCESS )
        {
            pInstance->SetCHString ( IDS_PrimaryOwner , sTemp ) ;
        }
        
        RegInfo.Close () ;
    }
    
    // Raid 14139
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegBiosSystem,
        KEY_READ
        ) ;
    
    if (  dwRet == ERROR_SUCCESS )
    {
        CHString sTemp ;
        
        dwRet = RegInfo.GetCurrentKeyValue ( IDS_RegIdentifierKey , sTemp ) ;
        if ( dwRet == ERROR_SUCCESS )
        {
            pInstance->SetCHString ( IDS_Description , sTemp ) ;
        }
    }
    
    CNetAPI32 NetAPI;
    
    if ( NetAPI.Init () == ERROR_SUCCESS )
    {
        NET_API_STATUS t_status ;
#if NTONLY >= 5
        
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *t_pDsInfo = 0;
        
        t_status = NetAPI.DSRoleGetPrimaryDomainInfo(
            NULL,
            DsRolePrimaryDomainInfoBasic,
            (PBYTE *)&t_pDsInfo ) ;
        
        if( t_status == NERR_Success && t_pDsInfo )
        {
            try
            {
                switch( t_pDsInfo->MachineRole )
                {
                case DsRole_RoleMemberWorkstation:
                case DsRole_RoleMemberServer:
                case DsRole_RoleBackupDomainController:
                case DsRole_RolePrimaryDomainController:
                    {
                        // Set the domain to the DNS domain name if it has
                        // been populated.  However, as this api has the option
                        // of not setting this element, if it hasn't been set,
                        // use the DomainNameFlat element instead.
                        if(t_pDsInfo->DomainNameDns)
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, t_pDsInfo->DomainNameDns ) ;
                        }
                        else
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, t_pDsInfo->DomainNameFlat ) ;
                        }
                        
                        pInstance->Setbool( L"PartOfDomain", true ) ;
                        break ;
                    }
                    
                case DsRole_RoleStandaloneWorkstation:
                case DsRole_RoleStandaloneServer:
                    {
                        bstr_t t_bstrWorkGroup( t_pDsInfo->DomainNameFlat ) ;
                        
                        if( !t_bstrWorkGroup.length() )
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, L"WORKGROUP" ) ;
                        }
                        else
                        {
                            pInstance->SetWCHARSplat( IDS_Domain, t_bstrWorkGroup ) ;
                        }
                        pInstance->Setbool( L"PartOfDomain", false ) ;
                    }
                }
            }
            catch( ... )
            {
                NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
                throw ;
            }
            NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
        }
#else
        WKSTA_INFO_100 *pstInfo = NULL ;
        t_status = NetAPI.NetWkstaGetInfo ( NULL , 100 , ( LPBYTE * ) &pstInfo ) ;
        if (t_status == NERR_Success)
        {
            try
            {
                pInstance->SetWCHARSplat ( IDS_Domain , ( WCHAR * ) pstInfo->wki100_langroup ) ;
            }
            catch ( ... )
            {
                NetAPI.NetApiBufferFree ( pstInfo );
                
                throw ;
            }
            
            NetAPI.NetApiBufferFree ( pstInfo );
        }
#endif
        PSERVER_INFO_101 ps = NULL;
        t_status = NetAPI.NetServerGetInfo ( NULL , 101 , (LPBYTE *)&ps ) ;
        if ( t_status == NERR_Success )
        {
            try
            {
                pInstance->Setbool ( IDS_NetworkServerModeEnabled , ps->sv101_type & SV_TYPE_SERVER ) ;
                SetRoles ( pInstance , ps->sv101_type ) ;
            }
            catch ( ... )
            {
                NetAPI.NetApiBufferFree ( ps ) ;
                
                throw ;
            }
            
            NetAPI.NetApiBufferFree ( ps ) ;
        }
        
        // KMH 32414
        if ( GetPlatformMajorVersion() >= 5 )
        {
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *info = NULL;
            
            t_status = NetAPI.DSRoleGetPrimaryDomainInfo (
                
                NULL,
                DsRolePrimaryDomainInfoBasic,
                (LPBYTE *)&info
                );
            
            if ( t_status == NERR_Success )
            {
                try
                {
                    pInstance->SetDWORD ( IDS_DomainRole , info->MachineRole ) ;
                }
                catch ( ... )
                {
                    NetAPI.DSRoleFreeMemory ( ( LPBYTE ) info ) ;
                    
                    throw ;
                }
                
                NetAPI.DSRoleFreeMemory ( ( LPBYTE ) info ) ;
            }
        }
        else
        {
            if ( IsWinNT4 () )
            {
                DSROLE_MACHINE_ROLE t_MachineRole ;
                DWORD t_dwError ;
                if ( NetAPI.DsRolepGetPrimaryDomainInformationDownlevel (
                    
                    t_MachineRole,
                    t_dwError
                    ) )
                {
                    pInstance->SetDWORD ( IDS_DomainRole , t_MachineRole ) ;
                }
            }
        }
   }
   
   GetOEMInfo ( pInstance ) ;
   t_hr = GetStartupOptions ( pInstance ) ;
   return t_hr ;
}
#endif
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32ComputerSystem::GetCompSysInfoWin95(CInstance *pInstance)
{
    CRegistry RegInfo ;
    CHString sTemp ;
    HRESULT t_hr = WBEM_S_NO_ERROR ;
    GetOEMInfo ( pInstance ) ;
    t_hr = GetStartupOptions ( pInstance ) ;
    
    // Look to see if this is a PC-98 machine.
    // If type == 7 and subtype has 0x0D in the hibyte of the loword it's a
    // PC-98.
    if (GetKeyboardType(0) == 7 && ((GetKeyboardType(1) & 0xFF00) == 0x0D00))
    {
        sTemp = _T("NEC PC-98");
    }
    else
    {
        sTemp = IDS_ATDescription ;
    }
    
    pInstance->SetCHString ( IDS_Description , sTemp ) ;
    
    // best guess for "Primary Owner" - it shows up under "My Computer"
    
    DWORD dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE ,
        IDS_RegCurrent95Version ,
        KEY_READ
        ) ;
    
    if ( dwRet == ERROR_SUCCESS )
    {
        dwRet = RegInfo.GetCurrentKeyValue ( IDS_RegRegisteredOwnerKey , sTemp ) ;
        if ( dwRet == ERROR_SUCCESS )
        {
            pInstance->SetCHString ( IDS_PrimaryOwner , sTemp ) ;
        }
        
        RegInfo.Close () ;
    }
    
    // no auto reboot on '95
    pInstance->Setbool ( IDS_AutomaticResetCapability, false ) ;
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegPowerManagementKey,
        KEY_READ
        ) ;
    
    // power management
    if ( dwRet == ERROR_SUCCESS )
    {
        // if we got this key, then we got power management
        
        pInstance->Setbool ( IDS_PowerManagementSupported , true ) ;
        
        // need config manager for this one
        // Setbool(IDS_PowerManagementEnabled,...);
        
        RegInfo.Close () ;
    }
    else
    {
        pInstance->Setbool ( IDS_PowerManagementSupported , false ) ;
    }
    
    // Only use this key if we weren't able to get it out of oeminfo.inf.
    if ( pInstance->IsNull ( L"Manufacturer" ) )
    {
        dwRet = RegInfo.Open (
            
            HKEY_LOCAL_MACHINE,
            IDS_RegCSEnumRootKey,
            KEY_READ
            ) ;
        
        if ( dwRet == ERROR_SUCCESS )
        {
            dwRet = RegInfo.GetCurrentKeyValue ( L"ComputerName" , sTemp ) ;
            if ( dwRet == ERROR_SUCCESS )
            {
                pInstance->SetCHString ( L"Manufacturer" , sTemp ) ;
            }
        }
        
        RegInfo.Close() ;
    }
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCurrent95Version,
        KEY_READ
        ) ;
    
    if ( dwRet == ERROR_SUCCESS )
    {
        dwRet = RegInfo.GetCurrentKeyValue ( IDS_RegRegisteredOwnerKey , sTemp ) ;
        if ( dwRet == ERROR_SUCCESS )
        {
            pInstance->SetCHString ( IDS_PrimaryOwnerName , sTemp ) ;
        }
        
        RegInfo.Close() ;
    }
    
    // The domain name is stored in different places depending on who the
    // 'PrimaryProvider' is.
    
    dwRet = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegNetworkLogon,
        KEY_READ
        ) ;
    
    if( dwRet == ERROR_SUCCESS )
    {
        dwRet = RegInfo.GetCurrentKeyValue ( IDS_RegPrimaryProvider , sTemp ) ;
        if ( dwRet == ERROR_SUCCESS )
        {
            // Microsoft Network is the primary provider
            
            if ( sTemp.CompareNoCase ( IDS_MicrosoftNetwork ) == 0 )
            {
                dwRet = RegInfo.Open (
                    
                    HKEY_LOCAL_MACHINE ,
                    IDS_RegNetworkProvider ,
                    KEY_READ
                    ) ;
                
                if ( dwRet == ERROR_SUCCESS )
                {
                    dwRet = RegInfo.GetCurrentKeyValue ( IDS_RegAuthenticatingAgent , sTemp ) ;
                    if ( dwRet == ERROR_SUCCESS )
                    {
                        TCHAR t_szValidatingDomain[_MAX_PATH] ;
                        _tcscpy ( t_szValidatingDomain , _bstr_t ( sTemp ) ) ;
                        OemToCharA ( t_szValidatingDomain , t_szValidatingDomain ) ;
                        pInstance->SetCHString ( IDS_Domain , t_szValidatingDomain ) ;
                    }
                }
            }
        }
        
        RegInfo.Close() ;
    }
    
    CNetAPI32 NetApi ;
    if ( NetApi.Init () == ERROR_SUCCESS )
    {
        server_info_1 *ps = ( server_info_1 * ) new char [ sizeof ( server_info_1 ) + MAXCOMMENTSZ + 1 ] ;
        if ( ps != NULL )
        {
            try
            {
                int nErr = 0;
                
                // If this call fails, and the error indicates no Net or no Server, then I
                // think we can safely assume that Server Mode is not enabled.
                
                unsigned short dwSize = 0 ;
                
                if ( ( nErr = NetApi.NetServerGetInfo95 ( NULL , 1 , (char *) ps , sizeof ( server_info_1 ) + MAXCOMMENTSZ +1 , & dwSize ) ) == NERR_Success )
                {
                    pInstance->Setbool ( IDS_NetworkServerModeEnabled , ps->sv1_type & SV_TYPE_SERVER ) ;
                    SetRoles ( pInstance, ps->sv1_type ) ;
                }
                else if ( NERR_ServerNotStarted == nErr || NERR_NetNotStarted == nErr )
                {
                    pInstance->Setbool ( IDS_NetworkServerModeEnabled , FALSE ) ;
                }
            }
            catch ( ... )
            {
                delete [] ( char* ) ps ;
                
                throw ;
            }
            
            delete [] ( char * ) ps;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    return t_hr ;
}

#endif
///////////////////////////////////////////////////////////////////////

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::GetStartupOptions
*
*  DESCRIPTION : Reads boot.ini to find startup options
*
*  INPUTS      : pInstance to store data in
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem::GetStartupOptions(CInstance *pInstance)
{
    SAFEARRAY *saNames = NULL ;
    SAFEARRAY *saDirs = NULL ;
    DWORD dwTimeout = 0;
    HRESULT t_hrRetVal = WBEM_S_NO_ERROR ;
    //    CHString strName;
    CHString strDir;

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

    CNVRam nvram;
    CNVRam::InitReturns nvRet;

    if ( nvram.IsEfi () )
    {

        // EFI implementation
        
        nvRet = nvram.Init();
        
        if ( nvRet != CNVRam::Success )
        {
            SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SYSTEM_ENVIRONMENT_NAME ) ;
            return t_hrRetVal ;
        }

        // On EFI it's always the first setting: 0
        pInstance->SetByte ( IDS_SystemStartupSetting , 0 ) ;

        DWORD dwCount ;
        BOOL ok = nvram.GetBootOptions ( & saNames, & dwTimeout, &dwCount ) ;
        if ( ! ok )
        {
            return t_hrRetVal ;
        }

        if ( dwCount != 0 )
        {
            variant_t vValue ;
            
            // Move the array to a variant
            V_VT(&vValue) = VT_BSTR | VT_ARRAY ;
            V_ARRAY(&vValue) = saNames ;
            
            // Send it off
            pInstance->SetVariant ( IDS_SystemStartupOptions , vValue ) ;
        }
        
        pInstance->SetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;

        return t_hrRetVal ;
    }
#endif // defined(EFI_NVRAM_ENABLED)

#if defined(_AMD64_) || defined(_X86_)
    
    // Since the boot drive isn't always C, we have to find out where boot.ini lives
    
    CRegistry RegInfo ;
    
    RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegCurrentNTVersionSetup,
        KEY_READ
        ) ;
    
    CHString sTemp ;
    
    if ( RegInfo.GetCurrentKeyValue ( IDS_RegBootDirKey , sTemp ) == ERROR_SUCCESS )
    {
        sTemp += IDS_BootIni;
    }
    else
    {
        sTemp = IDS_CBootIni ;
    }
    
    // See if there is a boot.ini (we might be on w95 which may or may not have this file).
    
    HANDLE hFile = CreateFile (
        
        TOBSTRT(sTemp),
        GENERIC_READ,
        FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_NO_BUFFERING,
        NULL
        ) ;
    
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        return t_hrRetVal ;
    }
    
    CloseHandle ( hFile ) ;
    
    // Load the operating systems into an array
    
    
    
    DWORD dwCount = LoadOperatingSystems ( TOBSTRT ( sTemp ) , & saNames , & saDirs ) ;
    if ( dwCount )
    {
        try
        {
            // Now, find the default boot option.  Note that the default entry only specifies the boot directory.
            // If there are three boot options that all start from the same directory but have different options,
            // the booter will pick the first one in that list.
            
            TCHAR *szDefault = GetAllocatedProfileString ( IDT_BootLoader , IDT_Default , sTemp ) ;
            
            try
            {
                // Scan for the default os
                
                for ( DWORD x = 0; x < dwCount; x ++ )
                {
                    long ix [ 1 ] ;
                    
                    // Get the name
                    
                    ix [ 0 ] = x ;
                    
                    BSTR bstrName;
                    SafeArrayGetElement ( saDirs , ix , & bstrName ) ;
                    
                    // Do the compare
                    
                    try
                    {
                        if ( lstrcmpi ( TOBSTRT(bstrName), szDefault ) == 0 )
                        {
                            // We found it, set the property
                            pInstance->SetByte ( IDS_SystemStartupSetting , x ) ;
                            
                            SysFreeString(bstrName);
                            // Only the first match counts
                            break;
                        }
                    }
                    catch ( ... )
                    {
                        SysFreeString(bstrName);
                        throw;
                    }
                    
                    SysFreeString(bstrName);
                }
            }
            catch ( ... )
            {
                delete [] szDefault ;
                
                throw ;
            }
            
            delete [] szDefault ;
            
            variant_t vValue ;
            
            // Move the array to a variant
            
            V_VT(&vValue) = VT_BSTR | VT_ARRAY ;
            V_ARRAY(&vValue) = saNames ;
            saNames = NULL ;
            
            // Send it off, free the variant
            
            pInstance->SetVariant ( IDS_SystemStartupOptions , vValue ) ;
            
        }
        catch ( ... )
        {
            if ( saDirs )
            {
                SafeArrayDestroy ( saDirs ) ;
            }
            
            if ( saNames )
            {
                SafeArrayDestroy ( saNames ) ;
            }
            
            throw ;
        }
        
        if ( saDirs )
        {
            SafeArrayDestroy ( saDirs ) ;
            saDirs = NULL ;
        }
    }
    
    // Read the default time
    dwTimeout = WMI_FILE_GetPrivateProfileIntW ( IDT_BootLoader , IDT_Timeout , -1 , sTemp ) ;
    if (dwTimeout != -1)
    {
        pInstance->SetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
    }
    
#else
    
    // On Alpha it's always the first setting: 0
    pInstance->SetByte ( IDS_SystemStartupSetting , 0 ) ;
    
    DWORD dwCount = LoadOperatingSystems ( _T(""), & saNames , & saDirs ) ;
    if ( dwCount )
    {
        SafeArrayDestroy ( saDirs ) ;
        
        variant_t vValue ;
        
        // Move the array to a variant
        V_VT(&vValue) = VT_BSTR | VT_ARRAY ;
        V_ARRAY(&vValue) = saNames ;
        
        // Send it off
        pInstance->SetVariant ( IDS_SystemStartupOptions , vValue ) ;
    }
    
    nvRet = nvram.Init();
    
    if ( nvRet == CNVRam::Success )
    {
        if ( nvram.GetNVRamVar ( L"COUNTDOWN" , & dwTimeout ) )
        {
            pInstance->SetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
        }
    }
    else
    {
        SetSinglePrivilegeStatusObject(pInstance->GetMethodContext(), SE_SYSTEM_ENVIRONMENT_NAME ) ;
        t_hrRetVal = WBEM_S_PARTIAL_RESULTS ;
    }
    
#endif
    return t_hrRetVal ;
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::GetOEMInfo
*
*  DESCRIPTION : Reads OEMINFO.INI for oem info
*
*  INPUTS      : pInstance to store data in
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
void CWin32ComputerSystem :: GetOEMInfo (
                                         
                                         CInstance *pInstance
                                         )
{
    TCHAR szSystemDirectory[_MAX_PATH +1] = _T("");
    TCHAR szOEMFile[_MAX_PATH +1] = _T("");
    TCHAR szBuff[256] = _T("");
    TCHAR szLine[4+MAXITOA] = _T("");
    DWORD dwIndex, dwBytesRead;
    void *pVoid;
    long ix[1];
    bstr_t bstrTemp;
    HRESULT t_Result;
    
    // Find the system directory (where oeminfo.ini and oemlogo.bmp live)
    
    UINT uRet = GetSystemDirectory ( szSystemDirectory , sizeof ( szSystemDirectory ) / sizeof(TCHAR) ) ;
    if ( ( uRet > _MAX_PATH ) || ( uRet == 0 ) )
    {
        return; // shouldn't ever happen, but hey...
    }
    
    if ( szSystemDirectory [ lstrlen ( szSystemDirectory ) - 1 ] != TEXT('\\') )
    {
        lstrcat ( szSystemDirectory , TEXT("\\") ) ;
    }
    
    // Build the file name
    lstrcpy ( szOEMFile , szSystemDirectory ) ;
    lstrcat ( szOEMFile , IDT_OEMInfoIni ) ;
    
    // Get the manufacturer name
    if ( pInstance->IsNull ( L"Manufacturer" ) )
    {
        if ( WMI_FILE_GetPrivateProfileStringW (
            TEXT("General") ,
            TEXT("Manufacturer") ,
            _T("") ,
            szBuff ,
            sizeof ( szBuff ) / sizeof(TCHAR) ,
            szOEMFile )
            )
        {
            pInstance->SetCharSplat ( L"Manufacturer" , szBuff ) ;
        }
    }
    
    // Get the model name
    if ( pInstance->IsNull ( IDS_Model ) )
    {
        if ( WMI_FILE_GetPrivateProfileStringW (
            IDT_General ,
            IDT_Model ,
            _T("") ,
            szBuff ,
            sizeof ( szBuff ) / sizeof(TCHAR) ,
            szOEMFile )
            )
        {
            pInstance->SetCharSplat ( IDS_Model, szBuff ) ;
        }
    }
    
    // Create a safearray for the Support information
    
    SAFEARRAYBOUND rgsabound[1] ;
    
    rgsabound[0].cElements = 0 ;
    rgsabound[0].lLbound = 0 ;
    variant_t vValue;
    
    V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
    if ( V_ARRAY(&vValue) )
    {
        V_VT(&vValue) = VT_BSTR | VT_ARRAY;
        // Support information is stored with one entry per line ie:
        
        // Line1=For product support, contact the manufacturer of your PC.
        // Line2=Refer to the documentation that came with your PC for the product
        
        // We are done when getting the string for lineX fails.
        
        dwIndex = 1;
        lstrcpy(szLine, IDT_Line);
        lstrcat(szLine, _itot(dwIndex, szBuff, 10));
        
        while ( ( WMI_FILE_GetPrivateProfileStringW ( IDT_SupportInformation,
            szLine,
            _T("@"),
            szBuff,
            sizeof(szBuff) / sizeof(TCHAR),
            szOEMFile)) > 1 || (szBuff[0] != '@')
            )
        {
            // Resize the array
            
            ix[0] = rgsabound[0].cElements ;
            rgsabound[0].cElements += 1 ;
            
            t_Result = SafeArrayRedim ( V_ARRAY(&vValue), rgsabound ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            // Add the new element
            bstrTemp = szBuff ;
            t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , (wchar_t*)bstrTemp ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            // Reset for next loop
            lstrcpy ( szLine , IDT_Line ) ;
            lstrcat ( szLine , _itot ( ++ dwIndex , szBuff , 10 ) ) ;
        }
        
        // If we found anything
        
        if ( dwIndex > 1 )
        {
            pInstance->SetVariant ( IDS_SupportContactDescription , vValue ) ;
        }
        
        vValue.Clear();
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
    
    // Build the path for the logo file
    
    lstrcpy ( szOEMFile , szSystemDirectory ) ;
    lstrcat ( szOEMFile , IDT_OemLogoBmp ) ;
    
    // Attempt to open it
    SmartCloseHandle hFile = CreateFile (
        
        szOEMFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
        );
    
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        // I ignore the upper dword since safearraycreate can't handle it anyway.  Shouldn't
        // be a problem unless we get 2 gig bmp files.
        
        rgsabound[0].cElements = GetFileSize ( hFile , NULL ) ;
        rgsabound[0].lLbound = 0 ;
        
        V_ARRAY(&vValue) = SafeArrayCreate ( VT_UI1 , 1 , rgsabound ) ;
        if ( V_ARRAY(&vValue) )
        {
            V_VT(&vValue) = VT_UI1 | VT_ARRAY;
            
            // Get a pointer to read the data into
            
            SafeArrayAccessData ( V_ARRAY(&vValue) , & pVoid ) ;
            try
            {
                ReadFile ( hFile , pVoid , rgsabound[0].cElements, &dwBytesRead, NULL ) ;
            }
            catch ( ... )
            {
                SafeArrayUnaccessData ( V_ARRAY(&vValue) ) ;
                
                throw ;
            }
            
            SafeArrayUnaccessData ( V_ARRAY(&vValue) ) ;
            
            pInstance->SetVariant(IDS_OEMLogoBitmap, vValue);
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::LoadOperatingSystems
*
*  DESCRIPTION : Parses and loads the operating systems
*
*  INPUTS      : fully qualified ini file name, pointers to names and dirs sa
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

DWORD CWin32ComputerSystem :: LoadOperatingSystems (
                                                    
                                                    LPCTSTR szIniFile,
                                                    SAFEARRAY **ppsaNames,
                                                    SAFEARRAY **ppsaDirs
                                                    )
{
    CHString strName,strDir,strSwap;

#if defined(_AMD64_) || defined(_X86_)
    
    *ppsaNames = NULL ;
    *ppsaDirs = NULL ;
    
    // Grab the whole section of boot options
    
    DWORD dwRet = 0 ;
    TCHAR *szOptions = GetAllocatedProfileSection ( IDT_OperatingSystems , szIniFile , dwRet ) ;
    
    SAFEARRAYBOUND rgsabound[1] ;
    rgsabound[0].cElements = 0 ;
    rgsabound[0].lLbound = 0 ;
    
    try
    {
        // Create an array to put them in.  We'll start with 0 elements and add as necessary.
        
        *ppsaNames = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaNames )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        *ppsaDirs = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaDirs )
        {
            SafeArrayDestroy ( *ppsaNames ) ;
            
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        try
        {
            // Start walking the returned string
            
            DWORD dwIndex = 0 ;
            while ( dwIndex < dwRet )
            {
                // Trim leading spaces
                
                while (szOptions[dwIndex] == ' ')
                {
                    dwIndex ++;
                }
                
                // Skip comment lines
                
                if ( szOptions[dwIndex] == ';' )
                {
                    do {
                        
                        dwIndex++;
                        
                    } while ( szOptions [ dwIndex ] != '\0' ) ;
                    
                }
                else
                {
                    // pChar will point at the directory
                    
                    TCHAR *pChar = &szOptions[dwIndex];
                    
                    do {
                        
                        dwIndex++;
                        
                    } while ( ( szOptions [ dwIndex ] != '=' ) && ( szOptions [ dwIndex ] != '\0') ) ;
                    
                    // We must have an = sign or this is an invalid string
                    
                    if ( szOptions [ dwIndex ] == '=' )
                    {
                        // Punch in a null
                        
                        szOptions[dwIndex++] = '\0';
                        
                        // Increase the number of elements
                        
                        long ix[1];
                        
                        ix[0] = rgsabound[0].cElements;
                        rgsabound[0].cElements += 1;
                        
                        HRESULT t_Result = SafeArrayRedim ( *ppsaNames , rgsabound ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        t_Result = SafeArrayRedim ( *ppsaDirs , rgsabound ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        // Put the new element in
                        
                        bstr_t bstrTemp = &szOptions [ dwIndex ];
                        t_Result = SafeArrayPutElement ( *ppsaNames , ix , (wchar_t*)bstrTemp ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        bstrTemp = pChar;
                        t_Result = SafeArrayPutElement ( *ppsaDirs , ix , (wchar_t*)bstrTemp ) ;
                        if ( t_Result == E_OUTOFMEMORY )
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        
                        // Find the end of this string
                        
                        while ( szOptions [ dwIndex ] != '\0' )
                        {
                            dwIndex ++ ;
                        }
                    }
                }
                
                // Move to the start of the next string
                dwIndex++ ;
            }
        }
        catch ( ... )
        {
            SafeArrayDestroy ( *ppsaNames ) ;
            
            SafeArrayDestroy ( *ppsaDirs ) ;
            
            throw ;
        }
        
    }
    catch ( ... )
    {
        delete [] szOptions;
        
        throw ;
    }
    
    if ( szOptions != NULL )
    {
        delete [] szOptions;
    }
    
    return rgsabound[0].cElements ;
    
#else
    
    // RISC implementation
    
    *ppsaNames = NULL ;
    *ppsaDirs = NULL ;
    
    // Try to load the setupdll.dll functions.
    
    CHSTRINGLIST listNames ;
    CHSTRINGLIST listDirs ;
    
    CNVRam nvram;
    if ( nvram.Init () == CNVRam::PrivilegeNotHeld )
    {
        return 0 ;
    }
    
    BOOL t_Failure = !nvram.GetNVRamVar(L"LOADIDENTIFIER", &listNames) ||
        !nvram.GetNVRamVar(L"OSLOADPARTITION", &listDirs) ;
    
    if ( t_Failure )
    {
        return 0;
    }
    
    // Create an array to put them in.  We'll start with 0 elements and add as necessary.
    
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].cElements = min(listNames.size(), listDirs.size());
    rgsabound[0].lLbound = 0;
    
    try
    {
        *ppsaNames = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaNames )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        *ppsaDirs = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
        if ( ! *ppsaDirs )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        CHSTRINGLIST_ITERATOR iterNames ;
        CHSTRINGLIST_ITERATOR iterDirs ;
        
        long lIndex[1] = {0};
        
        for (iterNames = listNames.begin(), iterDirs = listDirs.begin();
        iterNames != listNames.end() && iterDirs != listDirs.end();
        ++iterNames, ++iterDirs, lIndex[0]++)
        {
            strName = *iterNames,
                strDir = *iterDirs;
            
            // Put the new element in
            
            bstr_t bstrTemp = (LPCWSTR)strName;
            HRESULT t_Result = SafeArrayPutElement ( *ppsaNames , lIndex , (void *) (wchar_t*)bstrTemp ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                SysFreeString ( bstrTemp ) ;
                
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            SysFreeString(bstrTemp);
            
            bstrTemp = (LPCWSTR)strDir;
            t_Result = SafeArrayPutElement ( *ppsaDirs , lIndex , (void *) (wchar_t*)bstrTemp ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                SysFreeString ( bstrTemp ) ;
                
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            SysFreeString(bstrTemp);
        }
    }
    catch ( ... )
    {
        if ( *ppsaNames )
        {
            SafeArrayDestroy ( *ppsaNames ) ;
        }
        
        if ( *ppsaDirs )
        {
            SafeArrayDestroy ( *ppsaDirs ) ;
        }
        
        throw ;
    }
    
    return rgsabound[0].cElements ;
    
#endif
}


/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::GetPrivateProfileSection98
*
*  DESCRIPTION : Win98 hack since corresponding api fn not working as of 6/15/98
*
*  INPUTS      : pInstance to store data from
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

#ifdef WIN9XONLY
DWORD GetPrivateProfileSection98 (
                                  
                                  LPCTSTR cszSection,
                                  LPTSTR buf,
                                  DWORD dwSize,
                                  LPCTSTR szIniFile
                                  )
{
#ifndef UNICODE
    
    // Need buffer to contain the section head we will read.
    // Need a copy of it too
    TCHAR *szSectionPreserve = new TCHAR [ lstrlen ( cszSection ) + 3 ] ;
    if ( szSectionPreserve == NULL )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
    
    TCHAR *szSection = new TCHAR [ lstrlen ( cszSection ) + 3 ] ;
    if( szSection == NULL)
    {
        delete [] szSectionPreserve;
        
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
    
    ZeroMemory ( szSectionPreserve , lstrlen ( cszSection ) + 3 ) ;
    ZeroMemory ( szSection , lstrlen ( cszSection ) + 3 ) ;
    
    _stprintf ( szSection , _T("[%s]") , cszSection ) ;
    lstrcpy ( szSectionPreserve , szSection ) ;
    
    FILE *fp = fopen ( szIniFile ,"rb" ) ;
    if ( fp == NULL )
    {
        delete [] szSection ;
        delete [] szSectionPreserve ;
        
        return 0L ;
    }
    
    // Read a line (or sizeof szSection chars at a time)
    // until the section head reached:
    
    while ( ! feof ( fp ) )
    {
        if ( fgets ( szSection , strlen( cszSection ) + 3 , fp ) != NULL )
        {
            if ( _stricmp ( szSectionPreserve , szSection ) == 0 )
            {
                break ;
            }
        }
    }
    
    // Now we are either at the end of the file (the section didn't exist)
    // or positioned correctly to read the section.  Read the section one
    // line at a time, and append to buffer, checking each time that there
    // is enough buffer space and that we haven't read in another [, which
    // would be the start of another section.
    
    char* p = buf;
    LONG lBufSpaceUsed = 0L;
    LONG lBufSpaceLeft = dwSize-1; // save space for the second final null
    LONG lCharsRead = 0L;
    
    while ( ! feof ( fp ) )
    {
        fgets ( p, lBufSpaceLeft , fp ) ;
        
        // If the line was a comment line, delete it from the buffer and
        // read another line.
        
        if ( *p == ';' )
        {
            ZeroMemory ( p , lBufSpaceLeft ) ;  // a little overkill, but ok anyway
            continue ;
        }
        
        if ( *p == '[' )
        {
            ZeroMemory ( p , lBufSpaceLeft ) ;
            break;  // only happens if we reach another section
        }
        
        lCharsRead = strlen ( p ) ;
        
        if ( strstr ( p , "\r" ) != NULL )
        {
            lCharsRead -- ;
        }
        
        if ( strstr ( p, "\n" ) != NULL )
        {
            lCharsRead -- ;
        }
        
        if ( lCharsRead != 0 )
        {
            lBufSpaceUsed += ( lCharsRead + 1 ) ;
            lBufSpaceLeft -= lBufSpaceUsed ;
        }
        
        ZeroMemory ( p + lCharsRead , lBufSpaceLeft ) ;
        if ( lCharsRead != 0 )
        {
            p += ( lCharsRead + 1 ) ;
        }
    }
    
    fclose ( fp );
    
    delete [] szSection ;
    delete [] szSectionPreserve ;
    return lBufSpaceUsed;
    
#else
    
    // Not needed for NT.
    return 0;
    
#endif
    
}

#endif

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::PutInstance
*
*  DESCRIPTION : Write changed instance
*
*  INPUTS      : pInstance to store data from
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/

HRESULT CWin32ComputerSystem :: PutInstance (
                                             
                                             const CInstance &pInstance,
                                             long lFlags /*= 0L*/
                                             )
{
    // Tell the user we can't create a new computersystem (much as we might like to)
    if ( lFlags & WBEM_FLAG_CREATE_ONLY )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }
    
    HRESULT hRet = WBEM_S_NO_ERROR ;
    
    // Make sure we are looking at a good instance.  Get the name from the instance...
    
    CHString sName;
    pInstance.GetCHString ( IDS_Name , sName ) ;
    
    DWORD dwTimeout ;
    
    // Check for the correct computer name
    
    if ( sName.CompareNoCase ( GetLocalComputerName () ) != 0 )
    {
        if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
        {
            hRet = WBEM_E_NOT_FOUND ;
        }
        else
        {
            hRet = WBEM_E_PROVIDER_NOT_CAPABLE ;
        }
    }
    else
    {
#ifdef NTONLY
        // update AutomaticResetBootOption
        if( !pInstance.IsNull( IDS_AutomaticResetBootOption ) )
        {
            bool t_bReset ;
            pInstance.Getbool(IDS_AutomaticResetBootOption, t_bReset ) ;
            
            CRegistry t_RegInfo ;
            
            DWORD t_dwRet = t_RegInfo.CreateOpen (
                
                HKEY_LOCAL_MACHINE,
                IDS_RegCrashControl
                ) ;
            
            if ( ERROR_SUCCESS == t_dwRet )
            {
                DWORD t_dwReset = t_bReset ;
                DWORD t_dwTmp = ERROR_SUCCESS;
                if( ( t_dwTmp = t_RegInfo.SetCurrentKeyValue(IDS_RegAutoRebootKey, t_dwReset) ) == ERROR_SUCCESS )
                {
                    hRet = WBEM_S_NO_ERROR ;
                }
                else
                {
                    hRet = WinErrorToWBEMhResult(t_dwTmp) ;
                }
                
                t_RegInfo.Close();
            }
            else
            {
                hRet = WinErrorToWBEMhResult(t_dwRet) ;
            }
            
            if( WBEM_S_NO_ERROR != hRet )
            {
                return hRet ;
            }
        }
#endif
        
#ifdef NTONLY
        // set roles
        if( !pInstance.IsNull( IDS_Roles ) )
        {
            DWORD t_dwRoles = 0 ;
            
            hRet = GetRoles( pInstance, &t_dwRoles ) ;
            
            if( WBEM_S_NO_ERROR == hRet )
            {
                CNetAPI32 NetAPI;
                
                if ( NetAPI.Init () == ERROR_SUCCESS )
                {
                    PSERVER_INFO_101 t_ps = NULL;
                    
                    NET_API_STATUS stat = NetAPI.NetServerGetInfo ( NULL , 101 , (LPBYTE *)&t_ps ) ;
                    
                    if ( stat == NERR_Success && t_ps )
                    {
                        try
                        {
                            DWORD t_dwParmError = 0 ;
                            
                            t_ps->sv101_type = t_dwRoles ;
                            
                            stat = NetAPI.NetServerSetInfo ( NULL , 101 , (LPBYTE)t_ps, &t_dwParmError ) ;
                            
                            if ( stat != NERR_Success )
                            {
                                hRet = WBEM_E_ACCESS_DENIED ;
                            }
                        }
                        catch( ... )
                        {
                            NetAPI.NetApiBufferFree ( t_ps ) ;
                            throw ;
                        }
                        NetAPI.NetApiBufferFree ( t_ps ) ;
                    }
                    else
                    {
                        hRet = WBEM_E_ACCESS_DENIED ;
                    }
                }
                else
                {
                    hRet = WBEM_E_ACCESS_DENIED ;
                }
            }
            
            if( WBEM_S_NO_ERROR != hRet )
            {
                return hRet ;
            }
        }
#endif
        
        // Set CurrentTimeZone if presented
        hRet = SetTimeZoneInfo( pInstance ) ;
        
        if( WBEM_S_NO_ERROR != hRet )
        {
            return hRet ;
        }
        
#if defined(_AMD64_) || defined(_X86_)
        
        // Since the boot drive isn't always C, we have to find out where boot.ini lives
        
        CRegistry RegInfo ;
        
        RegInfo.Open ( HKEY_LOCAL_MACHINE , IDS_RegCurrentNTVersionSetup , KEY_READ ) ;
        
        CHString sTemp ;
        
        if ( RegInfo.GetCurrentKeyValue ( IDS_RegBootDirKey , sTemp ) == ERROR_SUCCESS )
        {
            sTemp += IDS_BootIni ;
        }
        else
        {
            sTemp = IDS_CBootIni ;
        }
        
        // See if there is a boot.ini (we might be on w95 which may or may not have this file).
        bool fBootIniExists = false;
        {
            SmartCloseHandle hFile;
        
            // Limit the time the file is open...
            {
                hFile = CreateFile (
            
                    TOBSTRT(sTemp),
                    GENERIC_READ,
                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_NO_BUFFERING,
                    NULL
                    ) ;

                if(hFile != INVALID_HANDLE_VALUE)
                {
                    fBootIniExists = true;
                }
            }
        }

        if(fBootIniExists)
        {
            // Update the startup options if supplied
            // by the PutInstance caller...
            if(UpdatingSystemStartupOptions(pInstance))
            {
                hRet = UpdateSystemStartupOptions(
                    pInstance,
                    sTemp);
            }
            
            // If a value was specified for StartupDelay
            
            if ( ! pInstance.IsNull ( IDS_SystemStartupDelay ) )
            {
                // Write it out.
                
                pInstance.GetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
                
                if ( SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_NORMAL ) )
                {
                    TCHAR szBuff [ MAXITOA ] ;
                    
                    WMI_FILE_WritePrivateProfileStringW ( IDT_BootLoader , IDT_Timeout, _itot( dwTimeout, szBuff, 10 ), TOBSTRT ( sTemp ) ) ;                    
                    SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ) ;
                }
                else
                {
                    hRet = WBEM_E_ACCESS_DENIED ;
                }
            }
            
            // If a value was specified for StartupSetting
            
            if ( ! pInstance.IsNull ( IDS_SystemStartupSetting ) )
            {
                
                BSTR bstrDefaultDir ;
                BSTR bstrDefaultName ;
                BSTR bstrName ;
                BSTR bstrDir;
                
                // This becomes something of a mess.  Since the only thing you specify in the 'default' key
                // is the path, how do you make sure that the options that you want (which are part of the name
                // portion) get chosen?  The answer is that they re-shuffle the entries in the boot.ini so that
                // the line you want comes first.
                
                BYTE btIndex = 0 ;
                pInstance.GetByte ( IDS_SystemStartupSetting , btIndex ) ;
                
                DWORD dwIndex = btIndex ;
                
                SAFEARRAY *saNames = NULL;
                SAFEARRAY *saDirs = NULL;
                
                DWORD dwCount = LoadOperatingSystems ( TOBSTRT ( sTemp ) , & saNames , & saDirs ) ;
                try
                {
                    if ( dwIndex + 1 <= dwCount )
                    {
                        long ix[1];
                        
                        ix [ 0 ] = dwIndex ;
                        SafeArrayGetElement ( saDirs , ix , & bstrDefaultDir ) ;
                        SafeArrayGetElement ( saNames , ix , & bstrDefaultName ) ;
                        
                        // Pull everything down on top of the entry to become the default
                        
                        for ( int x = dwIndex ; x > 0 ; x -- )
                        {
                            ix[0] = x-1 ;
                            SafeArrayGetElement ( saDirs , ix , & bstrDir ) ;
                            SafeArrayGetElement ( saNames , ix , & bstrName ) ;
                            
                            ix[0] = x ;
                            SafeArrayPutElement ( saDirs , ix , bstrDir );
                            SafeArrayPutElement ( saNames , ix , bstrName ) ;
                        }
                        
                        // Write the new one on top
                        
                        if ( dwIndex > 0 )
                        {
                            ix[0] = 0 ;
                            SafeArrayPutElement ( saNames , ix , bstrDefaultName ) ;
                            SafeArrayPutElement ( saDirs , ix , bstrDefaultDir ) ;
                        }
                        
                        // Build up the section to write to the ini file.  Ini file sections are written
                        // as 'dir'='name'\0 with a final \0 at the end.
                        
                        CHString sSection ;
                        
                        sSection.Empty();
                        
                        for (x=0; x < dwCount; x++)
                        {
                            ix[0] = x;
                            SafeArrayGetElement ( saDirs , ix , & bstrDir ) ;
                            
                            sSection += bstrDir ;
                            sSection += _T('=') ;
                            
                            SafeArrayGetElement ( saNames , ix , & bstrName ) ;
                            sSection += bstrName ;
                            sSection += _T('\0');
                        }
                        
                        sSection += _T('\0') ;
                        
                        // Make the file writable
                        
                        if ( SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_NORMAL ) )
                        {
                            // Write the changes
                            
                            WMI_FILE_WritePrivateProfileStringW ( IDT_BootLoader , IDT_Default , TOBSTRT( bstrDefaultDir ) , TOBSTRT ( sTemp ) ) ;
                            WMI_FILE_WritePrivateProfileSectionW ( IDT_OperatingSystems , TOBSTRT ( sSection ) , TOBSTRT ( sTemp ) ) ;
                            
                            // Put it back
                            SetFileAttributes ( TOBSTRT ( sTemp ) , FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ) ;
                        }
                        else
                        {
                            hRet = WBEM_E_ACCESS_DENIED;
                        }
                        
                    }
                    else
                    {
                        hRet = WBEM_E_VALUE_OUT_OF_RANGE ;
                    }
                }
                catch ( ... )
                {
                    if ( saDirs )
                    {
                        SafeArrayDestroy ( saDirs ) ;
                    }
                    
                    if ( saNames )
                    {
                        SafeArrayDestroy ( saNames ) ;
                    }
                    
                    throw ;
                }
                
                if ( saDirs )
                {
                    SafeArrayDestroy ( saDirs ) ;
                }
                
                if ( saNames )
                {
                    SafeArrayDestroy ( saNames ) ;
                }
            }
        }

#else //defined(_AMD64_) || defined(_X86_)

    CNVRam nvram;

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

//
// ChuckL (1/24/01):
// This code will have to be restructured when x86 EFI support is added.
// I would have liked to have put this at the top of the routine, and I
// did in GetStartupOptions(), but, for x86 only, this routine also changes
// a bunch of other stuff that it doesn't change on non-x86, so it wasn't
// easy to put the EFI stuff at the top. I'm not sure why all that extra
// stuff is x86-only. Seems to me like it's not platform-specific.
//

		if (nvram.IsEfi()) {

			if ( pInstance.IsNull ( IDS_SystemStartupDelay ) &&
				 pInstance.IsNull ( IDS_SystemStartupSetting ) )
			{
				return WBEM_S_NO_ERROR;
			}

			if ( nvram.Init () == CNVRam::PrivilegeNotHeld )
			{
				SetSinglePrivilegeStatusObject ( pInstance.GetMethodContext(), _bstr_t ( SE_SYSTEM_ENVIRONMENT_NAME ) ) ;
				return WBEM_E_PRIVILEGE_NOT_HELD ;
			}
        
			if ( ! pInstance.IsNull ( IDS_SystemStartupDelay ) )
			{
				DWORD dwTimeout ;
            
				// Write it out.
				pInstance.GetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
				nvram.SetBootTimeout ( dwTimeout ) ;
			}

			if ( ! pInstance.IsNull ( IDS_SystemStartupSetting ) )
			{
				BYTE cIndex;

				pInstance.GetByte ( IDS_SystemStartupSetting , cIndex ) ;
				nvram.SetDefaultBootEntry ( cIndex ) ;
			}
        
			return WBEM_S_NO_ERROR;
		}

#endif // defined(EFI_NVRAM_ENABLED)

		WCHAR *pszVarNames[6] = {
        
			L"LOADIDENTIFIER" ,
				L"SYSTEMPARTITION" ,
				L"OSLOADER" ,
				L"OSLOADPARTITION" ,
				L"OSLOADFILENAME" ,
				L"OSLOADOPTIONS"
		} ;
    
		if ( nvram.Init () == CNVRam::PrivilegeNotHeld )
		{
			SetSinglePrivilegeStatusObject ( pInstance.GetMethodContext(), _bstr_t ( SE_SYSTEM_ENVIRONMENT_NAME ) ) ;
			return WBEM_E_PRIVILEGE_NOT_HELD ;
		}
    
		// Set the startup delay.
		if ( ! pInstance.IsNull ( IDS_SystemStartupDelay ) )
		{
			DWORD dwTimeout ;
        
			// Write it out.
			pInstance.GetDWORD ( IDS_SystemStartupDelay , dwTimeout ) ;
			nvram.SetNVRamVar ( L"COUNTDOWN" , dwTimeout ) ;
		}
    
		// Set the desired OS configuration.
		if ( pInstance.IsNull ( IDS_SystemStartupSetting ) )
		{
			return WBEM_S_NO_ERROR ;
		}
    
		// If the first config is still desired, just leave.
    
		BYTE cIndex;
		pInstance.GetByte ( IDS_SystemStartupSetting , cIndex ) ;
		if ( cIndex == 0 )
		{
			return WBEM_S_NO_ERROR;
		}
     
		// Switch all items[cIndex] with items[0] so the desired item is at the
		// top.
    
		for ( int i = 0 ; i < 6 ; i++ )
		{
			CHSTRINGLIST listValues;
        
			if ( ! nvram.GetNVRamVar ( pszVarNames [ i ] , &listValues ) )
			{
				continue;
			}
        
			// In case a number too large was chosen.  Only check the first item
			// since some of the others seem to live just fine with less.
        
			if ( i == 0 && listValues.size () <= cIndex )
			{
				hRet = WBEM_E_VALUE_OUT_OF_RANGE ;
				break ;
			}
        
			// Go through the list until we hit item iIndex == cIndex.  Then switch
			// it with 0 and write the values back into NVRam.
        
			int iIndex = 0;
			for (CHSTRINGLIST_ITERATOR iVal = listValues.begin(); iVal != listValues.end(); ++iVal, iIndex++)
			{
				if (iIndex == cIndex)
				{
					CHString &strVal0 = *listValues.begin() ;
					CHString &strValIndex = *iVal;
					CHString strSwap ;
                
					strSwap = strVal0;
					strVal0 = strValIndex;
					strValIndex = strSwap;
                
					break;
				}
			}
        
			nvram.SetNVRamVar ( pszVarNames [ i ] , & listValues ) ;
		}
        
#endif

    }
    
    return hRet;

}

void CWin32ComputerSystem::GetTimeZoneInfo ( CInstance *pInstance )
{
    TIME_ZONE_INFORMATION tzone ;
    
    DWORD dwRet = GetTimeZoneInformation ( & tzone ) ;
    
    if (TIME_ZONE_ID_INVALID == dwRet )
    {
        return;
    }
    
    if (dwRet == TIME_ZONE_ID_DAYLIGHT)
    {
        tzone.Bias += tzone.DaylightBias ;
    }
    else
    {
        // This is normally 0 but is non-zero in some timezones.
        tzone.Bias += tzone.StandardBias ;
    }
    
    pInstance->SetWBEMINT16 ( IDS_CurrentTimeZone , -1 * tzone.Bias ) ;
    
    //DaylightInEffect property is set to true if Daylight savings mode is on & false if standard time mode is on
    //DaylightInEffect property is NULL if zone has no daylight savings mode
    
    if ( dwRet != TIME_ZONE_ID_UNKNOWN )
    {
        if ( dwRet == TIME_ZONE_ID_DAYLIGHT )
        {
            pInstance->Setbool ( IDS_DaylightInEffect, TRUE ) ;
        }
        else
        {
            pInstance->Setbool ( IDS_DaylightInEffect, FALSE ) ;
        }
    }

    // Set the EnableDaylightSavingsTime propety
    CRegistry reg;
    CHString chstrTmp;

    if(reg.OpenLocalMachineKeyAndReadValue(
        REGKEY_TIMEZONE_INFO,
        REGVAL_TZNOAUTOTIME,
        chstrTmp) == ERROR_SUCCESS)
    {
        pInstance->Setbool(IDS_EnableDaylightSavingsTime, FALSE);
    }
    else
    {
        pInstance->Setbool(IDS_EnableDaylightSavingsTime, TRUE);
    }
}

//
HRESULT CWin32ComputerSystem::SetTimeZoneInfo ( const CInstance &a_rInstance )
{
    HRESULT t_Result = WBEM_S_NO_ERROR ;
    
    TIME_ZONE_INFORMATION t_TimeZone ;
    
    if( !a_rInstance.IsNull( IDS_CurrentTimeZone ) )
    {
        DWORD dwRet = GetTimeZoneInformation ( &t_TimeZone ) ;
        
        if( TIME_ZONE_ID_INVALID == dwRet )
        {
            t_Result =  WBEM_E_FAILED ;
        }
        else
        {
            short sTimeZoneBias = 0 ;
            
            a_rInstance.GetWBEMINT16( IDS_CurrentTimeZone , sTimeZoneBias ) ;

            // Got the value as a short, now need it as a long.  Can't just
            // get it directly into t_TimeZone.Bias in the GetWBEMINT16 call
            // as the sign digits will not be handled properly (that is, the
            // value of -420 (0x1A4) comes in as FE5C, not FFFFFE5C, so when we 
            // multiply this by -1, it becomes FFFF01A4, not 1A4).
            t_TimeZone.Bias = (LONG) sTimeZoneBias;
            
            t_TimeZone.Bias *= -1 ;
            
            if( dwRet == TIME_ZONE_ID_DAYLIGHT )
            {
                t_TimeZone.Bias -= t_TimeZone.DaylightBias ;
            }
            else
            {
                // This is normally 0 but is non-zero in some timezones.
                t_TimeZone.Bias -= t_TimeZone.StandardBias ;
            }
            
            BOOL t_status = SetTimeZoneInformation( &t_TimeZone ) ;
            
            if( !t_status )
            {
                t_Result = WBEM_E_FAILED ;
            }
        }
    }

    if(SUCCEEDED(t_Result))
    {
        if(!a_rInstance.IsNull(IDS_EnableDaylightSavingsTime))
        {
            bool fEnableDaylightAutoAdj;
            if(a_rInstance.Getbool(
                IDS_EnableDaylightSavingsTime,
                fEnableDaylightAutoAdj))
            {
                CRegistry reg;
                CHString chstrTmp;

                if(fEnableDaylightAutoAdj)
                {
                    // they want to enable auto daylight
                    // adjustment, so remove the reg key
                    // that disables auto adjustment.
                    if(reg.Open(
                        HKEY_LOCAL_MACHINE,
                        REGKEY_TIMEZONE_INFO,
                        KEY_SET_VALUE) == ERROR_SUCCESS)
                    {
                        LONG lRes = reg.DeleteValue(REGVAL_TZNOAUTOTIME);
                        // If failed to delete due to error other
                        // than no such key (which is fine),
                        // return an error.
                        if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
                        {
                            t_Result = WBEM_E_FAILED;
                        }
                    }
                    else
                    {
                        t_Result = WBEM_E_FAILED;
                    }
                }
                else
                {
                    // they want to disable auto adjustment
                    // so add the registry key to disable auto
                    // daylight adjustment if it isn't already there.
                    if(reg.OpenLocalMachineKeyAndReadValue(
                        REGKEY_TIMEZONE_INFO,
                        REGVAL_TZNOAUTOTIME,
                        chstrTmp) == ERROR_SUCCESS)
                    {
                        // key is present, so do nothing
                    }
                    else
                    {
                        // add the value to disable auto adjustment.
                        if(reg.Open(
                            HKEY_LOCAL_MACHINE,
                            REGKEY_TIMEZONE_INFO,
                            KEY_SET_VALUE) == ERROR_SUCCESS)
                        {
                            DWORD dwVal = 1L;
                            if(reg.SetCurrentKeyValue(
                                REGVAL_TZNOAUTOTIME,
                                dwVal) != ERROR_SUCCESS)
                            {
                                t_Result = WBEM_E_FAILED;
                            }
                        }
                        else
                        {
                            t_Result = WBEM_E_FAILED;
                        }
                    }
                }
            }
            else
            {
                t_Result = WBEM_E_FAILED;
            }
        }
    }

    return t_Result ;
}

void CWin32ComputerSystem :: SetRoles (
                                       
                                       CInstance *pInstance,
                                       DWORD dwType
                                       )
{
    variant_t vValue;
    
    // Create a safearray for the Roles information.  Make it overlarge and
    // size it down later.
    
    SAFEARRAYBOUND rgsabound [ 1 ] ;
    
    rgsabound [ 0 ].cElements = 30 ;
    rgsabound [ 0 ].lLbound = 0 ;
    
    V_ARRAY(&vValue) = SafeArrayCreate ( VT_BSTR , 1 , rgsabound ) ;
    if ( V_ARRAY(&vValue) )
    {
        V_VT(&vValue) = VT_ARRAY | VT_BSTR;
        
        long ix [ 1 ] ;
        ix [ 0 ] = 0 ;
        
        // Check each of the bits, and add to the safearray if set
        
        if ( dwType & SV_TYPE_WORKSTATION )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix,  ( wchar_t * ) bstr_t ( IDS_LM_Workstation ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix ,  ( wchar_t * ) bstr_t ( IDS_LM_Server ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SQLSERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix ,  ( wchar_t * ) bstr_t ( IDS_SQLServer ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_CTRL )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Controller ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_BAKCTRL )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Backup_Controller )  ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_TIME_SOURCE )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Timesource ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_AFP )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_AFP ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_NOVELL )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Novell ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_MEMBER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Member ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_LOCAL_LIST_ONLY )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Local_List_Only ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_PRINTQ_SERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Print ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DIALIN_SERVER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_DialIn ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if (dwType & SV_TYPE_XENIX_SERVER)
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Xenix_Server ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SERVER_MFPN )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_MFPN ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_NT )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_NT ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_WFW )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_WFW ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_SERVER_NT )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Server_NT ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_POTENTIAL_BROWSER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Potential_Browser ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_BACKUP_BROWSER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Backup_Browser ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_MASTER_BROWSER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Master_Browser ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_MASTER )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Master ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix[0] ++;
        }
        
        if ( dwType & SV_TYPE_DOMAIN_ENUM )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Domain_Enum ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_WINDOWS )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_Windows_9x ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        if ( dwType & SV_TYPE_DFS )
        {
            HRESULT t_Result = SafeArrayPutElement ( V_ARRAY(&vValue) , ix , ( wchar_t * ) bstr_t ( IDS_DFS ) ) ;
            if ( t_Result == E_OUTOFMEMORY )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
            
            ix [ 0 ] ++ ;
        }
        
        // Since the array is zero based, don't use ix[0]-1
        
        rgsabound [ 0 ].cElements = ix [ 0 ] ;
        HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValue) , rgsabound ) ;
        if ( t_Result == E_OUTOFMEMORY )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        
        // Set the property and be done
        
        pInstance->SetVariant ( IDS_Roles , vValue ) ;
    }
    
}

//
HRESULT CWin32ComputerSystem::GetRoles (
                                        
                                        const CInstance &a_rInstance,
                                        DWORD *a_pdwRoleType
                                        )
{
    HRESULT     t_hResult = WBEM_S_NO_ERROR ;
    LONG        t_uLBound = 0 ;
    LONG        t_uUBound = 0 ;
    variant_t   t_vRoles;
    
    a_rInstance.GetVariant ( IDS_Roles , t_vRoles ) ;
    
    if( !t_vRoles.parray || t_vRoles.vt != (VT_BSTR | VT_ARRAY) )
    {
        return WBEM_E_FAILED ;
    }
    
    SAFEARRAY *t_saRoles = t_vRoles.parray ;
    
    if( 1 != SafeArrayGetDim( t_saRoles ) )
    {
        return WBEM_E_FAILED;
    }
    
    // Get the IP bounds
    if( S_OK != SafeArrayGetLBound( t_saRoles, 1, &t_uLBound ) ||
        S_OK != SafeArrayGetUBound( t_saRoles, 1, &t_uUBound ) )
    {
        return WBEM_E_FAILED ;
    }
    
    if( !a_pdwRoleType )
    {
        return WBEM_E_FAILED ;
    }
    else
    {
        *a_pdwRoleType = 0 ;
    }
    
    //
    for( LONG t_ldx = t_uLBound; t_ldx <= t_uUBound; t_ldx++ )
    {
        BSTR t_bsRole = NULL ;
        
        SafeArrayGetElement( t_saRoles, &t_ldx, &t_bsRole  ) ;
        
        bstr_t t_bstrRole( t_bsRole, FALSE ) ;
        
        for( int t_i = 0; t_i < sizeof( g_SvRoles ) / sizeof( g_SvRoles[0] ); t_i++ )
        {
            if( t_bstrRole == bstr_t( g_SvRoles[ t_i ].pwStrRole ) )
            {
                *a_pdwRoleType |= g_SvRoles[ t_i ].dwRoleMask ;
                
                t_hResult = WBEM_S_NO_ERROR ;
                break ;
            }
        }
        if( WBEM_S_NO_ERROR != t_hResult )
        {
            t_hResult = WBEM_E_VALUE_OUT_OF_RANGE ;
            break ;
        }
    }
    
    return t_hResult ;
}

HRESULT CWin32ComputerSystem :: GetAccount ( HANDLE a_TokenHandle , CHString &a_Domain , CHString &a_User )
{
    HRESULT t_Status = S_OK ;
    
    TOKEN_USER *t_TokenUser = NULL ;
    DWORD t_ReturnLength = 0 ;
    TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;
    
    BOOL t_TokenStatus = GetTokenInformation (
        
        a_TokenHandle ,
        t_TokenInformationClass ,
        NULL ,
        0 ,
        & t_ReturnLength
        ) ;
    
    if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
    {
        t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ;
        if ( t_TokenUser )
        {
            try
            {
                t_TokenStatus = GetTokenInformation (
                    
                    a_TokenHandle ,
                    t_TokenInformationClass ,
                    ( void * ) t_TokenUser ,
                    t_ReturnLength ,
                    & t_ReturnLength
                    ) ;
                
                if ( t_TokenStatus )
                {
                    CSid t_Sid ( t_TokenUser->User.Sid ) ;
                    if ( t_Sid.IsOK () )
                    {
                        a_Domain = t_Sid.GetDomainName () ;
                        a_User = t_Sid.GetAccountName () ;
                    }
                    else
                    {
                        t_Status = WBEM_E_PROVIDER_FAILURE ;
                    }
                }
                else
                {
                    t_Status = WBEM_E_PROVIDER_FAILURE ;
                }
            }
            catch ( ... )
            {
                delete [] ( UCHAR * ) t_TokenUser ;
                
                throw ;
            }
            
            if ( t_TokenUser )
            {
                delete [] ( UCHAR * ) t_TokenUser ;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else
    {
        t_Status = WBEM_E_PROVIDER_FAILURE ;
    }
    
    return t_Status ;
}


HRESULT CWin32ComputerSystem :: GetUserAccount ( CHString &a_Domain , CHString &a_User )
{
    HRESULT t_Status = S_OK ;
    
#ifdef NTONLY
    SetLastError ( 0 ) ;
    
    SmartCloseHandle t_TokenHandle;
    
    //Access check is to be made against the security context of the process for the calling thread. This is because
    //it was observed that the call failed if the logged-in user is not an Admin and access check is made against the
    //impersonated thread.Also, this is safe since we're not carrying out any activity using this token.
    BOOL t_TokenStatus = OpenThreadToken (
        
        GetCurrentThread () ,
        TOKEN_QUERY ,
        TRUE ,
        & t_TokenHandle
        ) ;
    
    if ( t_TokenStatus )
    {
        t_Status = GetAccount ( t_TokenHandle , a_Domain , a_User );
    }
    else
    {
        t_Status = WBEM_E_PROVIDER_FAILURE ;
    }
    
#endif
    
#ifdef WIN9XONLY
    TCHAR t_UserName [ _MAX_PATH + 1 ] ;
    DWORD t_UserNameLength = _MAX_PATH ;
    
    BOOL t_UserStatus = GetUserName ( t_UserName , & t_UserNameLength ) ;
    if ( t_UserStatus )
    {
        a_User = t_UserName ;
    }
    
    // The domain name is stored in different places depending on who the
    // 'PrimaryProvider' is.
    
    CHString t_RegistryValue ;
    CRegistry RegInfo ;
    
    DWORD t_RegistryStatus = RegInfo.Open (
        
        HKEY_LOCAL_MACHINE,
        IDS_RegNetworkLogon,
        KEY_READ
        ) ;
    
    if ( t_RegistryStatus == ERROR_SUCCESS )
    {
        t_RegistryStatus = RegInfo.GetCurrentKeyValue ( IDS_RegPrimaryProvider , t_RegistryValue ) ;
        if ( ! t_RegistryStatus )
        {
            if ( t_RegistryValue.CompareNoCase ( IDS_MicrosoftNetwork ) == 0 )
            {
                // Microsoft Network is the primary provider
                
                t_RegistryStatus = RegInfo.Open (
                    
                    HKEY_LOCAL_MACHINE,
                    IDS_RegNetworkProvider,
                    KEY_READ
                    ) ;
                
                if ( t_RegistryStatus == ERROR_SUCCESS )
                {
                    t_RegistryStatus = RegInfo.GetCurrentKeyValue ( IDS_RegAuthenticatingAgent , t_RegistryValue ) ;
                    if ( ! t_RegistryStatus )
                    {
                        a_Domain = t_RegistryValue ;
                    }
                }
            }
        }
        else
        {
            // We have no knowledge of other providers.
        }
        
        RegInfo.Close() ;
    }
#endif
    
    return t_Status ;
}

void CWin32ComputerSystem :: InitializePropertiestoUnknown ( CInstance *a_pInstance )
{
    a_pInstance->SetWBEMINT64( L"PauseAfterReset", (__int64) -1);
    a_pInstance->SetDWORD( L"PowerOnPasswordStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetDWORD( L"KeyboardPasswordStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetDWORD( L"AdminPasswordStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetDWORD( L"FrontPanelResetStatus", SM_BIOS_HARDWARE_SECURITY_UNKNOWN );
    a_pInstance->SetByte ( L"ChassisBootupState", CS_UNKNOWN );
    a_pInstance->SetByte ( L"PowerSupplyState", CS_UNKNOWN );
    a_pInstance->SetByte ( L"ThermalState", CS_UNKNOWN );
    a_pInstance->SetWBEMINT16( L"ResetCount", -1 );
    a_pInstance->SetWBEMINT16( L"ResetLimit", -1 );
    // Assume all computers can be reset, either through power or a reset switch.
    a_pInstance->SetWBEMINT16( L"ResetCapability", 1);
    a_pInstance->SetWBEMINT16( L"PowerState", 0 );
}

/*****************************************************************************
*
*  FUNCTION    : CWin32ComputerSystem::ExecMethod
*
*  DESCRIPTION : Executes a method
*
*  INPUTS      : Instance to execute against, method name, input parms instance
*                Output parms instance.
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CWin32ComputerSystem::ExecMethod(const CInstance& pInstance, const BSTR bstrMethodName,
                                         CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/)
{
    HRESULT t_RetVal = WBEM_S_NO_ERROR;
    CHString sComputerName = GetLocalComputerName () ;
    CHString sReqName ;
    pInstance.GetCHString ( IDS_Name , sReqName ) ;
    
    if ( sReqName.CompareNoCase ( sComputerName ) != 0 )
    {
        t_RetVal = WBEM_E_NOT_FOUND ;
    }
    else if (_wcsicmp(bstrMethodName, L"Rename") == 0)
        {
                t_RetVal = ExecRename(pInstance, pInParams, pOutParams, lFlags);
    }
    else if (_wcsicmp(bstrMethodName, L"JoinDomainOrWorkgroup") == 0)
        {
                t_RetVal = ExecJoinDomain(pInstance, pInParams, pOutParams, lFlags);
    }
    else if (_wcsicmp(bstrMethodName, L"UnjoinDomainOrWorkgroup") == 0)
        {
                t_RetVal = ExecUnjoinDomain(pInstance, pInParams, pOutParams, lFlags);
    }
    else
    {
        t_RetVal = WBEM_E_INVALID_METHOD ;
    }

    return t_RetVal ;
}

HRESULT CWin32ComputerSystem::CheckPasswordAndUserName(const CInstance& pInstance, CInstance *pInParams,
                                                                                                           CHString &a_passwd, CHString &a_username)
{
    HRESULT t_RetVal = WBEM_S_NO_ERROR;
        BOOL t_bCheckEncryption = FALSE;

    if( !pInParams->IsNull( L"Password") )
        {
                t_bCheckEncryption = TRUE;

                if (!pInParams->GetCHString( L"Password", a_passwd ))
                {
                        t_RetVal = WBEM_E_FAILED;
                }
        }

    if( !pInParams->IsNull( L"UserName") )
        {
                t_bCheckEncryption = TRUE;

                if (!pInParams->GetCHString( L"UserName", a_username ))
                {
                        t_RetVal = WBEM_E_FAILED;
                }
        }

        if (t_bCheckEncryption)
        {
                HRESULT t_hr = t_RetVal;
                t_RetVal = WBEM_E_ENCRYPTED_CONNECTION_REQUIRED;
                IServerSecurity * pss = NULL;

                if(S_OK == WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss))
                {
                        DWORD dwAuthLevel = 0;

                        if (SUCCEEDED(pss->QueryBlanket(NULL, NULL, NULL, &dwAuthLevel, NULL, NULL, NULL))
                                && dwAuthLevel >= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
                        {
                                t_RetVal = t_hr;

                                //OK one final check, if we are out of proc from winmgmt we'll get a context with the authcn level
                                if (pInstance.GetMethodContext())
                                {
                                        IWbemContext *pCtx = pInstance.GetMethodContext()->GetIWBEMContext();
                                        VARIANT t_Var;
                                        VariantInit(&t_Var);

                                        if (pCtx && SUCCEEDED(pCtx->GetValue(L"__WBEM_CLIENT_AUTHENTICATION_LEVEL", 0, &t_Var)))
                                        {
                                                if ((t_Var.vt != VT_I4) || (t_Var.lVal < RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
                                                {
                                                        t_RetVal = WBEM_E_ENCRYPTED_CONNECTION_REQUIRED;
                                                }

                                                VariantClear(&t_Var);   
                                        }

                                        if (pCtx)
                                        {
                                                pCtx->Release();
                                                pCtx = NULL;
                                        }
                                }
                        }

                        pss->Release();
                }
        }

        return t_RetVal;
}

HRESULT CWin32ComputerSystem::ExecUnjoinDomain(const CInstance& pInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/) 
{
#if NTONLY >= 5
        CHString t_passwd;
        CHString t_username;
    HRESULT t_RetVal = CheckPasswordAndUserName(pInstance, pInParams, t_passwd, t_username);

        if (SUCCEEDED(t_RetVal))
        {
                DWORD t_Flags = 0;

                if( !pInParams->IsNull( L"fUnjoinOptions") )
                {
                        if (!pInParams->GetDWORD( L"fUnjoinOptions", t_Flags ))
                        {
                                t_RetVal = WBEM_E_FAILED;
                        }
                }

                if (SUCCEEDED(t_RetVal))
                {
                        CNetAPI32 NetAPI;

                        if ( NetAPI.Init () == ERROR_SUCCESS )
                        {
                                DSROLE_PRIMARY_DOMAIN_INFO_BASIC *t_pDsInfo = 0;
                                NET_API_STATUS t_netstatus = NetAPI.NetUnjoinDomain(
                                                                                                                NULL,
                                                                                                                t_username.GetLength() > 0 ? (LPCWSTR)t_username : NULL,
                                                                                                                t_passwd.GetLength() > 0 ? (LPCWSTR)t_passwd : NULL,
                                                                                                                t_Flags);
                                pOutParams->SetDWORD ( L"ReturnValue", t_netstatus ) ;
                        }
                        else
                        {
                                t_RetVal = WBEM_E_FAILED;
                        }
                }
        }

        return t_RetVal;
#else
        return WBEM_E_NOT_SUPPORTED;
#endif
}

HRESULT CWin32ComputerSystem::ExecJoinDomain(const CInstance& pInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/) 
{
#if NTONLY >= 5
        CHString t_passwd;
        CHString t_username;
    HRESULT t_RetVal = CheckPasswordAndUserName(pInstance, pInParams, t_passwd, t_username);

        if (SUCCEEDED(t_RetVal))
        {

                if( !pInParams->IsNull( L"Name") )
                {
                        CHString t_strName;
        
                        if (pInParams->GetCHString( L"Name", t_strName ) && t_strName.GetLength())
                        {
                                DWORD t_Flags = 0;
                                CHString t_strOU;

                                if( !pInParams->IsNull( L"fJoinOptions") )
                                {
                                        if (!pInParams->GetDWORD( L"fJoinOptions", t_Flags ))
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }

                                if(SUCCEEDED(t_RetVal) && !pInParams->IsNull( L"AccountOU") )
                                {
                                        if (!pInParams->GetCHString( L"AccountOU", t_strOU ))
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }

                                if (SUCCEEDED(t_RetVal))
                                {
                                        CNetAPI32 NetAPI;

                                        if ( NetAPI.Init () == ERROR_SUCCESS )
                                        {
                                                NET_API_STATUS t_netstatus = NetAPI.NetJoinDomain(
                                                                                                                        NULL,
                                                                                                                        (LPCWSTR)t_strName,
                                                                                                                        t_strOU.GetLength() > 0 ? (LPCWSTR)t_strOU : NULL,
                                                                                                                        t_username.GetLength() > 0 ? (LPCWSTR)t_username : NULL,
                                                                                                                        t_passwd.GetLength() > 0 ? (LPCWSTR)t_passwd : NULL,
                                                                                                                        t_Flags
                                                                                                                        );

                                                pOutParams->SetDWORD ( L"ReturnValue", t_netstatus ) ;
                                        }
                                        else
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }
                        }
                        else
                        {
                                t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                        }
                }
                else
                {
                        t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                }
        }

        return t_RetVal;
#else
        return WBEM_E_NOT_SUPPORTED;
#endif
}

HRESULT CWin32ComputerSystem::ExecRename(const CInstance& pInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags /*= 0L*/) 
{
        CHString t_passwd;
        CHString t_username;
    HRESULT t_RetVal = CheckPasswordAndUserName(pInstance, pInParams, t_passwd, t_username);

        if (SUCCEEDED(t_RetVal))
        {
                if( !pInParams->IsNull( L"Name") )
                {
                        CHString t_strName;
        
                        if (pInParams->GetCHString( L"Name", t_strName ) && t_strName.GetLength())
                        {
#if NTONLY >= 5
                                CNetAPI32 NetAPI;

                                if ( NetAPI.Init () == ERROR_SUCCESS )
                                {
                                        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *t_pDsInfo = 0;
    
                                        NET_API_STATUS t_netstatus = NetAPI.DSRoleGetPrimaryDomainInfo(
                                                NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&t_pDsInfo ) ;
    
                                        if( t_netstatus == NERR_Success && t_pDsInfo )
                                        {
                                                try
                                                {
                                                        switch( t_pDsInfo->MachineRole )
                                                        {
                                                                case DsRole_RoleMemberWorkstation:
                                                                case DsRole_RoleMemberServer:
                                                                case DsRole_RoleBackupDomainController:
                                                                case DsRole_RolePrimaryDomainController:
                                                                {
                                                                        //Rename the machine in the domain
                                                                        t_netstatus = NetAPI.NetRenameMachineInDomain(
                                                                                                        NULL,                                                                                                           //local machine
                                                                                                        t_strName,                                                                                                      //new machine name
                                                                                                        t_username.GetLength() > 0 ? (LPCWSTR)t_username : NULL,        //use calling context (user)
                                                                                                        t_passwd.GetLength() > 0 ? (LPCWSTR)t_passwd : NULL,            //use calling context (passwd)
                                                                                                        NETSETUP_ACCT_CREATE);
                                                                        pOutParams->SetDWORD ( L"ReturnValue", t_netstatus ) ;
                                                                }
                                                                break;
                
                                                                case DsRole_RoleStandaloneWorkstation:
                                                                case DsRole_RoleStandaloneServer:
                                                                {
                                                                        //we're not in a domain...
                                                                        if( SetComputerNameEx(ComputerNamePhysicalDnsHostname, t_strName ) )
                                                                        {
                                                                                pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                                                                        }
                                                                        else
                                                                        {
                                                                                //worst case....
                                                                                if( SetComputerNameEx(ComputerNamePhysicalNetBIOS, t_strName ) )
                                                                                {
                                                                                        pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                                                                                }
                                                                                else
                                                                                {
                                                                                        pOutParams->SetDWORD ( L"ReturnValue", GetLastError() ) ;
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                                catch( ... )
                                                {
                                                        NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
                                                        throw ;
                                                }
                                                NetAPI.DSRoleFreeMemory( (LPBYTE)t_pDsInfo ) ;
                                        }
                                        else
                                        {
                                                t_RetVal = WBEM_E_FAILED;
                                        }
                                }
                                else
                                {
                                        t_RetVal = WBEM_E_FAILED;
                                }
#else
                                if( SetComputerName( t_strName ) )
                                {
                                        pOutParams->SetDWORD ( L"ReturnValue", 0 ) ;
                                }
                                else
                                {
                                        pOutParams->SetDWORD ( L"ReturnValue", GetLastError() ) ;
                                }
#endif
                        }
                        else
                        {
                                t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                        }
                }
                else
                {
                        t_RetVal = WBEM_E_INVALID_METHOD_PARAMETERS ;
                }
        }

        return t_RetVal;
}

bool CWin32ComputerSystem::UpdatingSystemStartupOptions(
    const CInstance &pInstance)
{
    bool fRet = false;
    variant_t vStartupOpts;

    pInstance.GetVariant(IDS_SystemStartupOptions, vStartupOpts);

    if(vStartupOpts.parray && 
        vStartupOpts.vt == (VT_BSTR | VT_ARRAY) &&
        (1 == ::SafeArrayGetDim(vStartupOpts.parray)))
    {
        fRet = true;
    }    

    return fRet;
}



HRESULT CWin32ComputerSystem::UpdateSystemStartupOptions(
    const CInstance& pInstance,
    const CHString& chstrFilename)

{
    HRESULT hrRet = WBEM_E_FAILED;

    LONG lLBound = 0;
    LONG lUBound = 0;
    variant_t vStartupOpts;
    SAFEARRAY* saStartupOpts = NULL;
    CHStringArray rgchstrOptions;

    pInstance.GetVariant(IDS_SystemStartupOptions, vStartupOpts);

    if(vStartupOpts.parray && 
        vStartupOpts.vt == (VT_BSTR | VT_ARRAY))
    {
        saStartupOpts = vStartupOpts.parray;
    
        if(1 == ::SafeArrayGetDim(saStartupOpts))
        {
            // Get the bounds...
            if(S_OK == ::SafeArrayGetLBound(saStartupOpts, 1, &lLBound) &&
               S_OK == ::SafeArrayGetUBound(saStartupOpts, 1, &lUBound))
            {
                for(long ldx = lLBound; ldx <= lUBound; ldx++)
                {
                    BSTR bstrRole = NULL;
        
                    ::SafeArrayGetElement(
                        saStartupOpts, 
                        &ldx, 
                        &bstrRole);
        
                    // Take ownership of the bstr to
                    // guarentee freeing...
                    bstr_t bstrtRole(bstrRole, false);
        
                    // Store each startup option...
                    rgchstrOptions.Add(bstrtRole);
                }

                // Write the entries out to boot.ini...
                if(rgchstrOptions.GetSize() > 0)
                {
                    hrRet = WriteOptionsToIniFile(
                        rgchstrOptions,
                        chstrFilename);
                }
            }
            else
            {
                ASSERT_BREAK(0);
                LogErrorMessage(L"Could not retrieve SAFEARRAY element while setting system startup options");
                hrRet = WBEM_E_FAILED;
            }
        }
        else
        {
            hrRet = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hrRet = WBEM_E_INVALID_PARAMETER;
    }

    return hrRet;
}


HRESULT CWin32ComputerSystem::WriteOptionsToIniFile(
    const CHStringArray& rgchstrOptions,
    const CHString& chstrFilename)
{
    HRESULT hrRet = WBEM_S_NO_ERROR;
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwAttribs;
    DWORD dwSize;
    CHStringArray rgchstrOldOptions;

    // The boot.ini entry of concern here resembles the following:
    //
    // [operating systems]
    // multi(0)disk(0)rdisk(0)partition(4)\WINNT="Microsoft Windows Whistler Advanced Server" /fastdetect /debug /baudrate=57600
    // multi(0)disk(0)rdisk(0)partition(2)\WIN2K="Microsoft Windows Whistler Professional" /fastdetect /debug 
    // multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows NT Workstation Version 4.00" 
    // multi(0)disk(0)rdisk(0)partition(1)\WINNT="Windows NT Workstation Version 4.00 [VGA mode]" /basevideo /sos
    //
    // Each element in the rgchstrOptions array is the contents
    // of the right side of the equal signn in the name value pairs
    // as shown above.  
    //
    // First thing to do: see if we can write to the file, and
    // if not (due to read only attribute being set), alter the
    // attributes so we can.
    
    CFileAttributes fa(chstrFilename);
    dwError = fa.GetAttributes(&dwAttribs);

    if(dwError == ERROR_SUCCESS)
    {
        dwError = fa.SetAttributes(dwAttribs & ~FILE_ATTRIBUTE_READONLY);

        if(dwError == ERROR_SUCCESS)
        {
            // GetPrivateProfileSection won't tell you how
            // big a buffer you need, so allocate a reasonable
            // size one first, then try a much bigger one.  If
            // still not big enough, bail.
            LPWSTR wstrSection = NULL;
            try
            {
                wstrSection = new WCHAR[PROF_SECT_SIZE + 2];
                if(wstrSection)
                {
                    dwSize = WMI_FILE_GetPrivateProfileSectionW(
                        L"operating systems",
                        wstrSection,
                        PROF_SECT_SIZE,
                        chstrFilename);
                        
                    if(dwSize == PROF_SECT_SIZE)
                    {
                        delete wstrSection;
                        wstrSection = NULL;
                        
                        wstrSection = new WCHAR[(PROF_SECT_SIZE * 10) + 2];

                        if(wstrSection)
                        {
                            dwSize = WMI_FILE_GetPrivateProfileSectionW(
                                L"operating systems",
                                wstrSection,
                                PROF_SECT_SIZE,
                                chstrFilename);
                        
                            if(dwSize == (PROF_SECT_SIZE * 10))
                            {
                                // bail...
                                dwError = E_FAIL;
                                delete wstrSection;
                                wstrSection = NULL;
                                hrRet = WBEM_E_ACCESS_DENIED;
                            }
                        }
                        else
                        {
                            dwError = E_FAIL;
                            hrRet = WBEM_E_OUT_OF_MEMORY;
                        }
                    }

                    // Proceed if we got all the section contents...
                    if(dwError == ERROR_SUCCESS)
                    {
                        // Place the section contents into an array...
                        if(wstrSection)
                        {
                            LPWSTR pwc = wstrSection;
                            rgchstrOldOptions.Add(pwc);
                            pwc += (wcslen(pwc) + 1);

                            for(; *pwc != L'\0'; )
                            {
                                rgchstrOldOptions.Add(pwc);
                                pwc += (wcslen(pwc) + 1);
                            }
                        }
                        else
                        {
                            if(rgchstrOptions.GetSize() != 0)
                            {
                                // We were given option entries but
                                // the [operating systems] section
                                // was empty.
                                hrRet = WBEM_E_INVALID_PARAMETER;
                            }
                        }
                    }

                    if(wstrSection)
                    {
                        delete wstrSection;
                        wstrSection = NULL;
                    }
                }
                else
                {
                    hrRet = WBEM_E_OUT_OF_MEMORY;
                }
            }
            catch(...)
            {
                if(wstrSection)
                {
                    delete wstrSection;
                    wstrSection = NULL;
                }
                throw;
            }

            // First check:  do we have the same number
            // of name value pairs initially in the ini file
            // as we have elements in the new options array?
            if(SUCCEEDED(hrRet))
            {
                long lElemCount = rgchstrOptions.GetSize();

                if(lElemCount ==
                    rgchstrOldOptions.GetSize())
                {
                    // Prepare output buffer...
                    LPWSTR wstrOut = NULL;
                    dwSize = 0;
                    for(long m = 0; m < lElemCount; m++)
                    {
                        dwSize += rgchstrOptions[m].GetLength();
                        // Need space for extra NULL for each string...
                        dwSize++;
                    }

                    // That accounted for the values.  Now allocate space
                    // for the name and the equal sign.  The following ends
                    // up counting more space than we need, but it faster
                    // than finding the equal sign, counting the characters
                    // up to it, and adding one for the equal sign, for each
                    // name value pair.
                    for(m = 0; m < lElemCount; m++)
                    {
                        dwSize += rgchstrOldOptions[m].GetLength();
                        // Need space for extra NULL for each string...
                        dwSize++;
                    }


                    // Need space for extra second NULL at end of block...
                    dwSize += 1;

                    try
                    {
                        wstrOut = new WCHAR[dwSize];

                        if(wstrOut)
                        {
                            ::ZeroMemory(wstrOut, dwSize*sizeof(WCHAR));

                            WCHAR* pwc = wstrOut;
                            CHString chstrTmp;

                            for(m = 0; m < lElemCount; m++)
                            {
                                chstrTmp = rgchstrOldOptions[m].SpanExcluding(L"=");
                                chstrTmp += L"=";
                                chstrTmp += rgchstrOptions[m];
                                memcpy(pwc, chstrTmp, (chstrTmp.GetLength())*sizeof(WCHAR));
                                // Move insertion pointer ahead, including one space for
                                // a null at the end of the string...
                                pwc += (chstrTmp.GetLength() + 1);
                            }

                            // Now write out the section...
                            if(!WMI_FILE_WritePrivateProfileSectionW(
                                L"operating systems",
                                wstrOut,
                                chstrFilename))
                            {
                                DWORD dwWriteErr = ::GetLastError();
                                hrRet = WinErrorToWBEMhResult(dwWriteErr);
                                LogErrorMessage2(
                                    L"Failed to write out [operating systems] private profile section data to boot.ini, with error %d",
                                    dwWriteErr);
                            }
                        }
                        else
                        {
                            hrRet = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    catch(...)
                    {
                        if(wstrOut)
                        {
                            delete wstrOut;
                            wstrOut = NULL;
                        }
                        throw;
                    }
                }
                else
                {
                    hrRet = WBEM_E_INVALID_PARAMETER;
                }
            }
        }
        else
        {
            hrRet = WinErrorToWBEMhResult(dwError);
        }
    }
    else
    {
        hrRet = WinErrorToWBEMhResult(dwError);
    }

    return hrRet;
}





#if NTONLY >= 5
void CWin32ComputerSystem::SetUserName(
    CInstance* pInstance)
{
    CSid sidThreadUser;

    if(GetUserOnThread(sidThreadUser))
    {
        CSid sidLoggedOnUser;
        CSid sidTemp;

        bool fGotLoggedOnUser = false;
        if(GetLoggedOnUserViaTS(sidTemp))
        {
            sidLoggedOnUser = sidTemp;
            fGotLoggedOnUser = true;
        }

        if(!fGotLoggedOnUser)
        {
            if(GetLoggedOnUserViaImpersonation(sidTemp))
            {
                sidLoggedOnUser = sidTemp;
                fGotLoggedOnUser = true;
            }
        }

        if(fGotLoggedOnUser)
        {
            CHString chstrUserDomAndName;
            CHString chstrUserDom = sidLoggedOnUser.GetDomainName();
            CHString chstrUserName = sidLoggedOnUser.GetAccountName();

            if(chstrUserDom.GetLength() > 0)
            {
                chstrUserDomAndName = chstrUserDom;
                chstrUserDomAndName += L"\\";
            }

            chstrUserDomAndName += chstrUserName;

            pInstance->SetCHString(
                IDS_UserName,
                chstrUserDomAndName);
        }
    }
}
#endif


#if NTONLY >= 5
bool CWin32ComputerSystem::GetUserOnThread(
    CSid& sidUserOnThread)
{
    bool fRet = false;
    CSid sidTemp;
    SmartCloseHandle hThread;
    SmartCloseHandle hToken;
    PTOKEN_USER ptokusr = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwRetSize = 0L;

    // the token user struct varries
    // in size depending on the size
    // of the sid in the SID_AND_ATTRIBUTES
    // structure, so need to allocate
    // it dynamically.

    hThread = GetCurrentThread();
    if(hThread != INVALID_HANDLE_VALUE)
    {
        if(::OpenThreadToken(
            hThread,
            TOKEN_QUERY,
            FALSE,    // open with the thread's, not the processes' credentials
            &hToken))
        {
            if(!::GetTokenInformation(
                hToken,
                TokenUser,
                NULL,
                0L,
                &dwRetSize))
            {
                dwRet = ::GetLastError();
            }

            if(dwRet == ERROR_INSUFFICIENT_BUFFER)
            {
                // now get it for real...
                // (new throws on failure, don't need to check)
                ptokusr = (PTOKEN_USER) new BYTE[dwRetSize]; 
                try
                { 
                    DWORD dwTmp = dwRetSize;

                    if(::GetTokenInformation(
                        hToken,
                        TokenUser,
                        ptokusr,
                        dwTmp,
                        &dwRetSize))
                    {
                        sidTemp = ptokusr->User.Sid;
                    }
                 
                    delete ptokusr;
                    ptokusr = NULL;
                }
                catch(...)
                {
                    if(ptokusr)
                    {
                        delete ptokusr;
                        ptokusr = NULL;
                    }
                    throw;
                }
            }
        }
    }

    if(sidTemp.IsOK() && sidTemp.IsValid())
    {
        sidUserOnThread = sidTemp;
        fRet = true;
    }

    return fRet;
}
#endif


#if NTONLY >= 5
bool CWin32ComputerSystem::GetLoggedOnUserViaTS(
    CSid& sidLoggedOnUser)
{
    bool fRet = false;
    bool fCont = true;
    PWTS_SESSION_INFO psesinfo = NULL;
    DWORD dwSessions = 0;
    LPWSTR wstrUserName = NULL;
    LPWSTR wstrDomainName = NULL;
    LPWSTR wstrWinstaName = NULL;
    DWORD dwSize = 0L;

    // Use of delay loaded functions requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        if(!(::WTSEnumerateSessions(
           WTS_CURRENT_SERVER_HANDLE,
           0,
           1,
           &psesinfo,
           &dwSessions) && psesinfo))
        {
            fCont = false;
        }

        if(fCont)
        {
            for(int j = 0; j < dwSessions && !fRet; j++, fCont = true)
            {
                if(psesinfo[j].State != WTSActive)
                {
                    fCont = false;
                }

                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSUserName,
                        &wstrUserName,
                        &dwSize) && wstrUserName))
                    {
                        fCont = false;
                    }
                }
                
                if(fCont)
                {
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSDomainName,
                        &wstrDomainName,
                        &dwSize) && wstrDomainName))
                    {
                        fCont = false;
                    }
                }
                    
                if(fCont)
                {            
                    if(!(::WTSQuerySessionInformation(
                        WTS_CURRENT_SERVER_HANDLE,
                        psesinfo[j].SessionId,
                        WTSWinStationName,
                        &wstrWinstaName,
                        &dwSize) && wstrWinstaName))   
                    {
                        fCont = false;
                    }
                }

                if(fCont)
                {
                    if(_wcsicmp(wstrWinstaName, L"Console") != 0)
                    {
                        fCont = false;
                    }
                }

                if(fCont)
                {
                    // That establishes that this user
                    // is associated with the interactive
                    // desktop.
                    CSid sidInteractive(wstrDomainName, wstrUserName, NULL);
    
                    if(sidInteractive.IsOK() && sidInteractive.IsValid())
                    {
                        sidLoggedOnUser = sidInteractive;
                        fRet = true;
                    }
                }

                if(wstrUserName)
                {
                    WTSFreeMemory(wstrUserName);
					wstrUserName = NULL;
                }
                if(wstrDomainName)
                {
                    WTSFreeMemory(wstrDomainName);
					wstrDomainName = NULL;
                }
                if(wstrWinstaName)
                {
                    WTSFreeMemory(wstrWinstaName);
					wstrWinstaName = NULL;
                }
            }

            if(psesinfo)
            {
                WTSFreeMemory(psesinfo);
                psesinfo = NULL;
            }
        }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
		fRet = false;

        if(wstrUserName)
        {
            WTSFreeMemory(wstrUserName);
			wstrUserName = NULL;
        }
        if(wstrDomainName)
        {
            WTSFreeMemory(wstrDomainName);
			wstrDomainName = NULL;
        }
        if(wstrWinstaName)
        {
            WTSFreeMemory(wstrWinstaName);
			wstrWinstaName = NULL;
        }
        if(psesinfo)
        {
            WTSFreeMemory(psesinfo);
            psesinfo = NULL;
        }
    }
    catch(...)
    {
        if(wstrUserName)
        {
            WTSFreeMemory(wstrUserName);
			wstrUserName = NULL;
        }
        if(wstrDomainName)
        {
            WTSFreeMemory(wstrDomainName);
			wstrDomainName = NULL;
        }
        if(wstrWinstaName)
        {
            WTSFreeMemory(wstrWinstaName);
			wstrWinstaName = NULL;
        }
        if(psesinfo)
        {
            WTSFreeMemory(psesinfo);
            psesinfo = NULL;
        }
        throw;
    }

    return fRet;
}
#endif


#if NTONLY >= 5
bool CWin32ComputerSystem::GetLoggedOnUserViaImpersonation(
    CSid& sidLoggedOnUser)
{
    bool fRet = false;
    CImpersonateLoggedOnUser impersonateLoggedOnUser;

    if(impersonateLoggedOnUser.Begin())
    {
        try
        {
            CHString chstrDomain;
            CHString chstrUserName;
            CHString chstrDomainAndUser;
            {
                // do actual lookup inside mutex
                CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
                
                if(SUCCEEDED(GetUserAccount(
                    chstrDomain, 
                    chstrUserName)))
                {
                    CSid sidTemp(chstrDomain, chstrUserName, NULL);
                    if(sidTemp.IsOK() && sidTemp.IsValid())
                    {
                        sidLoggedOnUser = sidTemp;
                        fRet = true;
                    }
                }
            }
        }
        catch(...)
        {
            impersonateLoggedOnUser.End();
            throw ;
        }
        
        impersonateLoggedOnUser.End();
    }

    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\configmg.h ===
/****************************************************************************

*                                                                           *

* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *

* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *

* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *

* PURPOSE.                                                                  *

*                                                                           *

* Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

//#ifdef	GOLDEN	
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
//#endif

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
	"Find_Range", \
	"Get_Global_State", \
	"Broadcast_Device_Change_Message", \
	"Call_DevNode_Handler", \
	"Remove_Reinsert_All", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040
#define BusType_USB         0x00000080
/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_NO_MORE_HW_PROFILES	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_FREE_RESOURCES	0x00000029
#define	CR_QUERY_VETOED		0x0000002A
#define	CR_CANT_SHARE_IRQ	0x0000002B
#define	NUM_CR_RESULTS		0x0000002C

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E
#define	NUM_CM_PROB				0x0000001F

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down

#define	NUM_CONFIG_COMMANDS	0x00000013	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\comobjsecregkey.cpp ===
//=============================================================================================================

//

// COMObjSecRegKey.CPP -- implementation file for CCOMObjectSecurityRegistryKey class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/25/98    a-dpawar       Created
//
//==============================================================================================================

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "COMObjSecRegKey.h"

#ifdef NTONLY

///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey()
:	CSecurityDescriptor()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey
//
//	Alternate Class CTOR
//
//	Inputs:
//				PSECURITY_DESCRIPTOR- Security Descriptor stored in the registry for the COM Class
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CCOMObjectSecurityRegistryKey::CCOMObjectSecurityRegistryKey( PSECURITY_DESCRIPTOR a_pSD )
:	CSecurityDescriptor( a_pSD )
{
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::~CCOMObjectSecurityRegistryKey
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CCOMObjectSecurityRegistryKey::~CCOMObjectSecurityRegistryKey( void )
{
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CCOMObjectSecurityRegistryKey::WriteAcls( PSECURITY_DESCRIPTOR a_pAbsoluteSD, SECURITY_INFORMATION a_securityinfo )
{
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CCOMObjectSecurityRegistryKey::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CCOMObjectSecurityRegistryKey::WriteOwner( PSECURITY_DESCRIPTOR a_pAbsoluteSD )
{
	return ERROR_SUCCESS;
}

DWORD CCOMObjectSecurityRegistryKey::AllAccessMask( void )
{
	// File specific All Access Mask
	return FILE_ALL_ACCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cprocess.cpp ===
//=================================================================

//

// WMIProcess.CPP --Process property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/27/97	 a-hhance		updated to new framework paradigm.
//				1/13/98		a-brads		updated to V2 MOF
//
//=================================================================

#include "precomp.h"
#include <userenv.h>

#pragma warning ( disable : 4005 )
#include <cregcls.h>
#include <winperf.h>
#include <tlhelp32.h>
#include <mmsystem.h>

#include "WBEMPSAPI.h"
#include "WBEMToolH.h"
#include "sid.h"
#include "userhive.h"
#include "systemname.h"
#include <createmutexasprocess.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "NtDllApi.h"
#include "UserEnvApi.h"

#include "resource.h"

#include "CProcess.h"
#include "tokenprivilege.h"

#ifdef WIN9XONLY
bool GetThreadList ( CKernel32Api &a_ToolHelp, std::deque<DWORD> & a_ThreadQ )	;
#endif

#if NTONLY >= 5
typedef BOOLEAN ( WINAPI *pfnWinStationGetProcessSid )( HANDLE hServer, DWORD ProcessId , FILETIME ProcessStartTime , PBYTE pProcessUserSid , PDWORD dwSidSize );
#endif


// Property set declaration
//=========================

Process MyProcessSet ( PROPSET_NAME_PROCESS , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : Process::Process
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Process :: Process (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::~Process
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

Process :: ~Process ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process :: GetObject (

	CInstance* pInstance,
	long lFlags,
    CFrameworkQuery &pQuery
)
{
	HRESULT hRetCode = WBEM_E_FAILED;

    // Initialize API DLL & freshen the cache
    //=======================================

#ifdef NTONLY

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	CNtDllApi *pNtdll = ( CNtDllApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
	if ( pNtdll )
	{
		try
		{
			t_ProcessBlock = RefreshProcessCacheNT ( *pNtdll , pInstance->GetMethodContext () , & hRetCode ) ;
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

			throw ;
		}
	}

	if ( ! SUCCEEDED ( hRetCode ) )
	{
		if ( t_ProcessBlock )
		{
			delete []  t_ProcessBlock;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		return hRetCode ;
	}

#endif
#ifdef WIN9XONLY

	PROCESS_CACHE PCache ;

    CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if ( pKernel32 != NULL)
    {
        if ( RefreshProcessCacheWin95(*pKernel32, PCache ) )
		{
			hRetCode = S_OK ;
		}
    }

	if ( ! SUCCEEDED ( hRetCode ) )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidKernel32Api, pKernel32 ) ;

		return hRetCode ;
	}

	std::deque<DWORD> t_ThreadQ ;
	GetThreadList ( *pKernel32, t_ThreadQ )	;

#endif

	hRetCode = WBEM_E_FAILED ;

	try
	{
		// Look for key values
		//====================

		CHString chsHandle;
		pInstance->GetCHString ( IDS_Handle , chsHandle ) ;

		DWORD processID ;
        WCHAR wszHandle[MAXITOA];

		if ( swscanf ( chsHandle, L"%lu" , & processID ) && (wcscmp ( chsHandle , _ultow(processID, wszHandle, 10)) == 0 ))
		{
			BOOL t_Found = FALSE ;

#ifdef NTONLY

			SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = GetProcessBlock ( *pNtdll , t_ProcessBlock , processID ) ;
			if ( t_CurrentInformation )
			{
				t_Found = TRUE ;
			}
#else

			for ( DWORD i = 0 ; i < PCache.dwProcessCount ; i++ )
			{
				if ( processID == PCache.pdwPIDList [ i ] )
				{
					t_Found = TRUE ;
					break ;
				}
			}
#endif

			if ( t_Found )
			{

			// Load all properties
			//====================

                if (!pQuery.KeysOnly())
                {
#ifdef NTONLY
					hRetCode = LoadCheapPropertiesNT ( *pNtdll, t_CurrentInformation , pInstance ) 
								? WBEM_S_NO_ERROR : WBEM_E_FAILED;
#endif

#ifdef WIN9XONLY
	    			hRetCode = LoadCheapPropertiesWin95(*pKernel32, i, PCache, pInstance, t_ThreadQ ) 
								? WBEM_S_NO_ERROR : WBEM_E_FAILED;
#endif
                }
                else
                {
                    hRetCode = WBEM_S_NO_ERROR;
                }

			}
			else
			{
				hRetCode = WBEM_E_NOT_FOUND ;
			}

		}
		else
		{
			hRetCode = WBEM_E_NOT_FOUND ;
		}
	}
	catch ( ... )
	{
#ifdef NTONLY

		if ( t_ProcessBlock )
		{
			delete [] t_ProcessBlock ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

#ifdef WIN9XONLY

        CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidKernel32Api, pKernel32 ) ;

#endif

		throw ;
	}

#ifdef NTONLY

	if ( t_ProcessBlock )
	{
		delete [] t_ProcessBlock;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

#ifdef WIN9XONLY

    CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidKernel32Api, pKernel32 ) ;

#endif

    return hRetCode ;
}

HRESULT Process::ExecQuery (

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    return Enumerate(pMethodContext, lFlags, pQuery.KeysOnly());
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::AddDynamicInstances
 *
 *  DESCRIPTION : Creates instance of property set for each discovered process
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags, FALSE);
}

HRESULT Process :: Enumerate (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/,
    BOOL bKeysOnly
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initialize API DLL & freshen the cache
    //=======================================

#ifdef NTONLY

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	CNtDllApi *pNtdll = ( CNtDllApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
	if ( pNtdll )
	{
		try
		{
			t_ProcessBlock = RefreshProcessCacheNT ( *pNtdll , pMethodContext , &hr ) ;
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

			throw ;
		}
	}

	if ( ! SUCCEEDED ( hr ) )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		return hr ;
	}

#endif
#ifdef WIN9XONLY

    PROCESS_CACHE PCache ;

    CKernel32Api* pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
    if ( pKernel32 != NULL)
    {
        if ( RefreshProcessCacheWin95(*pKernel32, PCache ) )
		{
			hr = S_OK ;
		}
    }

	if ( ! SUCCEEDED ( hr ) )
	{
		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidKernel32Api, pKernel32 ) ;

		return hr ;
	}

#endif

	try
	{
#ifdef NTONLY

		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;

		while ( t_CurrentInformation )
		{
			CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

            WCHAR wszHandle[_MAX_PATH];
            _ui64tow( HandleToUlong ( t_CurrentInformation->UniqueProcessId ), wszHandle, 10);
            pInstance->SetWCHARSplat(IDS_Handle, wszHandle);

            BOOL bRetCode = TRUE;
            if (!bKeysOnly)
            {
			    bRetCode = LoadCheapPropertiesNT (

				    *pNtdll ,
				    t_CurrentInformation ,
				    pInstance
			    ) ;
            }

			if( bRetCode)
			{
				HRESULT t_hr ;
				if ( FAILED ( t_hr = pInstance->Commit () ) )
				{
					hr = t_hr ;
					break ;
				}
			}

			t_CurrentInformation = NextProcessBlock ( *pNtdll , t_CurrentInformation ) ;
		}

#else
		std::deque<DWORD> t_ThreadQ ;
		GetThreadList ( *pKernel32, t_ThreadQ )	;
		// Create instances for all valid processes
		//=========================================

		for ( DWORD i = 0 ; i < PCache.dwProcessCount && SUCCEEDED ( hr ) ; i ++ )
		{
			CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

	        WCHAR wszHandle [ _MAX_PATH ] ;
	        _ui64tow(PCache.pdwPIDList [ i ], wszHandle, 10 ) ;
	        pInstance->SetWCHARSplat ( IDS_Handle , wszHandle ) ;

            BOOL bRetCode = TRUE;
            if (!bKeysOnly)
            {
			    bRetCode = LoadCheapPropertiesWin95 (

				    *pKernel32,
				    i,
				    PCache,
				    pInstance ,
					t_ThreadQ
			    ) ;
            }

			if( bRetCode)
			{
				hr = pInstance->Commit (  ) ;
			}
		}
#endif
	}
	catch ( ... )
	{
#ifdef NTONLY

		if ( t_ProcessBlock )
		{
			delete [] t_ProcessBlock;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

#ifdef WIN9XONLY

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidKernel32Api, pKernel32 ) ;

#endif

		throw ;
	}

#ifdef NTONLY

	if ( t_ProcessBlock )
	{
		delete [] t_ProcessBlock;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi , pNtdll ) ;

#endif

#ifdef WIN9XONLY

    CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidKernel32Api, pKernel32 ) ;

#endif

    return  hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::RefreshProcessCacheNT
 *
 *  DESCRIPTION : Refreshes cache of key properties
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE if unable to refresh
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
SYSTEM_PROCESS_INFORMATION *Process :: RefreshProcessCacheNT (

	CNtDllApi &a_NtApi ,
	MethodContext *pMethodContext ,
	HRESULT *a_phrRetVal /* = NULL */
)
{
    // Without this privilege, a local admin user won't be able to see all the
    // information of some system processes.
	if ( ! EnablePrivilegeOnCurrentThread ( SE_DEBUG_NAME ) )
    {
	    *a_phrRetVal = WBEM_S_PARTIAL_RESULTS ;
		SAFEARRAYBOUND rgsabound [ 1 ] ;
	    rgsabound[0].cElements = 1;
	    rgsabound[0].lLbound = 0;

	    SAFEARRAY *psaPrivilegesReqd = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;

		SAFEARRAY *psaPrivilegesNotHeld = SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ;

        if ( psaPrivilegesReqd && psaPrivilegesNotHeld )
        {
			try
			{
				long index = 0 ;

				bstr_t privilege(L"SE_DEBUG_NAME");

				HRESULT t_Result = SafeArrayPutElement ( psaPrivilegesReqd, & index, (void *)(BSTR)privilege ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				t_Result = SafeArrayPutElement ( psaPrivilegesNotHeld, &index, (void *)(BSTR)privilege ) ;
				if ( t_Result == E_OUTOFMEMORY )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			catch ( ... )
			{
				if ( psaPrivilegesNotHeld )
				{
					SafeArrayDestroy ( psaPrivilegesNotHeld ) ;
				}

				if ( psaPrivilegesReqd )
				{
					SafeArrayDestroy ( psaPrivilegesReqd ) ;
				}

				throw ;
			}
        }
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}

        if ( psaPrivilegesNotHeld )
		{
            SafeArrayDestroy ( psaPrivilegesNotHeld ) ;
		}

        if ( psaPrivilegesReqd )
		{
            SafeArrayDestroy ( psaPrivilegesReqd ) ;
		}
    }
	else
	{
		*a_phrRetVal = S_OK ;
	}

	return GetProcessBlocks ( a_NtApi ) ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : Process::LoadCheapPropertiesNT
 *
 *  DESCRIPTION : Retrieves 'easy-to-get' properties
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE if unable
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
BOOL Process::LoadCheapPropertiesNT (

	CNtDllApi &a_NtApi ,
	SYSTEM_PROCESS_INFORMATION *a_ProcessBlock ,
	CInstance* pInstance
)
{
	SetCreationClassName ( pInstance ) ;

	pInstance->SetDWORD ( IDS_ProcessID, HandleToUlong ( a_ProcessBlock->UniqueProcessId ) ) ;

	if ( a_ProcessBlock->ImageName.Buffer )
	{
		pInstance->SetWCHARSplat ( IDS_Name , a_ProcessBlock->ImageName.Buffer ) ;

		pInstance->SetWCHARSplat ( IDS_Caption , a_ProcessBlock->ImageName.Buffer ) ;

		pInstance->SetWCHARSplat ( IDS_Description, a_ProcessBlock->ImageName.Buffer ) ;
	}
	else
	{
		switch ( HandleToUlong ( a_ProcessBlock->UniqueProcessId ) )
		{
			case 0:
			{
				pInstance->SetWCHARSplat ( IDS_Name , L"System Idle Process" ) ;

				pInstance->SetWCHARSplat ( IDS_Caption , L"System Idle Process" ) ;

				pInstance->SetWCHARSplat ( IDS_Description, L"System Idle Process" ) ;
			}
			break ;

			case 2:
			case 8:
			{
				pInstance->SetWCHARSplat ( IDS_Name , L"System" ) ;

				pInstance->SetWCHARSplat ( IDS_Caption , L"System" ) ;

				pInstance->SetWCHARSplat ( IDS_Description, L"System" ) ;
			}
			break ;

			default:
			{
				pInstance->SetWCHARSplat ( IDS_Name , IDS_Unknown ) ;

				pInstance->SetWCHARSplat ( IDS_Caption , IDS_Unknown ) ;

				pInstance->SetWCHARSplat ( IDS_Description, IDS_Unknown ) ;
			}
			break ;
		}
	}

	// let's make the key
	pInstance->SetWCHARSplat ( IDS_CSCreationClassName , L"Win32_ComputerSystem" ) ;

	pInstance->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

	WCHAR szHandle [ _MAX_PATH ] ;
	_stprintf ( szHandle , _T("%lu"), HandleToUlong ( a_ProcessBlock->UniqueProcessId ) ) ;
	pInstance->SetWCHARSplat ( IDS_Handle , szHandle ) ;

	pInstance->SetWCHARSplat ( IDS_OSCreationClassName , L"Win32_OperatingSystem" ) ;

	OSVERSIONINFO OSVersionInfo ;
	CHString chsOs;

	OSVersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ) ;
	if ( ! GetVersionEx ( & OSVersionInfo ) )
	{
		return FALSE ;
	}

	WCHAR wszTemp[_MAX_PATH] ;
    swprintf (	wszTemp,
				L"%d.%d.%hu",
				OSVersionInfo.dwMajorVersion,
				OSVersionInfo.dwMinorVersion,
				LOWORD ( OSVersionInfo.dwBuildNumber )
			) ;

	pInstance->SetWCHARSplat(IDS_WindowsVersion, wszTemp );

	CSystemName sys;
	CHString strOS = sys.GetLongKeyName();

	pInstance->SetCHString ( IDS_OSName, strOS ) ;

	pInstance->SetDWORD ( IDS_PageFaults , a_ProcessBlock->PageFaultCount ) ;

	pInstance->SetDWORD ( IDS_PeakWorkingSetSize , a_ProcessBlock->PeakWorkingSetSize ) ;

	pInstance->SetWBEMINT64 ( IDS_WorkingSetSize , (const unsigned __int64) a_ProcessBlock->WorkingSetSize ) ;

	pInstance->SetDWORD ( IDS_QuotaPeakPagedPoolUsage , a_ProcessBlock->QuotaPeakPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_QuotaPagedPoolUsage , a_ProcessBlock->QuotaPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_QuotaPeakNonPagedPoolUsage , a_ProcessBlock->QuotaPeakNonPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_QuotaNonPagedPoolUsage , a_ProcessBlock->QuotaNonPagedPoolUsage ) ;

	pInstance->SetDWORD ( IDS_PageFileUsage , a_ProcessBlock->PagefileUsage ) ;

	pInstance->SetDWORD ( IDS_PeakPageFileUsage , a_ProcessBlock->PeakPagefileUsage ) ;

	pInstance->SetDWORD ( IDS_Priority , a_ProcessBlock->BasePriority ) ;
/*
 *  For "System" & "System Idle" , Creation Time (offset from January 1, 1601) is zero
 */
	if ( a_ProcessBlock->CreateTime.u.HighPart > 0 )
	{
		pInstance->SetDateTime ( IDS_CreationDate, WBEMTime ( * ( FILETIME * ) ( & a_ProcessBlock->CreateTime.u ) ) ) ;
	}

	pInstance->SetWBEMINT64 ( IDS_KernelModeTime , (const unsigned __int64) a_ProcessBlock->KernelTime.QuadPart ) ;

	pInstance->SetWBEMINT64 ( IDS_UserModeTime , (const unsigned __int64) a_ProcessBlock->UserTime.QuadPart ) ;

    pInstance->SetWBEMINT64 ( L"PrivatePageCount" , (const unsigned __int64) a_ProcessBlock->PrivatePageCount ) ;

    pInstance->SetWBEMINT64 ( L"PeakVirtualSize" , (const unsigned __int64) a_ProcessBlock->PeakVirtualSize ) ;

    pInstance->SetWBEMINT64 ( L"VirtualSize" , (const unsigned __int64) a_ProcessBlock->VirtualSize ) ;

    pInstance->SetDWORD ( L"ThreadCount" , a_ProcessBlock->NumberOfThreads ) ;

    pInstance->SetDWORD ( L"ParentProcessId" , HandleToUlong ( a_ProcessBlock->InheritedFromUniqueProcessId ) ) ;

    pInstance->SetDWORD ( L"HandleCount" , a_ProcessBlock->HandleCount ) ;

#if NTONLY == 5
    pInstance->SetDWORD ( L"SessionId" , a_ProcessBlock->SessionId ) ;

	pInstance->SetWBEMINT64 ( L"ReadOperationCount" , (const unsigned __int64) a_ProcessBlock->ReadOperationCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"WriteOperationCount" , (const unsigned __int64) a_ProcessBlock->WriteOperationCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"OtherOperationCount" , (const unsigned __int64) a_ProcessBlock->OtherOperationCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"ReadTransferCount" , (const unsigned __int64) a_ProcessBlock->ReadTransferCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"WriteTransferCount" , (const unsigned __int64) a_ProcessBlock->WriteTransferCount.QuadPart ) ;

	pInstance->SetWBEMINT64 ( L"OtherTransferCount" , (const unsigned __int64) a_ProcessBlock->OtherTransferCount.QuadPart ) ;

#endif


	SmartCloseHandle hProcessHandle = OpenProcess (

		PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
		FALSE,
        HandleToUlong ( a_ProcessBlock->UniqueProcessId )
	) ;

	if(hProcessHandle != INVALID_HANDLE_VALUE &&
        hProcessHandle != 0L &&
        ::GetLastError() == ERROR_SUCCESS)
    {
	    CHString t_ExecutableName ;
	    BOOL t_Status = GetProcessExecutable ( a_NtApi , hProcessHandle , t_ExecutableName ) ;
	    if ( t_Status )
	    {
		    pInstance->SetWCHARSplat ( IDS_ExecutablePath, t_ExecutableName );
	    }

	    QUOTA_LIMITS QuotaLimits;

	    NTSTATUS Status = a_NtApi.NtQueryInformationProcess (

            hProcessHandle,
            ProcessQuotaLimits,
            &QuotaLimits,
            sizeof(QuotaLimits),
            NULL
        );

	    if ( NT_SUCCESS ( Status ) )
	    {
		    pInstance->SetDWORD ( IDS_MinimumWorkingSetSize, QuotaLimits.MinimumWorkingSetSize ) ;
		    pInstance->SetDWORD ( IDS_MaximumWorkingSetSize, QuotaLimits.MaximumWorkingSetSize ) ;
	    }

	    CHString t_CommandParameters ;

	    t_Status = GetProcessParameters (

		    a_NtApi ,
		    hProcessHandle ,
		    t_CommandParameters
	    ) ;

	    if ( t_Status )
	    {
		    pInstance->SetCharSplat ( _T("CommandLine") , t_CommandParameters ) ;
	    }
    }

    return TRUE ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Process::RefreshProcessCacheWin95
 *
 *  DESCRIPTION : Refreshes cache of key properties
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE if unable to refresh
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL Process::RefreshProcessCacheWin95 (

	CKernel32Api &ToolHelp,
	PROCESS_CACHE& PCache
)
{
    // Get process snapshot
    //=====================

	DWORD dwProcessCount = 0 ;

    SmartCloseHandle hSnapshot;

    if ( ToolHelp.CreateToolhelp32Snapshot ( TH32CS_SNAPPROCESS , 0, &hSnapshot ) )
	{
		// Create PID list
		//================

		//Go enumerating until we are sure we've got all the processes

		do
		{
			PROCESSENTRY32 ProcessEntry = {0} ;
			ProcessEntry.dwSize = sizeof(ProcessEntry) ;
			BOOL bRetCode = false;
            ToolHelp.Process32First(hSnapshot, &ProcessEntry, &bRetCode) ;

			while( bRetCode && dwProcessCount < PCache.dwProcessCount )
			{
				PCache.pdwPIDList[dwProcessCount] = ProcessEntry.th32ProcessID ;
				PCache.pdwBaseModuleList[dwProcessCount] = ProcessEntry.th32ModuleID ;

				dwProcessCount++ ;

				ToolHelp.Process32Next(hSnapshot, &ProcessEntry, &bRetCode) ;
			}

			if(bRetCode)
			{
				DWORD dwAllocSize = ( PCache.dwProcessCount/MAX_PROCESSES + 1 )* MAX_PROCESSES ;
				PCache.Clear() ;
				PCache.AllocateMemories(dwAllocSize) ;
			}
			else
			{
				//we've got all the processes,so break free
				break ;
			}

		} while(1) ;


		//if here ...we've enumerated all the processes

		PCache.dwProcessCount = dwProcessCount ;
	}
	else
	{
        PCache.bInvalid = TRUE ;
        return FALSE ;
    }

    for ( DWORD i = 0 ; i < dwProcessCount ; i++ )
	{
        // Set key values
        //===============

        _tcscpy(PCache.pszNameList[i], _T("Unknown") ) ;

        // Search for base module to get process name
        //===========================================

        SmartCloseHandle hModule;

        if(ToolHelp.CreateToolhelp32Snapshot ( TH32CS_SNAPMODULE , PCache.pdwPIDList [ i ], &hModule ))
		{

			// Walk the snapshot & look for module belonging to process
			//=========================================================

			MODULEENTRY32 ModuleEntry = {0} ;
			ModuleEntry.dwSize = sizeof(ModuleEntry) ;

			BOOL bRetCode = false;
            ToolHelp.Module32First ( hModule , &ModuleEntry, &bRetCode ) ;
			while(bRetCode)
			{
				if(ModuleEntry.th32ModuleID == PCache.pdwBaseModuleList[i])
				{
					// Module found -- collect name
					//=============================

					_tcscpy(PCache.pszNameList[i], ModuleEntry.szModule) ;
					break ;
				}

				ToolHelp.Module32Next(hModule, &ModuleEntry, &bRetCode ) ;
			}
        }
	}

    PCache.bInvalid = FALSE ;

    return TRUE ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Process::LoadCheapPropertiesWin95
 *
 *  DESCRIPTION : Retrieves 'easy-to-get' properties
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE if unable
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL Process :: LoadCheapPropertiesWin95 (

	CKernel32Api &ToolHelp ,
	DWORD dwProcIndex ,
	PROCESS_CACHE &PCache,
	CInstance *pInstance,
	const std::deque<DWORD> & a_ThreadQ
)
{
	SetCreationClassName ( pInstance ) ;

	pInstance->SetDWORD ( IDS_ProcessID , PCache.pdwPIDList [ dwProcIndex ] ) ;

	TCHAR szHandle [ _MAX_PATH ] ;
	_stprintf ( szHandle , _T("%lu") , PCache.pdwPIDList [ dwProcIndex ] ) ;
	pInstance->SetCharSplat ( IDS_Handle , szHandle ) ;

	pInstance->SetCharSplat ( IDS_Name , PCache.pszNameList [ dwProcIndex ] ) ;

	pInstance->SetCharSplat ( IDS_Caption , PCache.pszNameList [ dwProcIndex ] ) ;

	pInstance->SetCharSplat ( IDS_Description , PCache.pszNameList [ dwProcIndex ] ) ;

	pInstance->SetWCHARSplat ( IDS_CSCreationClassName , L"Win32_ComputerSystem" ) ;

	pInstance->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

	pInstance->SetWCHARSplat ( IDS_OSCreationClassName , L"Win32_OperatingSystem" ) ;

    // Refresh properties for running OS (redundant until we're discovering others)
    //=============================================================================

    OSVERSIONINFO OSVersionInfo ;
	CHString chsOs ;

    OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO) ;
    if ( ! GetVersionEx ( & OSVersionInfo ) )
	{
        return FALSE;
    }

    CSystemName sys;
	CHString strOSKey		= sys.GetLongKeyName();

	pInstance->SetCHString ( IDS_OSName , strOSKey ) ;


	wchar_t wszTemp[_MAX_PATH] ;
    swprintf (	wszTemp,
				L"%d.%d.%hu",
				OSVersionInfo.dwMajorVersion,
				OSVersionInfo.dwMinorVersion,
				LOWORD ( OSVersionInfo.dwBuildNumber )
			) ;

	pInstance->SetCHString ( IDS_WindowsVersion , wszTemp ) ;

    SmartCloseHandle hProcess = OpenProcess (

		PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
		FALSE,
        PCache.
		pdwPIDList[dwProcIndex]
	) ;

    if ( hProcess != INVALID_HANDLE_VALUE )
	{
		pInstance->SetDWORD ( IDS_Priority , GetPriorityClass ( hProcess ) ) ;
	}

    SmartCloseHandle hModule;

    if ( ToolHelp.CreateToolhelp32Snapshot (

		TH32CS_SNAPMODULE,
		PCache.pdwPIDList[dwProcIndex],
        &hModule
	) )
	{
		
		// Walk the snapshot & look for module belonging to process
		//=========================================================

		MODULEENTRY32 ModuleEntry = {0} ;
		ModuleEntry.dwSize = sizeof(ModuleEntry) ;

		BOOL bRetCode = false;
        ToolHelp.Module32First ( hModule , & ModuleEntry, &bRetCode ) ;

		while ( bRetCode )
		{
			if ( ModuleEntry.th32ModuleID == PCache.pdwBaseModuleList [ dwProcIndex ] )
			{
				// Module found -- collect properties
				//===================================

				pInstance->SetCharSplat ( IDS_ExecutablePath , ModuleEntry.szExePath ) ;

				break ;
			}

			ToolHelp.Module32Next ( hModule , & ModuleEntry, &bRetCode  ) ;
		}
    }

	DWORD t_dwThreadCount = 0 ;
	for (
			std::deque<DWORD>::const_iterator pdeque = a_ThreadQ.begin();
			pdeque != a_ThreadQ.end();
			pdeque++
		)
		{
			if ( *pdeque == PCache.pdwPIDList[dwProcIndex] )
			{
				t_dwThreadCount++ ;
			}

		}

		if ( t_dwThreadCount )
		{
			pInstance->SetDWORD ( IDS_ThreadCount , t_dwThreadCount ) ;
		}

    return TRUE ;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : Process::filetimeToUint64CHString
 *
 *
 *  DESCRIPTION : Modifies a FILTTIME structure to a unit64 string representation
 * of the number in milliseconds
 *
 *  INPUTS      : A FILETIME object
 *
 *  RETURNS     : A CHString representing the object, or NULL if it fails.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CHString Process :: filetimeToUint64CHString (

	FILETIME inputTime
)
{
	__int64 val = inputTime.dwHighDateTime;
	val = (val << 32) | inputTime.dwLowDateTime;

	// We need to go from "100-nano seconds" to milliseconds
	val *= 0.0001;
	TCHAR wTemp[100];
	_stprintf(wTemp, _T("%I64i"), val);

	return CHString(wTemp);
}

/*****************************************************************************
 *
 *  FUNCTION    : Process ::DeleteInstance
 *
 *  DESCRIPTION : Deletes an instance of a class
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process :: DeleteInstance (

	const CInstance &a_Instance,
	long a_Flags /*= 0L*/
)
{
	HRESULT t_Result = S_OK ;

	CHString t_Handle ;
	if ( a_Instance.GetCHString ( PROPERTY_NAME_PROCESSHANDLE , t_Handle ) && ! t_Handle.IsEmpty () )
	{
		DWORD t_ProcessId = 0;

		if ( swscanf ( t_Handle , L"%lu" , &t_ProcessId ))
		{
			TCHAR buff[20];
			_ultot(t_ProcessId, buff, 10);

			if (t_Handle == buff)
			{
				if ( t_ProcessId != 0 )
				{
					// Clear error
					SetLastError ( 0 ) ;

					SmartCloseHandle t_Handle = OpenProcess ( PROCESS_TERMINATE , FALSE , t_ProcessId ) ;
					if ( t_Handle )
					{
						BOOL t_Status = TerminateProcess ( t_Handle, 0 ) ;
						if ( ! t_Status )
						{
							t_Result = GetProcessResultCode () ;
							if ( t_Result == WBEM_E_INVALID_PARAMETER )
							{
								t_Result = WBEM_E_NOT_FOUND ;
							}
						}
					}
					else
					{
						t_Result = GetProcessResultCode () ;
						if ( t_Result == WBEM_E_INVALID_PARAMETER )
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}
					}
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_OBJECT_PATH ;
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : Process::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Process::ExecMethod (

	const CInstance& a_Instance,
	const BSTR a_MethodName ,
	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	long a_Flags
)
{
	if ( ! a_OutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

   // Do we recognize the method?

	if ( _wcsicmp ( a_MethodName , METHOD_NAME_CREATE ) == 0 )
	{
		return ExecCreate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_TERMINATE ) == 0 )
	{
		return ExecTerminate ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_GETOWNER ) == 0 )
	{
		return ExecGetOwner ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
	else if ( _wcsicmp ( a_MethodName , METHOD_NAME_GETOWNERSID ) == 0 )
	{
		return ExecGetOwnerSid ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
    else if ( _wcsicmp ( a_MethodName , METHOD_NAME_SETPRIORITY ) == 0 )
	{
		return ExecSetPriority ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}
    else if ( _wcsicmp ( a_MethodName , METHOD_NAME_ATTACHDEBUGGER ) == 0 )
	{
		return ExecAttachDebugger ( a_Instance , a_InParams , a_OutParams , a_Flags ) ;
	}


	return WBEM_E_INVALID_METHOD;
}

DWORD Process :: GetProcessErrorCode ()
{
	DWORD t_Status ;
	DWORD t_Error = GetLastError() ;

	switch ( t_Error )
	{
		case ERROR_INVALID_HANDLE:
		{
			t_Status = Process_STATUS_UNKNOWN_FAILURE ;
		}
		break ;

		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
		{
			t_Status = Process_STATUS_PATH_NOT_FOUND ;
		}
		break ;

		case ERROR_ACCESS_DENIED:
		{
			t_Status = Process_STATUS_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Status = Process_STATUS_INVALID_PARAMETER ;
		}
		break;

		case ERROR_PRIVILEGE_NOT_HELD:
		{
			t_Status = Process_STATUS_INSUFFICIENT_PRIVILEGE ;
		}
		break ;

		default:
		{
			t_Status = Process_STATUS_UNKNOWN_FAILURE ;
		}
		break ;
	}

	return t_Status ;
}

HRESULT Process :: GetProcessResultCode ()
{
	HRESULT t_Result ;
	DWORD t_Error = GetLastError() ;
	switch ( t_Error )
	{
		case ERROR_ACCESS_DENIED:
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
		break ;

		case ERROR_INVALID_PARAMETER:
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
		break ;

		default:
		{
			t_Result = WBEM_E_FAILED ;
		}
		break ;
	}

	return t_Result ;
}

DWORD Process :: GetSid ( HANDLE a_TokenHandle , CHString &a_Sid )
{
	DWORD t_Status = S_OK ;

	TOKEN_USER *t_TokenUser = NULL ;
	DWORD t_ReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		t_TokenInformationClass ,
		NULL ,
		0 ,
		& t_ReturnLength
	) ;

	if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ;
		if ( t_TokenUser )
		{
			try
			{
				t_TokenStatus = GetTokenInformation (

					a_TokenHandle ,
					t_TokenInformationClass ,
					( void * ) t_TokenUser ,
					t_ReturnLength ,
					& t_ReturnLength
				) ;

				if ( t_TokenStatus )
				{
					CSid t_Sid ( t_TokenUser->User.Sid ) ;
					if ( t_Sid.IsOK () )
					{
						a_Sid = t_Sid.GetSidString () ;
					}
					else
					{
						t_Status = GetProcessErrorCode () ;
					}
				}
				else
				{
					t_Status = GetProcessErrorCode () ;
				}
			}
			catch ( ... )
			{
				delete [] ( UCHAR * ) t_TokenUser ;

				throw ;
			}

			delete [] ( UCHAR * ) t_TokenUser ;

		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

DWORD Process :: GetLogonSid ( HANDLE a_TokenHandle , PSID &a_Sid )
{
	DWORD t_Status = S_OK ;

	TOKEN_GROUPS *t_TokenGroups = NULL ;
	DWORD t_ReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenGroups ;

	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		t_TokenInformationClass ,
		NULL ,
		0 ,
		& t_ReturnLength
	) ;

	if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_TokenGroups = ( TOKEN_GROUPS * ) new UCHAR [ t_ReturnLength ] ;
		if ( t_TokenGroups )
		{
			try
			{
				t_TokenStatus = GetTokenInformation (

					a_TokenHandle ,
					t_TokenInformationClass ,
					( void * ) t_TokenGroups ,
					t_ReturnLength ,
					& t_ReturnLength
				) ;

				if ( t_TokenStatus )
				{
					t_Status = Process_STATUS_UNKNOWN_FAILURE ;

					for ( ULONG t_Index = 0; t_Index < t_TokenGroups->GroupCount; t_Index ++ )
					{
						DWORD t_Attributes = t_TokenGroups->Groups [ t_Index ].Attributes ;
						if ( ( t_Attributes & SE_GROUP_LOGON_ID ) ==  SE_GROUP_LOGON_ID )
						{
							DWORD t_Length = GetLengthSid ( t_TokenGroups->Groups [ t_Index ].Sid ) ;

							a_Sid = ( PSID ) new UCHAR [ t_Length ] ;
							if ( a_Sid )
							{
								CopySid ( t_Length , a_Sid , t_TokenGroups->Groups [ t_Index ].Sid ) ;
							}
							else
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}

							break ;
						}
					}
				}
				else
				{
					t_Status = GetProcessErrorCode () ;
				}
			}
			catch ( ... )
			{
				delete [] ( UCHAR * ) t_TokenGroups ;

				throw ;
			}

			delete [] ( UCHAR * ) t_TokenGroups ;

		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

	}


	return t_Status ;
}

DWORD Process :: GetAccount ( HANDLE a_TokenHandle , CHString &a_Domain , CHString &a_User )
{
	DWORD t_Status = S_OK ;

	TOKEN_USER *t_TokenUser = NULL ;
	DWORD t_ReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS t_TokenInformationClass = TokenUser ;

	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		t_TokenInformationClass ,
		NULL ,
		0 ,
		& t_ReturnLength
	) ;

	if ( ! t_TokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
	{
		t_TokenUser = ( TOKEN_USER * ) new UCHAR [ t_ReturnLength ] ;

        if (t_TokenUser)
        {
            try
            {
		        t_TokenStatus = GetTokenInformation (

			        a_TokenHandle ,
			        t_TokenInformationClass ,
			        ( void * ) t_TokenUser ,
			        t_ReturnLength ,
			        & t_ReturnLength
		        ) ;

		        if ( t_TokenStatus )
		        {
			        CSid t_Sid ( t_TokenUser->User.Sid ) ;
			        if ( t_Sid.IsOK () )
			        {
				        a_Domain = t_Sid.GetDomainName () ;
				        a_User = t_Sid.GetAccountName () ;
			        }
			        else
			        {
				        t_Status = GetProcessErrorCode () ;
			        }
		        }
		        else
		        {
			        t_Status = GetProcessErrorCode () ;
		        }
            }
            catch ( ... )
            {
    			delete [] ( UCHAR * ) t_TokenUser ;
                throw;
            }

			delete [] ( UCHAR * ) t_TokenUser ;
        }
        else
        {
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

DWORD Process :: GetImpersonationStatus (

	HANDLE a_TokenHandle ,
	SECURITY_IMPERSONATION_LEVEL &a_Level ,
	TOKEN_TYPE &a_Token
)
{
	DWORD t_Status = S_OK ;
	DWORD t_ReturnLength = 0 ;
	BOOL t_TokenStatus = GetTokenInformation (

		a_TokenHandle ,
		TokenType ,
		( void * ) & a_Token ,
		sizeof ( a_Token ) ,
		& t_ReturnLength
	) ;

	if ( t_TokenStatus )
	{
		if ( a_Token == TokenImpersonation )
		{
			BOOL t_TokenStatus = GetTokenInformation (

				a_TokenHandle ,
				TokenImpersonationLevel ,
				( void * ) & a_Level ,
				sizeof ( a_Level ) ,
				& t_ReturnLength
			) ;

			if ( t_TokenStatus )
			{
			}
			else
			{
				t_Status = GetProcessErrorCode () ;
			}
		}
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

DWORD Process :: EnableDebug ( HANDLE &a_Token )
{
    BOOL t_Status = OpenThreadToken (

		GetCurrentThread(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		FALSE,
        &a_Token
	) ;

	if ( ! t_Status )
	{
		t_Status = OpenProcessToken (

			GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &a_Token
		) ;

		if ( ! t_Status )
		{
			DWORD t_ErrorCode = GetProcessErrorCode () ;
			if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
			{
				t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
			}

			return t_ErrorCode ;
		}
    }

    //
    // Enable the SE_DEBUG_NAME privilege
    //

	if ( ! t_Status )
	{
		return GetProcessErrorCode () ;
    }

	try
	{
		LUID t_Luid ;
		{
			CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			t_Status = LookupPrivilegeValue (

				(LPTSTR) NULL,
				SE_DEBUG_NAME,
				&t_Luid
			) ;
		}

		if ( ! t_Status )
		{
			CloseHandle ( a_Token ) ;

			return GetProcessErrorCode () ;
		}

		TOKEN_PRIVILEGES t_Privilege ;

		t_Privilege.PrivilegeCount = 1;
		t_Privilege.Privileges[0].Luid = t_Luid ;
		t_Privilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		AdjustTokenPrivileges (

			a_Token ,
			FALSE ,
			& t_Privilege ,
			sizeof ( TOKEN_PRIVILEGES ) ,
			( PTOKEN_PRIVILEGES ) NULL ,
			( PDWORD) NULL
		) ;
	}
	catch ( ... )
	{
		CloseHandle ( a_Token ) ;

		throw ;
	}

    //
    // The return value of AdjustTokenPrivileges can't be tested
    //

    if ( GetLastError () != ERROR_SUCCESS )
	{
		return GetProcessErrorCode () ;
    }

	return Process_STATUS_SUCCESS ;
}

DWORD Process :: GetSidOrAccount (const CInstance &a_Instance ,CInstance *a_OutParams , DWORD a_ProcessId , BOOL a_Sid )
{
	DWORD t_Status = Process_STATUS_SUCCESS ;

	    // Require the SE_DEBUG_NAME privilege...
    CTokenPrivilege	debugPrivilege(SE_DEBUG_NAME);
	BOOL fDisablePrivilege = FALSE;
	BOOL fTryWinstation = FALSE;

	fDisablePrivilege = (debugPrivilege.Enable() == ERROR_SUCCESS);

	SetLastError ( 0 ) ;
	SmartCloseHandle t_Handle = OpenProcess ( PROCESS_QUERY_INFORMATION , FALSE , ( ( a_ProcessId ) ? a_ProcessId : 4 ) ) ;

	if ( t_Handle )
	{

		SmartCloseHandle t_TokenHandle;
		BOOL t_TokenStatus = OpenProcessToken (

			t_Handle ,
			TOKEN_QUERY ,
			& t_TokenHandle
		) ;

		if ( t_TokenStatus )
		{
			if ( a_Sid )
			{
				CHString t_SidString ;
				t_Status = GetSid ( t_TokenHandle , t_SidString ) ;
				if ( t_Status == 0 )
				{
					a_OutParams->SetCHString( METHOD_ARG_NAME_SID , t_SidString ) ;
				}
			}
			else
			{
				CHString t_DomainString ;
				CHString t_UserString ;

				t_Status = GetAccount ( t_TokenHandle , t_DomainString , t_UserString );
				if ( t_Status == 0 )
				{
					a_OutParams->SetCHString( METHOD_ARG_NAME_DOMAIN , t_DomainString ) ;
					a_OutParams->SetCHString( METHOD_ARG_NAME_USER , t_UserString ) ;
				}

			}
		}
		else
		{
			fTryWinstation = TRUE;
			DWORD t_ErrorCode = GetProcessErrorCode () ;
			if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
			{
				t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
			}

			t_Status = t_ErrorCode ;
		}
	}
	else
	{
		fTryWinstation = TRUE;
		DWORD t_ErrorCode = GetProcessErrorCode () ;
		if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
		{
			t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
		}

		t_Status = t_ErrorCode ;
	}

#if NTONLY >= 5
	if (fTryWinstation)
	{
        HMODULE hWinstaDLL = LoadLibrary( L"winsta.dll" );
		pfnWinStationGetProcessSid myWinStationGetProcessSid = NULL;

        if( hWinstaDLL != NULL)
        {
            myWinStationGetProcessSid = ( pfnWinStationGetProcessSid )GetProcAddress(hWinstaDLL, "WinStationGetProcessSid");
		}

		SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

		CNtDllApi *pNtdll = ( CNtDllApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidNtDllApi, NULL ) ;
		HRESULT hRetCode = 0;


		if ( pNtdll && myWinStationGetProcessSid )
		{
			try
			{
				t_ProcessBlock = RefreshProcessCacheNT ( *pNtdll , a_Instance.GetMethodContext () , & hRetCode ) ;

				if ( SUCCEEDED ( hRetCode ) )
				{
					SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = GetProcessBlock ( *pNtdll , t_ProcessBlock , a_ProcessId ) ;

					if ( t_CurrentInformation )
					{
						BYTE tmpSid [128];
						DWORD dwSidSize = sizeof(tmpSid);
						CSmartBuffer pBuff;
						PSID pSid = NULL;

						if (!myWinStationGetProcessSid(NULL,
													 a_ProcessId,
													 * ( FILETIME * ) ( & t_CurrentInformation->CreateTime.u ),
													 (PBYTE)&tmpSid,
													 &dwSidSize
													))
						{
							//-------------------------------------------//
							// Sid is too big for the temp storage       //
							//Get the size of the sid and do it again    //
							//-------------------------------------------//
							if (GetLastError() == STATUS_BUFFER_TOO_SMALL)
							{
								pBuff = new BYTE[dwSidSize];

								//-------------------------------------------//
								// Call the server again to get the SID
								//-------------------------------------------//
								if (myWinStationGetProcessSid(NULL,
															 a_ProcessId,
															 * ( FILETIME * ) ( & t_CurrentInformation->CreateTime.u ),
															 (PBYTE)pBuff,
															 &dwSidSize
															))
								{
									pSid = (PSID) ((PBYTE)pBuff);
								}
							}
						}
						else
						{
							pSid = (PSID) tmpSid;
						}

						if (pSid)
						{
							CSid t_Sid ( pSid ) ;

							if ( t_Sid.IsOK () )
							{
								if ( a_Sid )
								{
									a_OutParams->SetCHString( METHOD_ARG_NAME_SID , t_Sid.GetSidString () );
								}
								else
								{
									a_OutParams->SetCHString( METHOD_ARG_NAME_DOMAIN , t_Sid.GetDomainName () ) ;
									a_OutParams->SetCHString( METHOD_ARG_NAME_USER , t_Sid.GetAccountName () ) ;
								}

								t_Status = 0;
							}
						}
					}
				}
			}
			catch ( ... )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

				if ( t_ProcessBlock )
				{
					delete []  t_ProcessBlock;
				}

				if (hWinstaDLL)
				{
					FreeLibrary(hWinstaDLL);
				}

				throw ;
			}
		}

		if ( t_ProcessBlock )
		{
			delete []  t_ProcessBlock;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidNtDllApi, pNtdll ) ;

		if (hWinstaDLL)
		{
			FreeLibrary(hWinstaDLL);
		}
	}
#endif

    // Disable debug privilege if we enabeled it...
    if(fDisablePrivilege)
    {
        debugPrivilege.Enable(FALSE);
    }

	return t_Status ;
}

DWORD Process :: Creation (

	CInstance *a_OutParams ,
	HANDLE a_TokenHandle ,
	CHString a_CmdLine ,
	BOOL a_WorkingDirectorySpecified ,
	CHString a_WorkingDirectory ,
	TCHAR *a_EnvironmentBlock ,
	BOOL a_ErrorModeSpecified ,
	DWORD a_ErrorMode ,
	DWORD a_CreationFlags ,
	BOOL a_StartupSpecified ,
	STARTUPINFO a_StartupInformation
)
{
	DWORD t_Status = Process_STATUS_SUCCESS ;

	bstr_t t_CommandLine(a_CmdLine);

	PROCESS_INFORMATION t_ProcessInformation;

#if 0
	UINT t_ErrorMode = SetErrorMode ( a_ErrorMode ) ;
#endif

	const WCHAR *t_Const = a_WorkingDirectory ;

#ifdef NTONLY
	{

		t_Status = CreateProcessAsUser (

			a_TokenHandle ,
			NULL ,
			( LPTSTR ) t_CommandLine,
			NULL ,
			NULL ,
			FALSE ,
			a_CreationFlags ,
			a_EnvironmentBlock ,
			a_WorkingDirectorySpecified ? t_Const : NULL  ,
			& a_StartupInformation ,
			&t_ProcessInformation
		) ;
	}
#endif
#ifdef WIN9XONLY
	{
		t_Status = CreateProcess (

			NULL ,
			( LPTSTR ) t_CommandLine,
			NULL ,
			NULL ,
			FALSE ,
			a_CreationFlags ,
			a_EnvironmentBlock ,
			a_WorkingDirectorySpecified ? (LPTSTR) TOBSTRT(t_Const) : NULL  ,
			& a_StartupInformation ,
			&t_ProcessInformation
		) ;
	}
#endif


#if 0
	SetErrorMode ( t_ErrorMode ) ;
#endif

	if ( t_Status )
	{
		CloseHandle ( t_ProcessInformation.hProcess ) ;
		CloseHandle ( t_ProcessInformation.hThread ) ;

		t_Status = Process_STATUS_SUCCESS ;

		a_OutParams->SetDWORD ( METHOD_ARG_NAME_PROCESSID , t_ProcessInformation.dwProcessId ) ;
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
}

typedef BOOL  (WINAPI *PFN_DUPLICATETOKENEX ) (  HANDLE ,					// handle to token to duplicate
										DWORD ,								// access rights of new token
										LPSECURITY_ATTRIBUTES ,				// security attributes of the new token
										SECURITY_IMPERSONATION_LEVEL ,		// impersonation level of new token
										TOKEN_TYPE ,						// primary or impersonation token
										PHANDLE )	;						// handle to duplicated token


DWORD Process :: ProcessCreation (

	CInstance *a_OutParams ,
	CHString a_CmdLine ,
	BOOL a_WorkingDirectorySpecified ,
	CHString a_WorkingDirectory ,
	TCHAR *&a_EnvironmentBlock ,
	BOOL a_ErrorModeSpecified ,
	DWORD a_ErrorMode ,
	DWORD a_CreationFlags ,
	BOOL a_StartupSpecified ,
	STARTUPINFO a_StartupInformation
)
{
#ifdef WIN9XONLY
	{
		return Creation (

			a_OutParams ,
			NULL,
			a_CmdLine ,
			a_WorkingDirectorySpecified ,
			a_WorkingDirectory ,
			a_EnvironmentBlock ,
			a_ErrorModeSpecified ,
			a_ErrorMode ,
			a_CreationFlags ,
			a_StartupSpecified ,
			a_StartupInformation
		) ;
	}
#endif

#ifdef NTONLY
	DWORD t_Status = Process_STATUS_SUCCESS ;
	DWORD dwCheckKeyPresentStatus ;

	SmartCloseHandle t_TokenPrimaryHandle ;
	SmartCloseHandle t_TokenImpersonationHandle;

	BOOL t_TokenStatus = OpenThreadToken (

		GetCurrentThread () ,
		TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY  ,
		TRUE ,
		& t_TokenImpersonationHandle
	) ;

	if ( t_TokenStatus )
	{
		CAdvApi32Api *t_pAdvApi32 = NULL;
        t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
		if(t_pAdvApi32 == NULL)
		{
			return Process_STATUS_UNKNOWN_FAILURE ;
		}
        else
        {
		    t_pAdvApi32->DuplicateTokenEx (t_TokenImpersonationHandle ,
			                                               TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY ,
			                                               NULL,
			                                               SecurityImpersonation,
			                                               TokenPrimary ,
			                                               &t_TokenPrimaryHandle, &t_TokenStatus );

		    CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
            t_pAdvApi32 = NULL;
        }
	}

	if ( t_TokenStatus )
	{
		CHString t_Domain ;
		CHString t_User ;

		t_Status = GetAccount ( t_TokenImpersonationHandle , t_Domain , t_User ) ;
		if ( t_Status == 0 )
		{
			CHString t_Account = t_Domain + CHString ( _T("\\") ) + t_User ;

			CHString chsSID ;
			CUserHive t_Hive ;
			TCHAR t_KeyName [ 1024 ] ;

			if( (t_Status = GetSid(t_TokenImpersonationHandle,chsSID) ) == Process_STATUS_SUCCESS )
			{

				CRegistry Reg ;
				//check if SID already present under HKEY_USER ...
				dwCheckKeyPresentStatus = Reg.Open(HKEY_USERS, chsSID, KEY_READ) ;
				Reg.Close() ;

				if(dwCheckKeyPresentStatus != ERROR_SUCCESS)
				{
					t_Status = t_Hive.Load ( t_Account , t_KeyName ) ;
				}
/*
 * If the DCOM client has never logged on to the machine, we can't load his hive.
 * In this case, we allow the process creation to continue
 * From MSDN: If the user's hive is not loaded, the system will map references pertaining to HKEY_CURRENT_USER to HKEY_USER\.default.
 */
				if ( t_Status == ERROR_FILE_NOT_FOUND )
				{
					t_Status = ERROR_SUCCESS ;
					dwCheckKeyPresentStatus = ERROR_SUCCESS ;
				}

				if ( t_Status == ERROR_SUCCESS ) // rt. now is equal to Process_STATUS_SUCCESS--->GetSid
				{
					try
					{
						LPVOID t_Environment = NULL ;

#ifdef NTONLY
						CUserEnvApi *pUserEnv = NULL ;

						if ( !a_EnvironmentBlock )
						{
							pUserEnv = ( CUserEnvApi * )CResourceManager::sm_TheResourceManager.GetResource ( g_guidUserEnvApi, NULL ) ;

							BOOL t_EnvironmentCreated = pUserEnv->CreateEnvironmentBlock (

								& t_Environment ,
								t_TokenPrimaryHandle ,
								FALSE
							);

							if ( ! t_EnvironmentCreated )
							{
								t_Status = Process_STATUS_UNKNOWN_FAILURE ;
								DWORD t_Error = GetLastError () ;
							}
						}

#else
						if ( !a_EnvironmentBlock )
						{
							t_Status = GetEnvBlock ( chsSID, t_User, t_Domain , a_EnvironmentBlock ) ;
						}
#endif

						if( t_Status == ERROR_SUCCESS )
						{
							t_Status = Creation (

								a_OutParams ,
								t_TokenPrimaryHandle ,
								a_CmdLine ,
								a_WorkingDirectorySpecified ,
								a_WorkingDirectory ,
								a_EnvironmentBlock ? a_EnvironmentBlock : ( TCHAR * ) t_Environment ,
								a_ErrorModeSpecified ,
								a_ErrorMode ,
								a_CreationFlags ,
								a_StartupSpecified ,
								a_StartupInformation
							) ;
						}

#ifdef NTONLY
						if ( t_Environment )
						{
							pUserEnv->DestroyEnvironmentBlock ( t_Environment ) ;
						}

						if ( pUserEnv )
						{
							CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidUserEnvApi, pUserEnv ) ;
						}
#endif

					}
					catch ( ... )
					{
						//remove the key if it wasn't there b4....
						if(dwCheckKeyPresentStatus != ERROR_SUCCESS )
						{
							t_Hive.Unload ( t_KeyName ) ;
						}

						throw;
					}

					//remove the key if it wasn't there b4....
					if(dwCheckKeyPresentStatus != ERROR_SUCCESS )
					{
						t_Hive.Unload ( t_KeyName ) ;
					}

				}
				else
				{
					t_Status = GetProcessErrorCode () ;
				}
			}
		}
	}
	else
	{
		t_Status = GetProcessErrorCode () ;
	}

	return t_Status ;
#endif
}

HRESULT Process :: CheckProcessCreation (

	CInstance *a_InParams ,
	CInstance *a_OutParams ,
	DWORD &a_Status
)
{
	HRESULT t_Result = S_OK ;

	bool t_Exists ;
	VARTYPE t_Type ;

	CHString t_CmdLine ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_COMMANDLINE , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR ) )
		{
			if ( a_InParams->GetCHString ( METHOD_ARG_NAME_COMMANDLINE , t_CmdLine ) && ! t_CmdLine.IsEmpty () )
			{
			}
			else
			{
// Zero Length string

				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
		else
		{
			a_Status = Process_STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = Process_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	bool t_WorkingDirectorySpecified = false ;
	CHString t_WorkingDirectory ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_CURRENTDIRECTORY , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_WorkingDirectorySpecified = false ;
			}
			else
			{
				if ( a_InParams->GetCHString ( METHOD_ARG_NAME_CURRENTDIRECTORY , t_WorkingDirectory ) && ! t_WorkingDirectory.IsEmpty () )
				{
					t_WorkingDirectorySpecified = true ;
				}
				else
				{
// Zero Length string

					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = Process_STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = Process_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	CInstancePtr t_EmbeddedObject;

	bool t_StartupSpecified = true ;
	if ( a_InParams->GetStatus ( METHOD_ARG_NAME_PROCESSTARTUPINFORMATION , t_Exists , t_Type ) )
	{
		if ( t_Exists && ( t_Type == VT_UNKNOWN || t_Type == VT_NULL ) )
		{
			if ( t_Type == VT_NULL )
			{
				t_StartupSpecified = false ;
			}
			else
			{
				if ( a_InParams->GetEmbeddedObject ( METHOD_ARG_NAME_PROCESSTARTUPINFORMATION , &t_EmbeddedObject , a_InParams->GetMethodContext () ) )
				{
					t_StartupSpecified = true ;
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
		}
		else
		{
			a_Status = Process_STATUS_INVALID_PARAMETER ;
			return t_Result ;
		}
	}
	else
	{
		a_Status = Process_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

/*
 * Release CInstance when Stack goes out of scope.
 */

	if ( t_StartupSpecified )
	{
		CHString t_ClassProperty ( IDS___Class ) ;
		if ( t_EmbeddedObject->GetStatus ( t_ClassProperty , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_BSTR ) )
			{
				CHString t_Class ;
				if ( t_EmbeddedObject->GetCHString ( t_ClassProperty , t_Class ) )
				{
					if ( t_Class.CompareNoCase ( PROPSET_NAME_PROCESSSTARTUP ) != 0 )
					{
						a_Status = Process_STATUS_INVALID_PARAMETER ;
						return t_Result ;
					}
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}
		}
	}

	bool t_ErrorModeSpecified = false ;
	DWORD t_ErrorMode = 0 ;
	DWORD t_CreationFlags = 0 ;
	DWORD t_PriorityFlags = 0 ;
	TCHAR *t_EnvironmentBlock = NULL ;
	STARTUPINFO t_StartupInformation ;
/*
 *	NOTE:	(RAID #48587). On optimized builds it's seen that the statement
			t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USESHOWWINDOW ;
			doesn't update t_StartupInformation.dwFlags with the result of the bitwise OR opeartion.
			ZeroMemorying the structure however, updates the t_StartupInformation.dwFlags with the new value(!!!)
*/

	ZeroMemory ( &t_StartupInformation , sizeof ( t_StartupInformation ) ) ;

	t_StartupInformation.cb = sizeof ( STARTUPINFO ) ;
	t_StartupInformation.lpReserved = NULL ;
	t_StartupInformation.lpReserved2 = NULL ;
	t_StartupInformation.cbReserved2 = 0 ;

	CHString t_Title ;
	CHString t_Desktop ;

	t_StartupInformation.lpTitle = NULL ;
	t_StartupInformation.lpDesktop = PROPERTY_VALUE_DESKTOP_WIN0DEFAULT ;
	t_StartupInformation.dwX = 0 ;
	t_StartupInformation.dwY = 0 ;
	t_StartupInformation.dwXSize = 0 ;
	t_StartupInformation.dwYSize = 0 ;
	t_StartupInformation.dwXCountChars = 0 ;
	t_StartupInformation.dwYCountChars = 0 ;
	t_StartupInformation.dwFillAttribute = 0 ;
	t_StartupInformation.dwFlags = 0 ;
	t_StartupInformation.wShowWindow = SW_SHOW ;
	t_StartupInformation.hStdInput = NULL ;
	t_StartupInformation.hStdOutput = NULL ;
	t_StartupInformation.hStdError = NULL ;

	SAFEARRAY *t_SafeArray = NULL ;

	try
	{
		if ( t_StartupSpecified )
		{
	#if 0

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_ERRORMODE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						t_ErrorModeSpecified = false ;
					}
					else
					{
						DWORD t_Error = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_ERRORMODE , t_Error ) )
						{
							t_ErrorMode = t_Error ;

							t_ErrorModeSpecified = true ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

	#endif

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_CREATIONFLAGS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_CREATIONFLAGS , t_Flags ) )
						{
							if( ( !t_Flags ) || ( ! ( t_Flags & ( CREATIONFLAGS ) ) ) )
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
							t_CreationFlags = t_Flags ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_PRIORITYCLASS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						t_CreationFlags = t_CreationFlags | NORMAL_PRIORITY_CLASS ;
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_PRIORITYCLASS , t_Flags ) )
						{
							switch( t_Flags )
							{
								case NORMAL_PRIORITY_CLASS: { t_CreationFlags |= NORMAL_PRIORITY_CLASS; break; }
								case IDLE_PRIORITY_CLASS: { t_CreationFlags |= IDLE_PRIORITY_CLASS; break; }
								case HIGH_PRIORITY_CLASS: { t_CreationFlags |= HIGH_PRIORITY_CLASS; break; }
								case REALTIME_PRIORITY_CLASS: { t_CreationFlags |= REALTIME_PRIORITY_CLASS; break; }
								case BELOW_NORMAL_PRIORITY_CLASS: { t_CreationFlags |= BELOW_NORMAL_PRIORITY_CLASS; break; }
								case ABOVE_NORMAL_PRIORITY_CLASS: { t_CreationFlags |= ABOVE_NORMAL_PRIORITY_CLASS; break; }
								default:
								{
									a_Status = Process_STATUS_INVALID_PARAMETER ;
									return t_Result ;
								}
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_FILLATTRIBUTE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_FILLATTRIBUTE , t_Flags ) )
						{
							t_StartupInformation.dwFillAttribute = t_Flags ;

							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USEFILLATTRIBUTE ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_X , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_X = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_X , t_X ) )
						{
							t_StartupInformation.dwX = t_X ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USEPOSITION ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_Y , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						if ( t_StartupInformation.dwFlags & STARTF_USEPOSITION )
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					else
					{
						DWORD t_Y = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_Y , t_Y ) )
						{
							if ( t_StartupInformation.dwFlags & STARTF_USEPOSITION )
							{
								t_StartupInformation.dwY = t_Y ;
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_XSIZE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_XSize = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_XSIZE , t_XSize ) )
						{
							t_StartupInformation.dwXSize = t_XSize ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USESIZE ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_YSIZE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						if ( t_StartupInformation.dwFlags & STARTF_USESIZE )
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					else
					{
						DWORD t_Y = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_YSIZE , t_Y ) )
						{
							if ( t_StartupInformation.dwFlags & STARTF_USESIZE )
							{
								t_StartupInformation.dwYSize = t_Y ;
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_XCOUNTCHARS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_XCountChars = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_XCOUNTCHARS , t_XCountChars ) )
						{
							t_StartupInformation.dwXCountChars = t_XCountChars ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USECOUNTCHARS ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_YCOUNTCHARS , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
						if ( t_StartupInformation.dwFlags & STARTF_USECOUNTCHARS )
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
					else
					{
						DWORD t_YCountChars = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_YCOUNTCHARS , t_YCountChars ) )
						{
							if ( t_StartupInformation.dwFlags & STARTF_USECOUNTCHARS )
							{
								t_StartupInformation.dwYCountChars = t_YCountChars ;
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
								return t_Result ;
							}
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_SHOWWINDOW , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						DWORD t_Flags = 0 ;
						if ( t_EmbeddedObject->GetDWORD ( PROPERTY_NAME_SHOWWINDOW , t_Flags ) )
						{
							t_StartupInformation.wShowWindow = t_Flags ;
							t_StartupInformation.dwFlags = t_StartupInformation.dwFlags | STARTF_USESHOWWINDOW ;
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return t_Result ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_TITLE , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( t_Type == VT_BSTR || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						if ( t_EmbeddedObject->GetCHString ( PROPERTY_NAME_TITLE , t_Title ) )
						{
							//const TCHAR *t_Const = (LPCTSTR) t_Title ;
							t_StartupInformation.lpTitle = (LPTSTR) (LPCTSTR) TOBSTRT(t_Title);
						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
							return t_Result ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}

			if ( t_EmbeddedObject->GetStatus ( PROPERTY_NAME_ENVIRONMENTVARIABLES , t_Exists , t_Type ) )
			{
				if ( t_Exists && ( ( t_Type == ( VT_BSTR | VT_ARRAY ) ) || t_Type == VT_NULL ) )
				{
					if ( t_Type == VT_NULL )
					{
					}
					else
					{
						if ( t_EmbeddedObject->GetStringArray ( PROPERTY_NAME_ENVIRONMENTVARIABLES , t_SafeArray ) )
						{
							if ( t_SafeArray )
							{
								if ( SafeArrayGetDim ( t_SafeArray ) == 1 )
								{
									LONG t_Dimension = 1 ;
									LONG t_LowerBound ;
									SafeArrayGetLBound ( t_SafeArray , t_Dimension , & t_LowerBound ) ;
									LONG t_UpperBound ;
									SafeArrayGetUBound ( t_SafeArray , t_Dimension , & t_UpperBound ) ;

									ULONG t_BufferLength = 0 ;

									for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
									{
										BSTR t_Element ;
										HRESULT t_Result = SafeArrayGetElement ( t_SafeArray , &t_Index , & t_Element ) ;
										if ( t_Result == S_OK )
										{
											try
											{
												CHString t_String ( t_Element ) ;
												t_BufferLength += lstrlen ( _bstr_t ( ( LPCWSTR ) t_String ) ) + 1 ;
											}
											catch ( ... )
											{
												SysFreeString ( t_Element ) ;

												throw ;
											}

											SysFreeString ( t_Element ) ;
										}
										else
										{
											throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
										}
									}

									t_BufferLength ++ ;

									t_EnvironmentBlock = new TCHAR [ t_BufferLength ] ;
									if ( t_EnvironmentBlock )
									{
										t_BufferLength = 0 ;

										for ( t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
										{
											BSTR t_Element ;

											HRESULT t_Result = SafeArrayGetElement ( t_SafeArray , &t_Index , & t_Element ) ;
											if ( t_Result == S_OK )
											{
												try
												{
													CHString t_String ( t_Element ) ;

													_tcscpy ( & t_EnvironmentBlock [ t_BufferLength ] , TOBSTRT(t_String));

													t_BufferLength += lstrlen ( _bstr_t ( ( LPCWSTR ) t_String ) ) + 1 ;

												}
												catch ( ... )
												{
													SysFreeString ( t_Element ) ;

													throw ;
												}

												SysFreeString ( t_Element ) ;
											}
											else
											{
												throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
											}
										}

										t_EnvironmentBlock [ t_BufferLength ] = 0 ;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
								else
								{
									a_Status = Process_STATUS_INVALID_PARAMETER ;
								}
							}
							else
							{
								a_Status = Process_STATUS_INVALID_PARAMETER ;
							}

							SafeArrayDestroy ( t_SafeArray ) ;
                            t_SafeArray = NULL;

						}
						else
						{
							a_Status = Process_STATUS_INVALID_PARAMETER ;
						}
					}
				}
				else
				{
					a_Status = Process_STATUS_INVALID_PARAMETER ;
					return t_Result ;
				}
			}
			else
			{
				a_Status = Process_STATUS_INVALID_PARAMETER ;
				return WBEM_E_PROVIDER_FAILURE ;
			}
		}
/*
 * passing unicode environment strings on 9x doesn't work, though the documentation doesn't say anything about this.
 */
#ifdef NTONLY
		t_CreationFlags |= CREATE_UNICODE_ENVIRONMENT ;
#endif
		if ( a_Status == Process_STATUS_SUCCESS )
		{
			a_Status = ProcessCreation (

				a_OutParams ,
				t_CmdLine ,
				t_WorkingDirectorySpecified ,
				t_WorkingDirectory ,
				t_EnvironmentBlock ,
				t_ErrorModeSpecified ,
				t_ErrorMode ,
				t_CreationFlags ,
				t_StartupSpecified ,
				t_StartupInformation
			) ;
		}
	}
	catch ( ... )
	{
		if ( t_EnvironmentBlock )
			delete [] t_EnvironmentBlock ;

        if ( t_SafeArray )
		    SafeArrayDestroy ( t_SafeArray ) ;

		throw  ;
	}

	if ( t_EnvironmentBlock )
		delete [] t_EnvironmentBlock ;

	return t_Result ;
}

HRESULT Process :: ExecCreate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;
	DWORD t_Status = Process_STATUS_SUCCESS ;

	if ( a_InParams && a_OutParams )
	{
		t_Result = CheckProcessCreation (

			a_InParams ,
			a_OutParams ,
			t_Status
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}


HRESULT Process :: ExecTerminate (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

	if ( a_InParams && a_OutParams )
	{
		bool t_Exists ;
		VARTYPE t_Type ;

		DWORD t_Flags = 0 ;
		if ( a_InParams->GetStatus ( METHOD_ARG_NAME_REASON , t_Exists , t_Type ) )
		{
			if ( t_Exists && ( t_Type == VT_I4 || t_Type == VT_NULL ) )
			{
				if ( t_Type == VT_I4 )
				{
					if ( a_InParams->GetDWORD ( METHOD_ARG_NAME_REASON , t_Flags ) )
					{
					}
					else
					{
// Zero Length string

						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_INVALID_PARAMETER ) ;
						return t_Result ;
					}
				}
			}
			else
			{
				a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_INVALID_PARAMETER ) ;
				return t_Result ;
			}
		}
		else
		{
			a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_INVALID_PARAMETER ) ;
			return WBEM_E_PROVIDER_FAILURE ;
		}

		CHString t_ProcessHandle ;

		if ( a_Instance.GetCHString ( PROPERTY_NAME_PROCESSHANDLE , t_ProcessHandle ) )
		{
			DWORD t_ProcessId = 0;

			if ( swscanf ( t_ProcessHandle , L"%lu" , &t_ProcessId ) )
			{
				// Clear error
				SetLastError ( 0 ) ;

				SmartCloseHandle t_Handle = OpenProcess ( PROCESS_TERMINATE , FALSE , t_ProcessId ) ;
				if ( t_Handle )
				{
					BOOL t_Status = TerminateProcess ( t_Handle, t_Flags ) ;
					if ( t_Status )
					{
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_SUCCESS ) ;
					}
					else
					{
						DWORD t_ErrorCode = GetProcessErrorCode () ;
						a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_ErrorCode ) ;
					}
				}
				else
				{
					DWORD t_ErrorCode = GetProcessErrorCode () ;
					//if the process has terminated by this time, we'll get the following return code.
					if ( t_ErrorCode == Process_STATUS_INVALID_PARAMETER )
					{
						t_ErrorCode = Process_STATUS_PATH_NOT_FOUND ;
					}

					a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_ErrorCode ) ;
				}

				t_Result = WBEM_S_NO_ERROR;
			}
			else
			{
				t_Result = WBEM_E_INVALID_OBJECT_PATH ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

HRESULT Process :: ExecGetOwnerSid (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

#ifdef WIN9XONLY
		a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_NOT_SUPPORTED ) ;
		return t_Result ;
#endif

#ifdef NTONLY
	DWORD t_Status = Process_STATUS_SUCCESS ;
	if ( a_OutParams )
	{
		CHString t_Path ;
		CHString t_Prop ( IDS___Relpath ) ;

		if ( a_Instance.GetCHString ( t_Prop ,  t_Path ) )
		{
			CHString t_Namespace ( IDS_CimWin32Namespace ) ;

			DWORD t_BufferSize = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR t_ComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] ;

			GetComputerName ( t_ComputerName , & t_BufferSize ) ;

			CHString t_Computer ( t_ComputerName ) ;

			CHString t_AbsPath = L"\\\\" + t_Computer + L"\\" + t_Namespace + L":" + t_Path ;

			CInstancePtr t_ObjectInstance;
			t_Result = CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath , & t_ObjectInstance, a_Instance.GetMethodContext() ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ProcessId ;

				if ( t_ObjectInstance->GetDWORD ( METHOD_ARG_NAME_PROCESSID , t_ProcessId ) )
				{
					t_Status = GetSidOrAccount (a_Instance, a_OutParams , t_ProcessId , TRUE ) ;
				}
				else
				{
					t_Status = Process_STATUS_INVALID_PARAMETER ;
				}
			}
			else
			{
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}

	return t_Result ;
#endif
}


HRESULT Process :: ExecGetOwner (

	const CInstance& a_Instance,
	CInstance *a_InParams,
	CInstance *a_OutParams,
	long lFlags
)
{
	HRESULT t_Result = S_OK ;

#ifdef WIN9XONLY
		a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , Process_STATUS_NOT_SUPPORTED ) ;
		return t_Result ;
#endif

#ifdef NTONLY
	DWORD t_Status = Process_STATUS_SUCCESS ;

	if ( a_OutParams )
	{
		CHString t_Path ;
		CHString t_Prop ( IDS___Relpath ) ;

		if ( a_Instance.GetCHString ( t_Prop ,  t_Path ) )
		{
			CHString t_Namespace ( IDS_CimWin32Namespace ) ;

			DWORD t_BufferSize = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR t_ComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] ;

			GetComputerName ( t_ComputerName , & t_BufferSize ) ;

			CHString t_Computer ( t_ComputerName ) ;

			CHString t_AbsPath = L"\\\\" + t_Computer + L"\\" + t_Namespace + L":" + t_Path ;

			CInstancePtr t_ObjectInstance;
			t_Result = CWbemProviderGlue :: GetInstanceByPath ( ( LPCTSTR ) t_AbsPath , & t_ObjectInstance, a_Instance.GetMethodContext() ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ProcessId ;

				if ( t_ObjectInstance->GetDWORD ( METHOD_ARG_NAME_PROCESSID , t_ProcessId ) )
				{
					t_Status = GetSidOrAccount (a_Instance , a_OutParams , t_ProcessId , FALSE ) ;
				}
				else
				{
					t_Status = Process_STATUS_INVALID_PARAMETER ;
				}
			}
			else
			{
			}

		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		a_OutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , t_Status ) ;
	}

	return t_Result ;
#endif
}


HRESULT Process::ExecSetPriority(

	const CInstance& cinstProcess,
	CInstance *cinstInParams,
	CInstance *cinstOutParams,
	long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef WIN9XONLY
		cinstOutParams->SetDWORD(METHOD_ARG_NAME_RETURNVALUE, Process_STATUS_NOT_SUPPORTED);
#endif

#ifdef NTONLY

    DWORD dwError = ERROR_SUCCESS;
    if(cinstInParams && cinstOutParams)
    {
        // Get the process id...
        DWORD dwPID;
        DWORD dwNewPriority;
        bool fValidPriority = false;
        CHString chstrTmp;

        if(!cinstProcess.GetCHString(
               L"Handle",
               chstrTmp))
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
        else
        {
            dwPID = wcstoul(chstrTmp, NULL, 10);
        }

        // Get the requested new priority...
        if(SUCCEEDED(hr))
        {
            if(!cinstInParams->GetDWORD(
                   METHOD_ARG_NAME_PRIORITY,
                   dwNewPriority))
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }

        // Validate the new value...
        if(SUCCEEDED(hr))
        {
            switch(dwNewPriority)
            {
                case IDLE_PRIORITY_CLASS:
                case BELOW_NORMAL_PRIORITY_CLASS:
                case NORMAL_PRIORITY_CLASS:
                case ABOVE_NORMAL_PRIORITY_CLASS:
                case HIGH_PRIORITY_CLASS:
                case REALTIME_PRIORITY_CLASS:
                    fValidPriority = true;
                break;
            }

            if(!fValidPriority)
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }

        // Set the thread priority...
        if(SUCCEEDED(hr))
        {
            SmartCloseHandle hProcess = ::OpenProcess(
                                  PROCESS_SET_INFORMATION, 
                                  FALSE, 
                                  dwPID);
            if(hProcess) 
            {
                if(!::SetPriorityClass(
                        hProcess, 
                        dwNewPriority)) 
                {
                    dwError = ::GetLastError();
                }
                
            }
            else
            {
                dwError = ::GetLastError();
            }
        }

        // Set the return value...
        if(SUCCEEDED(hr))
        {
		    cinstOutParams->SetDWORD(
                METHOD_ARG_NAME_RETURNVALUE, 
                dwError);
	    }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

#endif  // NTONLY

    return hr;
}


HRESULT Process::ExecAttachDebugger(

	const CInstance& cinstProcess,
	CInstance *cinstInParams,
	CInstance *cinstOutParams,
	long lFlags)
{
	HRESULT hr = WBEM_S_NO_ERROR;

#ifdef WIN9XONLY
		cinstOutParams->SetDWORD(METHOD_ARG_NAME_RETURNVALUE, Process_STATUS_NOT_SUPPORTED);
#endif

#ifdef NTONLY

    DWORD dwError = ERROR_SUCCESS;

    // Require the SE_DEBUG_NAME privilege...
    CTokenPrivilege	debugPrivilege(SE_DEBUG_NAME);
	BOOL fDisablePrivilege = FALSE;

	fDisablePrivilege = (debugPrivilege.Enable() == ERROR_SUCCESS);
    
    // Get the process id...
    DWORD dwPID;
    bool fValidPriority = false;
    CHString chstrTmp;

    if(!cinstProcess.GetCHString(
           L"Handle",
           chstrTmp))
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        dwPID = wcstoul(chstrTmp, NULL, 10);
    }

    // Get the debug cmd line from the registry...
    CHString chstrDbgStr;
    if(SUCCEEDED(hr))
    {
        GetDebuggerString(chstrDbgStr);    
    }

    // Validate the new value...
    if(SUCCEEDED(hr))
    {
        if(chstrDbgStr.GetLength() == 0)
        {
            // Set an explanatory status
            // object...
            CHString chstrMsg;
            chstrMsg = "Missing or invalid registry debug string in HKEY_LOCAL_MACHINE subkey ";
            chstrMsg += DEBUG_REGISTRY_STRING;
            SetStatusObject(
                   cinstProcess.GetMethodContext(),
                   chstrMsg);
            hr = WBEM_E_FAILED;
        }
    }

    // Start the debugger...
    if(SUCCEEDED(hr))
    {
        WCHAR wstrCmdline[MAX_PATH * 2];
        wsprintf(wstrCmdline, 
                 L"\"%s\" -p %ld", 
                 (LPCWSTR)chstrDbgStr, 
                 dwPID);
        
        // Desktop specified (rather than left NULL) because
        // without specifying the interactive (console) desktop
        // the debugger, if launched remotely, would not show
        // up.
        STARTUPINFO sinfo = { sizeof(STARTUPINFO), 0, L"WinSta0\\Default"};

        LPWSTR wstrEnv = NULL;
        dwError = ProcessCreation(
	        cinstOutParams,
	        wstrCmdline,
	        FALSE,
	        CHString(),
	        wstrEnv,
	        FALSE,
	        0,
	        CREATE_NEW_CONSOLE,
	        FALSE,
	        sinfo);
    }

    // Set the return value...
    if(SUCCEEDED(hr))
    {
		cinstOutParams->SetDWORD(
            METHOD_ARG_NAME_RETURNVALUE, 
            dwError);
	}

    // If we failed because we didn't have
    // the debug privilege, set a status object...
    if(SUCCEEDED(hr))
    {
        if(dwError == ERROR_PRIVILEGE_NOT_HELD)
        {
            cinstOutParams->SetDWORD(
                METHOD_ARG_NAME_RETURNVALUE, 
                STATUS_PRIVILEGE_NOT_HELD);

            SetSinglePrivilegeStatusObject(
                cinstProcess.GetMethodContext(), 
                SE_SECURITY_NAME);

			hr = WBEM_E_ACCESS_DENIED;
        }
    }

    // Disable debug privilege if we enabeled it...
    if(fDisablePrivilege)
    {
        debugPrivilege.Enable(FALSE);
    }

#endif  // NTONLY

    return hr;
}



DWORD Process :: GetEnvBlock (

	const CHString &rchsSid,
	const CHString &rchsUserName,
	const CHString &rchsDomainName ,
	TCHAR* &rszEnvironBlock
)
{
	CHStringArray aEnvironmentVars ;
	CHStringArray aEnvironmentVarsValues ;
	rszEnvironBlock = NULL ;

	//fill user env. vars. under HKEY_USERS\{Sid}\Environment
	DWORD dwRetVal = GetEnvironmentVariables (

		HKEY_USERS,
		rchsSid + CHString( _T("\\Environment") ),
		aEnvironmentVars,
		aEnvironmentVarsValues
	) ;

	// if the user has no env. set, the HKEY_USERS\{Sid}\Environment is missing
	if ( dwRetVal == ERROR_SUCCESS || dwRetVal == ERROR_FILE_NOT_FOUND )
	{
		//fill user env. vars. under HKEY_USERS\{Sid}\Volatile Environment
		DWORD dwRetVal = GetEnvironmentVariables (

			HKEY_USERS,
			rchsSid + CHString( _T("\\Volatile Environment") ),
			aEnvironmentVars,
			aEnvironmentVarsValues
		) ;
	}

	if ( dwRetVal == ERROR_SUCCESS || dwRetVal == ERROR_FILE_NOT_FOUND )
	{
		//fill system env. vars. under HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment
		dwRetVal = GetEnvironmentVariables (

			HKEY_LOCAL_MACHINE,
			_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"),
			aEnvironmentVars,
			aEnvironmentVarsValues
		) ;
	}

	if ( dwRetVal == ERROR_SUCCESS )
	{
		aEnvironmentVars.Add ( L"USERNAME" ) ;
		aEnvironmentVarsValues.Add ( rchsUserName ) ;

		aEnvironmentVars.Add ( L"USERDOMAIN" ) ;
		aEnvironmentVarsValues.Add ( rchsDomainName );
		DWORD dwBlockSize = 0 ;
		//get the size reqd. for env. block

		for ( int i = 0 ; i < aEnvironmentVars.GetSize() ; i++ )
		{
			CHString chsTmp = aEnvironmentVars.GetAt ( i ) + aEnvironmentVarsValues.GetAt ( i ) ;

			//add two: one for "=" sign + NULL terminator
			dwBlockSize += wcslen ( chsTmp ) + 2 ;
		}

		//add one more for null terminator
		rszEnvironBlock = new TCHAR [ dwBlockSize + 1 ] ;
		if ( rszEnvironBlock )
		{
			try
			{
				DWORD dwOffset = 0 ;

				//now start copying .....var=value
				for ( int i = 0 ; i < aEnvironmentVars.GetSize() ; i++ )
				{
					CHString chsTmp = aEnvironmentVars.GetAt ( i ) + CHString( _T("=") ) + aEnvironmentVarsValues.GetAt ( i ) ;
					_tcscpy( &rszEnvironBlock[dwOffset], TOBSTRT(chsTmp)) ;
					dwOffset += wcslen( chsTmp ) + 1 ;
				}

				rszEnvironBlock[ dwOffset ] = 0 ;
			}
			catch ( ... )
			{
				delete [] rszEnvironBlock ;

				throw ;
			}
		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

	return dwRetVal ;
}




DWORD Process :: GetEnvironmentVariables (

	 HKEY hKey,
	 const CHString& chsSubKey,
	 CHStringArray &aEnvironmentVars,
	 CHStringArray &aEnvironmentVarsValues
)
{
	CRegistry Reg ;
	DWORD dwRetVal = Reg.Open ( hKey, chsSubKey, KEY_READ ) ;
	if( dwRetVal == ERROR_SUCCESS )
	{
		if ( Reg.GetValueCount() )
		{
			bool bContinue = true ;
			DWORD dwIndexOfValue = 0 ;
			while ( bContinue && dwRetVal == ERROR_SUCCESS )
			{
				// haven't seen ERROR_NO_MORE_ITEMS being returned

				if( dwIndexOfValue >= Reg.GetValueCount() )
				{
					break ;
				}

				WCHAR *pValueName = NULL ;
				BYTE  *pValueData = NULL ;

				//get the next value under the key
				dwRetVal = Reg.EnumerateAndGetValues (

					dwIndexOfValue,
					pValueName,
					pValueData
				) ;

				if ( dwRetVal == ERROR_SUCCESS )
				{
					try
					{
						DWORD dwLen = _tcslen( (LPCTSTR) pValueData ) +1 ;

						TCHAR *pszExpandedVarValue = new TCHAR [ dwLen ] ;
						if ( pszExpandedVarValue )
						{
							DWORD dwReq ;
							try
							{
								ZeroMemory ( pszExpandedVarValue, dwLen*sizeof(TCHAR) ) ;
								dwReq = ExpandEnvironmentStrings ( (LPCTSTR) pValueData, pszExpandedVarValue, dwLen ) ;
							}
							catch ( ... )
							{
								delete [] pszExpandedVarValue ;

								throw ;
							}

							if ( dwReq > dwLen)
							{
								delete [] pszExpandedVarValue ;
								dwLen = dwReq ;
								pszExpandedVarValue = new TCHAR[ dwLen ] ;
								if ( pszExpandedVarValue )
								{
									try
									{
										ZeroMemory ( pszExpandedVarValue, dwLen*sizeof(TCHAR) ) ;
										dwReq = ExpandEnvironmentStrings ( (LPCTSTR) pValueData, pszExpandedVarValue, dwLen ) ;
									}
									catch ( ... )
									{
										delete [] pszExpandedVarValue ;

										throw ;
									}
								}
								else
								{
									throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
								}
							}

							bool bAddIt = true ;

							try
							{
								//check to see if same env. var. already present
								for ( int i = 0 ; i < aEnvironmentVars.GetSize() ; i++ )
								{
									CHString chsTmp = aEnvironmentVars.GetAt ( i ) ;
									if ( !chsTmp.CompareNoCase ( pValueName ) )
									{
										//prefix the new value before the old one, if it's a PATH var.
										if ( !chsTmp.CompareNoCase( IDS_Path ) )
										{
											aEnvironmentVarsValues[i] = CHString( pszExpandedVarValue ) + CHString ( _T(";") ) + aEnvironmentVarsValues[i] ;
										}
										bAddIt = false ;
										break ;
									}
								}

								if( bAddIt )
								{
									aEnvironmentVars.Add ( pValueName ) ;
									aEnvironmentVarsValues.Add ( TOBSTRT(pszExpandedVarValue)) ;
								}
							}
							catch ( ... )
							{
								delete[] pszExpandedVarValue ;

								throw ;
							}

							delete[] pszExpandedVarValue ;
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
					catch ( ... )
					{
						delete [] pValueName ;
						delete [] pValueData ;

						throw ;
					}

					delete [] pValueName ;
					delete [] pValueData ;
				}

				if( dwRetVal == ERROR_NO_MORE_ITEMS )
				{
					bContinue = false ;
					dwRetVal = ERROR_SUCCESS ;
				}
				dwIndexOfValue++ ;
			}
		}

		Reg.Close() ;
	}

	return dwRetVal ;
}


#ifdef NTONLY
SYSTEM_PROCESS_INFORMATION *Process :: GetProcessBlocks ( CNtDllApi &a_NtApi )
{
	DWORD t_ProcessInformationSize = 32768;
	SYSTEM_PROCESS_INFORMATION *t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
	if ( t_ProcessInformation )
	{
		try
		{
			BOOL t_Retry = TRUE ;
			while ( t_Retry )
			{
				NTSTATUS t_Status = a_NtApi.NtQuerySystemInformation (

					SystemProcessInformation,
					t_ProcessInformation,
					t_ProcessInformationSize,
					NULL
				) ;

				if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
				{
					delete [] t_ProcessInformation;
					t_ProcessInformation = NULL ;
					t_ProcessInformationSize += 32768 ;
					t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
					if ( !t_ProcessInformation )
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
				else
				{
					t_Retry = FALSE ;

					if ( ! NT_SUCCESS ( t_Status ) )
					{
						delete [] t_ProcessInformation;
						t_ProcessInformation = NULL ;
					}
				}
			}
		}
		catch ( ... )
		{
			if ( t_ProcessInformation )
			{
				delete [] t_ProcessInformation;
				t_ProcessInformation = NULL ;
			}
			throw ;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return t_ProcessInformation ;
}

SYSTEM_PROCESS_INFORMATION *Process :: NextProcessBlock ( CNtDllApi &a_NtApi , SYSTEM_PROCESS_INFORMATION *a_ProcessBlock )
{
	if ( a_ProcessBlock )
	{
		DWORD t_NextOffSet = a_ProcessBlock->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			return ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) a_ProcessBlock ) + t_NextOffSet ) ;
		}
	}

	return NULL ;
}

SYSTEM_PROCESS_INFORMATION *Process :: GetProcessBlock ( CNtDllApi &a_NtApi , SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , DWORD a_ProcessId )
{
	if ( a_ProcessBlock )
	{
		DWORD t_OffSet = 0;

		while ( TRUE )
		{
			SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = ( PSYSTEM_PROCESS_INFORMATION ) ( ( BYTE * ) a_ProcessBlock + t_OffSet ) ;

			if ( HandleToUlong ( t_CurrentInformation->UniqueProcessId ) == a_ProcessId )
			{
				return t_CurrentInformation ;
			}

			DWORD t_NextOffSet = t_CurrentInformation->NextEntryOffset ;

			if ( ! t_NextOffSet )
			{
				return NULL ;
			}

			t_OffSet += t_NextOffSet ;
		}
	}

	return NULL ;
}

BOOL Process :: GetProcessExecutable ( CNtDllApi &a_NtApi , HANDLE a_Process , CHString &a_ExecutableName )
{
	BOOL t_Success = FALSE ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = a_NtApi.NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		t_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( t_Status )
		{
			LIST_ENTRY *t_LdrHead = & t_Ldr->InMemoryOrderModuleList ;

			//
			// LdrNext = Head->Flink;
			//

			LIST_ENTRY *t_LdrNext ;

			t_Status = ReadProcessMemory (

				a_Process,
				& t_LdrHead->Flink,
				& t_LdrNext,
				sizeof ( t_LdrNext ) ,
				NULL
			) ;

			if ( t_Status )
			{
				if ( t_LdrNext != t_LdrHead )
				{
					LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

					LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( t_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

					t_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntry,
						& t_LdrEntryData,
						sizeof ( t_LdrEntryData ) ,
						NULL
					) ;

					if ( t_Status )
					{
						wchar_t *t_Executable = ( wchar_t * ) new WCHAR [t_LdrEntryData.FullDllName.MaximumLength ];
						if ( t_Executable )
						{
							try
							{
								t_Status = ReadProcessMemory (

									a_Process,
									t_LdrEntryData.FullDllName.Buffer,
									t_Executable ,
									t_LdrEntryData.FullDllName.MaximumLength ,
									NULL
								) ;

								if ( t_Status )
								{
									CHString t_Path ( t_Executable ) ;

									if ( t_Path.Find ( _T("\\??\\") ) == 0 )
									{
										a_ExecutableName = t_Path.Mid ( sizeof ( _T("\\??\\") ) / sizeof ( wchar_t ) - 1 ) ;
									}
									else if ( t_Path.Find ( _T("\\SystemRoot\\") ) == 0 )
									{
										wchar_t t_NormalisedPath [ MAX_PATH ] ;

										GetWindowsDirectory ( t_NormalisedPath , sizeof ( t_NormalisedPath ) / sizeof ( wchar_t ) ) ;

										wcscat ( t_NormalisedPath , t_Path.Mid ( sizeof ( _T("\\SystemRoot") ) / sizeof ( wchar_t ) - 1 ) ) ;

										a_ExecutableName = t_NormalisedPath;
									}
									else
									{
										a_ExecutableName = t_Path ;
									}

									t_Success = TRUE ;
								}
							}
							catch ( ... )
							{
								delete [] t_Executable;

								throw ;
							}
						}
						else
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}

						delete [] t_Executable;
					}
				}
			}
		}
	}

    return t_Success ;
}

BOOL Process :: GetProcessModuleBlock (

	CNtDllApi &a_NtApi ,
	HANDLE a_Process ,
	LIST_ENTRY *&a_Head
)
{
    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = a_NtApi.NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		t_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr ,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( t_Status )
		{
			a_Head = & t_Ldr->InMemoryOrderModuleList ;

			return TRUE ;
		}
	}

    return FALSE ;
}

BOOL Process :: NextProcessModule (

	CNtDllApi &a_NtApi ,
	HANDLE a_Process ,
	LIST_ENTRY *&a_LdrHead ,
	LIST_ENTRY *&a_LdrNext ,
	CHString &a_ModuleName ,
    DWORD_PTR *a_pdwBaseAddress,
    DWORD *a_pdwUsageCount
)
{
	BOOL t_Success = FALSE ;

    //
    // LdrNext = Head->Flink;
    //

	BOOL t_Status = ReadProcessMemory (

		a_Process,
		& a_LdrNext->Flink,
		& a_LdrNext,
		sizeof ( a_LdrNext ) ,
		NULL
	) ;

    if ( t_Status )
	{
		if ( a_LdrNext != a_LdrHead )
		{
			LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

			LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( a_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

			t_Status = ReadProcessMemory (

				a_Process,
				t_LdrEntry,
				& t_LdrEntryData,
				sizeof ( t_LdrEntryData ) ,
				NULL
			) ;

			if ( t_Status )
			{
				WCHAR t_StackString [ MAX_PATH ] ;
				BOOL t_HeapAllocated = t_LdrEntryData.FullDllName.MaximumLength > MAX_PATH * sizeof ( WCHAR ) ;

				*a_pdwBaseAddress = (DWORD_PTR) t_LdrEntryData.DllBase;
                *a_pdwUsageCount = t_LdrEntryData.LoadCount;

                wchar_t *t_Executable = t_StackString ;

				if ( t_HeapAllocated )
				{
					t_Executable = ( wchar_t * ) new WCHAR [t_LdrEntryData.FullDllName.MaximumLength ];
					if ( ! t_Executable )
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}

				try
				{
					t_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntryData.FullDllName.Buffer,
						t_Executable ,
						t_LdrEntryData.FullDllName.MaximumLength ,
						NULL
					) ;

					if ( t_Status )
					{
						CHString t_Path ( t_Executable ) ;

						if ( t_Path.Find ( _T("\\??\\") ) == 0 )
						{
							a_ModuleName = t_Path.Mid ( sizeof ( _T("\\??\\") ) / sizeof ( wchar_t ) - 1 ) ;
						}
						else if ( t_Path.Find ( _T("\\SystemRoot\\") ) == 0 )
						{
							wchar_t t_NormalisedPath [ MAX_PATH ] ;

							GetWindowsDirectory ( t_NormalisedPath , sizeof ( t_NormalisedPath ) / sizeof ( wchar_t ) ) ;

							wcscat ( t_NormalisedPath , t_Path.Mid ( sizeof ( _T("\\SystemRoot") ) / sizeof ( wchar_t ) - 1 ) ) ;

							a_ModuleName = t_NormalisedPath;
						}
						else
						{
							a_ModuleName = t_Path ;
						}

						t_Success = TRUE ;
					}
				}
				catch ( ... )
				{
					if ( t_HeapAllocated )
					{
						delete [] t_Executable;
					}

					throw ;
				}

				if ( t_HeapAllocated )
				{
					delete [] t_Executable;
				}
			}
		}
	}

    return t_Success ;
}

BOOL Process :: GetProcessParameters (

	CNtDllApi &a_NtApi ,
	HANDLE a_Process ,
	CHString &a_ProcessCommandLine
)
{
	BOOL t_Success = FALSE ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = a_NtApi.NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		RTL_USER_PROCESS_PARAMETERS *t_ProcessParameters = NULL ;

		t_Success = ReadProcessMemory (

			a_Process,
			& t_Peb->ProcessParameters,
			& t_ProcessParameters,
			sizeof ( t_ProcessParameters ) ,
			NULL
		) ;

		if ( t_Success )
		{
			RTL_USER_PROCESS_PARAMETERS t_Parameters ;

			t_Success = ReadProcessMemory (

				a_Process,
				t_ProcessParameters,
				& t_Parameters ,
				sizeof ( RTL_USER_PROCESS_PARAMETERS ) ,
				NULL
			) ;

			if ( t_Success )
			{
				WCHAR *t_Command = new WCHAR [ t_Parameters.CommandLine.MaximumLength ];

				try
				{
					t_Success = ReadProcessMemory (

						a_Process,
						t_Parameters.CommandLine.Buffer ,
						t_Command ,
						t_Parameters.CommandLine.MaximumLength ,
						NULL
					) ;

					if ( t_Success )
					{
						a_ProcessCommandLine = t_Command ;
					}
				}
				catch(...)
				{
					delete [] t_Command ;
					t_Command = NULL;
					throw;
				}

				delete [] t_Command ;
				t_Command = NULL;
			}
		}
	}

	return t_Success ;
}

#endif

#ifdef WIN9XONLY

bool GetThreadList ( CKernel32Api &a_ToolHelp, std::deque<DWORD> & a_ThreadQ )
{
	bool t_bRet = false ;
	SmartCloseHandle t_hSnapshot ;

	if(

		a_ToolHelp.CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0, &t_hSnapshot ) &&
		( t_hSnapshot != INVALID_HANDLE_VALUE )
		)
	{
		t_bRet = true ;
		BOOL t_fRetCode ;
		THREADENTRY32 t_oThreadEntry ;
		t_oThreadEntry.dwSize = sizeof( THREADENTRY32 ) ;

		if ( a_ToolHelp.Thread32First( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) && t_fRetCode )
		{
			while( t_fRetCode )
			{
				a_ThreadQ.push_back ( t_oThreadEntry.th32OwnerProcessID ) ;
				a_ToolHelp.Thread32Next( t_hSnapshot, &t_oThreadEntry, &t_fRetCode ) ;
			}
		}
	}

	return t_bRet ;
}

#endif


#ifdef NTONLY
void Process::GetDebuggerString(
    CHString& chstrDbgStr)
{
    HKEY hkDebug;

    if (ERROR_SUCCESS == RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE, 
                             DEBUG_REGISTRY_STRING,
                             0, 
                             KEY_READ, 
                             &hkDebug))
    {
        WCHAR wstrDebugger[MAX_PATH * 2];
        DWORD dwString = sizeof(wstrDebugger);

        if (ERROR_SUCCESS == RegQueryValueEx(
                                 hkDebug, 
                                 L"Debugger", 
                                 NULL, 
                                 NULL, 
                                 (LPBYTE) wstrDebugger, 
                                 &dwString))
        {
            // Find the first token (which is the debugger exe name/path)
            LPWSTR pwstrCmdLine = wstrDebugger;
            if(*pwstrCmdLine == L'\"') 
            {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                while(*++pwstrCmdLine && (*pwstrCmdLine != L'\"'));
            }
            else
            {
                // there are no double quotes - just go up to the next
                // space...
                WCHAR* pwc = wcschr(pwstrCmdLine, L' ');
                if(pwc)
                {
                    pwstrCmdLine = pwc;
                }
            }

            if(pwstrCmdLine)
            {
                // Don't need the rest of the args, etc
                *pwstrCmdLine = L'\0';   

                // If the doctor is in, we don't allow the Debug action...
                if(lstrlen(wstrDebugger) && 
                   lstrcmpi(wstrDebugger, L"drwtsn32") && 
                   lstrcmpi(wstrDebugger, L"drwtsn32.exe"))
                {
                    chstrDbgStr = wstrDebugger;
                    if(chstrDbgStr.Left(1) == L"\"")
                    {
                        chstrDbgStr = chstrDbgStr.Mid(1);
                    }
                }
            }
        }

        RegCloseKey(hkDebug);
    }
}
#endif


#ifdef NTONLY
// sets a status object with a message
bool Process::SetStatusObject(
    MethodContext* pContext, 
    const WCHAR* wstrMsg)
{
	return CWbemProviderGlue::SetStatusObject(
                pContext, 
                IDS_CimWin32Namespace,
                wstrMsg, 
                WBEM_E_FAILED, 
                NULL, 
                NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cpuid.h ===
//=================================================================

//

// CPUID.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#define FPU_FLAG			0x00000001 
#define VME_FLAG			0x00000002 
#define DE_FLAG			0x00000004 
#define PSE_FLAG			0x00000008 
#define TSC_FLAG			0x00000010 
#define MSR_FLAG			0x00000020 
#define PAE_FLAG			0x00000040 
#define MCE_FLAG			0x00000080 
#define CX8_FLAG			0x00000100 
#define APIC_FLAG			0x00000200 
#define MTRR_FLAG			0x00001000 
#define PGE_FLAG			0x00002000 
#define MCA_FLAG			0x00004000 
#define CMOV_FLAG			0x00008000 
#define MMX_FLAG			0x00800000
#define THREEDNOW_FLAG	0x80000000

#define WBEM_CPU_FAMILY_OTHER		1
#define WBEM_CPU_FAMILY_UNKNOWN	    2
#define WBEM_CPU_FAMILY_386		    5
#define WBEM_CPU_FAMILY_486		    6
#define WBEM_CPU_FAMILY_PENTIUM	    11
#define WBEM_CPU_FAMILY_PPRO		12
#define WBEM_CPU_FAMILY_PII		    13
#define WBEM_CPU_FAMILY_PMMX		14
#define WBEM_CPU_FAMILY_CELERON		15
#define WBEM_CPU_FAMILY_PIIXEON		16
#define WBEM_CPU_FAMILY_PIII		17
#define WBEM_CPU_FAMILY_PIIIXEON	176
#define WBEM_CPU_FAMILY_M1			18
#define WBEM_CPU_FAMILY_M2			19
#define WBEM_CPU_FAMILY_K5			25
#define WBEM_CPU_FAMILY_K6			26
#define WBEM_CPU_FAMILY_K62 		27
#define WBEM_CPU_FAMILY_K63	    	28
#define WBEM_CPU_FAMILY_K7	    	29
#define WBEM_CPU_FAMILY_ALPHA 	    48
#define WBEM_CPU_FAMILY_MIPS		64
#define WBEM_CPU_FAMILY_PPC		    32
#define WBEM_CPU_FAMILY_6X86	    300
#define WBEM_CPU_FAMILY_MEDIAGX	    301
#define WBEM_CPU_FAMILY_MII 	    302
#define WBEM_CPU_FAMILY_WINCHIP     320
#define WBEM_CPU_FAMILY_IA64		400

#define WBEM_CPU_UPGRADE_OTHER	    1
#define WBEM_CPU_UPGRADE_UNKNOWN    2
#define WBEM_CPU_UPGRADE_ZIFF		4
#define WBEM_CPU_UPGRADE_SLOT1	    8
#define WBEM_CPU_UPGRADE_SLOT2	    9
#define WBEM_CPU_UPGRADE_SOCKET_370 10
#define WBEM_CPU_UPGRADE_SLOTA	    11
#define WBEM_CPU_UPGRADE_SLOTM	    12





typedef struct _tagSYSTEM_INFO_EX
{
	// From SYSTEM_INFO
	union 
	{         
		DWORD  dwOemId;         
		struct 
		{ 
            WORD wProcessorArchitecture;             
			WORD wReserved;         
		}; 
    };     
	DWORD	dwPageSize;     
	LPVOID	lpMinimumApplicationAddress; 
	LPVOID	lpMaximumApplicationAddress;     
	DWORD	dwActiveProcessorMask; 
	DWORD	dwNumberOfProcessors;     
	DWORD	dwProcessorType; 
	DWORD	dwAllocationGranularity;     
	WORD	wProcessorLevel; 
	WORD	wProcessorRevision;
	
	// New properties for SYSTEM_INFO_EX
	WCHAR   szProcessorName[100];
	WCHAR   szCPUIDProcessorName[100];
	WCHAR   szProcessorVersion[100];
    WCHAR   szProcessorVendor[40];
	WCHAR	szProcessorStepping[17];
	DWORD	dwProcessorSpeed;
	DWORD	dwProcessorL2CacheSize;
	DWORD	dwProcessorL2CacheSpeed;
	DWORD	dwProcessorSignature;
	DWORD	dwProcessorFeatures;
	DWORD   dwProcessorFeaturesEx;
	BOOL	bCoprocessorPresent;
	
    // PIII (and higher) serial number
    DWORD   dwSerialNumber[3];

	// WBEM specific
	WORD	wWBEMProcessorFamily;
	WORD	wWBEMProcessorUpgradeMethod;

    // SMBIOS
    DWORD   dwExternalClock;
} SYSTEM_INFO_EX;

#define CPU_386
#ifdef __cplusplus
extern "C" {
#endif

BOOL GetSystemInfoEx(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo, DWORD dwCurrentSpeed);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cprocess.h ===
//=============================================================================

//

// Process.h -- Process property set provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/27/97	 a-hhance		updated to new framework paradigm.
//
//=============================================================================

// Property set identification
//============================
#include <deque>
#define PROPSET_NAME_PROCESS					    L"Win32_Process"           
#define PROPSET_NAME_PROCESSSTARTUP				    L"Win32_ProcessStartup"           

#define PROPERTY_NAME_ENVIRONMENTVARIABLES		    L"EnvironmentVariables"
#define PROPERTY_NAME_WINSTATIONDESKTOP			    L"WinstationDesktop"
#define PROPERTY_NAME_TITLE						    L"Title"
#define PROPERTY_NAME_SHOWWINDOW				    L"ShowWindow"

#define PROPERTY_NAME_X							    L"X"
#define PROPERTY_NAME_Y							    L"Y"
#define PROPERTY_NAME_XSIZE						    L"XSize"
#define PROPERTY_NAME_YSIZE						    L"YSize"
#define PROPERTY_NAME_XCOUNTCHARS				    L"XCountChars"
#define PROPERTY_NAME_YCOUNTCHARS				    L"YCountChars"

#define PROPERTY_NAME_CREATIONFLAGS				    L"CreateFlags"
#define PROPERTY_NAME_PRIORITYCLASS				    L"PriorityClass"
#define PROPERTY_NAME_FILLATTRIBUTE				    L"FillAttribute"
#define PROPERTY_NAME_ERRORMODE					    L"ErrorMode"


#define METHOD_NAME_CREATE				            L"Create"
#define METHOD_NAME_TERMINATE			            L"Terminate"
#define METHOD_NAME_GETOWNER			            L"GetOwner"
#define METHOD_NAME_GETOWNERSID			            L"GetOwnerSid"
#define METHOD_NAME_SETPRIORITY                     L"SetPriority"
#define METHOD_NAME_ATTACHDEBUGGER                  L"AttachDebugger"


#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"
#define METHOD_ARG_NAME_REASON						L"Reason"
#define METHOD_ARG_NAME_COMMANDLINE					L"CommandLine"
#define METHOD_ARG_NAME_PROCESSID					L"ProcessId"
#define METHOD_ARG_NAME_CURRENTDIRECTORY			L"CurrentDirectory"
#define METHOD_ARG_NAME_PROCESSTARTUPINFORMATION	L"ProcessStartupInformation"
#define METHOD_ARG_NAME_DOMAIN						L"Domain"
#define METHOD_ARG_NAME_USER						L"User"
#define METHOD_ARG_NAME_SID							L"Sid"
#define METHOD_ARG_NAME_PRIORITY                    L"Priority"

#define	PROPERTY_NAME_PROCESSHANDLE					L"Handle"

#define PROPERTY_VALUE_DESKTOP_WIN0DEFAULT			_T("")

#define DEBUG_REGISTRY_STRING                       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"

#define PROPERTY_VALUE_MODE_CREATE_DEFAULT_ERROR_MODE	        0
#define PROPERTY_VALUE_MODE_CREATE_NEW_CONSOLE			        1
#define PROPERTY_VALUE_MODE_CREATE_NEW_PROCESS_GROUP	        2	
#define PROPERTY_VALUE_MODE_CREATE_SEPARATE_WOW_VDM 	        3
#define PROPERTY_VALUE_MODE_CREATE_SHARED_WOW_VDM		        4
#define PROPERTY_VALUE_MODE_CREATE_SUSPENDED			        5
#define PROPERTY_VALUE_MODE_CREATE_UNICODE_ENVIRONMENT	        6
#define PROPERTY_VALUE_MODE_DEBUG_PROCESS				        7
#define PROPERTY_VALUE_MODE_DEBUG_ONLY_THIS_PROCESS 	        8
#define PROPERTY_VALUE_MODE_DETACHED_PROCESS			        9

#define PROPERTY_VALUE_PRIORITYCLASS_HIGH		                0
#define PROPERTY_VALUE_PRIORITYCLASS_IDLE		                1
#define PROPERTY_VALUE_PRIORITYCLASS_NORMAL		                2
#define PROPERTY_VALUE_PRIORITYCLASS_REALTIME	                3

#define PROPERTY_VALUE_ERRORMODE_FAIL_CRITICAL_ERRORS			0
#define PROPERTY_VALUE_ERRORMODE_NO_ALIGNMENT_FAULT_EXCEPT		1
#define PROPERTY_VALUE_ERRORMODE_NO_GP_FAULT_ERROR_BOX			2
#define PROPERTY_VALUE_ERRORMODE_NO_OPEN_FILE_ERROR_BOX			3


#define Process_STATUS_SUCCESS							        0
#define Process_STATUS_NOT_SUPPORTED					        1

// Control 
#define Process_STATUS_ACCESS_DENIED					        2
#define Process_STATUS_INSUFFICIENT_PRIVILEGE			        3
#define Process_STATUS_UNKNOWN_FAILURE					        8

// Start
#define Process_STATUS_PATH_NOT_FOUND					        9
#define Process_STATUS_INVALID_PARAMETER				        21

//#define  PROPSET_UUID_PROCESS "{7d9b7a20-3ead-11d0-93a1-0000e80d7352}"

#define BUFFER_SIZE_INIT        0x8000
#define BUFFER_SIZE_INCREMENT   0x1000

#define MAX_PROCESSES           0x0100

// valid CREATIONFLAGS
#define CREATIONFLAGS	(	DEBUG_PROCESS |					\
							DEBUG_ONLY_THIS_PROCESS |		\
							CREATE_SUSPENDED |				\
							DETACHED_PROCESS |				\
							CREATE_NEW_CONSOLE |			\
							CREATE_NEW_PROCESS_GROUP |		\
							CREATE_UNICODE_ENVIRONMENT  |	\
							CREATE_FORCEDOS |				\
							CREATE_BREAKAWAY_FROM_JOB |		\
							CREATE_DEFAULT_ERROR_MODE )		\

/*
typedef struct _PROCESS_CACHE
{
    BOOL    bInvalid ;
    DWORD   dwProcessCount ;
    DWORD   dwPIDList[MAX_PROCESSES] ;
    DWORD   dwBaseModuleList[MAX_PROCESSES] ;
    char    szNameList[MAX_PROCESSES][50] ;

} PROCESS_CACHE ;
*/

//doesn't have copyctr...use ref or ptr !!
class PROCESS_CACHE
{

public:

	BOOL    bInvalid ;
    DWORD   dwProcessCount ;
    DWORD   *pdwPIDList ;
    DWORD   *pdwBaseModuleList ;
    TCHAR   (*pszNameList)[50] ;

	PROCESS_CACHE()
	{
		AllocateMemories(MAX_PROCESSES) ;
		dwProcessCount = MAX_PROCESSES ;
	}


	~PROCESS_CACHE()
	{
		dwProcessCount = 0 ;
		Clear() ;
	}

	void AllocateMemories(DWORD dwSize)
	{
		pdwPIDList = new DWORD[dwSize] ;
		pdwBaseModuleList = new DWORD[dwSize] ;
		pszNameList = new TCHAR[dwSize][50] ;
		dwProcessCount = dwSize ;
	}

	void Clear()
	{

		if(pdwPIDList)
		{
			delete[] pdwPIDList ;
			pdwPIDList = NULL ;

		}
		if(pdwBaseModuleList)
		{
			delete[] pdwBaseModuleList ;
			pdwBaseModuleList = NULL ;
		}
		if(pszNameList)
		{
			delete[] pszNameList ;
			pszNameList = NULL ;
		}

	}

};

#if NTONLY == 4
typedef struct _SYSTEM_PROCESS_INFORMATION_NT4 {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SpareUl2;
    ULONG SpareUl3;
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
    ULONG PrivatePageCount;
} SYSTEM_PROCESS_INFORMATION_NT4, *PSYSTEM_PROCESS_INFORMATION_NT4;

#define SYSTEM_PROCESS_INFORMATION SYSTEM_PROCESS_INFORMATION_NT4
#define PSYSTEM_PROCESS_INFORMATION PSYSTEM_PROCESS_INFORMATION_NT4

#endif

#if NTONLY == 5
typedef struct _SYSTEM_PROCESS_INFORMATION_W2K {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG SpareUl3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION_W2K, *PSYSTEM_PROCESS_INFORMATION_W2K;

#define SYSTEM_PROCESS_INFORMATION SYSTEM_PROCESS_INFORMATION_W2K
#define PSYSTEM_PROCESS_INFORMATION PSYSTEM_PROCESS_INFORMATION_W2K

#endif

class Process: public Provider
{
public:

    // Constructor/destructor
    //=======================

    Process(LPCWSTR name, LPCWSTR pszNamespace) ;
   ~Process() ;

    // Funcitons provide properties with current values
    //=================================================

    HRESULT Process::ExecQuery (

        MethodContext* pMethodContext, 
        CFrameworkQuery &pQuery, 
        long lFlags 
    );

    HRESULT Process :: Enumerate (

	    MethodContext *pMethodContext, 
	    long lFlags /*= 0L*/,
        BOOL bKeysOnly
    );

	HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
	HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &pQuery);

	HRESULT ExecMethod (

		const CInstance &a_Instance, 
		const BSTR a_MethodName, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long a_Flags = 0L
	);

	HRESULT DeleteInstance (

		const CInstance& a_Instance, 
		long a_Flags = 0L
	) ;

    // Utility function(s)
    //====================

#ifdef NTONLY


    BOOL LoadCheapPropertiesNT (

		CNtDllApi &a_NtApi , 
		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		CInstance* pInstance
	) ;

#else

    BOOL RefreshProcessCacheWin95(CKernel32Api &ToolHelp, PROCESS_CACHE& PCache) ;
    BOOL LoadCheapPropertiesWin95(CKernel32Api &ToolHelp, DWORD dwProcIndex, PROCESS_CACHE& PCache, CInstance* pInstance, const std::deque<DWORD>& a_ThreadQ ) ;

#endif

#ifdef NTONLY

    static SYSTEM_PROCESS_INFORMATION *RefreshProcessCacheNT (

		CNtDllApi &a_NtApi , 
		MethodContext *pMethodContext ,
		HRESULT *a_phrRetVal = NULL
	) ;

	static SYSTEM_PROCESS_INFORMATION *GetProcessBlocks ( 

		CNtDllApi &a_NtApi
	) ;

	static SYSTEM_PROCESS_INFORMATION *NextProcessBlock ( 

		CNtDllApi &a_NtApi , 
		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock 
	) ;

	static SYSTEM_PROCESS_INFORMATION *GetProcessBlock ( 

		CNtDllApi &a_NtApi , 
		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		DWORD a_ProcessId
	) ;

	static BOOL GetProcessModuleBlock ( 

		CNtDllApi &a_NtApi , 
		HANDLE a_Process ,
		LIST_ENTRY *&a_LdrHead
	) ;

	static BOOL NextProcessModule ( 

		CNtDllApi &a_NtApi , 
		HANDLE a_Process , 
		LIST_ENTRY *&a_LdrHead , 
		LIST_ENTRY *&a_LdrNext , 
		CHString &a_ModuleName ,
        DWORD_PTR *a_pdwBaseAddress ,
        DWORD *a_pdwUsageCount
	) ;

	static BOOL GetProcessExecutable ( 

		CNtDllApi &a_NtApi , 
		HANDLE a_Process , 
		CHString &a_ExecutableName
	) ;

	static BOOL GetProcessParameters ( 

		CNtDllApi &a_NtApi ,
		HANDLE a_Process ,
		CHString &a_CommandLine
	) ;

#endif

private:
	// Converts kernel and user mode times to the required DMTF
	// representation
	CHString filetimeToUint64CHString(FILETIME inputTime);

	DWORD GetProcessErrorCode () ;
	HRESULT GetProcessResultCode () ;

	DWORD GetSidOrAccount (
		
		const CInstance &a_Instance ,
		CInstance *a_OutParams , 
		DWORD a_ProcesId , 
		BOOL a_Sid 
	) ;

	DWORD GetAccount ( 

		HANDLE a_TokenHandle , 
		CHString &a_Domain , 
		CHString &a_User 
	) ;

	DWORD GetSid ( 

		HANDLE a_TokenHandle , 
		CHString &a_Sid 
	) ;

	DWORD GetLogonSid ( 

		HANDLE a_TokenHandle , 
		PSID &a_Sid 
	) ;

	DWORD Creation ( 

		CInstance *a_OutParams ,
		HANDLE a_TokenHandle ,
		CHString a_CmdLine , 
		BOOL a_WorkingDirectorySpecified ,
		CHString a_WorkingDirectory ,
		TCHAR *a_EnvironmentBlock ,
		BOOL a_ErrorModeSpecified ,
		DWORD a_ErrorMode ,
		DWORD a_CreationFlags ,
		BOOL a_StartupSpecified ,
		STARTUPINFO a_StartupInformation
	) ;

	DWORD ProcessCreation ( 

		CInstance *a_OutParams ,
		CHString a_CmdLine , 
		BOOL a_WorkingDirectorySpecified ,
		CHString a_WorkingDirectory ,
		TCHAR *&a_EnvironmentBlock ,
		BOOL a_ErrorModeSpecified ,
		DWORD a_ErrorMode ,
		DWORD a_CreationFlags ,
		BOOL a_StartupSpecified ,
		STARTUPINFO a_StartupInformation
	) ;

	HRESULT CheckProcessCreation ( 

		CInstance *a_InParams ,
		CInstance *a_OutParams ,
		DWORD &a_Status 
	) ;

	DWORD GetImpersonationStatus ( 

		HANDLE a_TokenHandle , 
		SECURITY_IMPERSONATION_LEVEL &a_Level , 
		TOKEN_TYPE &a_TokenType 
	) ;

	DWORD EnableDebug ( HANDLE &a_DebugToken ) ;

	HRESULT ExecCreate (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

	HRESULT ExecTerminate (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

	HRESULT ExecGetOwner (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

	HRESULT ExecGetOwnerSid (

		const CInstance& a_Instance, 
		CInstance *a_InParams, 
		CInstance *a_OutParams, 
		long lFlags 
	) ;

    HRESULT ExecSetPriority(
	    const CInstance& a_Instance,
	    CInstance *cinstInParams,
	    CInstance *cinstOutParams,
	    long lFlags);

    HRESULT ExecAttachDebugger(
	    const CInstance& a_Instance,
	    CInstance *cinstInParams,
	    CInstance *cinstOutParams,
	    long lFlags);

#ifdef NTONLY
    void GetDebuggerString(
        CHString& chstrDbgStr);
#endif

#ifdef NTONLY
    bool SetStatusObject(
        MethodContext* pContext, 
        const WCHAR* wstrMsg);
#endif
	
	DWORD GetEnvBlock( 
		
		const CHString &rchsSid, 
		const CHString &rchsUserName, 
		const CHString &rchsDomainName , 
		TCHAR* &rszEnvironBlock 
	) ;
	
	DWORD GetEnvironmentVariables(

		HKEY hKey,
		const CHString& chsSubKey,	
		CHStringArray &aEnvironmentVars,
		CHStringArray &aEnvironmentVarsValues 
		) ;
	
friend class CWin32ProcessDLL;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dependentservice.cpp ===
//=================================================================

//

// DependentService.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <cregcls.h>
#include <FrQueryEx.h>
#include <map>
#include "dependentservice.h"
#include <dllutils.h>

// The Map we will use below is an STL Template, so make sure we have the std namespace
// available to us.

using namespace std;

// Property set declaration
//=========================

CWin32DependentService win32DependentService( PROPSET_NAME_DEPENDENTSERVICE, IDS_CimWin32Namespace );

//////////////////////////////////////////////////////////////////////////////
//
//  dependentservice.cpp - Class implementation of CWin32DependentService.
//
//  This class is intended to locate Win32 System Services that are dependent
//  on other services to run.  It does this by checking the registry key for
//  the service and querying the "DependOnService" value, which will return
//  the names of the services that the service is dependent on.
//
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DependentService::CWin32DependentService
 *
 *  DESCRIPTION : Constructor
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DependentService::CWin32DependentService( const CHString& strName, LPCWSTR pszNamespace /*=NULL*/ )
:   Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DependentService::~CWin32DependentService
 *
 *  DESCRIPTION : Destructor
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DependentService::~CWin32DependentService()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32DependentService::ExecQuery
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32DependentService::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
#ifdef NTONLY
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    CHStringArray csaDependents, csaAntecedents;
    pQuery.GetValuesForProp(IDS_Dependent, csaDependents);

    DWORD dwDependents = csaDependents.GetSize();
    DWORD dwAntecedents = 0;

    // If we can resolve the query using dependents, that's our best bet.
    if (dwDependents == 0)
    {
        // If not, perhaps we can produce a list of antecedents
        pQuery.GetValuesForProp(IDS_Antecedent, csaAntecedents);
        dwAntecedents = csaAntecedents.GetSize();
    }

    // If we can't find either, perhaps this is a 3TokenOr.  This
    // would happen if someone did an associators or references of a Win32_Service
    if ( (dwDependents == 0) && (dwAntecedents == 0) )
    {
        VARIANT vValue1, vValue2;
        VariantInit(&vValue1);
        VariantInit(&vValue2);

        CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);

        if (pQuery2->Is3TokenOR(IDS_Dependent, IDS_Antecedent, vValue1, vValue2))
        {
            try
            {
                dwDependents = 1;
                dwAntecedents = 1;

                csaAntecedents.Add(vValue1.bstrVal);
                csaDependents.Add(vValue1.bstrVal);
            }
            catch ( ... )
            {
                VariantClear(&vValue1);
                VariantClear(&vValue2);
                throw;
            }

            VariantClear(&vValue1);
            VariantClear(&vValue2);
        }
        else
        {
            // Don't know what they're asking for, but we can't help them with it
            hr = WBEM_E_PROVIDER_NOT_CAPABLE;
        }
    }

    // Did we find anything to do
    if ( (dwDependents > 0) || (dwAntecedents > 0) )
    {
        TRefPointerCollection<CInstance>    serviceList;
        map<CHString, CHString>             servicetopathmap;

        // First we need to get a list of all the Win32 services
        if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select __path, name from Win32_BaseService", &serviceList, pMethodContext, GetNamespace())))
        {
            // Next, build a map of the services and their associated paths.  This subjects us
            // to the overhead of walking the list once to get the values, but from that point
            // forwards, we basically will have VERY fast access to service object paths via
            // our CHString2CHString map.

            InitServiceToPathMap( serviceList, servicetopathmap );

            LPBYTE pByteArray = NULL;
            DWORD       dwByteArraySize =   0;

            try
            {
                if (dwDependents > 0)
                {
                    map<CHString, CHString>::iterator   servicemapiter;

                    for (DWORD x = 0; x < dwDependents; x++)
                    {
                        ParsedObjectPath    *pParsedPath = NULL;
                        CObjectPathParser    objpathParser;

                        int nStatus = objpathParser.Parse( csaDependents[x],  &pParsedPath );

                        if ( ( 0 == nStatus ) && ( pParsedPath->m_dwNumKeys == 1) )
                        {
                            try
                            {
                                CHString sName(V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue));

                                sName.MakeUpper();

                                if( ( servicemapiter = servicetopathmap.find( sName ) ) != servicetopathmap.end() )
                                {
                                    hr = CreateServiceDependenciesNT( 
                
                                        (*servicemapiter).first, 
                                        (*servicemapiter).second, 
                                        pMethodContext, 
                                        servicetopathmap, 
                                        pByteArray, 
                                        dwByteArraySize 
                                    );
                                }
                            }
                            catch ( ... )
                            {
                                objpathParser.Free( pParsedPath );
                                throw;
                            }

                            objpathParser.Free( pParsedPath );
                        }
                    }
                }

                if (dwAntecedents > 0)
                {
                    hr = CreateServiceAntecedentsNT( 

                        pMethodContext, 
                        servicetopathmap,
                        csaAntecedents,
                        pByteArray, 
                        dwByteArraySize 
                    );
                }
            }
            catch ( ... )
            {
                if (pByteArray != NULL)
                {
                    delete pByteArray;
                    pByteArray = NULL;
                }
                throw;
            }

            if (pByteArray != NULL)
            {
                delete pByteArray;
                pByteArray = NULL;
            }
        }
    }

#endif
    return hr;

}
////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32DependentService::GetObject
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32DependentService::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
    // Find the instance depending on platform id.
#ifdef NTONLY
        return RefreshInstanceNT(pInstance);
#endif
#ifdef WIN9XONLY
        return WBEM_E_NOT_FOUND;
#endif
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32DependentService::EnumerateInstances
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32DependentService::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
    BOOL        fReturn     =   FALSE;
    HRESULT     hr          =   WBEM_S_NO_ERROR;

    // Get the proper OS dependent instance

#ifdef NTONLY
        hr = AddDynamicInstancesNT( pMethodContext );
#endif
#ifdef WIN9XONLY
        hr = WBEM_S_NO_ERROR;
#endif

    return hr;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::AddDynamicInstancesNT
//
//  DESCRIPTION :   Enumerates existing services to get information to
//                  dynamically build a list of associations.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32DependentService::AddDynamicInstancesNT( MethodContext* pMethodContext )
{
    HRESULT     hr              =   WBEM_S_NO_ERROR;

    // Collection, Map and iterator
    TRefPointerCollection<CInstance>    serviceList;
    map<CHString, CHString>             servicetopathmap;

    LPBYTE      pByteArray      =   NULL;
    DWORD       dwByteArraySize =   0;

    try
    {
        // First we need to get a list of all the Win32 services

    //  if (SUCCEEDED(hr = CWbemProviderGlue::GetAllDerivedInstances(_T("Win32_BaseService"), &serviceList, pMethodContext, IDS_CimWin32Namespace)))
        if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(_T("select __path, name from Win32_BaseService"), &serviceList, pMethodContext, GetNamespace())))
        {
            // Next, build a map of the services and their associated paths.  This subjects us
            // to the overhead of walking the list once to get the values, but from that point
            // forwards, we basically will have VERY fast access to service object paths via
            // our CHString2CHString map.

            InitServiceToPathMap( serviceList, servicetopathmap );

            REFPTRCOLLECTION_POSITION   pos;

            if ( serviceList.BeginEnum( pos ) )
            {
                CInstancePtr                pService;
                map<CHString, CHString>::iterator   servicemapiter;
                CHString sName, sPath;

                for (pService.Attach(serviceList.GetNext( pos ));
                     SUCCEEDED(hr) && (pService) != NULL;
                     pService.Attach(serviceList.GetNext( pos )))
                {
                     pService->GetCHString(IDS_Name, sName);
                     pService->GetCHString(IDS___Path, sPath);

                    hr = CreateServiceDependenciesNT( 

                                sName, 
                                sPath, 
                                pMethodContext, 
                                servicetopathmap, 
                                pByteArray, 
                                dwByteArraySize 
                            );
                }   // for all Services

                serviceList.EndEnum();

            }   // IF BeginEnum

        }   // IF GetAllDerivedInstances
    }
    catch ( ... )
    {
        if ( NULL != pByteArray )
        {
            delete [] pByteArray;
            pByteArray = NULL;
        }

        throw;
    }

    // Clean up the byte array we were using.

    if ( NULL != pByteArray )
    {
        delete [] pByteArray;
        pByteArray = NULL;
    }

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::InitServiceToPathMap
//
//  DESCRIPTION :   Enumerates a service list, creating associations between
//                  service names and their WBEM paths.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
void CWin32DependentService::InitServiceToPathMap(
TRefPointerCollection<CInstance>&   serviceList,
map<CHString,CHString>&         servicetopathmap
)
{
    CHString    strServiceName,
                strServicePathName;

    REFPTRCOLLECTION_POSITION   pos;

    if ( serviceList.BeginEnum( pos ) )
    {
        CInstancePtr                pService;

        for ( pService.Attach(serviceList.GetNext( pos )) ;
              pService != NULL;
              pService.Attach(serviceList.GetNext( pos )))
        {
            if (    pService->GetCHString( IDS_Name, strServiceName )
                &&  GetLocalInstancePath( pService, strServicePathName ) )
            {
                // The service name must be case insensitive
                strServiceName.MakeUpper();

                servicetopathmap[strServiceName] = strServicePathName;
            }
        }

        serviceList.EndEnum();
    }

}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::CreateServiceDependenciesNT
//
//  DESCRIPTION :   Given a service name, looks in the registry for a
//                  dependency list and if found, creates associations
//                  for all entries in the list.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32DependentService::CreateServiceDependenciesNT(

LPCWSTR pwszServiceName,
LPCWSTR pwszServicePath,
MethodContext*          pMethodContext,
map<CHString,CHString>& servicetopathmap,
LPBYTE&                 pByteArray,
DWORD&                  dwArraySize
)
{
    HRESULT     hr          =   WBEM_S_NO_ERROR;

    map<CHString, CHString>::iterator   servicemapiter;

    // If we get a value from the registry, then we have some dependencies that we
    // will have to deal with (probably via a 12-step program or some such thing.
    // Remember, addiction is no laughing matter.  Giggling maybe, but definitely
    // not laughing).

    if ( QueryNTServiceRegKeyValue( pwszServiceName, SERVICE_DEPENDSONSVC_NAME, pByteArray, dwArraySize ) )
    {
        CHString    strAntecedentServiceName;

        LPWSTR  pwcTempSvcName = (LPWSTR) pByteArray;
        CInstancePtr pInstance;

        // Create dependencies for each service name we encounter.

        while (     L'\0' != *pwcTempSvcName
                &&  SUCCEEDED(hr) )
        {

            // Convert to upper case for Case Insensitivity.
            strAntecedentServiceName = pwcTempSvcName;
            strAntecedentServiceName.MakeUpper();

            // See if the service name exists in our map

            if( ( servicemapiter = servicetopathmap.find( strAntecedentServiceName ) ) != servicetopathmap.end() )
            {
                pInstance.Attach(CreateNewInstance( pMethodContext ));

                pInstance->SetCHString( IDS_Dependent, pwszServicePath );
                pInstance->SetCHString( IDS_Antecedent, (*servicemapiter).second );

                hr = pInstance->Commit(  );

            }

            // Jump to one char past the string NULL terminator, since
            // the actual array is terminated by a Double NULL.

            pwcTempSvcName += ( lstrlenW( pwcTempSvcName ) + 1 );

        }   // WHILE NULL !- *pszTempSvcName

    }   // IF QueryNTServiceRegKeyValue

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::RefreshInstanceNT
//
//  DESCRIPTION :   Loads the paths of the association data, then obtains
//                  the service names and looks in the registry to verify
//                  that the dependency still exists.
//
//  COMMENTS    :   None.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32DependentService::RefreshInstanceNT( CInstance* pInstance )
{
    CHString        strDependentSvcPath,
                    strAntecedentSvcPath,
                    strDependentSvcName,
                    strAntecedentSvcName,
                    strTemp;
    LPBYTE      pByteArray = NULL;
    DWORD           dwByteArraySize = 0;
    CInstancePtr    pDependentSvc;
    CInstancePtr    pAntecedentSvc;
    HRESULT     hr;

    // Dependent and Antecedent values are actually object path names
    pInstance->GetCHString( IDS_Dependent, strDependentSvcPath );
    pInstance->GetCHString( IDS_Antecedent, strAntecedentSvcPath );

    // Get the Antecedent and dependent services, then check if the relationship
    // still exists

    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(strDependentSvcPath,
        &pDependentSvc, pInstance->GetMethodContext())) &&
        SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(strAntecedentSvcPath,
        &pAntecedentSvc, pInstance->GetMethodContext())))
    {
        hr = WBEM_E_NOT_FOUND;

        if (    pDependentSvc->GetCHString( IDS_Name, strDependentSvcName )
            &&  pAntecedentSvc->GetCHString( IDS_Name, strAntecedentSvcName ) )
        {

            // If we get a value from the registry, then we have some dependencies we can
            // search for a match against the antecedent service name.

            if ( QueryNTServiceRegKeyValue( strDependentSvcName, SERVICE_DEPENDSONSVC_NAME, pByteArray, dwByteArraySize ) )
            {
                try
                {
                    LPWSTR  pwcTempSvcName  =   (LPWSTR) pByteArray;

                    // Create dependencies for each service name we encounter.

                    while (FAILED(hr) && L'\0' != *pwcTempSvcName)
                    {
                        strTemp = pwcTempSvcName;

                        // If we have a match, we should reset the Dependent and Antecedent paths,
                        // and return TRUE.  We are done, though, at that point since we have
                        // effectively established that the relationship exists.

                        if ( strAntecedentSvcName.CompareNoCase( strTemp ) == 0 )
                        {
                            pInstance->SetCHString( IDS_Antecedent, strAntecedentSvcPath );
                            pInstance->SetCHString( IDS_Dependent, strDependentSvcPath );
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                        {
                            // Jump to one char past the string NULL terminator, since
                            // the actual array is terminated by a Double NULL.
                            pwcTempSvcName += ( lstrlenW( pwcTempSvcName ) + 1 );
                        }

                    }   // WHILE !fReturn && NULL != *pszTempSvcName
                }
                catch ( ... )
                {
                    delete [] pByteArray;
                    throw ;
                }

                delete [] pByteArray;

            }   // IF QueryNTServiceRegKeyValue

        }   // IF got both service names

    }   // IF got service

    return hr;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::QueryNTServiceRegKeyValue
//
//  DESCRIPTION :   Loads data from the registry and places the data in a
//                  supplied buffer.  The buffer will be grown if necessary.
//
//  COMMENTS    :   The byte array will be reallocated if necessary.  It is up to
//                  the calling function to delete the array when it is done.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CWin32DependentService::QueryNTServiceRegKeyValue( LPCTSTR pszServiceName, LPCWSTR pwcValueName, LPBYTE& pByteArray, DWORD& dwArraySize )
{
    BOOL        fReturn             =   FALSE;
    DWORD       dwSizeDataReturned  =   0;
    CRegistry   reg;
    CHString    strDependentServiceRegKey;

    // Build the key name for the service, then open the registry
    strDependentServiceRegKey.Format( SERVICE_REG_KEY_FMAT, pszServiceName );

    if ( ERROR_SUCCESS == reg.Open( HKEY_LOCAL_MACHINE, strDependentServiceRegKey, KEY_READ ) )
    {

        // Query the value to see how big our array needs to be.

        if ( ERROR_SUCCESS == RegQueryValueExW( reg.GethKey(),
                                                pwcValueName,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &dwSizeDataReturned ) )
        {

            // Make sure our Byte array buffer is big enough to handle this

            if ( ReallocByteArray( pByteArray, dwArraySize, dwSizeDataReturned ) )
            {

                // Now we REALLY query the value.

                if ( ERROR_SUCCESS == RegQueryValueExW( reg.GethKey(),
                                                        pwcValueName,
                                                        NULL,
                                                        NULL,
                                                        pByteArray,
                                                        &dwSizeDataReturned ) )
                {
                    fReturn = TRUE;
                }   // IF RegQueryValueEx

            }   // IF Realloc Array

        }   // IF RegQueryValueEx

        reg.Close();

    }   // IF Open Reg Key

    return fReturn;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::ReallocByteArray
//
//  DESCRIPTION :   Ensures that the supplied array size is >= the required
//                  size.  If it is smaller, it is deleted and a new array
//                  returned.
//
//  COMMENTS    :   The byte array will only be reallocated if necessary.  It
//                  is up to the calling function to delete the array when it
//                  is done.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CWin32DependentService::ReallocByteArray( LPBYTE& pByteArray, DWORD& dwArraySize, DWORD dwSizeRequired )
{
    BOOL    fReturn = FALSE;

    // Check if we need to realloc the array.  If not, we can
    // go ahead and return TRUE

    if ( dwSizeRequired > dwArraySize )
    {

        LPBYTE  pbArray =   new BYTE[dwSizeRequired];

        if ( NULL != pbArray )
        {

            // Free the old array before storing the new value
            if ( NULL != pByteArray )
            {
                delete [] pByteArray;
            }

            pByteArray = pbArray;
            dwArraySize = dwSizeRequired;
            fReturn = TRUE;

        }   // If NULL != pbArray
        else
        {
            if ( NULL != pByteArray )
            {
                delete [] pByteArray;
            }

            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }   // If array not big enough
    else
    {
        fReturn = TRUE;
    }

    return fReturn;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   CWin32DependentService::CreateServiceAntecedentsNT
//
//  DESCRIPTION :   Given an array of service names, looks in the registry for
//                  services that have that dependency.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CWin32DependentService::CreateServiceAntecedentsNT(

    MethodContext*          pMethodContext,
    map<CHString, CHString> &servicetopathmap,
    CHStringArray           &csaAntecedents,
    LPBYTE&                 pByteArray,
    DWORD&                  dwArraySize
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // First, parse out the service names from the object paths
    for (DWORD x=0; x < csaAntecedents.GetSize(); x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( csaAntecedents[x],  &pParsedPath );

        if ( ( 0 == nStatus ) && ( pParsedPath->m_dwNumKeys == 1) )
        {
            try
            {
                csaAntecedents[x] = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);

                csaAntecedents[x].MakeUpper();
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );
        }
    }

    map<CHString, CHString>::iterator   servicemapiter, servicemapfind;

    // Now, walk each service, and see if any of its dependencies are in csaAntecedents
    servicemapiter = servicetopathmap.begin();

    CHString    strAntecedentServiceName;

    CInstancePtr pInstance;

    while ( servicemapiter != servicetopathmap.end() && SUCCEEDED(hr) )
    {
        // Get the dependencies
        if ( QueryNTServiceRegKeyValue( (*servicemapiter).first, SERVICE_DEPENDSONSVC_NAME, pByteArray, dwArraySize ) )
        {

            LPWSTR  pwcTempSvcName = (LPWSTR) pByteArray;

            // Walk the dependencies
            while (     L'\0' != *pwcTempSvcName
                    &&  SUCCEEDED(hr) )
            {
                // Convert to upper case for Case Insensitivity.
                strAntecedentServiceName = pwcTempSvcName;
                strAntecedentServiceName.MakeUpper();

                // See if the service name exists in our list
                if (IsInList(csaAntecedents, strAntecedentServiceName) != -1)
                {
                    pInstance.Attach(CreateNewInstance( pMethodContext ));

                    if( ( servicemapfind = servicetopathmap.find( strAntecedentServiceName ) ) != servicetopathmap.end() )
                    {
                        pInstance->SetCHString( IDS_Antecedent, (*servicemapfind).second );
                        pInstance->SetCHString( IDS_Dependent, (*servicemapiter).second );

                        hr = pInstance->Commit(  );
                    }
                }

                // Jump to one char past the string NULL terminator, since
                // the actual array is terminated by a Double NULL.

                pwcTempSvcName += ( lstrlenW( pwcTempSvcName ) + 1 );

            }   // WHILE NULL !- *pszTempSvcName

        }   // IF QueryNTServiceRegKeyValue

        servicemapiter++;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : IsInList
 *
 *  DESCRIPTION : Checks to see if a specified element is in the list
 *
 *  INPUTS      : Array to scan, and element
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : -1 if not in list, else zero based element number
 *
 *  COMMENTS    : This routine does a CASE SENSITIVE compare
 *
 *****************************************************************************/
DWORD CWin32DependentService::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE SENSITIVE compare
        if (wcscmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\cpuid.cpp ===
//=================================================================

//

// CPUID.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "smbios.h"
#include "smbstruc.h"
#include <cregcls.h>
#include "cpuid.h"
#include "resource.h"

DWORD CPURawSpeed();
DWORD GetFixedCPUSpeed();
DWORD GetTimeCounterCPUSpeed();

#ifdef _X86_

#define CPU_ID _asm _emit 0x0F _asm _emit 0xA2
#define RDTSC  _asm _emit 0x0F _asm _emit 0x31

BOOL CanDoCPUID(void);
void DoCPUID(DWORD dwLevel, DWORD *pdwEAX, DWORD *pdwEBX,
        DWORD *pdwECX, DWORD *pdwEDX);
BOOL GetVendor(LPWSTR szVendor);
void GetCPUInfo(DWORD *pdwFamily, DWORD *pdwSignature, DWORD *pdwFeatures,
        DWORD *pdwFeaturesEx, SYSTEM_INFO *pInfo);
void GetCPUDescription(LPWSTR szDescrip, DWORD dwSize);
DWORD CPURawSpeedHelper(DWORD dwFamily, DWORD dwFeatures);

// This is the one to call to get the CPU speed.
DWORD GetFixedCPUSpeed();

DWORD ProcessorCount();

DWORD GetBSFCPUSpeed(DWORD cycles);
BOOL HasCoprocessor();

static DWORD diffTime64(DWORD t1Hi, DWORD t1Low,
                                                 DWORD t2Hi, DWORD t2Low,
                                                 DWORD *tHi, DWORD *tLow );

BOOL CanDoCPUID()
{
        BOOL bRet;

        _asm
        {
                pushfd                                  ; push original EFLAGS
                pop             eax                             ; get original EFLAGS
                mov             ecx, eax                ; save original EFLAGS
                xor             eax, 200000h    ; flip ID bit in EFLAGS
                push    eax                         ; save new EFLAGS value on stack
                popfd                                   ; replace current EFLAGS value
                pushfd                                  ; get new EFLAGS
                pop             eax                             ; store new EFLAGS in EAX
                xor             eax, ecx                ; cant toggle ID bit,

                je              no_cpuid                ; can't do CPUID

                mov             bRet, 1
                jmp             done_cpuid

no_cpuid:
                mov             bRet, 0

done_cpuid:
        }

        return bRet;
}

void DoCPUID(DWORD dwLevel, DWORD *pdwEAX, DWORD *pdwEBX,
        DWORD *pdwECX, DWORD *pdwEDX)
{
        _asm
        {
                push    esi
                push    eax
                push    ebx
                push    ecx
                push    edx

                mov             eax, dwLevel
                CPU_ID

                mov             esi, dword ptr pdwEAX
                mov             dword ptr [esi], eax

                mov             esi, dword ptr pdwEBX
                mov             dword ptr [esi], ebx

                mov             esi, dword ptr pdwECX
                mov             dword ptr [esi], ecx

                mov             esi, dword ptr pdwEDX
                mov             dword ptr [esi], edx

                pop             edx
                pop             ecx
                pop             ebx
                pop             eax
                pop             esi
        }
}
#endif // _X86_

BOOL GetVendor(LPWSTR szVendor)
{
#ifdef _X86_
        if (CanDoCPUID())
        {
                DWORD   dwEAX;
        char    szTemp[100];
                DWORD   *pVendor = (DWORD *) szTemp;

                DoCPUID(0, &dwEAX, &pVendor[0], &pVendor[2], &pVendor[1]);
                szTemp[12] = '\0';

        mbstowcs(szVendor, szTemp, strlen(szTemp) + 1);

                return TRUE;
        }
#endif // _X86_

    CRegistry reg;
    CHString  strVendor;
    BOOL      bRet =
                        reg.OpenLocalMachineKeyAndReadValue(
                                L"HARDWARE\\Description\\System\\CentralProcessor\\0",
                                L"VendorIdentifier",
                                strVendor) == ERROR_SUCCESS;

    if (bRet)
        wcscpy(szVendor, strVendor);

    return bRet;
}

BOOL ReadRegistryForName(DWORD a_dwProcessor, CHString &a_strName, CHString &a_strIdentifier)
{
        // For non-CPUID processors, try to get it from the registry.
    WCHAR     szKey[100];
    CRegistry reg;

    swprintf(
        szKey,
        L"HARDWARE\\Description\\System\\CentralProcessor\\%d",
        a_dwProcessor);

    BOOL bRet =
                reg.OpenLocalMachineKeyAndReadValue(
                        szKey,
                        L"ProcessorNameString",
                        a_strName) == ERROR_SUCCESS;

    bRet = bRet &&
                    reg.OpenLocalMachineKeyAndReadValue(
                            szKey,
                            L"Identifier",
                            a_strIdentifier) == ERROR_SUCCESS;
        return bRet;
}

BOOL GetCPUIDName(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
#ifdef _X86_
        if (CanDoCPUID())
        {
                DWORD   dwLevels,
                dwTemp;
        char    szTemp[100];
                DWORD   *pName = (DWORD *) szTemp;

                // Clear out the temp var.
        memset(szTemp, 0, sizeof(szTemp));

        // Get the number of extended levels supported.
        DoCPUID(0x80000000, &dwLevels, &dwTemp, &dwTemp, &dwTemp);

                // Does this CPU support more than one level? (AMD and Cyrix only,
        // Intel doesn't.)
        if (dwLevels > 0x80000000)
        {
            // Convert back to 0-based.
            dwLevels -= 0x80000002;

            // 4 is the last one for getting the CPU name.
            if (dwLevels > 3)
                dwLevels = 3;

            for (int i = 0; i < (int) dwLevels; i++)
            {
                DoCPUID(
                    0x80000002 + i,
                    &pName[0],
                    &pName[1],
                    &pName[2],
                    &pName[3]);

                // Just got 4 DWORDs worth, so skip to the next 4.
                pName += 4;
            }

            mbstowcs(pInfo->szCPUIDProcessorName, szTemp, strlen(szTemp) + 1);
        }
        else
        {
            CHString    strName;
                DWORD       dwFamily = pInfo->wProcessorLevel,
                                    dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
                                    dwStepping = pInfo->dwProcessorSignature & 0xF;

            FormatMessageW(strName,
                IDR_x86FamilyModelStepping,
                dwFamily,
                dwModel,
                dwStepping);

            wcscpy(pInfo->szCPUIDProcessorName, strName);
        }

                return TRUE;
        }
    else
#endif // ifdef _X86_
    {
            // For non-CPUID processors, try to get it from the registry.
                CHString sName;
                CHString sID;
                ReadRegistryForName(dwProcessor, sName, sID);
                BOOL bRet = TRUE;

        if (sName.GetLength())
                {
            wcscpy(pInfo->szCPUIDProcessorName, sName);
                }
                else if (sID.GetLength())
                {
            wcscpy(pInfo->szCPUIDProcessorName, sID);
                }
                else
                {
                        bRet = FALSE;
                }

        return bRet;
    }
}

#ifdef _X86_
void GetCPUInfo(DWORD *pdwFamily, DWORD *pdwSignature, DWORD *pdwFeatures,
        DWORD *pdwFeaturesEx, SYSTEM_INFO *pInfo)
{
        if (pInfo)
                GetSystemInfo(pInfo);

        if (CanDoCPUID())
        {
                DWORD dwNichts;

                DoCPUID(1, pdwSignature, &dwNichts, &dwNichts, pdwFeatures);

                *pdwFamily = (*pdwSignature >> 8) & 0xF;

                if (pdwFeaturesEx)
                {
                        DWORD   eax,
                                        ebx,
                                        ecx,
                                        edx;

                        DoCPUID(0x80000000, &eax, &ebx, &ecx, &edx);
                        if (!eax)
                                *pdwFeaturesEx = 0;
                        else
                                DoCPUID(0x80000001, &eax, &ebx, &ecx, pdwFeaturesEx);
                }
        }
        else // Can't do CPUID, so fake it.
        {
                // Assume no cool features if we can't do CPUID.
                *pdwFeatures = 0;

                if (pdwFeaturesEx)
                        *pdwFeaturesEx = 0;

                // Can't do CPUID, so do some assembly.
                _asm
                {
                        push            esi
                        mov             esi, dword ptr [pdwFamily]

;check_80386:
                        pushfd                                                          ; push original EFLAGS
                        pop             eax                                             ; get original EFLAGS
                        mov             ecx, eax                                        ; save original EFLAGS
                        xor             eax, 40000h                             ; flip AC bit in EFLAGS
                        push            eax                                             ; save new EFLAGS value on stack
                        popfd                                                                   ;replace current EFLAGS value
                        pushfd                                                          ; get new EFLAGS
                        pop             eax                                             ; store new EFLAGS in EAX
                        xor             eax, ecx                                        ; cant toggle AC bit, processor=80386
                        mov             dword ptr [esi], 3      ; turn on 80386 processor flag
                        jz                      end_cpu_type                    ; jump if 80386 processor
                        push            ecx
                        popfd                                                                   ; restore AC bit in EFLAGS first

                        mov             dword ptr [esi], 4      ; at least a 486.

end_cpu_type:
                        pop             esi
                }

                if (*pdwFamily == 4)
                {
                        // Can't use GetFixedCPUSpeed because it calls GetCPUInfo.
                        DWORD dwSpeed = CPURawSpeedHelper(*pdwFamily, 0);

                        if (!HasCoprocessor())
                                // Either SX or SX2
                                *pdwSignature = dwSpeed <= 33 ? 0x0440 : 0x0450;
                        else
                                // Either DX or DX2
                                *pdwSignature = dwSpeed <= 33 ? 0x0410 : 0x0430;
                }
                else
                        *pdwSignature = 0x0300;
        }

        // Fill out the rest of SYSTEM_INFO since Win95 can't.
#ifdef WIN9XONLY
        if (pInfo)
        {
                pInfo->wProcessorLevel = (WORD) *pdwFamily;
                pInfo->wProcessorRevision =
                        (WORD) (((*pdwSignature & 0xF0) << 4) | (*pdwSignature & 0x0F));
        }
#endif
}

// Uses L2 cache size and SMBIOS to try to figure out if the machine is a Xeon.
BOOL IsXeon(SYSTEM_INFO_EX *pInfo)
{
    // Try to find if we're a Xeon by using the cache size.
    // If it's 512 (we'll also say or if lower, because of the PII PE
        // for portables and Coppermine) it's either a Xeon or PII (or PIII), but
        // if SMBIOS doesn't tell us, there's no way to know for sure which one.
    // If the L2 is greater than 512 we know for sure it's a Xeon.
    return pInfo->dwProcessorL2CacheSize > 512 ||
        pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_SLOT2;
}

// This is for 486/Pentium class machines where the L2 is running at the same
// speed as the system clock.
void SetL2SpeedViaExternalClock(SYSTEM_INFO_EX *pInfo)
{
    // Make sure we have a valid cache size and external clock speed.
    if (pInfo->dwProcessorL2CacheSize != 0 && pInfo->dwProcessorL2CacheSize !=
        (DWORD) -1 && pInfo->dwExternalClock != 0)
    {
        pInfo->dwProcessorL2CacheSpeed = pInfo->dwExternalClock;
    }
}

// Assumes processor can do CPUID
void GetIntelSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
        DWORD   dwFamily = pInfo->wProcessorLevel,
                        dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
                        dwStepping = pInfo->dwProcessorSignature & 0xF;

        BOOL bCanDo = CanDoCPUID();

        // Get the cache info
        if (bCanDo)
        {
        DWORD   dwInfo[4] = {0, 0, 0, 0};
                BYTE    *pcVal = (BYTE *) dwInfo,
                                *pcEnd = pcVal + sizeof(dwInfo);

                DoCPUID(2, &dwInfo[0], &dwInfo[1], &dwInfo[2], &dwInfo[3]);
                for (; pcVal < pcEnd; pcVal++)
                {
                        if (*pcVal == 0x40)
                                pInfo->dwProcessorL2CacheSize = 0;
                        else if (*pcVal == 0x41)
                                pInfo->dwProcessorL2CacheSize = 128;
                        else if (*pcVal == 0x42)
                                pInfo->dwProcessorL2CacheSize = 256;
                        else if (*pcVal == 0x43)
                                pInfo->dwProcessorL2CacheSize = 512;
                        else if (*pcVal == 0x44)
                                pInfo->dwProcessorL2CacheSize = 1024;
                        else if (*pcVal == 0x45)
                                pInfo->dwProcessorL2CacheSize = 2048;
                        else if (*pcVal == 0x7A)
                        {
                                //pentium 4 cache, full speed
                                pInfo->dwProcessorL2CacheSize = 256;
                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                        }
                        else if (*pcVal == 0x82)
                        {
                                pInfo->dwProcessorL2CacheSize = 256;
                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                        }
                        else if (*pcVal == 0x84)
                        {
                                pInfo->dwProcessorL2CacheSize = 1024;
                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                        }
                        else if (*pcVal == 0x85)
                        {
                                pInfo->dwProcessorL2CacheSize = 2048;
                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                        }
                }
        }

        CHString    strFormat;
    DWORD       dwID;

    Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

    wcscpy(pInfo->szProcessorVersion, strFormat);

        swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

        switch(dwFamily)
        {
                case 4:
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_486;

            // L2 speed == external clock.
            SetL2SpeedViaExternalClock(pInfo);

            // Set this since no 486 will have SMBIOS.
            pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_ZIFF;

                        switch(dwModel)
                        {
                                case 0:
                                case 1:
                                        dwID = IDR_Intel486DX;
                    //wcscpy(pInfo->szProcessorName, _T("Intel486 DX processor"));
                                        break;

                                case 2:
                                        dwID = IDR_Intel486SX;
                                        //wcscpy(pInfo->szProcessorName, _T("Intel486 SX processor"));
                                        break;

                                case 3:
                                        dwID = IDR_Intel486DX2;
                                        //wcscpy(pInfo->szProcessorName, _T("IntelDX2 processor"));
                                        break;

                                case 4:
                                        dwID = IDR_Intel486SL;
                                        //wcscpy(pInfo->szProcessorName, _T("Intel486 SL processor"));
                                        break;

                                case 5:
                                        dwID = IDR_Intel486SX2;
                                        //wcscpy(pInfo->szProcessorName, _T("IntelSX2 processor"));
                                        break;

                                case 7:
                                        dwID = IDR_Intel486SX2WriteBack;
                                        //wcscpy(pInfo->szProcessorName, _T("Write-Back Enhanced IntelDX2 processor"));
                                        break;

                                case 8:
                                        dwID = IDR_Intel486DX4;
                                        //wcscpy(pInfo->szProcessorName, _T("IntelDX4 processor"));
                                        break;

                                default:
                                        //wcscpy(pInfo->szProcessorName, _T("Intel486 processor"));
                    dwID = IDR_Intel486;
                        }

                        break;

                case 5:
        {
            // L2 speed == external clock.
            SetL2SpeedViaExternalClock(pInfo);

                        if (pInfo->dwProcessorFeatures & MMX_FLAG)
            {
                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PMMX;
                dwID = IDR_IntelPentiumMMX;
                        //wcscpy(pInfo->szProcessorName, _T("Intel Pentium MMX processor"));
            }
            else
            {
                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PENTIUM;
                dwID = IDR_IntelPentium;
                        //wcscpy(pInfo->szProcessorName, _T("Intel Pentium processor"));
            }

                        break;
        }

                case 6:
                        if (dwModel < 3)
                        {
                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PPRO;

                // If the value is unknown set it as a ZIFF (Socket 8).
                if (pInfo->wWBEMProcessorUpgradeMethod ==
                    WBEM_CPU_UPGRADE_UNKNOWN)
                    pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_ZIFF;

                dwID = IDR_IntelPentiumPro;
                                //wcscpy(pInfo->szProcessorName, _T("Intel Pentium Pro processor"));
                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                        }
                        else
                        {
                                // PII only
                                if (dwModel == 3)
                                {
                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PII;
                    dwID = IDR_IntelPentiumII;
					//wcscpy(pInfo->szProcessorName, _T("Intel Pentium II processor"));
					pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
				}
								// First check for Celeron.
				// If L2 is 0 or 128 it's a Celeron.
				else if (dwModel == 6 ||
					pInfo->dwProcessorL2CacheSize == 128)
				{
					if ((pInfo->dwProcessorL2CacheSize != 128) && (pInfo->dwProcessorL2CacheSize != 0))
					{
        				pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PII;

						//wcscpy(pInfo->szProcessorName,
						//	_T("Intel Pentium II processor"));
                        dwID = IDR_IntelPentiumII;

						// runs at the same speed as 512 size, it's half speed.
                        pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
					}
					else
					{
    					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_CELERON;

						if (pInfo->dwProcessorL2CacheSize)
							pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
						else
							pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;

						dwID = IDR_IntelCeleron;
						//wcscpy(pInfo->szProcessorName, _T("Intel Celeron processor"));
					}
				}
				// PII or Xeon
				else if (dwModel == 5)
				{
					if (pInfo->dwProcessorL2CacheSize == 0 ||
						pInfo->dwProcessorL2CacheSize == 128)
					{
    					pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_CELERON;

                                                if (pInfo->dwProcessorL2CacheSize)
                                                        pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                                else
                                                        pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;

                                                dwID = IDR_IntelCeleron;
                                                //wcscpy(pInfo->szProcessorName, _T("Intel Celeron processor"));
                                        }
                    else if (!IsXeon(pInfo))
                                        {
                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PII;

                                                //wcscpy(pInfo->szProcessorName,
                                                //      _T("Intel Pentium II processor"));
                        dwID = IDR_IntelPentiumII;

                                                // If the cache size is 512, it's half speed.
                        // Otherwise it's full speed.
                                                if (pInfo->dwProcessorL2CacheSize == 512)
                            pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
                        else
                            pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                        }
                                        // Has to be a Xeon if we see more than 512 KB L2 cache.
                                        else
                                        {
                                                // Always Slot 2 for Xeons.
                        pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIXEON;
                                                //wcscpy(pInfo->szProcessorName,
                                                //      _T("Intel Pentium II Xeon processor"));
                        dwID = IDR_IntelPentiumIIXeon;

                                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                        }
                                }
                                // PIII
                else if (dwModel == 7)
                {
                    if (!IsXeon(pInfo))
                                        {
                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIII;

                                                //wcscpy(pInfo->szProcessorName,
                                                //      _T("Intel Pentium III processor"));
                        dwID = IDR_IntelPentiumIII;

                                                // If the cache size is 512, it's half speed.
                        // Otherwise it's full speed.
                                                if (pInfo->dwProcessorL2CacheSize == 512)
                            pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
                        else
                            pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                        }
                                        else
                                        {
                                                // Always Slot 2 for Xeons.
                        pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIIXEON;
                                                //wcscpy(pInfo->szProcessorName,
                                                //      _T("Intel Pentium III Xeon processor"));
                        dwID = IDR_IntelPentiumIIIXeon;

                                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                        }
                }
                                else if ((dwModel == 8) && bCanDo)
                                {
                                        // Get the brand info
                                        DWORD   dwInfo[4] = {0, 0, 0, 0};
                                                DoCPUID(1, &dwInfo[0], &dwInfo[1], &dwInfo[2], &dwInfo[3]);

                                                switch (dwInfo[1] & 0xFF)
                                                {
                                                        case 1:
                                                        {
                                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_CELERON;

                                                                if (pInfo->dwProcessorL2CacheSize)
                                                                        pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                                                else
                                                                        pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;

                                                                dwID = IDR_IntelCeleron;
                                                                //wcscpy(pInfo->szProcessorName, _T("Intel Celeron processor"));
                                                        }
                                                        break;
                                                        
                                                        case 2:
                                                        {
                                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIII;

                                                                //wcscpy(pInfo->szProcessorName,
                                                                //      _T("Intel Pentium III processor"));
                                                                dwID = IDR_IntelPentiumIII;

                                                                // If the cache size is 512, it's half speed.
                                                                // Otherwise it's full speed.
                                                                if (pInfo->dwProcessorL2CacheSize == 512)
                                                                        pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed / 2;
                                                                else
                                                                        pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                                        }
                                                        break;
                                                        
                                                        case 3:
                                                        {
                                                                // Always Slot 2 for Xeons.
                                                                pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

                                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIIXEON;
                                                                //wcscpy(pInfo->szProcessorName,
                                                                //      _T("Intel Pentium III Xeon processor"));
                                                                dwID = IDR_IntelPentiumIIIXeon;

                                                                pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                                        }
                                                        break;

                                                        default:
                                                        {
                                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
                                                                dwID = IDR_UnknownIntelP6;
                                                        }
                                                        break;
                                                }
                                }
                                //PIII Xeon
                                else if (dwModel == 10)
                                {
                                        // Always Slot 2 for Xeons.
                    pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOT2;

                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_PIIIXEON;
                                        //wcscpy(pInfo->szProcessorName,
                                        //      _T("Intel Pentium III Xeon processor"));
                    dwID = IDR_IntelPentiumIIIXeon;

                                        pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
                                }
                else
                                {
                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
                    dwID = IDR_UnknownIntelP6;
                                        //wcscpy(pInfo->szProcessorName, _T("Unknown Intel P6 processor"));
                                }
                        }

                        break;

                default:
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
                        //wcscpy(pInfo->szProcessorName, _T("Unknown Intel processor"));
            dwID = IDR_IntelUnknown;
                        break;
        }

    CHString strName;
        BOOL bUseResource = TRUE;

        if ((dwID == IDR_UnknownIntelP6) || (dwID == IDR_IntelUnknown))
        {
                CHString strID;
                ReadRegistryForName(dwProcessor, strName, strID);

                if (strName.GetLength())
                {
                        bUseResource = FALSE;
                }
                else if (strID.GetLength())
                {
                        strName = strID; 
                        bUseResource = FALSE;
                }
        }

    if (bUseResource)
        {
                LoadStringW(strName, dwID);
        }

    wcscpy(pInfo->szProcessorName, strName);
}

// Assumes processor can do CPUID
void GetAMDSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
        DWORD       dwFamily = pInfo->wProcessorLevel,
                            dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
                            dwStepping = pInfo->dwProcessorSignature & 0xF;
        CHString    strFormat;
    DWORD       dwID;

    Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

    wcscpy(pInfo->szProcessorVersion, strFormat);

        //wsprintf(pInfo->szProcessorVersion, _T("Model %d, Stepping %d"),
        //      dwModel, dwStepping);

        swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

        switch(dwFamily)
        {
                case 4:
            // L2 speed == external clock.
            SetL2SpeedViaExternalClock(pInfo);

                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_486;
            dwID = IDR_AMD4685x86;
                        //wcscpy(pInfo->szProcessorName, _T("Am486 or Am5x86"));
                        break;

                case 5:
                {
                        switch(dwModel)
                        {
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                    // L2 speed == external clock.
                    SetL2SpeedViaExternalClock(pInfo);

                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K5;
                    dwID = IDR_AMDK5;
                                        //wcscpy(pInfo->szProcessorName, _T("AMD-K5 processor"));
                                        break;

                                case 6:
                                case 7:
                    // L2 speed == external clock.
                    SetL2SpeedViaExternalClock(pInfo);

                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K6;
                    dwID = IDR_AMDK6;
                                        //wcscpy(pInfo->szProcessorName, _T("AMD-K6 processor"));
                                        break;

                                case 8:
                    // L2 speed == external clock.
                    SetL2SpeedViaExternalClock(pInfo);

                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K62;
                    dwID = IDR_AMDK62;
                                        //wcscpy(pInfo->szProcessorName, _T("AMD-K6-2 processor"));
                                        break;

                                case 9:
                    // L2 speed == processor speed
                    pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;

                                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K63;
                    dwID = IDR_AMDK63;
                                        //wcscpy(pInfo->szProcessorName, _T("AMD-K6-3 processor"));
                                        break;

                                default:
                                        // Unknown cache speed.

                    pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_OTHER;
                    dwID = IDR_AMDUnknown;
                                        //wcscpy(pInfo->szProcessorName, _T("Unknown AMD processor"));
                                        break;
                        }

                        break;
                }

        case 6:
            pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_K7;

            // L2 speed == 1/3(processor speed)
                        if (pInfo->dwProcessorSpeed > 0)
                        {
                                pInfo->dwProcessorL2CacheSpeed = (pInfo->dwProcessorSpeed)/3;
                        }

            // If we don't yet know the upgrade method, set it to Slot A.
            if (pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_UNKNOWN)
                pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_SLOTA;

            dwID = IDR_AMDAthlon;
            break;

                default:
            dwID = IDR_AMDUnknown;
                        break;
        }

    CHString strName;
        BOOL bUseResource = TRUE;

        if ((dwID == IDR_AMDUnknown) || (dwID == IDR_AMDAthlon))
        {
                CHString strID;
                ReadRegistryForName(dwProcessor, strName, strID);

                if (strName.GetLength())
                {
                        bUseResource = FALSE;
                }
                else if (strID.GetLength())
                {
                        strName = strID; 
                        bUseResource = FALSE;
                }
        }

    if (bUseResource)
        {
                LoadStringW(strName, dwID);
        }

    wcscpy(pInfo->szProcessorName, strName);
}

void GetCyrixSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
        DWORD       dwFamily = pInfo->wProcessorLevel,
                            dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
                            dwStepping = pInfo->dwProcessorSignature & 0xF;
        CHString    strFormat;
    DWORD       dwID;

    Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

    wcscpy(pInfo->szProcessorVersion, strFormat);

        swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

    // L2 speed == external clock.
    SetL2SpeedViaExternalClock(pInfo);

        switch(dwFamily)
        {
                case 4:
                        if (dwModel == 4)
            {
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_MEDIAGX;
                dwID = IDR_CyrixMediaGX;
                                //wcscpy(pInfo->szProcessorName, _T("Cyrix MediaGX processor"));
            }
                        else
            {
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_486;
                dwID = IDR_Cyrix486;
                                //wcscpy(pInfo->szProcessorName, _T("Cyrix 486 processor"));
            }
                        break;

                case 5:
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_M1;
                        switch(dwModel)
                        {
                                case 0:
                                case 1:
                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_6X86;
                                        dwID = IDR_Cyrix6x86;
                                        //wcscpy(pInfo->szProcessorName, _T("Cyrix 6x86 processor"));
                    break;

                                case 2:
                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_6X86;
                                        dwID = IDR_Cyrix6x86L;
                                        //wcscpy(pInfo->szProcessorName, _T("Cyrix 6x86(L) processor"));
                                        break;

                                case 4:
                                pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_MEDIAGX;
                                        dwID = IDR_CyrixMediaGXMMX;
                                        //wcscpy(pInfo->szProcessorName, _T("Cyrix MediaGX MMX Enhanced processor"));
                                        break;

                                default:
                                        dwID = IDR_Cyrix586;
                                        //wcscpy(pInfo->szProcessorName, _T("Cyrix 586 processor"));
                                        break;
                        }

                case 6:
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_OTHER;
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_6X86;
                        dwID = IDR_Cyrix6x86MX;
                        //wcscpy(pInfo->szProcessorName, _T("Cyrix 6x86MX processor"));
            break;

                default:
                        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
                        //wcscpy(pInfo->szProcessorName, _T("Unknown Cyrix processor"));
                        dwID = IDR_CyrixUnknown;
                        break;
        }

    CHString strName;
        BOOL bUseResource = TRUE;

        if (dwID == IDR_CyrixUnknown)
        {
                CHString strID;
                ReadRegistryForName(dwProcessor, strName, strID);

                if (strName.GetLength())
                {
                        bUseResource = FALSE;
                }
                else if (strID.GetLength())
                {
                        strName = strID; 
                        bUseResource = FALSE;
                }
        }

    if (bUseResource)
        {
                LoadStringW(strName, dwID);
        }

    wcscpy(pInfo->szProcessorName, strName);
}

void GetCentaurSystemInfo(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo)
{
        DWORD       dwFamily = pInfo->wProcessorLevel,
                            dwModel = (pInfo->dwProcessorSignature >> 4) & 0xF,
                            dwStepping = pInfo->dwProcessorSignature & 0xF;
        CHString    strFormat;

    // L2 speed == external clock.
    SetL2SpeedViaExternalClock(pInfo);

    Format(strFormat, IDR_ModelSteppingFormat, dwModel, dwStepping);

    wcscpy(pInfo->szProcessorVersion, strFormat);

    // Set it to ZIFF (Socket 7) if we don't have the upgrade method.
    if (pInfo->wWBEMProcessorUpgradeMethod == WBEM_CPU_UPGRADE_UNKNOWN)
            pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_ZIFF;

        //wsprintf(pInfo->szProcessorVersion, _T("Model %d, Stepping %d"),
        //      dwModel, dwStepping);

        swprintf(pInfo->szProcessorStepping, L"%d", dwStepping);

    pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_WINCHIP;

    CHString strName;
        CHString strID;
        ReadRegistryForName(dwProcessor, strName, strID);

        if (!strName.GetLength())
        {
                if (strID.GetLength())
                {
                        strName = strID; 
                }
                else
                {
                        LoadStringW(strName, IDR_IDTWinChip);
                }
        }

    wcscpy(pInfo->szProcessorName, strName);
}
#endif // _X86_

void GetInfoViaSMBIOS(SYSTEM_INFO_EX *pInfo, DWORD dwIndex)
{
    CSMBios smbios;

    if (smbios.Init())
    {
        PPROCESSORINFO ppi =
            (PPROCESSORINFO) smbios.GetNthStruct(4, dwIndex);

        // If we don't find the specified processor, use the 1st.  Some buggy
        // BIOSes mess up with more than one CPU and only have a single struct.
        if (!ppi)
            ppi = (PPROCESSORINFO) smbios.GetNthStruct(4, 0);

        // Some version of smbios don't report cpu info at all
        if (ppi)
        {
            // Find the upgrade method.
            // The values translate straight across from SMBIOS to CIM.
            pInfo->wWBEMProcessorUpgradeMethod = ppi->Processor_Upgrade;

            // Find the external clock.  We'll use this later when determining the
            // cache speed.
            pInfo->dwExternalClock = ppi->External_Clock;

            PCACHEINFO pCache = NULL;

            // Find the L2 cache size.

            // For SMBIOS 2.1 and better, use the cache handle found on the
            // processor struct.
            if (smbios.GetVersion() >= 0x00020001)
            {
                pCache = (PCACHEINFO) smbios.SeekViaHandle(ppi->L2_Cache_Handle);
            }
            // For SMBIOS 2.0, enum through the cache structs and find the one
            // marked as the L2 cache.
            else
            {
                for (int i = 0; pCache = (PCACHEINFO) smbios.GetNthStruct(7, i); i++)
                {
                    // If we found the L2 cache, break.
                    if ((pCache->Cache_Configuration & 3) == 1)
                        break;
                }
            }

            if (pCache)
            {
                // Only the lower 14 bits are significant.
                pInfo->dwProcessorL2CacheSize = pCache->Installed_Size & 0x7FFF;

                // If bit 15 is set, the granularity is 64KB, so multiply the value
                // by 64.
                if (pCache->Installed_Size & 0x8000)
                    pInfo->dwProcessorL2CacheSize *= 64;

#ifdef _IA64_
				pInfo->dwProcessorL2CacheSpeed = pInfo->dwProcessorSpeed;
#endif
            }
        }
    }
}

#ifndef _X86_

#ifdef _IA64_
#include <ia64reg.h>
#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
#pragma intrinsic (__getReg)

#ifdef __cplusplus
}
#endif
#endif

void GetNonX86SystemInfo(SYSTEM_INFO_EX *pInfo, DWORD dwProcessor)
{
	switch(pInfo->wProcessorArchitecture)
	{
		case PROCESSOR_ARCHITECTURE_IA64:
		{

#ifdef _IA64_
			UINT64 val64 = __getReg( CV_IA64_CPUID3 ); 
			DWORD dwFamily = ( UINT32 ) ( ( val64 >> 24 ) & 0xFF );           // ProcessorFamily

			// there is a bug here which the kernel works around so get these
			// values from the kernel (if they exposed family also wouldn't need
			// the call to read the CPUID3 register).
			//DWORD dwStepping = ( UINT32 )( ( val64 >> 8 ) & 0xFF );           // ProcessorRevision
			//DWORD dwModel = ( UINT32 )( ( val64 >> 16 ) & 0xFF );             // ProcessorModel
			SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
			ZeroMemory(&ProcessorInfo,sizeof(ProcessorInfo));
			NTSTATUS Status = NtQuerySystemInformation(
                SystemProcessorInformation,
                &ProcessorInfo,
                sizeof(ProcessorInfo),
                NULL
                );

			CHString strName;
			CHString strID;
			ReadRegistryForName(dwProcessor, strName, strID);

                        if (!strName.GetLength())
                        {
                                if (strID.GetLength())
                                {
                                        strName = strID; 
                                }
                                else
                                {
                                        LoadString(strName, IDR_Itanium);
                                }
                        }

            pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_IA64;
            wcscpy(pInfo->szProcessorName, strName);
            wcscpy(pInfo->szCPUIDProcessorName, strID.GetLength() ? strID : strName);
			pInfo->wProcessorLevel = dwFamily;

			if ( NT_SUCCESS(Status) )
			{
				CHString    strFormat;
				Format(strFormat, IDR_ModelSteppingFormat, ProcessorInfo.ProcessorLevel, ProcessorInfo.ProcessorRevision);
				wcscpy(pInfo->szProcessorVersion, strFormat);
				swprintf(pInfo->szProcessorStepping, L"%d", ProcessorInfo.ProcessorRevision);
			}
			else
			{
				wcscpy(pInfo->szProcessorVersion, strName);
				pInfo->szProcessorStepping[0] = L'\0';
			}
#endif

			break;

		}
        }
}
#endif

BOOL GetSystemInfoEx(DWORD dwProcessor, SYSTEM_INFO_EX *pInfo, DWORD dwCurrentSpeed)
{
    // Make the thread run on the right processor.
    DWORD dwPreviousMask =
            SetThreadAffinityMask(GetCurrentThread(), 1 << dwProcessor);

#ifdef _X86_
        BOOL    bCanDoCPUID = CanDoCPUID();
        DWORD   dwFamily;
#endif

        // Fill in the first part of the structure using Win32.
        memset(pInfo, 0, sizeof(*pInfo));
#ifdef _X86_
        GetCPUInfo(&dwFamily, &pInfo->dwProcessorSignature, &pInfo->dwProcessorFeatures,
                &pInfo->dwProcessorFeaturesEx, (SYSTEM_INFO *) pInfo);
        pInfo->bCoprocessorPresent = HasCoprocessor();

    // Serial number available?
    if (pInfo->dwProcessorFeatures & (1 << 18))
    {
        DWORD dwNichts;

        pInfo->dwSerialNumber[0] = pInfo->dwProcessorSignature;

        DoCPUID(3, &dwNichts, &dwNichts, &pInfo->dwSerialNumber[2],
            &pInfo->dwSerialNumber[1]);
    }
    else
    {
        pInfo->dwSerialNumber[0] = 0;
        pInfo->dwSerialNumber[1] = 0;
        pInfo->dwSerialNumber[2] = 0;
    }
#else
        GetSystemInfo((SYSTEM_INFO *) pInfo);
        pInfo->bCoprocessorPresent = TRUE;
#endif

        if (dwCurrentSpeed == 0)
        {
                pInfo->dwProcessorSpeed = GetFixedCPUSpeed();
        }
        else
        {
                pInfo->dwProcessorSpeed = dwCurrentSpeed;
        }

        pInfo->dwProcessorL2CacheSpeed = (DWORD) -1;
        pInfo->dwProcessorL2CacheSize = (DWORD) -1;
        pInfo->wWBEMProcessorFamily = WBEM_CPU_FAMILY_UNKNOWN;
        pInfo->wWBEMProcessorUpgradeMethod = WBEM_CPU_UPGRADE_UNKNOWN;

        GetVendor(pInfo->szProcessorVendor);

        GetInfoViaSMBIOS(pInfo, dwProcessor);

    // These calls will fill in the szProcessorName.  This is a string
    // we'll deduce by looking at the CPUID signature, L2 cache size, etc.
#ifdef _X86_

    BOOL bGotName = TRUE;

        if (!bCanDoCPUID)
                bGotName = FALSE;
        else
        {
                if (!_wcsicmp(pInfo->szProcessorVendor, L"GenuineIntel"))
                        GetIntelSystemInfo(dwProcessor, pInfo);
                else if (!_wcsicmp(pInfo->szProcessorVendor, L"AuthenticAMD"))
                        GetAMDSystemInfo(dwProcessor, pInfo);
                else if (!_wcsicmp(pInfo->szProcessorVendor, L"CyrixInstead"))
                        GetCyrixSystemInfo(dwProcessor, pInfo);
                else if (!_wcsicmp(pInfo->szProcessorVendor, L"CentaurHauls"))
                        GetCentaurSystemInfo(dwProcessor, pInfo);
                else
            bGotName = FALSE;
        }

    if (!bGotName)
    {
                CHString strName;
                CHString strID;
                ReadRegistryForName(dwProcessor, strName, strID);

                if (!strName.GetLength())
                {
                        if (strID.GetLength())
                        {
                                strName = strID; 
                        }
                        else
                        {
                                Format(strName, IDR_x86ProcessorFormat, dwFamily);
                                //wsprintf(pInfo->szProcessorName, _T("%d86 processor"), dwFamily);
                        }
                }

                wcscpy(pInfo->szProcessorName, strName);
    }

#else
        GetNonX86SystemInfo(pInfo, dwProcessor);
#endif

    // This one fills in szProcessorName, using either CPUID (as with later AMD
    // chips) or with a generic 'x86, Family 6, ...' string.
    GetCPUIDName(dwProcessor, pInfo);

    // Put back the previous thread affinity.
    SetThreadAffinityMask(GetCurrentThread(), dwPreviousMask);

        return TRUE;
}

#define MHZ_LOW_TOLERANCE   3
#define MHZ_HIGH_TOLERANCE  1

const DWORD dwMHzVal[] =
{
    4,   10,   16,   20,   25,   33,   40,   50,   60,   66,   75,   83,   90,
  100,  120,  125,  133,  150,  166,  180,  200,  233,  266,  300,  333,  350,
  366,  400,  433,  450,  466,  475,  500,  533,  550,  600,  633,  667,  700,
  800,  900, 1000, 1100, 1200
};

DWORD GetFixedCPUSpeed()
{
        int         i,
            nVals = sizeof(dwMHzVal) / sizeof(dwMHzVal[0]);
#ifdef _X86_
        DWORD   dwCPUClockRate = CPURawSpeed();
#else
    DWORD   dwCPUClockRate = GetTimeCounterCPUSpeed();
#endif

        for (i = 0; i < nVals; i++)
        {
                if (dwCPUClockRate >= dwMHzVal[i] - MHZ_LOW_TOLERANCE &&
            dwCPUClockRate <= dwMHzVal[i] + MHZ_HIGH_TOLERANCE)
                {
                        dwCPUClockRate = dwMHzVal[i];
                        break;
                }
        }

        return dwCPUClockRate;
}

#if defined(_X86_)

// Counter function for IA-32
#define GetCounter(pdwRet)  RDTSC _asm MOV pdwRet, EAX

#elif defined(_AMD64_)

#define GetCounter(pdwRet) pdwRet = (ULONG)ReadTimeStampCounter()

#elif defined(_IA64_)

// TODO: Counter function for IA-64
#define GetCounter(pdwRet)  pdwRet = 0

#endif

#define MAX_TRIES               500             // Maximum number of samplings
#define WAIT_MS         5
#define NUM_TO_MATCH    5

BOOL DoFreqsMatch(DWORD *pdwFreq)
{
    for (int i = 1; i < NUM_TO_MATCH; i++)
    {
        if (pdwFreq[i] != pdwFreq[0])
            return FALSE;
    }

    return TRUE;
}

DWORD GetTimeCounterCPUSpeed()
{
        LARGE_INTEGER   liFreq;         // High Resolution Performance Counter frequency
        DWORD           dwFreq[NUM_TO_MATCH];
        HANDLE                  hThread = GetCurrentThread();

        // Must have a high resolution counter.
        if (!QueryPerformanceFrequency(&liFreq))
                return 0;

        // Loop until all three frequencies match or we exeed MAX_TRIES.
        for (int iTries = 0;
                (iTries < NUM_TO_MATCH || !DoFreqsMatch(dwFreq)) && iTries < MAX_TRIES;
                iTries++)
        {
            LARGE_INTEGER       liBegin,
                        liEnd;
            DWORD           dwCycles,
                        dwStamp0,       // Time Stamp Variable for beginning and end
                        dwStamp1,
                        dwTicks;

            int iPriority = GetThreadPriority(hThread);

        // Set the thread to the highest priority.
        if (iPriority != THREAD_PRIORITY_ERROR_RETURN)
                    SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);


        // Get the initial time.
        QueryPerformanceCounter(&liBegin);

        // Get the processor counter.
        GetCounter(dwStamp0);

        // This allows for elapsed time for sampling.
        Sleep(WAIT_MS);

        // Get the end time.
        QueryPerformanceCounter(&liEnd);

        // Get the processor counter.
        GetCounter(dwStamp1);


        // Put back the priority to where we found it.
            if (iPriority != THREAD_PRIORITY_ERROR_RETURN)
                SetThreadPriority(hThread, iPriority);

        // Number of internal clock cycles is difference between
        // two time stamp readings.
        dwCycles = dwStamp1 - dwStamp0;

                // Number of external ticks is difference between two
                // hi-res counter reads.
        dwTicks = (DWORD) liEnd.LowPart - (DWORD) liBegin.LowPart;

        DWORD dwCurrentFreq =
                        (DWORD) ((((float) dwCycles * (float) liFreq.LowPart) /
                                (float) dwTicks) / 100000.0f);

            // dwCurrentFreq is currently in this form: 4338 (433.8 MHz)
            // Take any fraction up to the next round number.
        dwFreq[iTries % NUM_TO_MATCH] =
            (dwCurrentFreq + (dwCurrentFreq % 10)) / 10;
        }

        return dwFreq[0];
}

#ifdef _X86_
// Number of cycles needed to execute a single BSF instruction.
// Note that processors below i386(tm) are not supported.
static DWORD dwProcessorCycles[] =
{
        00,  00,  00, 115, 47, 43,
        38,  38,  38, 38,  38, 38,
};

#define ITERATIONS              4000
#define SAMPLINGS               10

DWORD CPURawSpeedHelper(DWORD dwFamily, DWORD dwFeatures)
{
        // Clock cycles elapsed during test
        DWORD   dwCycles;
        int         bManual = FALSE;    // Specifies whether the user
                                //   manually entered the number of
                                //   cycles for the BSF instruction.

        dwCycles = ITERATIONS * dwProcessorCycles[dwFamily];

        // Check for manual BSF instruction clock count
        if (!(dwFeatures & TSC_FLAG))
                bManual = 1;

        if (!bManual)
                // On processors supporting the Read Time Stamp opcode, compare elapsed
                //   time on the High-Resolution Counter with elapsed cycles on the Time
                //   Stamp Register.
                return GetTimeCounterCPUSpeed();
        else if (dwFamily >= 3)
                return GetBSFCPUSpeed(dwCycles);

        return 0;
}

DWORD CPURawSpeed()
{
        DWORD   dwFamily,
                        dwSignature,
                        dwFeatures;

    GetCPUInfo(&dwFamily, &dwSignature, &dwFeatures, NULL, NULL);

    return CPURawSpeedHelper(dwFamily, dwFeatures);
}

DWORD GetBSFCPUSpeed(DWORD dwCycles)
{
        // If processor does not support time stamp reading, but is at least a
        // 386 or above, utilize method of timing a loop of BSF instructions
        // which take a known number of cycles to run on i386(tm), i486(tm), and
        // Pentium(R) processors.
    LARGE_INTEGER   t0,
                    t1,         // Variables for Highres perf counter reads.
                    liCountFreq;// Highres perf counter frequency
        DWORD           dwFreq = 0, // Most current freq. calculation
                        dwTicks,
                    dwCurrent = 0,
                    dwLowest = 0xFFFFFFFF;
        int             i;

        if (!QueryPerformanceFrequency(&liCountFreq))
                return 0;

        for (i = 0; i < SAMPLINGS; i++)
    {
        QueryPerformanceCounter(&t0);   // Get start time

        _asm
        {
            mov eax, 80000000h
            mov bx, ITERATIONS

            // Number of consecutive BSF instructions to execute.

        loop1:
            bsf ecx,eax

            dec bx
            jnz loop1
        }

                // Get end time
        QueryPerformanceCounter(&t1);

        // Number of external ticks is difference between two
                //   hi-res counter reads.
                dwCurrent = (DWORD) t1.LowPart - (DWORD) t0.LowPart;

                if (dwCurrent < dwLowest)
                        dwLowest = dwCurrent;
        }

        dwTicks = dwLowest;


        dwFreq =
            (DWORD) ((((float) dwCycles * (float) liCountFreq.LowPart) /
            (float) dwTicks) / 1000000.0f);

        return dwFreq;
}

BOOL HasCoprocessor()
{
        BOOL bRet;
        WORD wFPStatus;

        _asm
        {
                fninit                                  ; reset FP status word
                mov wFPStatus, 5a5ah    ; initialize temp word to non-zero
                fnstsw wFPStatus                ; save FP status word
                mov ax, wFPStatus               ; check FP status word
                cmp al, 0                       ; was correct status written
                mov bRet, 0                             ; no FPU present
                jne end_fpu_type

;check_control_word:
                fnstcw wFPStatus                ; save FP control word
                mov ax, wFPStatus               ; check FP control word
                and ax, 103fh                   ; selected parts to examine
                cmp ax, 3fh                             ; was control word correct
                mov bRet, 0
                jne end_fpu_type                ; incorrect control word, no FPU
                mov bRet, 1

end_fpu_type:
        }

        return bRet;
}

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dependentservice.h ===
//=================================================================

//

// DependentService.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_DEPENDENTSERVICE__
#define __ASSOC_DEPENDENTSERVICE__

// Property set identification
//============================

#define	PROPSET_NAME_DEPENDENTSERVICE	_T("Win32_DependentService")

#define	SERVICE_REG_KEY_FMAT		_T("System\\CurrentControlSet\\Services\\%s")
#define	SERVICE_DEPENDSONSVC_NAME	L"DependOnService"
#define	SERVICE_DEPENDSONGRP_NAME	L"DependOnGroup"

class CWin32DependentService : public Provider
{
public:
	// Constructor/destructor
	//=======================
	CWin32DependentService( const CHString& strName, LPCWSTR pszNamespace = NULL ) ;
	~CWin32DependentService() ;

	// Functions provide properties with current values
	//=================================================
	virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
	virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
    virtual HRESULT ExecQuery( MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags);

	// Utility function(s)
	//====================
private:

#ifdef NTONLY
	// Windows NT Helpers
	HRESULT RefreshInstanceNT( CInstance* pInstance );
	HRESULT AddDynamicInstancesNT( MethodContext* pMethodContext );
    HRESULT CreateServiceDependenciesNT(

        LPCWSTR pwszServiceName,
        LPCWSTR pwszServicePath,
        MethodContext*			pMethodContext,
        std::map<CHString,CHString>&	servicetopathmap,
        LPBYTE&					pByteArray,
        DWORD&					dwArraySize
    );

    HRESULT CreateServiceAntecedentsNT(

        MethodContext*			pMethodContext,
        std::map<CHString, CHString>	&servicetopathmap,
        CHStringArray           &csaAntecedents,
        LPBYTE&					pByteArray,
        DWORD&					dwArraySize
    );

	BOOL QueryNTServiceRegKeyValue( LPCTSTR pszServiceName, LPCWSTR pwcValueName, LPBYTE& pByteArray, DWORD& dwArraySize );

	// Map Helpers
	void InitServiceToPathMap( TRefPointerCollection<CInstance>& serviceList, std::map<CHString,CHString>& servicetopathmap );

    DWORD IsInList(
                                
        const CHStringArray &csaArray, 
        LPCWSTR pwszValue
    );
#endif
	BOOL ReallocByteArray( LPBYTE& pByteArray, DWORD& dwArraySize, DWORD dwSizeRequired );

#ifdef WIN9XONLY
	// Windows 95 Helpers
	HRESULT RefreshInstanceWin95( CInstance* pInstance );
	HRESULT AddDynamicInstancesWin95( MethodContext* pMethodContext );
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\delayloadhandler.cpp ===
//***************************************************************************

//

//  DELAYLOADHANDLER.CPP

//

//  Module: Delay load handler functions

//

//  Purpose: When delay loaded libraries either fail to load, or functions

//           in them are not found, this handler is called as a result of

//           the //DELAYLOAD linker specification.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <delayimp.h>


// Skeleton DliHook function that does nothing interesting
FARPROC WINAPI DliHook(
    unsigned dliNotify, 
    PDelayLoadInfo pdli) 
{
   FARPROC fp = NULL;   // Default return value

   // NOTE: The members of the DelayLoadInfo structure pointed
   // to by pdli shows the results of progress made so far. 

   switch (dliNotify) 
   {
   case dliStartProcessing:
      // Called when __delayLoadHelper attempts to find a DLL/function
      // Return 0 to have normal behavior, or non-0 to override
      // everything (you will still get dliNoteEndProcessing)
      break;

   case dliNotePreLoadLibrary:
      // Called just before LoadLibrary
      // Return NULL to have __delayLoadHelper call LoadLibary
      // or you can call LoadLibrary yourself and return the HMODULE
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliFailLoadLib:
      // Called if LoadLibrary fails
      // Again, you can call LoadLibary yourself here and return an HMODULE
      // If you return NULL, __delayLoadHelper raises the 
      // ERROR_MOD_NOT_FOUND exception
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliNotePreGetProcAddress:
      // Called just before GetProcAddress
      // Return NULL to have __delayLoadHelper call GetProcAddress
      // or you can call GetProcAddress yourself and return the address
      fp = (FARPROC) NULL;
      break;

   case dliFailGetProc:
      // Called if GetProcAddress fails
      // Again, you can call GetProcAddress yourself here and return an address
      // If you return NULL, __delayLoadHelper raises the 
      // ERROR_PROC_NOT_FOUND exception
      fp = (FARPROC) NULL;
      break;

   case dliNoteEndProcessing:
      // A simple notification that __delayLoadHelper is done
      // You can examine the members of the DelayLoadInfo structure
      // pointed to by pdli and raise an exception if you desire
      break;
   }

   return(fp);
}

// Tell __delayLoadHelper to call my hook function
PfnDliHook __pfnDliNotifyHook  = DliHook;
PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\desktop.cpp ===
//=================================================================

//

// Desktop.CPP --Desktop property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				10/16/97	a-sanjes		Ported to new project.
//
//=================================================================

#include "precomp.h"
#include <cregcls.h>
#include "wbemnetapi32.h"
#include "UserHive.h"
#include "Desktop.h"


const WCHAR *IDS_IconHeight						= L"IconHeight";
const WCHAR *IDS_IconWidth						= L"IconWidth";
const WCHAR *IDS_IconHorizontalSpacing			= L"IconHorizontalSpacing";
const WCHAR *IDS_IconVerticalSpacing			= L"IconVerticalSpacing";

// Provider declaration
//=========================

CWin32Desktop	win32Desktop( PROPSET_NAME_DESKTOP, IDS_CimWin32Namespace );

// Initialize the static font size map
const int CWin32Desktop::MAP_SIZE = 19;
const CWin32Desktop::IconFontSizeMapElement CWin32Desktop::iconFontSizeMap[] =
{
	{6,  0xF6},
	{7,  0xF4},
	{8,  0xF3},
	{9,  0xF1},
	{10, 0xEF},
	{11, 0xEE},
	{12, 0xEC},
	{13, 0xEA},
	{14, 0xE9},
	{15, 0xE7},
	{16, 0xE5},
	{17, 0xE4},
	{18, 0xE2},
	{19, 0xE0},
	{20, 0xDF},
	{21, 0xDD},
	{22, 0xDB},
	{23, 0xDA},
	{24, 0xD8}
};

// Defined in ComputerSystem.cpp

extern TCHAR *GetAllocatedProfileSection (

	const CHString &a_Section ,
	const CHString &a_FileName ,
	DWORD &a_dwSize
) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::CWin32Desktop
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Desktop::CWin32Desktop (

	const CHString &strName,
	LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::~CWin32Desktop
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : None.
 *
 *****************************************************************************/

CWin32Desktop::~CWin32Desktop()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Desktop::GetObject
//
//	Inputs:		CInstance*		pInstance - Instance into which we
//											retrieve data.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Desktop :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	HRESULT	hr = WBEM_E_NOT_FOUND;

	// Pull the name out of the instance and attempt to load
	// the values for it.

	CHString strName ;
	pInstance->GetCHString( IDS_Name, strName );
        if(strName.GetLength() > 0)
        {
#ifdef NTONLY

	    hr = LoadDesktopValuesNT (
  
		    strName.CompareNoCase ( _T(".DEFAULT")) == 0 ? NULL : ( LPCTSTR ) strName,
		    NULL,
		    pInstance
	    ) ;

#endif
#ifdef WIN9XONLY

	    hr = LoadDesktopValuesWin95 (

		    TOBSTRT ( strName ),
		    pInstance
	    )  ;
#endif
        }
	return hr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32Desktop::EnumerateInstances
//
//	Inputs:		MethodContext*	pMethodContext - Context to enum
//								instance data in.
//
//	Outputs:	None.
//
//	Returns:	HRESULT			Success/Failure code.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32Desktop::EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{

	// Enumerate instances based on the OS.

#ifdef NTONLY

	HRESULT hr = EnumerateInstancesNT ( pMethodContext ) ;

#endif

#ifdef WIN9XONLY

	HRESULT hr = EnumerateInstancesWin95 ( pMethodContext ) ;

#endif

    return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::EnumerateInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local users (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Desktop::EnumerateInstancesNT (

	MethodContext *pMethodContext
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

//****************************************
//  Open the registry
//****************************************

	CRegistry regProfileList ;

	DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys (

		HKEY_LOCAL_MACHINE,
		IDS_RegNTProfileList,
		KEY_READ
	) ;

// Open the ProfileList key so we know which profiles to load up.

	if ( dwErr == ERROR_SUCCESS )
	{
		/*we know how many subkeys there are so only loop that many times
		 *Note to whoever wrote this allocating an initial profile array of
		 *20 means that you create 20 new instances and call LoadDesktopValuesNT
		 *20 times when you know that you must do it at most GetCurrentSubKeyCount times
		 */

		CHStringArray profiles;
		profiles.SetSize ( regProfileList.GetCurrentSubKeyCount () , 5 ) ;

		CHString strProfile ;
		for ( int i = 0; regProfileList.GetCurrentSubKeyName ( strProfile ) == ERROR_SUCCESS ; i ++ )
		{
			profiles.SetAt ( i , strProfile ) ;
			regProfileList.NextSubKey () ;
		}

		regProfileList.Close() ;

		for ( int j = 0 ; j < profiles.GetSize () && dwErr == ERROR_SUCCESS && SUCCEEDED ( hr ) ; j ++ )
		{
			CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false);

// We load by profile name here.

			HRESULT t_Result = LoadDesktopValuesNT ( NULL , profiles [ j ] , pInstance ) ;
			if ( WBEM_S_NO_ERROR ==  t_Result )
			{
				hr = pInstance->Commit ( ) ;
			}
		}

		profiles.RemoveAll();
	}
	else
	{
		hr = WinErrorToWBEMhResult(dwErr);
	}

	// ...and one for de faulty case (.DEFAULT):

	if ( dwErr != ERROR_ACCESS_DENIED )
	{
		CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
		HRESULT t_Result = LoadDesktopValuesNT ( NULL , NULL , pInstance ) ;
		if ( WBEM_S_NO_ERROR == t_Result )
		{
			hr = pInstance->Commit ( ) ;
		}
	}
	else
	{
		hr = WinErrorToWBEMhResult ( dwErr ) ;
	}

	return hr ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Desktop::EnumerateInstancesWin95
 *
 *  DESCRIPTION : Creates instance for all known local users (Win95)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32Desktop :: EnumerateInstancesWin95 (

	MethodContext *pMethodContext
)
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    if(IsWin95())
    {
	    DWORD dwRet = 0 ;

	    TCHAR szTemp [ MAX_PATH ] ;

	    GetWindowsDirectory ( szTemp , sizeof ( szTemp ) / sizeof(TCHAR)) ;
	    _tcscat ( szTemp , _T("\\system.ini") ) ;

	    TCHAR *szBuff = GetAllocatedProfileSection (

		    _T("Password Lists"),
		    szTemp,
		    dwRet
	    ) ;

        /*********************************************************************
        * TODO: Needs to be fixed for TCHARS
        *********************************************************************/

        try
        {
	        DWORD dwIndex = 0;
	        while ( dwIndex < dwRet)
	        {

        // Trim leading spaces

		        while ( szBuff [ dwIndex ] == ' ')
		        {
			        dwIndex ++;
		        }

		        // Skip comment lines

		        if ( szBuff [ dwIndex ] == ';')
		        {
			        do {

				        dwIndex++;

			        } while ( szBuff [ dwIndex ] != '\0');

		        }
		        else
		        {
			        TCHAR *pChar = & szBuff [ dwIndex ] ;

			        do
			        {
				        dwIndex ++ ;

			        } while ( ( szBuff [ dwIndex ] != '=') && ( szBuff [ dwIndex ] != '\0' ) );

			        if ( szBuff [ dwIndex ] == '=' )
			        {
				        szBuff[dwIndex] = '\0' ;

				        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
					    CHString strName = pChar;

					    HRESULT t_Result = LoadDesktopValuesWin95 ( TOBSTRT(strName), pInstance ) ;
					    if ( WBEM_S_NO_ERROR == t_Result )
					    {
						    hr = pInstance->Commit( );
				        }
			        }

			        dwIndex++;

			        while (szBuff[dwIndex] != '\0')
			        {
				        dwIndex++;
			        }
		        }

		        dwIndex++;
	        }
        }
        catch ( ... )
        {
            delete [] szBuff;
            throw ;
        }

        delete [] szBuff;
    }

    if(IsWin98())
    {
        CRegistry regProfileList ;
	    DWORD dwErr = regProfileList.OpenAndEnumerateSubKeys(HKEY_LOCAL_MACHINE,
                                                             L"Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList\\",
                                                             KEY_READ);
        if(dwErr == ERROR_SUCCESS)
	    {
		    CHStringArray profiles;
		    profiles.SetSize(regProfileList.GetCurrentSubKeyCount(), 5);

		    CHString strProfile ;
		    for(int i = 0; regProfileList.GetCurrentSubKeyName(strProfile) == ERROR_SUCCESS; i++)
		    {
			    profiles.SetAt(i ,strProfile);
			    regProfileList.NextSubKey();
		    }

		    regProfileList.Close() ;

		    for(int j = 0; j < profiles.GetSize() && dwErr == ERROR_SUCCESS && SUCCEEDED(hr); j++)
		    {
			    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                // We load by profile name here.
			    HRESULT t_Result = LoadDesktopValuesWin95(profiles[j], pInstance);
			    if(WBEM_S_NO_ERROR ==  t_Result)
			    {
				    hr = pInstance->Commit();
			    }
		    }

		    profiles.RemoveAll();
	    }
	    else
	    {
		    hr = WinErrorToWBEMhResult(dwErr);
	    }
    }

    // ...and one for de faulty case:

	CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
	HRESULT t_Result = LoadDesktopValuesWin95(L".DEFAULT", pInstance);
	if(WBEM_S_NO_ERROR == t_Result)
	{
		hr = pInstance->Commit();
	}

    return	hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadDesktopValuesNT
 *
 *  DESCRIPTION : Sets up for NT desktop discovery
 *
 *  INPUTS      :	LPCTSTR pszUserName - User Name to get profile for.
 *					LPCTSTR	pszProfile - Profile Name
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32Desktop::LoadDesktopValuesNT (

	LPCTSTR pszUserName,
	LPCTSTR pszProfile,
	CInstance *pInstance
)
{
	CHString strUserName ( pszUserName ) ;
	CHString strProfile ( pszProfile ) ;

	DWORD		dwReturn = 0;

	// Try to open user's hive

	CRegistry RegInfo ;

	// Load the UserHive depending on whether we have the username or the profile name
	// filled out.

	CUserHive UserHive ;
    bool t_bHiveIsLoaded = false;

	TCHAR szKeyName [ _MAX_PATH ] ;

    try
    {

	    if ( NULL != pszUserName )
	    {
		    // KeyName will get loaded.  This is essentially the string representation
		    // of our profile name.

		    if ( ( dwReturn = UserHive.Load ( pszUserName , szKeyName ) ) == ERROR_SUCCESS )
		    {
                t_bHiveIsLoaded = true;
			    strProfile = szKeyName;
		    }
	    }
	    else if (pszProfile)
	    {
		    // If this succeeds, store the profile in the keyname
		    if ( ( dwReturn = UserHive.LoadProfile ( pszProfile , strUserName ) ) == ERROR_SUCCESS  && 
                            strUserName.GetLength() > 0 )
		    {
                t_bHiveIsLoaded = true;
			    lstrcpy( szKeyName, pszProfile );
		    }
	    }
	    else
	    {
	    // Both name and profile are NULL, which means use the .DEFAULT hive.

		    lstrcpy ( szKeyName, _T(".DEFAULT") ) ;
		    strUserName = szKeyName ;
		    strProfile = szKeyName ;

            // Find out if we can read the default user hive.
            dwReturn = RegInfo.Open ( HKEY_USERS , _T(".DEFAULT") , KEY_READ ) ;
	    }

	    // User name is the key so there is no point adding the instance if we
        // failed to get the key.
        if(strUserName.IsEmpty())
        {
            dwReturn = E_FAIL;
        }
        if ( ERROR_SUCCESS == dwReturn)
	    {
            // User hive exists, try to open it

		    // szKeyName should be loaded with the profile name
		    // (a string representation of the SID) for this
		    // particular user, so strcat is OK here.

            lstrcat ( szKeyName, IDS_RegControlPanelDesktop ) ;

            dwReturn = RegInfo.Open ( HKEY_USERS , szKeyName , KEY_READ ) ;
            if ( dwReturn == ERROR_SUCCESS )
            {
                pInstance->SetCHString ( IDS_Name , strUserName ) ;

			    CHString sTemp ;

                if ( RegInfo.GetCurrentKeyValue ( IDS_CoolSwitch , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool ( IDS_CoolSwitch , sTemp == _T("1") ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_CursorBlinkRate , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD ( IDS_CursorBlinkRate , _ttoi(sTemp) ) ;
			    }
                else
			    {
                   // This appears to be the default
	                pInstance->SetDWORD ( IDS_CursorBlinkRate , 500 ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_DragFullWindows , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool(IDS_DragFullWindows, sTemp == _T("1"));
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_GridGranularity , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD(IDS_GridGranularity, _ttoi(sTemp));
			    }

				// Adding the Horizontal and Vertical Spacing
				int iIconHeight = GetSystemMetrics( SM_CYICON );
				int iIconWidth  = GetSystemMetrics ( SM_CXICON );
				int iIconHorizontalSpacing = GetSystemMetrics ( SM_CXICONSPACING );
				int iIconVerticalSpacing = GetSystemMetrics ( SM_CYICONSPACING );

				pInstance->SetDWORD ( IDS_IconHeight, iIconHeight );
				pInstance->SetDWORD ( IDS_IconWidth, iIconWidth );
				pInstance->SetDWORD ( IDS_IconHorizontalSpacing, iIconHorizontalSpacing );
				pInstance->SetDWORD ( IDS_IconVerticalSpacing, iIconVerticalSpacing );

                if ( ! IsWinNT5 () )
                {
                    if ( RegInfo.GetCurrentKeyValue ( IDS_IconSpacing , sTemp ) == ERROR_SUCCESS )
				    {
                        // Have to subtract 32 to get the correct value
                        pInstance->SetDWORD(IDS_IconSpacing, CALC_IT(_ttoi(sTemp) - 32));
				    }

                    if (RegInfo.GetCurrentKeyValue(IDS_IconTitleWrap, sTemp) == ERROR_SUCCESS)
				    {
	                    pInstance->Setbool(IDS_IconTitleWrap, sTemp == _T("1"));
				    }
                }
                else
                {
                    CHString strKey;
                    strKey.Format(_T("%s\\WindowMetrics"), szKeyName);

                    CRegistry reg;
                    if ( reg.Open ( HKEY_USERS , strKey , KEY_READ ) == ERROR_SUCCESS )
                    {
                        if ( reg.GetCurrentKeyValue ( IDS_IconSpacing, sTemp ) == ERROR_SUCCESS )
					    {
                            // Have to subtract 32 to get the correct value
                            pInstance->SetDWORD ( IDS_IconSpacing , CALC_IT ( _ttoi ( sTemp ) ) - 32  ) ;
					    }

                        if ( reg.GetCurrentKeyValue ( IDS_IconTitleWrap , sTemp ) == ERROR_SUCCESS )
					    {
	                        pInstance->Setbool ( IDS_IconTitleWrap , sTemp == _T("1") ) ;
					    }
                        else
					    {
	                        // This seems to not be there on later NT5 builds,
                            // but since the user can't change this anyway we'll
                            // assume it's always set.
                            pInstance->Setbool ( IDS_IconTitleWrap , TRUE ) ;
					    }
                    }
                }

                sTemp = L"";
                if ( RegInfo.GetCurrentKeyValue ( IDS_Pattern , sTemp ) != ERROR_SUCCESS )
			    {
                    sTemp = L"(None)";
                }
                pInstance->SetCHString ( IDS_Pattern , sTemp ) ;

                //if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveActive , sTemp ) == ERROR_SUCCESS )
			    //{
	            //    pInstance->Setbool ( IDS_ScreenSaverActive , sTemp == _T("1") ) ;
			    //}

                sTemp = L"";
                if( RegInfo.GetCurrentKeyValue ( IDS_RegSCRNSAVEEXE , sTemp ) == ERROR_SUCCESS )
			    {
				    pInstance->SetCHString ( IDS_ScreenSaverExecutable , sTemp ) ;
                }
                else
                {
                    sTemp = L"";
                }    

                // The control panel applet bases the decision as to whether
                // a screen saver is active or not based not on the ScreenSaverActive
                // registry entry, but on whether the ScreenSaverExecutable
                // setting is there or not.  So we will too...
                if(sTemp.GetLength() > 0)
                {
                    pInstance->Setbool ( IDS_ScreenSaverActive , true ) ;
                }
                else
                {
                    pInstance->Setbool ( IDS_ScreenSaverActive , false ) ;
                }
			    

                if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaverIsSecure , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool ( IDS_ScreenSaverSecure , sTemp == _T("1") ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveTimeOut , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD ( IDS_ScreenSaverTimeout , _ttoi ( sTemp ) ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_Wallpaper, sTemp ) == ERROR_SUCCESS )
			    {
				    pInstance->SetCHString ( IDS_Wallpaper , sTemp ) ;
			    }

                if ( RegInfo.GetCurrentKeyValue ( IDS_RegTileWallpaper , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->Setbool ( IDS_WallpaperTiled , sTemp == _T("1") ) ;
			    }

			    DWORD dwStyle = 0 ;
                if ( RegInfo.GetCurrentKeyValue ( _T("WallpaperStyle") , dwStyle ) == ERROR_SUCCESS )
                {
				    if ( dwStyle != 0 )
				    {
	                    pInstance->SetDWORD ( _T("WallpaperStretched") , TRUE ) ;
				    }
				    else
				    {
					    pInstance->SetDWORD ( _T("WallpaperStretched") , FALSE ) ;
				    }
			    }
			    else
			    {
				    pInstance->SetDWORD ( _T("WallpaperStretched") , FALSE ) ;
			    }



                if(!IsWinNT5())  // what this does is set the user's default values, which will remain the ones we report unless we override it below from values contained in windowmstrics\iconfont
                {
                    if ( RegInfo.GetCurrentKeyValue ( IDS_IconTitleFaceName , sTemp ) == ERROR_SUCCESS )
			        {
	                    pInstance->SetCHString ( IDS_IconTitleFaceName , sTemp) ;
			        }

                    if ( RegInfo.GetCurrentKeyValue ( IDS_IconTitleSize , sTemp ) == ERROR_SUCCESS )
			        {
	                    pInstance->SetDWORD ( IDS_IconTitleSize , _ttoi(sTemp) - 1) ;
			        }
                }

                RegInfo.Close () ;
            }

            lstrcat( szKeyName , IDS_RegWindowMetricsKey ) ;
            if ( RegInfo.Open ( HKEY_USERS , szKeyName , KEY_READ) == ERROR_SUCCESS )
            {
			    CHString sTemp ;

                if ( RegInfo.GetCurrentKeyValue ( IDS_BorderWidth , sTemp ) == ERROR_SUCCESS )
			    {
	                pInstance->SetDWORD ( IDS_BorderWidth , CALC_IT ( _ttoi ( sTemp ) ) );
			    }

                if(IsWinNT5() || IsWinNT4())
                {
                    DWORD t_Length ;
				    if ( RegInfo.GetCurrentBinaryKeyValue ( L"IconFont" , NULL , & t_Length ) == ERROR_SUCCESS )
				    {
					    BYTE *t_Buffer = new BYTE [ t_Length ] ;
					    if ( t_Buffer )
					    {
						    try
						    {
							    if ( RegInfo.GetCurrentBinaryKeyValue ( IDS_IconFont , t_Buffer , & t_Length ) == ERROR_SUCCESS )
							    {
								    if ( t_Length == sizeof ( LOGFONTW )  )
								    {
        							    LOGFONTW lfIcon;
									    memcpy ( & lfIcon, t_Buffer , sizeof ( LOGFONTW ) ) ;

									    pInstance->SetWCHARSplat ( IDS_IconTitleFaceName , lfIcon.lfFaceName);

									    HDC hDC = GetDC ( NULL ) ;

									    int nPointSize = - ( MulDiv (lfIcon.lfHeight, 72, GetDeviceCaps ( hDC , LOGPIXELSY ) ) );

									    ReleaseDC ( NULL, hDC ) ;

									    pInstance->SetDWORD ( IDS_IconTitleSize , nPointSize ) ;
								    }
							    }
						    }
						    catch ( ... )
						    {
							    delete [] t_Buffer ;

							    throw ;
						    }

						    delete [] t_Buffer ;
					    }
					    else
					    {
						    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					    }
				    }
                }

                RegInfo.Close();
            }


            // On NT5, these registry entries don't appear until the user
            // changes them.  So, give them a default to be consistent with
            // other NT4 and 351.

            if ( IsWinNT5 () )
            {
                if ( pInstance->IsNull ( IDS_IconTitleFaceName ) )
			    {
                    pInstance->SetCharSplat ( IDS_IconTitleFaceName , _T("MS Shell Dlg") ) ;
			    }

                if ( pInstance->IsNull ( IDS_IconTitleSize ) )
			    {
                    pInstance->SetDWORD ( IDS_IconTitleSize , 8 ) ;
			    }
            }
        }
    }
    catch ( ... )
    {
        if (t_bHiveIsLoaded)
        {
            UserHive.Unload ( strProfile ) ;
            t_bHiveIsLoaded = false;
        }
        throw ;
    }

	// The User's profile gets loaded by the appropriate load function.  However,
	// the profile name is what we should use to unload it.

    UserHive.Unload ( strProfile ) ;
    t_bHiveIsLoaded = false;

    return WinErrorToWBEMhResult ( dwReturn ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : LoadDesktopValuesWin95
 *
 *  DESCRIPTION : Sets up for Win95 desktop discovery
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32Desktop::LoadDesktopValuesWin95 (

	LPCWSTR pszUserName ,
	CInstance* pInstance
)
{
	HRESULT hr = WBEM_E_NOT_FOUND;

	WCHAR szKeyName[_MAX_PATH] ;
   	swprintf ( szKeyName, IDS_RegControlPanelDesktop95, ( LPWSTR ) TOBSTRT ( pszUserName ) ) ;

	CRegistry RegInfo ;
	CUserHive UserHive ;

	WCHAR szHiveKeyName[_MAX_PATH];

	if ( UserHive.Load ( pszUserName , szHiveKeyName ) == ERROR_SUCCESS )
    {
        try
        {
            if ( RegInfo.Open ( HKEY_USERS , szKeyName , KEY_READ ) == ERROR_SUCCESS )
	        {
		        hr = WBEM_S_NO_ERROR ;

		        pInstance->SetCharSplat( IDS_Name, pszUserName ) ;

		        CHString sTemp ;

		        if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveActive , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->Setbool ( IDS_ScreenSaverActive, ( sTemp == _T("1") ? TRUE : FALSE ) ) ;
		        }

		        if ( RegInfo.GetCurrentKeyValue ( IDS_CursorBlinkRate , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->SetDWORD ( IDS_CursorBlinkRate, _wtoi ( sTemp.GetBuffer (0) ) ) ;
		        }
		        else
		        {
                 // This appears to be the default
			        pInstance->SetDWORD ( IDS_CursorBlinkRate, 500 ) ;
		        }

		        DWORD dwTemp ;

		        if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveUsePassword , dwTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->Setbool ( IDS_ScreenSaverSecure , dwTemp ? TRUE : FALSE ) ;
		        }

		        if( RegInfo.GetCurrentKeyValue ( IDS_DragFullWindows , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->Setbool ( IDS_DragFullWindows , ( sTemp == _T("1") ? TRUE : FALSE ) ) ;
		        }

		        if ( RegInfo.GetCurrentKeyValue ( IDS_RegScreenSaveTimeOut , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->SetDWORD ( IDS_ScreenSaverTimeout, _wtoi ( sTemp.GetBuffer (0) ) );
		        }

	          // Grab out the pattern.  This is a string representation of a bunch of bytes

                sTemp = L"";
		        if ( RegInfo.GetCurrentKeyValue ( IDS_Pattern , sTemp ) != ERROR_SUCCESS )
		        {
                    sTemp = L"(None)";
		        }
                pInstance->SetCHString ( IDS_Pattern, sTemp ) ;

		        if ( RegInfo.GetCurrentKeyValue ( IDS_Wallpaper , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->SetCHString ( IDS_Wallpaper, sTemp ) ;
		        }

		        if ( RegInfo.GetCurrentKeyValue ( IDS_RegTileWallpaper , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->Setbool ( IDS_WallpaperTiled , ( sTemp == _T("1") ? TRUE : FALSE ) ) ;
		        }

		        if ( RegInfo.GetCurrentKeyValue ( L"WallpaperStyle", sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->Setbool ( L"WallpaperStretched" , ( sTemp == L"2" ? TRUE : FALSE ) ) ;
		        }
		        else
		        {
			        pInstance->Setbool ( L"WallpaperStretched" , FALSE ) ;
		        }

		        RegInfo.Close () ;
	        }

	        wcscat(szKeyName, IDS_RegWindowMetricsKey);

	        if ( RegInfo.Open ( HKEY_USERS , szKeyName , KEY_READ ) == ERROR_SUCCESS)
	        {
		        CHString sTemp ;
				// Adding the Horizontal and Vertical Spacing
				int iIconHeight = GetSystemMetrics( SM_CYICON );
				int iIconWidth  = GetSystemMetrics ( SM_CXICON );
				int iIconHorizontalSpacing = GetSystemMetrics ( SM_CXICONSPACING );
				int iIconVerticalSpacing = GetSystemMetrics ( SM_CYICONSPACING );

				pInstance->SetDWORD ( IDS_IconHeight, iIconHeight );
				pInstance->SetDWORD ( IDS_IconWidth, iIconWidth );
				pInstance->SetDWORD ( IDS_IconHorizontalSpacing, iIconHorizontalSpacing );
				pInstance->SetDWORD ( IDS_IconVerticalSpacing, iIconVerticalSpacing );

		        if ( RegInfo.GetCurrentKeyValue ( IDS_IconSpacing , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->SetDWORD ( IDS_IconSpacing, CALC_IT ( _wtoi ( sTemp.GetBuffer (0) ) )-32 ) ;
		        }

		        if ( RegInfo.GetCurrentKeyValue ( IDS_BorderWidth , sTemp ) == ERROR_SUCCESS )
		        {
			        pInstance->SetDWORD ( IDS_BorderWidth , CALC_IT ( _wtoi ( sTemp.GetBuffer (0) ) ) ) ;
		        }

				// Only want to obtain the values from HKEY_USERS if the user has custom set her desktop
                // settings (otherwise the information contained in IconSize is wrong - returns font size'
                // of six instead of eight).  The only way to tell this is if there is a "Shell Icon Size"
                // entry under the WindowMetrics key. It seems consistent...
                if(RegInfo.GetCurrentKeyValue(L"Shell Icon Size", sTemp) == ERROR_SUCCESS)
                {
                    DWORD t_Length ;
				    if ( RegInfo.GetCurrentBinaryKeyValue ( L"IconFont" , NULL , & t_Length ) == ERROR_SUCCESS )
				    {
					    BYTE *t_Buffer = new BYTE [ t_Length ] ;
					    if ( t_Buffer )
					    {
						    try
						    {
							    if ( RegInfo.GetCurrentBinaryKeyValue ( L"IconFont" , t_Buffer , & t_Length ) == ERROR_SUCCESS )
							    {
								    if ( t_Length > 18 )
								    {
									    CHString t_Temp ( ( t_Buffer + 18 ) ) ;
									    pInstance->SetCHString ( IDS_IconTitleFaceName , t_Temp ) ;

									    long t_lIconTitleSize = *((long*)(t_Buffer));
									    pInstance->SetDWORD ( IDS_IconTitleSize , t_lIconTitleSize ) ;
								    }
							    }
						    }
						    catch ( ... )
						    {
							    delete [] t_Buffer ;

							    throw ;
						    }

						    delete [] t_Buffer ;
					    }
					    else
					    {
						    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					    }
				    }
                }
                else // go with default values
                {
                    pInstance->SetCHString(IDS_IconTitleFaceName , "MS Sans Serif");
                    pInstance->SetDWORD(IDS_IconTitleSize , 8L);
                }

                /*
		        if ( RegInfo2.GetCurrentKeyValue ( L"IconFont" , sTemp ) == ERROR_SUCCESS )
		        {
					if ( sTemp.GetLength () > 18 )
					{
						CHString t_Temp ( ( ( char * ) sTemp.GetBuffer ( 0 ) + 18 ) ) ;
						pInstance->SetCHString ( IDS_IconTitleFaceName , t_Temp ) ;
					}
		        }
                */
		        RegInfo.Close () ;
	        }
        }
        catch ( ... )
        {
        	UserHive.Unload ( szHiveKeyName ) ;
            throw ;
        }

    	UserHive.Unload ( szHiveKeyName ) ;
    }


	return hr ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetIconFontSizeFromRegistryValue
 *
 *  DESCRIPTION : A function to look up the above font size mapping table
 *
 *  INPUTS      : The registry value representing the icon font size
 *
 *  RETURNS     : The icon font size corresponding to the value in the registry.
 *				  0 if not found.
 *
 *  COMMENTS    : This is required since there doesnt seem to an obvious mapping
 *				  function between the value in the control panel and the value
 *				  stored in the registry
 *
 *****************************************************************************/

int CWin32Desktop::GetIconFontSizeFromRegistryValue ( BYTE registryValue )
{
	for ( int size = 0; size < MAP_SIZE ; size++ )
	{
		if ( iconFontSizeMap [ size ].byRegistryValue == registryValue )
		{
			return size + 6 ;
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\desktop.h ===
//=================================================================

//

// Desktop.h -- Desktop property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define	PROPSET_NAME_DESKTOP	_T("Win32_Desktop")
#define CALC_IT(x) (x < 0 ? ((x)/(-15)) : x)

class CWin32Desktop : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32Desktop( const CHString& strName, LPCWSTR pszNamespace ) ;
       ~CWin32Desktop() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

	private:
        // Utility function(s)
        //====================
#ifdef NTONLY
		HRESULT EnumerateInstancesNT( MethodContext* pMethodContext ) ;
		HRESULT LoadDesktopValuesNT( LPCWSTR pszUserName, LPCTSTR pszProfile, CInstance* pInstance );
#endif
#ifdef WIN9XONLY
		HRESULT EnumerateInstancesWin95( MethodContext* pMethodContext ) ;
		HRESULT LoadDesktopValuesWin95( LPCWSTR pszUserName, CInstance* pInstance ) ;
#endif


		// A mapping is required between the icon font size specified in
		// the control panem and the value stored in the registry
		typedef struct 
		{
			int iFontSize;
			BYTE byRegistryValue;
		} IconFontSizeMapElement;

		// The storage for the above map table
		static const IconFontSizeMapElement iconFontSizeMap[];
		static const int MAP_SIZE;

		// A function to look up the above font size mapping table
		static int GetIconFontSizeFromRegistryValue(BYTE registryValue);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\desktopmonitor.h ===
//=================================================================

//

// DesktopMonitor.h -- CWin32DesktopMonitor property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/05/98    sotteson         Created
//
//=================================================================
#ifndef _DESKTOPMONITOR_H
#define _DESKTOPMONITOR_H

class CMultiMonitor;

class CWin32DesktopMonitor : public Provider
{
public:
	// Constructor/destructor
	//=======================
	CWin32DesktopMonitor(LPCWSTR szName, LPCWSTR szNamespace);
	~CWin32DesktopMonitor();

	virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, 
		long lFlags = 0);
	virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0);

protected:
    HRESULT SetProperties(CInstance *pInstance, CMultiMonitor *pMon, int iWhich);
    void SetDCProperties(CInstance *pInstance, LPCWSTR szDeviceName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\desktopmonitor.cpp ===
//=================================================================

//

// DesktopMonitor.CPP -- CodecFile property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/27/98    sotteson         Created
//
//=================================================================

#include "precomp.h"
#include "sid.h"
#include "implogonuser.h"
#include "DesktopMonitor.h"
#include <multimon.h>
#include "multimonitor.h"
#include "resource.h"

// Property set declaration
//=========================

CWin32DesktopMonitor startupCommand(L"Win32_DesktopMonitor", IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DesktopMonitor::CWin32DesktopMonitor
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DesktopMonitor::CWin32DesktopMonitor(
	LPCWSTR szName,
	LPCWSTR szNamespace) :
    Provider(szName, szNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DesktopMonitor::~CWin32DesktopMonitor
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DesktopMonitor::~CWin32DesktopMonitor()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DesktopMonitor::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DesktopMonitor::EnumerateInstances(
	MethodContext *pMethodContext,
	long lFlags)
{
    HRESULT       hres = WBEM_S_NO_ERROR;
	CMultiMonitor monitor;

    for (int i = 0; i < monitor.GetNumAdapters() && SUCCEEDED(hres); i++)
    {
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
	    // Set the device ID.
		CHString strDeviceID;
		CHString strDeviceName;

		strDeviceID.Format(L"DesktopMonitor%d", i + 1);

	    pInstance->SetCharSplat(L"DeviceID", strDeviceID);

		hres = SetProperties(pInstance, & monitor, i);

        // If we found one, commit.
        if (SUCCEEDED(hres))
    		hres = pInstance->Commit();
        // It's possible the adapter is enabled but the montior isn't.  In
        // this case, just keep enuming.
        else if (hres == WBEM_E_NOT_FOUND)
            hres = WBEM_S_NO_ERROR;
    }

    return hres;
}

HRESULT CWin32DesktopMonitor::SetProperties(
	CInstance *pInstance,
	CMultiMonitor *pMon,
	int iWhich)
{
    // Set the config mgr properties.
    CHString            strDescription,
                        strTemp,
                        strDriver;
	CConfigMgrDevicePtr pDeviceMonitor;
    HRESULT             hres = WBEM_S_NO_ERROR;

    if (pMon->GetMonitorDevice(iWhich, & pDeviceMonitor))
	{
		pDeviceMonitor->GetDeviceDesc(strDescription);

		if (pDeviceMonitor->GetMfg(strTemp))
		{
			pInstance->SetCHString(IDS_MonitorManufacturer, strTemp);
		}

	    if (pDeviceMonitor->GetStatus(strTemp))
	    {
		    pInstance->SetCHString(IDS_Status, strTemp);
	    }

        SetConfigMgrProperties(pDeviceMonitor, pInstance);

        hres = WBEM_S_NO_ERROR;
    }
    else
	{
        // Sometimes cfg mgr doesn't come up with an instance for
        // the monitor.  So if we don't find it, fill in the name
        // ourselves.
        LoadStringW(strDescription, IDR_DefaultMonitor);

	    // Assume this monitor is working.
        pInstance->SetCharSplat(IDS_Status, L"OK");
	}

    pInstance->SetCHString(IDS_Description, strDescription);
    pInstance->SetCHString(IDS_Caption, strDescription);
    pInstance->SetCHString(IDS_Name, strDescription);
    pInstance->SetCHString(L"MonitorType", strDescription);
    SetCreationClassName(pInstance);

    // Set the system name.

    pInstance->SetCharSplat(IDS_SystemName, GetLocalComputerName());
    pInstance->SetWCHARSplat(IDS_SystemCreationClassName, L"Win32_ComputerSystem");

    // Set the properties that require a DC.

    CHString strDeviceName;

    pMon->GetAdapterDisplayName(iWhich, strDeviceName);

    SetDCProperties(pInstance, strDeviceName);

    return hres;
}

HRESULT CWin32DesktopMonitor::GetObject(
	CInstance *pInstance,
	long lFlags)
{
	HRESULT	 hres = WBEM_E_NOT_FOUND;
	CHString strDeviceID;
    DWORD    dwWhich;

    pInstance->GetCHString(L"DeviceID", strDeviceID);

    if (ValidateNumberedDeviceID(strDeviceID, L"DESKTOPMONITOR", &dwWhich))
    {
        CMultiMonitor monitor;

        if (dwWhich >= 1 && dwWhich <= monitor.GetNumAdapters())
        {
            hres = SetProperties(pInstance, &monitor, dwWhich - 1);
        }
    }

	return hres;
}

void CWin32DesktopMonitor::SetDCProperties(
	CInstance *pInstance,
    LPCWSTR szDeviceName
)
{
	CSmartCreatedDC hdc(CreateDC(
            			   TOBSTRT(szDeviceName),
			               NULL,
			               NULL,
			               NULL));

	if (hdc)
	{
        pInstance->SetDWORD(IDS_Availability, 3); // 3 == Running
		pInstance->SetDWORD(L"PixelsPerXLogicalInch", GetDeviceCaps(hdc, LOGPIXELSX));
	    pInstance->SetDWORD(L"PixelsPerYLogicalInch", GetDeviceCaps(hdc, LOGPIXELSY));
		pInstance->SetDWORD(L"ScreenWidth", GetDeviceCaps(hdc, HORZRES));
		pInstance->SetDWORD(L"ScreenHeight", GetDeviceCaps(hdc, VERTRES));
	}
    else
    {
		// Assume this is because the device is not in use.  Set Availability
        // to 8 (off line).
        pInstance->SetDWORD(IDS_Availability, 8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devbus.cpp ===
//=================================================================

//

// devbus.h -- cim_logicaldevice to win32_bus

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/23/98    davwoh         Created
//
// Comment: Relationship between device and bus
//
//=================================================================

#include "precomp.h"
#include "PNPEntity.h"
#include "LPVParams.h"

#include "devbus.h"

// Property set declaration
//=========================

CWin32DeviceBus MyDevBus(PROPSET_NAME_DEVICEBUS, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::CWin32DeviceBus
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DeviceBus::CWin32DeviceBus(LPCWSTR setName, LPCWSTR pszNamespace)
: CWin32PNPEntity(setName, pszNamespace),
  Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::~CWin32DeviceBus
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DeviceBus::~CWin32DeviceBus()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceBus::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrBus, chstrBusID, chstrDevice, chstrDeviceID, chstrTemp, chstrPNPDeviceID;
    HRESULT hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pBus;
    CConfigManager	cfgManager;
    INTERFACE_TYPE itBusType = InterfaceTypeUndefined;
    DWORD dwBusNumber = 0;

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, chstrBus);
    pInstance->GetCHString(IDS_Dependent, chstrDevice);

    // If both ends are there
    // No easy way to circumvent call through CIMOM for the bus, without multipally inherriting this class from CWin32Bus also.
    if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrBus, &pBus, pInstance->GetMethodContext())))
    {
        // Bus exists.  Now check if device instance exists (object name valid and device actually exists)
        if(ObjNameValid(chstrDevice,L"Win32_PnPEntity", IDS_DeviceID,chstrPNPDeviceID) && (DeviceExists(chstrPNPDeviceID, &dwBusNumber, &itBusType)))
        {
            // Get the id (to send to cfgmgr)
            pBus->GetCHString(IDS_DeviceID, chstrBusID);
            chstrTemp.Format(L"%s_BUS_%u", szBusType[itBusType], dwBusNumber);
            if (chstrBusID.CompareNoCase(chstrTemp) == 0)
            {
                hRet = WBEM_S_NO_ERROR;
            }
        }
    }

    return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceBus::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceBus::LoadPropertyValues(void* pvData)
{
    CHString chstrDeviceID, chstrDevicePath, chstrTemp;
    HRESULT hr = WBEM_S_NO_ERROR;
    INTERFACE_TYPE itBusType = InterfaceTypeUndefined;
    DWORD dwBusNumber = 0;

    CLPVParams* pParams = (CLPVParams*)pvData;
    CInstance* pInstance = (CInstance*)(pParams->m_pInstance); // This instance released by caller
    CConfigMgrDevice* pDevice = (CConfigMgrDevice*)(pParams->m_pDevice);

    if(pDevice == NULL || pInstance == NULL) return hr;
    MethodContext* pMethodContext = pInstance->GetMethodContext();
    if(pMethodContext == NULL) return hr;

    // Get the id (to send to cfgmgr) and the path (to send back in 'Dependent')
    pDevice->GetDeviceID(chstrDeviceID);
    CHString chstrDeviceIDAdj;
    EscapeBackslashes(chstrDeviceID, chstrDeviceIDAdj);
    chstrDevicePath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"",
                           (LPCWSTR)GetLocalComputerName(),
                           IDS_CimWin32Namespace,
                           PROPSET_NAME_PNPEntity,
                           IDS_DeviceID,
                           (LPCWSTR)chstrDeviceIDAdj);

    if(DeviceExists(chstrDeviceID, &dwBusNumber, &itBusType))
    {
        {
            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
            chstrTemp.Format(L"\\\\%s\\%s:%s.%s=\"%s_BUS_%u\"",
                            (LPCWSTR)GetLocalComputerName(), IDS_CimWin32Namespace,
                            L"Win32_Bus", IDS_DeviceID, szBusType[itBusType], dwBusNumber);

            pInstance->SetCHString(IDS_Antecedent, chstrTemp);
            pInstance->SetCHString(IDS_Dependent, chstrDevicePath);

            hr = pInstance->Commit();
        }
    }

   return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : ObjNameValid
 *
 *  DESCRIPTION : Internal helper to check if the given object exists.
 *
 *  INPUTS      : chstrObject - name of prospecitive object.
 *
 *  OUTPUTS     : chstrPATH, the path of the provided object
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32DeviceBus::ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH)
{
    bool fRet = false;

    ParsedObjectPath*    pParsedPath = 0;
    CObjectPathParser    objpathParser;

    // Parse the object path passed to us by CIMOM
    // ==========================================
    int nStatus = objpathParser.Parse( wstrObject,  &pParsedPath );

    // One of the biggest if statements I've ever written.
    if ( 0 == nStatus )                                                     // Did the parse succeed?
    {
        try
        {
            if ((pParsedPath->IsInstance()) &&                                      // Is the parsed object an instance?
                (_wcsicmp(pParsedPath->m_pClass, wstrObjName) == 0) &&              // Is this the class we expect (no, cimom didn't check)
                (pParsedPath->m_dwNumKeys == 1) &&                                  // Does it have exactly one key
                (pParsedPath->m_paKeys[0]) &&                                       // Is the keys pointer null (shouldn't happen)
                ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                     // Key name not specified or
                (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, wstrKeyName) == 0)) &&  // key name is the right value
                                                                                // (no, cimom doesn't do this for us).
                (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == VT_BSTR) &&           // Check the variant type (no, cimom doesn't check this either)
                (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )             // And is there a value in it?
            {
                chstrPATH = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);
            }
        }
        catch ( ... )
        {
            objpathParser.Free( pParsedPath );
            throw ;
        }

        // Clean up the Parsed Path
        objpathParser.Free( pParsedPath );
        fRet = true;
    }

    return fRet;
}


/*****************************************************************************
 *
 *  FUNCTION    : DeviceExists
 *
 *  DESCRIPTION : Internal helper to check if the given device exists.
 *
 *  INPUTS      : chstrDevice - name of prospecitive device.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : true if it exists; false otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32DeviceBus::DeviceExists(const CHString& chstrDevice, DWORD* pdwBusNumber, INTERFACE_TYPE* pitBusType)
{
    bool fRet = false;
    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pDevice(NULL);

    if(cfgmgr.LocateDevice(chstrDevice, &pDevice))
    {
        if(pDevice->GetBusInfo(pitBusType, pdwBusNumber))
        {
            fRet = true;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devicememory.cpp ===
//=================================================================

//

// DevMem.CPP --DevMem property set provider(Windows NT only)

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

#include "precomp.h"

#include <CRegCls.h>
#include "cHWRes.h"

#include "DeviceMemory.h"
#include "ntdevtosvcsearch.h"

#include <tchar.h>

// Property set declaration
//=========================

DevMem MyDevMemSet(PROPSET_NAME_DEVMEM, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::DevMem
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : bae class Registers property set with framework
 *
 *****************************************************************************/

DevMem::DevMem(

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::~DevMem
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

DevMem::~DevMem()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT DevMem::GetObject(

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hRetCode =  WBEM_E_NOT_FOUND;

    // This only has meaning for NT
    //=============================

#if NTONLY == 4

	CHWResource HardwareResource;

	LPRESOURCE_DESCRIPTOR pResourceDescriptor;

	// Create hardware resource list
	//==============================

	HardwareResource.CreateSystemResourceLists();

	// Find the starting address
	//==========================

	__int64 i64StartingAddress = 0;
	pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

	pResourceDescriptor = HardwareResource._SystemResourceList.MemoryHead;
	while(pResourceDescriptor != NULL)
	{
        LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

        liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
        liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

		if (liTemp.QuadPart == i64StartingAddress)
		{
			LoadPropertyValues(pInstance, pResourceDescriptor);
			hRetCode = WBEM_S_NO_ERROR;

			break;
		}

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

#endif

#if defined(WIN9XONLY) || NTONLY > 4

	__int64 i64StartingAddress = 0;
	pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

	CConfigManager CMgr(ResType_Mem);

    //=================================================================
    // Get the latest IO info from the Configuration Manager
    //=================================================================

    if (CMgr.RefreshList())
	{
#ifdef WIN9XONLY
        // This code is only used for 9x because the 9x Cfg Mgr reports all
        // ports it doesn't have information on as 'In use by unknown device'.
        CConfigMgrAPI *pCfgMgr =
                           (CConfigMgrAPI*) CResourceManager::sm_TheResourceManager.
                                GetResource(guidCFGMGRAPI, NULL);

        if (!pCfgMgr)
            return WBEM_E_NOT_FOUND;

        RANGE_LIST rl;

        // Get the list of all ranges currently allocated.
        // As we enum through devices, we'll remove the ranges each is using
        // so that we'll end up with the list of addresses that are allocated
        // but are being used by something not in the list of cfgmgr devices.
        // The code for Device Manager does the exact same thing.
        pCfgMgr->CM_Query_Arbitrator_Free_Data(
            &rl,
            sizeof(RANGE_LIST),
            NULL,
            ResType_Mem,
            0);
#endif

        for (int i = 0; i < CMgr.GetTotal(); i++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================
			MEM_INFO *pMemory = CMgr.GetMem(i);

			if (i64StartingAddress == pMemory->StartingAddress)
			{
                LoadPropertyValues(
                    pInstance,
                    pMemory->StartingAddress,
                    pMemory->EndingAddress);

#if NTONLY >= 5
                if (!pMemory->MemoryType.IsEmpty())
                {
                    pInstance->SetCHString(IDS_MemoryType, pMemory->MemoryType);
                }
#endif

				hRetCode = WBEM_S_NO_ERROR;

				break;
			}

#ifdef WIN9XONLY
            // Remove it from the range list.
            pCfgMgr->CM_Delete_Range(
                pMemory->StartingAddress,
                pMemory->EndingAddress,
                rl,
                0);
#endif
		}


#ifdef WIN9XONLY
        RANGE_ELEMENT   re;
        ULONG           ulStart,
                        ulEnd;

        if (hRetCode != WBEM_S_NO_ERROR &&
            pCfgMgr->CM_First_Range(rl, &ulStart, &ulEnd, &re, 0) == CR_SUCCESS)
        {
            do
            {
			    if (i64StartingAddress == ulStart)
			    {
                    LoadPropertyValues(pInstance, ulStart, ulEnd);

				    hRetCode = WBEM_S_NO_ERROR;

				    break;
			    }

            } while (pCfgMgr->CM_Next_Range(&re, &ulStart, &ulEnd, 0) ==
                CR_SUCCESS);
        }

        // Free the range list.
        pCfgMgr->CM_Delete_Range(0, 0xFFFFFFFF, rl, 0);
#endif
	}

#endif

    return hRetCode;
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT DevMem::EnumerateInstances(

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// This only has meaning for NT
	//=============================

#if NTONLY == 4

	CHWResource HardwareResource;
	LPRESOURCE_DESCRIPTOR pResourceDescriptor;

	// Create hardware resource list
	//==============================

	HardwareResource.CreateSystemResourceLists();

	// Traverse list & create instance for each device's memory
	//=========================================================

	pResourceDescriptor = HardwareResource._SystemResourceList.MemoryHead;
	if (pResourceDescriptor == NULL)
	{
		hr = WBEM_E_FAILED;
	}

	typedef std::map<__int64, bool> Type64bitLookup;

	Type64bitLookup t_Lookup;

	int n = 0;

	BOOL bFound = FALSE;

	while(pResourceDescriptor != NULL && SUCCEEDED(hr))
	{
		CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
		hr = LoadPropertyValues(pInstance, pResourceDescriptor);
		if (SUCCEEDED(hr))
		{
			__int64 i64StartingAddress = 0;
			pInstance->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

			if (!t_Lookup [ i64StartingAddress ])
			{
				t_Lookup [ i64StartingAddress ] = true;
				hr = pInstance->Commit();
			}
			else
			{
                // duplicate memory address
			}
		}

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

#endif

#if defined(WIN9XONLY) || NTONLY > 4

#ifdef WIN9XONLY
    // This code is only used for 9x because the 9x Cfg Mgr reports all
    // ports it doesn't have information on as 'In use by unknown device'.
    CConfigMgrAPI *pCfgMgr =
                       (CConfigMgrAPI*) CResourceManager::sm_TheResourceManager.
                            GetResource(guidCFGMGRAPI, NULL);

    if (!pCfgMgr)
        return WBEM_E_NOT_FOUND;

    RANGE_LIST rl;

    // Get the list of all ranges currently allocated.
    // As we enum through devices, we'll remove the ranges each is using
    // so that we'll end up with the list of addresses that are allocated
    // but are being used by something not in the list of cfgmgr devices.
    // The code for Device Manager does the exact same thing.
    pCfgMgr->CM_Query_Arbitrator_Free_Data(
        &rl,
        sizeof(RANGE_LIST),
        NULL,
        ResType_Mem,
        0);
#endif

    typedef std::map<DWORD_PTR, DWORD> DWORDPTR_2_DWORD;

	CConfigManager CMgr(ResType_Mem);

    //=================================================================
    // Get the latest IO info from the Configuration Manager
    //=================================================================
    if (CMgr.RefreshList())
	{
        DWORDPTR_2_DWORD mapAddrs;

        for (int i = 0; i < CMgr.GetTotal() && SUCCEEDED(hr); i ++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================

			MEM_INFO *pMemory = CMgr.GetMem(i);

            // If it's already in the map, skip it.
            if (mapAddrs.find(pMemory->StartingAddress) != mapAddrs.end())
                continue;

            // It wasn't in the map.
            // Set it so we don't try this port again.
		    mapAddrs[pMemory->StartingAddress] = 0;

			CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

			hr =
                LoadPropertyValues(
                    pInstance,
                    pMemory->StartingAddress,
                    pMemory->EndingAddress);

#if NTONLY >= 5
                if (!pMemory->MemoryType.IsEmpty())
                {
                    pInstance->SetCHString(IDS_MemoryType, pMemory->MemoryType);
                }
#endif

			if (SUCCEEDED(hr))
			{
				hr = pInstance->Commit();
			}

#ifdef WIN9XONLY
            // Remove it from the range list.
            pCfgMgr->CM_Delete_Range(
                pMemory->StartingAddress,
                pMemory->EndingAddress,
                rl,
                0);
#endif
		}


#ifdef WIN9XONLY
        // Loop through the remaining ranges.  These are classified as
        // unavailable to new devices by Device Mgr.
        RANGE_ELEMENT   re;
        ULONG           ulStart,
                        ulEnd;

        if (SUCCEEDED(hr) &&
            pCfgMgr->CM_First_Range(rl, &ulStart, &ulEnd, &re, 0) == CR_SUCCESS)
        {
            do
            {
                CInstancePtr pInstance(
                    CreateNewInstance(pMethodContext),
                    false);

                LoadPropertyValues(pInstance, ulStart, ulEnd);

                hr = pInstance->Commit();

            } while (pCfgMgr->CM_Next_Range(&re, &ulStart, &ulEnd, 0)
                == CR_SUCCESS && hr == WBEM_S_NO_ERROR);

            // Free the range list.
            pCfgMgr->CM_Delete_Range(0, 0xFFFFFFFF, rl, 0);
        }
#endif
	}

#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : DevMem::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties according to passed struct
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#if NTONLY == 4

HRESULT DevMem::LoadPropertyValues(

	CInstance *pInstance,
	LPRESOURCE_DESCRIPTOR pResourceDescriptor
)
{
    pInstance->SetCharSplat(IDS_Status, IDS_OK);

    LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

    pInstance->SetWBEMINT64(

		IDS_StartingAddress,
		liTemp.QuadPart
	);

    pInstance->SetWBEMINT64(

		IDS_EndingAddress,
		liTemp.QuadPart +(__int64)pResourceDescriptor->CmResourceDescriptor.u.Port.Length -(__int64)1
	);

    WCHAR szTemp [ _MAX_PATH ];

    swprintf(

		szTemp,
		IDS_RegAddressRange,
		liTemp.QuadPart,
		liTemp.QuadPart + pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1
	);

    pInstance->SetCharSplat(IDS_Caption, szTemp);

    pInstance->SetCharSplat(IDS_Name, szTemp);

    pInstance->SetCharSplat(IDS_Description, szTemp);

    SetCreationClassName(pInstance);

    pInstance->SetCHString(IDS_CSName, GetLocalComputerName());

    pInstance->SetCHString(IDS_CSCreationClassName, L"Win32_ComputerSystem");

    switch(pResourceDescriptor->CmResourceDescriptor.Flags)
	{
        case CM_RESOURCE_MEMORY_READ_WRITE :
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTReadWrite);
		}
		break;

        case CM_RESOURCE_MEMORY_READ_ONLY:
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTReadOnly);
		}
		break;

        case CM_RESOURCE_MEMORY_WRITE_ONLY:
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTWriteOnly);
		}
		break;

        case CM_RESOURCE_MEMORY_PREFETCHABLE:
		{
			pInstance->SetCharSplat(IDS_MemoryType, IDS_MTPrefetchable);
		}
		break;

		default:
		{
		}
		break;
    }

    return WBEM_S_NO_ERROR;
}

#endif

////////////////////////////////////////////////////////////////////////
//
//  Get Device Memory info for 9x
//
////////////////////////////////////////////////////////////////////////

#if defined(WIN9XONLY) || NTONLY > 4

HRESULT DevMem::LoadPropertyValues(
	CInstance *pInstance,
	DWORD_PTR dwBeginAddr,
    DWORD_PTR dwEndAddr)
{
	WCHAR szTemp[_MAX_PATH];

	// Easy properties
    SetCreationClassName(pInstance);
	pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
	pInstance->SetCHString(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
    pInstance->SetCharSplat(IDS_Status, IDS_OK);

	pInstance->SetWBEMINT64(IDS_StartingAddress, (__int64) dwBeginAddr);
	pInstance->SetWBEMINT64(IDS_EndingAddress, (__int64) dwEndAddr);

	swprintf(szTemp, IDS_RegStartingAddress, dwBeginAddr, dwEndAddr);

	pInstance->SetCharSplat(IDS_Caption, szTemp);
	pInstance->SetCHString(IDS_Name, szTemp);
	pInstance->SetCHString(IDS_Description, szTemp);

	return WBEM_NO_ERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devicememory.h ===
//=================================================================

//

// DevMem.h -- Device Memory property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//
//=================================================================

// Property set identification
//============================

#define PROPSET_NAME_DEVMEM L"Win32_DeviceMemoryAddress"

class DevMem:public Provider
{
public:

    // Constructor/destructor
    //=======================

    DevMem(LPCWSTR name, LPCWSTR pszNamespace) ;
   ~DevMem() ;

	HRESULT EnumerateInstances ( MethodContext *pMethodContext , long lFlags = 0L ) ;
	HRESULT GetObject ( CInstance *pInstance , long lFlags = 0L ) ;


    // Utility function(s)
    //====================

#if NTONLY == 4

    HRESULT LoadPropertyValues (

		CInstance *pInstance, 
		LPRESOURCE_DESCRIPTOR pResourceDescriptor
	) ;

#endif

#if defined(WIN9XONLY) || NTONLY > 4

	HRESULT LoadPropertyValues(
		CInstance *pInstance,
        DWORD_PTR dwBeginAddr,
        DWORD_PTR dwEndAddr);
#endif

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devbattery.h ===
//=================================================================

//

// DevBattery.h -- LogicalDevice to Battery

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    4/21/98    davwoh         Created
//
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_ASSOCBATTERY L"Win32_AssociatedBattery"

class CAssociatedBattery:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CAssociatedBattery(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CAssociatedBattery() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);

    private:
        HRESULT CAssociatedBattery::IsItThere(CInstance *pInstance);

        // Utility function(s)
        //====================

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devbattery.cpp ===
//=================================================================

//

// DevBattery.CPP -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    4/21/98    davwoh         Created
//
//
//=================================================================

#include "precomp.h"

#include "devBattery.h"

// Property set declaration
//=========================

CAssociatedBattery MyBattery(PROPSET_NAME_ASSOCBATTERY, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::CAssociatedBattery
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CAssociatedBattery::CAssociatedBattery(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::~CAssociatedBattery
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CAssociatedBattery::~CAssociatedBattery()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CAssociatedBattery::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
   CHString sBattery, sUPS;
   HRESULT hr = WBEM_E_NOT_FOUND;

   // Get the two paths
   pInstance->GetCHString(IDS_Antecedent, sBattery);
   pInstance->GetCHString(IDS_Dependent, sUPS);

   hr = IsItThere(pInstance);
   if (SUCCEEDED(hr)) {
      CHString sBattery2, sUPS2;

      pInstance->GetCHString(IDS_Antecedent, sBattery2);
      pInstance->GetCHString(IDS_Dependent, sUPS2);

      if ((sUPS.CompareNoCase(sUPS2) != 0) || (sBattery.CompareNoCase(sBattery2) != 0)) {
         hr = WBEM_E_NOT_FOUND;
      }
   }

   return hr;

}

/*****************************************************************************
 *
 *  FUNCTION    : CAssociatedBattery::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CAssociatedBattery::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr;

    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
    if (pInstance)
    {
        hr = IsItThere(pInstance);
        if (SUCCEEDED(hr))
        {
            hr = pInstance->Commit();
        }
        else
        {
            if (hr == WBEM_E_NOT_FOUND)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CAssociatedBattery::IsItThere(CInstance *pInstance)
{

   CHString sBatPath, sUPSPath, sTemp1, sTemp2;
   CInstancePtr pUPS;
   CInstancePtr pBattery;
   HRESULT hr = WBEM_E_NOT_FOUND;

   // Get list of Services
   //=====================
   sTemp1.Format(L"\\\\%s\\%s:Win32_UninterruptiblePowerSupply.DeviceID=\"%s\"", GetLocalComputerName(), IDS_CimWin32Namespace, IDS_UPSName);
   sTemp2.Format(L"\\\\%s\\%s:Win32_Battery.DeviceID=\"%s\"", GetLocalComputerName(), IDS_CimWin32Namespace, IDS_UPSBatteryName);

   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(sTemp1, &pUPS, pInstance->GetMethodContext())))   {
      if (SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath(sTemp2, &pBattery, pInstance->GetMethodContext()))) {

         GetLocalInstancePath(pUPS, sUPSPath);
         GetLocalInstancePath(pBattery, sBatPath);

         // Do the puts, and that's it
         pInstance->SetCHString(IDS_Dependent, sUPSPath);
         pInstance->SetCHString(IDS_Antecedent, sBatPath);

         hr = WBEM_S_NO_ERROR;
      }
   }

   return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devid.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DevID.h
//
//  Purpose: Relationship between Win32_PNPEntity and CIM_LogicalDevice
//
//***************************************************************************

// Property set identification
//============================

#define  PROPSET_NAME_PNPDEVICE L"Win32_PNPDevice"

class CWin32DeviceIdentity ;

class CWin32DeviceIdentity:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32DeviceIdentity(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DeviceIdentity() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devid.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DevID.cpp
//
//  Purpose: Relationship between Win32_PNPEntity and CIM_LogicalDevice
//
//  SameElement = win32_pnpdevice
//  SystemElement = cim_logicaldevice
//
//***************************************************************************

#include "precomp.h"

#include "devid.h"

// Property set declaration
//=========================

CWin32DeviceIdentity MyDevRes(PROPSET_NAME_PNPDEVICE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::CWin32DeviceIdentity
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DeviceIdentity::CWin32DeviceIdentity(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::~CWin32DeviceIdentity
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DeviceIdentity::~CWin32DeviceIdentity()
{
}

/*****************************************************************************
*
*  FUNCTION    : CWin32DeviceIdentity::ExecQuery
*
*  DESCRIPTION : Query support
*
*  INPUTS      : none
*
*  OUTPUTS     : none
*
*  RETURNS     : nothing
*
*  COMMENTS    : Since I can't know what DeviceID a given class has given a
*                particular PNPID, the only optimization I can do is if they
*                give me a CIM_LogicalDevice DeviceID, since I know that
*                the PNPDeviceID property of that device is populated (otherwise
*                the enumeration couldn't have found it).
*
*****************************************************************************/
HRESULT CWin32DeviceIdentity::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    CHStringArray saDevices;

    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    if (SUCCEEDED(pQuery.GetValuesForProp(IDS_SameElement, saDevices)) && (saDevices.GetSize() > 0))
    {
        CHString sPNPId, sPNPId2, sDevicePath, sTemp;
        CInstancePtr pDevice;

        hr = WBEM_S_NO_ERROR;

        for (int x=0; (x < saDevices.GetSize()) && SUCCEEDED(hr); x++)
        {
            // This GetInstanceByPath will both confirm the existence of the requested device,
            // and give us the pnpid.
            CHStringArray csaProperties;
            csaProperties.Add(IDS___Path);
            csaProperties.Add(IDS_DeviceID);
            csaProperties.Add(IDS_PNPDeviceID);

            if(SUCCEEDED(hr = CWbemProviderGlue::GetInstancePropertiesByPath(saDevices[x], &pDevice, pMethodContext, csaProperties)))
            {
                if (!pDevice->IsNull(IDS_PNPDeviceID) &&
                    !pDevice->IsNull(IDS___Path) &&
                    pDevice->GetCHString(IDS___Path, sDevicePath) &&
                    pDevice->GetCHString(IDS_PNPDeviceID, sPNPId))
                {
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

                    pInstance->SetCHString(IDS_SameElement, sDevicePath);

                    EscapeBackslashes(sPNPId, sPNPId2);
                    sTemp.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                        L"Win32_PnPEntity", IDS_DeviceID, sPNPId2);
                    pInstance->SetCHString(IDS_SystemElement, sTemp);

                    hr = pInstance->Commit();
                }
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceIdentity::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    CHString    sCimLogicalDevice,
                sPNPDevice,
                sDeviceID,
                sClass;
    HRESULT     hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pResource;

    // Get the two paths
    pInstance->GetCHString(IDS_SameElement, sCimLogicalDevice);
    pInstance->GetCHString(IDS_SystemElement, sPNPDevice);

    // Get the CIM_LogicalDevice.  This checks for existence, and gets us the pnpid.
    if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sCimLogicalDevice, &pResource, pInstance->GetMethodContext())))
    {
        ParsedObjectPath*    pParsedPath = 0;
        CObjectPathParser    objpathParser;

        hRet = WBEM_E_NOT_FOUND;

        // Parse the object path passed to us by CIMOM.  We do this to see if the
        // Win32_PNPDevice they passed us is the same as the one we got back from
        // the GetInstanceByPath.
        int nStatus = objpathParser.Parse( sPNPDevice,  &pParsedPath );

        if ( 0 == nStatus )                                                 // Did the parse succeed?
        {
            try
            {
                if ((pParsedPath->IsInstance()) &&                                  // Is the parsed object an instance?
                    (_wcsicmp(pParsedPath->m_pClass, L"Win32_PnPEntity") == 0) &&       // Is this the class we expect (no, cimom didn't check)
                    (pParsedPath->m_dwNumKeys == 1) &&                              // Does it have exactly one key
                    (pParsedPath->m_paKeys[0]) &&                                   // Is the keys pointer null (shouldn't happen)
                    ((pParsedPath->m_paKeys[0]->m_pName == NULL) ||                 // Key name not specified or
                    (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, IDS_DeviceID) == 0)) &&  // key name is the right value
                                                                                // (no, cimom doesn't do this for us).
                    (V_VT(&pParsedPath->m_paKeys[0]->m_vValue) == CIM_STRING) &&    // Check the variant type (no, cimom doesn't check this either)
                    (V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue) != NULL) )         // And is there a value in it?
                {
                    CHString sSeekPNPId, sPNPId;

                    if (pResource->GetCHString(IDS_PNPDeviceID, sPNPId))
                    {

                        sSeekPNPId = V_BSTR(&pParsedPath->m_paKeys[0]->m_vValue);

                        if (sSeekPNPId.CompareNoCase(sPNPId) == 0)
                        {
                            hRet = WBEM_S_NO_ERROR;
                        }
                    }

                }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw ;
            }

            // Clean up the Parsed Path
            objpathParser.Free( pParsedPath );
        }
    }

   // There are no properties to set, if the endpoints exist, we be done

   return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceIdentity::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceIdentity::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    CHString sDeviceID, sDeviceID2, sDevicePath, sTemp;
    HRESULT hr = WBEM_S_NO_ERROR;

   // Get list of Services
   //=====================
   TRefPointerCollection<CInstance> LDevices;

   // Find all the devices that have a pnp id, EXCEPT the ones from Win32_PNPDevice

   // PERF NOTE!  CIMOM still calls Win32_PNPDevices.  It just throws the instances away.  It MIGHT be faster to
   // call each of the classes individually.  On the other hand, by doing it this way, cimom launches multiple threads.
   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(
       L"SELECT __PATH, PNPDeviceID from CIM_LogicalDevice where (PNPDeviceID <> NULL) and (__Class <> \"Win32_PnPEntity\")",
       &LDevices,
       pMethodContext,
       IDS_CimWin32Namespace)))
	{
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pDevice;

      if (LDevices.BeginEnum(pos))
      {
         // Walk through the devices
         for (pDevice.Attach(LDevices.GetNext( pos )) ;
             (SUCCEEDED(hr)) && (pDevice != NULL) ;
              pDevice.Attach(LDevices.GetNext( pos )) )
         {

            // Get the id (to send to cfgmgr) and the path (to send back in 'SameElement')
            pDevice->GetCHString(IDS_PNPDeviceID, sDeviceID) ;
            pDevice->GetCHString(IDS___Path, sDevicePath) ;

            CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

            pInstance->SetCHString(IDS_SameElement, sDevicePath);

            EscapeBackslashes(sDeviceID, sDeviceID2);

            sTemp.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCWSTR) GetLocalComputerName(), IDS_CimWin32Namespace,
                L"Win32_PnPEntity", IDS_DeviceID, sDeviceID2);
            pInstance->SetCHString(IDS_SystemElement, sTemp);

            hr = pInstance->Commit();
         }

         LDevices.EndEnum();
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devbus.h ===
//=================================================================

//

// devbus.h -- cim_logicaldevice to win32_bus

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/23/98    davwoh         Created
//
// Comment: Relationship between device and bus
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_DEVICEBUS L"Win32_DeviceBus"

class CWin32DeviceBus ;

class CWin32DeviceBus: virtual public CWin32PNPEntity 
{
    public:

        // Constructor/destructor
        //=======================

       CWin32DeviceBus(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DeviceBus() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);

    protected:

        // Functions inherrited from CWin32PNPDevice:
        virtual HRESULT LoadPropertyValues(void* pv);
        virtual bool ShouldBaseCommit(void* pvData);

    private:

        bool ObjNameValid(LPCWSTR wstrObject, LPCWSTR wstrObjName, LPCWSTR wstrKeyName, CHString& chstrPATH);
        bool DeviceExists(const CHString& chstrDevice, DWORD* pdwBusNumber, INTERFACE_TYPE* itBusType);

} ;

// This derived class commits here, not in the base.
inline bool CWin32DeviceBus::ShouldBaseCommit(void* pvData) { return false; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devres.h ===
//=================================================================

//

// devres.h -- cim_logicaldevice to cim_systemresource

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/13/98    davwoh         Created
//
// Comment: Relationship between device and system resource
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_ALLOCATEDRESOURCE L"Win32_AllocatedResource"

class CWin32DeviceResource ;

class CWin32DeviceResource:public Provider 
{

    public:

        // Constructor/destructor
        //=======================

        CWin32DeviceResource(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DeviceResource() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags );

    protected:
        HRESULT CommitResourcesForDevice(CInstance *pLDevice, MethodContext *pMethodContext);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpinfo.cpp ===
//=================================================================

//

// DHCPInfo.cpp -- DHCPinfo provider for Windows '95

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:
//							a-brads			created
//
//				03/03/99    		syntactic clean up
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include "wsock32api.h"
#include "dhcpinfo.h"
#include "dhcpcsdk.h"


#ifdef WIN9XONLY
//
// TIME_ADJUST - DHCP uses seconds since 1980 as its time value; the C run-time
// uses seconds since 1970. To get the C run-times to produce the correct time
// given a DHCP time value, we need to add on the number of seconds elapsed
// between 1970 and 1980, which includes allowance for 2 leap years (1972 and 1976)
//

#define TIME_ADJUST(t)  ((time_t)(t) + ((time_t)(((10L * 365L) + 2L) * 24L * 60L * 60L)))

CDHCPInfo::CDHCPInfo ()
{
	m_pDhcpQueryInfo = NULL ;
	m_dwLeaseExpires = 0;
	m_dwLeaseObtained = 0;
	m_chsDHCPServer = _T("");

	m_pwsock32api = (CWsock32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWsock32Api, NULL);
	if ( ! m_pwsock32api )
	{
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}

	GatherDhcpNicInfo();
}

CDHCPInfo::~CDHCPInfo ()
{
	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWsock32Api, m_pwsock32api);

	ClearDhcpNicInfo() ;
}

BOOL CDHCPInfo::GetDHCPInfo ( BYTE *a_MACAddress )
{
	BOOL t_bRet = FALSE;

	if ( IsWin98() )
	{
		t_bRet = GetDHCPInfo98( a_MACAddress ) ;
	}
	else
	{
		t_bRet = GetDHCPInfo95( a_MACAddress ) ;
	}

	return t_bRet ;
}

BOOL CDHCPInfo::GetDHCPInfo95 ( BYTE *a_MACAddress )
{
	HKEY	t_hKey ;
	DWORD	t_dwByteCount		= 100 ;
	DWORD	t_dwType ;
	BYTE	t_bInfo[ 100 ] ;		// buffer for DHCPInfo
	BYTE	t_bMACAddress[ 6 ] ;	// buffer for MACAddress

	DWORD	t_dwDHCPServer		= 0 ;
	DWORD	t_dwLeaseObtained	= 0 ;
	DWORD	t_dwLeaseExpires	= 0 ;
	DWORD	t_dwMACAddress		= 0 ;
	DWORD	t_dwDhcpIndex		= 0 ;

	struct in_addr t_uAddr ;

	if( IsDhcpEnabled( a_MACAddress, t_dwDhcpIndex ) )
	{
		CRegistry t_Registry ;
		CHString t_csDHCPKey( _T("System\\CurrentControlSet\\Services\\VXD\\DHCP") ) ;
		CHString t_csDHCPInstKey ;

		if(ERROR_SUCCESS == t_Registry.OpenAndEnumerateSubKeys( HKEY_LOCAL_MACHINE, t_csDHCPKey, KEY_READ ) )
		{
			// Walk through each instance under this key.
			while (	( ERROR_SUCCESS == t_Registry.GetCurrentSubKeyName( t_csDHCPInstKey ) ) )
			{
				CHString t_csDHCPCompleteKey ;
						 t_csDHCPCompleteKey = t_csDHCPKey ;
						 t_csDHCPCompleteKey += _T("\\") ;
						 t_csDHCPCompleteKey += t_csDHCPInstKey ;


				// open registry key
				if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
													TOBSTRT( t_csDHCPCompleteKey ),
													0,
													KEY_READ,
													&t_hKey ) )
				{
					t_dwByteCount = 500 ;

					if ( ERROR_SUCCESS == RegQueryValueEx(	t_hKey,
															_T("DHCPInfo"),
															NULL,
															&t_dwType,
															(LPBYTE) &t_bInfo,
															&t_dwByteCount ) )
					{
						// now that we have the actual DHCPInfo thingy, we can parse it for
						// the useful information and store it for later
						//
						// Breakdown list of what we need from this info:
						//
						// DHCPLeaseExpires -- date time
						// DHCPLeaseObtained -- date time
						// DHCPServer -- IP Address
						// IPddress -- IP Address
						// IPSubnet -- IP Address
						// MACAddress -- conveniently stored here

						// now get the MAC Address
						memcpy( t_bMACAddress, &t_bInfo[ 45 ], 6 ) ;

						// is this the right adapter?
						for( int t_j = 0; t_j < 6; t_j++ )
						{
							if( t_bMACAddress[ t_j ] != a_MACAddress[ t_j ] )
							{
								goto next_key ;
							}
						}

						// now get the server address
						memcpy( &t_dwDHCPServer, &t_bInfo[ 12 ], 4 ) ;

						// now, get the lease obtained time
						memcpy( &t_dwLeaseObtained, &t_bInfo[ 24 ], 4 ) ;

						// now get the lease expires time
						memcpy( &t_dwLeaseExpires, &t_bInfo[ 36 ], 4 ) ;

						// now we need to do the conversions and save to the
						// data members so we can actually USE this information

						t_uAddr.s_addr = t_dwDHCPServer ;
						char *t_p = m_pwsock32api->Wsinet_ntoa (t_uAddr ) ;
						m_chsDHCPServer = t_p ;

						m_dwLeaseObtained = TIME_ADJUST( t_dwLeaseObtained ) ;
						m_dwLeaseExpires = TIME_ADJUST( t_dwLeaseExpires ) ;

						return TRUE ;
					}

	next_key:
					RegCloseKey( t_hKey ) ;
				}

				t_Registry.NextSubKey() ;
				continue ;
			}
		}
	}
	return FALSE ;

}

BOOL CDHCPInfo::GetDHCPInfo98 ( BYTE *a_MACAddress )
{
	BOOL		t_bIsEnabled = FALSE ;
	DWORD		t_dwDhcpIndex = 0 ;
	LPDWORD		t_pNicOffSet ;

	struct in_addr t_uAddr ;

	if( IsDhcpEnabled( a_MACAddress, t_dwDhcpIndex ) )
	{
		LPDHCP_NIC_INFO t_pDhcpInfo = &m_pDhcpQueryInfo->NicInfo[ t_dwDhcpIndex ] ;

		// Dhcp Server IP Address
		t_uAddr.s_addr = t_pDhcpInfo->DhcpServerAddress ;
		char *t_p = m_pwsock32api->Wsinet_ntoa ( t_uAddr ) ;
		m_chsDHCPServer = t_p ;

		// Lease obtained
		m_dwLeaseObtained = TIME_ADJUST( t_pDhcpInfo->LeaseObtainedTime ) ;

		// Lease expires
		m_dwLeaseExpires = TIME_ADJUST( t_pDhcpInfo->LeaseExpiresTime ) ;

		// DNS servers
		CHString t_Server ;

		t_pNicOffSet = (LPDWORD)( (LPBYTE)m_pDhcpQueryInfo + t_pDhcpInfo->OffsetDNSServers ) ;

		m_chsaDNServers.RemoveAll() ;

		for ( int i = 0; i < t_pDhcpInfo->DNSServersLen / sizeof(DWORD); i++ )
		{
			t_Server.Format( L"%d.%d.%d.%d",
							((LPBYTE)t_pNicOffSet)[0] & 0xff,
							((LPBYTE)t_pNicOffSet)[1] & 0xff,
							((LPBYTE)t_pNicOffSet)[2] & 0xff,
							((LPBYTE)t_pNicOffSet)[3] & 0xff ) ;

			*t_pNicOffSet++ ;

			m_chsaDNServers.Add( t_Server ) ;
		}

		GetDomainName( m_chsDnsDomain ) ;

		t_bIsEnabled = TRUE ;

	}
	return t_bIsEnabled ;
}

//
void CDHCPInfo::GatherDhcpNicInfo()
{
	SmartCloseHandle		t_hVxdHandle ;
	CHString	t_chsVxdPath( "\\\\.\\VDHCP" ) ;

	ClearDhcpNicInfo() ;

	//
	//  Open the device.
	//
	//  First try the name without the .VXD extension.  This will
	//  cause CreateFile to connect with the VxD if it is already
	//  loaded (CreateFile will not load the VxD in this case).

	t_hVxdHandle = CreateFile( bstr_t( t_chsVxdPath ),
							GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_DELETE_ON_CLOSE,
							NULL );

	if( t_hVxdHandle == INVALID_HANDLE_VALUE )
	{
		//
		//  Not found.  Append the .VXD extension and try again.
		//  This will cause CreateFile to load the VxD.

		t_chsVxdPath += ".VXD" ;
		t_hVxdHandle = CreateFile( bstr_t( t_chsVxdPath ),
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_EXISTING,
								FILE_FLAG_DELETE_ON_CLOSE,
								NULL );
	}

	DWORD t_dwResult = 0 ;
	if( t_hVxdHandle != INVALID_HANDLE_VALUE )
	{
		DWORD t_dwBytesRead ;
		DWORD t_dwSizeRequired = 1024 ;

		try
		{
			// Calling into this vxd with a request for buffer size
			// will overrun our DWORD buffer. The correct value is
			// returned but it trashes the stack. Therefore we begin
			// with a default 1k buffer and proceed from there.
			m_pDhcpQueryInfo = (LPDHCP_QUERYINFO) new BYTE[ t_dwSizeRequired ] ;

			if( m_pDhcpQueryInfo )
			{
				if( !DeviceIoControl( t_hVxdHandle,
										DHCP_QUERY_INFO,
										m_pDhcpQueryInfo,
										t_dwSizeRequired,
										m_pDhcpQueryInfo,
										t_dwSizeRequired,
										&t_dwBytesRead,
										NULL ) )
				{
					t_dwResult = GetLastError() ;
				}

				if( ERROR_BUFFER_OVERFLOW == t_dwResult && t_dwSizeRequired )
				{
					ClearDhcpNicInfo() ;

					m_pDhcpQueryInfo = (LPDHCP_QUERYINFO) new BYTE[ t_dwSizeRequired ] ;

					if( m_pDhcpQueryInfo )
					{
						// populate this structure
						//
						if( !DeviceIoControl( t_hVxdHandle,
												DHCP_QUERY_INFO,
												m_pDhcpQueryInfo,
												t_dwSizeRequired,
												m_pDhcpQueryInfo,
												t_dwSizeRequired,
												&t_dwBytesRead,
												NULL ) )
						{
							ClearDhcpNicInfo() ;

							t_dwResult = GetLastError() ;
						}
					}
				}
			}
		}
		catch( ... )
		{

			ClearDhcpNicInfo() ;

			throw ;
		}
	}
}

//
void CDHCPInfo::ClearDhcpNicInfo()
{
	if( m_pDhcpQueryInfo )
	{
		delete []m_pDhcpQueryInfo ;
		m_pDhcpQueryInfo = NULL ;
	}
}

//
BOOL CDHCPInfo::IsDhcpEnabled( BYTE *a_MACAddress, DWORD &a_dwDhcpIndex )
{
	BOOL			t_bEnabled = FALSE ;
	LPDHCP_NIC_INFO t_pDhcpInfo ;

	if( m_pDhcpQueryInfo )
	{
		// loop thru known DHCP adapters
		for ( DWORD dw = 0; dw < m_pDhcpQueryInfo->NumNICs; dw++ )
		{
			t_pDhcpInfo = &m_pDhcpQueryInfo->NicInfo[ dw ] ;

			// MAC address match
			if( !memcmp( a_MACAddress,
						(LPBYTE)m_pDhcpQueryInfo + t_pDhcpInfo->OffsetHardwareAddress,
						6 ) )
			{
				// need a valid IP to be enabled
				if ( ( INADDR_ANY != t_pDhcpInfo->IpAddress ) &&
					 ( INADDR_NONE != t_pDhcpInfo->IpAddress ) )
				{
					a_dwDhcpIndex = dw ;
					t_bEnabled = TRUE ;
				}
				break ;
			}
		}
	}

	return t_bEnabled ;
}

/*	GetDomainName() returns the 1st DHCP aware adapter that
	has a valid domain name. This is the current methodology
	used by IPconfig under 9x. This implies no multithomed
	DHCP support on these platforms.
*/
BOOL CDHCPInfo::GetDomainName( CHString &a_chsDnsDomain )
{
	BOOL			t_bHaveDomain = FALSE ;
	LPDHCP_NIC_INFO t_pDhcpInfo ;
	LPDWORD			t_pNicOffSet ;

	if( m_pDhcpQueryInfo )
	{
		// loop thru known DHCP adapters
		for ( DWORD dw = m_pDhcpQueryInfo->NumNICs; dw > 0; dw-- )
		{
			t_pDhcpInfo = &m_pDhcpQueryInfo->NicInfo[ dw - 1 ] ;

			// Domain name
			if( t_pDhcpInfo->DomainNameLen )
			{
				char	t_localHost[ 255 ] ;
				int		t_DomainLen ;

				t_pNicOffSet = (LPDWORD)( (LPBYTE)m_pDhcpQueryInfo + t_pDhcpInfo->OffsetDomainName ) ;
				t_DomainLen	 = min( t_pDhcpInfo->DomainNameLen, sizeof( t_localHost ) - 1 ) ;

				memcpy( &t_localHost, t_pNicOffSet, t_DomainLen ) ;

				t_localHost[ t_DomainLen ] = NULL ;

				a_chsDnsDomain = (char*) &t_localHost ;

				t_bHaveDomain = TRUE ;
				break;
			}
		}
	}
	return t_bHaveDomain ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\devres.cpp ===
//=================================================================

//

// devres.CPP -- cim_logicaldevice to cim_systemresource

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/13/98    davwoh         Created
//
// Comment: Relationship between device and system resource
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>

#include "devres.h"

// Property set declaration
//=========================

CWin32DeviceResource MyDevRes(PROPSET_NAME_ALLOCATEDRESOURCE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::CWin32DeviceResource
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DeviceResource::CWin32DeviceResource(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::~CWin32DeviceResource
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DeviceResource::~CWin32DeviceResource()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::ExecQuery
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceResource::ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags )
{
    CHStringArray saDevices;
    HRESULT hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    pQuery.GetValuesForProp(IDS_Dependent, saDevices);

    if (saDevices.GetSize() > 0)
    {
        // This GetInstanceByPath will both confirm the existence of the requested device,
        // and give us the pnpid.
        CHStringArray csaProperties;
        csaProperties.Add(IDS___Path);
        csaProperties.Add(IDS_PNPDeviceID);

        CInstancePtr pInstance;
        CHString sPNPId;

        hr = WBEM_S_NO_ERROR;

        for (int x=0; (x < saDevices.GetSize()) && SUCCEEDED(hr); x++)
        {
            hr = CWbemProviderGlue::GetInstancePropertiesByPath(saDevices[x], &pInstance, pMethodContext, csaProperties);
            if (SUCCEEDED(hr))
            {
                hr = CommitResourcesForDevice(pInstance, pMethodContext);
            }
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceResource::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
    CHString    sResource,
                sDevice,
                sDeviceID,
                sClass;
    HRESULT     hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pResource, pIDevice;

    // Get the two paths
    pInstance->GetCHString(IDS_Antecedent, sResource);
    pInstance->GetCHString(IDS_Dependent, sDevice);

    CHStringArray csaResource, csaDevice;

    csaResource.Add(IDS_IRQNumber);
    csaResource.Add(IDS_DMAChannel);
    csaResource.Add(IDS_StartingAddress);

    csaDevice.Add(IDS_PNPDeviceID);

    // If both ends are there
    if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstancePropertiesByPath((LPCWSTR) sResource,
        &pResource, pInstance->GetMethodContext(), csaResource)))
    {
        if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstancePropertiesByPath((LPCWSTR) sDevice,
            &pIDevice, pInstance->GetMethodContext(), csaDevice)))
        {
             hRet = WBEM_E_NOT_FOUND;  // Haven't proved anything yet.

             // Get the id (to send to cfgmgr)
             pIDevice->GetCHString(IDS_PNPDeviceID, sDeviceID) ;
             pResource->GetCHString(IDS___Class, sClass);

            CConfigManager	cfgManager;
            CDeviceCollection	deviceList;

            CConfigMgrDevicePtr pDevice;

            // Find the device
            if (cfgManager.LocateDevice(sDeviceID, &pDevice))
            {
                REFPTR_POSITION pos2;

                //------------------------------
                if (sClass.CompareNoCase(L"Win32_IRQResource") == 0)
                {
                    CIRQCollection irqList;

                    // Get the IRQs
                    pDevice->GetIRQResources(irqList);

                    if (irqList.BeginEnum(pos2))
                    {
                        CIRQDescriptorPtr pIRQ;
                        DWORD dwIRQSeeking;

                        pResource->GetDWORD(IDS_IRQNumber, dwIRQSeeking);

                        // Walk the irq's
                        for (pIRQ.Attach(irqList.GetNext(pos2));
                             pIRQ != NULL;
                             pIRQ.Attach(irqList.GetNext(pos2)))
                        {
                            if (pIRQ->GetInterrupt() == dwIRQSeeking)
                            {
                               hRet = WBEM_S_NO_ERROR;
                               break;
                            }
                        }
                   }
                //------------------------------
                }
                else if (sClass.CompareNoCase(L"Win32_DMAChannel") == 0)
                {
                    CDMACollection dmaList;

                    // Get the DMAs
                    pDevice->GetDMAResources(dmaList);

                    if (dmaList.BeginEnum(pos2))
                    {
                        CDMADescriptorPtr pDMA;
                        DWORD dwDMASeeking;

                        pResource->GetDWORD(IDS_DMAChannel, dwDMASeeking);

                        // Walk the dma's
                        for (pDMA.Attach(dmaList.GetNext(pos2));
                             pDMA != NULL;
                             pDMA.Attach(dmaList.GetNext(pos2)))
                        {
                            if (pDMA->GetChannel() == dwDMASeeking)
                            {
                               hRet = WBEM_S_NO_ERROR;
                               break;
                            }
                        }
                    }
             //------------------------------
             }
             else if (sClass.CompareNoCase(L"Win32_DeviceMemoryAddress") == 0)
             {

                CDeviceMemoryCollection DevMemList;

                // Get the DeviceMemory
                pDevice->GetDeviceMemoryResources( DevMemList );

                if ( DevMemList.BeginEnum(pos2))
                {
                    CDeviceMemoryDescriptorPtr pDeviceMemory;
                    __int64 i64StartingAddress;

                    pResource->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

                    // Walk the Device Memory
                    for (pDeviceMemory.Attach(DevMemList.GetNext(pos2));
                         pDeviceMemory != NULL;
                         pDeviceMemory.Attach(DevMemList.GetNext(pos2)))
                    {
                        if (pDeviceMemory->GetBaseAddress() == i64StartingAddress)
                        {
                           hRet = WBEM_S_NO_ERROR;
                           break;
                        }
                    }
                }
             }
             else if (sClass.CompareNoCase(L"Win32_PortResource") == 0)
             {
                CIOCollection ioList;

                // Get the IRQs
                pDevice->GetIOResources(ioList);

                if ( ioList.BeginEnum(pos2))
                {
                    CIODescriptorPtr pIO;
                    __int64 i64StartingAddress;

                    pResource->GetWBEMINT64(IDS_StartingAddress, i64StartingAddress);

                    // Walk the dma's
                    for (pIO.Attach(ioList.GetNext(pos2));
                         pIO != NULL;
                         pIO.Attach(ioList.GetNext(pos2)))
                    {
                        if (pIO->GetBaseAddress() == i64StartingAddress)
                        {
                           hRet = WBEM_S_NO_ERROR;
                           break;
                        }
                    }
                }
             }
             else
                 // Don't know what type of system resource this is
                 ASSERT_BREAK(0);
         }
      }
   }

   // There are no properties to set, if the endpoints exist, we be done

   return hRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DeviceResource::EnumerateInstances
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DeviceResource::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hr1 = WBEM_S_NO_ERROR;

    // Get list of Services
    //=====================
    TRefPointerCollection<CInstance> LDevices;

    // Find all the devices that have a pnp id
    hr1 = CWbemProviderGlue::GetInstancesByQuery(
        L"SELECT __PATH, PNPDeviceID from CIM_LogicalDevice where PNPDeviceID <> NULL and __Class <> 'Win32_PNPEntity'",
        &LDevices,
        pMethodContext,
        IDS_CimWin32Namespace);

    // Just becuase the call returned an error, doesn't mean it returned zero instances
    if (LDevices.GetSize() > 0)
    {
        REFPTRCOLLECTION_POSITION pos;
        CInstancePtr pLDevice;

        if (LDevices.BeginEnum(pos))
        {
            // Walk through the devices
            for (pLDevice.Attach(LDevices.GetNext( pos ));
                 SUCCEEDED(hr) && (pLDevice != NULL);
                 pLDevice.Attach(LDevices.GetNext( pos )))
            {
                hr = CommitResourcesForDevice(pLDevice, pMethodContext);
            }
        }

        LDevices.EndEnum();
    }

    // Cast away the sign, so 0x80000001 is considered greater then WBEM_S_NO_ERROR
    return (ULONG)hr > (ULONG)hr1 ? hr : hr1;
}

HRESULT CWin32DeviceResource::CommitResourcesForDevice(CInstance *pLDevice, MethodContext *pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR buff[MAXI64TOA];

    CHString sDeviceID, sDevicePath, sTemp;
    CIRQCollection irqList;
    CDMACollection dmaList;
    CDeviceMemoryCollection DevMemList;
    CIOCollection ioList;
    REFPTR_POSITION pos2;

    // Get the id (to send to cfgmgr) and the path (to send back in 'Dependent')
    pLDevice->GetCHString(IDS_PNPDeviceID, sDeviceID) ;
    pLDevice->GetCHString(IDS___Path, sDevicePath) ;

    CConfigManager	cfgManager;
    CDeviceCollection	deviceList;

    CConfigMgrDevicePtr pDevice;

    // Find the device
    if (cfgManager.LocateDevice(sDeviceID, &pDevice))
    {
        // Get the IRQs
        pDevice->GetIRQResources( irqList );

        if ( irqList.BeginEnum( pos2 ) )
        {
            CIRQDescriptorPtr pIRQ;

            // Walk the irq's
            for (pIRQ.Attach(irqList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pIRQ != NULL);
                 pIRQ.Attach(irqList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=%u",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_IRQResource",
                    IDS_IRQNumber,
                    pIRQ->GetInterrupt());

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }

        // Get DMAChannel
        pDevice->GetDMAResources( dmaList );

        if ( dmaList.BeginEnum( pos2 ) )
        {
            CDMADescriptorPtr pDMA;

            // Walk the Channels (or is that surf?)
            for (pDMA.Attach(dmaList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pDMA != NULL);
                 pDMA.Attach(dmaList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=%u",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_DMAChannel",
                    IDS_DMAChannel,
                    pDMA->GetChannel());

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }

        // Get DeviceMemory
        pDevice->GetDeviceMemoryResources( DevMemList );

        if ( DevMemList.BeginEnum( pos2 ) )
        {
            CDeviceMemoryDescriptorPtr pDeviceMemory;

            // Walk the memory resource
            for (pDeviceMemory.Attach(DevMemList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pDeviceMemory != NULL);
                 pDeviceMemory.Attach(DevMemList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=\"",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_DeviceMemoryAddress",
                    IDS_StartingAddress);

                sTemp += _i64tow(pDeviceMemory->GetBaseAddress(), buff, 10);
                sTemp += L'\"';

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }

        // Get IO Ports
        pDevice->GetIOResources( ioList );

        if ( ioList.BeginEnum( pos2 ) )
        {
            CIODescriptorPtr pIO;

            // Walk the ports
            for (pIO.Attach(ioList.GetNext( pos2 ));
                 SUCCEEDED(hr) && (pIO != NULL);
                 pIO.Attach(ioList.GetNext( pos2 )))
            {
                sTemp.Format(L"\\\\%s\\%s:%s.%s=\"",
                    (LPCWSTR)GetLocalComputerName(),
                    IDS_CimWin32Namespace,
                    L"Win32_PortResource",
                    IDS_StartingAddress);

                sTemp += _i64tow(pIO->GetBaseAddress(), buff, 10);
                sTemp += L'\"';

                // Do the puts, and that's it
                CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                pInstance->SetCHString(IDS_Antecedent, sTemp);
                pInstance->SetCHString(IDS_Dependent, sDevicePath);

                hr = pInstance->Commit();
            }
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\directory.h ===
//=================================================================

//

// Directory.h -- Directory property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

// Property set identification
//============================



#define  PROPSET_NAME_DIRECTORY L"Win32_Directory"


class CWin32Directory;


class CWin32Directory : public CImplement_LogicalFile 
{

    public:

        // Constructor/destructor
        //=======================

        CWin32Directory(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32Directory() ;


    protected:

#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               LPCSTR strFullPathName);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);
#endif

        // Overridable function inherrited from CProvider
        virtual void GetExtendedProperties(CInstance* pInstance, long lFlags = 0L);

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpinfo.h ===
//=================================================================

//

// DHCPInfo.h -- DHCPinfo provider for Windows '95

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    
//
//=================================================================

#ifndef __DHCPINFO_H_
#define __DHCPINFO_H_


#ifdef WIN9XONLY

typedef struct _DHCP_OPTION {
    UCHAR Tag;
    UCHAR Length;
    UCHAR Option[1];
} DHCP_OPTION, *PDHCP_OPTION;

// 9x VXD defines --- need to make reference to the appropriate NT header for these defines, etc. 
// this after the SourceDepot migration. 
#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3

typedef struct _DHCP_NIC_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
    DWORD IpAddress;
    DWORD Lease;
    DWORD LeaseObtainedTime;
    DWORD LeaseExpiresTime;
    DWORD DhcpServerAddress;
    DWORD DNSServersLen;
    DWORD OffsetDNSServers;
    DWORD DomainNameLen;
    DWORD OffsetDomainName;
} DHCP_NIC_INFO, *LPDHCP_NIC_INFO;

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

typedef struct _DHCP_QUERYINFO {
    DWORD NumNICs;
    DHCP_NIC_INFO NicInfo[1];
} DHCP_QUERYINFO, *LPDHCP_QUERYINFO;
// end 9x VXD defines

class CDHCPInfo
{
private:
	DWORD			m_dwLeaseExpires;
	DWORD			m_dwLeaseObtained;
	CHString		m_chsIPAddress;
	CHString		m_chsSubNetMask;
	CHString		m_chsDHCPServer;
	CHString		m_chsDnsDomain ;
	CHStringArray	m_chsaDNServers ;

	CWsock32Api		*m_pwsock32api ;
	DHCP_QUERYINFO	*m_pDhcpQueryInfo ;

	void GatherDhcpNicInfo() ;
	void ClearDhcpNicInfo() ;
	BOOL IsDhcpEnabled( BYTE *a_MACAddress, DWORD &a_dwDhcpIndex ) ;
	BOOL GetDomainName( CHString &a_chsDnsDomain ) ; 

protected:

public:
	CDHCPInfo ();
	~CDHCPInfo ();

	BOOL GetDHCPInfo(BYTE *a_MACAddress ) ;
	BOOL GetDHCPInfo95(BYTE *a_MACAddress ) ;
	BOOL GetDHCPInfo98(BYTE *a_MACAddress ) ;

	void GetDHCPServer ( CHString &a_csDHCPServer )
	{	a_csDHCPServer = m_chsDHCPServer ; }

	void GetDnsDomain (CHString &a_csDnsDomain )
	{	a_csDnsDomain = m_chsDnsDomain ; }

	void GetDnsServerList( CHStringArray **a_ppcsaDnsServerList )
	{	*a_ppcsaDnsServerList = &m_chsaDNServers ; }

	DWORD GetLeaseObtainedDate ()
	{	return m_dwLeaseObtained ;	}

	DWORD GetLeaseExpiresDate ()
	{	return m_dwLeaseExpires ;	}

};	// end class definition
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpcsvcapi.cpp ===
//=================================================================

//

// DHCPSvcAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#include <cominit.h>
#include "DhcpcsvcApi.h"
#include "DllWrapperCreatorReg.h"



// {E31A80D2-D12F-11d2-911F-0060081A46FD}
static const GUID g_guidDhcpcsvcApi =
{0xe31a80d2, 0xd12f, 0x11d2, {0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};



static const TCHAR g_tstrDhcpcsvc[] = _T("DHCPCSVC.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CDhcpcsvcApi, &g_guidDhcpcsvcApi, g_tstrDhcpcsvc> MyRegisteredDhcpcsvcWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CDhcpcsvcApi::CDhcpcsvcApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnDhcpAcquireParameters(NULL),
   m_pfnDhcpReleaseParameters(NULL),
   m_pfnDhcpNotifyConfigChange(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CDhcpcsvcApi::~CDhcpcsvcApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CDhcpcsvcApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnDhcpAcquireParameters = (PFN_DHCP_ACQUIRE_PARAMETERS)
                                       GetProcAddress("DhcpAcquireParameters");

        m_pfnDhcpReleaseParameters = (PFN_DHCP_RELEASE_PARAMETERS)
                                       GetProcAddress("DhcpReleaseParameters");

        m_pfnDhcpNotifyConfigChange = (PFN_DHCP_NOTIFY_CONFIG_CHANGE)
                                      GetProcAddress("DhcpNotifyConfigChange");
        // Check that we have function pointers to functions that should be
        // present...
        if(m_pfnDhcpAcquireParameters == NULL ||
           m_pfnDhcpReleaseParameters == NULL ||
           m_pfnDhcpNotifyConfigChange == NULL)
        {
            fRet = false;
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Dhcpcsvc api functions. Add new functions here
 * as required.
 ******************************************************************************/
DWORD CDhcpcsvcApi::DhcpAcquireParameters
(
    LPWSTR a_lpwstr
)
{
    return m_pfnDhcpAcquireParameters(a_lpwstr);
}

DWORD CDhcpcsvcApi::DhcpReleaseParameters
(
    LPWSTR a_lpwstr
)
{
    return m_pfnDhcpReleaseParameters(a_lpwstr);
}

DWORD CDhcpcsvcApi::DhcpNotifyConfigChange
(
    LPWSTR a_lpwstr1,
    LPWSTR a_lpwstr2,
    BOOL a_f,
    DWORD a_dw1,
    DWORD a_dw2,
    DWORD a_dw3,
    SERVICE_ENABLE a_se
)
{
    return m_pfnDhcpNotifyConfigChange(a_lpwstr1,
                                       a_lpwstr2,
                                       a_f,
                                       a_dw1,
                                       a_dw2,
                                       a_dw3,
                                       a_se);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dhcpcsvcapi.h ===
//=================================================================

//

// DhcpSvcApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_DHCPCSVCAPI_H_
#define	_DHCPCSVCAPI_H_



#ifndef _ENUM_SERVICE_ENABLE_DEFINED
#define _ENUM_SERVICE_ENABLE_DEFINED
typedef enum _SERVICE_ENABLE {
    IgnoreFlag,
    DhcpEnable,
    DhcpDisable
} SERVICE_ENABLE, *LPSERVICE_ENABLE;
#endif





/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidDhcpcsvcApi;
extern const TCHAR g_tstrDhcpcsvc[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef DWORD (APIENTRY *PFN_DHCP_ACQUIRE_PARAMETERS)
(
    LPWSTR
);

typedef DWORD (APIENTRY *PFN_DHCP_RELEASE_PARAMETERS)
(
    LPWSTR
);

typedef DWORD (APIENTRY *PFN_DHCP_NOTIFY_CONFIG_CHANGE)
(
    LPWSTR, 
    LPWSTR, 
    BOOL, 
    DWORD, 
    DWORD, 
    DWORD, 
    SERVICE_ENABLE
);





/******************************************************************************
 * Wrapper class for Dhcpcsvc load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CDhcpcsvcApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_DHCP_ACQUIRE_PARAMETERS m_pfnDhcpAcquireParameters;
    PFN_DHCP_RELEASE_PARAMETERS m_pfnDhcpReleaseParameters;
    PFN_DHCP_NOTIFY_CONFIG_CHANGE m_pfnDhcpNotifyConfigChange;

public:

    // Constructor and destructor:
    CDhcpcsvcApi(LPCTSTR a_tstrWrappedDllName);
    ~CDhcpcsvcApi();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Dhcpcsvc functions.
    // Add new functions here as required:
    DWORD DhcpAcquireParameters
    (
        LPWSTR a_lpwstr
    );

    DWORD DhcpReleaseParameters
    (
        LPWSTR a_lpwstr
    );

    DWORD DhcpNotifyConfigChange
    (
        LPWSTR a_lpwstr1, 
        LPWSTR a_lpwstr2, 
        BOOL a_f, 
        DWORD a_dw1, 
        DWORD a_dw2, 
        DWORD a_dw3, 
        SERVICE_ENABLE a_se
    );

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\directory.cpp ===
//=================================================================

//

// Directory.CPP -- Directory property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/16/98    a-kevhu         Created
//
//=================================================================

#include "precomp.h"
#include "File.h"
#include "Implement_LogicalFile.h"
#include "Directory.h"

// Property set declaration
//=========================

CWin32Directory MyDirectorySet ( PROPSET_NAME_DIRECTORY , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::CWin32Directory
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32Directory::CWin32Directory (

	LPCWSTR setName,
	LPCWSTR pszNamespace

) : CImplement_LogicalFile ( setName , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::~CWin32Directory
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32Directory::~CWin32Directory()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32Directory::IsOneOfMe
 *
 *  DESCRIPTION : The guts of this class, actually.  IsOneOfMe is inherrited
 *                from CImplement_LogicalFile.  That class returns files or
 *                directories where this one should only return directories,
 *                in response to queries, getobject commands, etc.  It is
 *                overridden here to return TRUE only if the file (the
 *                information for which is contained in the function arguement
 *                pstFindData) is of type directory.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE or FALSE
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/


#ifdef NTONLY
BOOL CWin32Directory::IsOneOfMe (

	LPWIN32_FIND_DATAW pstFindData,
    const WCHAR* wstrFullPathName
)
{
    BOOL fRet = FALSE;

    // It is possible, in the case of the root directory, that pstFindData was NULL,
    // in which case wstrFullPathName should contain "<driveletter>:\\".  If all that
    // is true, this was one of us - namely, the root "directory".

    if ( pstFindData == NULL )
    {
        if ( wcslen ( wstrFullPathName ) == 2 )
        {
            fRet = TRUE;
        }
    }
    else
    {
        fRet = ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ? TRUE : FALSE ;
    }

    return fRet;
}
#endif


#ifdef WIN9XONLY
BOOL CWin32Directory::IsOneOfMe (

	LPWIN32_FIND_DATAA pstFindData,
    LPCSTR strFullPathName
)
{
    BOOL fRet = FALSE;

    //CHAR* pc = NULL;
    // It is possible, in the case of the root directory, that pstFindData was NULL,
    // in which case wstrFullPathName should contain "<driveletter>:\\".  If all that
    // is true, this was one of us - namely, the root "directory".
    if ( pstFindData == NULL )
    {
        if( strlen ( strFullPathName ) == 2 )
        {
            fRet = TRUE ;
        }
    }
    else
    {
        fRet = ( pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ? TRUE : FALSE ;
    }
    return fRet;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CCIMDataFile::GetExtendedProperties
 *
 *  DESCRIPTION : Sets properties unique to this provider (not common to all
 *                CImplement_LogicalFile derived classes).
 *
 *  INPUTS      : CInstance pointer and flags
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
void CWin32Directory :: GetExtendedProperties (

	CInstance* pInstance,
    long lFlags
)
{
#ifdef WIN9XONLY

    // Here we just want to reset to null the LastModified and LastAccessed properties
    // if the os is not NT, as these properties, though populated on 95, are incorrect
    // (for directories).  They are set to, and always stay the date the directory was
    // first created.

	pInstance->SetNull ( IDS_LastAccessed ) ;
    pInstance->SetNull ( IDS_LastModified ) ;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\diskdrive.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DiskDrive.CPP
//
//  Purpose: Disk Drive instance provider
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <frqueryex.h>
#include "wmiapi.h"

#include <setupapi.h>

#include <winioctl.h>
#include <ntddscsi.h>

#include "diskdrive.h"
#include "computersystem.h"
#include "resource.h"

#ifdef WIN9XONLY
#include <win32thk.h>
#endif

#define BIT_ALL_PROPS                    0xFFFFFFFF

#define BIT_Model                   0x00000001
#define BIT_Partitions              0x00000002
#define BIT_Name                    0x00000004
#define BIT_Index                   0x00000008
#define BIT_CreationClassName       0x00000010
#define BIT_SystemCreationClassName 0x00000020
#define BIT_SystemName              0x00000040
#define BIT_Status                  0x00000080
#define BIT_Caption                 0x00000100
#define BIT_TotalHeads              0x00000200
#define BIT_TracksPerCylinder       0x00000400
#define BIT_SectorsPerTrack         0x00000800
#define BIT_BytesPerSector          0x00001000
#define BIT_TotalCylinders          0x00002000
#define BIT_TotalTracks             0x00004000
#define BIT_TotalSectors            0x00008000
#define BIT_Size                    0x00010000
#define BIT_MediaType               0x00020000
#define BIT_MediaLoaded             0x00040000
#define BIT_Capabilities            0x00080000
#define BIT_Description             0x00100000
#define BIT_InterfaceType           0x00200000
#define BIT_SCSIPort                0x00400000
#define BIT_SCSIBus                 0x00800000
#define BIT_SCSITargetID            0x01000000
#define BIT_SCSILogicalUnit         0x02000000
#define BIT_Manufacturer            0x04000000
#define BIT_PNPDeviceID             0x08000000
#define BIT_ConfigManagerUserConfig 0x10000000
#define BIT_ConfigManagerErrorCode  0x20000000
#define BIT_Signature               0x40000000

// Property set declaration
//=========================

CWin32DiskDrive MyWin32DiskDriveSet ( PROPSET_NAME_DISKDRIVE , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::CWin32DiskDrive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DiskDrive :: CWin32DiskDrive (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
    m_ptrProperties.SetSize(31);

//  m_ptrProperties[0] = ((LPVOID) IDS_DeviceID);  // Key is always set
    m_ptrProperties[0] = ((LPVOID) IDS_Model);
    m_ptrProperties[1] = ((LPVOID) IDS_Partitions);
    m_ptrProperties[2] = ((LPVOID) IDS_Name);
    m_ptrProperties[3] = ((LPVOID) IDS_Index);
    m_ptrProperties[4] = ((LPVOID) IDS_CreationClassName);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_Status);
    m_ptrProperties[8] = ((LPVOID) IDS_Caption);
    m_ptrProperties[9] = ((LPVOID) IDS_TotalHeads);
    m_ptrProperties[10] = ((LPVOID) IDS_TracksPerCylinder);
    m_ptrProperties[11] = ((LPVOID) IDS_SectorsPerTrack);
    m_ptrProperties[12] = ((LPVOID) IDS_BytesPerSector);
    m_ptrProperties[13] = ((LPVOID) IDS_TotalCylinders);
    m_ptrProperties[14] = ((LPVOID) IDS_TotalTracks);
    m_ptrProperties[15] = ((LPVOID) IDS_TotalSectors);
    m_ptrProperties[16] = ((LPVOID) IDS_Size);
    m_ptrProperties[17] = ((LPVOID) IDS_MediaType);
    m_ptrProperties[18] = ((LPVOID) IDS_MediaLoaded);
    m_ptrProperties[19] = ((LPVOID) IDS_Capabilities);
    m_ptrProperties[20] = ((LPVOID) IDS_Description);
    m_ptrProperties[21] = ((LPVOID) IDS_InterfaceType);
    m_ptrProperties[22] = ((LPVOID) IDS_SCSIPort);
    m_ptrProperties[23] = ((LPVOID) IDS_SCSIBus);
    m_ptrProperties[24] = ((LPVOID) IDS_SCSITargetID);
    m_ptrProperties[25] = ((LPVOID) IDS_SCSILogicalUnit);
    m_ptrProperties[26] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[27] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[28] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[29] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[30] = ((LPVOID) IDS_Signature);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::~CWin32DiskDrive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DiskDrive::~CWin32DiskDrive()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32DiskDrive :: ExecQuery (

	MethodContext *pMethodContext,
    CFrameworkQuery &pQuery,
	long lFlags /*= 0L*/
)
{

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    return Enumerate(pMethodContext, lFlags, dwProperties);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                from pInstance
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskDrive :: GetObject (

	CInstance *pInstance,
	long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT	hRetCode = WBEM_E_NOT_FOUND ;

    // Find out which one they want

	CHString sDeviceID ;
    pInstance->GetCHString ( IDS_DeviceID , sDeviceID ) ;

    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);

    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

#ifdef NTONLY
	// Parse off the index

	if ( sDeviceID.Left(17).CompareNoCase ( _T("\\\\.\\PHYSICALDRIVE") ) == 0 )
	{
		CHString sTemp = sDeviceID.Mid(17) ;

		if ( ( ! sTemp.IsEmpty () ) && ( _istdigit ( sTemp [ 0 ] ) ) )
		{
			DWORD dwRequestedIndex = _ttoi ( sTemp ) ;

// sanity check: gotta have right number of digits, etc...

			int length = sTemp.GetLength () ;

			BOOL t_Status = ( \
								( ( dwRequestedIndex < 10 ) && ( length == 1 ) ) || \
								( ( dwRequestedIndex > 9  ) && ( dwRequestedIndex < 100  )  && ( length == 2 ) ) || \
								( ( dwRequestedIndex > 99 ) && ( dwRequestedIndex < 1000 )  && ( length == 3 ) ) \
							) ;

			if ( t_Status )
			{
				hRetCode = GetPhysDiskInfoNT ( pInstance , sDeviceID, dwRequestedIndex, dwProperties, FALSE ) ;
			}
		}
	}

#endif

#ifdef WIN9XONLY


	CConfigManager configMgr;

    CConfigMgrDevicePtr pDevice;
	if ( configMgr.LocateDevice ( sDeviceID, &pDevice ) )
	{
		if	( pDevice->IsClass ( L"DiskDrive" ) )
		{

// Ok, it's a hard drive.  Is it removable?


			BYTE bRemovable;
            DWORD dwSize = sizeof(bRemovable);

            CRegistry RegInfo;
            CHString sKeyName;
            pDevice->GetRegistryKeyName(sKeyName);

            DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_QUERY_VALUE);
            if (dwRet == ERROR_SUCCESS)
            {
                dwRet = RegInfo.GetCurrentBinaryKeyValue(L"Removable", &bRemovable, &dwSize);
            }

			if ( ( dwRet != ERROR_SUCCESS ) || ( bRemovable != 1) )
			{

// No, it's not removable

// Get the pointers to the int13 thunking functions.

				CCim32NetApi *t_pCim32NetApi = HoldSingleCim32NetPtr::GetCim32NetApiPtr () ;
				if ( t_pCim32NetApi )
				{
					try
					{
						hRetCode = GetPhysDiskInfoWin95 (

							pDevice ,
							pInstance ,
							sDeviceID ,
							t_pCim32NetApi,
                            RegInfo,
                            dwProperties
						) ;
					}
					catch ( ... )
					{
						CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;

						throw ;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
				}
				else
				{
					hRetCode = WBEM_E_PROVIDER_FAILURE ;
				}
			}
		}
	}

#endif

    return hRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each physical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskDrive :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags, BIT_ALL_PROPS);
}

HRESULT CWin32DiskDrive::Enumerate(
	MethodContext *pMethodContext,
	long lFlags,
    DWORD dwProperties)
{
    HRESULT	hres = WBEM_E_FAILED;

#ifdef NTONLY

	HDEVINFO					DeviceInfoSet	= INVALID_HANDLE_VALUE;
	SP_DEVINFO_DATA				DeviceInfoData;
	SP_INTERFACE_DEVICE_DATA	DeviceInterfaceData;

	::ZeroMemory ( &DeviceInfoData, sizeof ( SP_DEVINFO_DATA ) );
	DeviceInfoData.cbSize = sizeof ( SP_DEVINFO_DATA );

	::ZeroMemory ( &DeviceInterfaceData, sizeof ( SP_INTERFACE_DEVICE_DATA ) );
	DeviceInterfaceData.cbSize	= sizeof ( SP_INTERFACE_DEVICE_DATA );

	GUID		ClassGuid		= GUID_DEVINTERFACE_DISK;
	DWORD		MemberIndex		= 0;

	// get device list
	DeviceInfoSet = SetupDiGetClassDevs	(	&ClassGuid, 
											NULL, 
											NULL, 
											DIGCF_INTERFACEDEVICE
										);

	if ( DeviceInfoSet != INVALID_HANDLE_VALUE )
	{
		BOOL bContinue = TRUE;
		hres = WBEM_S_NO_ERROR;

		// enumerate list
		while (bContinue && SetupDiEnumDeviceInterfaces	(	DeviceInfoSet,
												NULL,
												&ClassGuid,
												MemberIndex,
												&DeviceInterfaceData
											)
			  )
		{
			PSP_INTERFACE_DEVICE_DETAIL_DATA	pDeviceInterfaceDetailData		= NULL;
			DWORD								DeviceInterfaceDetailDataSize	= 0L;
			DWORD								RequiredSize					= 0L;

			if ( ! SetupDiGetDeviceInterfaceDetail	(	DeviceInfoSet,
														&DeviceInterfaceData, 
														NULL,
														0, 
														&RequiredSize,
														&DeviceInfoData
													))
			{
				if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
				{
					DeviceInterfaceDetailDataSize = RequiredSize;
					BYTE* data = NULL;

					try
					{
						if ( ( data = new BYTE [RequiredSize] ) == NULL )
						{
							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
						}

						pDeviceInterfaceDetailData = reinterpret_cast < PSP_INTERFACE_DEVICE_DETAIL_DATA > ( data );
					}
					catch ( ... )
					{
						// clear resources
						SetupDiDestroyDeviceInfoList ( DeviceInfoSet );

						throw;
					}
				}
				else
				{
					bContinue = FALSE;
				}
			}

			if ( bContinue )
			{
				// set size
				pDeviceInterfaceDetailData->cbSize = sizeof ( SP_INTERFACE_DEVICE_DETAIL_DATA );

				if ( ! SetupDiGetDeviceInterfaceDetail	(	DeviceInfoSet,
															&DeviceInterfaceData, 
															pDeviceInterfaceDetailData,
															DeviceInterfaceDetailDataSize, 
															&RequiredSize,
															&DeviceInfoData
														))
				{
					bContinue = FALSE;
				}
				else
				{
					try
					{
						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
						HRESULT	hresTemp = GetPhysDiskInfoNT ( pInstance, pDeviceInterfaceDetailData->DevicePath, MemberIndex, dwProperties, TRUE ) ;
						if ( SUCCEEDED ( hresTemp ) )
						{
							hres = pInstance->Commit (  ) ;

							if FAILED ( hres )
							{
								bContinue = FALSE;
							}
						}
					}
					catch ( ... )
					{
						// clear resource
						if (pDeviceInterfaceDetailData)
						{
							delete [] reinterpret_cast < BYTE* > (pDeviceInterfaceDetailData);
							pDeviceInterfaceDetailData = NULL;
						}

						DeviceInterfaceDetailDataSize = 0L;

						// clear resources
						SetupDiDestroyDeviceInfoList ( DeviceInfoSet );

						throw;
					}

					MemberIndex++;
				}

				DeviceInterfaceDetailDataSize = 0L;
			}

			if (pDeviceInterfaceDetailData)
			{
				delete [] reinterpret_cast < BYTE* > (pDeviceInterfaceDetailData);
				pDeviceInterfaceDetailData = NULL;
			}
		}

		// is it error ?
		if ( ERROR_NO_MORE_ITEMS != ::GetLastError () )
		{
			hres = WBEM_E_FAILED;
		}

		// clear resources
		SetupDiDestroyDeviceInfoList ( DeviceInfoSet );
	}

#endif

#ifdef WIN9XONLY

    CConfigManager cfgmgr;
    CDeviceCollection deviceList;

    // Get all the disk drives.  Note that this includes floppies and cd's

    cfgmgr.GetDeviceListFilterByClass ( deviceList , L"DiskDrive" ) ;

    // Walk the list

    REFPTR_POSITION pos ;

    if ( deviceList.BeginEnum ( pos ) )
    {
        // Get the pointers to the int13 thunking functions.

		CCim32NetApi *t_pCim32NetApi = HoldSingleCim32NetPtr::GetCim32NetApiPtr () ;
		if ( t_pCim32NetApi )
		{
			try
			{
				CConfigMgrDevicePtr pDisk;
				hres = WBEM_S_NO_ERROR;

				for ( pDisk.Attach(deviceList.GetNext ( pos ) ) ;
                    ( SUCCEEDED ( hres ) ) && ( pDisk != NULL ) ;
                    pDisk.Attach(deviceList.GetNext ( pos ) ) )
				{
					// Is it removable?  We don't want floppies or cd's.

					BYTE bRemovable;
                    DWORD dwSize = sizeof(bRemovable);

                    CRegistry RegInfo;
                    CHString sKeyName;
                    pDisk->GetRegistryKeyName(sKeyName);

                    DWORD dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_QUERY_VALUE);
                    if (dwRet == ERROR_SUCCESS)
                    {
                        dwRet = RegInfo.GetCurrentBinaryKeyValue(L"Removable", &bRemovable, &dwSize);
                    }

					if ( ( dwRet != ERROR_SUCCESS) || ( bRemovable != 1) )
					{
						// Get the pnpID

						CHString strDeviceID ;
						pDisk->GetDeviceID(strDeviceID);

						// Build the instance

						CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
						pInstance->SetCHString ( IDS_DeviceID , strDeviceID ) ;

						hres = GetPhysDiskInfoWin95 (

							pDisk,
							pInstance,
							strDeviceID,
							t_pCim32NetApi,
                            RegInfo,
                            dwProperties
						) ;

						if ( SUCCEEDED ( hres ) )
						{
							hres = pInstance->Commit ( ) ;
						}
					}
				}
			}
			catch ( ... )
			{
				CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;

				throw ;
			}

			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
		}
		else
		{
			hres = WBEM_E_PROVIDER_FAILURE ;
		}
	}
#endif

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::GetPhysDiskInfoNT
 *
 *  DESCRIPTION : Retrieves property values for physical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32DiskDrive::GetPhysDiskInfoNT (

	CInstance *pInstance,
    LPCWSTR lpwszDiskSpec,
    DWORD dwIndex,
	DWORD dwProperties,
	BOOL bGetIndex
)
{
	HRESULT hres = WBEM_S_NO_ERROR ;

	// Get handle to physical drive
	//=============================

	SetCreationClassName(pInstance);

	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;
    pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , PROPSET_NAME_COMPSYS ) ;
    pInstance->SetWCHARSplat ( IDS_Status , IDS_OK ) ;

	SmartCloseHandle hDiskHandle = CreateFile (

		lpwszDiskSpec,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		0
	) ;

	DWORD dwErr = GetLastError () ;

	if ( hDiskHandle == INVALID_HANDLE_VALUE && dwErr == ERROR_ACCESS_DENIED )
	{
		hDiskHandle = CreateFile (

			lpwszDiskSpec,
			0,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			0,
			0
		) ;

		dwErr = GetLastError () ;
	}

	if (bGetIndex)
	{
		if ( hDiskHandle != INVALID_HANDLE_VALUE )
		{
			DWORD                   dwBytesReturned = 0;
			STORAGE_DEVICE_NUMBER   StorageDevNum;

			//send an IOCTL_STORAGE_GET_DEVICE_NUMBER to the drive using DeviceIoControl and the handle to the drive
			if ( DeviceIoControl (
									hDiskHandle,						// handle to device
									IOCTL_STORAGE_GET_DEVICE_NUMBER,	// operation
									NULL,								// input data buffer - we have none, so passing NULL
									0,									// size of input data buffer - we have none, so passing 0
									&StorageDevNum,						// output data buffer
									sizeof ( STORAGE_DEVICE_NUMBER ),	// size of output data buffer
									&dwBytesReturned,					// byte count
									NULL								// overlapped information
								 ))
			{

				pInstance->SetDWORD ( IDS_Index , StorageDevNum.DeviceNumber ) ;

				CHString	wszDiskSpec ( L"\\\\.\\PHYSICALDRIVE" );
				WCHAR		wszNumber [ 32 ] = { L'\0' };

				_itow ( StorageDevNum.DeviceNumber, wszNumber, 10 );
				wszDiskSpec += wszNumber;

				pInstance->SetCHString ( IDS_DeviceID , wszDiskSpec) ;
				pInstance->SetCHString ( IDS_Caption , wszDiskSpec ) ;
				pInstance->SetCHString ( IDS_Name , wszDiskSpec ) ;
				pInstance->SetCHString ( IDS_Description , wszDiskSpec ) ;
			}
		}
	}
	else
	{
		pInstance->SetDWORD ( IDS_Index , dwIndex ) ;
		pInstance->SetCHString ( IDS_DeviceID , lpwszDiskSpec) ;
		pInstance->SetCHString ( IDS_Caption , lpwszDiskSpec ) ;
		pInstance->SetCHString ( IDS_Name , lpwszDiskSpec ) ;
		pInstance->SetCHString ( IDS_Description , lpwszDiskSpec ) ;
	}

#if NTONLY >= 5

    if ( (hDiskHandle != INVALID_HANDLE_VALUE) &&
        (dwProperties &
            (BIT_Description |
             BIT_Caption |
             BIT_Model |
             BIT_Manufacturer |
             BIT_PNPDeviceID |
             BIT_MediaLoaded |
             BIT_InterfaceType |
             BIT_Status |
             BIT_ConfigManagerErrorCode |
             BIT_ConfigManagerUserConfig)) )
    {

        CHString sTemp;
        if (GetPNPDeviceIDFromHandle(hDiskHandle, sTemp))
        {
            CConfigManager configMgr;

            CConfigMgrDevicePtr pDevice;
	        if ( configMgr.LocateDevice ( sTemp, &pDevice ) )
	        {
                if (dwProperties & BIT_InterfaceType)
                {
                    SetInterfaceType(pInstance, pDevice);
                }

                if (dwProperties &
                     (BIT_PNPDeviceID |
                     BIT_ConfigManagerErrorCode |
                     BIT_ConfigManagerUserConfig))
                {
                    SetConfigMgrProperties(pDevice, pInstance);
                }

                if ( (dwProperties & (BIT_Description | BIT_Caption)) && (pDevice->GetDeviceDesc(sTemp) ))
	            {
                    pInstance->SetCHString ( IDS_Description , sTemp ) ;
    	            pInstance->SetCHString ( IDS_Caption , sTemp ) ;
                }

                if ((dwProperties & (BIT_Caption | BIT_Model)) && (pDevice->GetFriendlyName(sTemp)) )
                {
    	            pInstance->SetCHString ( IDS_Caption , sTemp ) ;
                    pInstance->SetCHString ( IDS_Model , sTemp ) ;
                }

                if ((dwProperties & BIT_Manufacturer) && (pDevice->GetMfg(sTemp)))
                {
                    pInstance->SetCHString(IDS_Manufacturer, sTemp);
                }

                if ((dwProperties & BIT_Status) && (pDevice->GetStatus(sTemp)))
                {
		            pInstance->SetCHString ( IDS_Status , sTemp ) ;
	            }
            }
        }
    }

#endif

	if (( hDiskHandle != INVALID_HANDLE_VALUE ) || (dwErr == ERROR_ACCESS_DENIED))
	{
        if ((dwProperties & (BIT_Partitions|BIT_Signature|BIT_MediaLoaded)) && (hDiskHandle != INVALID_HANDLE_VALUE))
        {
			 // Get other resources we'll need
			 //===============================

			DWORD dwByteCount =	sizeof(DRIVE_LAYOUT_INFORMATION) -
									sizeof(PARTITION_INFORMATION) +
									128 * sizeof(PARTITION_INFORMATION ) ;

			DRIVE_LAYOUT_INFORMATION *DriveLayout = reinterpret_cast < DRIVE_LAYOUT_INFORMATION * > ( new char [ dwByteCount ] ) ;

   			if ( DriveLayout )
			{
				try
				{
					BOOL t_Status = DeviceIoControl (

						hDiskHandle ,
						IOCTL_DISK_GET_DRIVE_LAYOUT ,
						NULL ,
						0 ,
						DriveLayout ,
						dwByteCount ,
						&dwByteCount ,
						NULL
					) ;

					if ( t_Status )
					{
// MS documentation says we get an entry in PartitionEntry for each
// disk partition.  What we really get is an entry for each slot in
// the disk's partition table -- some used, some not.  Not knowing
// in advance how many slots there are in the table, (at the time of
// this writing, 8 is the most I've seen), I'm going to allow space
// for a 64-entry partition table (about 2k).  It'll be interesting
// to see how long it takes to find a disk exceeding this limit.
//==================================================================
// Well, we're there.  GPT disks can have 128 partitions.
//==================================================================
						if (dwProperties & BIT_Partitions)
						{
							DWORD dwPartitions = 0 ;
							for ( DWORD i = 0 ; i < DriveLayout->PartitionCount ; i ++ )
							{
								if ( DriveLayout->PartitionEntry[i].RecognizedPartition )
								{
									dwPartitions ++ ;
								}
							}

							pInstance->SetDWORD(IDS_Partitions, dwPartitions ) ;
						}

						if (dwProperties & BIT_Signature)
						{
							pInstance->SetDWORD(IDS_Signature, DriveLayout->Signature ) ;
						}

						if (dwProperties & BIT_MediaLoaded)
						{
							pInstance->Setbool(IDS_MediaLoaded, TRUE );
						}
					}
					else
					{
						if (dwProperties & BIT_MediaLoaded)
						{
							pInstance->Setbool(IDS_MediaLoaded, FALSE );
						}
					}
				}
				catch ( ... )
				{
					if ( DriveLayout != NULL )
					{
						delete [] reinterpret_cast<char *> (DriveLayout) ;
					}

					throw ;
				}

				delete [] reinterpret_cast<char *> (DriveLayout);
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
        }

		if ( (dwProperties &
                (BIT_TotalHeads |
                 BIT_TracksPerCylinder |
                 BIT_SectorsPerTrack |
                 BIT_BytesPerSector |
                 BIT_TotalCylinders |
                 BIT_TotalTracks |
                 BIT_TotalSectors |
                 BIT_Size |
                 BIT_MediaType |
                 BIT_Capabilities))
                 && (hDiskHandle != INVALID_HANDLE_VALUE))
		{

			DWORD dwByteCount = 0 ;
			DISK_GEOMETRY DiskGeometry ;

			BOOL t_Status = DeviceIoControl (

				hDiskHandle ,
				IOCTL_DISK_GET_DRIVE_GEOMETRY ,
				NULL ,
				0 ,
				& DiskGeometry ,
				sizeof ( DiskGeometry ) ,
				&dwByteCount ,
				NULL
			) ;

			if ( t_Status )
			{

// Calculate size info
//====================

				pInstance->SetDWORD ( IDS_TotalHeads , DiskGeometry.TracksPerCylinder ) ;
				pInstance->SetDWORD ( IDS_TracksPerCylinder , DiskGeometry.TracksPerCylinder ) ;
				pInstance->SetDWORD ( IDS_SectorsPerTrack , DiskGeometry.SectorsPerTrack ) ;
				pInstance->SetDWORD ( IDS_BytesPerSector , DiskGeometry.BytesPerSector ) ;

				unsigned __int64 i64Temp = DiskGeometry.Cylinders.QuadPart;
				pInstance->SetWBEMINT64 ( IDS_TotalCylinders , i64Temp );

				i64Temp *= (unsigned __int64) DiskGeometry.TracksPerCylinder ;
				pInstance->SetWBEMINT64(IDS_TotalTracks, i64Temp );

				i64Temp *= (unsigned __int64) DiskGeometry.SectorsPerTrack ;
				pInstance->SetWBEMINT64(IDS_TotalSectors, i64Temp );

				i64Temp *= (unsigned __int64) DiskGeometry.BytesPerSector ;
				pInstance->SetWBEMINT64(IDS_Size, i64Temp);

				// Create a safearray for the Capabilities information

				SAFEARRAYBOUND rgsabound[1];

				rgsabound [ 0 ].cElements = 2 ;
				rgsabound [ 0 ].lLbound = 0 ;

				variant_t vValue;

				V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;

				if ( V_ARRAY(&vValue) )
				{
    				V_VT(&vValue) = VT_I2 | VT_ARRAY;

					long ix [ 1 ] ;

					DWORD dwVal = 3 ;
					ix [ 0 ] = 0 ;

					SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

					dwVal = 4 ;
					ix [ 0 ] = 1 ;

					SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

					// Assume fixed, non-removable until otherwise indicated
					//======================================================

					bool bRemovable = false ;

					switch ( DiskGeometry.MediaType )
					{
						case RemovableMedia :
						{
							rgsabound[0].cElements ++ ;

							HRESULT t_Result = SafeArrayRedim ( V_ARRAY(&vValue) , rgsabound ) ;
							if ( t_Result == E_OUTOFMEMORY )
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
							}

							ix [ 0 ] ++ ;
							dwVal = 7;

							SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

							pInstance->SetWCHARSplat ( IDS_MediaType , L"Removable media other than floppy" );

							bRemovable = true;
						}
						break ;

						case FixedMedia :
						{
							pInstance->SetWCHARSplat(IDS_MediaType, L"Fixed hard disk media" );
						}
						break ;

						default :
						{
							pInstance->SetWCHARSplat(IDS_MediaType, L"Format is unknown" );
						}
						break ;
					}

					pInstance->SetVariant ( IDS_Capabilities , vValue ) ;
                }
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
            }
            else
            {
                LogMessage2(L"Failed to GetDriveGeometry: %d", GetLastError());
            }
        }

// Now some real fun -- determining the drive type
//================================================
        if (dwProperties &
              (BIT_Description |
#if NTONLY == 4
               BIT_InterfaceType |
#endif
               BIT_SCSIPort |
               BIT_SCSIBus |
               BIT_SCSITargetID |
               BIT_SCSILogicalUnit |
               BIT_Manufacturer)
               && (hDiskHandle != INVALID_HANDLE_VALUE))
        {
			DWORD dwByteCount = 0 ;
			SCSI_ADDRESS SCSIAddress ;

			BOOL t_Status = DeviceIoControl (

				hDiskHandle,
				IOCTL_SCSI_GET_ADDRESS,
				NULL,
				0,
				&SCSIAddress,
				sizeof(SCSI_ADDRESS),
				&dwByteCount,
				NULL
			) ;

			if ( t_Status )
			{
#if NTONLY == 4
				pInstance->SetWCHARSplat ( IDS_InterfaceType , L"SCSI" ) ;
#endif

				pInstance->SetDWORD ( IDS_SCSIPort,        DWORD ( SCSIAddress.PortNumber ) ) ;
				pInstance->SetDWORD ( IDS_SCSIBus,         DWORD ( SCSIAddress.PathId ) ) ;
				pInstance->SetDWORD ( IDS_SCSITargetID,    DWORD ( SCSIAddress.TargetId) ) ;
				pInstance->SetDWORD ( IDS_SCSILogicalUnit, DWORD ( SCSIAddress.Lun) ) ;
#if NTONLY == 4

                if (dwProperties & (BIT_Description | BIT_Manufacturer))
                {
                    CHString sSCSIKey, sTemp;
                    CRegistry cReg;

                    sSCSIKey.Format(L"Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                        SCSIAddress.PortNumber,
                        SCSIAddress.PathId,
                        SCSIAddress.TargetId,
                        SCSIAddress.Lun);

                    if (cReg.Open(HKEY_LOCAL_MACHINE, sSCSIKey, KEY_QUERY_VALUE) == ERROR_SUCCESS)
                    {
                        if (cReg.GetCurrentKeyValue(L"Identifier", sTemp) == ERROR_SUCCESS)
                        {
                            if (dwProperties & BIT_Manufacturer)
                            {
                                CHString sMfg(sTemp.Left(8));
                                sMfg.TrimRight();

                                pInstance->SetCHString(IDS_Manufacturer, sMfg);
                            }
                            if (dwProperties & BIT_Description)
                            {
                                CHString sDesc(sTemp.Mid(8,16));
                                sDesc.TrimRight();

                                pInstance->SetCHString(IDS_Description, sDesc);
                            }
                        }
                    }
                }
#endif



            }
			else
			{
#if NTONLY == 4
				pInstance->SetWCHARSplat ( IDS_InterfaceType , L"IDE") ;
#endif
			}

#if NTONLY == 4
//              Under NT 3.51, 4.0, the IDE drives are controlled
//              by a subset of the SCSI miniport and are identified
//              by the above call as SCSI drives.  We need to go
//              into the registry & get the driver type.  If ATAPI,
//              the drive is really IDE.  This may not always work.
//=================================================================

            TCHAR szTemp[_MAX_PATH] ;
			_stprintf ( szTemp , L"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %d" , SCSIAddress.PortNumber ) ;

			CRegistry RegInfo ;
			if ( RegInfo.Open ( HKEY_LOCAL_MACHINE , szTemp , KEY_READ ) == ERROR_SUCCESS )
			{
				CHString sTemp ;
				if ( RegInfo.GetCurrentKeyValue (L"Driver", sTemp) == ERROR_SUCCESS )
				{
					if ( ! lstrcmpi ( sTemp.GetBuffer(1), L"ATAPI" ) )
					{
						 pInstance->SetWCHARSplat ( IDS_InterfaceType , L"IDE" ) ;
					}
				}

				RegInfo.Close() ;
			}
#endif

        }
	}
	else
	{
        if ( dwErr == ERROR_FILE_NOT_FOUND)
		{
			hres = WBEM_E_NOT_FOUND ;
		}
	}

  	return hres ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskDrive::GetPhysDiskInfoWin95
 *
 *  DESCRIPTION : Retrieves property values for physical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32DiskDrive :: GetPhysDiskInfoWin95 (
    CConfigMgrDevice *pDisk,
	CInstance *pInstance,
	LPCWSTR wszDeviceID,
	CCim32NetApi *a_pCim32Net,
    CRegistry &RegInfo,
    DWORD dwProperties
)
{
    // By virtue of the fact that we are here, we know we are working with a
    // fixed disk.  Set the fixed values

	pInstance->Setbool ( IDS_MediaLoaded , TRUE ) ;
	pInstance->SetWCHARSplat ( IDS_MediaType , L"Fixed hard disk media" ) ;

	SetCreationClassName(pInstance);
	pInstance->SetCharSplat ( IDS_SystemCreationClassName , PROPSET_NAME_COMPSYS ) ;
	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;

    SetConfigMgrProperties(pDisk, pInstance);

	pInstance->SetWCHARSplat ( IDS_Caption , wszDeviceID ) ;
	pInstance->SetWCHARSplat ( IDS_Name , wszDeviceID ) ;
    pInstance->SetWCHARSplat ( IDS_Description , wszDeviceID ) ;

    CHString sTemp;
    if ((dwProperties & BIT_Status) && (pDisk->GetStatus(sTemp)))
    {
		pInstance->SetCHString ( IDS_Status , sTemp ) ;
	}

    if ( (dwProperties & (BIT_Description | BIT_Caption)) && (pDisk->GetDeviceDesc(sTemp) ))
	{
        pInstance->SetCHString ( IDS_Description , sTemp ) ;
    	pInstance->SetWCHARSplat ( IDS_Caption , sTemp ) ;
    }

    if ((dwProperties & BIT_Caption) && (pDisk->GetFriendlyName(sTemp)) )
    {
    	pInstance->SetWCHARSplat ( IDS_Caption , sTemp ) ;
    }

    if ((dwProperties & BIT_Manufacturer) && (pDisk->GetMfg(sTemp)))
    {
        pInstance->SetCHString(IDS_Manufacturer, sTemp);
    }

    if (dwProperties & BIT_InterfaceType)
    {
#if 0
	    // This code will get the interface type for the drive (scsi, ide, etc).  This
	    // is based on two assertions from bill parry.  First, ESDI really means IDE.  They
	    // just never got around to renaming this registry key.  Second, for non-removable drives
	    // (which means cd roms don't come under this statement), the first part of the pnp id
	    // indicates the interface.  Given these assertions, I created this code:

        CHString sParse ( wszDeviceID ) ;
        int iWhere = sParse.Find ( '\\' ) ;
        if ( iWhere != -1 )
        {
            CHString sInterface ( sParse.Left ( iWhere ) ) ;
            if ( sInterface.CompareNoCase ( L"ESDI" ) == 0 )
            {
                sInterface = "IDE" ;
            }

            pInstance->SetCHString ( IDS_InterfaceType , sInterface ) ;
        }
#endif

        SetInterfaceType(pInstance, pDisk);

    }

    // Several of the properties we need can be easily read from the registry.
    // If any of these registry keys are not found, they will return NULL.


    if ( (dwProperties & BIT_Model) &&
        (RegInfo.GetCurrentKeyValue( L"ProductId" , sTemp ) == ERROR_SUCCESS ))
	{
        pInstance->SetCHString ( IDS_Model , sTemp ) ;
    }

    if ( (dwProperties & BIT_SCSITargetID) &&
        (RegInfo.GetCurrentKeyValue( L"SCSITargetID" , sTemp ) == ERROR_SUCCESS ))
	{
        pInstance->SetDWORD ( IDS_SCSITargetID , _wtoi ( sTemp ) ) ;
    }

    if ( (dwProperties & BIT_SCSILogicalUnit) &&
        (RegInfo.GetCurrentKeyValue( L"SCSILUN" , sTemp ) == ERROR_SUCCESS ))
	{
        pInstance->SetDWORD ( IDS_SCSILogicalUnit , _wtoi ( sTemp ) ) ;
    }

    if (dwProperties & BIT_Capabilities)
    {
        // Create a safearray for the Capabilities information

        SAFEARRAYBOUND rgsabound [ 1 ] ;

        rgsabound [ 0 ].cElements = 2 ;
        rgsabound [ 0 ].lLbound = 0 ;

	    variant_t vValue ;

	    V_ARRAY(&vValue) = SafeArrayCreate ( VT_I2 , 1 , rgsabound );

	    if ( V_ARRAY(&vValue) )
	    {
		    V_VT(&vValue) = VT_I2 | VT_ARRAY ;
		    long ix[1];

		    //   Random Access

		    DWORD dwVal = 3 ;
		    ix [ 0 ] = 0 ;

		    SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

		    // Supports Writing

		    dwVal = 7;
		    ix [ 0 ] = 1 ;

		    SafeArrayPutElement ( V_ARRAY(&vValue) , ix , & dwVal ) ;

		    pInstance->SetVariant ( IDS_Capabilities , vValue ) ;
	    }
	    else
	    {
		    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	    }
    }

    if (dwProperties &
           (BIT_Index |
            BIT_Size |
            BIT_TotalSectors |
            BIT_TotalTracks |
            BIT_TotalCylinders |
            BIT_TotalHeads |
            BIT_TracksPerCylinder |
            BIT_SectorsPerTrack |
            BIT_BytesPerSector |
            BIT_Partitions))
    {


		// Now for the fun part.  We are going to use 16 bit mode to read some int13 info
		// about the drive, including the partition table.

		BYTE btBiosUnit = GetBiosUnitNumberFromPNPID ( wszDeviceID ) ;

		// Did we get a unit number and is it a fixed disk?  If not, these other fields will remain unpopulated

		if ( ( btBiosUnit >= 0x80 ) && ( btBiosUnit != -1 ) )
		{
			pInstance->SetDWORD ( IDS_Index, btBiosUnit-0x80 ) ;

			if ( (dwProperties & BIT_Partitions) &&
                (a_pCim32Net->GetWin9XPartitionTable != NULL ))
			{
				MasterBootSector stMBS;

				BYTE cRet = a_pCim32Net->GetWin9XPartitionTable ( btBiosUnit , &stMBS ) ;
				if ( cRet == 0 )
				{
					DWORD dwPartCount = 0;

					for ( int x = 0; x < 4; x++ )
					{
						if ( stMBS.stPartition [ x ].cOperatingSystem != PARTITION_ENTRY_UNUSED )
						{
							dwPartCount ++;
						}
					}

					pInstance->SetDWORD ( IDS_Partitions , dwPartCount ) ;
				}
			}

            if ( (dwProperties &
                   (BIT_Size |
                    BIT_TotalSectors |
                    BIT_TotalTracks |
                    BIT_TotalCylinders |
                    BIT_TotalHeads |
                    BIT_TracksPerCylinder |
                    BIT_SectorsPerTrack |
                    BIT_BytesPerSector)) &&

                    ( a_pCim32Net->GetWin9XDriveParams != NULL ) )
			{
    			Int13DriveParams stParams;

    			BYTE cRet = a_pCim32Net->GetWin9XDriveParams ( btBiosUnit , & stParams ) ;
	    		if ( cRet == 0 )
				{
					// Values from int13 call

					pInstance->SetDWORD ( IDS_SectorsPerTrack , stParams.dwMaxSector ) ;
					pInstance->SetDWORD ( IDS_TracksPerCylinder , stParams.dwMaxHead ) ;
					pInstance->SetDWORD ( IDS_TotalHeads , stParams.dwMaxHead ) ;
					pInstance->SetWBEMINT64 ( IDS_TotalCylinders , (ULONGLONG)stParams.dwMaxCylinder ) ;
                    pInstance->SetDWORD ( IDS_BytesPerSector , stParams.wSectorSize ) ;

					// Some calculated values

					ULONGLONG u64Temp = stParams.dwMaxCylinder * stParams.dwMaxHead ;
					pInstance->SetWBEMINT64 ( IDS_TotalTracks , u64Temp ) ;

                    if (stParams.wExtStep == 3)
                    {
                        u64Temp = *(ULONGLONG*)&stParams.dwSectors ;
                    }
                    else
                    {
                        u64Temp *= stParams.dwMaxSector ;
                    }
					pInstance->SetWBEMINT64 ( IDS_TotalSectors , u64Temp ) ;

					u64Temp *= stParams.wSectorSize ;
					pInstance->SetWBEMINT64 ( IDS_Size , u64Temp ) ;
				}
			}
		}
    }

    return WBEM_S_NO_ERROR;
}
#endif

#if NTONLY == 5

#define WMI_PNPDEVICEID_GUID           { 0xc7bf35d2, 0xaadb, 0x11d1, { 0xbf, 0x4a, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } }
#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

BOOL CWin32DiskDrive::GetPNPDeviceIDFromHandle(HANDLE hHandle, CHString &sPNPDeviceID)
{
    BOOL bRet = FALSE;

    WMIHANDLE WmiHandle;
	ULONG status;
    GUID GeomGuid = WMI_DISK_GEOMETRY_GUID;

    CWmiApi* pWmi = (CWmiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidWmiApi, NULL);
    if(pWmi != NULL)
    {
	    try
        {

            status = pWmi->WmiOpenBlock(&GeomGuid,
                                  GENERIC_ALL,
                                  &WmiHandle);

            if (status == ERROR_SUCCESS)
            {
                WCHAR wszInstancePath[_MAX_PATH];
                try
                {
	                ULONG NameLen = _MAX_PATH;
                    status = pWmi->WmiFileHandleToInstanceName(WmiHandle,
                                                         hHandle,
                                                         &NameLen,
                                                         wszInstancePath);
                }
                catch ( ... )
                {
            		pWmi->WmiCloseBlock( WmiHandle );
                    throw;
                }
            	pWmi->WmiCloseBlock( WmiHandle );

                if (status == ERROR_SUCCESS)
                {
                    GUID PNPGuid = WMI_PNPDEVICEID_GUID;
                    status = pWmi->WmiOpenBlock(&PNPGuid,
                                          GENERIC_ALL,
                                          &WmiHandle);

                    if (status == ERROR_SUCCESS)
                    {
                        try
                        {
                            WCHAR wszPNPId[_MAX_PATH + sizeof(WNODE_SINGLE_INSTANCE)];
                            ULONG NameLen = sizeof(wszPNPId);

                            status = pWmi->WmiQuerySingleInstance(WmiHandle,
                                                                  wszInstancePath,
                                                                  &NameLen,
                                                                  wszPNPId);

                            if (status == ERROR_SUCCESS)
                            {
                                WNODE_SINGLE_INSTANCE *pNode = (PWNODE_SINGLE_INSTANCE)wszPNPId;

                                // Number of bytes in string
                                WORD *pWord = (WORD *)OffsetToPtr(pNode, pNode->DataBlockOffset);
                                WORD wChars = *pWord / sizeof(WCHAR);

                                WCHAR *pBuff = sPNPDeviceID.GetBuffer(wChars + 1);
                                memcpy(pBuff, OffsetToPtr(pNode, pNode->DataBlockOffset) + 2, *pWord);
                                pBuff[wChars] = 0;

                                bRet = TRUE;
                            }
                        }
                        catch ( ... )
                        {
            			    pWmi->WmiCloseBlock( WmiHandle );
                            throw;
                        }
            			pWmi->WmiCloseBlock( WmiHandle );
                    }
                    else
                    {
                        LogMessage2(L"WmiOpenBlock PNPDeviceID failed %d\n", status);
                    }
                }
                else
                {
                    LogMessage2(L"WmiFileHandleToInstanceName failed %d\n", status);
                }
            }
            else
            {
                LogMessage2(L"WmiOpenBlock Geom failed %d\n", status);
            }
        }
        catch ( ... )
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
            throw;
        }

        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidWmiApi, pWmi);
    }

    return bRet;
}

#endif

void CWin32DiskDrive::SetInterfaceType(CInstance *pInstance, CConfigMgrDevice *pDevice)
{
    CConfigMgrDevicePtr pParent, pCurDevice(pDevice);

    while (pCurDevice->GetParent(&pParent))
    {
        if (pParent->IsClass (L"SCSIAdapter"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"SCSI");
            break;
        }
        else if (pParent->IsClass (L"hdc"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"IDE");
            break;
        }
        else if (pParent->IsClass (L"USB"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"USB");
            break;
        }
        else if (pParent->IsClass (L"1394"))
        {
            pInstance->SetWCHARSplat(IDS_InterfaceType, L"1394");
            break;
        }
        pCurDevice = pParent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\directorycontainsfile.h ===
//=================================================================

//

// DirectoryContainsFile

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Relationship between Win32_Directory and CIM_DataFile
//
//=================================================================

// Property set identification
//============================

#ifndef _DIRECTORYCONTAINSFILE_H_
#define _DIRECTORYCONTAINSFILE_H_

#define  PROPSET_NAME_DIRECTORYCONTAINSFILE L"CIM_DirectoryContainsFile"


#include "implement_logicalfile.h"



class CDirContFile;

class CDirContFile : public CImplement_LogicalFile
{
    public:
        // Constructor/destructor
        //=======================
        CDirContFile(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CDirContFile() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        //virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L);

        virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L) { return WBEM_E_PROVIDER_NOT_CAPABLE; }

    protected:
       
       // Overridable function inherrited from CImplement_LogicalFile
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName);

        virtual void LoadPropertyValues95(CInstance* pInstance,
                                          LPCTSTR pszDrive, 
                                          LPCTSTR pszPath, 
                                          LPCTSTR pszFSName, 
                                          LPWIN32_FIND_DATA pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\directorycontainsfile.cpp ===
//=================================================================

//

// DirectoryContainsFile.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Relationship between win32_directory and contained cim_datafiles
//
//=================================================================

#include "precomp.h"

#include "DirectoryContainsFile.h"
#include "directory.h"
#include "cimdatafile.h"



// Property set declaration
//=========================
CDirContFile MyCDirContFile(PROPSET_NAME_DIRECTORYCONTAINSFILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::CDirContFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CDirContFile::CDirContFile(LPCWSTR setName, LPCWSTR pszNamespace)
:CImplement_LogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::~CDirContFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CDirContFile::~CDirContFile()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CDirContFile::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrDirectory;
    CHString chstrDatafile;
    CHString chstrDirFullPathName;
    CHString chstrFileFullPathName;
    HRESULT hr = WBEM_E_NOT_FOUND;

    if(pInstance != NULL)
    {
        // Get the two paths
        pInstance->GetCHString(IDS_GroupComponent, chstrDirectory);
        pInstance->GetCHString(IDS_PartComponent, chstrDatafile);

        CInstancePtr pinstDirectory;
        CInstancePtr pinstDatafile;

        // If both ends are there
        if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDirectory, &pinstDirectory, pInstance->GetMethodContext())))
        {
            if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrDatafile, &pinstDatafile, pInstance->GetMethodContext())))
            {
                // Confirm that the directory is part of the datafile's path:
                chstrDirFullPathName = chstrDirectory.Mid(chstrDirectory.Find(_T('='))+2);
                chstrDirFullPathName = chstrDirFullPathName.Left(chstrDirFullPathName.GetLength() - 1);

                chstrFileFullPathName = chstrDatafile.Mid(chstrDatafile.Find(_T('='))+2);
                chstrFileFullPathName = chstrFileFullPathName.Left(chstrFileFullPathName.GetLength() - 1);

                chstrDirFullPathName.MakeUpper();
                chstrFileFullPathName.MakeUpper();

                if(chstrFileFullPathName.Find(chstrDirFullPathName) != -1)
                {
                    hr = WBEM_S_NO_ERROR;
                }

            } //dir instancebypath
        } //logicaldisk instancebypath
    } // pinstance not null

    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CDirContFile::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHStringArray achstrGroupComponent;
    DWORD dwGroupComponents = 0L;
    CHStringArray achstrPartComponent;
    DWORD dwPartComponents = 0L;

    pQuery.GetValuesForProp(IDS_GroupComponent, achstrGroupComponent);
    dwGroupComponents = achstrGroupComponent.GetSize();
    pQuery.GetValuesForProp(IDS_PartComponent, achstrPartComponent);
    dwPartComponents = achstrPartComponent.GetSize();

    // The first optimization is for the case where the user asked for associations of a directory -
    // the query will have a WHERE clause specifying a group component that is the directory containing files
    if(dwGroupComponents == 1L && dwPartComponents == 0L)
    {
        // Need the directory path...
        // Need to format the path parameter for the sub-directories (the partcomponents)...
        CHString chstrFilePath;
        LONG lPos = achstrGroupComponent[0].Find(L":");
        chstrFilePath = achstrGroupComponent[0].Mid(lPos+1);
        chstrFilePath = chstrFilePath.Left(chstrFilePath.GetLength() - 1);
        if(chstrFilePath != _T("\\\\")) // it is not a root dir (proper syntax for root is just "\\", not "\\\\")
        {
            chstrFilePath += _T("\\\\"); // if not the root, need to tack on trailing pair of backslashes
        }

        CHString chstrDiskLetter;
        lPos = achstrGroupComponent[0].Find(L":");
        chstrDiskLetter = achstrGroupComponent[0].Mid(lPos-1, 2);

        CHString chstrFilePathAdj;  // to hold the version of the path without the extra escaped backslashes.
        RemoveDoubleBackslashes(chstrFilePath, chstrFilePathAdj);

#ifdef NTONLY
        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                        chstrDiskLetter,
                        chstrFilePathAdj,   // use the given path
                        L"*",               // filename
                        L"*",               // extension
                        false,              // no recursion desired
                        NULL,               // don't need the file system name
                        NULL,               // don't need ANY of cim_logicalfile's props (irrelavent in this class's overload of LoadPropetyValues)
                        false,              // this association is not interested in calling LoadPropertyValues for the root, only for files off of it
                        NULL));
#endif
#ifdef WIN9XONLY
        hr = EnumDirs95(C95EnumParm(pMethodContext,
                        TOBSTRT(chstrDiskLetter),
                        TOBSTRT(chstrFilePathAdj),   // use the given path
                        _T("*"),            // filename
                        _T("*"),            // extension
                        false,              // no recursion desired
                        NULL,
                        NULL,
                        false,              // this association is not interested in calling LoadPropertyValues for the root, only for files off of it
                        NULL));
#endif
    }

    // The second optimization is for the case where the user asked for associations of a specific file -
    // in this case the WHERE clause will contain a part component that is the file.  We should give back the directory
    // the file is in.
    else if(dwGroupComponents == 0L && dwPartComponents == 1L)
    {
        // Need the directory name - obtain from the file name...
        CHString chstrDirName;
        LONG lPos = achstrPartComponent[0].Find(L"=");
        chstrDirName = achstrPartComponent[0].Mid(lPos+1);
        chstrDirName = chstrDirName.Left(chstrDirName.ReverseFind(_T('\\')) - 1);

        // Need to construct the path of the GroupPart...
        CHString chstrDirPATH;
        chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=%s\"", GetLocalComputerName(), IDS_CimWin32Namespace, PROPSET_NAME_DIRECTORY, chstrDirName);

        // Now construct the part component...
        CHString chstrFilePATH;
        chstrFilePATH.Format(L"\\\\%s\\%s:%s", GetLocalComputerName(), IDS_CimWin32Namespace, achstrPartComponent[0]);

        // commit it now...
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            pInstance->SetCHString(IDS_PartComponent, chstrFilePATH);
            pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
            hr = pInstance->Commit();
        }
    }
    else
    {
        hr = EnumerateInstances(pMethodContext);
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//WITH CHANGE TO MAKE THIS CLASS INHERRIT FROM CIMPLEMENTLOGICALFILE, NO NEED TO
//IMPLEMENT HERE AT ALL.  WHAT WILL HAPPEN IS ENUMINSTANCES FROM THE PARENT CLASS
//WILL BE CALLED, BUT ONLY FILES WILL SATISFY THIS CLASS'S ISONEOFME (WHICH WILL
//BE THE VERSION OF THAT FUNCTION CALLED AS THIS IS THE MOST DERIVED VERSION),
//AND SIMILARLY THIS CLASS'S LOADPROPERTYVALUES WILL BE CALLED.
//
// NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE *** NOTE
//
//HRESULT CDirContFile::EnumerateInstances(MethodContext* pMethodContext, long lFlags /*= 0L*/)
//{
//    HRESULT hr = WBEM_S_NO_ERROR;
//    TRefPointerCollection<CInstance> LDirs;
//
//    if(SUCCEEDED(CWbemProviderGlue::GetAllInstances(CHString(_T("Win32_Directory")),
//                                                    &LDirs,
//                                                    IDS_CimWin32Namespace,
//                                                    pMethodContext)))
//    {
//        REFPTRCOLLECTION_POSITION pos;
//        if(LDirs.BeginEnum(pos))
//        {
//            CInstance* pinstDir = NULL;
//            CHString chstrDirPATH;
//            CHString chstrDriveLetter;
//            CHString chstrQuery;
//            //CHString chstrWbemizedPath;
//            CHString chstrFileFilename;
//            CHString chstrFilePath;
//            LONG lPos;
//
//            while((SUCCEEDED(hr)) && (pinstDir = LDirs.GetNext(pos)))
//            {
//                if(pinstDir != NULL)
//                {
//                    // grab every directory hanging off of the root of that disk...
//                    pinstDir->GetCHString(_T("__PATH"), chstrDirPATH);  // groupcomponent
//                    pinstDir->GetCHString(IDS_Drive, chstrDriveLetter);
//                    pinstDir->GetCHString(IDS_Name, chstrFileFilename);
//                    lPos = chstrFileFilename.Find(_T(":"));
//                    chstrFilePath = chstrFileFilename.Mid(lPos+1);
//                    if(chstrFilePath != _T("\\"))
//                    {
//                        chstrFilePath += _T("\\");
//                    }
//
//                    //EscapeBackslashes(chstrFilePath,chstrWbemizedPath);
//
//                    chstrQuery.Format(_T("SELECT __PATH FROM CIM_DataFile WHERE Drive = \"%s\" and Path = \"%s\""),chstrDriveLetter,chstrFilePath);
//                    hr = QueryForSubItemsAndCommit(chstrDirPATH,
//                                                   chstrQuery,
//                                                   pMethodContext);
//                    pinstDir->elease();
//                }
//            }
//            LDirs.EndEnum();
//        }
//    }
//    return hr;
//}


/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::IsOneOfMe
 *
 *  DESCRIPTION : IsOneOfMe is inherritedfrom CIM_LogicalFile.  That class
 *                returns files or directories where this one should only
 *                return files, in response to queries, getobject commands,
 *                etc.  It is overridden here to return TRUE only if the file
 *                (the information for which is contained in the function
 *                arguement pstFindData) is of type file.
 *
 *  INPUTS      : LPWIN32_FIND_DATA and a string containing the full pathname
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if a file or FALSE if a directory
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef NTONLY
BOOL CDirContFile::IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                             const WCHAR* wstrFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE);
    }
}
#endif


#ifdef WIN9XONLY
BOOL CDirContFile::IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                             const char* strFullPathName)
{
    // pstFindData would be null if this function were called for the root
    // directory.  Since that "directory" is not a file, return false.
    if(pstFindData == NULL)
    {
        return FALSE;
    }
    else
    {
        return ((pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? FALSE : TRUE);
    }
}
#endif




/*****************************************************************************
 *
 *  FUNCTION    : CDirContFile::LoadPropertyValues
 *
 *  DESCRIPTION : LoadPropertyValues is inherritedfrom CIM_LogicalFile.  That class
 *                calls LoadPropertyValues just prior to commiting the instance.
 *                Here we just need to load the PartComponent and GroupComponent
 *                properties.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    : none
 *
 *****************************************************************************/
#ifdef WIN9XONLY
void CDirContFile::LoadPropertyValues95(CInstance* pInstance,
                                         LPCTSTR pszDrive,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszFSName,
                                         LPWIN32_FIND_DATA pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirNameAdj;
    CHString chstrDirPATH;

    CHString chstrFileName;
    CHString chstrFileNameAdj;
    CHString chstrFilePATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrDirName.Format(L"%s%s",(LPCWSTR)TOBSTRT(pszDrive),(LPCWSTR)TOBSTRT(pszPath));
    if(chstrDirName.GetLength() != 3)
    {   // it was not the root dir, so need to trim off trailing backslash.
        chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);
    }
    EscapeBackslashes(chstrDirName, chstrDirNameAdj);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirNameAdj);
    // Get the PartComponent (the file name) ready...
    chstrFileName.Format(L"%s%s%s",(LPCWSTR)TOBSTRT(pszDrive),(LPCWSTR)TOBSTRT(pszPath),(LPCWSTR)TOBSTRT(pstFindData->cFileName));
    EscapeBackslashes(chstrFileName, chstrFileNameAdj);
    chstrFilePATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_CIMDATAFILE,
                        (LPCWSTR)chstrFileNameAdj);
    // Set Properties...
    pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
    pInstance->SetCHString(IDS_PartComponent, chstrFilePATH);
}
#endif


#ifdef NTONLY
void CDirContFile::LoadPropertyValuesNT(CInstance* pInstance,
                                         const WCHAR* pszDrive,
                                         const WCHAR* pszPath,
                                         const WCHAR* pszFSName,
                                         LPWIN32_FIND_DATAW pstFindData,
                                         const DWORD dwReqProps,
                                         const void* pvMoreData)
{
    CHString chstrDirName;
    CHString chstrDirNameAdj;
    CHString chstrDirPATH;

    CHString chstrFileName;
    CHString chstrFileNameAdj;
    CHString chstrFilePATH;

    // Note: this routing will not be called from the root "directory" instance, since our EnumDirs final
    // parameter was false.  This is what we want, since this association only commits instances for files
    // hanging off a directory.  If we were called in the root case, the root would be the file (PartComponent),
    // and what would be the GroupComponent?!?

    // Get the GroupComponent (the directory name) ready...
    chstrDirName.Format(L"%s%s",pszDrive,pszPath);
    if(chstrDirName.GetLength() != 3)
    {   // it was not the root dir, so need to trim off trailing backslash.
        chstrDirName = chstrDirName.Left(chstrDirName.GetLength() - 1);
    }
    EscapeBackslashes(chstrDirName, chstrDirNameAdj);
    chstrDirPATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_DIRECTORY,
                        (LPCWSTR)chstrDirNameAdj);
    // Get the PartComponent (the file name) ready...
    chstrFileName.Format(L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
    EscapeBackslashes(chstrFileName, chstrFileNameAdj);
    chstrFilePATH.Format(L"\\\\%s\\%s:%s.Name=\"%s\"",
                        (LPCWSTR)GetLocalComputerName(),
                        IDS_CimWin32Namespace,
                        PROPSET_NAME_CIMDATAFILE,
                        (LPCWSTR)chstrFileNameAdj);
    // Set Properties...
    pInstance->SetCHString(IDS_GroupComponent, chstrDirPATH);
    pInstance->SetCHString(IDS_PartComponent, chstrFilePATH);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\diskdrive.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  diskdrive.h
//
//  Purpose: Disk drive instance provider
//
//***************************************************************************

// Property set identification
//============================

#define  PROPSET_NAME_DISKDRIVE L"Win32_DiskDrive"
#define BYTESPERSECTOR 512

class CWin32DiskDrive;

class CWin32DiskDrive:public Provider {

    public:

        // Constructor/destructor
        //=======================

        CWin32DiskDrive(LPCWSTR name, LPCWSTR pszNamespace);
        ~CWin32DiskDrive() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
        HRESULT Enumerate(MethodContext *pMethodContext, long lFlags, DWORD dwProperties);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

    private:
        CHPtrArray m_ptrProperties;

        // Utility
        //========

#ifdef NTONLY
        HRESULT GetPhysDiskInfoNT(CInstance *pInstance, LPCWSTR lpwszDrive, DWORD dwDrive, DWORD dwProperties, BOOL bGetIndex) ;
#endif

#if NTONLY == 5
        BOOL GetPNPDeviceIDFromHandle(
            HANDLE hHandle, 
            CHString &sPNPDeviceID
        );

#endif
        void SetInterfaceType(
            CInstance *pInstance, 
            CConfigMgrDevice *pDevice
        );


#ifdef WIN9XONLY
        HRESULT GetPhysDiskInfoWin95(
            CConfigMgrDevice *pDisk, 
            CInstance *pInstance, 
            LPCWSTR wszDeviceID,
            CCim32NetApi* t_pCim32Net, 
            CRegistry &RegInfo, 
            DWORD dwProperties
        );

#endif
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\diskpartition.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  DiskPartition.h
//
//  Purpose: Disk partition instance provider
//
//***************************************************************************

// Property set identification
//============================

#define PROPSET_NAME_DISKPARTITION L"Win32_DiskPartition"
#define BYTESPERSECTOR 512

typedef BOOL (STDAPICALLTYPE *GETDISKFREESPACEEX)(LPCSTR lpDirectoryName,
                                                      PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                      PULARGE_INTEGER lpTotalNumberOfBytes,
                                                      PULARGE_INTEGER lpTotalNumberOfFreeBytes);

typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (LPCTSTR lpDirectoryName,
                                                  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                  PULARGE_INTEGER lpTotalNumberOfBytes,
                                                  PULARGE_INTEGER lpTotalNumberOfFreeBytes) ;

#ifdef NTONLY

#pragma pack(push, 1)
typedef struct  
{
    BYTE cBoot;
    BYTE cStartHead;
    BYTE cStartSector;
    BYTE cStartTrack;
    BYTE cOperatingSystem;
    BYTE cEndHead;
    BYTE cEndSector;
    BYTE cEndTrack;
    DWORD dwSectorsPreceding;
    DWORD dwLengthInSectors;
} PartitionRecord, *pPartitionRecord;

typedef struct 
{
    BYTE cLoader[446];
    PartitionRecord stPartition[4];
    WORD wSignature;
} MasterBootSector, FAR *pMasterBootSector;

typedef struct
{
    // Article ID: Q140418 & Windows NT Server 4.0 resource kit - Chap 3 (partition boot sector)
    BYTE cJMP[3];
    BYTE cOEMID[8];
    WORD wBytesPerSector;
    BYTE cSectorsPerCluster;
    WORD wReservedSectors;
    BYTE cFats;
    WORD cRootEntries;
    WORD wSmallSectors;
    BYTE cMediaDescriptor;
    WORD wSectorsPerFat;
    WORD wSectorsPerTrack;
    WORD wHeads;
    DWORD dwHiddenSectors;
    DWORD dwLargeSectors;

    // ExtendedBiosParameterBlock (not always supported)
    BYTE cPhysicalDriveNumber;
    BYTE cCurrentHead;
    BYTE cSignature;
    DWORD dwID;
    BYTE cVolumeLabel[11];
    BYTE cSystemID[8];

    BYTE cBootStrap[448];
    BYTE cEndOfSector[2];

} PartitionBootSector, FAR *pPartitionBootSector;


#pragma pack(pop)
#endif

class CWin32DiskPartition ;

class CWin32DiskPartition:public Provider 
{
public:

        // Constructor/destructor
        //=======================

        CWin32DiskPartition(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CWin32DiskPartition() ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject(CInstance *pInstance, long lFlags = 0L) ;
        HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L) ;

private:

        // Utility
        //========

#ifdef NTONLY

        HRESULT RefreshInstanceNT (

			DWORD dwDiskIndex, 
			DWORD dwPartitionIndex, 
			CInstance *pInstance
		) ;

        HRESULT AddDynamicInstancesNT (

			MethodContext *pMethodContext
		) ;

        BOOL LoadPartitionValuesNT (

			CInstance *pInstance, 
			DWORD dwDiskIndex, 
            DWORD dwPartitionNumber, 
            DWORD dwFakePartitionNumber, 
			LPBYTE pBuff,
			DWORD dwLayoutStyle
		) ;

        LPBYTE	GetPartitionInfoNT(LPCWSTR szTemp, DWORD &dwType);
		DWORD	GetRealPartitionIndex(DWORD dwFakePartitionIndex, LPBYTE pBuff, DWORD dwLayoutStyle);

#endif
#ifdef WIN9XONLY

        HRESULT RefreshInstanceWin95 (

			CHString strDeviceID, 
			DWORD dwPartitionIndex, 
			CInstance *pInstance
		);

        HRESULT AddDynamicInstancesWin95 (

			MethodContext *pMethodContext
		) ;

        void LoadPartitionValuesWin95 (

			CInstance *pInstance, 
			CHString strDeviceID, 
			BYTE btBiosUnitNumber, 
            pPartitionRecord pstPartition, 
			DWORD dwPartitionNumber
		);

        BYTE LoadPartitions (

			CCim32NetApi *a_pCim32Net, 
			BYTE btBiosUnit, 
			pMasterBootSector pMBS
		) ;

#endif

		BOOL GetDriveFreeSpace ( CInstance *pInstance , const char *pszName ) ;

        void CreateNameProperty ( DWORD dwDisk , DWORD dwPartition , char *pszName ) ;

        BOOL SetPartitionType ( CInstance *pInstance , DWORD dwPartitionType ) ;
        BOOL SetPartitionType ( CInstance *pInstance , GUID *pGuidPartitionType , BOOL &bIsSystem ) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\displaycfg.cpp ===
///////////////////////////////////////////////////////////////////////

//

// displaycfg.cpp -- Implementation of MO Provider for Win32DisplayConfiguration

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
//  10/05/96     jennymc     Initial Code
//  10/24/97     jennymc     Moved to new framework
//
///////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include <winuser.h>
#include "DisplayCfg.h"

// Property set declaration
//=========================

CWin32DisplayConfiguration MyCWin32DisplayConfigurationSet ( PROPSET_NAME_DISPLAY , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayConfiguration::CWin32DisplayConfiguration
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DisplayConfiguration :: CWin32DisplayConfiguration (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayConfiguration::~CWin32DisplayConfiguration
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DisplayConfiguration :: ~CWin32DisplayConfiguration ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayConfiguration :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

	CHString littleOldKey ;
	if ( pInstance->GetCHString ( IDS_DeviceName, littleOldKey ) )
	{
		hr = GetDisplayInfo ( pInstance , TRUE ) ;
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( hr ) )
	{
		CHString littleNewKey ;
		pInstance->GetCHString ( IDS_DeviceName, littleNewKey ) ;

		if ( littleNewKey.CompareNoCase ( littleOldKey ) != 0 )
		{
			hr = WBEM_E_NOT_FOUND ;
		}
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayConfiguration :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_FAILED;
    CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
    hr = GetDisplayInfo ( pInstance , TRUE ) ;
	if ( SUCCEEDED ( hr ) )
	{
		hr = pInstance->Commit ( ) ;
	}

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayConfiguration :: GetDisplayInfo (

	CInstance *pInstance,
	BOOL fAssignKey
)
{
	CHString strName ;
	CHString strDesc ;

#ifdef WIN9XONLY

	strName = GetNameWin95 () ;

#endif

	CConfigManager      configMngr;
	CDeviceCollection   devCollection;

	if ( configMngr.GetDeviceListFilterByClass ( devCollection , L"Display" ) )
	{
		REFPTR_POSITION pos ;

		devCollection.BeginEnum ( pos ) ;

		if ( devCollection.GetSize () )
		{
			CConfigMgrDevicePtr pDevice(devCollection.GetNext ( pos ), false) ;
			if ( pDevice )
			{
				pDevice->GetDeviceDesc ( strDesc ) ;

				if ( strName.IsEmpty () )
				{
					strName = strDesc ;
				}

#ifdef NTONLY
				CHString strService ;
				CHString strFileName ;
				CHString strVersion ;

				// If under WinNT, get the version by getting the service
				// name and getting its version information.

				BOOL t_Status = pDevice->GetService ( strService ) &&
								GetServiceFileName ( strService , strFileName ) &&
								GetVersionFromFileName ( strFileName , strVersion ) ;

				if ( t_Status )
				{
					pInstance->SetCHString ( IDS_DriverVersion , strVersion ) ;
				}
#endif

#ifdef WIN9XONLY
				CHString chsDriverName ;
				if ( pDevice->GetDriver ( chsDriverName ) )
				{
					// open the driver key in the registry and get
					// the driver version

					CHString chsDriverKey = _T("System\\CurrentControlSet\\Services\\Class\\" ) ;
					chsDriverKey += chsDriverName ;

					CHString strVersion ;

					CRegistry Registry ;

					DWORD dwRet = Registry.OpenLocalMachineKeyAndReadValue (

						chsDriverKey,
						L"Ver",
						strVersion
					) ;

					if ( dwRet == ERROR_SUCCESS )
					{
						pInstance->SetCHString ( IDS_DriverVersion , strVersion ) ;
					}
					else
					{
						pInstance->SetCHString ( IDS_DriverVersion , "" ) ;
					}
				}
#endif
			}
		}
	}

	if ( fAssignKey )
	{
		pInstance->SetCHString ( IDS_DeviceName , strName ) ;
	}

	pInstance->SetCHString ( IDS_Caption , strName ) ;

	pInstance->SetCHString ( L"SettingID" , strName ) ;

	pInstance->SetCHString ( IDS_Description , strDesc.IsEmpty () ? strName : strDesc ) ;

	//===============================================
	//  Get the info
	//===============================================

	DWORD dMode = ENUM_REGISTRY_SETTINGS ;

	HDC hdc = GetDC ( GetDesktopWindow () ) ;
	if (hdc)
	{
		try
		{

			DWORD dwTemp = (DWORD) GetDeviceCaps ( hdc , BITSPIXEL ) ;
			pInstance->SetDWORD ( IDS_BitsPerPel , dwTemp ) ;

			dwTemp = ( DWORD ) GetDeviceCaps ( hdc , HORZRES ) ;
			pInstance->SetDWORD( IDS_PelsWidth, dwTemp );

			dwTemp = ( DWORD ) GetDeviceCaps ( hdc , VERTRES ) ;
			pInstance->SetDWORD ( IDS_PelsHeight , dwTemp );

#ifdef NTONLY
			pInstance->SetDWORD ( IDS_DisplayFrequency, ( DWORD ) GetDeviceCaps ( hdc , VREFRESH ) ) ;
#endif
		}
		catch ( ... )
		{
			ReleaseDC ( GetDesktopWindow () , hdc ) ;
            throw;
		}

		ReleaseDC ( GetDesktopWindow () , hdc ) ;
	}

	DEVMODE DevMode ;

	memset ( & DevMode , 0 , sizeof ( DEVMODE ) ) ;

	DevMode.dmSize = sizeof ( DEVMODE ) ;
	DevMode.dmSpecVersion = DM_SPECVERSION ;

	BOOL t_Status = EnumDisplaySettings ( NULL, ENUM_CURRENT_SETTINGS , & DevMode ) ;
	if ( t_Status )
	{
		pInstance->SetDWORD ( IDS_SpecificationVersion, (DWORD) DevMode. dmSpecVersion ) ;

		if ( DevMode.dmFields & DM_LOGPIXELS )
		{
			pInstance->SetDWORD ( IDS_LogPixels , ( DWORD ) DevMode.dmLogPixels ) ;
		}

		if ( DevMode.dmFields & DM_DISPLAYFLAGS )
		{
			pInstance->SetDWORD ( IDS_DisplayFlags, DevMode.dmDisplayFlags ) ;
		}

#ifdef WIN9XONLY

		if ( DevMode.dmFields & DM_ICMMETHOD )
		{
			pInstance->SetDWORD ( IDS_ICMMethod , DevMode.dmICMMethod ) ;
		}

		if ( DevMode.dmFields & DM_ICMINTENT )
		{
			pInstance->SetDWORD ( IDS_ICMIntent, DevMode.dmICMIntent ) ;
		}

		if ( DevMode.dmFields & DM_DITHERTYPE )
		{
			pInstance->SetDWORD ( IDS_DitherType , DevMode.dmDitherType ) ;
		}
#endif
	}


    return WBEM_S_NO_ERROR;
}

#ifdef WIN9XONLY

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CHString CWin32DisplayConfiguration :: GetNameWin95 ()
{
	// There is a setting in System.Ini that may hold a value for the display driver.
	// So shades of Win16, use GetPrivateProfileString to do our dirty work for us.

	TCHAR szTemp[256];
	DWORD cbData = sizeof ( szTemp ) / sizeof(TCHAR);

	GetPrivateProfileString (

		WIN95_DSPCTLCFG_BOOT_DESC ,
		WIN95_DSPCTLCFG_DISPLAY_DRV ,
		DSPCTLCFG_DEFAULT_NAME ,
		szTemp ,
		cbData ,
		WIN95_DSPCTLCFG_SYSTEM_INI
	);

	CHString strName = szTemp ;

    return strName ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\displaycfg.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   

// Display.h        	

//                                                                  

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   
//  10/05/96     jennymc     Initial Code
//  10/24/96     jennymc     Moved to new framework
//                                                                   
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_DISPLAY L"Win32_DisplayConfiguration"
#define WIN95_DSPCTLCFG_BOOT_DESC						_T("Boot.Description")
#define WIN95_DSPCTLCFG_DISPLAY_DRV						_T("Display.Drv")
#define	WIN95_DSPCTLCFG_SYSTEM_INI						_T("SYSTEM.INI")

#define	DSPCTLCFG_DEFAULT_NAME							_T("Current Display Controller Configuration")

///////////////////////////////////////////////////////////////////////////////////////
class CWin32DisplayConfiguration : Provider{

    public:

        // Constructor/destructor
        //=======================

        CWin32DisplayConfiguration(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32DisplayConfiguration() ;

        // Funcitons provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);


        // Utility
        //========

    private:

        HRESULT GetDisplayInfo(CInstance *pInstance, BOOL fAssignKey);
#ifdef WIN9XONLY
		CHString GetNameWin95();
#endif
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\diskpartition.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Partition.CPP
//
//  Purpose: Disk partition property set provider
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>

#include <ntdddisk.h>
#include "diskpartition.h"
#include "diskdrive.h"
#include "resource.h"

#define CLUSTERSIZE 4096

// Property set declaration
//=========================
CWin32DiskPartition MyDiskPartitionSet ( PROPSET_NAME_DISKPARTITION , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::CWin32DiskPartition
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DiskPartition :: CWin32DiskPartition (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::~CWin32DiskPartition
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DiskPartition :: ~CWin32DiskPartition ()
{
}

BOOL CWin32DiskPartition :: SetPartitionType (

	CInstance *pInstance,
	GUID *pGuidPartitionType,
	BOOL &bIsSystem
)
{
	bIsSystem = FALSE;
	CHString sTemp2;

	if (IsEqualGUID(*pGuidPartitionType, PARTITION_ENTRY_UNUSED_GUID))
	{
		return FALSE;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_SYSTEM_GUID))
	{
		//EFI system partition.
		bIsSystem = TRUE;
        LoadStringW(sTemp2, IDR_PartitionDescGPTSystem);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTSystem ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_MSFT_RESERVED_GUID))
	{
		return FALSE;

//		LoadStringW(sTemp2, IDR_PartitionDescGPTMSFTReserved);
//		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTMSFTReserved ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_BASIC_DATA_GUID))
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTBasicData);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTBasicData ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_LDM_METADATA_GUID))
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTLDMMetaData);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTLDMMetaData ) ;
	}
	else if (IsEqualGUID(*pGuidPartitionType, PARTITION_LDM_DATA_GUID))
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTLDMData);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTLDMData ) ;
	}
	else // Unknown!!
	{
        LoadStringW(sTemp2, IDR_PartitionDescGPTUnknown);
		pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescGPTUnknown ) ;
	}

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
	return TRUE;
}

BOOL CWin32DiskPartition :: SetPartitionType (

	CInstance *pInstance,
	DWORD dwPartitionType
)
{
	if ((dwPartitionType == PARTITION_ENTRY_UNUSED) || IsContainerPartition(dwPartitionType))
	{
		return FALSE;
	}

    CHString sTemp2;
	
	switch ( dwPartitionType )
	{

		case PARTITION_ENTRY_UNUSED:
		{
            LoadStringW(sTemp2, IDR_PartitionDescUnused);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescUnused ) ;
		}
		break;

		case PARTITION_FAT_12:
		{
            LoadStringW(sTemp2, IDR_PartitionDesc12bitFAT);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDesc12bitFAT ) ;
		}
		break;

		case PARTITION_XENIX_1:
		{
            LoadStringW(sTemp2, IDR_PartitionDescXenixOne);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescXenixOne ) ;
		}
		break;

		case PARTITION_XENIX_2:
		{
            LoadStringW(sTemp2, IDR_PartitionDescXenixTwo);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescXenixTwo ) ;
		}
		break;

		case PARTITION_FAT_16:
		{
            LoadStringW(sTemp2, IDR_PartitionDesc16bitFAT);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDesc16bitFAT ) ;
		}
		break;

		case PARTITION_EXTENDED:
		{
            LoadStringW(sTemp2, IDR_PartitionDescExtPartition);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescExtPartition ) ;
		}
		break;

		case PARTITION_HUGE:
		{
            LoadStringW(sTemp2, IDR_PartitionDescDOSV4Huge);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescDOSV4Huge ) ;
		}
		break;

		case PARTITION_IFS:
		{
            LoadStringW(sTemp2, IDR_PartitionDescInstallable);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescInstallable ) ;
		}
		break;

		case PARTITION_PREP:
		{
            LoadStringW(sTemp2, IDR_PartitionDescPowerPCRef);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescPowerPCRef);
		}
		break;

		case PARTITION_UNIX:
		{
            LoadStringW(sTemp2, IDR_PartitionDescUnix);
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescUnix ) ;
		}
		break;

		case VALID_NTFT:
		{
            LoadStringW(sTemp2, IDR_PartitionDescNTFT);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescNTFT ) ;
		}
		break;

		case PARTITION_XINT13:
		{
            LoadStringW(sTemp2, IDR_PartitionDescWin95Ext);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescWin95Ext ) ;
		}
		break;

		case PARTITION_XINT13_EXTENDED:
		{
            LoadStringW(sTemp2, IDR_PartitionDescExt13);
			pInstance->SetCharSplat ( IDS_Type , IDS_PartitionDescExt13 ) ;
		}
		break;

		case PARTITION_LDM:
		{
            LoadStringW(sTemp2, IDR_PartitionDescLogicalDiskManager);
			pInstance->SetWCHARSplat ( IDS_Type , L"Logical Disk Manager" ) ;
		}
		break;

		default:
		{
            sTemp2 = IDS_PartitionDescUnknown;
			pInstance->SetCharSplat ( IDS_Type, IDS_PartitionDescUnknown ) ;
		}
		break;
	}

	pInstance->SetCHString ( IDS_Description , sTemp2 ) ;
	return TRUE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::GetObject
 *                                         RefreshInstanceNT
 *                                         RefreshInstanceWin95
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                from pInstance
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	CHString chsDeviceID ;
	pInstance->GetCHString ( IDS_DeviceID , chsDeviceID ) ;
	chsDeviceID.MakeUpper () ;

#ifdef NTONLY

	int iWhere = chsDeviceID.Find ( L"DISK #" ) ;
	if ( iWhere == -1 )
	{
		return WBEM_E_NOT_FOUND ;
	}

    // We want the number of characters, not the number of bytes.

	DWORD dwDiskIndex = _ttol ( chsDeviceID.Mid ( iWhere + sizeof("DISK #") - 1 ) ) ; // Don't use _T here.

	iWhere = chsDeviceID.Find ( L"PARTITION #" ) ;
	if ( iWhere == -1 )
	{
		return WBEM_E_NOT_FOUND;
	}

	DWORD dwPartitionIndex = _ttol ( chsDeviceID.Mid ( iWhere + sizeof ("PARTITION #") - 1 ) ) ; // Don't use _T here.

	HRESULT hres = RefreshInstanceNT (

		dwDiskIndex,
		dwPartitionIndex,
		pInstance
	) ;

#endif

#ifdef WIN9XONLY

	int iWhere = chsDeviceID.Find ( L", PARTITION #" ) ;
	if ( iWhere == -1 )
    {
		return WBEM_E_NOT_FOUND ;
	}

    DWORD dwPartitionIndex = _wtol ( chsDeviceID.Mid ( iWhere + sizeof (", PARTITION #") - 1 ) ) ; // Don't use _T here.

	HRESULT hres = RefreshInstanceWin95 (

		chsDeviceID.Left ( iWhere ) ,
		dwPartitionIndex ,
		pInstance
	);

#endif

    // If we seem to have succeeded, make one last check to be SURE we got what they asked for

    if ( SUCCEEDED ( hres ) )
    {
		CHString chsDeviceIDNew ;
        pInstance->GetCHString ( IDS_DeviceID , chsDeviceIDNew ) ;

        if ( chsDeviceIDNew.CompareNoCase ( chsDeviceID ) != 0 )
        {
            return WBEM_E_NOT_FOUND;
        }
    }

	return hres ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
#ifdef NTONLY

    HRESULT t_Result = AddDynamicInstancesNT (

		pMethodContext
	) ;

	return t_Result ;

#endif

#ifdef WIN9XONLY

    HRESULT t_Result = AddDynamicInstancesWin95 (

		pMethodContext
	) ;

	return t_Result ;

#endif
}

#ifdef NTONLY

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: AddDynamicInstancesNT (

	MethodContext *pMethodContext
)
{
    HRESULT	hres;
    DWORD	j;
    TCHAR   szTemp[_MAX_PATH];

    // Get list of disks
    //==================

    TRefPointerCollection<CInstance> Disks;

    hres = CWbemProviderGlue :: GetInstancesByQuery (

		L"SELECT Index FROM Win32_DiskDrive" ,
        & Disks,
		pMethodContext,
                GetNamespace()
	) ;

    if ( FAILED ( hres ) )
    {
        return hres ;
    }

    REFPTRCOLLECTION_POSITION pos ;

    if ( Disks.BeginEnum ( pos ) )
    {

	    CInstancePtr pDisk;
        for (pDisk.Attach(Disks.GetNext ( pos ));
             SUCCEEDED( hres ) && (pDisk != NULL);
             pDisk.Attach(Disks.GetNext ( pos )))
        {
			DWORD dwDiskIndex = 0 ;

			pDisk->GetDWORD ( IDS_Index , dwDiskIndex ) ;

            // Open the disk
            //==============

            _stprintf ( szTemp , IDS_PhysicalDrive , dwDiskIndex ) ;

			DWORD dwLayoutType = 0;
            CSmartBuffer pBuff (GetPartitionInfoNT(szTemp, dwLayoutType));

            // Should we return an error here?  Or not?  Hmmm.
            if ((LPBYTE)pBuff != NULL)
            {
			    // Create instance for each partition on drive
			    //============================================
				DWORD dwPCount = (dwLayoutType == 1)
									? ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionCount
									: ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionCount;

				// fake index for "valid" partitions only
				DWORD dwFakePartitionNumber = 0L;

				for ( j = 0 ; (j < dwPCount ) && ( SUCCEEDED ( hres ) ) ; j++ )
				{
					CInstancePtr pInstance(CreateNewInstance(pMethodContext ), false) ;

					if (LoadPartitionValuesNT (

						pInstance,
						dwDiskIndex,
						j,
						dwFakePartitionNumber,
						(LPBYTE)pBuff,
						dwLayoutType
					))
					{
						hres = pInstance->Commit (  ) ;

						if SUCCEEDED ( hres )
						{
							dwFakePartitionNumber++;
						}
					}
				}
            }
        }

        Disks.EndEnum() ;

    } // If Disks.BeginEnum()

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::RefreshInstanceNT
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: RefreshInstanceNT (

	DWORD dwDiskIndex,
	DWORD dwPartitionIndex,
	CInstance *pInstance
)
{
	HRESULT	hres = WBEM_E_NOT_FOUND ;

	// Open the target drive
	//======================

	TCHAR szTemp [ _MAX_PATH ] ;
	wsprintf ( szTemp , IDS_PhysicalDrive , dwDiskIndex ) ;

	DWORD dwLayoutType = 0;
    CSmartBuffer pBuff (GetPartitionInfoNT(szTemp, dwLayoutType));

    // Should we return an error here?  Or not?  Hmmm.
    if ((LPBYTE)pBuff != NULL)
    {
		DWORD dwRealPartitionIndex = static_cast < DWORD > ( - 1 );
		dwRealPartitionIndex = GetRealPartitionIndex ( dwPartitionIndex, (LPBYTE)pBuff, dwLayoutType );

		// Create instance for each partition on drive
		//============================================
	    if (dwRealPartitionIndex != static_cast < DWORD > ( - 1 ) )
	    {
		    if (LoadPartitionValuesNT (

			    pInstance ,
			    dwDiskIndex ,
				dwRealPartitionIndex ,
			    dwPartitionIndex ,
			    (LPBYTE)pBuff,
				dwLayoutType
		    ))
			{
				hres = WBEM_S_NO_ERROR ;
			}
	    }

    }

	return hres ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::LoadPartitionValuesNT
 *
 *  DESCRIPTION : Loads property values according to passed PARTITION_INFORMATION
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32DiskPartition::LoadPartitionValuesNT (

	CInstance *pInstance,
	DWORD dwDiskIndex,
    DWORD dwPartitionNumber,
    DWORD dwFakePartitionNumber,
	LPBYTE pBuff,
	DWORD dwLayoutStyle
)
{
	BOOL retVal = FALSE;
	BOOL bIndicator = FALSE;
	BOOL bSetIndicator = FALSE;
	LONGLONG llStart = 0;
	LONGLONG llLength = 0;

	if (dwLayoutStyle == 1)
	{
		UCHAR uPType = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionType;
		retVal = SetPartitionType(pInstance, (DWORD)uPType);

		if (retVal)
		{
			bSetIndicator = TRUE;
			bIndicator = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].BootIndicator;
			llStart = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].StartingOffset.QuadPart;
			llLength = ((DRIVE_LAYOUT_INFORMATION *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionLength.QuadPart;
		}
	}
	else //dwLayoutStyle == 2
	{
		switch (((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionStyle)
		{
			case PARTITION_STYLE_MBR :
			{
				UCHAR uPType = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].Mbr.PartitionType;
				retVal = SetPartitionType(pInstance, (DWORD)uPType);

				if (retVal)
				{
					bSetIndicator = TRUE;
					bIndicator = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].Mbr.BootIndicator;
				}
			}
			break;

			case PARTITION_STYLE_GPT :
			{
				GUID *pGuid = &(((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].Gpt.PartitionType);
				retVal = SetPartitionType(pInstance, pGuid, bIndicator);

				if (retVal)
				{
					bSetIndicator = bIndicator;
				}
			}
			break;

			case PARTITION_STYLE_RAW :
			default:
			{
				retVal = FALSE;
			}
			break;
		}

		if (retVal)
		{
			llStart = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].StartingOffset.QuadPart;
			llLength = ((DRIVE_LAYOUT_INFORMATION_EX *)(LPBYTE)pBuff)->PartitionEntry[dwPartitionNumber].PartitionLength.QuadPart;
		}
	}

	if (retVal)
	{
		CHString strDesc ;
		FormatMessage ( strDesc, IDR_DiskPartitionFormat , dwDiskIndex , dwFakePartitionNumber ) ;

		pInstance->SetCharSplat ( IDS_Caption , strDesc ) ;
		pInstance->SetCharSplat ( IDS_Name , strDesc ) ;

		TCHAR szTemp [ _MAX_PATH ] ;
		_stprintf (

			szTemp,
			L"Disk #%d, Partition #%d",
			dwDiskIndex,
			dwFakePartitionNumber
		) ;

		pInstance->SetCharSplat ( IDS_DeviceID , szTemp ) ;

		SetCreationClassName ( pInstance ) ;

		pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

		pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName() ) ;

		pInstance->SetWBEMINT64 ( IDS_BlockSize , (ULONGLONG)BYTESPERSECTOR ) ;

		pInstance->SetDWORD ( IDS_DiskIndex , dwDiskIndex ) ;

		pInstance->SetDWORD ( IDS_Index , dwFakePartitionNumber ) ;

		pInstance->SetWBEMINT64 ( IDS_NumberOfBlocks , llLength /  (LONGLONG) BYTESPERSECTOR) ;

		pInstance->SetWBEMINT64 ( IDS_Size , llLength ) ;

		pInstance->SetWBEMINT64 ( IDS_StartingOffset , llStart ) ;

		if (bSetIndicator)
		{
			pInstance->Setbool ( IDS_PrimaryPartition , bIndicator ) ;

			// The partition table doesn't seem to show if a partition is bootable.  However,
			// we can intuit that the active partition is bootable.

			if ( bIndicator )
			{
				pInstance->Setbool ( IDS_Bootable, true ) ;
				pInstance->Setbool ( IDS_BootPartition, true ) ;
			}
		}
	}

	return retVal;
}

#endif

#ifdef WIN9XONLY

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::AddDynamicInstancesWin95
 *
 *  DESCRIPTION : Loads property values according to passed PARTITION_INFORMATION
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: AddDynamicInstancesWin95 (

	MethodContext *pMethodContext
)
{
    HRESULT hres = WBEM_E_FAILED;
#ifdef WIN9XONLY

    // Get the pointers to the int13 thunking functions.

    CCim32NetApi *t_pCim32NetApi = HoldSingleCim32NetPtr :: GetCim32NetApiPtr () ;
	if ( t_pCim32NetApi )
	{
		try
		{
// Get all the disk drives.  Note that this includes floppies

			CConfigManager cfgmgr;
			CDeviceCollection deviceList;

			cfgmgr.GetDeviceListFilterByClass ( deviceList, L"DiskDrive" ) ;

			// Walk the list
			REFPTR_POSITION pos ;
			if ( deviceList.BeginEnum ( pos ) )
			{
				CConfigMgrDevicePtr pDisk;

				hres = WBEM_S_NO_ERROR ;

				MasterBootSector stMBS ;

                for (pDisk.Attach(deviceList.GetNext ( pos ));
                     SUCCEEDED(hres) & (pDisk != NULL);
                     pDisk.Attach(deviceList.GetNext ( pos )))
				{
					// Get the pnpID
					CHString strDeviceID ;
					pDisk->GetDeviceID ( strDeviceID ) ;

					// Get the bios unit number

					CHString sTemp ;
					BYTE btBiosUnitNumber = GetBiosUnitNumberFromPNPID ( strDeviceID ) ;

					// Make sure this is a hard drive

					if ( ( btBiosUnitNumber >= 0x80 ) && ( btBiosUnitNumber != -1 ) )
					{
						// Load the entire partition table

						if ( LoadPartitions ( t_pCim32NetApi , btBiosUnitNumber , & stMBS ) == 0 )
						{
							for ( int x = 0 ; x < 4 ; x ++ )
							{
								// Check to make sure the partition slot is used

								if ( stMBS.stPartition [ x ].cOperatingSystem != PARTITION_ENTRY_UNUSED )
								{
									// Build the instance

									CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;

									// Stuff the values in
									LoadPartitionValuesWin95 (

										pInstance,
										strDeviceID,
										btBiosUnitNumber,
										& stMBS.stPartition [ x ] ,
										x
									) ;

									hres = pInstance->Commit (  ) ;
								}
							}
						}
					}
				}
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;

			throw ;
		}

		CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
    }
#endif

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::RefreshInstanceWin95
 *
 *  DESCRIPTION : Loads property values according to passed PARTITION_INFORMATION
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DiskPartition :: RefreshInstanceWin95 (

	CHString strDeviceID,
	DWORD dwPartitionIndex,
	CInstance *pInstance
)
{
    HRESULT hres = WBEM_E_NOT_FOUND;
#ifdef WIN9XONLY
//    CDeviceCollection deviceList;

    // Get the pointers to the int13 thunking functions.
    CCim32NetApi *t_pCim32NetApi = HoldSingleCim32NetPtr :: GetCim32NetApiPtr () ;
	if ( t_pCim32NetApi )
	{
		try
		{
			CConfigManager cfgmgr;

			// Open the specified disk

			CConfigMgrDevicePtr pDisk;
			if ( cfgmgr.LocateDevice ( strDeviceID , &pDisk ) )
			{
				// Make sure the pnp id I got was a disk
				if ( pDisk->IsClass ( L"DiskDrive" ) )
				{
					// Read the partition table in

					MasterBootSector stMBS ;
					BYTE btBiosUnitNumber = GetBiosUnitNumberFromPNPID ( strDeviceID ) ;

					// Make sure this his a hard drive
					if ( ( btBiosUnitNumber >= 0x80 ) && ( btBiosUnitNumber != -1 ) )
					{
						if ( LoadPartitions ( t_pCim32NetApi , btBiosUnitNumber , & stMBS ) == 0 )
						{
							// Check to make sure the partition slot is both legal and used

							if ( ( dwPartitionIndex  < 4 ) && ( stMBS.stPartition [ dwPartitionIndex ].cOperatingSystem != PARTITION_ENTRY_UNUSED ) )
							{
								// Stuff the values in

								LoadPartitionValuesWin95 (

									pInstance,
									strDeviceID,
									btBiosUnitNumber,
									& stMBS.stPartition [ dwPartitionIndex ] ,
									dwPartitionIndex
								) ;

								hres = WBEM_S_NO_ERROR;
							}
						}
					}
				}
			}
		}
		catch ( ... )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;

			throw ;
		}

        CResourceManager::sm_TheResourceManager.ReleaseResource ( g_guidCim32NetApi , t_pCim32NetApi ) ;
    }

#endif

    return hres;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::LoadPartitionValuesWin95
 *
 *  DESCRIPTION : Loads property values according to passed indexes
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32DiskPartition :: LoadPartitionValuesWin95 (

	CInstance *pInstance,
	CHString strDeviceID,
	BYTE btBiosUnitNumber,
    pPartitionRecord pstPartition,
	DWORD dwPartitionNumber
)
{
#ifdef WIN9XONLY
    CHString strDesc ;
    strDesc.FormatMessageW ( IDR_DiskPartitionFormat1 , (LPCSTR)TOBSTRT(strDeviceID), dwPartitionNumber ) ;
	pInstance->SetCharSplat ( IDS_DeviceID , strDesc ) ;

    DWORD dwDiskIndex = btBiosUnitNumber - 0x80;
    strDesc.FormatMessageW ( IDR_DiskPartitionFormat, dwDiskIndex, dwPartitionNumber ) ;

	pInstance->SetCharSplat ( IDS_Caption , strDesc ) ;
	pInstance->SetCharSplat ( IDS_Name, strDesc ) ;

	SetCreationClassName ( pInstance ) ;

	pInstance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;

	pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

    pInstance->SetCHString ( IDS_PNPDeviceID , strDeviceID ) ;

    pInstance->SetWBEMINT64 ( IDS_BlockSize , (ULONGLONG)BYTESPERSECTOR ) ;

    pInstance->SetDWORD ( IDS_DiskIndex , dwDiskIndex) ;

    pInstance->SetDWORD ( IDS_Index , dwPartitionNumber ) ;

    pInstance->SetWBEMINT64 ( IDS_NumberOfBlocks , (ULONGLONG)pstPartition->dwLengthInSectors ) ;

    pInstance->SetWBEMINT64 ( IDS_Size , (LONGLONG) pstPartition->dwLengthInSectors * (LONGLONG) BYTESPERSECTOR ) ;

    pInstance->SetWBEMINT64 ( IDS_StartingOffset , (LONGLONG) pstPartition->dwSectorsPreceding * (LONGLONG) BYTESPERSECTOR ) ;

    pInstance->Setbool ( IDS_PrimaryPartition , pstPartition->cBoot == 0x80 ) ;

    // The partition table doesn't seem to show if a partition is bootable.  However,
    // we can intuit that the active partition is bootable.

    if ( pstPartition->cBoot == 0x80 )
    {
        pInstance->Setbool ( IDS_Bootable , true ) ;
        pInstance->Setbool ( IDS_BootPartition , true ) ;
    }

    SetPartitionType ( pInstance , pstPartition->cOperatingSystem ) ;
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::LoadPartitions
 *
 *  DESCRIPTION : Loads property values according to passed PARTITION_INFORMATION
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BYTE CWin32DiskPartition :: LoadPartitions (

	CCim32NetApi *t_pCim32Net,
	BYTE btBiosUnit,
	pMasterBootSector pMBS
)
{
    BYTE cRet = 1 ;
    memset ( pMBS , 0, sizeof ( MasterBootSector ) ) ;

    // Did we get a unit number?  If not, no instances.

    if ( btBiosUnit != -1 )
    {
        if ( t_pCim32Net != NULL )
        {
            cRet = t_pCim32Net->GetWin9XPartitionTable ( btBiosUnit , pMBS ) ;
        }
    }

    return cRet;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::GetRealPartitionIndex
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD CWin32DiskPartition::GetRealPartitionIndex(DWORD dwFakePartitionIndex, LPBYTE pBuff, DWORD dwLayoutStyle)
{
	DWORD dwPartitionIndex = static_cast <DWORD> ( -1 );
	DWORD dwRealPartitionIndex = 0L;

	// loop counter
	DWORD dwPCount = (dwLayoutStyle == 1)
						? (reinterpret_cast <DRIVE_LAYOUT_INFORMATION *> (pBuff))->PartitionCount
						: (reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionCount;

	BOOL bContinue = TRUE;

	if (dwLayoutStyle == 2)
	{
		for ( DWORD dwPartitionNumber = 0; dwPartitionNumber < dwPCount && bContinue; dwPartitionNumber++ )
		{
			switch ((reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionEntry[dwPartitionNumber].PartitionStyle)
			{
				case PARTITION_STYLE_MBR :
				{
					UCHAR uPType = (reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionEntry[dwPartitionNumber].Mbr.PartitionType;
					if ( static_cast <DWORD> (uPType) != PARTITION_ENTRY_UNUSED && !IsContainerPartition(static_cast <DWORD> (uPType)) )
					{
						if ( dwFakePartitionIndex == dwRealPartitionIndex )
						{
							bContinue = FALSE;
							dwPartitionIndex = dwPartitionNumber;
						}
						else
						{
							dwRealPartitionIndex ++;
						}
					}
				}
				break;

				case PARTITION_STYLE_GPT :
				{
					GUID *pGuid = &((reinterpret_cast <DRIVE_LAYOUT_INFORMATION_EX *> (pBuff))->PartitionEntry[dwPartitionNumber].Gpt.PartitionType);
					if ( !IsEqualGUID(*pGuid, PARTITION_ENTRY_UNUSED_GUID) && ! IsEqualGUID(*pGuid, PARTITION_MSFT_RESERVED_GUID) )
					{
						if ( dwFakePartitionIndex == dwRealPartitionIndex )
						{
							bContinue = FALSE;
							dwPartitionIndex = dwPartitionNumber;
						}
						else
						{
							dwRealPartitionIndex ++;
						}
					}
				}
				break;

				case PARTITION_STYLE_RAW :
				default:
				{
				}
				break;
			}
		}
	}
	else //dwLayoutStyle == 1
	{
		for ( DWORD dwPartitionNumber = 0; dwPartitionNumber < dwPCount && bContinue; dwPartitionNumber++ )
		{
			UCHAR uPType = (reinterpret_cast <DRIVE_LAYOUT_INFORMATION *> (pBuff))->PartitionEntry[dwPartitionNumber].PartitionType;
			if ( static_cast <DWORD> (uPType) != PARTITION_ENTRY_UNUSED && !IsContainerPartition(static_cast <DWORD> (uPType)) )
			{
				if ( dwFakePartitionIndex == dwRealPartitionIndex )
				{
					bContinue = FALSE;
					dwPartitionIndex = dwPartitionNumber;
				}
				else
				{
					dwRealPartitionIndex ++;
				}
			}
		}
	}

	return dwPartitionIndex;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DiskPartition::GetPartitionInfoNT
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
LPBYTE CWin32DiskPartition::GetPartitionInfoNT(LPCWSTR szTemp, DWORD &dwType)
{
    LPBYTE pDiskInfo = NULL;
	dwType = 0;

	SmartCloseHandle hDiskHandle = CreateFile (

		szTemp,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		0
	) ;

	if ( hDiskHandle != INVALID_HANDLE_VALUE )
	{
		DWORD dwBytesAllocatedPartition = 0L;
		dwBytesAllocatedPartition = 32 * sizeof(PARTITION_INFORMATION_EX);

		DWORD dwBytesInfoAllocated = 0L;
		dwBytesInfoAllocated = sizeof(DRIVE_LAYOUT_INFORMATION_EX);

		DWORD dwBytesAllocated = 0L;
		dwBytesAllocated = dwBytesInfoAllocated + dwBytesAllocatedPartition;

		DWORD dwBytes = 0;

		BOOL bSucceeded = FALSE;
		BOOL bFailure = FALSE;

        // The reason we do this two different ways, is that using IOCTL_DISK_GET_DRIVE_LAYOUT
        // returns extended partitions as partitions.  In this class, we only want the 4 'hard'
        // partitions.  However, NEC_98 stores its info differently, so this approach doesn't work
        // there.  On the plus side, NEC_98 boxes don't have extended partitions, so we can safely
        // use IOCTL_DISK_GET_DRIVE_LAYOUT.
        if (IsNotNEC_98)
        {
			//let's try IOCTL_DISK_GET_DRIVE_LAYOUT_EX and work with extended partitions first...
			pDiskInfo = new BYTE [dwBytesAllocated];

			try
			{
				while ( pDiskInfo && !( bSucceeded || bFailure ) )
				{
					if (!DeviceIoControl(
						hDiskHandle,
						IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
						NULL,
						0,
						pDiskInfo,
						dwBytesAllocated,
						&dwBytes,
						NULL))
					{
						if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
						{
							if ( pDiskInfo )
							{
								delete [] pDiskInfo;
								pDiskInfo = NULL;
							}

							dwBytesAllocated = dwBytesAllocated + dwBytesAllocatedPartition;
							pDiskInfo = new BYTE [dwBytesAllocated];
						}
						else
						{
							LogErrorMessage3(L"Failed to IOCTL_DISK_GET_DRIVE_LAYOUT_EX device %s (%d)", szTemp, GetLastError());

							if ( pDiskInfo )
							{
								delete [] pDiskInfo;
								pDiskInfo = NULL;
							}

							bFailure = FALSE;
						}
					}
					else
					{
						dwType = 2;

						bSucceeded = TRUE;
					}
				}
			}
			catch(...)
			{
				if ( pDiskInfo )
				{
					delete [] pDiskInfo;
					pDiskInfo = NULL;
				}

				throw;
			}

			if (pDiskInfo == NULL)
			{
				//Using IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed, try the old fashioned way...

				// Get drive information
				//======================

				CSmartBuffer pClusterBuffer (CLUSTERSIZE);

				DWORD dwRead = 0 ;

				BOOL t_Status = ReadFile (

					hDiskHandle ,
					pClusterBuffer ,
					CLUSTERSIZE ,
					&dwRead ,
					NULL
				) ;

				// Get a more useful handle on the data
				MasterBootSector *stMasterBootSector = ( MasterBootSector * ) (LPBYTE)pClusterBuffer ;

				// See if the read worked, and the signature is there
				if ( t_Status && ( dwRead == CLUSTERSIZE ) && (stMasterBootSector->wSignature == 0xaa55) )
				{
					// This is the pointer we return
					pDiskInfo = new BYTE [sizeof(DRIVE_LAYOUT_INFORMATION) + (4 * sizeof(PARTITION_INFORMATION))];

					if (pDiskInfo)
					{
						try
						{
							// Copy the data to a common structure format
							DRIVE_LAYOUT_INFORMATION *pDInfo =  (DRIVE_LAYOUT_INFORMATION *)pDiskInfo;
							dwType = 1;
							pDInfo->PartitionCount = 4;
							pDInfo->Signature = stMasterBootSector->wSignature;

							for (DWORD x=0; x < 4; x++)
							{
								pDInfo->PartitionEntry[x].StartingOffset.QuadPart = stMasterBootSector->stPartition [ x ].dwSectorsPreceding;
								pDInfo->PartitionEntry[x].StartingOffset.QuadPart *= (LONGLONG)BYTESPERSECTOR;
								pDInfo->PartitionEntry[x].PartitionLength.QuadPart = stMasterBootSector->stPartition [ x ].dwLengthInSectors;
								pDInfo->PartitionEntry[x].PartitionLength.QuadPart *= (LONGLONG)BYTESPERSECTOR;
								pDInfo->PartitionEntry[x].HiddenSectors = 0;
								pDInfo->PartitionEntry[x].PartitionNumber = x;
								pDInfo->PartitionEntry[x].PartitionType = stMasterBootSector->stPartition [ x ].cOperatingSystem;
								pDInfo->PartitionEntry[x].BootIndicator = stMasterBootSector->stPartition [ x ].cBoot == 0x80;
								pDInfo->PartitionEntry[x].RecognizedPartition = TRUE; // Well....
								pDInfo->PartitionEntry[x].RewritePartition = FALSE;
							}
						}
						catch ( ... )
						{
							delete [] pDiskInfo;
							throw;
						}
					}
					else
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
				else
				{
					LogErrorMessage3(L"Failed to read from device %s (%d)", szTemp, GetLastError());
				}
			}
        }
        else
        {
            pDiskInfo = new BYTE [dwBytesAllocated];
            if (pDiskInfo)
            {
                try
                {
                    // NOTE!  This ioctl is not appropriate for whistler and beyond.  However, nec98 isn't supported
                    // for whistler and beyond either.  The only reason this code is still here is that we MIGHT
                    // backprop this dll to w2k.
					while ( pDiskInfo && !( bSucceeded || bFailure ) )
					{
						if (!DeviceIoControl(
							hDiskHandle,
							IOCTL_DISK_GET_DRIVE_LAYOUT,
							NULL,
							0,
							pDiskInfo,
							dwBytesAllocated,
							&dwBytes,
							NULL))
						{
							if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
							{
								if ( pDiskInfo )
								{
									delete [] pDiskInfo;
									pDiskInfo = NULL;
								}

								dwBytesAllocated = dwBytesAllocated + dwBytesAllocatedPartition;
								pDiskInfo = new BYTE [dwBytesAllocated];
							}
							else
							{
								LogErrorMessage3(L"Failed to IOCTL_DISK_GET_DRIVE_LAYOUT_EX device %s (%d)", szTemp, GetLastError());

								if ( pDiskInfo )
								{
									delete [] pDiskInfo;
									pDiskInfo = NULL;
								}

								bFailure = FALSE;
							}
						}
						else
						{
							dwType = 1;

							bSucceeded = TRUE;
						}
					}
                }
                catch ( ... )
                {
					if ( pDiskInfo )
					{
						delete [] pDiskInfo;
						pDiskInfo = NULL;
					}

                    throw;
                }
            }
            else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
        }
    }
    else
    {
        LogErrorMessage3(L"Failed to open device %s (%d)", szTemp, GetLastError());
    }

    return (LPBYTE)pDiskInfo;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\displayctrlcfg.cpp ===
//

// DSPCTLCFG.CPP -- video managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 09/23/95     a-skaja     Prototype for demo
// 09/27/96     jennymc     Updated to current standards
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <cregcls.h>

#include "displayctrlcfg.h"

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32DisplayControllerConfig win32DspCtlCfg ( PROPSET_NAME_DSPCTLCFG , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayControllerConfig::CWin32DisplayControllerConfig
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DisplayControllerConfig :: CWin32DisplayControllerConfig (

	LPCWSTR strName,
    LPCWSTR pszNamespace

) : Provider ( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DisplayControllerConfig::~CWin32DisplayControllerConfig
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DisplayControllerConfig::~CWin32DisplayControllerConfig()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayControllerConfig :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
	// Find the instance depending on platform id.

#ifdef NTONLY
	BOOL fReturn = RefreshNTInstance ( pInstance ) ;
#endif

#ifdef WIN9XONLY
	BOOL fReturn = RefreshWin95Instance ( pInstance ) ;
#endif

	return ( fReturn ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DisplayControllerConfig :: EnumerateInstances (

	MethodContext *pMethodContext ,
	long lFlags /*= 0L*/
)
{
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;
	if ( NULL != pInstance )
	{
		// Get the proper OS dependent instance

#ifdef NTONLY

		BOOL fReturn = GetNTInstance ( pInstance ) ;

#endif

#ifdef WIN9XONLY

		BOOL fReturn = GetWin95Instance ( pInstance ) ;
#endif

		// Commit the instance if'n we got it.

		if ( fReturn )
		{
			hr = pInstance->Commit ( ) ;
		}

		hr = WBEM_S_NO_ERROR ;
	}

	return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32DisplayControllerConfig :: RefreshNTInstance (

	CInstance *pInstance
)
{
	BOOL fReturn = FALSE ;

	// Check that we will be getting the requested instance

	CHString strName ;
	GetNameNT ( strName ) ;

	CHString strInstanceName ;
	pInstance->GetCHString ( IDS_Name , strInstanceName ) ;

	if ( 0 == strInstanceName.CompareNoCase ( strName ) )
	{
		fReturn = GetNTInstance ( pInstance ) ;
	}

    return fReturn;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY

BOOL CWin32DisplayControllerConfig :: RefreshWin95Instance ( CInstance *pInstance )
{
	BOOL fReturn = FALSE ;

	// Check that we will be getting the requested instance

	CHString strName ;
	GetNameWin95 ( strName ) ;

	CHString strInstanceName ;
	pInstance->GetCHString( IDS_Name, strInstanceName );

	if ( 0 == strInstanceName.CompareNoCase ( strName ) )
	{
		fReturn = GetWin95Instance ( pInstance );
	}

    return fReturn ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

BOOL CWin32DisplayControllerConfig :: GetNTInstance ( CInstance *pInstance )
{
	// Get the adapter name from the registry

	CHString strName ;
	GetNameNT ( strName ) ;

	pInstance->SetCHString ( IDS_Name , strName ) ;
	pInstance->SetCHString ( IDS_Caption , strName ) ;
	pInstance->SetCHString ( _T("SettingID") , strName ) ;
	pInstance->SetCHString ( IDS_Description , strName ) ;

	BOOL fReturn = FALSE ;

	// Get commonly available information, then go ahead and obtain
	// NT applicable information

	if ( GetCommonVideoInfo ( pInstance ) )
	{

		// For now, the only NT Specific value we are getting is the Refresh Rate
		// Don't fail if GetDC fails here since we got mosty of the values anyway

		HDC hdc = GetDC ( NULL );
		if ( NULL != hdc )
		{
			try
			{
				pInstance->SetDWORD ( IDS_RefreshRate , (DWORD) GetDeviceCaps ( hdc , VREFRESH ) ) ;
			}
			catch ( ... )
			{
				ReleaseDC ( NULL, hdc ) ;

				throw ;
			}

			ReleaseDC ( NULL, hdc ) ;

		}

		// We need the refresh rate to set the video mode correctly.

		SetVideoMode ( pInstance ) ;

		fReturn = TRUE ;

	}

	return fReturn ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY

BOOL CWin32DisplayControllerConfig :: GetWin95Instance ( CInstance *pInstance )
{
	// Get the adapter name

	CHString strName ;
	GetNameWin95 ( strName ) ;

	pInstance->SetCHString ( IDS_Name , strName ) ;
	pInstance->SetCHString ( IDS_Caption , strName ) ;
	pInstance->SetCHString ( L"SettingID" , strName ) ;
	pInstance->SetCHString ( IDS_Description , strName ) ;


	BOOL fReturn = GetCommonVideoInfo ( pInstance ) ;

	// We don't do this in GetCommonVideoInfo() because NT has some
	// values it gets separately (after the common info).

	SetVideoMode ( pInstance ) ;

    return fReturn ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32DisplayControllerConfig :: GetCommonVideoInfo ( CInstance *pInstance )
{
    HDC hdc = GetDC ( NULL ) ;
    if( hdc )
	{
		try
		{
			//  Get the common info
			//=============================

			DWORD dwTemp = (DWORD) GetDeviceCaps ( hdc , BITSPIXEL ) ;
			pInstance->SetDWORD ( IDS_BitsPerPixel , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , PLANES ) ;
			pInstance->SetDWORD ( IDS_ColorPlanes , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , NUMCOLORS ) ;
			pInstance->SetDWORD ( IDS_DeviceEntriesInAColorTable , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , NUMPENS ) ;
			pInstance->SetDWORD ( IDS_DeviceSpecificPens , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , HORZRES ) ;
			pInstance->SetDWORD ( IDS_HorizontalResolution , dwTemp ) ;

			dwTemp = (DWORD) GetDeviceCaps ( hdc , VERTRES ) ;
			pInstance->SetDWORD ( IDS_VerticalResolution , dwTemp ) ;

			if ( GetDeviceCaps ( hdc , RASTERCAPS ) & RC_PALETTE )
			{
				dwTemp = (DWORD) GetDeviceCaps ( hdc , SIZEPALETTE ) ;
				pInstance->SetDWORD ( IDS_SystemPaletteEntries , dwTemp ) ;

				dwTemp = (DWORD) GetDeviceCaps ( hdc , NUMRESERVED ) ;
				pInstance->SetDWORD ( IDS_ReservedSystemPaletteEntries , dwTemp ) ;
			}
		}
		catch ( ... )
		{
			ReleaseDC ( NULL , hdc ) ;

			throw ;
		}

		ReleaseDC ( NULL , hdc ) ;
	}
	else
	{
        return FALSE ;
	}

    return TRUE ;
}

/*****************************************************************************
 *
 *  FUNCTION    : EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32DisplayControllerConfig :: SetVideoMode ( CInstance *pInstance )
{
	DWORD dwBitsPerPixel = 0 ;
	DWORD dwHorizontalResolution = 0 ;
	DWORD dwVerticalResolution = 0 ;
	DWORD dwRefreshRate =0 ;

	pInstance->GetDWORD ( IDS_BitsPerPixel , dwBitsPerPixel ) ;
	pInstance->GetDWORD ( IDS_HorizontalResolution , dwHorizontalResolution ) ;
	pInstance->GetDWORD ( IDS_VerticalResolution , dwVerticalResolution ) ;
	pInstance->GetDWORD ( IDS_RefreshRate , dwRefreshRate ) ;

	// DevMode MUST be Zeroed out or NT 3.51

	DEVMODE	devmode ;

    memset ( &devmode , NULL , sizeof ( DEVMODE ) ) ;
    devmode.dmSize = sizeof ( DEVMODE ) ;

	// Enumerate the display modes until we find one that matches our settings

	DWORD dwModeNum = 0 ;
	BOOL fFoundMode	= FALSE ;

	// Not localized, deprecated anyway.
    while ( 0 != EnumDisplaySettings( NULL, dwModeNum, &devmode ) )
	{
		// Look for a hit.

		BOOL t_Status = devmode.dmBitsPerPel == dwBitsPerPixel &&
						devmode.dmPelsWidth == dwHorizontalResolution &&
						devmode.dmPelsHeight == dwVerticalResolution &&
						devmode.dmDisplayFrequency == dwRefreshRate ;

		if ( t_Status )
		{
			CHString strTemp ;

			CHString strVideoMode ;

			// Start with the resolution

			strVideoMode.Format (

				L"%u by %u pixels",
				devmode.dmPelsWidth,
				devmode.dmPelsHeight
			);

			if ( 32 == devmode.dmBitsPerPel )
			{
				strVideoMode += _T(", True Color") ;
			}
			else
			{
				// It's a power of two, so...

				DWORD dwNumColors = 1 << devmode.dmBitsPerPel ;

				strTemp.Format (

					L", %u Colors" ,
					dwNumColors
				) ;

				strVideoMode += strTemp ;
			}

			// Add in the vertical refresh rate, 0 and/or 1 are indicative of a default rate
			// specific to the device (set by jumpers or a propietary app).

			if ( 0 != devmode.dmDisplayFrequency &&	1 != devmode.dmDisplayFrequency )
			{
				strTemp.Format (

					L", %u Hertz",
					devmode.dmDisplayFrequency
				) ;

				strVideoMode += strTemp ;

				// If we're less than 50, it's interlaced.  This was straight out
				// of the NT Display Settings code, so I'm taking it on "faith".
				if ( 50 > devmode.dmDisplayFrequency )
				{
					strVideoMode += L", Interlaced";
				}
			}
#ifdef NTONLY
            else
			{
				// On Windows NT, if the refresh rate is zero or 1, a default rate is specified.  This
				// rate is either set on the hardware using jumpers or using a separate manufacturer
				// supplied configuration app.

				strVideoMode += _T(", Default Refresh Rate");
			}
#endif

			// Store the video mode and get out
			pInstance->SetCHString ( IDS_VideoMode, strVideoMode ) ;
			fFoundMode = TRUE ;

			break ;

		}	// IF mode matches

		dwModeNum ++ ;

		// To be safe clear out and reset DevMode due to the
		// sensitivity of NT 3.51

		memset ( & devmode , NULL , sizeof ( DEVMODE ) ) ;
		devmode.dmSize = sizeof ( DEVMODE ) ;

	}

	// If we didn't find a matching mode, then assume the adapter is configured incorrectly

	if ( !fFoundMode )
	{
		pInstance->SetCHString ( IDS_VideoMode, IDS_AdapterConfiguredIncorrect );
	}

}

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

void CWin32DisplayControllerConfig :: GetNameNT (

	CHString &strName
)
{
	// Store a default name in case something goes wrong
	strName = DSPCTLCFG_DEFAULT_NAME;

	// First get the key name that we will need to go to in order to get
	// the Adapter name.

	CRegistry reg ;

	CHString strAdapterNameKey ;

	DWORD dwRet = reg.Open (

		HKEY_LOCAL_MACHINE,
		WINNT_DSPCTLCFG_DISPLAYADAPTERNAME_KEY,
		KEY_READ
	) ;

	if ( ERROR_SUCCESS == dwRet )
	{
		reg.GetCurrentKeyValue ( WINNT_DSPCTLCFG_VIDEOADAPTERKEY_VALUE , strAdapterNameKey ) ;

		reg.Close () ;
	}

	// The string will not be empty if we got a value.


	if ( ! strAdapterNameKey.IsEmpty () )
	{
		// Look for the System name, which is the beginning of the subkey under HKEY_LOCAL_MACHINE
		// where we will be looking.

		INT	nIndex = strAdapterNameKey.Find ( _T("System") ) ;
		if ( -1 != nIndex )
		{
			// We found our index, so extract our key name, then open the key.  If that succeeds, then
			// there should be a binary value called "HardwareInformation.AdapterString" we can retrieve.
			// This binary value is actually a WSTR value which we can then copy into the Name field.

			strAdapterNameKey = strAdapterNameKey.Right ( strAdapterNameKey.GetLength() - nIndex ) ;

			dwRet = reg.Open (

				HKEY_LOCAL_MACHINE ,
				strAdapterNameKey ,
				KEY_READ
			) ;

			if ( ERROR_SUCCESS == dwRet )
			{
				BYTE *pbValue = NULL ;
				DWORD dwValueSize = 0 ;

				// Find out how big the string is, then allocate a buffer for it.

				dwRet = reg.GetCurrentBinaryKeyValue (

					WINNT_DSPCTLCFG_ADAPTERSTRING_VALUE_NAME,
					pbValue,
					&dwValueSize
				) ;

				if ( ERROR_SUCCESS == dwRet )
				{
					pbValue = new BYTE [ dwValueSize ] ;
					if ( NULL != pbValue )
					{
						try
						{
							dwRet = reg.GetCurrentBinaryKeyValue (

								WINNT_DSPCTLCFG_ADAPTERSTRING_VALUE_NAME,
								pbValue,
								&dwValueSize
							) ;

							if ( ERROR_SUCCESS == dwRet )
							{
								// Reset the name since we found a value

								strName = (LPWSTR) pbValue ;

                                // Get rid of CR+LF (thanks to the Stealth II G460).
                                // Otherwise, CIMOM will throw away the key.
                                strName = strName.SpanExcluding(L"\t\r\n");
							}

						}
						catch ( ... )
						{
							delete [] pbValue ;

							throw ;
						}

						delete [] pbValue ;
					}
					else
					{
						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}

				reg.Close ();

			}
		}
	}

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Creates instance of property set for each
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY

void CWin32DisplayControllerConfig :: GetNameWin95 ( CHString &strName )
{
	// There is a setting in System.Ini that may hold a value for the display driver.
	// So shades of Win16, use GetPrivateProfileString to do our dirty work for us.

	TCHAR szTemp [ 256 ] ;
	DWORD cbData = sizeof ( szTemp ) / sizeof(TCHAR);

	GetPrivateProfileString (

		WIN95_DSPCTLCFG_BOOT_DESC,
		WIN95_DSPCTLCFG_DISPLAY_DRV,
		DSPCTLCFG_DEFAULT_NAME,
		szTemp,
		cbData,
		WIN95_DSPCTLCFG_SYSTEM_INI
	) ;

	strName = szTemp ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dma.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// DMA.h -- DMA property set description for WBEM MO                 //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
#define PROPSET_NAME_DMA  L"Win32_DMAChannel"

class CWin32DMAChannel : public Provider{

    public:

        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32DMAChannel(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32DMAChannel() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        



#ifdef NTONLY
#if NTONLY > 4
        void SetNonKeyProps(
            CInstance* pInstance, 
            CDMADescriptor* pDMA);

        bool FoundAlready(
            ULONG ulKey,
            std::set<long>& S);
#endif
        HRESULT GetNTDMA(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#else
        HRESULT GetWin9XDMA(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#endif

        //=================================================
        // Utility
        //=================================================
    private:
        bool BitSet(unsigned int iUsed[], ULONG iPos, DWORD iSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\driverfordevice.h ===
/******************************************************************



   DriverForDevice.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef _CDRIVERFORDEVICE_H_
#define _CDRIVERFORDEVICE_H_

#define PROVIDER_NAME_DRIVERFORDEVICE L"Win32_DriverForDevice"
#define PROVIDER_NAME_PRINTER		  L"Win32_Printer"
#define PROVIDER_NAME_PRINTERDRIVER   L"Win32_PrinterDriver"

#define ANTECEDENT					  L"Antecedent"
#define DEPENDENT					  L"Dependent"
#define DRIVERNAME					  L"Name"
#define DEVICEID				      L"DeviceID"


class CDriverForDevice : public Provider 
{
public:
    CDriverForDevice ( LPCWSTR lpwszClassName,  LPCWSTR lpwszNameSpace ) ;
    virtual ~CDriverForDevice () ;

public:

    HRESULT EnumerateInstances ( MethodContext *pMethodContext, long lFlags = 0L ) ;
    HRESULT GetObject ( CInstance *pInstance, long lFlags, CFrameworkQuery &Query ) ;
	HRESULT ExecQuery ( MethodContext *pMethodContext, CFrameworkQuery &Query, long lFlags );

private:

 	HRESULT EnumerateAllDriversForDevice ( MethodContext *pMethodContext );
	void MakeObjectPath ( LPWSTR &a_ObjPathString, LPWSTR a_ClassName, DRIVER_INFO_2 *pDriverBuff );
	HRESULT SetError();
	HRESULT ConvertDriverKeyToValues ( IN CHString  Key, IN OUT CHString &DriverName, IN OUT DWORD &dwVersion, IN OUT CHString &Environment, IN WCHAR cDelimiter = L',' );
	HRESULT GetDriversFromQuery ( CHStringArray &t_DriverObjPath, CHStringArray &t_DriverNameArray, CHStringArray &t_EnvironmentArray, DWORD **pdwVersion );
	HRESULT GetPrintersFromQuery ( CHStringArray &t_PrintersObjPath, CHStringArray &t_Printers );
	HRESULT CommitInstance ( CHString &a_Driver, CHString &a_Printer, MethodContext *pMethodContext );

#if NTONLY >= 5
	HRESULT AssociateDriverToDevice (CHString &a_PrinterName, MethodContext *pMethodContext);
#endif

private:

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\displayctrlcfg.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// DisplayCtrlCfg.h -- Video display controller property set         //

//                      description for WBEM MO                      //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//                                                                   //
// 09/08/95     a-skaja     Prototype                                //
// 09/27/96     jennymc     Updated to meet current standards        //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define	PROPSET_NAME_DSPCTLCFG	L"Win32_DisplayControllerConfiguration"

//==================================================================

///////////////////////////////////////////////////////////////////////////////////////
//                                                                                   //
//                           PROPERTY SET DEFINITION                                 //
//                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////
#define WIN95_DSPCTLCFG_REGISTRY_KEY _T("System\\CurrentControlSet\\Services\\Class\\Display\\0000")
#define WIN95_DSPCTLCFG_MONITOR_TYPE_REGISTRY_KEY _T("System\\CurrentControlSet\\Services\\Class\\Monitor\\0000")
#define WIN95_DSPCTLCFG_MONITOR_MFG_REGISTRY_KEY _T("Enum\\Monitor\\Default_Monitor\\0001")
#define WINNT_DSPCTLCFG_REGISTRY_KEY             _T("HARDWARE\\DEVICEMAP\\DSPCTLCFG")
#define WIN95_DISPLAY_DRIVER_KEY			 _T("System\\CurrentControlSet\\Services\\Class\\Display")

#define	WINNT_DSPCTLCFG_ADAPTERSTRING_VALUE_NAME		_T("HardwareInformation.AdapterString")
#define	WINNT_DSPCTLCFG_DISPLAYADAPTERNAME_KEY			_T("HARDWARE\\DEVICEMAP\\VIDEO")
#define	WINNT_DSPCTLCFG_VIDEOADAPTERKEY_VALUE			_T("\\Device\\Video0")

#define WIN95_DSPCTLCFG_BOOT_DESC						_T("Boot.Description")
#define WIN95_DSPCTLCFG_DISPLAY_DRV						_T("Display.Drv")
#define	WIN95_DSPCTLCFG_SYSTEM_INI						_T("SYSTEM.INI")

#define	DSPCTLCFG_DEFAULT_NAME							_T("Current Display Controller Configuration")

#define ADAPTER_DESC _T("DriverDesc")
#define MONITOR_TYPE _T("DriverDesc")
#define MONITOR_MFG _T("DriverDesc")
#define MFG _T("Mfg")
#define ADAPTER_COMPATIBILITY                _T("Adapter Compatibility")
#define DSPCTLCFG_INFO_PATH                  _T("\\Device\\Video0")
#define SERVICES                             _T("\\SERVICES\\")
#define DEVICE                               _T("\\DEVICE")
#define SYSTEM                               _T("\\SYSTEM")
#define INTERLACED                           _T("DefaultSettings.Interlaced")
#define INSTALLED_DISPLAY_DRIVERS            _T("InstalledDisplayDrivers")
#define ADAPTER_RAM                          _T("HardwareInformation.MemorySize")
#define ADAPTER_DESCRIPTION                  _T("HardwareInformation.AdapterString")
#define ADAPTER_CHIPTYPE                     _T("HardwareInformation.ChipType")
#define ADAPTER_DAC_TYPE                     _T("HardwareInformation.DACType")
#define WINNT_HARDWARE_DESCRIPTION_REGISTRY_KEY _T("HARDWARE\\Description\\System")
#define DISPLAY_CONTROLLER                   _T("DisplayController")
#define INTERNAL                             _T("INTERNAL")
#define INTEGRATED_CIRCUITRY                 _T("Integrated circuitry/Internal")
#define ADD_ON_CARD                          _T("Add-on card on ")
#define MONITOR_PERIPHERAL                   _T("\\MonitorPeripheral\\0")
#define ZERO                                 _T("\\0")
#define IDENTIFIER                           _T("Identifier")
#define SLASH                                _T("\\")
#define INF_PATH		_T("InfPath")
#define INF_SECTION		_T("InfSection")
#define DRIVER_DATE		_T("DriverDate")
///////////////////////////////////////////////////////////////////////////////////////

class CWin32DisplayControllerConfig : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32DisplayControllerConfig( LPCWSTR strName, LPCWSTR pszNamespace ) ;
       ~CWin32DisplayControllerConfig() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );

        // Utility
        //========

        // Utility function(s)
        //====================

    private:

#ifdef NTONLY
	    BOOL GetNTInstance( CInstance* pInstance );
	    BOOL RefreshNTInstance( CInstance* pInstance );
		void GetNameNT( CHString& strName );
#endif
#ifdef WIN9XONLY
	    BOOL GetWin95Instance(  CInstance* pInstance );
	    BOOL RefreshWin95Instance( CInstance* pInstance );
		void GetNameWin95( CHString& strName );
#endif
        BOOL GetCommonVideoInfo( CInstance* pInstance );

		void SetVideoMode( CInstance* pInstance );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\elementsetting.cpp ===
//=================================================================

//

// ElementSetting.cpp

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>

#include "ElementSetting.h"

//========================

CWin32AssocElementToSettings::CWin32AssocElementToSettings(
const CHString&	strName,
const CHString& strElementClassName,
const CHString&	strElementBindingPropertyName,
const CHString& strSettingClassName,
const CHString& strSettingBindingPropertyName,
LPCWSTR			pszNamespace )
:	Provider( strName, pszNamespace ),
	m_strElementClassName( strElementClassName ),
	m_strElementBindingPropertyName( strElementBindingPropertyName ),
	m_strSettingClassName( strSettingClassName  ),
	m_strSettingBindingPropertyName( strSettingBindingPropertyName )
{

	// Binding Property Name and Setting Property Name MUST either
	// both be empty or both have values

	ASSERT_BREAK(	( strElementBindingPropertyName.IsEmpty() && strSettingBindingPropertyName.IsEmpty() )
				||	( !strElementBindingPropertyName.IsEmpty() && !strSettingBindingPropertyName.IsEmpty() ) );
}

CWin32AssocElementToSettings::~CWin32AssocElementToSettings()
{
}

HRESULT CWin32AssocElementToSettings::EnumerateInstances( MethodContext*  pMethodContext, long lFlags /*= 0L*/ )
{
	HRESULT		hr	=	WBEM_S_NO_ERROR;

    // Perform queries
    //================

	TRefPointerCollection<CInstance>	elementList;
	TRefPointerCollection<CInstance>	settingsList;

	REFPTRCOLLECTION_POSITION	pos;

   CHString sQuery1, sQuery2;

   if (m_strElementBindingPropertyName.IsEmpty()) {
      sQuery1.Format(L"SELECT __RELPATH FROM %s", m_strElementClassName);
   } else {
      sQuery1.Format(L"SELECT __RELPATH, %s FROM %s", m_strElementBindingPropertyName, m_strElementClassName);
   }

   if (m_strSettingBindingPropertyName.IsEmpty()) {
      sQuery2.Format(L"SELECT __RELPATH FROM %s", m_strSettingClassName);
   } else {
      sQuery2.Format(L"SELECT __RELPATH, %s FROM %s", m_strSettingBindingPropertyName, m_strSettingClassName);
   }

	// grab all of both items that could be endpoints
//	if (SUCCEEDED(CWbemProviderGlue::GetAllInstances( m_strElementClassName, &elementList, IDS_CimWin32Namespace, pMethodContext ))
//		&&
//		SUCCEEDED(CWbemProviderGlue::GetAllInstances( m_strSettingClassName, &settingsList, IDS_CimWin32Namespace, pMethodContext )) )
   if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery1, &elementList, pMethodContext, IDS_CimWin32Namespace))
      &&
      SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(sQuery2, &settingsList, pMethodContext, IDS_CimWin32Namespace)))

	{
		if ( elementList.BeginEnum( pos ) )
		{

			// For each element, check the settings list for associations
        	CInstancePtr pElement;

			for (pElement.Attach(elementList.GetNext( pos )) ;
                 SUCCEEDED(hr) && ( pElement != NULL );
                 pElement.Attach(elementList.GetNext( pos )) )
			{

				hr = EnumSettingsForElement( pElement, settingsList, pMethodContext );

			}	// IF GetNext Computer System

			elementList.EndEnum();

		}	// IF BeginEnum

	}	// IF GetInstancesByQuery

	return hr;

}

HRESULT CWin32AssocElementToSettings::EnumSettingsForElement(
CInstance*							pElement,
TRefPointerCollection<CInstance>&	settingsList,
MethodContext*						pMethodContext )
{

	HRESULT		hr	=	WBEM_S_NO_ERROR;

	REFPTRCOLLECTION_POSITION	pos;

	CHString	strElementPath,
				strSettingPath;

	// Pull out the object path of the element as the various
	// settings object paths will be associated to this value

	if ( GetLocalInstancePath( pElement, strElementPath ) )
	{

		if ( settingsList.BeginEnum( pos ) )
		{

        	CInstancePtr pInstance;
        	CInstancePtr pSetting;

			for (pSetting.Attach(settingsList.GetNext( pos ) );
                 SUCCEEDED(hr) && ( pSetting != NULL );
                 pSetting.Attach(settingsList.GetNext( pos ) ))
			{
				// Check if we have an association

				if ( AreAssociated( pElement, pSetting ) )
				{
					// Get the path to the setting object and create us an association.

					if ( GetLocalInstancePath( pSetting, strSettingPath ) )
					{

						pInstance.Attach(CreateNewInstance( pMethodContext ));
						if ( NULL != pInstance )
						{
							pInstance->SetCHString( IDS_Element, strElementPath );
							pInstance->SetCHString( IDS_Setting, strSettingPath );

							// Invalidates pointer
							hr = pInstance->Commit(  );
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}

					}	// IF GetPath to Setting Object

				}	// IF AreAssociated

			}	// WHILE GetNext

			settingsList.EndEnum();

		}	// IF BeginEnum

	}	// IF GetLocalInstancePath

	return hr;

}

HRESULT CWin32AssocElementToSettings::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	HRESULT		hr;

	CInstancePtr pElement;
	CInstancePtr pSetting;

	CHString	strElementPath,
				strSettingPath;

	pInstance->GetCHString( IDS_Element, strElementPath );
	pInstance->GetCHString( IDS_Setting, strSettingPath );

	// If we can get both objects, test for an association

	if (	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strElementPath, &pElement, pInstance->GetMethodContext() ))
		&&	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strSettingPath, &pSetting, pInstance->GetMethodContext() )) )
	{
        if (AreAssociated( pElement, pSetting ))
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
	}

	return ( hr );
}

BOOL CWin32AssocElementToSettings::AreAssociated( CInstance* pElement, CInstance* pSetting )
{
	BOOL	fReturn = FALSE;

	// If we've got Binding property names, the properties MUST be checked, otherwise,
	// the objects are assumed to be associated

	if ( !m_strElementBindingPropertyName.IsEmpty() && !m_strSettingBindingPropertyName.IsEmpty() )
	{
		variant_t vElementValue, vSettingValue;

		// Get the property values and if they are equal, we have an association

		if (	pElement->GetVariant( m_strElementBindingPropertyName, vElementValue )
			&&	pSetting->GetVariant( m_strSettingBindingPropertyName, vSettingValue ) )
		{

			fReturn = CompareVariantsNoCase(&vElementValue, &vSettingValue);

		}

	}
	else
	{
		fReturn = TRUE;
	}

	return fReturn;
}

// Static Classes
CWin32AssocUserToDesktop::CWin32AssocUserToDesktop(void) : CWin32AssocElementToSettings(L"Win32_UserDesktop",
																						L"Win32_UserAccount",
																						L"Domain, Name",
																						L"Win32_Desktop",
																						L"Name",
																						IDS_CimWin32Namespace)
{
}

// only difference betweeen this and the base class
// is that it will use .DEFAULT
HRESULT CWin32AssocUserToDesktop::EnumSettingsForElement(
CInstance*							pElement,
TRefPointerCollection<CInstance>&	settingsList,
MethodContext*						pMethodContext )
{

	HRESULT		hr	=	WBEM_S_NO_ERROR;

    REFPTRCOLLECTION_POSITION	pos;

	CInstancePtr pSetting;
	CInstancePtr pInstance;

	CHString	strElementPath,
				strSettingPath,
				strDefaultPath;


	{
		// find de faulty setting
		CHString desktopName;
		if (settingsList.BeginEnum( pos ))
		{
	        CInstancePtr pSetting;
	        CInstancePtr pInstance;

			for (pSetting.Attach(settingsList.GetNext( pos ));
                 strDefaultPath.IsEmpty() && ( pSetting != NULL );
                 pSetting.Attach(settingsList.GetNext( pos )))
			{
				pSetting->GetCHString(IDS_Name,  desktopName);
				// check to see if the last few letters are ".Default"
				// there MAY be a way to fool this check, but it'd be rather obscure;
				//if (desktopName.Find(".DEFAULT") == (desktopName.GetLength() - 8))
				if (!desktopName.CompareNoCase(L".DEFAULT"))
                {
					GetLocalInstancePath( pSetting, strDefaultPath );
                }
			}
			settingsList.EndEnum();
		}
	}

	// Pull out the object path of the element as the various
	// settings object paths will be associated to this value
	bool bGotOne = false; // did we find one that was NOT .default?

	if ( GetLocalInstancePath( pElement, strElementPath ) )
	{
		if ( settingsList.BeginEnum( pos ) )
		{
			for( pSetting.Attach(settingsList.GetNext( pos )) ;
                (!bGotOne )	&& 	SUCCEEDED(hr) && ( pSetting != NULL ) ;
                pSetting.Attach(settingsList.GetNext( pos )) )

			{
				// Check if we have an association

				if ( bGotOne = AreAssociated( pElement, pSetting ) )
				{
					// Get the path to the setting object and create us an association.
					if ( GetLocalInstancePath( pSetting, strSettingPath ) )
					{
						pInstance.Attach(CreateNewInstance( pMethodContext ));

						if ( NULL != pInstance )
						{
							pInstance->SetCHString( IDS_Element, strElementPath );
							pInstance->SetCHString( IDS_Setting, strSettingPath );

							// Invalidates pointer
							hr = pInstance->Commit(  );
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}	// IF GetPath to Setting Object
				}	// IF AreAssociated
			}	// WHILE GetNext
			settingsList.EndEnum();
		}	// IF BeginEnum
	}	// IF GetLocalInstancePath

	// if we didn't got one, he gets the default...
	if (!bGotOne && !strDefaultPath.IsEmpty())
	{
		pInstance.Attach(CreateNewInstance( pMethodContext ));

		if ( NULL != pInstance )
		{
			pInstance->SetCHString( IDS_Element, strElementPath );
			pInstance->SetCHString( IDS_Setting, strDefaultPath );

			// Invalidates pointer
			hr = pInstance->Commit(  );
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}


// element is account
// setting is desktop
BOOL CWin32AssocUserToDesktop::AreAssociated( CInstance* pElement, CInstance* pSetting )
{
	CHString userName, desktopName, userQualifiedName;

	pElement->GetCHString(IDS_Name,   userName);
	pSetting->GetCHString(IDS_Name,   desktopName);

#ifdef NTONLY
	{
		CHString userDomain;
		pElement->GetCHString(IDS_Domain, userDomain);
		userQualifiedName = userDomain + L'\\' + userName;
	}
#endif
#ifdef WIN9XONLY
		userQualifiedName = userName;
#endif

	return (desktopName.CompareNoCase(userQualifiedName) == 0);
}

// only difference betweeen this and the base class
// is that it will use .DEFAULT
HRESULT CWin32AssocUserToDesktop::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
	CInstancePtr pElement;
	CInstancePtr pSetting;
    HRESULT hr;

	CHString	strElementPath,
				strSettingPath;

	pInstance->GetCHString( IDS_Element, strElementPath );
	pInstance->GetCHString( IDS_Setting, strSettingPath );

	// If we can get both objects, test for an association

	if (	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strElementPath, &pElement, pInstance->GetMethodContext() ))
		&&	SUCCEEDED(hr = CWbemProviderGlue::GetInstanceByPath( strSettingPath, &pSetting, pInstance->GetMethodContext() )) )
	{
		if (!AreAssociated( pElement, pSetting ))
		{
            hr = WBEM_E_NOT_FOUND;

			CHString desktopName;
			pSetting->GetCHString(IDS_Name,   desktopName);
            desktopName.MakeUpper();

			// okay, we're trying to match with default
			// only a match if the user DOESN'T have his own...
			if (desktopName.Find(L".DEFAULT") == (desktopName.GetLength() - 8))
			{
				// note local "desktopName" superceding the outer scope
                CHString userName, desktopName, userQualifiedName;

				pElement->GetCHString(IDS_Name,   userName);
				pSetting->GetCHString(IDS_Name,   desktopName);

#ifdef NTONLY
				{
					CHString userDomain;
					pElement->GetCHString(IDS_Domain, userDomain);
					userQualifiedName = userDomain + L'\\' + userName;
				}
#endif
#ifdef WIN9XONLY
					userQualifiedName = userName;
#endif

				CHString newPath;
				CInstancePtr pNewSetting;
				newPath.Format(L"Win32_Desktop.Name=\"%s\"", (LPCWSTR) userQualifiedName);

				if (FAILED(CWbemProviderGlue::GetInstanceByPath( newPath, &pNewSetting, pInstance->GetMethodContext() )))
                {
					hr = WBEM_S_NO_ERROR;
                }
			}
        }
        else
        {
            hr = WBEM_S_NO_ERROR;
        }
	}

	return ( hr );
}


CWin32AssocUserToDesktop MyUserToDesktop;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dllmain.h ===
//***************************************************************************

//

//  MAINDLL.H

// 

//  Module: WBEM Framework Instance provider 

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

HRESULT RegisterServer(TCHAR *a_pName, REFGUID a_rguid ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\dma.cpp ===
/////////////////////////////////////////////////////////////////

//

// DMA.CPP -- DMA managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 10/18/95     a-skaja     Prototype for demo
// 09/10/96     jennymc     Updated to current standards
//
/////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include <conio.h>
#include <winnls.h>
#include <wincon.h>

#include "chwres.h"
#include "ntdevtosvcsearch.h"
#include "resource.h"
#include <set>

#include "DMA.h"

CWin32DMAChannel MyCWin32DMAChannelSet ( PROPSET_NAME_DMA , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::CWin32DMAChannel
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32DMAChannel :: CWin32DMAChannel (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}
/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::~CWin32DMAChannel
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32DMAChannel :: ~CWin32DMAChannel ()
{
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DMAChannel :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{

#ifdef NTONLY

 	HRESULT hr = GetNTDMA ( NULL , pInstance ) ;

#else

 	HRESULT hr = GetWin9XDMA ( NULL , pInstance ) ;

#endif

    return hr ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DMAChannel :: EnumerateInstances (

	MethodContext *pMethodContext ,
	long lFlags /*= 0L*/)
{

#ifdef NTONLY

	HRESULT hr = GetNTDMA ( pMethodContext , NULL ) ;

#else

	HRESULT hr = GetWin9XDMA ( pMethodContext , NULL ) ;
#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY

HRESULT CWin32DMAChannel :: GetNTDMA (

	MethodContext *pMethodContext ,
    CInstance *pInstance
)
{
    HRESULT hr = WBEM_S_NO_ERROR ;

	CInstancePtr pInstanceAlias ( pInstance );
    //=======================================
    // If we are refreshing a specific
    // instance, get which channel we are
    // going for
    //=======================================

	DWORD ChannelNumberToRefresh ;

    if ( pInstanceAlias )
	{
        pInstanceAlias->GetDWORD ( IDS_DMAChannel, ChannelNumberToRefresh ) ;
	}

    //=======================================
    // Create hardware system resource list &
    // get the head of the list
    //=======================================

#if NTONLY == 4
    CHWResource HardwareResource ;
    HardwareResource.CreateSystemResourceLists () ;

    SYSTEM_RESOURCES SystemResource ;
    SystemResource = HardwareResource._SystemResourceList;


    // Just count how many DMAs we're going to find.  We need this so
    // we can build an array to keep the DMAs found so we don't commit
    // the same DMA more than once.  (This problem only seems to happen
    // on NT5.

    LPRESOURCE_DESCRIPTOR ResourceDescriptor ;

	int nFound = 0 ;
	int nDMA ;

    for (	nDMA = 0, ResourceDescriptor = SystemResource.DmaHead;
			ResourceDescriptor;
			ResourceDescriptor = ResourceDescriptor->NextSame, nDMA++
	)
    {
    }

    DWORD *pdwDMAFound = new DWORD [ nDMA ] ;

	if ( pdwDMAFound )
	{
		try
		{
			// Go through the list of DMAs.

			for (	ResourceDescriptor = SystemResource.DmaHead;
					ResourceDescriptor;
					ResourceDescriptor = ResourceDescriptor->NextSame
			)
			{
				//===============================================================
				//  If we are just trying to refresh a specific one and it is NOT
				//  the one we want, get the next one...
				//===============================================================
				if ( ! pMethodContext )
				{
					if ( ChannelNumberToRefresh != ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel )
					{
						continue ;
					}
				}
				else
				{
					// Look to see if we already have this DMA value.

					for ( int i = 0; i < nFound; i++ )
					{
						// Skip this DMA if we already have it.
						if ( ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel == pdwDMAFound [ i ] )
						{
							break ;
						}
					}

					// Skip this DMA if we already have it.
					// If we didn't find it, i == nFound.

					if ( i != nFound )
					{
						continue ;
					}

					pdwDMAFound[nFound++] = ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ;

					pInstanceAlias.Attach( CreateNewInstance ( pMethodContext ) );
				
					pInstanceAlias->SetDWORD ( IDS_DMAChannel , ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ) ;
				}

				//===============================================================
				// If we are here, we want it
				//===============================================================

				//---------------------------------------------------------------
				// Set defaults for unknown items

				pInstanceAlias->SetWBEMINT16 ( L"AddressSize" , 0 ) ;
				pInstanceAlias->SetDWORD ( L"MaxTransferSize" , 0 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"ByteMode" , 2 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"WordMode" , 2 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"ChannelTiming" , 2 ) ;
				pInstanceAlias->SetWBEMINT16 ( L"TypeCTiming" , 2 ) ;

				SAFEARRAYBOUND rgsabound [ 1 ] ;

				rgsabound [ 0 ].cElements = 1 ;
				rgsabound [ 0 ].lLbound = 0 ;

				SAFEARRAY *sa = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
				if ( sa )
				{
					try
					{
						long ix [ 1 ] ;

						ix [ 0 ] = 0 ;
						WORD wWidth = 0;

						HRESULT t_Result = SafeArrayPutElement ( sa , ix , &wWidth ) ;
						if ( t_Result != E_OUTOFMEMORY )
						{
							VARIANT vValue;

							VariantInit(&vValue);

							V_VT(&vValue) = VT_I2 | VT_ARRAY ;
							V_ARRAY(&vValue) = sa ;
							sa = NULL ;

							try
							{
								pInstanceAlias->SetVariant(L"TransferWidths", vValue);
							}
							catch ( ... )
							{
								VariantClear ( & vValue ) ;

								throw ;
							}

							VariantClear ( & vValue ) ;
						}
						else
						{
							SafeArrayDestroy ( sa ) ;
							sa = NULL ;

							throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
						}
					}
					catch ( ... )
					{
						if ( sa )
						{
							SafeArrayDestroy ( sa ) ;
						}

						throw ;
					}
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
				//---------------------------------------------------------------

				CHString sTemp ;
				Format ( sTemp , IDR_ChannelFormat , ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ) ;

				pInstanceAlias->SetCHString ( IDS_Name , sTemp ) ;

				CHString sDesc ;
				Format ( sDesc , IDR_ChannelFormat , ResourceDescriptor->CmResourceDescriptor.u.Dma.Channel ) ;

				pInstanceAlias->SetCHString ( IDS_Caption , sDesc ) ;

				pInstanceAlias->SetCHString ( IDS_Description , sDesc ) ;

				pInstanceAlias->SetDWORD (IDS_Port, ResourceDescriptor->CmResourceDescriptor.u.Dma.Port ) ;

				pInstanceAlias->SetCharSplat ( IDS_Status , IDS_OK ) ;

				SetCreationClassName ( pInstanceAlias ) ;

				pInstanceAlias->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

				pInstanceAlias->SetCHString ( IDS_CSCreationClassName , _T("Win32_ComputerSystem") ) ;

				pInstanceAlias->SetWBEMINT16 ( IDS_Availability , 4 ) ;

				//===============================================================
				// Set return code
				//===============================================================

				hr = WBEM_NO_ERROR ;

				if ( pMethodContext )
				{
					hr = pInstanceAlias->Commit ( ) ;
				}
			}
		}
		catch ( ... )
		{
			delete [] pdwDMAFound ;

			throw ;
		}

		delete [] pdwDMAFound ;
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

#else   // Modernized approach: use Config Manager.

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    std::set<long> setDMA;
    bool fDone = false;
    bool fFound = false; 

    if(cfgManager.GetDeviceList(deviceList))
    {
        REFPTR_POSITION posDev;

        if(deviceList.BeginEnum(posDev))
        {
            // Walk the list
            CConfigMgrDevicePtr pDevice;
            for(pDevice.Attach(deviceList.GetNext(posDev));
                SUCCEEDED(hr) && (pDevice != NULL) && !fDone;
                pDevice.Attach(deviceList.GetNext(posDev)))
            {
				// Enumerate the device's DMA resource usage...
                CDMACollection DevDMACollection;
                REFPTR_POSITION posDMA;

                pDevice->GetDMAResources(DevDMACollection);

                if(DevDMACollection.BeginEnum(posDMA))
                {
                    CDMADescriptorPtr pDMA(NULL);
                    // Walk the dma's
                    for(pDMA.Attach(DevDMACollection.GetNext(posDMA));
                        pDMA != NULL && !fDone && SUCCEEDED(hr);
                        pDMA.Attach(DevDMACollection.GetNext(posDMA)))
                    {
                        ULONG ulChannel = pDMA->GetChannel();

				        // If we are just trying to refresh a 
                        // specific one and it is NOT
				        // the one we want, get the next one...
				        if(!pMethodContext) // we were called by GetObject
				        {
					        if(ChannelNumberToRefresh != ulChannel)
					        {
						        continue;
					        }
                            else
                            {
                                SetNonKeyProps(pInstanceAlias, pDMA);
                                fDone = fFound = true;
                            }
				        }
				        else  // We were called by enum
				        {
                            // If we don't have this DMA already,
                            if(!FoundAlready(ulChannel, setDMA))
				            {
					            // add it to the list,
                                setDMA.insert(ulChannel);
                                // create a new instance,
                                pInstanceAlias.Attach(CreateNewInstance(pMethodContext));
				                // set that instance's properties,
					            pInstanceAlias->SetDWORD(IDS_DMAChannel, ulChannel);  // key
                                SetNonKeyProps(pInstanceAlias, pDMA);
                                // and commit it.
                                hr = pInstanceAlias->Commit();
                            }
                        }
                    }
                    DevDMACollection.EndEnum();
				}
            }
            deviceList.EndEnum();
        }
    }
#endif

    if(!fFound)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr ;
}


bool CWin32DMAChannel::FoundAlready(
    ULONG ulKey,
    std::set<long>& S)
{
    return (S.find(ulKey) != S.end());
}


void CWin32DMAChannel::SetNonKeyProps(
    CInstance* pInstance, 
    CDMADescriptor* pDMA)
{
    pInstance->SetWBEMINT16(L"AddressSize", 0);
	pInstance->SetDWORD(L"MaxTransferSize", 0);
	pInstance->SetWBEMINT16(L"ByteMode", 2);
	pInstance->SetWBEMINT16(L"WordMode", 2);
	pInstance->SetWBEMINT16(L"ChannelTiming", 2);
	pInstance->SetWBEMINT16(L"TypeCTiming", 2);

    SAFEARRAYBOUND rgsabound[1];

	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;

	SAFEARRAY *sa = ::SafeArrayCreate(VT_I2, 1, rgsabound);
	if(sa)
	{
		try
		{
			long ix[1];

			ix[0] = 0;
			WORD wWidth = 0;

			if(::SafeArrayPutElement(sa , ix, &wWidth) != E_OUTOFMEMORY)
			{
				VARIANT vValue;
				::VariantInit(&vValue);
				V_VT(&vValue) = VT_I2 | VT_ARRAY;
				V_ARRAY(&vValue) = sa;
				sa = NULL;

				try
				{
					pInstance->SetVariant(L"TransferWidths", vValue);
				}
				catch(...)
				{
					::VariantClear(&vValue);
					throw;
				}

				::VariantClear(&vValue);
			}
			else
			{
				::SafeArrayDestroy(sa);
				sa = NULL ;

				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch(...)
		{
			if(sa)
			{
				::SafeArrayDestroy(sa);
			}
			throw;
		}
	}
	else
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    CHString chstrTemp;
    Format(chstrTemp, IDR_ChannelFormat, pDMA->GetChannel());
    pInstance->SetCHString(IDS_Name, chstrTemp);

    pInstance->SetCHString(IDS_Caption, chstrTemp);
    pInstance->SetCHString(IDS_Description, chstrTemp);

    // DMA ports are an invalid concept for W2K and later.
    // pInstanceAlias->SetDWORD(IDS_Port, ResourceDescriptor->CmResourceDescriptor.u.Dma.Port ) ;

    pInstance->SetCharSplat(IDS_Status, IDS_OK);
    SetCreationClassName(pInstance);
    pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
    pInstance->SetCHString(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
    pInstance->SetWBEMINT16(IDS_Availability, 4);
}
#else

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32DMAChannel::GetWin9XDMA (

	MethodContext *pMethodContext ,
    CInstance *pInstance
)
{
    HRESULT hr = WBEM_E_NOT_FOUND ;

	CInstancePtr pInstanceAlias ( pInstance );
    //=================================================================
    // If we are refreshing a specific instance, get which channel we
    // are going for
    //=================================================================

    DWORD ChannelNumberToRefresh ;

    if ( pInstanceAlias )
	{
        pInstanceAlias->GetDWORD ( IDS_DMAChannel , ChannelNumberToRefresh ) ;
    }

    //=================================================================
    // Get the latest DMA info from the Configuration Manager
    //=================================================================

    CConfigManager CMgr ( ResType_DMA ) ;

    if ( CMgr.RefreshList () )
	{
		unsigned int iUsed [8] = {0, 0, 0, 0, 0, 0, 0, 0};

        for ( int i = 0 ; i < CMgr.GetTotal () ; i++ )
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================

            DMA_INFO *pDMA = CMgr.GetDMA ( i ) ;

            // If this channel has already been reported

            if ( BitSet ( iUsed , pDMA->Channel , sizeof ( iUsed ) ) )
			{
                continue;
            }

            //=========================================================
            //  If we are just trying to refresh a specific one and it
            //  is NOT the one we want, get the next one...
            //=========================================================

            if ( ! pMethodContext )
			{
	            if ( ChannelNumberToRefresh != pDMA->Channel )
				{
	                continue ;
                }
		    }
            else
			{
                pInstanceAlias.Attach ( CreateNewInstance ( pMethodContext ) );
                
/*
 *	Only set key when creating new instances.
 */
	    		pInstanceAlias->SetDWORD ( IDS_DMAChannel , pDMA->Channel ) ;
            }

			//---------------------------------------------------------------
			// Set defaults for unknown items

			pInstanceAlias->SetWBEMINT16 ( L"AddressSize" , 0 ) ;
			pInstanceAlias->SetDWORD ( L"MaxTransferSize" , 0 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"ByteMode" , 2 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"WordMode" , 2 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"ChannelTiming" , 2 ) ;
			pInstanceAlias->SetWBEMINT16 ( L"TypeCTiming" , 2 ) ;
            pInstanceAlias->SetCharSplat ( IDS_Status , IDS_OK ) ;

			//===========================================================
			//  Get what we can
			//===========================================================

			SAFEARRAYBOUND rgsabound [ 1 ] ;

			rgsabound [ 0 ].cElements = 1 ;
			rgsabound [ 0 ].lLbound = 0 ;

			SAFEARRAY *sa = SafeArrayCreate ( VT_I2 , 1 , rgsabound ) ;
			if ( sa )
			{
				try
				{
					long ix [ 1 ] ;

					ix [ 0 ] = 0 ;

					HRESULT t_Result = SafeArrayPutElement ( sa , ix , & ( pDMA->ChannelWidth ) ) ;
					if ( t_Result != E_OUTOFMEMORY )
					{
						VARIANT vValue;

						VariantInit(&vValue);

						V_VT(&vValue) = VT_I2 | VT_ARRAY ;
						V_ARRAY(&vValue) = sa ;
						sa = NULL ;

						try
						{
							pInstanceAlias->SetVariant(L"TransferWidths", vValue);
						}
						catch ( ... )
						{
							VariantClear ( & vValue ) ;

							throw ;
						}

						VariantClear ( & vValue ) ;
					}
					else
					{
						SafeArrayDestroy ( sa ) ;
						sa = NULL ;

						throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					}
				}
				catch ( ... )
				{
					if ( sa )
					{
						SafeArrayDestroy ( sa ) ;
					}

					throw ;
				}
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			pInstanceAlias->SetWBEMINT16 ( IDS_Availability, 4 ) ;

			CHString strTemp;
			Format ( strTemp, IDR_DMAFormat , pDMA->Channel ) ;

			pInstanceAlias->SetCharSplat ( IDS_Caption, strTemp ) ;
			pInstanceAlias->SetCharSplat ( IDS_Description, strTemp ) ;
			pInstanceAlias->SetCHString ( IDS_Name, strTemp ) ;

#if NTONLY >= 5
            if (pDMA->Port != 0xffffffff)
            {
    			pInstanceAlias->SetDWORD(IDS_Port , pDMA->Port);
            }
#endif

			SetCreationClassName ( pInstanceAlias ) ;

			pInstanceAlias->SetCHString ( IDS_CSName , GetLocalComputerName () ) ;

			pInstanceAlias->SetCHString ( IDS_CSCreationClassName , _T("Win32_ComputerSystem" ) ) ;

			//===========================================================
			// Set return code
			//===========================================================

			hr = WBEM_NO_ERROR;

			//===========================================================
			//  If we just want this one, then break out of here,
			//  otherwise get them all
			//===========================================================

			if ( ! pMethodContext )
			{
				break;
			}
			else
			{
					hr = pInstanceAlias->Commit () ;
			}
		}
    }

    if ( ( ! pMethodContext ) && ( FAILED ( hr ) ) )
	{
        hr = WBEM_E_NOT_FOUND ;
    }

    return hr ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32DMAChannel::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

bool CWin32DMAChannel :: BitSet (

	unsigned int iUsed[],
	ULONG iPos,
	DWORD iSize
)
{
	bool bRet;

    // iIndex is which DWORD to modify
	DWORD iIndex = iPos / (sizeof(iUsed[0]) * 8);

    // Make sure we have that many dwords
	if (iIndex < iSize)
	{
	    // I don't know why I need these, but if I don't use them, the compiler keeps
	    // adding code to extend the sign.  Once the optimizer gets this, it shouldn't
	    // matter anyway.
		unsigned int a1, a2;

        // a1 will tell how many bits over within the current dword
        // we need to move
		a1 =   iPos - (iIndex * (sizeof(iUsed[0]) * 8));

        // a2 will have set the bit we are trying to set
		a2 = 1 << a1;

        // The return value will indicate whether that bit had already been set.
		bRet = iUsed[iIndex] & a2;

		iUsed[iIndex] |= a2;
	}
	else
	{
		bRet = false;
		LogErrorMessage(L"Overflow on irq table");
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\driverfordevice.cpp ===
/******************************************************************

   CriverForDevice.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  
   Description:  Association Class between Printer and Printer Driver
   
******************************************************************/
#include "precomp.h"
#include <lockwrap.h>
#include <DllWrapperBase.h>
#include <WinSpool.h>
#include <ObjPath.h>
#include "prnutil.h"

#include "driverForDevice.h"

#define DELIMITER			L","

CDriverForDevice MyCDriverForDevice ( 

	PROVIDER_NAME_DRIVERFORDEVICE , 
	IDS_CimWin32Namespace
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CDfsJnPtReplica::CDfsJnPtReplica
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CDriverForDevice :: CDriverForDevice (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CDriverForDevice::~CDriverForDevice
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CDriverForDevice :: ~CDriverForDevice ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CDriverForDevice :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

#if NTONLY >= 5
	hRes = EnumerateAllDriversForDevice ( pMethodContext );

   	return ((hRes == WBEM_E_NOT_FOUND) ? WBEM_S_NO_ERROR : hRes);
#else
    return WBEM_E_NOT_SUPPORTED;
#endif

}


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CDriverForDevice :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    CHString t_Key1;
	CHString t_Key2;

    if ( pInstance->GetCHString (  ANTECEDENT, t_Key1 ) )
    {
	    if ( pInstance->GetCHString ( DEPENDENT, t_Key2 ) )
		{
			// here unparse Key2 and key1 the LinkName should be the same as that of t_key1 value entrypath
			CObjectPathParser t_ObjPathParser;
			ParsedObjectPath *t_Key1ObjPath;
			ParsedObjectPath *t_Key2ObjPath;

			// Parse the keys so that the values can be compared
			if ( t_ObjPathParser.Parse ( t_Key1, &t_Key1ObjPath ) == t_ObjPathParser.NoError  )
			{
				if ( t_Key1ObjPath != NULL )
				{
					try
					{
						if ( t_ObjPathParser.Parse ( t_Key2, &t_Key2ObjPath ) == t_ObjPathParser.NoError ) 
						{
							if ( t_Key2ObjPath != NULL ) 
							{
								// Use of delay loaded functions requires exception handler.
                                SetStructuredExceptionHandler seh;
                                try
								{
									CHString t_DriverName;
									CHString t_Environment;
									DWORD dwVersion;
									CHString t_DriverKey;
							
									if ( ( _wcsicmp ( t_Key2ObjPath->m_paKeys[0]->m_pName, DRIVERNAME ) == 0 ) && 
                                         (V_VT(&t_Key2ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR) )
									{
										t_DriverKey = t_Key2ObjPath->m_paKeys[0]->m_vValue.bstrVal;								
										hRes = ConvertDriverKeyToValues ( t_DriverKey, t_DriverName, dwVersion, t_Environment );
									}
									else
									{
										hRes = WBEM_E_INVALID_PARAMETER;
									}
						
									if ( SUCCEEDED ( hRes ) )
									{
										CHString t_PrinterName;

										if ( ( _wcsicmp ( t_Key1ObjPath->m_paKeys[0]->m_pName, DEVICEID ) == 0 ) &&
                                             ( V_VT(&t_Key1ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR ) )
										{
											t_PrinterName = t_Key1ObjPath->m_paKeys[0]->m_vValue.bstrVal;						
											// now check if for a given Printer Driver Exists
											BOOL bSuccess = FALSE;
											SmartClosePrinter hPrinter; 
											DWORD dwError;
											DWORD dwBytesNeeded;

											bSuccess = ::OpenPrinter ( TOBSTRT ( t_PrinterName.GetBuffer ( 0 ) ), (LPHANDLE) & hPrinter, NULL ) ;

											if ( bSuccess ) 
											{
													// Using this handle get the driver	
												BYTE *pDriverInfo = NULL;
												bSuccess = ::GetPrinterDriver( 
																hPrinter, 
																TOBSTRT ( t_Environment.GetBuffer ( 0 ) ), 
																2, 
																pDriverInfo, 
																0, 
																&dwBytesNeeded
															);
												if ( !bSuccess )
												{
													dwError = GetLastError();
													if ( dwError != ERROR_INSUFFICIENT_BUFFER )
													{
														hRes = SetError ();
													}
													else
													{
														// Here allocate memory and get the Driver again.
														pDriverInfo = new BYTE [ dwBytesNeeded ];

														if ( pDriverInfo )
														{
                                                            try
															{
																bSuccess = ::GetPrinterDriver( 
																				hPrinter, 
																				TOBSTRT ( t_Environment.GetBuffer ( 0 ) ), 
																				2, 
																				pDriverInfo, 
																				dwBytesNeeded, 
																				&dwBytesNeeded	
																			);

																if ( bSuccess )
																{
																	DRIVER_INFO_2 *pDriverBuf =  ( DRIVER_INFO_2 *)pDriverInfo;

																	if ((pDriverBuf->pName == NULL) ||
																		(pDriverBuf->pEnvironment == NULL) ||
																		( pDriverBuf->cVersion != dwVersion ) ||
																		(t_DriverName.CompareNoCase(pDriverBuf->pName) != 0) ||
																		(t_Environment.CompareNoCase(pDriverBuf->pEnvironment) != 0))
																	{
																		hRes = WBEM_E_NOT_FOUND;
																	}
																}
															}
                                                            catch(Structured_Exception se)
                                                            {
                                                                DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                                                                delete [] pDriverInfo;
																pDriverInfo = NULL;
                                                                hRes = WBEM_E_FAILED;
                                                            }
															catch ( ... )
															{
																delete [] pDriverInfo;
																pDriverInfo = NULL;
																throw;
															}
															delete [] pDriverInfo;
															pDriverInfo = NULL;
														}
														else
														{
															throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
														}
													}
												}
											}
											else
											{
												hRes = SetError ( );
											}
										}
										else
										{
											hRes = WBEM_E_INVALID_PARAMETER;
										}
									}
								}
                                catch(Structured_Exception se)
                                {
                                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                                    t_ObjPathParser.Free ( t_Key2ObjPath );
                                    hRes = WBEM_E_FAILED;
                                }
								catch ( ... )
								{
									t_ObjPathParser.Free ( t_Key2ObjPath );
									throw;
								}
								t_ObjPathParser.Free ( t_Key2ObjPath );
							}
						}
						else
						{
							hRes = WBEM_E_INVALID_PARAMETER;
						}
					}
					catch ( ... )
					{
						t_ObjPathParser.Free ( t_Key1ObjPath );
						throw;
					}
					t_ObjPathParser.Free ( t_Key1ObjPath );
				}

			}			
		}
		else
		{
			hRes = WBEM_E_PROVIDER_FAILURE;
		}
	}
	else
	{
		hRes = WBEM_E_PROVIDER_FAILURE;
	}

    return hRes ;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::ExecQuery
*
*  DESCRIPTION :    Optimization of the query based on only key value.
*
*****************************************************************************/
HRESULT CDriverForDevice :: ExecQuery ( 

	MethodContext *pMethodContext, 
	CFrameworkQuery &Query, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
	CHStringArray t_PrinterObjPath;
	CHStringArray t_DriverObjPath;

	CHStringArray t_EnvironmentArray;
	CHStringArray t_DriverNameArray; 
	CHStringArray t_Printers;
	DWORD *pdwVersion = NULL;


	// Both the properties being key cannot be null.
	hRes = Query.GetValuesForProp( ANTECEDENT, t_PrinterObjPath );
	if ( SUCCEEDED ( hRes ) )
	{
		hRes = Query.GetValuesForProp( DEPENDENT, t_DriverObjPath );
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( t_PrinterObjPath.GetSize () > 0 ) 
		{
			//  Get all the printers, in the t_PrinterObjPath arra
			hRes = GetPrintersFromQuery ( t_PrinterObjPath, t_Printers );
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( t_DriverObjPath.GetSize () > 0 )
		{
			hRes = GetDriversFromQuery ( t_DriverObjPath, t_DriverNameArray, t_EnvironmentArray, &pdwVersion );
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( ( t_PrinterObjPath.GetSize () > 0 ) && ( t_DriverObjPath.GetSize () > 0 ) )
		{
			if ( pdwVersion != NULL )
			{
				// Use of delay loaded functions requires exception handler.
                SetStructuredExceptionHandler seh;
                try
				{
					// For each Printer We need to get driver and if the driver exists in the above specified query
					// we need to commit that instance.
					for ( DWORD dwPrinter = 0; dwPrinter < t_Printers.GetSize (); dwPrinter++ )
					{
						SmartClosePrinter  hPrinter;

						BOOL bSuccess = ::OpenPrinter (

											TOBSTRT ( t_Printers.GetAt ( dwPrinter ).GetBuffer ( 0 ) ),
											& hPrinter,
											NULL
										) ;
						if ( bSuccess )
						{
							DRIVER_INFO_2 *pDriverInfo = NULL;
							DWORD bytesNeeded;
							bSuccess = ::GetPrinterDriver(
												hPrinter,     // printer object
												NULL,		// environment name
												2,         // information level
												( LPBYTE )pDriverInfo,  // driver data buffer
												0,         // size of buffer
												&bytesNeeded    // bytes received or required
											);
							if ( !bSuccess )
							{
								DWORD dwError = GetLastError();
	
								if( dwError == ERROR_INSUFFICIENT_BUFFER )
								{
									pDriverInfo = ( DRIVER_INFO_2 * ) new BYTE [ bytesNeeded ];

									if ( pDriverInfo != NULL )
									{
										try
										{
											bSuccess = ::GetPrinterDriver(
																hPrinter,     
																NULL,		
																2,         
																( LPBYTE )pDriverInfo,  
																bytesNeeded,         
																&bytesNeeded
														);
											if ( bSuccess )
											{
												// Search and commit
												for ( DWORD dwDrivers = 0; dwDrivers < t_DriverNameArray.GetSize(); dwDrivers++ )
												{
													if ( ( t_DriverNameArray.GetAt ( dwDrivers ).CompareNoCase ( TOBSTRT ( pDriverInfo->pName ) ) == 0 ) &&
														 ( t_EnvironmentArray.GetAt ( dwDrivers ).CompareNoCase ( TOBSTRT ( pDriverInfo->pEnvironment) ) == 0 ) &&
														 ( pdwVersion [ dwDrivers ] == pDriverInfo->cVersion ) )
													{
														// Commit the Instance
														CHString t_DriverKey;
														t_DriverKey.Format ( L"%s%s%d%s%s", 
																			 t_DriverNameArray.GetAt ( dwDrivers ),
																			 DELIMITER,
																			 pdwVersion [ dwDrivers ],
																			 DELIMITER,
																			 t_EnvironmentArray.GetAt ( dwDrivers )
																	 );
														hRes = CommitInstance ( t_DriverKey, t_Printers.GetAt ( dwPrinter ), pMethodContext );
													}
												}
											}
										}
                                        catch(Structured_Exception se)
                                        {
                                            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                                            delete [] pDriverInfo;
											pDriverInfo = NULL;
                                            hRes = WBEM_E_FAILED;
                                        }
										catch ( ... )
										{
											delete [] pDriverInfo;
											pDriverInfo = NULL;
											throw;
										}

										delete [] pDriverInfo;
										pDriverInfo = NULL;
									}
									else
									{
										throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
									}
								}
							}
						}
					}
				}
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                    delete [] pdwVersion;
					pdwVersion = NULL;
                    hRes = WBEM_E_FAILED;
                }
				catch ( ... )
				{
					delete [] pdwVersion;
					pdwVersion = NULL;
					throw;
				}
				delete [] pdwVersion;
				pdwVersion = NULL;
			}
		}
		else
		if ( t_PrinterObjPath.GetSize () > 0 )
		{
			// Use of delay loaded functions requires exception handler.
            for ( DWORD dwPrinter = 0; dwPrinter < t_Printers.GetSize (); dwPrinter++ )
			{
				AssociateDriverToDevice (t_Printers[dwPrinter], pMethodContext);
			}
		}
		else
		{
			hRes = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

#if NTONLY >= 5
HRESULT CDriverForDevice::AssociateDriverToDevice (CHString &a_PrinterName, MethodContext *pMethodContext)
{
	if (a_PrinterName.GetLength() == 0)
	{
		return WBEM_E_FAILED;
	}

	HRESULT hRes = WBEM_S_NO_ERROR;
    SetStructuredExceptionHandler seh;
	SmartClosePrinter hPrinter;

    try
    {
		BOOL bSuccess = ::OpenPrinter (

							TOBSTRT ( a_PrinterName.GetBuffer ( 0 ) ),
							& hPrinter,
							NULL
						) ;
		if ( bSuccess )
		{
			DRIVER_INFO_2 *pDriverInfo = NULL;
			DWORD bytesNeeded;
			bSuccess = ::GetPrinterDriver(
								hPrinter,     // printer object
								NULL,		// environment name
								2,         // information level
								( LPBYTE )pDriverInfo,  // driver data buffer
								0,         // size of buffer
								&bytesNeeded    // bytes received or required
							);
			if ( !bSuccess )
			{
				DWORD dwError = GetLastError();

				if( dwError == ERROR_INSUFFICIENT_BUFFER )
				{
					pDriverInfo = ( DRIVER_INFO_2 * ) new BYTE [ bytesNeeded ];

					if ( pDriverInfo != NULL )
					{
						try
						{
							bSuccess = ::GetPrinterDriver(
												hPrinter,     
												NULL,		
												2,         
												( LPBYTE )pDriverInfo,  
												bytesNeeded,         
												&bytesNeeded
										);
							if ( bSuccess )
							{
								// Commit the Instance
								CHString t_DriverKey;
								t_DriverKey.Format ( L"%s%s%d%s%s", 
													 pDriverInfo->pName,
													 DELIMITER,
													 pDriverInfo->cVersion,
													 DELIMITER,
													 pDriverInfo->pEnvironment
											 );
								CommitInstance ( t_DriverKey, a_PrinterName, pMethodContext );
							}
						}
                        catch(Structured_Exception se)
                        {
                            DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                            delete [] pDriverInfo;
							pDriverInfo = NULL;
                            hRes = WBEM_E_FAILED;
                        }
						catch ( ... )
						{
							delete [] pDriverInfo;
							pDriverInfo = NULL;
							throw;
						}

						delete [] pDriverInfo;
						pDriverInfo = NULL;
					}
				}
			}
		}
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());
        hRes = WBEM_E_FAILED;
    }

	return hRes;
}
#endif


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::EnumerateAllDriversForDevice
*
*  DESCRIPTION :    Enumerates all the drivers for Device
*
*****************************************************************************/
HRESULT CDriverForDevice::EnumerateAllDriversForDevice ( 
														
	MethodContext *pMethodContext 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
    DWORD PrinterFlags = PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS;

	BOOL bSuccess = FALSE;
	DWORD dwNeeded = 0;
	DWORD dwReturnedPrinters = 0;
	PRINTER_INFO_4 *pPrinterBuff = NULL;

	bSuccess = ::EnumPrinters(
					PrinterFlags,
					NULL,
					4,
					( LPBYTE) pPrinterBuff,  
					(DWORD ) 0L,
					&dwNeeded,
					&dwReturnedPrinters
				);

	if ( ! bSuccess )
	{
		DWORD dwError = GetLastError();

		if ( dwError == ERROR_INSUFFICIENT_BUFFER )
		{
			BYTE *pPrinterInfo = new BYTE [ dwNeeded ];

			if ( pPrinterInfo != NULL )
			{
				// Use of delay loaded functions requires exception handler.
                SetStructuredExceptionHandler seh;
                try
				{
					DWORD dwReturnedDrivers = 0;

					bSuccess = ::EnumPrinters(
									PrinterFlags,
									NULL,
									4,
									( LPBYTE) pPrinterInfo,  
									(DWORD ) dwNeeded,
									&dwNeeded,
									&dwReturnedPrinters
								);

					if ( bSuccess )
					{
						pPrinterBuff = ( PRINTER_INFO_4 *) pPrinterInfo;

						for ( DWORD dwPrinters = 0; dwPrinters < dwReturnedPrinters; dwPrinters++, pPrinterBuff++ )
						{
							HRESULT hr = AssociateDriverToDevice (CHString(pPrinterBuff->pPrinterName), pMethodContext);

							if (FAILED(hr) && SUCCEEDED(hRes))
							{
								hRes = hr;
							}
						}
					}
				}
                catch(Structured_Exception se)
                {
                    DelayLoadDllExceptionFilter(se.GetExtendedInfo());
                    delete [] pPrinterInfo;
                    pPrinterInfo = NULL;
                    hRes = WBEM_E_FAILED;
                }
				catch ( ... )
				{
					delete [] pPrinterInfo;
                    pPrinterInfo = NULL;
					throw;
				}
				delete [] pPrinterInfo;
			}
			else
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
	}
	else
	{
		hRes = SetError();
	}

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::SetError
*
*  DESCRIPTION :    Sets and logs the appropriate error. Logs only if logging 
*					is enabled
*
*****************************************************************************/

HRESULT CDriverForDevice::SetError ()
{
	HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
	DWORD dwError = GetLastError();
	if (dwError == ERROR_ACCESS_DENIED)
	{
		hRes = WBEM_E_ACCESS_DENIED;
	}
	else
	if ( ( dwError == ERROR_INVALID_PRINTER_NAME ) || (  dwError = ERROR_INVALID_ENVIRONMENT ) )
	{
		hRes = WBEM_E_NOT_FOUND;
	}
	else
	{
		hRes = WBEM_E_FAILED;

		if (IsErrorLoggingEnabled())
		{
			LogErrorMessage4(L"%s:Error %lxH (%ld)\n",PROVIDER_NAME_DRIVERFORDEVICE, dwError, dwError);
		}       
	}


	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}


/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::ConvertDriverKeyToValues
*
*  DESCRIPTION :    Converting composite driver keys into a individual values
*
*****************************************************************************/
HRESULT CDriverForDevice::
ConvertDriverKeyToValues(
    IN     CHString  Key,
    IN OUT CHString &DriverName,
    IN OUT DWORD    &dwVersion,
    IN OUT CHString &Environment,
    IN     WCHAR     cDelimiter
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;
#if NTONLY >= 5
    if (!Key.IsEmpty()) 
    {
        CHString t_Middle;

        int iFirst = Key.Find(cDelimiter);
        int iLast  = Key.ReverseFind(cDelimiter);
    
        if (iFirst>=1 && iLast>=1 && iLast!=iFirst) 
        {
            int iLength = Key.GetLength();

            DriverName  = Key.Left(iFirst);
            Environment = Key.Right(iLength - iLast - 1);
            t_Middle    = Key.Mid(iFirst + 1, iLast - iFirst - 1);

            if (1==swscanf(t_Middle, L"%u", &dwVersion)) 
            {
                hRes = WBEM_S_NO_ERROR;
            }            
        }
    }

    return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::GetDriversFromQuery
*
*  DESCRIPTION :    Gets all the Drivers from the array ObjectPath Array of Drivers
*
*****************************************************************************/
HRESULT CDriverForDevice::GetDriversFromQuery ( 
												  
	CHStringArray &t_DriverObjPath, 
	CHStringArray &t_DriverNameArray, 
	CHStringArray &t_EnvironmentArray, 
	DWORD **pdwVersion )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
	CObjectPathParser t_PathParser;
	ParsedObjectPath *t_ObjPath;

	*pdwVersion =  new DWORD [ t_DriverObjPath.GetSize() ];

	if ( *pdwVersion != NULL )
	{
		try
		{
			int iTotDrivers = 0;
			for ( int i = 0; i < t_DriverObjPath.GetSize(); i++ )
			{
			// Parse the DriverObject path
				CHString t_Driver = t_DriverObjPath.GetAt ( i );

				if ( ( t_PathParser.Parse( t_Driver, &t_ObjPath ) ==  t_PathParser.NoError ) &&
                    ( V_VT(&t_ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR ) )
				{
					if ( t_ObjPath != NULL )
					{
						try
						{
							if ( TRUE /* if DriverClass and if Key name is DRIVERNAME */)
							{
								CHString t_Environment;
								CHString t_DriverName; 
								DWORD dwVersion;
								// check for the key name 
								hRes = ConvertDriverKeyToValues( t_ObjPath->m_paKeys[0]->m_vValue.bstrVal, t_DriverName, dwVersion, t_Environment );
								if ( SUCCEEDED ( hRes ) )
								{
									t_EnvironmentArray.Add ( t_Environment.GetBuffer ( 0 ) );
									t_DriverNameArray.Add ( t_DriverName.GetBuffer ( 0 ) );
									*pdwVersion [ iTotDrivers ] = dwVersion;
									iTotDrivers++;
								}
							}
						}
						catch ( ... )
						{
							t_PathParser.Free (t_ObjPath);
							t_ObjPath = NULL;
							throw;
						}
						t_PathParser.Free (t_ObjPath);
						t_ObjPath = NULL;
					}
				}			
			}
		}
		catch ( ... )
		{
			delete [] *pdwVersion;
			*pdwVersion = NULL;
			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::GetPrintersFromQuery
*
*  DESCRIPTION :    Gets all the Printers from the array ObjectPath Array of Printers
*
*****************************************************************************/
HRESULT CDriverForDevice::GetPrintersFromQuery ( 
												  
	CHStringArray &t_PrinterObjPath, 
	CHStringArray &t_Printers
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >=5 
	CObjectPathParser t_PathParser;
	ParsedObjectPath *t_ObjPath;

	int iTotPrinters = 0;

	for ( int i = 0; i < t_PrinterObjPath.GetSize(); i++ )
	{
		// Parse the DriverObject path
		CHString t_Printer = t_PrinterObjPath.GetAt ( i );

		if ( ( t_PathParser.Parse( t_Printer, &t_ObjPath ) ==  t_PathParser.NoError ) &&
            ( V_VT(&t_ObjPath->m_paKeys[0]->m_vValue) == VT_BSTR ) )
		{
			if ( t_ObjPath != NULL )
			{
				try
				{
					if ( TRUE // First Verify that the class is Printer Class and the Key Value is DeviceId
					/*only then  add the values*/ )
					{
						t_Printers.Add (  t_ObjPath->m_paKeys[0]->m_vValue.bstrVal );
					}
				}
				catch ( ... )
				{
					t_PathParser.Free (t_ObjPath);
					throw;
				}
				t_PathParser.Free (t_ObjPath);
				t_ObjPath = NULL;
			}
		}
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CDriverForDevice::CommitInstance
*
*  DESCRIPTION :    Forming an Object Path and then Creating and Commiting an instance
*
*****************************************************************************/
HRESULT CDriverForDevice::CommitInstance ( 
										  
	CHString &a_Driver, 
	CHString &a_Printer, 
	MethodContext *pMethodContext 
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
#if NTONLY >= 5
	ParsedObjectPath t_PrinterObjPath;
	LPWSTR lpPrinterPath = NULL;
	variant_t t_PathPrinter = a_Printer.GetBuffer ( 0 );

	t_PrinterObjPath.SetClassName ( PROVIDER_NAME_PRINTER );
	t_PrinterObjPath.AddKeyRef ( DEVICEID, &t_PathPrinter );

	CObjectPathParser t_PathParser;

	if ( t_PathParser.Unparse( &t_PrinterObjPath, &lpPrinterPath  ) != t_PathParser.NoError )
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	if ( lpPrinterPath != NULL )
	{
		try
		{
			ParsedObjectPath t_DriverObjPath;
			variant_t t_PathDriver = a_Driver.GetBuffer ( 0 );
			LPWSTR lpDriverPath = NULL;

			t_DriverObjPath.SetClassName ( PROVIDER_NAME_PRINTERDRIVER );
			t_DriverObjPath.AddKeyRef ( DRIVERNAME, &t_PathDriver );

			if ( t_PathParser.Unparse( &t_DriverObjPath, &lpDriverPath  ) != t_PathParser.NoError )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			if ( lpDriverPath != NULL )
			{
				try 
				{
					// Now Create Instance and commit;
					CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ) , false ) ;
					pInstance->SetCHString ( ANTECEDENT, lpPrinterPath );
					pInstance->SetCHString ( DEPENDENT, lpDriverPath );
					hRes = pInstance->Commit();
				}
				catch ( ... )
				{
					delete [] lpDriverPath;
					lpDriverPath = NULL;
					throw;
				}
				delete [] lpDriverPath;
				lpDriverPath = NULL;
			}
		}
		catch ( ... )
		{
			delete [] lpPrinterPath;
			lpPrinterPath = NULL;
			throw;
		}
		delete [] lpPrinterPath;
		lpPrinterPath = NULL;
	}

	return hRes;
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\elementsetting.h ===
//=================================================================

//

// ElementSetting.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __ASSOC_ELEMENTSETTING__
#define __ASSOC_ELEMENTSETTING__

class CWin32AssocElementToSettings : protected Provider
{
    public:

        CWin32AssocElementToSettings(	const CHString&	strName,
										const CHString& strElementClassName,
										const CHString&	strElementBindingPropertyName,
										const CHString& strSettingClassName,
										const CHString& strSettingBindingPropertyName,
										LPCWSTR			pszNamespace = NULL );

       ~CWin32AssocElementToSettings() ;

		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
	   
	protected:

		CHString	m_strElementClassName;
		CHString	m_strElementBindingPropertyName;
        CHString	m_strSettingClassName;
		CHString	m_strSettingBindingPropertyName;

		virtual HRESULT EnumSettingsForElement( CInstance* pElement, TRefPointerCollection<CInstance>& settingsList, MethodContext* pMethodContext );
		virtual BOOL AreAssociated( CInstance* pElement, CInstance* pSetting );

} ;

class CWin32AssocSystemToSettings : public CWin32AssocElementToSettings
{
    public:

        CWin32AssocSystemToSettings(	const CHString&	strName,
										const CHString&	strSettingClassName,
										LPCWSTR			pszNamespace = NULL );

       ~CWin32AssocSystemToSettings() ;
    
} ;

class CWin32AssocDeviceToSettings : public CWin32AssocElementToSettings
{
    public:

        CWin32AssocDeviceToSettings(	const CHString&	strName,
										const CHString& strDeviceClassName,
										const CHString&	strDeviceBindingPropertyName,
										const CHString& strSettingClassName,
										const CHString& strSettingBindingPropertyName,
										LPCWSTR		pszNamespace = NULL );

       ~CWin32AssocDeviceToSettings() ;

};

class CWin32AssocUserToDesktop : public CWin32AssocElementToSettings
{
	public:	
		CWin32AssocUserToDesktop(void);

	protected:
		virtual HRESULT EnumSettingsForElement(CInstance* pElement,
												TRefPointerCollection<CInstance>&	settingsList,
												MethodContext*	pMethodContext );


		virtual BOOL	AreAssociated( CInstance* pElement, CInstance* pSetting );
		virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\environment.h ===
//=================================================================

//

// Environment.h -- Environment property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/24/97    a-hhance       ported to new paradigm
//				  1/11/98    a-hhance       ported to V2
//				  1/20/98	 a-brads        Added DeleteInstance
//											Added PutInstance
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_ENVIRONMENT L"Win32_Environment" 
//#define  PROPSET_UUID_ENVIRONMENT "{7D0E0480-FEEE-11d0-9E3B-0000E80D7352}"

class Environment : public Provider 
{
	public: 

        // Constructor/destructor
        //=======================
        Environment(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Environment() ;

        // Functions provide properties with current values
        //=================================================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT PutInstance(const CInstance& pInstance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& pInstance, long lFlags = 0L);

	protected:
        // Utility function(s)
        //====================
        HRESULT CreateEnvInstances(MethodContext*  pMethodContext,
								 LPCWSTR pszUserName, 
                                 HKEY hRootKey, 
                                 LPCWSTR pszEnvKeyName,
								 bool bItSystemVar) ;

#ifdef NTONLY
        HRESULT RefreshInstanceNT(CInstance* pInstance) ;
        HRESULT AddDynamicInstancesNT(MethodContext*  pMethodContext) ;
#endif
#ifdef WIN9XONLY
        HRESULT RefreshInstanceWin95(CInstance* pInstance) ; 
        HRESULT AddDynamicInstancesWin95(MethodContext*  pMethodContext) ;
#endif

		void GenerateCaption(LPCWSTR pUserName, LPCWSTR pVariableName, CHString& caption);
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\environment.cpp ===
//=================================================================

//

// Environment.CPP --Environment property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/24/97    a-hhance       ported to new paradigm
//				  1/11/98    a-hhance       ported to V2
//				1/20/98		a-brads			worked on GetObject
//
//=================================================================

#include "precomp.h"
#include "UserHive.h"

#include "Environment.h"
#include "desktop.h"
#include "sid.h"
#include "implogonuser.h"
#include <tchar.h>

#include "CreateMutexAsProcess.h"

// Property set declaration
//=========================

Environment MyEnvironmentSet(PROPSET_NAME_ENVIRONMENT, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : Environment::Environment
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Environment::Environment(LPCWSTR name, LPCWSTR pszNamespace)
: Provider(name, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Environment::~Environment
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

Environment::~Environment()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Environment::GetObject(CInstance* pInstance)
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : TRUE if success, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Environment::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
	HRESULT	hr;

#ifdef NTONLY
						hr = RefreshInstanceNT(pInstance);
#endif
#ifdef WIN9XONLY
						hr = RefreshInstanceWin95(pInstance);
#endif

	return hr;
}

#ifdef NTONLY
HRESULT Environment::RefreshInstanceNT(CInstance* pInstance)
{
	BOOL			bRetCode = FALSE;
	DWORD			dwRet;
	HRESULT		hRetCode;
	CRegistry	RegInfo;
	CUserHive	UserHive;
	TCHAR			szKeyName[_MAX_PATH];
	BOOL			bHiveLoaded = FALSE;
	CHString		sTemp;
	CHString		userName;

	pInstance->GetCHString(IDS_UserName, userName);
	try
	{
		// Load the user hive & retrieve the value
		if(!_tcsicmp(userName.GetBuffer(0), IDS_SystemUser))
		{
			dwRet = RegInfo.Open(HKEY_LOCAL_MACHINE,
						IDS_RegEnvironmentNT,
						KEY_READ) ;

			pInstance->Setbool(IDS_SystemVariable, true);
		}
		else
		{
			dwRet = UserHive.Load(userName.GetBuffer(0),
						szKeyName) ;

			if (dwRet == ERROR_SUCCESS)
			{
        		bHiveLoaded = TRUE ;
				TCHAR			szKeyName2[_MAX_PATH];
				_tcscpy(szKeyName2, szKeyName);

				_tcscat(szKeyName2, IDS_RegEnvironmentKey) ;
				hRetCode = RegInfo.Open(HKEY_USERS, szKeyName2, KEY_READ) ;
				pInstance->Setbool(IDS_SystemVariable, false);
			}
		}

		// looks healthy to me...
		pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

		if (dwRet == ERROR_SUCCESS)
		{

			CHString name;
			pInstance->GetCHString(IDS_Name, name);
			dwRet = RegInfo.GetCurrentKeyValue(name.GetBuffer(0), sTemp) ;
			pInstance->SetCHString(IDS_VariableValue, sTemp);

			CHString foo;
			GenerateCaption(userName, name, foo);
			pInstance->SetCHString(IDS_Description, foo);
			pInstance->SetCHString(IDS_Caption, foo);

			RegInfo.Close() ;
		}

	}
	catch ( ... )
	{
		if ( bHiveLoaded )
		{
			bHiveLoaded = false ;
			UserHive.Unload(szKeyName);
		}

		throw ;
	}

	if (bHiveLoaded)
	{
		bHiveLoaded = false ;
		UserHive.Unload(szKeyName);
	}
	return WinErrorToWBEMhResult(dwRet);
}
#endif

#ifdef WIN9XONLY
HRESULT Environment::RefreshInstanceWin95(CInstance* pInstance)
{
    HRESULT hRetCode = WBEM_E_NOT_FOUND ;
    TCHAR szTemp[_MAX_PATH] ;
	CHString variableName, userName;
	pInstance->GetCHString(IDS_Name, variableName);
    pInstance->GetCHString(IDS_UserName, userName);

	if(GetEnvironmentVariable(TOBSTRT(variableName),
                              szTemp, sizeof(szTemp) / sizeof(TCHAR))) {

        // Make sure the username is <DEFAULT>...
        if(userName.CompareNoCase(IDS_DefaultUser) == 0)
        {
            pInstance->SetCharSplat(IDS_VariableValue, szTemp);
		    pInstance->Setbool(IDS_SystemVariable, true);

		    // looks healthy to me...
		    pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

		    CHString foo;
		    GenerateCaption(userName, variableName, foo);
		    pInstance->SetCHString(IDS_Description, foo);
            pInstance->SetCHString(IDS_Caption,	    foo);

            hRetCode = WBEM_S_NO_ERROR;
        }
    }

    return hRetCode ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Environment::EnumerateInstances
 *
 *  DESCRIPTION : Creates property set instances
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT Environment::EnumerateInstances(MethodContext*  pMethodContext, long lFlags /*= 0L*/)
{
#ifdef NTONLY
		return AddDynamicInstancesNT(pMethodContext);
#endif
#ifdef WIN9XONLY
		return AddDynamicInstancesWin95(pMethodContext) ;
#endif
}

/*
 ** Environment::AddDynamicInstancesWin95
 *
 *  FILENAME: D:\PandoraNG\Win32Provider\providers\Environment\environment.cpp
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#ifdef WIN9XONLY
HRESULT Environment::AddDynamicInstancesWin95(MethodContext*  pMethodContext)
{
    TCHAR *pszEnvBlock, *pszEnvVar, *c ;
    TCHAR szTemp[_MAX_PATH * 4] ;
	HRESULT hr = WBEM_E_FAILED;
	CInstancePtr pInstance;

    pszEnvBlock = (TCHAR *) GetEnvironmentStrings() ;
	try
	{
		if(pszEnvBlock != NULL) {

		   hr = WBEM_S_NO_ERROR;

			for(pszEnvVar = pszEnvBlock ; ((*pszEnvVar) && (SUCCEEDED(hr))) ; pszEnvVar += (_tcslen(pszEnvVar)+1)) {

				_tcscpy(szTemp, pszEnvVar) ;
				pInstance.Attach(CreateNewInstance(pMethodContext));
				if (pInstance != NULL)
				{
		//            pInstance->SetCharSplat(IDS_UserName, "<DEFAULT>");
					pInstance->SetCharSplat(IDS_UserName, IDS_DefaultUser);

					c = _tcstok(szTemp, _T("=")) ;
					pInstance->SetCharSplat(IDS_Name, c);

					// Environment block can contain some strange stuff --
					// use RefreshInstance() to validate the variable
					//====================================================

					if(SUCCEEDED(RefreshInstanceWin95(pInstance)))
					{
						hr = pInstance->Commit();
					}
					else
					{
						hr = WBEM_S_NO_ERROR;
					}
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}		
	}
	catch ( ... )
	{
		if ( pszEnvBlock )
		{
			FreeEnvironmentStrings(pszEnvBlock) ;
			pszEnvBlock = NULL ;
		}

		throw ;
	}

	if ( pszEnvBlock )
	{
		FreeEnvironmentStrings(pszEnvBlock) ;
		pszEnvBlock = NULL ;
	}

	return hr;

}
#endif

/*
 ** Environment::AddDynamicInstancesNT
 *
 *  FILENAME: D:\PandoraNG\Win32Provider\providers\Environment\environment.cpp
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#ifdef NTONLY
HRESULT Environment::AddDynamicInstancesNT(MethodContext*  pMethodContext)
{
	HRESULT	hResult = WBEM_S_NO_ERROR;
    CUserHive UserHive ;
    TCHAR szUserName[_MAX_PATH], szKeyName[_MAX_PATH] , szKeyName2[_MAX_PATH] ;
    CHString userName;

    // Instance system environment vars first
    //=======================================

//    hr = CreateEnvInstances(pMethodContext, "<SYSTEM>", HKEY_LOCAL_MACHINE,
//                                          "System\\CurrentControlSet\\Control\\Session Manager\\Environment", true) ;

    hResult = CreateEnvInstances(pMethodContext, IDS_SystemUser, HKEY_LOCAL_MACHINE,
                                          IDS_RegEnvironmentNT, true) ;

    // Create instances for each user
    //===============================

    // logic: if they don't have a desktop, they're not likely to have any environment vars . . .
	// find Win32_Desktops...
	TRefPointerCollection<CInstance> users;

	if ((SUCCEEDED(hResult)) &&
//		(SUCCEEDED(hResult = CWbemProviderGlue::GetAllInstances(
//			PROPSET_NAME_DESKTOP, &users, IDS_CimWin32Namespace,
//			pMethodContext))))
		(SUCCEEDED(hResult = CWbemProviderGlue::GetInstancesByQuery(L"SELECT Name FROM Win32_Desktop",
                                                                    &users, pMethodContext, GetNamespace()))))
	{

		REFPTRCOLLECTION_POSITION pos;
		CInstancePtr pUser;

		if (users.BeginEnum(pos))
		{
			// GetNext() will AddRef() the pointer, so make sure we Release()
			// it when we are done with it.

			for (	pUser.Attach ( users.GetNext( pos ) ) ;
					(SUCCEEDED(hResult)) && (pUser != NULL) ;
					pUser.Attach ( users.GetNext( pos ) )
                )
			{
				// Look up the user's account info
				//================================

				pUser->GetCHString(IDS_Name, userName) ;

				_tcscpy(szUserName, userName) ;

                // Most names are of the form domain\user.  However, there are also two entries for 'default' and 'all users'.
                // This code will skip those users.
				if (_tcschr(szUserName, _T('\\')) != NULL)
                {
                    if (UserHive.Load(szUserName, szKeyName) == ERROR_SUCCESS)
                    {
						bool bHiveLoaded = true ;
						try
						{
							// Instance user's variables
							//==========================

			//				strcat(szKeyName, "\\Environment") ;
							_tcscpy(szKeyName2, szKeyName);
							_tcscat(szKeyName, IDS_RegEnvironmentKey) ;
							hResult = CreateEnvInstances(pMethodContext, szUserName, HKEY_USERS, szKeyName, false) ;

						}
						catch ( ... )
						{
							if ( bHiveLoaded )
							{
								bHiveLoaded = false ;
								UserHive.Unload(szKeyName2) ;
							}

							throw ;
						}

						if ( bHiveLoaded )
						{
							bHiveLoaded = false ;
							UserHive.Unload(szKeyName2) ;
						}
                    }

				}

                // While this seems like a good idea, it doesn't appear that the os really USES this key.  I tried adding
                // variables and changing variables, then created a new user and logged in.  I didn't get the new or changed vars.
//                else
//                {
//                    if (_tcsicmp(szUserName, _T(".Default")) == 0)
//                    {
//				        hResult = CreateEnvInstances(pMethodContext, szUserName, HKEY_USERS, _T(".DEFAULT\\Environment"), false) ;
//                    }
//                }

			}

			users.EndEnum();
		}
	}

    return hResult;
}
#endif

/*
 ** Environment::CreateEnvInstances
 *
 *  FILENAME: D:\PandoraNG\Win32Provider\providers\Environment\environment.cpp
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT Environment::CreateEnvInstances(MethodContext*  pMethodContext,
										LPCWSTR pszUserName,
                                        HKEY hRootKey,
                                        LPCWSTR pszEnvKeyName,
										bool bItSystemVar)
{
	HKEY	hKey;
	LONG	lRetCode;
	DWORD dwValueIndex,
			dwEnvVarNameSize,
			dwEnvVarValueSize,
			dwType;
	TCHAR	szEnvVarName[1024],
			szEnvVarValue[1024];
	CInstancePtr pInstance;

    HRESULT hr = WBEM_S_NO_ERROR;

	if ((lRetCode = RegOpenKeyEx(hRootKey, TOBSTRT(pszEnvKeyName), 0, KEY_READ, &hKey)) !=
		ERROR_SUCCESS)
		return WinErrorToWBEMhResult(lRetCode);

	for (dwValueIndex = 0; (lRetCode == ERROR_SUCCESS) && (SUCCEEDED(hr)); dwValueIndex++)
	{
		dwEnvVarNameSize  = sizeof(szEnvVarName) / sizeof (TCHAR);
		dwEnvVarValueSize = sizeof(szEnvVarValue) ;
		lRetCode = RegEnumValue(hKey, dwValueIndex, szEnvVarName,
						&dwEnvVarNameSize, NULL, &dwType,
						(BYTE *) szEnvVarValue, &dwEnvVarValueSize);

		if (lRetCode == ERROR_SUCCESS)
        {
		    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ)
		    {
			    pInstance.Attach(CreateNewInstance(pMethodContext));
                if (pInstance != NULL)
                {
			        pInstance->SetCharSplat(IDS_UserName, pszUserName);
			        pInstance->SetCharSplat(IDS_Name, szEnvVarName);
			        pInstance->SetCharSplat(IDS_VariableValue, szEnvVarValue);

			        CHString foo;
			        GenerateCaption(TOBSTRT(pszUserName), TOBSTRT(szEnvVarName), foo);
			        pInstance->SetCHString(IDS_Description, foo);
			        pInstance->SetCHString(IDS_Caption, foo);

			        pInstance->Setbool(IDS_SystemVariable, bItSystemVar);

			        // looks healthy to me...
			        pInstance->SetCharSplat(IDS_Status, IDS_CfgMgrDeviceStatus_OK);

			        hr = pInstance->Commit() ;
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
		    }
        }
	}

	RegCloseKey(hKey);

	return hr;
}

// takes in joeuser and envvar, returns joeuser\envar
void Environment::GenerateCaption(LPCWSTR pUserName, LPCWSTR pVariableName, CHString& caption)
{
	caption = CHString(pUserName) + "\\" +  CHString(pVariableName);
}


/*****************************************************************************
 *
 *  FUNCTION    : Environment::PutInstance
 *
 *  DESCRIPTION : Creates an environment variable on the system
 *
 *  INPUTS      : The instance to put
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : an HRESULT --
 *					WBEM_E_INVALID_PARAMETER - if one of the parameters is wrong or NULL
 *					WBEM_E_FAILED -- if the system wouldn't accept the put
 *					WBEM_E_PROVIDER_NOT_CAPABLE -- if in Win '95
 *					WBEM_S_NO_ERROR - if successful
 *
 *  COMMENTS    : Logic here is way too deep & convoluted TODO! fix.
 *
 *****************************************************************************/
HRESULT Environment::PutInstance(const CInstance &pInstance, long lFlags /*= 0L*/)
{
#ifdef NTONLY
    HRESULT hr = WBEM_E_FAILED;
    CHString EnvironmentVariable;
    CHString VariableValue;
    CHString UserName, sTmpUser;
    TCHAR szCurrentUserName[_MAX_PATH];

    HRESULT hRetCode ;
    CRegistry RegInfo ;
    CUserHive UserHive ;
    TCHAR szKeyName[_MAX_PATH] ;
    BOOL bHiveLoaded = FALSE ;
    int iFind;

    pInstance.GetCHString(IDS_Name, EnvironmentVariable);
    pInstance.GetCHString(IDS_VariableValue, VariableValue);
    pInstance.GetCHString(IDS_UserName, UserName);

    // the Username exists on this machine.  We can put the instance variables
    // Load the user hive & retrieve the value
    //========================================
    {
        // we need all the keys
        // but only need a value for CreateOnly
        // jumping out in the middle, since there's too much of a rewrite elsewise...
        if ((EnvironmentVariable.GetLength() == 0) ||
            (UserName.GetLength() == 0)             ||
            ((VariableValue.GetLength() == 0) && (lFlags & WBEM_FLAG_CREATE_ONLY)))
            return WBEM_E_INVALID_PARAMETER;

        //      if(!_strcmpi(UserName.GetBuffer(0), "<SYSTEM>"))
        if(!_tcsicmp(UserName.GetBuffer(0), IDS_SystemUser))
        {
            //            hRetCode = RegInfo.Open(HKEY_LOCAL_MACHINE,
            //             "System\\CurrentControlSet\\Control\\Session Manager\\Environment",
            //               KEY_ALL_ACCESS) ;

            hRetCode = RegInfo.Open(HKEY_LOCAL_MACHINE,
                IDS_RegEnvironmentNT,
                KEY_ALL_ACCESS) ;

            if (ERROR_SUCCESS == hRetCode)
            {
                // Check the flags.  First do we even care?
                if (lFlags & (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY))
                {
                    // Ok, we care.  Is this var already there?
                    CHString sTemp;
                    hRetCode = RegInfo.GetCurrentKeyValue(EnvironmentVariable, sTemp);

                    // If create only and already there, that's an error, else no error
                    if (lFlags & WBEM_FLAG_CREATE_ONLY)
                    {
                        if (hRetCode == ERROR_SUCCESS)
                        {
                            hr = WBEM_E_ALREADY_EXISTS;
                            hRetCode = ~ERROR_SUCCESS;
                        }
                        else
                        {
                            hRetCode = ERROR_SUCCESS;
                            // If update only (the only other option) and not there, that's an error, else no error
                        }
                    }
                    else if (hRetCode != ERROR_SUCCESS)
                    {
                        hr = WBEM_E_NOT_FOUND;
                        hRetCode = ~ERROR_SUCCESS;
                    }
                    else
                    {
                        hRetCode = ERROR_SUCCESS;
                    }
                }

                // If we're still in business, change the environment variable in the registry
                if (hRetCode == ERROR_SUCCESS) {
                    hRetCode = RegInfo.SetCurrentKeyValue(EnvironmentVariable, VariableValue);

                    if (ERROR_SUCCESS == hRetCode)
                    {
                        // From here, we can say that we've won.
                        hr = WBEM_S_NO_ERROR;
                        if (VariableValue.IsEmpty())
                        {
                            // Remove from registry
                            RegInfo.DeleteCurrentKeyValue(EnvironmentVariable);
                        }

                    }	// end if
                    else
                    {
                        // instance could not be put for some reason
                        hr = WBEM_E_FAILED;
                    }
                }
            }	// end if open registry key
            else if (hRetCode == ERROR_ACCESS_DENIED)
                hr = WBEM_E_ACCESS_DENIED;
            else
            {
                // instance could not be put for some reason....unknown
                hr = WBEM_E_FAILED;
            }	// end else
        }	// end if system variable
        else	// NOT A SYSTEM VARIABLE
        {
            hRetCode = UserHive.Load(UserName.GetBuffer(0),
                szKeyName) ;
            if(hRetCode == ERROR_SUCCESS)
            {
				try
				{
					bHiveLoaded = TRUE ;
					//               strcat(szKeyName, "\\Environment") ;
					_tcscat(szKeyName, IDS_RegEnvironmentKey) ;
					hRetCode = RegInfo.Open(HKEY_USERS, szKeyName, KEY_ALL_ACCESS) ;
					if (ERROR_SUCCESS == hRetCode)
					{
						// Check the flags.  First do we even care?
						if (lFlags & (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY))
						{

							// Ok, we care.  Is this var already there?
							CHString sTemp;
							hRetCode = RegInfo.GetCurrentKeyValue(EnvironmentVariable, sTemp);

							// If create only and already there, that's an error, else no error
							if (lFlags & WBEM_FLAG_CREATE_ONLY)
							{
								if (hRetCode == ERROR_SUCCESS)
								{
									hr = WBEM_E_ALREADY_EXISTS;
									hRetCode = ~ERROR_SUCCESS;
								}
								else
								{
									hRetCode = ERROR_SUCCESS;
									// If update only (the only other option) and not there, that's an error, else no error
								}
							} else if (hRetCode != ERROR_SUCCESS)
							{
								hr = WBEM_E_NOT_FOUND;
								hRetCode = ~ERROR_SUCCESS;
							}
							else
							{
								hRetCode = ERROR_SUCCESS;
							}
						}

						// If we're still in business, change the environment variable in the registry
						if (hRetCode == ERROR_SUCCESS)
						{
							hRetCode = RegInfo.SetCurrentKeyValue(EnvironmentVariable, VariableValue);

							if (ERROR_SUCCESS == hRetCode)
							{
								// From here, we can say that we've won.
								hr = WBEM_S_NO_ERROR;
								if (pInstance.IsNull(IDS_VariableValue) || VariableValue.IsEmpty())
								{
									// Remove from registry
									RegInfo.DeleteCurrentKeyValue(EnvironmentVariable);
								}

								// now check to see if you are the current logged on user
								// if you are, change the variable in memory.
								CImpersonateLoggedOnUser	impersonateLoggedOnUser;

								if ( !impersonateLoggedOnUser.Begin() )
								{
									LogErrorMessage(IDS_LogImpersonationFailed);
								}	// end if logged on successfully
								else
								{
									try
									{
										DWORD dwLength = 255;
										{
											// do actual lookup inside mutex
											CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
											GetUserName(szCurrentUserName, &dwLength);
										}

										iFind = UserName.Find('\\');
										if (iFind > 0) {
											sTmpUser = UserName.Mid(iFind + _tclen(_T("\\")) );
										} else {
											sTmpUser = UserName;
										}
										if (sTmpUser.CompareNoCase(szCurrentUserName) == 0)
										{
											if (!SetEnvironmentVariable(EnvironmentVariable, VariableValue))
											{
												hr = WBEM_E_FAILED;
											}	// end else
										}	// end if
									}
									catch ( ... )
									{
										if ( !impersonateLoggedOnUser.End() )
										{
											LogErrorMessage(IDS_LogImpersonationRevertFailed) ;
										}

										throw ;
									}
								}

								if ( !impersonateLoggedOnUser.End() )
								{
									LogErrorMessage(IDS_LogImpersonationRevertFailed) ;
								}	// end if
							}
							else if (hRetCode == ERROR_ACCESS_DENIED)
								hr = WBEM_E_ACCESS_DENIED;
							else
								// instance could not be put
								hr = WBEM_E_FAILED;
						}
					}	// end if
					else if (hRetCode == ERROR_ACCESS_DENIED)
					{
						hr = WBEM_E_ACCESS_DENIED;
					}
					else
					{
						// instance could not be put because the key could not be opened
						hr = WBEM_E_FAILED;
					}
				}

				catch ( ... )
				{
					if (bHiveLoaded)
					{
						bHiveLoaded = false ;
						UserHive.Unload(szKeyName) ;
					}

					throw ;
				}

				if (bHiveLoaded)
				{
					bHiveLoaded = false ;
					UserHive.Unload(szKeyName) ;
				}

         }	// end if loaded hive
      }	// end else system variable

      //Send public message announcing change to Environment
      //Time out value of 1000 ms taken from the Environment Variables dialog of the System Control Panel Applet
      if ( SUCCEEDED ( hr ) )
      {
          DWORD_PTR dwResult ;
          ::SendMessageTimeout(	HWND_BROADCAST,
              WM_SETTINGCHANGE,
              0,
              (LPARAM) TEXT("Environment"),
              SMTO_NORMAL | SMTO_ABORTIFHUNG,
              1000,
              &dwResult );
      }
   }	// end if NT

   return(hr);
#endif

#ifdef WIN9XONLY
   {
       return WBEM_E_PROVIDER_NOT_CAPABLE;
   }	// end else
#endif

}	// end Environment::PutInstance(const CInstance &pInstance)

////////////////////////////////////////////////////////////////////////
//
//	Function:	DeleteInstance
//
//	CIMOM wants us to delete this instance.
//
//	Inputs:
//
//	Outputs:
//
//	Return:
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////
HRESULT Environment::DeleteInstance(const CInstance& pInstance, long lFlags /*= 0L*/)
{
	HRESULT		hr = WBEM_E_NOT_FOUND;

#ifdef NTONLY
	// since the variable value is NULL, the value will be removed.
	hr = PutInstance(pInstance, WBEM_FLAG_UPDATE_ONLY);
#endif
#ifdef WIN9XONLY
	hr = WBEM_E_PROVIDER_NOT_CAPABLE;
#endif

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\filefile.cpp ===
//=================================================================

//

// FileFile.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/26/98    a-kevhu         Created
//
// Comment: Parent class for disk/dir, dir/dir, and dir/file association classes.
//
//=================================================================

#include "precomp.h"

#include "FileFile.h"


/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::CFileFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CFileFile::CFileFile(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::~CFileFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CFileFile::~CFileFile()
{
}


/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::QueryForSubItemsAndCommit
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Runs a query to obtain a list of dependent items, creates
 *                the associations with the antecedent, and commits the
 *                association instances.
 *
 *****************************************************************************/

HRESULT CFileFile::QueryForSubItemsAndCommit(CHString& chstrGroupComponentPATH,
                                                 CHString& chstrQuery,
                                                 MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> LList;
    if(SUCCEEDED(CWbemProviderGlue::GetInstancesByQuery(chstrQuery,
                                                        &LList,
                                                        pMethodContext,
                                                        IDS_CimWin32Namespace)))
    {
        REFPTRCOLLECTION_POSITION pos;
        CInstancePtr pinstListElement;
        if(LList.BeginEnum(pos))
        {
            CHString chstrPartComponentPATH;
            for (pinstListElement.Attach(LList.GetNext(pos)) ;
                (SUCCEEDED(hr)) && (pinstListElement != NULL) ;
                pinstListElement.Attach(LList.GetNext(pos)) )
            {
                if(pinstListElement != NULL)
                {
                    CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                    if(pInstance != NULL)
                    {
                        pinstListElement->GetCHString(IDS___Path, chstrPartComponentPATH); // goes back as 'Dependent'
                        pInstance->SetCHString(IDS_PartComponent, chstrPartComponentPATH);
                        pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
                        hr = pInstance->Commit();
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                } // if pinstListElement not NULL
            } // while list elements to enumerate
            LList.EndEnum();
        } // beginenum of list worked
    } // the query
    return(hr);
}

/*****************************************************************************
 *
 *  FUNCTION    : CFileFile::GetSingleSubItemAndCommit
 *
 *  DESCRIPTION :
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Obtains the dependent item, creates
 *                the association with the antecedent, and commits the
 *                association instance.
 *
 *****************************************************************************/
HRESULT CFileFile::GetSingleSubItemAndCommit(CHString& chstrGroupComponentPATH,
                                          CHString& chstrSubItemPATH,
                                          MethodContext* pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CInstancePtr pinstRootDir;
    if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath(chstrSubItemPATH, &pinstRootDir, pMethodContext)))
    {
        CHString chstrPartComponentPATH;
        CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
        if(pInstance != NULL)
        {
            pInstance->SetCHString(IDS_PartComponent, chstrSubItemPATH);
            pInstance->SetCHString(IDS_GroupComponent, chstrGroupComponentPATH);
            hr = pInstance->Commit();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\filefile.h ===
//=================================================================

//

// FileFile.h

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    11/09/98    a-kevhu         Created
//
// Comment: Parent class for disk/dir, dir/dir, and dir/file association classes.
//
//=================================================================

// Property set identification
//============================

#ifndef _FILEFILE_H_
#define _FILEFILE_H_

class CFileFile;

class CFileFile : public Provider 
{
    public:
        // Constructor/destructor
        //=======================
        CFileFile(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~CFileFile() ;

    protected:
        HRESULT QueryForSubItemsAndCommit(CHString& chstrGroupComponentPATH,
                                          CHString& chstrQuery,
                                          MethodContext* pMethodContext);

        HRESULT GetSingleSubItemAndCommit(CHString& chstrGroupComponentPATH,
                                          CHString& chstrSubItemPATH,
                                          MethodContext* pMethodContext);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\file.cpp ===
//=================================================================

//

// File.CPP -- File property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//=================================================================

//NOTE: The implementations of EnumerateInstances, GetObject & the pure virtual declaration of IsOneOfMe  method
//		is now present in the derived CImplement_LogicalFile class. Cim_LogicalFile is now instantiable & has only
//		generic method implementations.


//ADDITION ST
// Now in fwcommon.h
//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400 //will this affect something else....to be checked out
//#endif
//ADDITION END

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <comdef.h>
#include "tokenprivilege.h"
#include <winioctl.h>
#include "file.h"
#include "accessentrylist.h"
#include "dacl.h"
#include "sacl.h"
#include "Win32Securitydescriptor.h"
#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "tokenprivilege.h"


#include "NtDllApi.h"


#define PROPSET_NAME_WIN32_SECURITY				_T("Win32_SecurityDescriptor")


#define METHOD_NAME_COPYFILE						L"Copy"
#define METHOD_NAME_COPYFILE_EX						L"CopyEx"
#define METHOD_NAME_DELETEFILE						L"Delete"
#define METHOD_NAME_DELETEFILE_EX					L"DeleteEx"
#define METHOD_NAME_COMPRESS						L"Compress"
#define METHOD_NAME_COMPRESS_EX						L"CompressEx"
#define METHOD_NAME_UNCOMPRESS						L"Uncompress"
#define METHOD_NAME_UNCOMPRESS_EX					L"UncompressEx"
#define METHOD_NAME_TAKEOWNERSHIP					L"TakeOwnerShip"
#define METHOD_NAME_TAKEOWNERSHIP_EX				L"TakeOwnerShipEx"
#define METHOD_NAME_CHANGESECURITYPERMISSIONS		L"ChangeSecurityPermissions"
#define METHOD_NAME_CHANGESECURITYPERMISSIONS_EX	L"ChangeSecurityPermissionsEx"
#define METHOD_NAME_RENAMEFILE						L"Rename"
#define METHOD_NAME_EFFECTIVE_PERMISSION            L"GetEffectivePermission"

#define METHOD_ARG_NAME_RETURNVALUE					L"ReturnValue"
#define METHOD_ARG_NAME_NEWFILENAME					L"FileName"
#define METHOD_ARG_NAME_SECURITY_DESC				L"SecurityDescriptor"
#define METHOD_ARG_NAME_OPTION						L"Option"
#define METHOD_ARG_NAME_START_FILENAME				L"StartFileName"
#define METHOD_ARG_NAME_STOP_FILENAME				L"StopFileName"
#define METHOD_ARG_NAME_RECURSIVE					L"Recursive"
#define METHOD_ARG_NAME_PERMISSION                  L"Permissions"

#define OPTION_VALUE_CHANGE_OWNER				(0X00000001L)
#define OPTION_VALUE_CHANGE_GROUP				(0X00000002L)
#define OPTION_VALUE_CHANGE_DACL				(0X00000004L)
#define OPTION_VALUE_CHANGE_SACL				(0X00000008L)


#define File_STATUS_SUCCESS							0


// Control
#define File_STATUS_ACCESS_DENIED					2
#define File_STATUS_UNKNOWN_FAILURE					8

//start
#define File_STATUS_INVALID_NAME					9
#define File_STATUS_ALREADY_EXISTS					10
#define File_STATUS_FILESYSTEM_NOT_NTFS				11
#define File_STATUS_PLATFORM_NOT_WINNT				12
#define File_STATUS_NOT_SAME_DRIVE					13
#define File_STATUS_DIR_NOT_EMPTY					14
#define File_STATUS_SHARE_VIOLATION					15
#define File_STATUS_INVALID_STARTFILE				16
#define File_STATUS_PRIVILEGE_NOT_HELD				17

#define File_STATUS_INVALID_PARAMETER				21




// Property set declaration
//=========================
CCIMLogicalFile MyFileSet(PROPSET_NAME_FILE, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CCIMLogicalFile::CCIMLogicalFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CCIMLogicalFile::CCIMLogicalFile(LPCWSTR setName,
                                 LPCWSTR pszNamespace)
    : Provider(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CCIMLogicalFile::~CCIMLogicalFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CCIMLogicalFile::~CCIMLogicalFile()
{
}


HRESULT CCIMLogicalFile::ExecMethod (

	const CInstance& rInstance,
	const BSTR bstrMethodName ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	long lFlags
)
{
	if(!pOutParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_CHANGESECURITYPERMISSIONS) == 0	)
	{
		return ExecChangePermissions(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_COPYFILE) == 0 )
	{
		return ExecCopy(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_RENAMEFILE) == 0 )
	{
		return ExecRename(rInstance,pInParams,pOutParams, lFlags ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_DELETEFILE) == 0 )
	{
		return ExecDelete(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_COMPRESS) == 0 )
	{
		return ExecCompress(rInstance, pInParams, pOutParams, lFlags, false ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_UNCOMPRESS) == 0 )
	{
		return ExecUncompress(rInstance, pInParams, pOutParams, lFlags, false ) ;
	}
	else if ( _wcsicmp ( bstrMethodName , METHOD_NAME_TAKEOWNERSHIP ) == 0 )
	{
		return ExecTakeOwnership(rInstance,pInParams,pOutParams, lFlags, false ) ;
	}
	if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_CHANGESECURITYPERMISSIONS_EX ) == 0	)
	{
		return ExecChangePermissions(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_COPYFILE_EX ) == 0 )
	{
		return ExecCopy(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
	else if ( _wcsicmp ( bstrMethodName ,METHOD_NAME_DELETEFILE_EX ) == 0 )
	{
		return ExecDelete(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_COMPRESS_EX ) == 0 )
	{
		return ExecCompress(rInstance, pInParams, pOutParams, lFlags, true ) ;
	}
	else if (_wcsicmp ( bstrMethodName ,METHOD_NAME_UNCOMPRESS_EX ) == 0 )
	{
		return ExecUncompress(rInstance, pInParams, pOutParams, lFlags, true ) ;
	}
	else if ( _wcsicmp ( bstrMethodName , METHOD_NAME_TAKEOWNERSHIP_EX ) == 0 )
	{
		return ExecTakeOwnership(rInstance,pInParams,pOutParams, lFlags, true ) ;
	}
    else if(_wcsicmp(bstrMethodName, METHOD_NAME_EFFECTIVE_PERMISSION) == 0)
	{
		return ExecEffectivePerm(rInstance, pInParams, pOutParams, lFlags);
	}

	return WBEM_E_INVALID_METHOD ;
}


HRESULT CCIMLogicalFile::ExecChangePermissions(
	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
	if ( pInParams )
	{
		hr = CheckChangePermissionsOnFileOrDir(
				rInstance,
				pInParams ,
				pOutParams ,
				dwStatus,
				bExtendedMethod,
				InputParams
			) ;

			if ( SUCCEEDED ( hr ) )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
				if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
				{
					pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
				}
				if ( dwStatus == File_STATUS_PRIVILEGE_NOT_HELD )
				{
					hr = WBEM_E_PRIVILEGE_NOT_HELD ;
				}
			}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}


typedef void (*GETDESCRIPTOR)(
	CInstance* pInstance, PSECURITY_DESCRIPTOR *ppDescriptor);


HRESULT CCIMLogicalFile::CheckChangePermissionsOnFileOrDir(
	const CInstance& rInstance ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	DWORD &dwStatus,
	bool bExtendedMethod,
	CInputParams& InputParams

)
{
	HRESULT hr = S_OK ;

#ifdef WIN9XONLY
	{
		dwStatus = File_STATUS_PLATFORM_NOT_WINNT ;
		return hr ;
	}
#endif

#ifdef NTONLY
	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	DWORD dwOption ;

	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCTSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			dwStatus = File_STATUS_INVALID_NAME ;
			return hr ;
		}
	}

	if ( pInParams->GetStatus( METHOD_ARG_NAME_OPTION, bExists , eType ) )
	{
		if ( bExists && ( eType == VT_I4 ) )
		{
			if ( pInParams->GetDWORD( METHOD_ARG_NAME_OPTION, dwOption) )
			{
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

	MethodContext* pMethodContext = pInParams->GetMethodContext();
	CInstancePtr pSecurityDesc ;
	if ( pInParams->GetStatus ( METHOD_ARG_NAME_SECURITY_DESC , bExists , eType ) )
	{
		if ( bExists &&  eType == VT_UNKNOWN )
		{
			if ( pInParams->GetEmbeddedObject(METHOD_ARG_NAME_SECURITY_DESC, &pSecurityDesc, pMethodContext) )
			{
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
			}
		}
		else if(bExists)
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_PROVIDER_FAILURE ;
	}

	if( dwStatus != STATUS_SUCCESS )
	{
		return hr ;
	}


	CHString chsClassProperty ( L"__CLASS" ) ;
	if ( pSecurityDesc->GetStatus ( chsClassProperty, bExists , eType ) )
	{
		if ( bExists && ( eType == VT_BSTR ) )
		{
			CHString chsClass ;
			if ( pSecurityDesc->GetCHString ( chsClassProperty , chsClass ) )
			{
				if ( chsClass.CompareNoCase ( PROPSET_NAME_WIN32_SECURITY ) != 0 )
				{
					dwStatus = File_STATUS_INVALID_PARAMETER ;
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				hr = WBEM_E_PROVIDER_FAILURE ;
			}

		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			hr = WBEM_E_PROVIDER_FAILURE ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		hr = WBEM_E_PROVIDER_FAILURE ;
	}


	if( dwStatus != STATUS_SUCCESS )
	{
		return hr ;
	}


	PSECURITY_DESCRIPTOR pSD = NULL ;
	WCHAR *pwcName = NULL ;

	try
	{
		GetDescriptorFromMySecurityDescriptor(pSecurityDesc, &pSD);

		rInstance.GetWCHAR(IDS_Name,&pwcName) ;
		if(pSD)
		{
			InputParams.SetValues ( pwcName, dwOption, pSD, false, ENUM_METHOD_CHANGE_PERM, rInstance.GetMethodContext()) ;
			dwStatus = DoOperationOnFileOrDir(pwcName, InputParams ) ;
			free( InputParams.pSD );
			pSD = NULL ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
		}
	}
	catch ( ... )
	{
		if ( pSD )
		{
			free( pSD );
			pSD = NULL ;
		}

        free(pwcName);
        pwcName = NULL ;

		throw ;
	}

    if (pwcName)
    {
        free(pwcName);
        pwcName = NULL;
    }

	return hr ;
#endif
}



DWORD CCIMLogicalFile::ChangePermissions(_bstr_t bstrtFileName, DWORD dwOption, PSECURITY_DESCRIPTOR pSD, CInputParams& InputParams )
{
	//If the object's system ACL is being set,
	//the SE_SECURITY_NAME privilege must be enabled for the calling process.
	DWORD dwReturn = ERROR_SUCCESS;
	bool t_bErrorsDueToMissingPrivileges = false ;
#ifdef NTONLY
    // flags to tell us when the client has not enabled the needed flags
    bool noRestorePriv = false;
    bool noSecurityPriv = false;

	{
		// Fill out security information with only the appropriate DACL/SACL values.
		if ( dwOption & OPTION_VALUE_CHANGE_DACL )
		{
			if ( !::SetFileSecurityW( bstrtFileName,
						 DACL_SECURITY_INFORMATION,
						 pSD ) )
			{
				dwReturn = GetLastError() ;
			}

		}

		// If we need to write owner information, try to write just that piece first.  If
		// we fail because of insufficient access and we are setting the DACL, set that
		// then retry the Write_Owner.
		if ( ( dwOption & OPTION_VALUE_CHANGE_OWNER ) && dwReturn == ERROR_SUCCESS )
		{

			if ( !::SetFileSecurityW( bstrtFileName,
									 OWNER_SECURITY_INFORMATION,
									 pSD ) )
			{
				dwReturn = GetLastError() ;
			}

			// If we failed with this error, try adjusting the SE_RESTORE_NAME privilege
			// so it is enabled.  If that succeeds, retry the operation.
			if ( ERROR_INVALID_OWNER == dwReturn )
			{
				// We might need this guy to handle some special access stuff
				CTokenPrivilege	restorePrivilege( SE_RESTORE_NAME );

				// If we enable the privilege, retry setting the owner info
				if ( ERROR_SUCCESS == restorePrivilege.Enable() )
				{
					bool t_bRestore = true ;
					try
					{
						dwReturn = ERROR_SUCCESS ;
						if ( !::SetFileSecurityW( bstrtFileName,
												 OWNER_SECURITY_INFORMATION,
												 pSD ) )
						{
							dwReturn = GetLastError() ;
						}

						// Clear the privilege
						t_bRestore = false ;
					}
					catch ( ... )
					{
						if ( t_bRestore )
						{
							restorePrivilege.Enable( FALSE );
						}
						throw ;
					}
					restorePrivilege.Enable( FALSE );
				}
                else
                    noRestorePriv = true;
			}

			if ( noRestorePriv && dwReturn != ERROR_SUCCESS )
			{
				t_bErrorsDueToMissingPrivileges = true ;
			}
		}

		if ( ( dwOption & OPTION_VALUE_CHANGE_SACL ) && dwReturn == ERROR_SUCCESS )
		{
			CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
			BOOL fDisablePrivilege = FALSE;
			fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
            noSecurityPriv = !fDisablePrivilege;
			try
			{
				if  ( !::SetFileSecurityW( bstrtFileName,
										   SACL_SECURITY_INFORMATION,
										   pSD ) )
				{
					dwReturn = ::GetLastError();
				}
			}
			catch ( ... )
			{
				if ( fDisablePrivilege )
				{
					fDisablePrivilege = false ;
					securityPrivilege.Enable(FALSE);
				}
				throw ;
			}

			// Cleanup the Name Privilege as necessary.
			if ( fDisablePrivilege )
			{
				fDisablePrivilege = false ;
				securityPrivilege.Enable(FALSE);
			}

			if ( noSecurityPriv && dwReturn != ERROR_SUCCESS )
			{
				t_bErrorsDueToMissingPrivileges = true ;
			}
		}

		if ( ( dwOption & OPTION_VALUE_CHANGE_GROUP ) && dwReturn == ERROR_SUCCESS )
		{
			if  ( !::SetFileSecurityW( bstrtFileName,
									   GROUP_SECURITY_INFORMATION,
									   pSD ) )
			{
				dwReturn = ::GetLastError();
			}
		}

		dwReturn = MapWinErrorToStatusCode ( dwReturn ) ;

		if ( t_bErrorsDueToMissingPrivileges )
		{
			dwReturn = File_STATUS_PRIVILEGE_NOT_HELD ;
		}

        // client is missing essential privilege
        // prepare error info...
        if (noSecurityPriv || noRestorePriv)
        {
	        SAFEARRAY *psaPrivilegesReqd = NULL , *psaPrivilegesNotHeld = NULL ;
	        SAFEARRAYBOUND rgsabound[1];
	        rgsabound[0].cElements = 1;
	        rgsabound[0].lLbound = 0;
	        psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
			if ( !psaPrivilegesReqd )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}
			try
			{
				// how many elements? as many as there are true flags!
				rgsabound[0].cElements = noSecurityPriv + noRestorePriv;
				psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);
				if ( !psaPrivilegesNotHeld )
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}

				if (psaPrivilegesReqd && psaPrivilegesNotHeld)
				{
					bstr_t sercurityName(_T("SE_SECURITY_NAME"));
					bstr_t restoreName(_T("SE_RESTORE_NAME"));
					long index = 0;
					// both are REQUIRED
					SafeArrayPutElement(psaPrivilegesReqd, &index, (void *)(BSTR)sercurityName);
					index = 1;
					SafeArrayPutElement(psaPrivilegesReqd, &index, (void *)(BSTR)restoreName);

					// now list those that aren't here
					index = 0;
					if (noSecurityPriv)
					{
						SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void *)(BSTR)sercurityName);
						index++;
					}

					if (noRestorePriv)
						SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void *)(BSTR)restoreName);

					CWbemProviderGlue::SetStatusObject(InputParams.pContext, IDS_CimWin32Namespace,
						_T("Required privilege not enabled"), WBEM_E_FAILED, psaPrivilegesNotHeld,
						psaPrivilegesReqd);
				}
			}
			catch ( ... )
			{
				if (psaPrivilegesNotHeld)
				{
					SafeArrayDestroy(psaPrivilegesNotHeld);
					psaPrivilegesNotHeld = NULL ;
				}
				if (psaPrivilegesReqd)
				{
					SafeArrayDestroy(psaPrivilegesReqd);
					psaPrivilegesReqd = NULL ;
				}
				throw ;
			}

			if (psaPrivilegesNotHeld)
			{
				SafeArrayDestroy(psaPrivilegesNotHeld);
				psaPrivilegesNotHeld = NULL ;
			}
			if (psaPrivilegesReqd)
			{
				SafeArrayDestroy(psaPrivilegesReqd);
				psaPrivilegesReqd = NULL ;
			}
        }
	}
#endif
#ifdef WIN9XONLY
	{
		dwReturn = File_STATUS_PLATFORM_NOT_WINNT ;
	}
#endif

	//set the file-name at which error occured
	if ( dwReturn != STATUS_SUCCESS )
	{
		InputParams.bstrtErrorFileName = bstrtFileName ;
	}

	return dwReturn ;
}


HRESULT CCIMLogicalFile::ExecCopy(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags ,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
	if ( pInParams )
	{
		hr = CheckCopyFileOrDir(
				rInstance,
				pInParams ,
				pOutParams ,
				dwStatus,
				bExtendedMethod,
				InputParams
			) ;
			if ( SUCCEEDED ( hr ) )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
				if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
				{
					pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
				}
			}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}


HRESULT CCIMLogicalFile::ExecRename(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags
)
{

	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;

	if ( pInParams )
	{

		hr = CheckRenameFileOrDir(
				rInstance,
				pInParams ,
				pOutParams ,
				dwStatus
			) ;

			if ( SUCCEEDED ( hr ) )
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
			}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}
	return hr ;
}

HRESULT CCIMLogicalFile::ExecDelete(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{

	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;

	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCWSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME ) ;
			return hr ;
		}
	}


	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
	    InputParams.SetValues ( pszName, 0, NULL, true, ENUM_METHOD_DELETE ) ;
	    dwStatus = DoOperationOnFileOrDir( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free (pszName);
            pszName = NULL;
        }
        throw;
    }

    if (pszName)
    {
        free (pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
}

HRESULT CCIMLogicalFile::ExecCompress (

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
#ifdef WIN9XONLY
	{
		pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_PLATFORM_NOT_WINNT );
		return hr ;
	}
#endif

	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCWSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME );
			return hr ;
		}
	}

	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
	    InputParams.SetValues ( pszName, 0, NULL, false, ENUM_METHOD_COMPRESS ) ;
	    dwStatus = DoOperationOnFileOrDir ( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free(pszName);
            pszName = NULL;
        }
        throw;
    }

    if (pszName)
    {
        free(pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
}

HRESULT CCIMLogicalFile::ExecUncompress (

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;
#ifdef WIN9XONLY
	{
		pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_PLATFORM_NOT_WINNT );
		return hr ;
	}
#endif

#ifdef NTONLY
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;
	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCTSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME );
			return hr ;
		}
	}

	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
        InputParams.SetValues ( pszName, 0, NULL, false, ENUM_METHOD_UNCOMPRESS ) ;
	    dwStatus = DoOperationOnFileOrDir ( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free (pszName);
            pszName = NULL;
        }
        throw;
    }

    if (pszName)
    {
        free (pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
#endif
}

HRESULT CCIMLogicalFile::ExecTakeOwnership(

	const CInstance& rInstance,
	CInstance *pInParams,
	CInstance *pOutParams,
	long lFlags,
	bool bExtendedMethod
)
{
	HRESULT hr = S_OK ;

#ifdef WIN9XONLY
	{
		pOutParams->SetDWORD( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_PLATFORM_NOT_WINNT );
		return hr ;
	}
#endif

#ifdef NTONLY
	DWORD dwStatus = STATUS_SUCCESS ;
	CInputParams InputParams ;

	if ( bExtendedMethod && !pInParams )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	CHString chsStartFile ;
	bool bExists ;
	VARTYPE eType ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
						return hr ;
					}
				}
			}
			else
			{
				pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
				return hr ;
			}
		}
		else
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_PARAMETER );
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCTSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , File_STATUS_INVALID_NAME );
			return hr ;
		}
	}

	WCHAR *pszName = NULL ;
	rInstance.GetWCHAR(IDS_Name,&pszName) ;

    try
    {
	    InputParams.SetValues ( pszName, 0, NULL, false, ENUM_METHOD_TAKEOWNERSHIP ) ;
	    dwStatus = DoOperationOnFileOrDir ( pszName, InputParams ) ;
    }
    catch ( ... )
    {
        if (pszName)
        {
            free (pszName);
            pszName = NULL;
        }
        throw ;
    }

    if (pszName)
    {
        free (pszName);
        pszName = NULL;
    }

	pOutParams->SetDWORD ( METHOD_ARG_NAME_RETURNVALUE , dwStatus ) ;
	if ( bExtendedMethod && dwStatus != STATUS_SUCCESS && !InputParams.bstrtErrorFileName == false )
	{
		pOutParams->SetCHString ( METHOD_ARG_NAME_STOP_FILENAME, (PWCHAR)InputParams.bstrtErrorFileName ) ;
	}
	return hr ;
#endif
}


HRESULT CCIMLogicalFile::ExecEffectivePerm(const CInstance& rInstance,
	                                       CInstance *pInParams,
	                                       CInstance *pOutParams,
	                                       long lFlags)
{
	HRESULT hr = S_OK ;

#ifdef WIN9XONLY
	{
		pOutParams->Setbool(METHOD_ARG_NAME_RETURNVALUE, false);
	}
#endif
#ifdef NTONLY
	bool fHasPerm = false;
	if(pInParams != NULL)
	{
		hr = CheckEffectivePermFileOrDir(rInstance, pInParams, pOutParams, fHasPerm);
		if(SUCCEEDED(hr))
		{
			pOutParams->Setbool(METHOD_ARG_NAME_RETURNVALUE, fHasPerm);
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER;
	}
#endif
	return hr ;
}


DWORD CCIMLogicalFile::DoOperationOnFileOrDir(WCHAR *pwcName, CInputParams& InParams )
{
	_bstr_t bstrtDrive;
    _bstr_t bstrtPathName;
    WCHAR wstrTemp[_MAX_PATH];
    WCHAR* pwc = NULL;
    DWORD dwStatus = File_STATUS_INVALID_NAME ;

    ZeroMemory(wstrTemp,sizeof(wstrTemp));

	if ((pwcName != NULL) &&
        (wcschr(pwcName, L':') != NULL) &&
        (wcspbrk(pwcName,L"?*") == NULL)) //don't want files with wildchars
	{
		wcscpy(wstrTemp,pwcName);

		//parse the filename for drive & path
		pwc = wcschr(wstrTemp, L':');
        if(pwc == NULL)
        {
			return dwStatus ;
		}

		*pwc = NULL;

		//Get the drive
        bstrtDrive = wstrTemp;
        bstrtDrive += L":";

        ZeroMemory(wstrTemp,sizeof(wstrTemp));
        wcscpy(wstrTemp,pwcName);
        pwc = NULL;
        pwc = wcschr(wstrTemp, L':') + 1;
        if(pwc == NULL)
        {
			return dwStatus ;
		}


		//Get the path
		bstrtPathName = pwc;


		//chek that the the file system is NTFS

		_bstr_t bstrtBuff ;
		bstrtBuff = bstrtDrive ;
		bstrtBuff += L"\\"  ;

		TCHAR szFSName[_MAX_PATH];

		if( !GetVolumeInformation(bstrtBuff, NULL, 0, NULL, NULL, NULL, szFSName, sizeof(szFSName) / sizeof(TCHAR) ) )
		{
			return GetStatusCode() ;
		}

		//NTFS not reqd. for delete or copy...
		if( !lstrcmp(szFSName, _T("NTFS"))  || InParams.eOperation == ENUM_METHOD_DELETE || InParams.eOperation == ENUM_METHOD_COPY )
		{

			DWORD dwAttrib ;

#ifdef NTONLY
			{

				dwAttrib = GetFileAttributesW(pwcName) ;
			}
#endif
#ifdef WIN9XONLY
			{
				dwAttrib = GetFileAttributes( _bstr_t(pwcName) )  ;
			}
#endif

			if( dwAttrib == 0xFFFFFFFF )
			{
				return GetStatusCode() ;
			}

			//check if a dir.
			if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
			{
				if ( InParams.bDoDepthFirst )
				{
					// do a depth-first
#ifdef NTONLY
						dwStatus = EnumAllPathsNT(bstrtDrive, bstrtPathName, InParams ) ;
#endif
#ifdef WIN9XONLY
						dwStatus = EnumAllPaths95(bstrtDrive, bstrtPathName, InParams ) ;
#endif

					if(!dwStatus)
					{
						dwStatus = DoTheRequiredOperation ( pwcName, dwAttrib, InParams )  ;

						//check if the StartFile was encountered
						if ( !dwStatus && !InParams.bOccursAfterStartFile )
						{
							dwStatus = File_STATUS_INVALID_STARTFILE ;
						}
					}
				}
				else  //not a depth first
				{
					//for COPY: parent dir/file already copied so only enumerate sub-paths
					if ( InParams.eOperation != ENUM_METHOD_COPY )
					{
						dwStatus = DoTheRequiredOperation ( pwcName, dwAttrib, InParams ) ;
					}
					else
					{
						dwStatus = STATUS_SUCCESS ;
					}

					if(!dwStatus)
					{
#ifdef NTONLY
							dwStatus = EnumAllPathsNT (bstrtDrive, bstrtPathName, InParams ) ;
#endif
#ifdef WIN9XONLY
							dwStatus = EnumAllPaths95(bstrtDrive, bstrtPathName, InParams ) ;
#endif

						//check if the StartFile was encountered
						if ( !dwStatus && !InParams.bOccursAfterStartFile )
						{
							dwStatus = File_STATUS_INVALID_STARTFILE ;
						}
					}
				}
			}
			//compress the file
			else
			{
				if( InParams.eOperation != ENUM_METHOD_COPY )
				{
					dwStatus = DoTheRequiredOperation ( pwcName, dwAttrib, InParams ) ;

					//check if the StartFile was encountered
					if ( !dwStatus && !InParams.bOccursAfterStartFile )
					{
						dwStatus = File_STATUS_INVALID_STARTFILE ;
					}
				}
				else
				{
					dwStatus = STATUS_SUCCESS ;
				}
			}
		}
		else
		{
			dwStatus = File_STATUS_FILESYSTEM_NOT_NTFS  ; // this to be checked
		}
	}

    return dwStatus ;
}



#ifdef NTONLY
DWORD CCIMLogicalFile::EnumAllPathsNT(const WCHAR *pszDrive, const WCHAR *pszPath, CInputParams& InParams )
{
   WCHAR szBuff[_MAX_PATH];
   WCHAR szCompletePath[_MAX_PATH];

   WIN32_FIND_DATAW stFindData;
   SmartFindClose hFind;
   bool bRoot ;

   DWORD dwStatusCode = STATUS_SUCCESS ;

   // Start building the path for FindFirstFile
   wcscpy(szBuff, pszDrive);

   // Are we looking at the root?
   if (wcscmp(pszPath, L"\\") == 0)
   {
		bRoot = true;
   }
   else
   {
		bRoot = false;
		wcscat(szBuff, pszPath);
   }

   // Complete the path
   wcscat(szBuff, L"\\*.*");

   // Do the find
   hFind = FindFirstFileW(szBuff, &stFindData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
		return false;
   }


   // Walk the directory tree
   do
   {
		// Build path containing the directory we just found
		wcscpy(szCompletePath, pszDrive);
		wcscat(szCompletePath,pszPath) ;
		wcscpy(szBuff, pszPath);
		if (!bRoot)
		{
			wcscat(szBuff, L"\\");
			wcscat(szCompletePath, L"\\") ;
		}

		wcscat(szBuff, stFindData.cFileName);
		wcscat(szCompletePath, stFindData.cFileName);

		if(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			//do the operation on the directory only if the recursive option was set
			if ( InParams.bRecursive )
			{
				// check if it's a dir
				if( wcscmp(stFindData.cFileName, L".")	&& wcscmp(stFindData.cFileName, L"..") )
				{
					if ( InParams.bDoDepthFirst )	// do a depth-first
					{
						dwStatusCode = EnumAllPathsNT(pszDrive, szBuff, InParams );

						if(!dwStatusCode)
						{
							dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;
						}
					}
					else	//it's not a depth first
					{

						dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;

						if(!dwStatusCode)
						{
							dwStatusCode = EnumAllPathsNT(pszDrive, szBuff, InParams );
						}
					}
				}
			}
		}
		else //it's a file
		{
			dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;
		}
   }while ( !dwStatusCode && FindNextFileW(hFind, &stFindData) );

   return dwStatusCode;
}
#endif

#ifdef WIN9XONLY
DWORD CCIMLogicalFile::EnumAllPaths95(LPCTSTR pszDrive, LPCTSTR pszPath,
    CInputParams& InParams )
{
   TCHAR szBuff[_MAX_PATH];
   TCHAR szCompletePath[_MAX_PATH];

   WIN32_FIND_DATA stFindData;
   SmartFindClose hFind;
   bool bRoot ;

   DWORD dwStatusCode = STATUS_SUCCESS ;

   // Start building the path for FindFirstFile
   _tcscpy(szBuff, pszDrive);

   // Are we looking at the root?
   if (_tcscmp(pszPath, _T("\\")) == 0)
   {
		bRoot = true;
   }
   else
   {
		bRoot = false;
		_tcscat(szBuff, pszPath);
   }

   // Complete the path
   _tcscat(szBuff, _T("\\*.*"));

   // Do the find
   hFind = FindFirstFile(szBuff, &stFindData);
   if (hFind == INVALID_HANDLE_VALUE)
   {
		return false;
   }


   // Walk the directory tree
   do
   {
		 // Build path containing the directory we just found
		_tcscpy(szCompletePath, pszDrive);
		_tcscat(szCompletePath,pszPath) ;
		_tcscpy(szBuff, pszPath);
		if (!bRoot)
		{
			_tcscat(szBuff, _T("\\"));
			_tcscat(szCompletePath, _T("\\"));
		}

		_tcscat(szBuff, stFindData.cFileName);
		_tcscat(szCompletePath, stFindData.cFileName);

		if(stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			//do the operation on the directory only if the recursive option was set
			if ( InParams.bRecursive )
			{
				// check if it's a dir
				if( _tcscmp(stFindData.cFileName, _T(".")) && _tcscmp(stFindData.cFileName,
					_T("..")))
				{
					if( InParams.bDoDepthFirst )	// do a depth-first
					{
						dwStatusCode = EnumAllPaths95 ( pszDrive, szBuff, InParams );

						if(!dwStatusCode)
						{
							dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;
						}
					}
					else	//it's not a depth first
					{
						dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;

						if(!dwStatusCode)
						{
							dwStatusCode = EnumAllPaths95(pszDrive, szBuff, InParams );
						}
					}
				}
			}
		}
		else //it's a file
		{
			dwStatusCode = DoTheRequiredOperation ( szCompletePath, stFindData.dwFileAttributes, InParams ) ;
		}
   }while ( !dwStatusCode && FindNextFile(hFind, &stFindData) );

   return dwStatusCode ;

}
#endif

DWORD CCIMLogicalFile::Delete(_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams )
{
	DWORD dwStatus = STATUS_SUCCESS ;
	bool bRet ;

	//remove read-only attrib since we have to delete anyway ?? fix for Bug#31676
	DWORD dwTempAttribs = ~FILE_ATTRIBUTE_READONLY ;

	if(dwAttributes & FILE_ATTRIBUTE_READONLY)
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW(bstrtFileName, dwAttributes & dwTempAttribs ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = SetFileAttributes(bstrtFileName, dwAttributes & dwTempAttribs ) ;
		}
#endif

		if(!bRet)
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}


	if( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
	{

#ifdef NTONLY
		{
			bRet = RemoveDirectoryW( bstrtFileName ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = RemoveDirectory( bstrtFileName ) ;
		}
#endif

	}
	else
	{
#ifdef NTONLY
		{
			bRet = DeleteFileW( bstrtFileName ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = DeleteFile( bstrtFileName ) ;
		}
#endif

	}
	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		dwStatus = GetStatusCode() ;
	}

	return dwStatus ;
}

DWORD CCIMLogicalFile::Compress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams )
{
	SmartCloseHandle hFile ;
	BOOL bRet ;
	if( dwAttributes & FILE_ATTRIBUTE_COMPRESSED )
	{
		return STATUS_SUCCESS ;
	}

	//  Try to remove the READONLY attribute if set, as we've to open the file for writing
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes & ~FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = SetFileAttributes ( bstrtFileName, dwAttributes & ~FILE_ATTRIBUTE_READONLY ) ;
		}
#endif

		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

#ifdef NTONLY
	{

			hFile = CreateFileW(	bstrtFileName,											// pointer to name of the file
									FILE_READ_DATA | FILE_WRITE_DATA ,						// access (read-write) mode
									FILE_SHARE_READ | FILE_SHARE_WRITE ,					// share mode is exclusive
									NULL,													// pointer to security attributes
									OPEN_EXISTING,											// how to create
									FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,	// file attributes
									NULL													// handle to file with attributes to  copy
								);
	}
#endif
#ifdef WIN9XONLY
	{
			hFile = CreateFile(		bstrtFileName,											// pointer to name of the file
									FILE_READ_DATA | FILE_WRITE_DATA ,						// access (read-write) mode
									FILE_SHARE_READ | FILE_SHARE_WRITE ,					// share mode is exclusive
									NULL,													// pointer to security attributes
									OPEN_EXISTING,											// how to create
									FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,	// file attributes
									NULL													// handle to file with attributes to  copy
								);
	}
#endif

	//Turn the READONLY attribute back ON.
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes | FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = SetFileAttributes ( bstrtFileName, dwAttributes | FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

	if ( hFile == INVALID_HANDLE_VALUE )
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	//default Compression format is COMPRESSION_FORMAT_LZNT1
	//use COMPRESSION_FORMAT_NONE to decompress

	USHORT eCompressionState =  COMPRESSION_FORMAT_DEFAULT ;
	DWORD BytesReturned = 0;

	bRet =	DeviceIoControl(	hFile,							// handle to device of interest
								FSCTL_SET_COMPRESSION,			// control code of operation to perform
								(LPVOID ) &eCompressionState,   // pointer to buffer to supply input data
								sizeof(eCompressionState),		// size of input buffer
								NULL,							// pointer to buffer to receive output data
								0,								// size of output buffer
								&BytesReturned,					// pointer to variable to receive output
								NULL							// pointer to overlapped structure for asynchronous operation
							);


	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	return STATUS_SUCCESS ;
}

DWORD CCIMLogicalFile::Uncompress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams )
{
	SmartCloseHandle hFile ;
	BOOL bRet ;
	//check if the file is already uncompressed
	if ( !( dwAttributes & FILE_ATTRIBUTE_COMPRESSED ) )
	{
		return STATUS_SUCCESS ;
	}

	//  Try to remove the READONLY attribute if set, as we've to open the file for writing
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes & ~FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = SetFileAttributes ( bstrtFileName, dwAttributes & ~FILE_ATTRIBUTE_READONLY ) ;
		}
#endif

		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

#ifdef NTONLY
	{

			hFile = CreateFileW(	bstrtFileName,											// pointer to name of the file
									FILE_READ_DATA | FILE_WRITE_DATA ,						// access (read-write) mode
									FILE_SHARE_READ | FILE_SHARE_WRITE ,					// share mode is exclusive
									NULL,													// pointer to security attributes
									OPEN_EXISTING,											// how to create
									FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,	// file attributes
									NULL													// handle to file with attributes to  copy
								);
	}
#endif
#ifdef WIN9XONLY
	{
			hFile = CreateFile(		bstrtFileName,											// pointer to name of the file
									FILE_READ_DATA | FILE_WRITE_DATA ,						// access (read-write) mode
									FILE_SHARE_READ | FILE_SHARE_WRITE ,					// share mode is exclusive
									NULL,													// pointer to security attributes
									OPEN_EXISTING,											// how to create
									FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,	// file attributes
									NULL													// handle to file with attributes to  copy
								);
	}
#endif

	//Turn the READONLY attribute back ON.
	if ( dwAttributes & FILE_ATTRIBUTE_READONLY )
	{
#ifdef NTONLY
		{
			bRet = SetFileAttributesW ( bstrtFileName, dwAttributes | FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = SetFileAttributes ( bstrtFileName, dwAttributes | FILE_ATTRIBUTE_READONLY ) ;
		}
#endif
		if ( !bRet )
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}
	}

	if ( hFile == INVALID_HANDLE_VALUE )
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	USHORT eCompressionState = COMPRESSION_FORMAT_NONE ;
	DWORD BytesReturned = 0;

	bRet =	DeviceIoControl(	hFile,							// handle to device of interest
								FSCTL_SET_COMPRESSION,			// control code of operation to perform
								(LPVOID ) &eCompressionState,   // pointer to buffer to supply input data
								sizeof(eCompressionState),		// size of input buffer
								NULL,							// pointer to buffer to receive output data
								0,								// size of output buffer
								&BytesReturned,					// pointer to variable to receive output
								NULL							// pointer to overlapped structure for asynchronous operation
							);


	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
		return GetStatusCode() ;
	}

	return STATUS_SUCCESS ;
}

HRESULT CCIMLogicalFile::DeleteInstance(const CInstance& newInstance, long lFlags /*= 0L*/)
{
	HRESULT hr = WBEM_S_NO_ERROR ;
	DWORD dwStatus ;
	WCHAR *pwcFileName = NULL;
	if ( newInstance.GetWCHAR( IDS_Name, &pwcFileName) &&  pwcFileName != NULL )
	{
        try
        {
		    CInputParams InParams ( pwcFileName, (PWCHAR)NULL, 0, NULL, true, ENUM_METHOD_DELETE ) ;
		    dwStatus = DoOperationOnFileOrDir ( pwcFileName, InParams ) ;
        }
        catch ( ... )
        {
            if (pwcFileName)
            {
                free(pwcFileName);
                pwcFileName = NULL;
            }
            throw;
        }

        if (pwcFileName)
        {
            free(pwcFileName);
            pwcFileName = NULL;
        }

		if(dwStatus != STATUS_SUCCESS)
		{
			hr = MapStatusCodestoWbemCodes( dwStatus ) ;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_PARAMETER ;
	}

	return hr ;
}


typedef DWORD  (WINAPI *SETNAMEDSECURITYINFO)(
	LPWSTR,
	SE_OBJECT_TYPE,
	SECURITY_INFORMATION,
	PSID,
	PSID,
	PACL,
	PACL);


DWORD CCIMLogicalFile::TakeOwnership( _bstr_t bstrtFileName, CInputParams& InputParams )
{
#ifdef NTONLY
    HANDLE hToken ;
	TOKEN_USER * pTokenUser = NULL ;
	DWORD dwReturnLength ;
	HRESULT hr = E_FAIL ;
	CAdvApi32Api* pAdvApi32 = NULL ;
	try
	{

		BOOL bStatus = OpenThreadToken (	GetCurrentThread(),
											TOKEN_QUERY ,
											TRUE,  //?
											&hToken
										) ;

		if ( ! bStatus )
		{

			bStatus = OpenProcessToken (	GetCurrentProcess(),
											TOKEN_QUERY | TOKEN_DUPLICATE ,
											&hToken
										) ;
		}

		if(!bStatus)
		{
			//set the file-name at which error occured
			InputParams.bstrtErrorFileName = bstrtFileName ;
			return GetStatusCode() ;
		}

		TOKEN_INFORMATION_CLASS eTokenInformationClass = TokenUser ;

		BOOL bTokenStatus = GetTokenInformation (	hToken,
													eTokenInformationClass ,
													NULL ,
													0 ,
													&dwReturnLength
												) ;

		if ( ! bTokenStatus && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
		{
			pTokenUser = ( TOKEN_USER * ) new UCHAR [ dwReturnLength ] ;

			bTokenStatus = GetTokenInformation (	hToken,//hToken1,
													eTokenInformationClass ,
													(LPVOID) pTokenUser ,
													dwReturnLength ,
													& dwReturnLength
												) ;

			DWORD dwRes ;
			if ( bTokenStatus )
			{

				//HINSTANCE hinstAdvapi = LoadLibrary(_T("advapi32.dll"));
				//
				//if (!hinstAdvapi)
				//	return File_STATUS_UNKNOWN_FAILURE;

				pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
				if(pAdvApi32 != NULL)
				{

					//SETNAMEDSECURITYINFO fpSetNamedSecurityInfoW =
					//    (SETNAMEDSECURITYINFO) GetProcAddress(hinstAdvapi,
					//    "SetNamedSecurityInfoW");
					//
					//if (!fpSetNamedSecurityInfoW)
					//    return File_STATUS_UNKNOWN_FAILURE;

					pAdvApi32->SetNamedSecurityInfoW(
												bstrtFileName,               // name of the object
												SE_FILE_OBJECT,              // type of object
												OWNER_SECURITY_INFORMATION,  // change only the object's pwner
												pTokenUser->User.Sid ,       // desired SID
												NULL, NULL, NULL,
												&dwRes);
				}
				else
				{
					return File_STATUS_UNKNOWN_FAILURE;
				}

				//FreeLibrary(hinstAdvapi);

				if(pTokenUser)
				{
					delete[] (UCHAR*)pTokenUser ;
					pTokenUser = NULL ;
				}

				dwRes = MapWinErrorToStatusCode(dwRes) ;
				if ( dwRes != STATUS_SUCCESS )
				{
					//set the file-name at which error occured
					InputParams.bstrtErrorFileName = bstrtFileName ;
				}

				return dwRes ;
			}

		}
	}
	catch ( ... )
	{
		if(pTokenUser)
		{
			delete[] (UCHAR*)pTokenUser ;
			pTokenUser = NULL ;
		}

		if ( pAdvApi32 )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
			pAdvApi32 = NULL ;
		}

		throw ;
	}

	if(pTokenUser)
	{
		delete[] (UCHAR*)pTokenUser ;
		pTokenUser = NULL ;
	}

	CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
	pAdvApi32 = NULL;

	DWORD dwRet = GetStatusCode();
	if ( dwRet != STATUS_SUCCESS )
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtFileName ;
	}
	return dwRet ;


#endif
#ifdef WIN9XONLY
    return -1L;
#endif
}


HRESULT CCIMLogicalFile::CheckCopyFileOrDir(

	const CInstance& rInstance ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	DWORD &dwStatus ,
	bool bExtendedMethod,
	CInputParams& InputParams
)
{
	HRESULT hr = S_OK ;

	bool bExists ;
	VARTYPE eType ;

	WCHAR * pszNewFileName  = NULL;

	CHString chsStartFile ;
	if ( bExtendedMethod )
	{
		if ( pInParams->GetStatus( METHOD_ARG_NAME_START_FILENAME, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BSTR || eType == VT_NULL ) )
			{
				if ( eType == VT_BSTR )
				{
					if ( pInParams->GetCHString( METHOD_ARG_NAME_START_FILENAME, chsStartFile ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}

		//check if recursive operation is desired
		if ( pInParams->GetStatus( METHOD_ARG_NAME_RECURSIVE, bExists , eType ) )
		{
			if ( bExists && ( eType == VT_BOOL || eType == VT_NULL ) )
			{
				if ( eType == VT_BOOL )
				{
					if ( pInParams->Getbool( METHOD_ARG_NAME_RECURSIVE, InputParams.bRecursive ) )
					{
					}
					else
					{
						dwStatus = File_STATUS_INVALID_PARAMETER ;
						return hr ;
					}
				}
			}
			else
			{
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}

	//set the start file if given as input after checking that it's a fully qualified path
	if ( !chsStartFile.IsEmpty() )
	{
		InputParams.bstrtStartFileName = (LPCWSTR)chsStartFile ;
		WCHAR* pwcTmp	= InputParams.bstrtStartFileName ;
		WCHAR* pwcColon = L":" ;

		if( *(pwcTmp + 1) != *pwcColon )
		{
			dwStatus = File_STATUS_INVALID_NAME ;
			return hr ;
		}
	}

	if ( pInParams->GetStatus( METHOD_ARG_NAME_NEWFILENAME , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_BSTR ) )
		{
			if ( pInParams->GetWCHAR( METHOD_ARG_NAME_NEWFILENAME, &pszNewFileName) && pszNewFileName != NULL )
			{
			}
			else
			{
				// Zero Length string
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else if(bExists)
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

    try
    {
        if ( dwStatus == STATUS_SUCCESS )
	    {
		    dwStatus = CopyFileOrDir(rInstance, pszNewFileName, InputParams ) ;
	    }
    }
    catch ( ... )
    {
        if (pszNewFileName)
        {
            free(pszNewFileName);
            pszNewFileName = NULL;
        }
        throw;
    }

    if (pszNewFileName)
    {
        free(pszNewFileName);
        pszNewFileName = NULL;
    }

	return hr ;
}


DWORD CCIMLogicalFile::CopyFileOrDir(const CInstance &rInstance, _bstr_t bstrtNewFileName, CInputParams& InputParams )
{
	DWORD dwStatus = STATUS_SUCCESS ;

	WCHAR *pszTemp = NULL ;
	bool bRet = false;

// a very crude way to check for a fully qualified path(?)
	WCHAR* pwcTmp	= bstrtNewFileName ;

	if (!pwcTmp)
	{
		return File_STATUS_INVALID_NAME ;
	}

	WCHAR* pwcColon = L":" ;

	if( *(pwcTmp + 1) != *pwcColon )
	{
		return File_STATUS_INVALID_NAME ;
	}

    _bstr_t bstrtOriginalName;

	rInstance.GetWCHAR(IDS_Name,&pszTemp) ;

    try
    {
	    bstrtOriginalName = pszTemp;
    }
    catch ( ... )
    {
        free(pszTemp);
        throw;
    }

    free(pszTemp);
    pszTemp = NULL;

	if(  wcsstr( pwcTmp, bstrtOriginalName ) )
	{
		PWCHAR pwcTest = pwcTmp + bstrtOriginalName.length () ;
		if ( *pwcTest == '\0' || *pwcTest == '\\' )
		{
			return File_STATUS_INVALID_NAME ;
		}
	}

	DWORD dwAttrib ;

#ifdef NTONLY
	{
		dwAttrib = GetFileAttributesW(bstrtOriginalName)  ;
	}
#endif
#ifdef WIN9XONLY
	{
		dwAttrib = GetFileAttributes(bstrtOriginalName) ;
	}
#endif

	if( dwAttrib == 0xFFFFFFFF )
	{
		return GetStatusCode() ;
	}

	//copy the parent dir/file only if it satisfies start file-name condition
	bool bDoIt = false ;
	if ( !InputParams.bstrtStartFileName )
	{
		bDoIt = true ;
	}
	else
	{
		if ( bstrtOriginalName == InputParams.bstrtStartFileName )
		{
			bDoIt = true ;
		}
	}

	if ( bDoIt )
	{

		BOOL bCancel = FALSE ;

		//check if it's a file to be copied
		if( !( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) )
		{

#ifdef NTONLY
			{

				bRet = ::CopyFileW(	bstrtOriginalName,		// pointer to name of an existing file
									bstrtNewFileName,         // pointer to filename to copy to
									TRUE);

			}
#endif
#ifdef WIN9XONLY
			{
				bRet = ::CopyFile(bstrtOriginalName, bstrtNewFileName, TRUE ) ;
			}
#endif

			if( !bRet )
			{
				dwStatus = GetStatusCode() ;
				InputParams.bstrtErrorFileName = bstrtOriginalName ;
			}

			return dwStatus ;
		}


	// If we r here , we've to copy dir .CHek about SD's
#ifdef NTONLY
		{

			bRet = CreateDirectoryExW(	bstrtOriginalName,		// pointer to path string of template directory
										bstrtNewFileName,			// pointer to path string of directory to create
										NULL					// pointer to security descriptor
										) ;
		}
#endif
#ifdef WIN9XONLY
		{

			bRet = CreateDirectoryEx(	bstrtOriginalName,		// pointer to path string of template directory
										bstrtNewFileName,			// pointer to path string of directory to create
										NULL					// pointer to security descriptor
										) ;
		}
#endif

		if(!bRet)
		{
			InputParams.bstrtErrorFileName = bstrtOriginalName ;
			return GetStatusCode() ;
		}
	}

	//now copy from original dir to new dir...
	InputParams.SetValues ( bstrtOriginalName, 0, NULL, false, ENUM_METHOD_COPY ) ;
	if ( bDoIt )
	{
		InputParams.bOccursAfterStartFile = true ;
	}
	InputParams.bstrtMirror = bstrtNewFileName ;
	dwStatus = DoOperationOnFileOrDir(bstrtOriginalName, InputParams) ;

	return dwStatus ;
}




DWORD CCIMLogicalFile::CopyFile(_bstr_t bstrtOriginalFile, DWORD dwFileAttributes, bstr_t bstrtMirror, bstr_t bstrtParentDir, CInputParams& InputParams )
{
	_bstr_t wstrTemp ;
    WCHAR* pwc = NULL;
	bool bRet ;

	WCHAR pszOriginalName[_MAX_PATH] ;
    wcscpy(pszOriginalName, bstrtOriginalFile) ;

	wstrTemp = bstrtMirror ;

	//remove parent dir name
	pwc = wcsstr(pszOriginalName, bstrtParentDir ) ;
	if(pwc == NULL)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtOriginalFile ;
		return File_STATUS_INVALID_NAME ;
	}

	pwc = pwc + wcslen( bstrtParentDir ) ;
	if(pwc == NULL)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtOriginalFile ;
		return File_STATUS_INVALID_NAME ;
	}

	wstrTemp += pwc ;

	//create new dir if it's a dir
	if(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
	{

		//chek out SD
#ifdef NTONLY
		{
			bRet =  CreateDirectoryExW(	bstrtOriginalFile,		// pointer to path string of template directory
										wstrTemp,			// pointer to path string of directory to create
										NULL					// pointer to security descriptor
										) ;
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = CreateDirectoryEx(	bstrtOriginalFile,		// pointer to path string of template directory
										wstrTemp,			// pointer to path string of directory to create
										NULL					// pointer to security descriptor
										) ;
		}
#endif

	}
	else //copy the file
	{

		BOOL bCancel = FALSE ;

#ifdef NTONLY
		{
			bRet = ::CopyFileW(	bstrtOriginalFile,		// pointer to name of an existing file
								wstrTemp,         // pointer to filename to copy to
								TRUE);
		}
#endif
#ifdef WIN9XONLY
		{
			bRet = ::CopyFile(bstrtOriginalFile, wstrTemp, TRUE ) ;
		}
#endif


	}

	if(!bRet)
	{
		//set the file-name at which error occured
		InputParams.bstrtErrorFileName = bstrtOriginalFile ;
		return GetStatusCode() ;
	}
	else
	{
		return STATUS_SUCCESS ;
	}
}


HRESULT CCIMLogicalFile::CheckRenameFileOrDir(

	const CInstance& rInstance ,
	CInstance *pInParams ,
	CInstance *pOutParams ,
	DWORD &dwStatus
)
{
	HRESULT hr = S_OK ;

	bool bExists ;
	VARTYPE eType ;

	WCHAR * pszNewFileName  = NULL;

	if ( pInParams->GetStatus( METHOD_ARG_NAME_NEWFILENAME , bExists , eType ) )
	{
		if ( bExists && ( eType == VT_BSTR ) )
		{
			if ( pInParams->GetWCHAR( METHOD_ARG_NAME_NEWFILENAME, &pszNewFileName) && pszNewFileName != NULL )
			{
			}
			else
			{
				// Zero Length string
				dwStatus = File_STATUS_INVALID_PARAMETER ;
				return hr ;
			}
		}
		else if(bExists)
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
		else
		{
			dwStatus = File_STATUS_INVALID_PARAMETER ;
			return hr ;
		}
	}
	else
	{
		dwStatus = File_STATUS_INVALID_PARAMETER ;
		return WBEM_E_PROVIDER_FAILURE ;
	}

    try
    {
	    if ( dwStatus == STATUS_SUCCESS )
	    {
		    dwStatus = RenameFileOrDir(rInstance, pszNewFileName) ;
	    }
    }
    catch ( ... )
    {
        if (pszNewFileName)
        {
            free(pszNewFileName);
            pszNewFileName = NULL;
        }
        throw;
    }

    if (pszNewFileName)
    {
        free(pszNewFileName);
        pszNewFileName = NULL;
    }

	return hr ;
}


DWORD CCIMLogicalFile::RenameFileOrDir(const CInstance &rInstance, WCHAR* pszNewFileName )
{

	WCHAR pszOriginalName[_MAX_PATH] ;
	WCHAR *pszTemp = NULL ;
	ZeroMemory((PVOID) pszOriginalName, sizeof(pszOriginalName) ) ;
	DWORD dwStatus = STATUS_SUCCESS ;
	WCHAR *pwDrive1 = NULL , *pwDrive2 = NULL ;

	// a very crude way to check for a fully qualified path(?)
	WCHAR* pwcColon = L":" ;

	if( *(pszNewFileName + 1) != *pwcColon )
	{
		return File_STATUS_INVALID_NAME ;
	}



	rInstance.GetWCHAR(IDS_Name,&pszTemp) ;

	if(pszTemp)
	{
		wcscpy(pszOriginalName,pszTemp) ;
		free(pszTemp) ;
	}

#ifdef NTONLY
	{
    	bool bRet ;
		bRet = MoveFileExW(	pszOriginalName,	// pointer to the name of the existing file
							pszNewFileName,		// pointer to the new name for the file
							0	)	;			// flag that specifies how to move file

		if(!bRet)
		{
			dwStatus = GetStatusCode() ;
		}
	}
#endif
#ifdef WIN9XONLY
	{

		//note: MoveFileEx not implemented on 95
		WCHAR szTmpDrive1[_MAX_PATH] , szTmpDrive2[_MAX_PATH] ;
		wcscpy(szTmpDrive1, pszOriginalName) ;
		wcscpy(szTmpDrive2, pszNewFileName) ;


		pwDrive1 = wcschr(szTmpDrive1, L':') ;
		pwDrive2 = wcschr(szTmpDrive2, L':') ;

		if( (!pwDrive1) || (!pwDrive2) )
		{
			dwStatus = File_STATUS_INVALID_NAME ;
		}
		else
		{

			*pwDrive1 = 0 ; *pwDrive2 = 0 ;
			if( !_wcsicmp( szTmpDrive1, szTmpDrive2 ) ) //to be moved in same drive
			{
				CHString a(pszOriginalName) ; CHString b(pszNewFileName) ;
				if (!MoveFile(TOBSTRT(a), TOBSTRT(b)) )
				{
					dwStatus = GetStatusCode() ;
				}
			}
			else
			{
				dwStatus = File_STATUS_NOT_SAME_DRIVE ;
			}
		}
	}
#endif


	return dwStatus ;


}

HRESULT CCIMLogicalFile::CheckEffectivePermFileOrDir(const CInstance& rInstance,
	                                                 CInstance *pInParams,
	                                                 CInstance *pOutParams,
	                                                 bool& fHasPerm)
{
	HRESULT hr = S_OK;

#ifdef WIN9XONLY
	{
		hr = WBEM_E_INVALID_METHOD;
	}
#endif
#ifdef NTONLY
	bool bExists ;
	VARTYPE eType ;
	DWORD dwPermToCheck = 0L;

	if(pInParams->GetStatus(METHOD_ARG_NAME_PERMISSION, bExists, eType))
	{
		if(bExists && (eType == VT_I4))
		{
			if(!pInParams->GetDWORD(METHOD_ARG_NAME_PERMISSION, dwPermToCheck))
			{
				// Invalid arguement
				fHasPerm = false;
			}
		}
		else
		{
			fHasPerm = false;
			hr = WBEM_E_INVALID_PARAMETER;
		}
	}
	else
	{
		fHasPerm = false;;
		hr = WBEM_E_PROVIDER_FAILURE;
	}

	if(SUCCEEDED(hr))
	{
		DWORD dwRes = EffectivePermFileOrDir(rInstance, dwPermToCheck);
        if(dwRes == ERROR_SUCCESS)
        {
            fHasPerm = true;
        }
        else if(dwRes == ERROR_PRIVILEGE_NOT_HELD)  // This is the only error case we want to explicitly return
        {                                           // other than S_OK for, as one might invalidly assume that the right didn't exist just because the privilege wasn't enabled.
            SetSinglePrivilegeStatusObject(rInstance.GetMethodContext(), SE_SECURITY_NAME);
            fHasPerm = false;
            hr = WBEM_E_PRIVILEGE_NOT_HELD;
        }
	}
#endif
	return hr ;
}


DWORD CCIMLogicalFile::EffectivePermFileOrDir(const CInstance &rInstance, const DWORD dwPermToCheck)
{
    DWORD dwRet = -1L;

#ifdef NTONLY
    // All we need to do is call NtOpenFile with the specified permissions.  Must be careful
    // to not open the file/dir for exclusive access.  If we can open it with the requested
    // access, return true.

    // First, get the file/dir name...
    WCHAR wstrFileName[_MAX_PATH + 8];
    ZeroMemory(wstrFileName, sizeof(wstrFileName));
    WCHAR* wstrTemp = NULL;

    rInstance.GetWCHAR(IDS_Name,&wstrTemp);

	if(wstrTemp != NULL)
	{
		wcscpy(wstrFileName, L"\\??\\");
        wcsncat(wstrFileName, wstrTemp, _MAX_PATH - 1);
		free(wstrTemp);
	}

    CNtDllApi *pNtDllApi = NULL;
    pNtDllApi = (CNtDllApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNtDllApi, NULL);
    if(pNtDllApi != NULL)
    {
        HANDLE hFileHandle = 0L;
        UNICODE_STRING ustrNtFileName = { 0 };
        OBJECT_ATTRIBUTES oaAttributes;
        IO_STATUS_BLOCK IoStatusBlock;

        try
        {
            if(NT_SUCCESS(pNtDllApi->RtlInitUnicodeString(&ustrNtFileName, wstrFileName)) && ustrNtFileName.Buffer)
            {
                InitializeObjectAttributes(&oaAttributes,
					                       &ustrNtFileName,
					                       OBJ_CASE_INSENSITIVE,
					                       NULL,
					                       NULL);

                // We must have the security privilege enabled in order to access the object's SACL, which in
                // some cases is exactly what we are testing for (e.g., the ACCESS_SYSTEM_SECURITY right).
                CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
                bool fDisablePrivilege = false;

                if(dwPermToCheck & ACCESS_SYSTEM_SECURITY)
                {
                    fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
                }

                NTSTATUS ntstat = -1L;
                ntstat = pNtDllApi->NtOpenFile(&hFileHandle,
                                               dwPermToCheck,
                                               &oaAttributes,
                                               &IoStatusBlock,
                                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                               0);
                if(NT_SUCCESS(ntstat))
                {
                    dwRet = ERROR_SUCCESS;
                    pNtDllApi->NtClose(hFileHandle);
                    hFileHandle = 0L;
                }
                else if( STATUS_PRIVILEGE_NOT_HELD == ntstat )
                {
                    dwRet = ERROR_PRIVILEGE_NOT_HELD;
                }

                if(fDisablePrivilege)
                {
                    securityPrivilege.Enable(FALSE);
                }

                RtlFreeUnicodeString(&ustrNtFileName);
                ustrNtFileName.Buffer = NULL;
            }

            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNtDllApi, pNtDllApi);
            pNtDllApi = NULL;
        }
        catch(...)
        {
            if(ustrNtFileName.Buffer)
            {
                RtlFreeUnicodeString(&ustrNtFileName);
                ustrNtFileName.Buffer = NULL;
            }
            throw;
        }
    }

#endif

    return dwRet;
}





DWORD CCIMLogicalFile::GetStatusCode()
{
	DWORD t_Error = GetLastError() ;

	TCHAR buf[255];
	wsprintf(buf, _T("%d"), t_Error) ;
	OutputDebugString(buf) ;
	return MapWinErrorToStatusCode(t_Error) ;

}


DWORD CCIMLogicalFile::MapWinErrorToStatusCode(DWORD dwWinError)
{

	DWORD t_Result ;

	switch ( dwWinError )
	{
		case ERROR_SUCCESS:
			{
				t_Result = STATUS_SUCCESS ;
			}
			break;


		case ERROR_ACCESS_DENIED:
			{
				t_Result = File_STATUS_ACCESS_DENIED ;
			}
			break ;

		case ERROR_DIR_NOT_EMPTY:
			{
				t_Result = File_STATUS_DIR_NOT_EMPTY ;
			}
			break ;


		case ERROR_NOT_SAME_DEVICE:
			{
				t_Result = File_STATUS_NOT_SAME_DRIVE ;
			}
			break ;


		case ERROR_ALREADY_EXISTS:
		case ERROR_FILE_EXISTS:
			{
				t_Result = File_STATUS_ALREADY_EXISTS ;
			}
			break ;

		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
			{
				t_Result = File_STATUS_INVALID_NAME ;
			}
			break ;

		case ERROR_SHARING_VIOLATION:
			{
				t_Result = File_STATUS_SHARE_VIOLATION ;
			}
		break ;

		default:
			{
				t_Result = File_STATUS_UNKNOWN_FAILURE ;
			}
			break ;
	}

	return t_Result ;
}

HRESULT CCIMLogicalFile::MapStatusCodestoWbemCodes(DWORD dwStatus)
{
	HRESULT hr = E_FAIL ;

	switch(dwStatus)
	{
		case File_STATUS_ACCESS_DENIED:
			{
				hr = WBEM_E_ACCESS_DENIED ;
			}
			break ;

		case File_STATUS_INVALID_NAME:
			{
				hr = WBEM_E_NOT_FOUND ;
			}
			break ;

		default:
			{
				hr = WBEM_E_FAILED ;
			}
			break ;
	}

	return hr ;
}


DWORD CCIMLogicalFile::DoTheRequiredOperation ( bstr_t bstrtFileName, DWORD dwAttrib, CInputParams& InputParams )
{
	DWORD dwStatus = STATUS_SUCCESS ;
	//check if the this file occurs after the file from which operation has to be started
	if ( !InputParams.bOccursAfterStartFile )
	{
		if ( bstrtFileName == InputParams.bstrtStartFileName )
		{
			InputParams.bOccursAfterStartFile = true ;
		}
	}

	//now do the operation, only if the file occurs after the start file
	if ( InputParams.bOccursAfterStartFile )
	{
		switch ( InputParams.eOperation )
		{
		case ENUM_METHOD_DELETE:
			{
				dwStatus = Delete ( bstrtFileName, dwAttrib, InputParams ) ;
				break ;
			}

		case ENUM_METHOD_COMPRESS:
			{
				dwStatus = Compress ( bstrtFileName, dwAttrib, InputParams ) ;
				break ;
			}
		case ENUM_METHOD_UNCOMPRESS:
			{
				dwStatus = Uncompress ( bstrtFileName, dwAttrib, InputParams ) ;
				break;
			}

		case ENUM_METHOD_TAKEOWNERSHIP:
			{
				dwStatus = TakeOwnership ( bstrtFileName, InputParams ) ;
				break ;
			}

		case ENUM_METHOD_COPY:
			{
				dwStatus = CopyFile( bstrtFileName, dwAttrib, InputParams.bstrtMirror, InputParams.bstrtFileName, InputParams ) ;
				break ;
			}

		case ENUM_METHOD_CHANGE_PERM:
			{
				dwStatus = ChangePermissions( bstrtFileName, InputParams.dwOption, InputParams.pSD, InputParams ) ;
				break ;
			}
		}
	}

	return dwStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\floppy.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Floppy.cpp
//
//  Purpose: Floppy drive property set provider
//
//***************************************************************************

#include "precomp.h"

#include <winioctl.h>
#include <ntddscsi.h>

#include "Floppy.h"

#include <comdef.h>

#include "Kernel32Api.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_FLOPPYDISK L"FloppyDisk"
#define CONFIG_MANAGER_CLASS_GUID_FLOPPYDISK L"{4d36e980-e325-11ce-bfc1-08002be10318}"

CWin32_FloppyDisk s_FloppyDisk ( PROPSET_NAME_FLOPPYDISK , IDS_CimWin32Namespace );

/*
 *	Note QueryDosDevice doesn't allow us to get the actual size of the buffer.
 *	We would have to call the underlying OS api ( NtQueryDevice.... ) to do it
 *	properly. The buffers should be large enough however.
 */


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::CWin32_FloppyDisk
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_FloppyDisk :: CWin32_FloppyDisk (

	LPCWSTR a_Name,
	LPCWSTR a_Namespace

) : Provider ( a_Name, a_Namespace )
{
//	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::~CWin32_FloppyDisk
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_FloppyDisk :: ~CWin32_FloppyDisk()
{
//	DeleteCriticalSection ( & m_CriticalSection ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: GetObject ( CInstance *a_Instance, long a_Flags, CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;

    CConfigManager t_ConfigManager ;

/*
 * Let's see if config manager recognizes this device at all
 */

    CHString t_Key ;
    a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

    CConfigMgrDevicePtr t_Device;
    if ( t_ConfigManager.LocateDevice ( t_Key , & t_Device ) )
    {
/*
 * Ok, it knows about it.  Is it a Floppy device?
 */
        if (t_Device->IsClass(CONFIG_MANAGER_CLASS_FLOPPYDISK))
		{
			TCHAR *t_DosDeviceNameList = NULL ;

			if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
			{
				try
				{
					CHString t_DeviceId ;
					if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
					{
						DWORD t_SpecifiedProperties = GetBitMask( a_Query );

						t_Result = LoadPropertyValues ( a_Instance, t_Device , t_DeviceId , t_DosDeviceNameList, t_SpecifiedProperties ) ;
					}
				}
				catch ( ... )
				{
					delete [] t_DosDeviceNameList ;

					throw ;
				}

				delete [] t_DosDeviceNameList ;
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;
			}
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyDisk :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask( a_Query );

//	if ( t_SpecifiedProperties )
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_S_NO_ERROR ;

	TCHAR *t_DosDeviceNameList = NULL ;
	if ( QueryDosDeviceNames ( t_DosDeviceNameList ) )
	{
		try
		{
			CConfigManager t_ConfigManager ;
			CDeviceCollection t_DeviceList ;

		/*
		*	While it might be more performant to use FilterByGuid, it appears that at least some
		*	95 boxes will report InfraRed info if we do it this way.
		*/

			if ( t_ConfigManager.GetDeviceListFilterByClass ( t_DeviceList, CONFIG_MANAGER_CLASS_FLOPPYDISK ) )
			{
				REFPTR_POSITION t_Position ;

				if ( t_DeviceList.BeginEnum ( t_Position ) )
				{
					CConfigMgrDevicePtr t_Device;

					t_Result = WBEM_S_NO_ERROR ;

					// Walk the list
					for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
						 SUCCEEDED( t_Result ) && ( t_Device != NULL );
						 t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
					{
						CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
						CHString t_DeviceId ;
						if ( t_Device->GetPhysicalDeviceObjectName ( t_DeviceId ) )
						{
							t_Result = LoadPropertyValues ( t_Instance , t_Device , t_DeviceId , t_DosDeviceNameList , a_SpecifiedProperties ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Instance->Commit (  ) ;
							}
						}
						else
						{
							//t_Result = WBEM_E_PROVIDER_FAILURE ;  // Don't return failures from query or enum as impacts association classes
						}
					}

					// Always call EndEnum().  For all Beginnings, there must be an End

					t_DeviceList.EndEnum();
				}
			}
		}
		catch ( ... )
		{
			delete [] t_DosDeviceNameList ;

			throw ;
		}

		delete [] t_DosDeviceNameList ;
	}
	else
	{
		//t_Result = WBEM_E_PROVIDER_FAILURE ;  // Don't return failures from query or enum as impacts association classes
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyDisk :: LoadPropertyValues (

	CInstance *a_Instance,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = LoadConfigManagerPropertyValues ( a_Instance , a_Device , a_DeviceName , a_SpecifiedProperties ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_SpecifiedProperties & SPECIAL_MEDIA )
		{
			CHString t_DosDeviceName ;
			t_Result = GetDeviceInformation ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_DosDeviceNameList , a_SpecifiedProperties ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
#if 0
				t_Result = LoadMediaPropertyValues ( a_Instance , a_Device , a_DeviceName , t_DosDeviceName , a_SpecifiedProperties ) ;
#endif
			}
			else
			{
				t_Result = ( t_Result == WBEM_E_NOT_FOUND ) ? S_OK : t_Result ;
			}
		}
	}

	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyDisk::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyDisk :: LoadConfigManagerPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

	a_Instance->SetWBEMINT16(IDS_Availability, 3 ) ;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID ) // Always populate the key
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
        a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

//	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
//	{
//	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 16 ) ;
//	}

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk :: GetDeviceInformation
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk :: GetDeviceInformation (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	CHString a_DeviceName ,
	CHString &a_DosDeviceName ,
	const TCHAR *a_DosDeviceNameList ,
	DWORD a_SpecifiedProperties
)
{
	HRESULT t_Result = S_OK ;

	ULONG t_DeviceIndexLength = a_DeviceName.GetLength() + 1 - sizeof ( _TEXT("\\Device\\FloppyPdo" ) ) / sizeof ( TCHAR ) ;

	CHString t_FloppyIndex = a_DeviceName.Right ( t_DeviceIndexLength ) ;

	TCHAR t_DeviceLabel [ sizeof ( TCHAR ) * 17 + sizeof ( _TEXT("\\Device\\Floppy") ) * sizeof ( TCHAR ) ] ;
	_stprintf ( t_DeviceLabel , _TEXT("\\Device\\Floppy%s") , t_FloppyIndex ) ;

	TCHAR t_Query [ MAX_PATH * 2 ] ;

	DWORD t_QueryStatus = QueryDosDevice ( _TEXT("a:") , t_Query , sizeof ( t_Query ) / sizeof ( TCHAR ) ) ;

	if ( ! FindDosDeviceName ( a_DosDeviceNameList , t_DeviceLabel, a_DosDeviceName , TRUE ) )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyDisk :: LoadMediaPropertyValues
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyDisk::LoadMediaPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	const CHString &a_DosDeviceName ,
	DWORD a_SpecifiedProperties
)
{

	HRESULT t_Result = S_OK ;

/*
 *
 */
    // Set common drive properties
    //=============================

	CHString t_DeviceLabel = CHString ( a_DosDeviceName ) ;

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DRIVE )
	{
	    a_Instance->SetCharSplat ( IDS_Drive, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_ID )
	{
		a_Instance->SetCharSplat ( IDS_Id, t_DeviceLabel ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPABILITY )
	{
		// Create a safearray for the Capabilities information

		SAFEARRAYBOUND t_ArrayBounds ;

		t_ArrayBounds.cElements = 2;
		t_ArrayBounds.lLbound = 0;

        variant_t t_CapabilityValue ;
		if ( V_ARRAY ( & t_CapabilityValue ) = SafeArrayCreate ( VT_I2 , 1 , & t_ArrayBounds ) )
		{
			V_VT ( & t_CapabilityValue ) = VT_I2 | VT_ARRAY ;
			long t_Capability = 3 ;
			long t_Index = 0;

			HRESULT t_Result = SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ) , & t_Index , & t_Capability ) ;
			if ( t_Result == E_OUTOFMEMORY )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			t_Index = 1;
			t_Capability = 7 ;
			t_Result = SafeArrayPutElement ( V_ARRAY ( & t_CapabilityValue ), & t_Index , & t_Capability ) ;
			if ( t_Result == E_OUTOFMEMORY )
			{
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			a_Instance->SetVariant ( IDS_Capabilities , t_CapabilityValue ) ;

		}
		else
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
	}

/*
 * Media type
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIATYPE )
	{
	    a_Instance->SetCharSplat ( IDS_MediaType , IDS_MDT_CD ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_VOLUMEINFORMATION )
	{

/*
 * Set the DriveIntegrity and TransferRate properties:
 */

		CHString t_VolumeDevice = CHString ( L"\\\\.\\" ) + a_DosDeviceName + CHString ( L"\\" ) ;

/*
 *	Volume information
 */

		TCHAR t_FileSystemName [ _MAX_PATH ] = _T("Unknown file system");

		TCHAR t_VolumeName [ _MAX_PATH ] ;
		DWORD t_VolumeSerialNumber ;
		DWORD t_MaxComponentLength ;
		DWORD t_FileSystemFlags ;

		ULARGE_INTEGER t_TotalBytes ;
		ULARGE_INTEGER t_AvailableBytes ;
		BOOL t_SizeFound = FALSE ;

		BOOL t_Status =	GetVolumeInformation (

			TOBSTRT((LPCWSTR)t_VolumeDevice) ,
			t_VolumeName ,
			sizeof ( t_VolumeName ) / sizeof ( TCHAR ) ,
			& t_VolumeSerialNumber ,
			& t_MaxComponentLength ,
			& t_FileSystemFlags ,
			t_FileSystemName ,
			sizeof ( t_FileSystemName ) / sizeof ( TCHAR )
		) ;

		if ( t_Status )
		{
/*
 * There's a disk in -- set disk-related props
 */
			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , true ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
			{
				a_Instance->SetCharSplat ( IDS_Status , IDS_OK ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_VOLUMENAME )
			{
				a_Instance->SetCharSplat ( IDS_VolumeName , t_VolumeName ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MAXCOMPONENTLENGTH )
			{
				a_Instance->SetDWORD ( IDS_MaximumComponentLength , t_MaxComponentLength ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_FILESYSTEMFLAGS )
			{
				a_Instance->SetDWORD ( IDS_FileSystemFlags , t_FileSystemFlags ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_SERIALNUMBER )
			{
				TCHAR t_SerialNumber [ 9 ] ;

				_stprintf ( t_SerialNumber , _T("%x"), t_VolumeSerialNumber ) ;
				_tcsupr ( t_SerialNumber ) ;

				a_Instance->SetCharSplat ( IDS_VolumeSerialNumber , t_SerialNumber ) ;
			}

/*
 *	See if GetDiskFreeSpaceEx() is supported
 */

			if ( a_SpecifiedProperties & SPECIAL_VOLUMESPACE )
			{
				TCHAR t_TotalBytesString [ _MAX_PATH ];

                CKernel32Api *pKernel32 = (CKernel32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidKernel32Api, NULL);
                if ( pKernel32 != NULL)
				{
					try
					{
						// See if the function is available...
						BOOL fRetval = FALSE;
						if ( pKernel32->GetDiskFreeSpaceEx ( TOBSTRT((LPCWSTR)t_VolumeDevice) , & t_AvailableBytes , & t_TotalBytes , NULL , &fRetval) )
						{   // the function exists.
							if(fRetval)
							{   // and the return value was true.
								_stprintf ( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;
								a_Instance->SetCHString ( IDS_Size , t_TotalBytesString ) ;
								t_SizeFound = TRUE ;
							}
						}
					}
					catch ( ... )
					{
						CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);

						throw ;
					}

					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidKernel32Api, pKernel32);
					pKernel32 = NULL;
				}

		/*
		 *	If we couldn't get extended info -- use old API
		 *  (known to be inaccurate on Win95 for >2G drives)
		 */
				if ( ! t_SizeFound )
				{
					DWORD t_SectorsPerCluster ;
					DWORD t_BytesPerSector ;
					DWORD t_FreeClusters ;
					DWORD t_TotalClusters ;

					t_Status = GetDiskFreeSpace (

						TOBSTRT((LPCWSTR)a_DosDeviceName) ,
						& t_SectorsPerCluster,
						& t_BytesPerSector,
						& t_FreeClusters,
						& t_TotalClusters
					) ;

					if ( t_Status )
					{
						t_TotalBytes.QuadPart = (DWORDLONG) t_BytesPerSector * (DWORDLONG) t_SectorsPerCluster * (DWORDLONG) t_TotalClusters ;
						_stprintf( t_TotalBytesString , _T("%I64d"), t_TotalBytes.QuadPart ) ;

					}
				}
			}
		}
		else
		{
			DWORD t_LastError = GetLastError () ;

			if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
			{
				a_Instance->SetCharSplat ( IDS_Status , IDS_STATUS_Unknown ) ;
			}

			if ( a_SpecifiedProperties & SPECIAL_PROPS_MEDIALOADED )
			{
				a_Instance->Setbool ( IDS_MediaLoaded , false ) ;
			}
		}
	}

	return t_Result ;
}

DWORD CWin32_FloppyDisk :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SCSITargetId ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SCSITARGETID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Drive ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DRIVE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Id ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_ID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Capabilities ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPABILITY ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaType ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIATYPE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MediaLoaded ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MEDIALOADED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_VOLUMENAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_MaximumComponentLength ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MAXCOMPONENTLENGTH ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_FileSystemFlags ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_FILESYSTEMFLAGS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_VolumeSerialNumber ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SERIALNUMBER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Size ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SIZE ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\file.h ===
//=================================================================

//

// File.h -- File property set provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/02/98    a-kevhu         Created
//
//=================================================================

#ifndef _FILE_H
#define _FILE_H 

//NOTE: The implementations of EnumerateInstances, GetObject & the pure virtual declaration of IsOneOfMe  method 
//		is now present in the derived CImplement_LogicalFile class. Cim_LogicalFile is now instantiable & has only 
//		generic method implementations.
#define  PROPSET_NAME_FILE L"CIM_LogicalFile"

class CInputParams ; 

class CCIMLogicalFile : public Provider 
{
    public:

        // Constructor/destructor
        //=======================

        CCIMLogicalFile(LPCWSTR name, LPCWSTR pszNamespace);
       ~CCIMLogicalFile() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L) { return WBEM_E_NOT_AVAILABLE ; }
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, 
                                           long lFlags = 0L) 
		{ return WBEM_E_NOT_AVAILABLE ; }
        
		virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L)
		{ return WBEM_E_NOT_AVAILABLE ; }
		
		virtual HRESULT ExecMethod (const CInstance& rInstance, const BSTR bstrMethodName ,CInstance *pInParams ,CInstance *pOutParams ,long lFlags ) ;
    
	protected:
		
		virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

	private:

		HRESULT ExecDelete(const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;		
		HRESULT ExecCompress (const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecUncompress (const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecTakeOwnership(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod );
		HRESULT ExecChangePermissions(const CInstance& rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecCopy(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags, bool bExtendedMethod ) ;
		HRESULT ExecRename(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags) ;
        HRESULT ExecEffectivePerm(const CInstance &rInstance, CInstance *pInParams, CInstance *pOutParams, long lFlags);
		
		// support functions for checking permission
        HRESULT CheckEffectivePermFileOrDir(const CInstance& rInstance, CInstance *pInParams, CInstance* pOutParams, bool& fHasPerm);
		DWORD EffectivePermFileOrDir(const CInstance& rInstance, const DWORD dwPermToCheck);
        
        //fns to change permissions on file/dir
		HRESULT CheckChangePermissionsOnFileOrDir(const CInstance& rInstance ,CInstance *pInParams ,CInstance *pOutParams ,DWORD &dwStatus, bool bExtendedMethod, CInputParams& InputParams ) ;
 
		//fns. for copying file/dir
		HRESULT CheckCopyFileOrDir( const CInstance& rInstance ,CInstance *pInParams ,CInstance *pOutParams ,DWORD &dwStatus,	bool bExtendedMethod, CInputParams& InputParams ) ;
		DWORD CopyFileOrDir(const CInstance &rInstance, _bstr_t bstrtNewFileName, CInputParams& InputParams );
		

		//fns for renaming file/dir
		HRESULT CheckRenameFileOrDir( const CInstance& rInstance ,CInstance *pInParams ,CInstance *pOutParams ,DWORD &dwStatus );
		DWORD RenameFileOrDir(const CInstance &rInstance, WCHAR* pszNewFileName);
		
		DWORD DoTheRequiredOperation ( bstr_t bstrtFileName, DWORD dwAttrib, CInputParams& InputParams );		

		//wrappers over win32 API
		DWORD Delete(_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams );
		DWORD Compress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams );
		DWORD Uncompress (_bstr_t bstrtFileName, DWORD dwAttributes, CInputParams& InputParams );
		DWORD TakeOwnership( _bstr_t bstrtFileName, CInputParams& InputParams ) ;
		DWORD ChangePermissions(_bstr_t bstrtFileName, DWORD dwOption, PSECURITY_DESCRIPTOR pSD, CInputParams& InputParams );
		DWORD CopyFile(_bstr_t bstrtOriginalFile, DWORD dwFileAttributes, bstr_t bstrtMirror, bstr_t bstrtParentDir, CInputParams& InputParams );

		//helper fns.
		DWORD DoOperationOnFileOrDir(WCHAR *pwcName, CInputParams& InParams );
#ifdef NTONLY
		DWORD EnumAllPathsNT(const WCHAR *pszDrive, const WCHAR *pszPath, CInputParams& InParams );
#endif
#ifdef WIN9XONLY
		DWORD EnumAllPaths95(LPCTSTR pszDrive, LPCTSTR pszPath, CInputParams& InParams );
#endif
	
		//fn to map win32 error to status code
		DWORD GetStatusCode();    
		DWORD MapWinErrorToStatusCode(DWORD dwWinError);
		HRESULT MapStatusCodestoWbemCodes(DWORD dwStatus);
		friend class CInputParams ;

	private:
		enum OperationName  
		{
			ENUM_METHOD_DELETE = 0		,
			ENUM_METHOD_COMPRESS		,
			ENUM_METHOD_TAKEOWNERSHIP	,
			ENUM_METHOD_COPY			,
			ENUM_METHOD_CHANGE_PERM		,
			ENUM_METHOD_UNCOMPRESS
		} ;

};


class CInputParams
{
public:
	
    CInputParams::CInputParams () { pContext = NULL; }
	
	CInputParams::CInputParams 
	( 
		bstr_t bstrtFile,	
		bstr_t bstrtStartFile, 
		DWORD dwInOption,
		PSECURITY_DESCRIPTOR pSecDesc,
		bool bDepthFirst,
		CCIMLogicalFile::OperationName eOperationName,
        MethodContext* pMethodContext = NULL
	) : 
	bstrtFileName ( bstrtFile),
	bstrtStartFileName ( bstrtStartFile ), 
	dwOption ( dwInOption ), 
	pSD ( pSecDesc ),
	bDoDepthFirst ( bDepthFirst ), 
	eOperation (eOperationName ),
    pContext ( pMethodContext)
	{
		//check if we're given a start file to start the operation from
		if ( !bstrtStartFileName )
		{
			bOccursAfterStartFile = true ;
		}
		else
		{
			bOccursAfterStartFile = false ;
		}

		bRecursive = TRUE ;
	}

	void SetValues 
	( 
		bstr_t bstrtFile,	
		DWORD dwInOption,
		PSECURITY_DESCRIPTOR pSecDesc,
		bool bDepthFirst,
		CCIMLogicalFile::OperationName eOperationName,
        MethodContext* pMethodContext = NULL
	)
	{
		bstrtFileName = bstrtFile ;
		dwOption = dwInOption ;
		pSD = pSecDesc ;
		bDoDepthFirst = bDepthFirst ;
		eOperation = eOperationName ;
        pContext = pMethodContext ;

		//check if we're given a start file to start the operation from
		if ( !bstrtStartFileName )
		{
			bOccursAfterStartFile = true ;
		}
		else
		{
			bOccursAfterStartFile = false ;
		}
	}
	
	~CInputParams () {};

	//member variables
public:
	bstr_t bstrtFileName ;		//File or Dir. Name on which operation is to be performed
	bstr_t bstrtStartFileName ;	//file to start the operation from
	bstr_t bstrtErrorFileName ;  //file at which error occured while carrying out the operation
	bstr_t bstrtMirror ;		//The Mirror Dir. used for Copy Operation 
	DWORD dwOption ;			//Option for applying Security descriptor
	PSECURITY_DESCRIPTOR pSD ;	
	bool bDoDepthFirst ;		//flag for doing a depthfirst traversal of Dir. hierarchy
	bool bOccursAfterStartFile ;//Flag which checks if the current file occurs after the StartFile
	CCIMLogicalFile::OperationName eOperation ;	//Opertion type
    MethodContext* pContext;   // context for this operation, may be NULL.  
	bool bRecursive ;

}  ;


#endif // _FILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\floppy.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Floppy.h
//
//  Purpose: Floppy drive property set provider
//
//***************************************************************************

// Property set identification
//============================

typedef BOOL (WINAPI *KERNEL32_DISK_FREESPACEEX) (

		LPCTSTR lpDirectoryName,
        PULARGE_INTEGER lpFreeBytesAvailableToCaller,
        PULARGE_INTEGER lpTotalNumberOfBytes,
        PULARGE_INTEGER lpTotalNumberOfFreeBytes
) ;

// Property set identification
//============================

#define PROPSET_NAME_FLOPPYDISK				L"Win32_FloppyDrive"

#define METHOD_NAME_PROFILEDRIVE		L"ProfileDrive"
#define METHOD_NAME_TESTDRIVEINTEGRITY	L"TestDriveIntegrity"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_TEST_INTEGRITY        0x00000001
#define SPECIAL_PROPS_TEST_TRANSFERRATE     0x00000002
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_SCSITARGETID			0x00000800
#define SPECIAL_PROPS_DRIVE					0x00001000
#define SPECIAL_PROPS_ID					0x00002000
#define SPECIAL_PROPS_CAPABILITY			0x00004000
#define SPECIAL_PROPS_MEDIATYPE				0x00008000
#define SPECIAL_PROPS_VOLUMENAME			0x00010000
#define SPECIAL_PROPS_MAXCOMPONENTLENGTH	0x00020000
#define SPECIAL_PROPS_FILESYSTEMFLAGS		0x00040000
#define SPECIAL_PROPS_SERIALNUMBER			0x00080000
#define SPECIAL_PROPS_SIZE					0x00100000
#define SPECIAL_PROPS_MEDIALOADED			0x00200000
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_MEDIA				( SPECIAL_PROPS_SCSITARGETID | \
									SPECIAL_PROPS_DRIVE | \
									SPECIAL_PROPS_ID | \
									SPECIAL_PROPS_CAPABILITY | \
									SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )

#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER | \
									SPECIAL_MEDIA )

#define SPECIAL_VOLUMEINFORMATION	( SPECIAL_PROPS_MEDIATYPE | \
									SPECIAL_PROPS_VOLUMENAME | \
									SPECIAL_PROPS_MAXCOMPONENTLENGTH | \
									SPECIAL_PROPS_FILESYSTEMFLAGS | \
									SPECIAL_PROPS_SERIALNUMBER | \
									SPECIAL_PROPS_SIZE | \
									SPECIAL_PROPS_MEDIALOADED )
	

#define SPECIAL_VOLUMESPACE			( SPECIAL_PROPS_SIZE )
	
class CWin32_FloppyDisk : public Provider
{
protected:

//		CRITICAL_SECTION m_CriticalSection ;

protected:

        DWORD GetBitMask ( 

            CFrameworkQuery &a_Query 
        );

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

		HRESULT LoadPropertyValues ( 

			CInstance *a_Instance, 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

		HRESULT LoadConfigManagerPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT GetDeviceInformation ( 

			CInstance *a_Instance ,
			CConfigMgrDevice *a_Device , 
			CHString a_DeviceName , 
			CHString &a_DosDeviceName ,
			const TCHAR *a_DosDeviceNameList ,
			DWORD a_SpecifiedPropertied
		) ;

		HRESULT LoadMediaPropertyValues (	

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			const CHString &a_DosDeviceName , 
			DWORD a_SpecifiedPropertied 
		) ;

public:

        // Constructor/destructor
        //=======================

        CWin32_FloppyDisk ( LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
       ~CWin32_FloppyDisk () ;

        // Functions provide properties with current values
        //=================================================

        HRESULT GetObject ( 

			CInstance *a_Instance, 
			long a_Flags,
			CFrameworkQuery &a_Query
		) ;

        HRESULT EnumerateInstances ( 

			MethodContext *a_MethodContext, 
			long a_Flags = 0L 
		) ;

        HRESULT ExecQuery ( 

			MethodContext *a_MethodContext, 
			CFrameworkQuery &a_Query, 
			long a_Flags = 0L
		) ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\floppycontroller.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FloppyController.cpp
//
//  Purpose: Floppy Controller property set provider
//
//***************************************************************************

#include "precomp.h"

#include "FloppyController.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER L"fdc"
//#define CONFIG_MANAGER_CLASS_GUID_FLOPPYCONTROLLER L"{4d36e969-e325-11ce-bfc1-08002be10318}"

CWin32_FloppyController s_FloppyController ( PROPSET_NAME_FLOPPYCONTROLLER , IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::CWin32_FloppyController
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_FloppyController :: CWin32_FloppyController (

	LPCWSTR a_Name ,
	LPCWSTR a_Namespace

) : Provider( a_Name, a_Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::~CWin32_FloppyController
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_FloppyController :: ~CWin32_FloppyController ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyController::GetObject
//
//  Inputs:     CInstance*      a_Instance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyController :: GetObject ( CInstance *a_Instance , long a_Flags , CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;


    // Let's see if config manager recognizes this device at all

    CHString t_DeviceID;
    a_Instance->GetCHString ( IDS_DeviceID , t_DeviceID ) ;

    CConfigManager t_ConfigurationManager ;
    CConfigMgrDevicePtr t_Device;

    if ( t_ConfigurationManager.LocateDevice ( t_DeviceID , &t_Device ) )
    {
        // Ok, it knows about it.  Is it a Floppy controller?
		CHString t_Class;
		if ( t_Device->IsClass ( CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER ) )
		{
			CHString t_Key ;
			a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

            DWORD t_SpecifiedProperties = GetBitMask( a_Query );
			t_Result = LoadPropertyValues ( a_Instance , t_Device , t_Key , t_SpecifiedProperties ) ;
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_FloppyController::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_FloppyController :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result ;
	t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyController :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask( a_Query );
//	if ( t_SpecifiedProperties )
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

HRESULT CWin32_FloppyController :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report InfraRed info if we do it this way.

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
            CConfigMgrDevicePtr t_Device;

            t_Result = WBEM_S_NO_ERROR ;

            // Walk the list
            for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ));
                SUCCEEDED( t_Result ) && (t_Device != NULL);
                t_Device.Attach(t_DeviceList.GetNext ( t_Position )))
            {
				// Now to find out if this is the floppy controller

				CHString t_Key ;
				if ( t_Device->GetDeviceID ( t_Key ) )
				{
					CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false);
					if ( ( t_Result = LoadPropertyValues ( t_Instance , t_Device , t_Key , a_SpecifiedProperties ) ) == WBEM_S_NO_ERROR )
					{
						t_Result = t_Instance->Commit (  ) ;
					}
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            t_DeviceList.EndEnum () ;
        }
    }

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* a_Instance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_FloppyController :: LoadPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & SPECIAL_PROPS_STATUS )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				a_Instance->SetCHString ( IDS_Status , t_sStatus ) ;
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported , 2 ) ;
	}

    return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_FloppyController::IsInfraRedController
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of InfraRed device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid InfraRed class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CWin32_FloppyController :: IsFloppyController ( CConfigMgrDevice *a_Device )
{
    BOOL t_Status = FALSE ;

    if ( a_Device )
    {
        // Now to find out if this is the floppy controller
		t_Status = a_Device->IsClass ( CONFIG_MANAGER_CLASS_FLOPPYCONTROLLER ) ;
    }

    return t_Status ;
}


DWORD CWin32_FloppyController :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    return t_SpecifiedProperties;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\group.cpp ===
//=================================================================

//

// Group.CPP -- Group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//
//
//=================================================================

#include "precomp.h"

#include "wbemnetapi32.h"
#include <lmwksta.h>
#include <comdef.h>

#include "sid.h"
#include "Group.h"
#include <vector>
#include <frqueryex.h>

//////////////////////////////////////////////////////////////////////

// Property set declaration
//=========================

CWin32GroupAccount   Win32GroupAccount( PROPSET_NAME_GROUP, IDS_CimWin32Namespace );

class ProviderImpersonationRevert
{
	HANDLE hThreadToken;

	BOOL bImpersonated;
	BOOL bReverted;

	public:

	ProviderImpersonationRevert () :
		hThreadToken ( INVALID_HANDLE_VALUE ),
		bImpersonated ( TRUE ),
		bReverted ( FALSE )
	{
		if ( OpenThreadToken	(
									GetCurrentThread(),
									TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
									TRUE,
									&hThreadToken
								)
		   ) 
		{
			if ( RevertToSelf() )
			{
				bReverted = TRUE;
			}
			else
			{
				#if DBG == 1
				// for testing purpose I will let process break
				::DebugBreak();
				#endif
			}
		}
		else
		{
			DWORD dwError = ::GetLastError ();
			if ( ERROR_ACCESS_DENIED == dwError )
			{
				#if DBG == 1
				// for testing purpose I will let process break
				::DebugBreak();
				#endif
			}
			else if ( ERROR_NO_TOKEN == dwError || ERROR_NO_IMPERSONATION_TOKEN == dwError )
			{
				bImpersonated = FALSE;
			}
		}
	}

	~ProviderImpersonationRevert ()
	{
		// impersonate back (if not already)
		Impersonate ();

		if ( hThreadToken != INVALID_HANDLE_VALUE )
		{
			CloseHandle(hThreadToken);
			hThreadToken = INVALID_HANDLE_VALUE;
		}
	}

	BOOL Reverted ()
	{
		return ( bImpersonated && bReverted );
	}

	BOOL Impersonate ()
	{
		if ( Reverted () )
		{
			if ( ! ImpersonateLoggedOnUser ( hThreadToken ) )
			{
				#if DBG == 1
				// for testing purpose I will let process break
				::DebugBreak();
				#endif

				// we need to throw here to avoid running as process
				throw CFramework_Exception( L"ImpersonateLoggedOnUser failed", HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ;

			}
			else
			{
				bReverted = FALSE;
			}
		}

		return !bReverted;
	}
};

BOOL ProviderGetComputerName ( LPWSTR lpwcsBuffer, LPDWORD nSize )
{
	BOOL bResult = FALSE;
    if ( ( bResult = GetComputerNameW(lpwcsBuffer, nSize) ) == FALSE )
	{
		DWORD dwError = ::GetLastError ();
		if ( ERROR_ACCESS_DENIED == dwError )
		{
			// The GetComputer will need to be called in the process's context.
			ProviderImpersonationRevert ir;

			if ( ir.Reverted () )
			{
				bResult = GetComputerNameW(lpwcsBuffer, nSize);
			}
			else
			{
				// I was not impersonated or revert failed
				// that means call GetComputerName failed with process credentials already
				// or will fail as I'm not reverted

				::SetLastError ( dwError );
			}
		}
	}

	return bResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::CWin32GroupAccount
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *                LPCTSTR pszNamespace - Namespace for class
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32GroupAccount::CWin32GroupAccount(LPCWSTR strName, LPCWSTR pszNamespace /*=NULL*/ )
:  Provider( strName, pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::~CWin32GroupAccount
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32GroupAccount::~CWin32GroupAccount()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::ExecQuery
 *
 *  DESCRIPTION : Query support
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32GroupAccount::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
   HRESULT  hr = WBEM_S_NO_ERROR;

#ifdef NTONLY
   {
	   //CHStringArray acsDomains;
	   std::vector<_bstr_t> vectorDomains;
       std::vector<_bstr_t> vectorNames;
       std::vector<_variant_t> vectorLocalAccount;
	   DWORD dwDomains, x, dwNames;
       CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
        bool fLocalAccountPropertySpecified = false;
        bool fLocalAccount = false;

	   pQuery.GetValuesForProp(L"Domain", vectorDomains);
       pQuery.GetValuesForProp(L"Name", vectorNames);
	   dwDomains = vectorDomains.size();
       dwNames = vectorNames.size();
       pQuery2->GetValuesForProp(IDS_LocalAccount, vectorLocalAccount);
       // See if only local accounts requested
       if(vectorLocalAccount.size() > 0)
       {
           fLocalAccountPropertySpecified = true;
           // use variant_t's bool extractor...
           fLocalAccount = vectorLocalAccount[0];
       }

       if(dwDomains == 0 && dwNames >= 1)
       {
           // We were given one or more names, but no domain, so we need
           // to look for those groups on all domains...

           // For the local case, there won't be many groups,
           // so enumerate them...
           CNetAPI32 NetAPI;
           if(NetAPI.Init() == ERROR_SUCCESS)
           {
               GetLocalGroupsNT(NetAPI, pMethodContext);

               if(!(fLocalAccountPropertySpecified && fLocalAccount))
               {
                   // Now try to find the specified group on all
                   // trusted domains...
                   // Get all the domains related to this one (plus this one)
                   std::vector<_bstr_t> vectorTrustList;
                   NetAPI.GetTrustedDomainsNT(vectorTrustList);
                   WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1] = { L'\0' };
                   DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
         
                   if(ProviderGetComputerName(
                      wstrLocalComputerName,
                      &dwNameSize))
                   {
                       for(long z = 0L;
                           z < vectorNames.size();
                           z++)
                       {
                           // For each domain, try to find  the Groups
		                   bool fDone = false;
                           for(LONG m = 0L; 
                               m < vectorTrustList.size() && SUCCEEDED(hr) && !fDone; 
                               m++)
                           {
                               CInstancePtr pInstance = NULL;
                               pInstance.Attach(CreateNewInstance(pMethodContext));
	    			             if(pInstance != NULL)
                               {
                                   pInstance->SetWCHARSplat(IDS_Domain, vectorTrustList[m]);
                                   pInstance->SetWCHARSplat(IDS_Name, vectorNames[z]);
                             
                                   if((_wcsicmp((WCHAR*)vectorTrustList[m],
                                       wstrLocalComputerName) != 0) || 
                                        (NetAPI.IsDomainController(NULL)) ) 
                                   {
  				                       if(WBEM_S_NO_ERROR == GetSingleGroupNT(pInstance))
                                       {
                                           hr = pInstance->Commit();
                                       }                                         
                                   }
                               }
                           }
                       }
                   }
                }
           }
       }
       else if ((dwDomains == 0 && dwNames == 0))
	   {
           if(fLocalAccountPropertySpecified)
           {
               if(!fLocalAccount)
               {
                   hr = EnumerateInstances(pMethodContext);
               }
               else
               {
					CNetAPI32 NetAPI ;
		          // Get NETAPI32.DLL entry points
		          //==============================
					if(NetAPI.Init() == ERROR_SUCCESS)
					{
						hr = GetLocalGroupsNT(NetAPI, pMethodContext);
                  }
               }
           }
           else
           {
                hr = EnumerateInstances(pMethodContext);
           }
	   }
	   else  // Domain(s) specified...
	   {
		  CNetAPI32 NetAPI ;
		  // Get NETAPI32.DLL entry points
		  //==============================
		  if( NetAPI.Init() == ERROR_SUCCESS )
		  {
			 WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
			 DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
			 ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

			if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
			{
				if ( ERROR_ACCESS_DENIED == ::GetLastError () )
				{
					return WBEM_E_ACCESS_DENIED;
				}
				else
				{
					return WBEM_E_FAILED;
				}
			}

             // If we given both name and domain, just find the one instance
             // specified
             if(dwDomains == 1 && dwNames ==1)
             {
                // Use our GetSingleGroupNT function to get info on
                // the one instance requested.
                CInstancePtr pInstance = NULL;
                pInstance.Attach(CreateNewInstance(pMethodContext));
				if(pInstance != NULL)
                {
                    pInstance->SetWCHARSplat(IDS_Domain, vectorDomains[0]);
                    pInstance->SetWCHARSplat(IDS_Name, vectorNames[0]);
                    hr = GetSingleGroupNT(pInstance);
                    if(WBEM_S_NO_ERROR == hr)
                    {
                        hr = pInstance->Commit();   
                    }
                }
             }
             else   
             {
				CHString chstrBuiltIn;
    
				if(GetLocalizedBuiltInString(chstrBuiltIn))
				{
					 // We were given more than one name and one domain,
					 // so we have to enumerate groups by domain (since
					 // we can't match up requested domain-name pairs).
					 // For all the paths, get the info
					 if(fLocalAccountPropertySpecified)
					 {
							if(fLocalAccount)
							{
								hr = GetLocalGroupsNT( NetAPI, pMethodContext ); 
							}
							else
							{
								for(x=0; 
									x < dwDomains && SUCCEEDED(hr); 
									x++)
								{
									if((_wcsicmp((WCHAR*)vectorDomains[x], wstrLocalComputerName) != 0) && 
									   (_wcsicmp((WCHAR*)vectorDomains[x], chstrBuiltIn) != 0))
									{
										hr = GetLocalGroupsNT( NetAPI, pMethodContext,vectorDomains[x] ); 
										if ( SUCCEEDED ( hr ) )
										{
											hr = GetDomainGroupsNT( NetAPI, vectorDomains[x], pMethodContext );
										}
									}
								}
							}
					 }
					 else
					 {
						 for(x=0; 
							 x < dwDomains && SUCCEEDED(hr); 
							 x++)
						 {
#if 1
							 if ((_wcsicmp((WCHAR*)vectorDomains[x],wstrLocalComputerName) == 0) || (_wcsicmp((WCHAR*)vectorDomains[x],chstrBuiltIn) == 0))
							 {
								 hr = GetLocalGroupsNT( NetAPI, pMethodContext );
							 }
							 else
							 {
								hr = GetLocalGroupsNT( NetAPI, pMethodContext,vectorDomains[x] );
								if ( SUCCEEDED ( hr ) ) 
								{
									hr = GetDomainGroupsNT( NetAPI, vectorDomains[x], pMethodContext );
								}
							 }
#else
							 if ((_wcsicmp((WCHAR*)vectorDomains[x],wstrLocalComputerName) == 0) || (_wcsicmp((WCHAR*)vectorDomains[x],chstrBuiltIn) == 0))
							 {
								 hr = GetLocalGroupsNT( NetAPI, pMethodContext );
							 }
							 else
							 {
								 hr = GetDomainGroupsNT( NetAPI, vectorDomains[x], pMethodContext );
							 }
#endif
						 }
					 }
				}
             }
		  }
	   }
   }
#endif
   return WBEM_S_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetObject
//
// Inputs:     CInstance*     pInstance - Instance into which we
//                               retrieve data.
//
// Outputs: None.
//
// Returns: HRESULT        Success/Failure code.
//
// Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32GroupAccount::GetObject( CInstance* pInstance, long lFlags /*= 0L*/ )
{
   HRESULT hRes = WBEM_E_NOT_FOUND;

   // Find the instance depending on platform id.

#ifdef NTONLY
      hRes = RefreshInstanceNT( pInstance );
#endif
#ifdef WIN9XONLY
      hRes = RefreshInstanceWin95( pInstance );
#endif

   return hRes;
}

////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::EnumerateInstances
//
// Inputs:     MethodContext* pMethodContext - Context to enum
//                      instance data in.
//
// Outputs: None.
//
// Returns: HRESULT        Success/Failure code.
//
// Comments:      None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32GroupAccount::EnumerateInstances( MethodContext* pMethodContext, long lFlags /*= 0L*/ )
{
   BOOL     fReturn     =  FALSE;
   HRESULT     hr       =  WBEM_S_NO_ERROR;

   // Get the proper OS dependent instance

#ifdef NTONLY
      hr = AddDynamicInstancesNT( pMethodContext );
#endif
#ifdef WIN9XONLY
      hr = AddDynamicInstancesWin95( pMethodContext );
#endif

   return WBEM_S_NO_ERROR;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::ExecMethod
 *
 *  DESCRIPTION : Executes a method
 *
 *  INPUTS      : Instance to execute against, method name, input parms instance
 *                Output parms instance.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY

HRESULT CWin32GroupAccount::ExecMethod(

const CInstance &a_rInst,
const BSTR a_MethodName,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	if ( !a_pOutParams )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Method recognized?
	if( !_wcsicmp ( a_MethodName, METHOD_NAME_Rename ) )
	{
		return hRenameGroup( (CInstance*)&a_rInst, a_pInParams, a_pOutParams, a_Flags ) ;
	}

	return WBEM_E_INVALID_METHOD ;
}

#endif

/*******************************************************************
    NAME:       hRenameGroup

    SYNOPSIS:   Sets a new group name for this instance.
				A method is required here since we are changing the key
				on the instance.

    ENTRY:      const CInstance &a_rInst,
				CInstance *a_pInParams,
				CInstance *a_pOutParams,
				long a_Flags	:

	NOTES:		This is a non static, instance dependent method call

    HISTORY:
********************************************************************/
#ifdef NTONLY

HRESULT CWin32GroupAccount::hRenameGroup(

CInstance *a_pInst,
CInstance *a_pInParams,
CInstance *a_pOutParams,
long a_Flags )
{
	E_MethodResult	t_eResult = e_InstanceNotFound ;
	CHString	t_chsGroupName ;
	CHString	t_chsDomainName ;
	CHString	t_chsNewGroupName ;

	if( !a_pOutParams )
	{
		return WBEM_E_FAILED ;
	}

	if( !a_pInParams )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_InternalError ) ;
		return S_OK ;
	}

	// nonstatic method requires an instance
	if( !a_pInst )
	{
		a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, e_NoInstance ) ;
		return S_OK ;
	}

	// keys
	if( !a_pInst->IsNull( IDS_Name ) && !a_pInst->IsNull( IDS_Domain ) )
	{
		// Name
		if( a_pInst->GetCHString( IDS_Name , t_chsGroupName ) )
		{
			// Domain
			if( a_pInst->GetCHString( IDS_Domain, t_chsDomainName ) )
			{
				// New Group name
				if( !a_pInParams->IsNull( IDS_Name ) &&
					a_pInParams->GetCHString( IDS_Name, t_chsNewGroupName ) )
				{
					t_eResult = e_Success ;
				}
				else
				{
					t_eResult = e_InvalidParameter ;
				}
			}
		}
	}

	// proceed with the update...
	if( e_Success == t_eResult )
	{
		if( t_chsNewGroupName != t_chsGroupName )
		{
			CNetAPI32	t_NetAPI;

			if ( ERROR_SUCCESS == t_NetAPI.Init () )
			{
				DWORD t_ParmError = 0 ;
				NET_API_STATUS t_Status = 0 ;
				GROUP_INFO_0 t_GroupInfo_0 ;
				t_GroupInfo_0.grpi0_name  = (LPWSTR)(LPCWSTR)t_chsNewGroupName ;

				WCHAR t_wstrLocalComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ] ;
				DWORD t_dwNameSize = MAX_COMPUTERNAME_LENGTH + 1 ;
				ZeroMemory( t_wstrLocalComputerName, sizeof( t_wstrLocalComputerName ) ) ;

				if(ProviderGetComputerName( t_wstrLocalComputerName, &t_dwNameSize ) )
				{
					if( t_chsDomainName.CompareNoCase( t_wstrLocalComputerName ) )
					{
						// Changes for local group
						t_Status = t_NetAPI.NetGroupSetInfo(
															(LPCWSTR)t_chsDomainName,
															(LPCWSTR)t_chsGroupName,
															0,
															(LPBYTE) &t_GroupInfo_0,
															&t_ParmError
															) ;


						if ( NERR_GroupNotFound == t_Status )
						{
							t_Status = t_NetAPI.NetLocalGroupSetInfo(
																t_chsDomainName,
																(LPCWSTR)t_chsGroupName,
																0,
																(LPBYTE) &t_GroupInfo_0,
																&t_ParmError
																) ;
						}
					}
					else
					{
						t_Status = t_NetAPI.NetLocalGroupSetInfo(
															NULL,
															(LPCWSTR)t_chsGroupName,
															0,
															(LPBYTE) &t_GroupInfo_0,
															&t_ParmError
															) ;
					}

					switch( t_Status )
					{
						case NERR_Success:			t_eResult = e_Success ;			break ;
						case NERR_GroupNotFound:	t_eResult = e_GroupNotFound ;	break ;
						case NERR_InvalidComputer:	t_eResult = e_InvalidComputer ;	break ;
						case NERR_NotPrimary:		t_eResult = e_NotPrimary ;		break ;
						case NERR_SpeGroupOp:		t_eResult = e_SpeGroupOp ;		break ;
						default:					t_eResult = e_ApiError;			break ;
					}
				}
				else
				{
					t_eResult =  e_InternalError;
				}
			}
		}
	}

	a_pOutParams->SetDWORD( METHOD_ARG_NAME_METHODRESULT, t_eResult ) ;
	return S_OK ;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::AddDynamicInstancesNT
 *
 *  DESCRIPTION : Creates instance for all known local Groups (NT)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada, nichts, niente
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32GroupAccount::AddDynamicInstancesNT( MethodContext* pMethodContext )
{
   HRESULT  hr = WBEM_S_NO_ERROR;
   CNetAPI32 NetAPI ;

   // Get NETAPI32.DLL entry points
   //==============================

   if( NetAPI.Init() == ERROR_SUCCESS )
   {
      // Get the local groups first
      hr = GetLocalGroupsNT( NetAPI, pMethodContext );
      if (SUCCEEDED(hr))
      {
         // Get all the domains related to this one (plus this one)
         //CHStringArray achsTrustList;
         std::vector<_bstr_t> vectorTrustList;
         NetAPI.GetTrustedDomainsNT(vectorTrustList);
         WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
         DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
         ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

		if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
		{
			if ( ERROR_ACCESS_DENIED == ::GetLastError () )
			{
				return WBEM_E_ACCESS_DENIED;
			}
			else
			{
				return WBEM_E_FAILED;
			}
		}

         // For each domain, get the Groups
         //for (int x=0; (x < achsTrustList.GetSize()) && (SUCCEEDED(hr)) ; x++)
         //while(stackTrustList.size() > 0 && (SUCCEEDED(hr)))
		 for(LONG m = 0L; m < vectorTrustList.size(); m++)
         {
             if ( (_wcsicmp((WCHAR*)vectorTrustList[m],wstrLocalComputerName) != 0) ||
                  (NetAPI.IsDomainController(NULL)) )
             {
				hr = GetLocalGroupsNT( NetAPI, pMethodContext , vectorTrustList[m] );
				if ( SUCCEEDED ( hr ) )
				{
					//hr = GetDomainGroupsNT( NetAPI, (WCHAR*)stackTrustList.top(), pMethodContext );
					hr = GetDomainGroupsNT( NetAPI, (WCHAR*)vectorTrustList[m], pMethodContext );
				}

                if (hr == WBEM_E_CALL_CANCELLED)
                {
                    break;
                }
             }
         }
      }
   }
   return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceNT
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32GroupAccount::RefreshInstanceNT( CInstance* pInstance )
{
	HRESULT hRetCode = GetSingleGroupNT(pInstance );
	if ( SUCCEEDED (hRetCode) )
	{
		if ( WBEM_S_NO_ERROR != hRetCode )
		{
			return WBEM_E_NOT_FOUND ;
		}
	}

	return hRetCode ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupAccount::EnumerateGroupsWin95
 *
 *  DESCRIPTION : Creates instance for all known local Groups (Win95)
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    : No groups on win95
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32GroupAccount::AddDynamicInstancesWin95( MethodContext* pMethodContext )
{
   return WBEM_S_NO_ERROR;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : RefreshInstanceWin95
 *
 *  DESCRIPTION : Loads property values according to key value set by framework
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    : No groups on win95
 *
 *****************************************************************************/

#ifdef WIN9XONLY
HRESULT CWin32GroupAccount::RefreshInstanceWin95( CInstance* pInstance )
{
   return WBEM_S_NO_ERROR;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetDomainGroupsNT
//
// Obtains Group Names for all Groups in the specified domain.  If no
// domain is specified, then we assume the local machine.
//
// Inputs:     CNetAPI32      netapi - network api functions.
//          LPCTSTR        pszDomain - Domain to retrieve Groups from.
//          MethodContext* pMethodContext - Method Context
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32GroupAccount::GetDomainGroupsNT( CNetAPI32& netapi, LPCWSTR wstrDomain, MethodContext* pMethodContext )
{
   BOOL fGotDC   = TRUE;
   CHString chstrDCName;
   NET_DISPLAY_GROUP *pDomainGroupData = NULL;
   //CHString strComputerName;
   DWORD i;
   HRESULT hr = WBEM_S_NO_ERROR;
   bool fLookupSidLocally = true;

   // When the computer name is the same as the domain name, that's the local accounts
   //strComputerName = GetLocalComputerName();
   WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
   DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
   ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

	if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError () )
		{
			return WBEM_E_ACCESS_DENIED;
		}
		else
		{
			return WBEM_E_FAILED;
		}
	}

   if (wcscmp(wstrLocalComputerName, wstrDomain) != 0)
   {
      fGotDC = (netapi.GetDCName( wstrDomain, chstrDCName ) == ERROR_SUCCESS);
      fLookupSidLocally = false;
   }


   try
   {
	   if ( fGotDC )
	   {

		  DWORD       dwNumReturnedEntries = 0,
			 dwIndex = 0;
		  NET_API_STATUS stat;
		  CInstancePtr pInstance ;

		  // Global groups
		  //==============
		  dwIndex = 0;

		  do {

			 // Get a bunch of groups at once
			 stat = netapi.NetQueryDisplayInformation(_bstr_t((LPCWSTR)chstrDCName),
				3,
				dwIndex,
				16384,
				256000,
				&dwNumReturnedEntries,
				(PVOID*) &pDomainGroupData) ;

			 if (stat != NERR_Success && stat != ERROR_MORE_DATA)
				{
					if (stat == ERROR_ACCESS_DENIED)
						return WBEM_E_ACCESS_DENIED;
					else if (stat == ERROR_NO_SUCH_ALIAS)
						return WBEM_E_NOT_FOUND;
					else
						return WBEM_E_FAILED;
			 }

			 // Make instances for all the returned groups
			 for(i = 0 ; (i < dwNumReturnedEntries) && (SUCCEEDED(hr)) ; i++)
			 {
				pInstance.Attach ( CreateNewInstance(pMethodContext) ) ;
				if ( pInstance != NULL )
				{
					bool t_Resolved = GetSIDInformationW (
						
						wstrDomain,
                        pDomainGroupData[i].grpi3_name,
                        fLookupSidLocally ? wstrLocalComputerName : chstrDCName,
                        pInstance,
						false
					);
                    
					if ( t_Resolved )
					{
						pInstance->SetWCHARSplat(IDS_Description, pDomainGroupData[i].grpi3_comment);
						pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
						pInstance->Setbool(L"LocalAccount", false);

						hr = pInstance->Commit () ;
					}
				}
			 }

			 // The index for continuing the search is stored in the last entry
			 if ( dwNumReturnedEntries != 0 ) {
				dwIndex = pDomainGroupData[dwNumReturnedEntries-1].grpi3_next_index;
			 }
		  } while ((stat == ERROR_MORE_DATA) && (hr != WBEM_E_CALL_CANCELLED)) ;

	   }  // IF fGotDC
   }
   catch ( ... )
   {
		if ( pDomainGroupData )
		{
			netapi.NetApiBufferFree ( pDomainGroupData ) ;
			pDomainGroupData = NULL ;
		}

		throw ;
   }

	if ( pDomainGroupData )
	{
		netapi.NetApiBufferFree ( pDomainGroupData ) ;
		pDomainGroupData = NULL ;
	}

  return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetSingleGroupNT
//
// Obtains the Group name from the specified domain (which can be the
// local workstation)
//
// Inputs:     CNetAPI32      netapi - network api functions.
//          CInstance*     pInstance - Instance to get.
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:   No special access is necessary here.  We just need to make sure
//          we are able to get the appropriate domain controller.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32GroupAccount::GetSingleGroupNT(CInstance* pInstance )
{
	HRESULT     hReturn = WBEM_E_NOT_FOUND;
	CHString    chstrDCName;
	//CHString strDomainName,
    //  strGroupName,
    //  strComputerName;
    WCHAR* wstrDomainName = NULL;
    WCHAR* wstrGroupName = NULL;
    //WCHAR wstrComputerName[_MAX_PATH];

	CNetAPI32 netapi;

    //ZeroMemory(wstrComputerName,sizeof(wstrComputerName));

    WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
    ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

	if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
	{
		if ( ERROR_ACCESS_DENIED == ::GetLastError () )
		{
			return WBEM_E_ACCESS_DENIED;
		}
		else
		{
			return WBEM_E_FAILED;
		}
	}

    _bstr_t bstrtDomainName ;
	pInstance->GetWCHAR( IDS_Domain, &wstrDomainName );

    try
    {
	    bstrtDomainName = wstrDomainName;
    }
    catch ( ... )
    {
        free (wstrDomainName);
        throw ;
    }
    free (wstrDomainName);
    wstrDomainName = NULL;

    _bstr_t bstrtGroupName;
	pInstance->GetWCHAR( IDS_Name, &wstrGroupName );

    try
    {
	    bstrtGroupName = wstrGroupName;
    }
    catch ( ... )
    {
        free(wstrGroupName);
        throw ;
    }
    free(wstrGroupName);
    wstrGroupName = NULL;

	if ((!bstrtDomainName || !bstrtGroupName))
    {
		//hReturn = WBEM_E_INVALID_OBJECT_PATH; // domain name can be empty, as in the case of the Everyone group, and other well known RIDs, which systemaccount will pick up, so report back not found from this routine, not invalid object path.
        hReturn = WBEM_E_NOT_FOUND;
    }
    if (wcslen(bstrtDomainName)==0 || wcslen(bstrtGroupName)==0)
    {
		//hReturn = WBEM_E_INVALID_OBJECT_PATH; // domain name can be empty, as in the case of the Everyone group, and other well known RIDs, which systemaccount will pick up, so report back not found from this routine, not invalid object path.
        hReturn = WBEM_E_NOT_FOUND;
    }
	else if (netapi.Init() != ERROR_SUCCESS)
    {
		hReturn = WBEM_E_FAILED;
    }
	else // everything is in order, let's go!
	{
        // See if we want local or domain accounts
        if(_wcsicmp(bstrtDomainName,wstrLocalComputerName)!=0)
        {
		    // We have either a remote group , or an NT well-known-group (local).
            // Get the domain controller name; if that fails, we will see if it is a well-known-group...
            CHString chstrNTAUTHORITY;
			CHString chstrBuiltIn;
    
            if(!GetLocalizedNTAuthorityString(chstrNTAUTHORITY) || !GetLocalizedBuiltInString(chstrBuiltIn))
            {
                hReturn = WBEM_E_FAILED;
            }
            else
            {
		        if((_wcsicmp(bstrtDomainName, chstrBuiltIn) != 0)  &&
                    (_wcsicmp(bstrtDomainName, (LPCWSTR)chstrNTAUTHORITY) != 0)
                    && (netapi.GetDCName( bstrtDomainName, chstrDCName ) == ERROR_SUCCESS))
		        {
                    pInstance->Setbool(L"LocalAccount", false);

			        GROUP_INFO_1*  pGroupInfo = NULL ;
				    try
				    {
						// Add LocalGroup check
					    if ( ERROR_SUCCESS == netapi.NetGroupGetInfo( chstrDCName, bstrtGroupName, 1, (LPBYTE*) &pGroupInfo ) )
					    {
						    // Not much to get, but we got it
                            bool t_Resolved = GetSIDInformationW(
								
								bstrtDomainName, 
								bstrtGroupName, 
								chstrDCName, 
								pInstance,
								false 
							);

							if ( t_Resolved )
							{
								pInstance->SetWCHARSplat(IDS_Description, pGroupInfo->grpi1_comment);
								pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
								hReturn = WBEM_S_NO_ERROR;

							}
							else
							{
							    hReturn = WBEM_S_FALSE;
							}
					    }
						else
						{
							LOCALGROUP_INFO_1 *pLocalGroupInfo = NULL ;
							if ( ERROR_SUCCESS == netapi.NetLocalGroupGetInfo(chstrDCName,bstrtGroupName,1, (LPBYTE*)& pLocalGroupInfo) )
							{
								try
								{
									bool t_Resolved = GetSIDInformationW (
										
										bstrtDomainName, 
										bstrtGroupName, 
										chstrDCName, 
										pInstance,
										false 
									);

									if ( t_Resolved )
									{
										pInstance->SetWCHARSplat(IDS_Description, pLocalGroupInfo->lgrpi1_comment);
										pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
										hReturn = WBEM_S_NO_ERROR;
									}
									else
									{
										hReturn = WBEM_S_FALSE;
									}
								}
								catch ( ... )
								{
									if ( pLocalGroupInfo )
									{
										netapi.NetApiBufferFree( pLocalGroupInfo);
										pLocalGroupInfo = NULL ;
									}

									throw ;
								}

								netapi.NetApiBufferFree( pLocalGroupInfo);
								pLocalGroupInfo = NULL ;
							}
						}
				    }
				    catch ( ... )
				    {
					    if ( pGroupInfo )
					    {
						    netapi.NetApiBufferFree( pGroupInfo);
						    pGroupInfo = NULL ;
					    }

					    throw ;
				    }

				    // Free the buffer
				    netapi.NetApiBufferFree( pGroupInfo);
				    pGroupInfo = NULL ;

                }
                else
                {
                    // We may have a well known group (e.g., "NT AUTHORITY").  Check if we do...
                    // Commented out because Win32_Account and its children don't
                    // refer to well known groups with the domain being anything other
                    // than the machine name (when Win32_Account is enumerated, these
                    // accounts show up under Win32_SystemAccount - this class doesn't
                    // return them - and Win32_SystemAccount specifies the domain as
                    // the local machine name).
                    /*
                    CSid sid((LPCWSTR)bstrtDomainName, (LPCWSTR)bstrtGroupName, NULL);
                    if (sid.IsValid() && sid.IsOK())
                    {
                        SID_NAME_USE snu = sid.GetAccountType();
                        if(snu == SidTypeAlias)
                        {
                            // In order to properly set the description, we need to get local group
                            // info on this group.
                            LOCALGROUP_INFO_1	*pLocalGroupInfo = NULL ;
			                NET_API_STATUS		stat;

			                if (ERROR_SUCCESS == (stat = netapi.NetLocalGroupGetInfo(NULL,
				                bstrtGroupName, 1, (LPBYTE*) &pLocalGroupInfo)))
			                {
                                pInstance->SetWCHARSplat(IDS_Description, pLocalGroupInfo->lgrpi1_comment);
					            pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
                                pInstance->SetWCHARSplat(IDS_SID, sid.GetSidStringW());
                                pInstance->SetByte(IDS_SIDType, sid.GetAccountType());
                                pInstance->Setbool(L"LocalAccount", true);
                                // Because we didn't call GetSidInformation (didn't need to), we do still
                                // need to set the caption in this case...
                                _bstr_t bstrtCaption(bstrtDomainName);
                                bstrtCaption += L"\\";
                                bstrtCaption += bstrtGroupName;
                                pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
                                hReturn = WBEM_S_NO_ERROR;
                            }
                        }
                        else if(snu == SidTypeWellKnownGroup)
                        {
                            pInstance->SetWCHARSplat(IDS_Description, L"Well known group");
					        pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
                            pInstance->SetWCHARSplat(IDS_SID, sid.GetSidStringW());
                            pInstance->SetByte(IDS_SIDType, sid.GetAccountType());
                            pInstance->Setbool(L"LocalAccount", true);
                            // Because we didn't call GetSidInformation (didn't need to), we do still
                            // need to set the caption in this case...
                            _bstr_t bstrtCaption(bstrtDomainName);
                            bstrtCaption += L"\\";
                            bstrtCaption += bstrtGroupName;
                            pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
                            hReturn = WBEM_S_NO_ERROR;
                        }
                    }*/
                }
            }
        }
		else
		{
            pInstance->Setbool(L"LocalAccount", true);

            LOCALGROUP_INFO_1	*pLocalGroupInfo = NULL ;
			NET_API_STATUS		stat;

			if (ERROR_SUCCESS == (stat = netapi.NetLocalGroupGetInfo(NULL,
				bstrtGroupName, 1, (LPBYTE*) &pLocalGroupInfo)))
			{
				try
				{
				    GetSIDInformationW (
						
						wstrLocalComputerName, 
						bstrtGroupName, 
						wstrLocalComputerName, 
						pInstance,
						true
					);

					pInstance->SetWCHARSplat(IDS_Description, pLocalGroupInfo->lgrpi1_comment);
					pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
                    hReturn = WBEM_S_NO_ERROR;
				}
				catch ( ... )
				{
					if ( pLocalGroupInfo )
					{
						netapi.NetApiBufferFree ( pLocalGroupInfo );
						pLocalGroupInfo = NULL ;
					}
					throw ;
				}

				netapi.NetApiBufferFree( pLocalGroupInfo);
				pLocalGroupInfo = NULL ;
			}
			else
			{
                if (stat == ERROR_NO_SUCH_ALIAS || stat == NERR_GroupNotFound)
					hReturn = WBEM_E_NOT_FOUND;
				else
					hReturn = WinErrorToWBEMhResult(stat);
			}
		}
	}
	return hReturn;
}
#endif



/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetSIDInformation
//
// Obtains the SID Information for the group.
//
// Inputs:     CHString&      strDomainName - Domain Name.
//          CHString&      strAccountName - Account Name
//          CHString&      strComputerName - Computer Name
//          CInstance*     pInstance - Instance to put values in.
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:   Call for valid groups to get SID data.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CWin32GroupAccount::GetSIDInformationW(const LPCWSTR wstrDomainName,
                                            const LPCWSTR wstrAccountName,
                                            const LPCWSTR wstrComputerName,
                                            CInstance* pInstance,
											bool a_Local
											)
{
    BOOL  fReturn = FALSE;
    bool fDomainIsBuiltin = false;

    // Ignore Domain if it's the local machine.
    // Make sure we got the SID and it's all okey dokey
    if(wstrDomainName != NULL)
    {
       CSid  sid( wstrDomainName, wstrAccountName, wstrComputerName);

       // If that didn't work, see if this is a built-in account
       if (sid.GetError() == ERROR_NONE_MAPPED)
       {
			CHString chstrBuiltIn;

			if (GetLocalizedBuiltInString(chstrBuiltIn))
			{
				sid = CSid(chstrBuiltIn, wstrAccountName, wstrComputerName);
				if (sid.IsValid() && sid.IsOK())
				{
					fDomainIsBuiltin = true;
				}
			}

       }

       // barring that, try it without specifying the domain (let the os find it)...
       if (sid.GetError() == ERROR_NONE_MAPPED)
       {
            sid = CSid(NULL, wstrAccountName, wstrComputerName);
       }

       if (sid.IsValid() && sid.IsOK())
       {
            fReturn = TRUE;

            pInstance->SetWCHARSplat(IDS_SID, sid.GetSidStringW());
            pInstance->SetByte(IDS_SIDType, sid.GetAccountType());
            // Setting the domain and name here assures that their values are
            // in synch with the returned sid info. Same for caption.
            if(!fDomainIsBuiltin)
            {
                pInstance->SetCHString(IDS_Domain, wstrDomainName);
                _bstr_t bstrtCaption(wstrDomainName);
                bstrtCaption += L"\\";
                bstrtCaption += wstrAccountName;
                pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
            }
            else
            {
				if ( a_Local )
				{
					pInstance->SetCHString(IDS_Domain, wstrComputerName);
					_bstr_t bstrtCaption(wstrComputerName);
					bstrtCaption += L"\\";
					bstrtCaption += wstrAccountName;
					pInstance->SetWCHARSplat(IDS_Caption, (WCHAR*) bstrtCaption);
				}
				else
				{
					fReturn = false ;
				}
            }
            pInstance->SetCHString(IDS_Name, wstrAccountName);
       }
    }
    return fReturn;
}
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Function:   CWin32GroupAccount::GetLocalGroupsNT
//
// Obtains Group Names for local groups (including 'special' groups).
//
// Inputs:     CNetAPI32      netapi - network api functions.
//          MethodContext* pMethodContext - Method Context
//
// Outputs: None.
//
// Returns: TRUE/FALSE     Success/Failure
//
// Comments:
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
HRESULT CWin32GroupAccount::GetLocalGroupsNT(
	
	CNetAPI32& netapi, 
	MethodContext* pMethodContext ,
	LPCWSTR a_Domain
)
{
    HRESULT hr=WBEM_S_NO_ERROR;
    NET_API_STATUS stat;
    DWORD i;
    LOCALGROUP_INFO_1 *pLocalGroupData = NULL;
    DWORD dwNumReturnedEntries = 0,
          dwMaxEntries;

	DWORD_PTR dwptrResume = NULL;

    CInstancePtr pInstance;
//    WKSTA_INFO_100 *pstInfo;

    // Get Domain name
//    netapi.NetWkstaGetInfo(NULL, 100, (LPBYTE *)&pstInfo);

	CHString chstrDCName ;

	LPCWSTR t_Server = NULL ;
	if ( a_Domain )
	{
		bool fGotDC = (netapi.GetDCName( a_Domain, chstrDCName ) == ERROR_SUCCESS);
		if ( fGotDC )
		{
			t_Server = chstrDCName ;
		}
	}

    // Local groups
    //=============
	try
	{
		do
		{
			// Local groups are returned from a different call than Global groups
			stat = netapi.NetLocalGroupEnum(t_Server,
											1,
											(LPBYTE *) &pLocalGroupData,
											262144,
											&dwNumReturnedEntries,
											&dwMaxEntries,
											&dwptrResume) ;

			if (stat != NERR_Success && stat != ERROR_MORE_DATA)
			{
					if (stat == ERROR_ACCESS_DENIED)
						hr = WBEM_E_ACCESS_DENIED;
					else
						hr = WBEM_E_FAILED;
			}

			// Make instances for all the returned groups
			WCHAR wstrLocalComputerName[MAX_COMPUTERNAME_LENGTH+1];
			DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
			ZeroMemory(wstrLocalComputerName,sizeof(wstrLocalComputerName));

			if(!ProviderGetComputerName( wstrLocalComputerName, &dwNameSize ) )
			{
				if ( ERROR_ACCESS_DENIED == ::GetLastError () )
				{
					return WBEM_E_ACCESS_DENIED;
				}
				else
				{
					return WBEM_E_FAILED;
				}
			}

			_bstr_t bstrtCaption;
			for(i = 0 ; ((i < dwNumReturnedEntries) && (SUCCEEDED(hr))) ; i++)
			{
				pInstance.Attach ( CreateNewInstance(pMethodContext) ) ;
				if (pInstance != NULL )
				{
					bool t_Resolved = GetSIDInformationW(
						
						a_Domain?a_Domain:wstrLocalComputerName,
						pLocalGroupData[i].lgrpi1_name,
						a_Domain?t_Server:wstrLocalComputerName,
						pInstance,
						a_Domain?false:true
					);

					if ( t_Resolved )
					{
						pInstance->SetWCHARSplat(IDS_Description, pLocalGroupData[i].lgrpi1_comment);
						pInstance->SetCharSplat(IDS_Status, IDS_STATUS_OK);
						pInstance->Setbool(L"LocalAccount", a_Domain?false:true);
						hr = pInstance->Commit () ;
					}
				}
			}

			if ( pLocalGroupData )
			{
				netapi.NetApiBufferFree ( pLocalGroupData ) ;
				pLocalGroupData = NULL ;
			}

		} while ((stat == ERROR_MORE_DATA) && (hr != WBEM_E_CALL_CANCELLED));

	//    netapi.NetApiBufferFree(pstInfo);
	}
	catch ( ... )
	{
		if ( pLocalGroupData )
		{
			netapi.NetApiBufferFree ( pLocalGroupData ) ;
			pLocalGroupData = NULL ;
		}
		throw ;
	}

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\floppycontroller.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FloppyController.cpp
//
//  Purpose: Floppy Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_FLOPPYCONTROLLER	L"Win32_FloppyController"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

class CWin32_FloppyController : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32_FloppyController ( LPCWSTR a_Name , LPCWSTR a_Namespace ) ;

       ~CWin32_FloppyController() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject ( CInstance *a_Instance , long lFlags , CFrameworkQuery &a_Query) ;
		HRESULT ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags ) ;
        virtual HRESULT EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags = 0L ) ;

    private:

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

        HRESULT LoadPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

        BOOL IsFloppyController ( CConfigMgrDevice *a_Device ) ;
        DWORD GetBitMask ( CFrameworkQuery &a_Query );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\group.h ===
//=================================================================

//

// Group.h -- Group property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//               11/13/97    davwoh         Re-Worked to return all
//                                          domain Groups
//
//=================================================================

// Method name for changing the key in this WMI class
#define METHOD_NAME_Rename	L"Rename"

// Method return property
#define METHOD_ARG_NAME_METHODRESULT L"ReturnValue"


// Property set identification
//============================
#define	PROPSET_NAME_GROUP L"Win32_Group"

class CWin32GroupAccount : public Provider
{

    public:

        // Constructor/destructor
        //=======================

        CWin32GroupAccount(LPCWSTR strName, LPCWSTR pszNamespace ) ;
        ~CWin32GroupAccount() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject( CInstance* pInstance, long lFlags = 0L );
        virtual HRESULT EnumerateInstances( MethodContext* pMethodContext, long lFlags = 0L );
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ );

#ifdef NTONLY	
		virtual	HRESULT ExecMethod(	const CInstance &a_Inst,
									const BSTR a_MethodName, 
									CInstance *a_InParams,
									CInstance *a_OutParams,
									long a_Flags = 0L ) ;

		// method errors -- maps to mof
		enum E_MethodResult	{
			e_Success,
			e_InstanceNotFound,
			e_NoInstance,
			e_InvalidParameter,
			e_GroupNotFound,
			e_InvalidComputer,
			e_NotPrimary,
			e_SpeGroupOp,
			e_ApiError,
			e_InternalError
		};		
#endif		
    private:

        // Utility function(s)
        //====================

#ifdef NTONLY
        HRESULT AddDynamicInstancesNT( MethodContext* pMethodContext ) ;
        HRESULT RefreshInstanceNT( CInstance* pInstance ) ;
        void LoadGroupValuesNT(LPCWSTR pwszFullName, LPCWSTR pwszDescription, DWORD dwFlags, CInstance* pInstance );
		HRESULT GetDomainGroupsNT( CNetAPI32& netapi, LPCWSTR wstrDomain, MethodContext* pMethodContext );
        HRESULT GetLocalGroupsNT(CNetAPI32& netapi, MethodContext* pMethodContext , LPCWSTR a_Domain = NULL );
		HRESULT GetSingleGroupNT( CInstance* pInstance );
#endif
#ifdef WIN9XONLY
        HRESULT AddDynamicInstancesWin95( MethodContext* pMethodContext ) ;
        HRESULT RefreshInstanceWin95( CInstance* pInstance ) ;
#endif

#ifdef NTONLY
        BOOL GetSIDInformationW(const LPCWSTR wstrDomainName, 
                                const LPCWSTR wstrAccountName, 
                                const LPCWSTR wstrComputerName, 
                                CInstance* pInstance,
								bool a_Local=false
		);

		HRESULT hRenameGroup( 

			CInstance *a_pInst,
			CInstance *a_InParams,
			CInstance *a_OutParams,
			long a_Flags ) ;
#endif
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\groupuser.h ===
//=================================================================

//

// groupuser.h -- UserGroup to User Group Members association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    1/26/98      davwoh         Created
//
// Comments: Shows the members in each user group
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_GROUPUSER L"Win32_GroupUser"

class CWin32GroupUser ;

class CWin32GroupUser:public Provider {

   public:

      // Constructor/destructor
      //=======================

      CWin32GroupUser(LPCWSTR name, LPCWSTR pszNamespace) ;
      ~CWin32GroupUser() ;

      // Functions provide properties with current values
      //=================================================

      virtual HRESULT GetObject(CInstance *pInstance, long lFlags = 0L);
      virtual HRESULT EnumerateInstances(MethodContext *pMethodContext, long lFlags = 0L);
      virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags = 0L );
      static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pGroupData);

   private:

      // Utility function(s)
      //====================

      void CWin32GroupUser::GetDependentsFromGroup(CNetAPI32& netapi, 
                                               const CHString sDomain,
                                               const CHString sGroupName, 
                                               const BYTE btSidType, 
                                               CHStringArray &asArray);

      HRESULT EnumerationCallback(CInstance* pGroup, MethodContext* pContext, void* pUserData);

      HRESULT ProcessArray(
        MethodContext* pMethodContext,
        CHString& chstrGroup__RELPATH, 
        CHStringArray& rgchstrArray);


      CHString m_sGroupBase;
      CHString m_sUserBase;
      CHString m_sSystemBase;
//      CHString m_sSystemBase;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\ide.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  IDE.cpp
//
//  Purpose: IDE Controller property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>

#include "IDE.h"

// Property set declaration
//=========================

CWin32IDE MyIDEController( PROPSET_NAME_IDE, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::CWin32IDE
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32IDE :: CWin32IDE (

	LPCWSTR strName,
	LPCWSTR pszNamespace

) : Provider( strName, pszNamespace )
{
    m_ptrProperties.SetSize(13);
    m_ptrProperties[0] = ((LPVOID) IDS_ConfigManagerErrorCode);
    m_ptrProperties[1] = ((LPVOID) IDS_ConfigManagerUserConfig);
    m_ptrProperties[2] = ((LPVOID) IDS_Status);
    m_ptrProperties[3] = ((LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4] = ((LPVOID) IDS_DeviceID);
    m_ptrProperties[5] = ((LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6] = ((LPVOID) IDS_SystemName);
    m_ptrProperties[7] = ((LPVOID) IDS_Description);
    m_ptrProperties[8] = ((LPVOID) IDS_Caption);
    m_ptrProperties[9] = ((LPVOID) IDS_Name);
    m_ptrProperties[10] = ((LPVOID) IDS_Manufacturer);
    m_ptrProperties[11] = ((LPVOID) IDS_ProtocolSupported);
    m_ptrProperties[12] = ((LPVOID) IDS_CreationClassName);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::~CWin32IDE
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32IDE::~CWin32IDE()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32IDE::GetObject
(
    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Let's see if config manager recognizes this device at all
    CHString sDeviceID;
    pInstance->GetCHString(IDS_DeviceID, sDeviceID);

    CConfigManager cfgmgr;

    CConfigMgrDevicePtr pDevice;
    if(cfgmgr.LocateDevice(sDeviceID, &pDevice))
    {
		// OK, it knows about it.  Is it a IDEController?
		if ( IsOneOfMe ( pDevice ) )
		{
            CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
            DWORD dwProperties;
            pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

			hr = LoadPropertyValues (

					&CLPVParams (

						pInstance,
						pDevice,
						dwProperties
					)
			) ;
		}
    }

    return hr ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::ExecQuery
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32IDE::ExecQuery
(
    MethodContext* pMethodContext,
    CFrameworkQuery& pQuery,
    long lFlags
)
{
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx*>(&pQuery);
    DWORD dwProperties;
    pQuery2->GetPropertyBitMask(m_ptrProperties, &dwProperties);

    return Enumerate(pMethodContext, lFlags, dwProperties);
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32IDE::EnumerateInstances
(
    MethodContext* pMethodContext,
    long lFlags /*= 0L*/
)
{
    return Enumerate(pMethodContext, lFlags);
}



////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::Enumerate
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32IDE::Enumerate
(
    MethodContext* pMethodContext,
    long lFlags,
    DWORD dwReqProps
)
{
    HRESULT hr = WBEM_E_FAILED;

    CConfigManager cfgManager;
    CDeviceCollection deviceList;

    // While it might be more performant to use FilterByGuid, it appears that
    // at least some
    // 95 boxes will report IDE info if we do it this way.
    if ( cfgManager.GetDeviceListFilterByClass( deviceList, L"hdc" ) )
    {
        REFPTR_POSITION pos;

        if ( deviceList.BeginEnum( pos ) )
        {
            hr = WBEM_S_NO_ERROR;

            // Walk the list
            CConfigMgrDevicePtr pDevice;
            for (pDevice.Attach(deviceList.GetNext(pos));
                 SUCCEEDED(hr) && (pDevice != NULL);
                 pDevice.Attach(deviceList.GetNext(pos)))
            {
				// Now to find out if this is the IDE controller
				if (IsOneOfMe(pDevice))
				{
					CInstancePtr pInstance (CreateNewInstance ( pMethodContext ), false) ;
					if((hr = LoadPropertyValues(&CLPVParams(pInstance, pDevice, dwReqProps))) == WBEM_S_NO_ERROR)
					{
						// Derived classes (like CW32IDECntrlDev) may
						// commit as result of call to LoadPropertyValues,
						// so check if we should -> only do so if we are
						// of this class's type.

						if ( ShouldBaseCommit ( NULL ) )
						{
							hr = pInstance->Commit(  );
						}
					}
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End
            deviceList.EndEnum();
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* pInstance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32IDE::LoadPropertyValues
(
    void* a_pv
)
{
    HRESULT t_hr = WBEM_S_NO_ERROR;
    CHString t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/
    CLPVParams* t_pData = (CLPVParams*)a_pv;
    CInstance* t_pInstance = (CInstance*)(t_pData->m_pInstance); // This instance released by caller
    CConfigMgrDevice* t_pDevice = (CConfigMgrDevice*)(t_pData->m_pDevice);
    DWORD t_dwReqProps = (DWORD)(t_pData->m_dwReqProps);

    if(t_pInstance == NULL || t_pDevice == NULL)
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID(t_chstrDeviceID);
    if(t_chstrDeviceID.GetLength() == 0)
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInstance->SetCHString(IDS_DeviceID, t_chstrDeviceID);
    }


    /*****************************
    * Set IDEController properties
    *****************************/

    if(t_dwReqProps & IDE_PROP_Manufacturer)
    {
        if(t_pDevice->GetMfg(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Manufacturer, t_chstrTemp);
        }
    }


    /*****************************
    * Set CIMController properties
    *****************************/

    // Fixed value from enumerated list
    if(t_dwReqProps & IDE_PROP_ProtocolSupported)
    {
        t_pInstance->SetWBEMINT16(IDS_ProtocolSupported, 37);
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if(t_dwReqProps & IDE_PROP_PNPDeviceID)
    {
        t_pInstance->SetCHString(IDS_PNPDeviceID, t_chstrDeviceID);
    }
    if(t_dwReqProps & IDE_PROP_SystemCreationClassName)
    {
        t_pInstance->SetCHString(IDS_SystemCreationClassName,
                                 IDS_Win32ComputerSystem);
    }
    if(t_dwReqProps & IDE_PROP_CreationClassName)
    {
        SetCreationClassName(t_pInstance);
    }
    if(t_dwReqProps & IDE_PROP_SystemCreationClassName)
    {
        t_pInstance->SetCHString(IDS_SystemCreationClassName,
                                 IDS_Win32ComputerSystem);
    }
    if(t_dwReqProps & IDE_PROP_SystemName)
    {
        t_pInstance->SetCHString(IDS_SystemName, GetLocalComputerName());
    }

    if( t_dwReqProps & (IDE_PROP_Description | IDE_PROP_Caption | IDE_PROP_Name) )
    {
        if(t_pDevice->GetDeviceDesc(t_chstrDesc))
        {
            t_pInstance->SetCHString(IDS_Description, t_chstrDesc);
        }
    }

    if(t_dwReqProps & IDE_PROP_ConfigManagerErrorCode ||
       t_dwReqProps & IDE_PROP_Status)
    {
        DWORD t_dwStatus = 0L;
        DWORD t_dwProblem = 0L;
        if(t_pDevice->GetStatus(&t_dwStatus, &t_dwProblem))
        {
            if(t_dwReqProps & IDE_PROP_ConfigManagerErrorCode)
            {
                t_pInstance->SetDWORD(IDS_ConfigManagerErrorCode, t_dwProblem);
            }
            if(t_dwReqProps & IDE_PROP_Status)
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInstance->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if(t_dwReqProps & IDE_PROP_ConfigManagerUserConfig)
    {
        t_pInstance->SetDWORD(IDS_ConfigManagerUserConfig,
                              t_pDevice->IsUsingForcedConfig());
    }

    // Use the friendly name for caption and name
    if(t_dwReqProps & IDE_PROP_Caption || t_dwReqProps & IDE_PROP_Name)
    {
        if(t_pDevice->GetFriendlyName(t_chstrTemp))
        {
            t_pInstance->SetCHString(IDS_Caption, t_chstrTemp);
            t_pInstance->SetCHString(IDS_Name, t_chstrTemp);
        }
        else
        {
            // If we can't get the name, settle for the description
            if(t_chstrDesc.GetLength() > 0)
            {
                t_pInstance->SetCHString(IDS_Caption, t_chstrDesc);
                t_pInstance->SetCHString(IDS_Name, t_chstrDesc);
            }
        }
    }
    return t_hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IDE::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a controller, and not some
 *                other type of IDE device.
 *
 *  INPUTS      : CConfigMgrDevice* pDevice - The device to check.  It is
 *                assumed that the caller has ensured that the device is a
 *                valid IDE class device.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32IDE::IsOneOfMe
(
    void* pv
)
{
    bool fRet = false;

    if(pv != NULL)
    {
        CConfigMgrDevice* pDevice = (CConfigMgrDevice*) pv;
        // Ok, it knows about it.  Is it a IDE device?

        fRet = pDevice->IsClass(L"hdc");
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\groupuser.cpp ===
//=================================================================

//

// groupuser.h -- UserGroup to User Group Members association provider

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    1/26/98      davwoh         Created
//
// Comments: Shows the members in each usergroup
//
//=================================================================
// In trying to do the UserGroups->Group Members association, I have made the following assumptions
//
// a) Global groups cannot have groups as members.
// b) Global groups cannot have any well-known accounts as members.
// c) Local groups can have Global groups as members.
// d) Local groups cannot have any well-known accounts as members.
//
// This is based on my experimentation with RegEdt32 and UsrMgr.  When these are discovered not to be
// true, we will probably need to make some changes here.

#include "precomp.h"
#include <frqueryex.h>
#include <assertbreak.h>

#include <comdef.h>
#include "wbemnetapi32.h"
#include "sid.h"

#include "user.h"
#include "group.h"
#include "systemaccount.h"

#include "GroupUser.h"

// Property set declaration
//=========================

CWin32GroupUser MyLoadDepends(PROPSET_NAME_GROUPUSER, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::CWin32GroupUser
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32GroupUser::CWin32GroupUser(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
   CHString sTemp;

   // Just saves us from having to constantly re-calculate these when sending
   // instances back.
   sTemp = PROPSET_NAME_USER;
   sTemp += L".Domain=\"";
   m_sUserBase = MakeLocalPath(sTemp);

   sTemp = PROPSET_NAME_GROUP;
   sTemp += L".Domain=\"";
   m_sGroupBase = MakeLocalPath(sTemp);

   sTemp = PROPSET_NAME_SYSTEMACCOUNT;
   sTemp += L".Domain=\"";
   m_sSystemBase = MakeLocalPath(sTemp);

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::~CWin32GroupUser
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32GroupUser::~CWin32GroupUser()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32GroupUser::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{

   // No groups on 95
#ifdef WIN9XONLY
   {
      return WBEM_S_NO_ERROR;
   }
#endif

#ifdef NTONLY
   CHString sMemberPath, sGroupPath;
   HRESULT hRet = WBEM_E_NOT_FOUND;
	CInstancePtr pGroup;
	CInstancePtr pMember;

   // Initialize the net stuff
   CNetAPI32 netapi ;
   if( netapi.Init() != ERROR_SUCCESS ) {
      return WBEM_E_FAILED;
   }

   // Get the two paths
   pInstance->GetCHString(IDS_GroupComponent, sGroupPath);
   pInstance->GetCHString(IDS_PartComponent, sMemberPath);

   // As we will be comparing these object paths
   // with those returned from GetDependentsFromGroup,
   // which always contains __PATH style object paths,
   // and since the user might have specified a __RELPATH,
   // we need to convert to __PATH here for consistency.
   CHString chstrGroup__PATH;
   CHString chstrMember__PATH;
   int n = -1;

   // Handle various GroupComponent path specifications...
   if(sGroupPath.Find(L"\\\\") == -1)
   {
       chstrGroup__PATH = MakeLocalPath(sGroupPath);
   }
   else if(sGroupPath.Find(L"\\\\.") != -1)
   {
       n = sGroupPath.Find(L":");
       if(n == -1)
       {
           hRet = WBEM_E_INVALID_OBJECT_PATH;
       }
       else
       {
           chstrGroup__PATH = MakeLocalPath(sGroupPath.Mid(n+1));
       }    
   }
   else
   {
       chstrGroup__PATH = sGroupPath;
   }


   // Handle various PartComponent path specifications...
   if(hRet != WBEM_E_INVALID_OBJECT_PATH)
   {
       if(sMemberPath.Find(L"\\\\") == -1)
       {
           chstrMember__PATH = MakeLocalPath(sMemberPath);
       }
       else if(sMemberPath.Find(L"\\\\.") != -1)
       {
           n = sMemberPath.Find(L":");
           if(n == -1)
           {
               hRet = WBEM_E_INVALID_OBJECT_PATH;
           }
           else
           {
               chstrMember__PATH = MakeLocalPath(sMemberPath.Mid(n+1));
           }    
       }
       else
       {
           chstrMember__PATH = sMemberPath;
       }
   }

   // If both ends are there
   if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath( (LPCTSTR)chstrMember__PATH, &pMember, pInstance->GetMethodContext() ) ) ) 
   {
      if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath( (LPCTSTR)chstrGroup__PATH, &pGroup, pInstance->GetMethodContext() ) ) ) 
      {
         // Now we need to check to see if this member (user or group) is in the usergroup
         CHString sGroupName, sDomainName;
         CHStringArray asMembersGot;
         DWORD dwSize;
         BYTE btType;

         // Retrieve the values we are looking for
         pGroup->GetCHString(IDS_Domain, sDomainName);
         pGroup->GetCHString(IDS_Name, sGroupName);
         pGroup->GetByte(IDS_SIDType, btType);

         // Get the dependent list for this service
         GetDependentsFromGroup(netapi, sDomainName, sGroupName, btType, asMembersGot);

         // Walk the list to see if we're there
         dwSize = asMembersGot.GetSize();
 
         for (int x=0; x < dwSize; x++) 
         {
            if (asMembersGot.GetAt(x).CompareNoCase(chstrMember__PATH) == 0) 
            {
               hRet = WBEM_S_NO_ERROR;
               break;
            }
         }
      }
   }

   return hRet;
#endif

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32GroupUser::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
#ifdef WIN9XONLY
      return WBEM_S_NO_ERROR;
#endif

#ifdef NTONLY
   HRESULT hr;

   CNetAPI32 netapi ;
   if( netapi.Init() != ERROR_SUCCESS ) {
      return WBEM_E_FAILED;
   }

//	hr = CWbemProviderGlue::GetAllInstancesAsynch(PROPSET_NAME_GROUP, this, StaticEnumerationCallback, IDS_CimWin32Namespace, pMethodContext, &netapi);
   	hr = CWbemProviderGlue::GetInstancesByQueryAsynch(_T("Select Domain, Name, SidType from Win32_Group"),
                                                      this, StaticEnumerationCallback, IDS_CimWin32Namespace,
                                                      pMethodContext, &netapi);

   return hr;
#endif
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::ExecQuery
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
HRESULT CWin32GroupUser::ExecQuery(
    MethodContext *pMethodContext, 
    CFrameworkQuery& pQuery, 
    long lFlags /*= 0L*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    std::vector<_bstr_t> vecGroupComponents;
    std::vector<_bstr_t> vecPartComponents;
    DWORD dwNumGroupComponents;
    DWORD dwNumPartComponents;
    CHString chstrGroup__RELPATH;
    CHString chstrGroupDomain;
    CHString chstrGroupName;
    CHStringArray rgchstrGroupMembers;

    // Initialize the net stuff
    CNetAPI32 netapi;
    if( netapi.Init() != ERROR_SUCCESS ) 
    {
       return WBEM_E_FAILED;
    }

    // Did they specify groups?
    pQuery.GetValuesForProp(IDS_GroupComponent, vecGroupComponents);
    dwNumGroupComponents = vecGroupComponents.size();

    // Did they specify users?
    pQuery.GetValuesForProp(IDS_PartComponent, vecPartComponents);
    dwNumPartComponents = vecPartComponents.size();

    // Prepare information to be used below...
    ParsedObjectPath    *pParsedPath = NULL;
    CObjectPathParser	objpathParser;

    // Find out what type of query it was.
    // Was it a 3TokenOR?
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);
    if (pQuery2 != NULL)
    {
        variant_t vGroupComp;
        variant_t vPartComp;
        CHString chstrSubDirPath;
        CHString chstrCurrentDir;

        if ( (pQuery2->Is3TokenOR(IDS_GroupComponent, IDS_PartComponent, vGroupComp, vPartComp)) &&
             ((V_BSTR(&vGroupComp) != NULL) && (V_BSTR(&vPartComp) != NULL)) &&
             (wcscmp(V_BSTR(&vGroupComp), V_BSTR(&vPartComp)) == 0) )
        {
			//group can be a member of a group so we have to enumerate :-(...
			hr = EnumerateInstances(pMethodContext, lFlags);
        }
        else if(dwNumGroupComponents > 0 && dwNumPartComponents == 0)  // one or more groups specified; no users specified
        {
            for(LONG m = 0L; m < dwNumGroupComponents && SUCCEEDED(hr); m++)
            {
                // Parse the path to get the domain/user
                int nStatus = objpathParser.Parse(vecGroupComponents[m],  &pParsedPath);

                // Did we parse it and does it look reasonable?
                if (nStatus == 0)
                {
                    try
                    {
                        if ( (pParsedPath->m_dwNumKeys == 2) &&
                             (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) && 
                             (pParsedPath->m_paKeys[1]->m_vValue.vt == VT_BSTR))
                        {
                            // This contains the complete object path
                            chstrGroup__RELPATH = (wchar_t*) vecGroupComponents[m];

                            // This contains just the 'Domain' part of the object path
                            chstrGroupDomain = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                            // This contains just the 'Name' part of the object path
                            chstrGroupName = pParsedPath->m_paKeys[1]->m_vValue.bstrVal;

                            // Obtain members of this group...
                            CHString chstrComputerName(GetLocalComputerName());
                            CHString chstrNT_AUTHORITY;
							CHString chstrBuiltIn;
                        
                            if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
                            {
                                if(chstrGroupDomain.CompareNoCase(chstrComputerName) == 0 ||
                                    chstrGroupDomain.CompareNoCase(chstrBuiltIn) == 0 ||
                                    chstrGroupDomain.CompareNoCase(chstrNT_AUTHORITY) == 0)
                                {
                                    GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeWellKnownGroup, rgchstrGroupMembers);
                                }
                                else
                                {
                                    GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeGroup, rgchstrGroupMembers);
                                }
                                hr = ProcessArray(pMethodContext, chstrGroup__RELPATH, rgchstrGroupMembers);
                            }
                        }
                    }
                    catch (...)
                    {
                        objpathParser.Free( pParsedPath );
                        throw;
                    }

                    // Clean up the Parsed Path
                    objpathParser.Free( pParsedPath );
                }
            }
        }
        else if(dwNumGroupComponents == 1 && dwNumPartComponents == 1)  // one group specified; one user specified
        {
            // Parse the path to get the domain/user
            int nStatus = objpathParser.Parse(vecGroupComponents[0],  &pParsedPath);

            // Did we parse it and does it look reasonable?
            if (nStatus == 0)
            {
                try
                {
                    if ( (pParsedPath->m_dwNumKeys == 2) &&
                         (pParsedPath->m_paKeys[0]->m_vValue.vt == VT_BSTR) && 
                         (pParsedPath->m_paKeys[1]->m_vValue.vt == VT_BSTR))
                    {
                        // This contains the complete object path
                        chstrGroup__RELPATH = (wchar_t*) vecGroupComponents[0];

                        // This contains just the 'Domain' part of the object path
                        chstrGroupDomain = pParsedPath->m_paKeys[0]->m_vValue.bstrVal;

                        // This contains just the 'Name' part of the object path
                        chstrGroupName = pParsedPath->m_paKeys[1]->m_vValue.bstrVal;

                        // Obtain members of this group...
                        CHString chstrComputerName(GetLocalComputerName());
                        CHString chstrNT_AUTHORITY;
                        CHString chstrBuiltIn;

                        if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY) && GetLocalizedBuiltInString(chstrBuiltIn))
                        {
                            if(chstrGroupDomain.CompareNoCase(chstrComputerName) == 0 ||
                                chstrGroupDomain.CompareNoCase(chstrBuiltIn) == 0 ||
                                chstrGroupDomain.CompareNoCase(chstrNT_AUTHORITY) == 0)
                            {
                                GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeWellKnownGroup, rgchstrGroupMembers);
                            }
                            else
                            {
                                GetDependentsFromGroup(netapi, chstrGroupDomain, chstrGroupName, SidTypeGroup, rgchstrGroupMembers);
                            }
                    
                            DWORD dwSize = rgchstrGroupMembers.GetSize();
                            CInstancePtr pInstance;

							//get full path for partcomponent
							CHString chstrMember__PATH;
							CHString chstrPart((LPCWSTR)(vecPartComponents[0]));
							
							if(chstrPart.Find(L"\\\\") == -1)
							{
								chstrMember__PATH = MakeLocalPath(chstrPart);
							}
						    else if(chstrPart.Find(L"\\\\.") != -1)
							{
								int n = chstrPart.Find(L":");

								if(n != -1)
								{
									chstrMember__PATH = MakeLocalPath(chstrPart.Mid(n+1));
								}    
							}
						    else
							{
							   chstrMember__PATH = ((LPCWSTR)(vecPartComponents[0]));
							}

                            // Process the instance
                            for (int x=0; x < dwSize && SUCCEEDED(hr) ; x++)
                            {
                                if(rgchstrGroupMembers.GetAt(x).CompareNoCase(chstrMember__PATH) == 0)
                                {
                                    pInstance.Attach(CreateNewInstance(pMethodContext));
                                    if(pInstance)
                                    {
                                        // Do the puts, and that's it
                                        pInstance->SetCHString(IDS_GroupComponent, chstrGroup__RELPATH);
                                        pInstance->SetCHString(IDS_PartComponent, chstrMember__PATH);
                                        hr = pInstance->Commit();
                                        break;
                                    }
                                    else
                                    {
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                    }
                                }
                            }
                        }
                    }
                }
                catch (...)
                {
                    objpathParser.Free( pParsedPath );
                    throw;
                }

                // Clean up the Parsed Path
                objpathParser.Free( pParsedPath );
            }    
        }
        else
        {
            hr = EnumerateInstances(pMethodContext, lFlags);
        }
    }

    // Because this is an association class, we should only return WBEM_E_NOT_FOUND or WBEM_S_NO_ERROR.  Other error codes
    // will cause associations that hit this class to terminate prematurely.
    if(SUCCEEDED(hr))
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}
#endif


/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::GetDependentsFromGroup
 *
 *  DESCRIPTION : Given a group name, returns the Users/Groups in that group name
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : Returns empty array if no group, empty group, or bad
 *                group name.
 *
 *****************************************************************************/
#ifdef NTONLY
void CWin32GroupUser::GetDependentsFromGroup(CNetAPI32& netapi,
                                               const CHString sDomainName,
                                               const CHString sGroupName,
                                               const BYTE btSidType,
                                               CHStringArray &asArray)
{
    CHString sTemp;
    NET_API_STATUS	stat;
    bool bAddIt;
    DWORD dwNumReturnedEntries = 0, dwIndex = 0, dwTotalEntries = 0;
	DWORD_PTR dwptrResume = NULL;

    // Domain Groups
    if (btSidType == SidTypeGroup)
    {
        GROUP_USERS_INFO_0 *pGroupMemberData = NULL;
        CHString		chstrDCName;

        if (netapi.GetDCName( sDomainName, chstrDCName ) == ERROR_SUCCESS)
        {
            do
            {

                // Accept up to 256k worth of data.
                stat = netapi.NetGroupGetUsers( chstrDCName,
                    sGroupName,
                    0,
                    (LPBYTE *)&pGroupMemberData,
                    262144,
                    &dwNumReturnedEntries,
                    &dwTotalEntries,
                    &dwptrResume);

                // If we got some data
                if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
                {
                    try
                    {

                        // Walk through all the returned entries
                        for ( DWORD	dwCtr = 0; dwCtr < dwNumReturnedEntries; dwCtr++ )
                        {

                            // Get the sid type for this object
                            CSid	sid( sDomainName, CHString(pGroupMemberData[dwCtr].grui0_name), NULL );
                            DWORD dwType = sid.GetAccountType();

                            // From our assertions above, Domain groups can only have users
                            if (dwType == SidTypeUser)
                            {
                                sTemp = m_sUserBase;
                                sTemp += sDomainName;
                                sTemp += _T("\",Name=\"");
                                sTemp += pGroupMemberData[dwCtr].grui0_name;
                                sTemp += _T('"');
                                asArray.Add(sTemp);
                            }
                        }
                    }
                    catch ( ... )
                    {
                        netapi.NetApiBufferFree( pGroupMemberData );
                        throw ;
                    }

                    netapi.NetApiBufferFree( pGroupMemberData );

                }	// IF stat OK

            } while ( ERROR_MORE_DATA == stat );
            
        }
    }
    // Local Groups
    else if (btSidType == SidTypeAlias || btSidType == SidTypeWellKnownGroup)
    {
        LOCALGROUP_MEMBERS_INFO_1 *pGroupMemberData = NULL;

        do {

            // Accept up to 256k worth of data.
            stat = netapi.NetLocalGroupGetMembers( NULL,
                sGroupName,
                1,
                (LPBYTE *)&pGroupMemberData,
                262144,
                &dwNumReturnedEntries,
                &dwTotalEntries,
                &dwptrResume);

            // If we got some data
            if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
            {
                try
                {

                    // Walk through all the returned entries
                    for ( DWORD	dwCtr = 0; dwCtr < dwNumReturnedEntries; dwCtr++ )
                    {

                        // If this is a recognized type...
                        bAddIt = true;

                        switch (pGroupMemberData[dwCtr].lgrmi1_sidusage) {

                        case SidTypeUser:
                            sTemp = m_sUserBase;
                            break;

                        case SidTypeGroup:
                            sTemp = m_sGroupBase;
                            break;

                        case SidTypeWellKnownGroup:
                            sTemp = m_sSystemBase;
                            break;

                        default:
                            // Group member is of unrecognized type, don't add it
                            ASSERT_BREAK(0);
                            bAddIt = false;
                            break;
                        }

                        CSid cLCID(pGroupMemberData[dwCtr].lgrmi1_sid);

                        // Then add it to the list
                        if (bAddIt)
                        {
                            CHString chstrDomNameTemp = cLCID.GetDomainName();
                            CHString chstrComputerName(GetLocalComputerName());
							CHString chstrBuiltIn;

                            if(GetLocalizedBuiltInString(chstrBuiltIn))
                            {
								if (chstrDomNameTemp.CompareNoCase(chstrBuiltIn) == 0)
								{
									chstrDomNameTemp = chstrComputerName;
								}
								else
								{
									CHString chstrNT_AUTHORITY;
									if(GetLocalizedNTAuthorityString(chstrNT_AUTHORITY))
									{
										if(chstrDomNameTemp.CompareNoCase(chstrNT_AUTHORITY) == 0)
										{
											chstrDomNameTemp = chstrComputerName;
										}   
									}
									else
									{
										bAddIt = false;
									}
								}
                            }
                            else
                            {
								bAddIt = false;
                            }

                            if(bAddIt)
                            {
                                sTemp += chstrDomNameTemp;
                                //sTemp += cLCID.GetDomainName();
                                sTemp += _T("\",Name=\"");
                                sTemp += pGroupMemberData[dwCtr].lgrmi1_name;
                                sTemp += _T('"');
                                asArray.Add(sTemp);
                            }
                        }
                    }
                }
                catch ( ... )
                {
                    netapi.NetApiBufferFree( pGroupMemberData );
                    throw ;
                }

                netapi.NetApiBufferFree( pGroupMemberData );

            }	// IF stat OK

        } while ( ERROR_MORE_DATA == stat );
    }
	else
    {
        // Unrecognized Group type
        ASSERT_BREAK(0);
    }

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT WINAPI CWin32GroupUser::StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData)
{
	CWin32GroupUser* pThis;
   HRESULT hr;

	pThis = dynamic_cast<CWin32GroupUser *>(pThat);
	ASSERT_BREAK(pThis != NULL);

	if (pThis)
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
   else
      hr = WBEM_E_FAILED;

   return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32GroupUser::EnumerationCallback(CInstance* pGroup, MethodContext* pMethodContext, void* pUserData)
{
	CNetAPI32* pNetApi;
	pNetApi = (CNetAPI32 *) pUserData;
   CHStringArray asMembersGot;
   BYTE btSidType;
   DWORD dwSize, x;
   CHString sGroup, sDomain, sGroupPath;
   HRESULT hr = WBEM_S_NO_ERROR;

   // Get the info about this group
   pGroup->GetCHString(IDS_Domain, sDomain) ;
   pGroup->GetCHString(IDS_Name, sGroup) ;
   pGroup->GetByte(IDS_SIDType, btSidType);
   pGroup->GetCHString(L"__RELPATH", sGroupPath) ;

   // See if there are users in this group
   GetDependentsFromGroup(*pNetApi, sDomain, sGroup, btSidType, asMembersGot);

   dwSize = asMembersGot.GetSize();

   // Ok, turn the relpath into a complete path
   GetLocalInstancePath(pGroup, sGroupPath);
   CInstancePtr pInstance;

   // Start pumping out the instances
   for (x=0; x < dwSize && SUCCEEDED(hr) ; x++)
   {
      pInstance.Attach(CreateNewInstance(pMethodContext));
      if (pInstance)
      {
          // Do the puts, and that's it
          pInstance->SetCHString(IDS_GroupComponent, sGroupPath);
          pInstance->SetCHString(IDS_PartComponent, asMembersGot.GetAt(x));
          hr = pInstance->Commit();
      }
      else
      {
          hr = WBEM_E_OUT_OF_MEMORY;
      }
   }

   return hr;
}
#endif



/*****************************************************************************
 *
 *  FUNCTION    : CWin32GroupUser::ProcessArray
 *
 *  DESCRIPTION : Called from query routine to return instances
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef NTONLY
HRESULT CWin32GroupUser::ProcessArray(
    MethodContext* pMethodContext,
    CHString& chstrGroup__RELPATH, 
    CHStringArray& rgchstrArray)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwSize, x;
    CHString sGroup, sDomain, sGroupPath;

    dwSize = rgchstrArray.GetSize();

    CInstancePtr pInstance;

    // Start pumping out the instances
    for (x=0; x < dwSize && SUCCEEDED(hr) ; x++)
    {
        pInstance.Attach(CreateNewInstance(pMethodContext));
        if(pInstance)
        {
            // Do the puts, and that's it
            pInstance->SetCHString(IDS_GroupComponent, chstrGroup__RELPATH);
            pInstance->SetCHString(IDS_PartComponent, rgchstrArray.GetAt(x));
            hr = pInstance->Commit();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\infrared.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  InfraRed.h
//
//  Purpose: InfraRed Controller property set provider
//
//***************************************************************************

// Property set identification
//============================

#define	PROPSET_NAME_INFRARED	L"Win32_InfraredDevice"

#define SPECIAL_PROPS_ALL_REQUIRED          0xFFFFFFFF
#define SPECIAL_PROPS_NONE_REQUIRED         0x00000000
#define SPECIAL_PROPS_STATUS				0x00000004
#define SPECIAL_PROPS_DEVICEID				0x00000008
#define SPECIAL_PROPS_CREATIONNAME			0x00000010
#define SPECIAL_PROPS_SYSTEMNAME			0x00000020
#define SPECIAL_PROPS_DESCRIPTION			0x00000040
#define SPECIAL_PROPS_CAPTION				0x00000080
#define SPECIAL_PROPS_NAME					0x00000100
#define SPECIAL_PROPS_MANUFACTURER			0x00000200
#define SPECIAL_PROPS_PROTOCOLSSUPPORTED	0x00000400
#define SPECIAL_PROPS_PNPDEVICEID			0x00400000
#define SPECIAL_PROPS_CONFIGMERRORCODE		0x00800000
#define SPECIAL_PROPS_CONFIGMUSERCONFIG		0x01000000
#define SPECIAL_PROPS_CREATIONCLASSNAME		0x02000000
#define SPECIAL_PROPS_STATUSINFO			0x04000000
#define SPECIAL_PROPS_AVAILABILITY			0x08000000


#define SPECIAL_ALL					( SPECIAL_CONFIGMANAGER )

#define SPECIAL_CONFIGMANAGER		( SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_DEVICEID | \
									SPECIAL_PROPS_CREATIONNAME | \
									SPECIAL_PROPS_SYSTEMNAME | \
									SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME | \
									SPECIAL_PROPS_MANUFACTURER | \
									SPECIAL_PROPS_PROTOCOLSSUPPORTED | \
									SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_CREATIONCLASSNAME | \
									SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_STATUSINFO | \
									SPECIAL_PROPS_AVAILABILITY )

#define SPECIAL_CONFIGPROPERTIES 	( SPECIAL_PROPS_PNPDEVICEID | \
									SPECIAL_PROPS_CONFIGMERRORCODE | \
									SPECIAL_PROPS_CONFIGMUSERCONFIG | \
									SPECIAL_PROPS_STATUS | \
									SPECIAL_PROPS_STATUSINFO | \
									SPECIAL_PROPS_AVAILABILITY )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_DESC_CAP_NAME		( SPECIAL_PROPS_DESCRIPTION | \
									SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define SPECIAL_CAP_NAME			( SPECIAL_PROPS_CAPTION | \
									SPECIAL_PROPS_NAME )

#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000

class CWin32_InfraRed : public Provider
{
    public:

        // Constructor/destructor
        //=======================

        CWin32_InfraRed ( LPCWSTR a_Name , LPCWSTR a_Namespace ) ;

       ~CWin32_InfraRed() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject ( CInstance *a_Instance , long lFlags , CFrameworkQuery &a_Query ) ;
		HRESULT ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags ) ;
        virtual HRESULT EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags = 0L ) ;

    private:

        // Utility function(s)
        //====================

		HRESULT Enumerate ( 

			MethodContext *a_MethodContext , 
			long a_Flags , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED
		) ;

        HRESULT LoadPropertyValues ( 

			CInstance *a_Instance , 
			CConfigMgrDevice *a_Device , 
			const CHString &a_DeviceName , 
			DWORD a_SpecifiedPropertied = SPECIAL_PROPS_ALL_REQUIRED 
		) ;

        DWORD GetBitMask ( CFrameworkQuery &a_Query );

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\implement_logicalfile.h ===
//=================================================================

//

// Implement_LogicalFile.h -- 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/02/98    a-kevhu         Created
//
//=================================================================

//NOTE: The CImplement_LogicalFile class is not exposed to the outside world thru the mof. It now has implementations 
//		of EnumerateInstances & GetObject which were earlier present in CCimLogicalFile. CImplement_LogicalFile can't be 
//		instantiated since it has pure virtual declaration of the IsOneOfMe  method which the derived classes  should 
//		implement.

#ifndef _IMPLEMENT_LOGICALFILE_H
#define _IMPLEMENT_LOGICALFILE_H


//***************************************************************************************************
// Flags defined for use in determining whether certain expensive properties are required in queries.
// DEVNOTE: If you add to this list, be sure to enhance the function DetermineReqProps().

//   First, those common to all cim_logicalfile derived classes
#define PROP_NO_SPECIAL                          0x00000000
#define PROP_KEY_ONLY                            0x10000000
#define PROP_ALL_SPECIAL                         0x0FFFFFFF
#define PROP_COMPRESSION_METHOD                  0x00000001
#define PROP_ENCRYPTION_METHOD                   0x00000002
#define PROP_FILE_TYPE                           0x00000004
#define PROP_MANUFACTURER                        0x00000008
#define PROP_VERSION                             0x00000010
#define PROP_FILESIZE                            0x00000020
#define PROP_FILE_SYSTEM                         0x00000040
#define PROP_ACCESS_MASK                         0x00000080
#define PROP_CREATION_DATE                       0x00000100
#define PROP_LAST_ACCESSED                       0x00000200
#define PROP_LAST_MODIFIED                       0x00000400
#define PROP_INSTALL_DATE                        0x00000800
//   Then, those for specific classes derived from cim_logicalfile
//       Shortcut files
#define PROP_TARGET                              0x00010000

//***************************************************************************************************


#include "file.h"

class CDriveInfo
{
    public:
        CDriveInfo();
        CDriveInfo(WCHAR* wstrDrive, WCHAR* wstrFS);  
        ~CDriveInfo();

        WCHAR m_wstrDrive[8];
        WCHAR m_wstrFS[56];
};

class CEnumParm
{
    public:
        CEnumParm();
        CEnumParm(MethodContext* pMethodContext,
                  bool bRecurse,
                  DWORD dwReqProps,
                  bool bRoot,
                  void* pvMoreData);
        
        ~CEnumParm();

        MethodContext* m_pMethodContext;
        bool m_bRecurse;
        DWORD m_dwReqProps;
        bool m_bRoot;
        void* m_pvMoreData;
};

inline CEnumParm::CEnumParm()
:   m_bRecurse(false),
    m_dwReqProps(0L),
    m_bRoot(false),
    m_pMethodContext(NULL),
    m_pvMoreData(NULL)
{
}

inline CEnumParm::CEnumParm(MethodContext* pMethodContext,
                            bool bRecurse,
                            DWORD dwReqProps,
                            bool bRoot,
                            void* pvMoreData) 
:  m_pMethodContext(pMethodContext), 
   m_bRecurse(bRecurse),
   m_dwReqProps(dwReqProps),
   m_bRoot(bRoot),
   m_pvMoreData(pvMoreData)
{
}

inline CEnumParm::~CEnumParm()
{
}


#ifdef WIN9XONLY
class C95EnumParm : public CEnumParm
{
    public:
        C95EnumParm();
        C95EnumParm(MethodContext* pMethodContext,
                    LPCTSTR pszDrive,
                    LPCTSTR pszPath,
                    LPCTSTR pszFile,
                    LPCTSTR pszExt,
                    bool bRecurse,
                    LPCTSTR szFSName,
                    DWORD dwReqProps,
                    bool bRoot,
                    void* pvMoreData);

        C95EnumParm(C95EnumParm& oldp);

        ~C95EnumParm();

        LPCTSTR m_pszDrive;
        LPCTSTR m_pszPath;
        LPCTSTR m_pszFile;
        LPCTSTR m_pszExt;
        LPCTSTR m_szFSName;
};

inline C95EnumParm::C95EnumParm()
{
}

inline C95EnumParm::~C95EnumParm()
{
}

inline C95EnumParm::C95EnumParm(MethodContext* pMethodContext,
                                LPCTSTR pszDrive,
                                LPCTSTR pszPath,
                                LPCTSTR pszFile,
                                LPCTSTR pszExt,
                                bool bRecurse,
                                LPCTSTR szFSName,
                                DWORD dwReqProps,
                                bool bRoot,
                                void* pvMoreData) 
:  CEnumParm(pMethodContext, bRecurse, dwReqProps, bRoot, pvMoreData),
   m_pszDrive(pszDrive),
   m_pszPath(pszPath),
   m_pszFile(pszFile),
   m_pszExt(pszExt),
   m_szFSName(szFSName) 
{
}

inline C95EnumParm::C95EnumParm(C95EnumParm& oldp)
{
    m_pMethodContext = oldp.m_pMethodContext;
    m_bRecurse = oldp.m_bRecurse;
    m_dwReqProps = oldp.m_dwReqProps;
    m_bRoot = oldp.m_bRoot;
    m_pszDrive = oldp.m_pszDrive;
    m_pszPath = oldp.m_pszPath;
    m_pszFile = oldp.m_pszFile;
    m_pszExt = oldp.m_pszExt;
    m_szFSName = oldp.m_szFSName;
    m_pvMoreData = oldp.m_pvMoreData;               
}

#endif

#ifdef NTONLY
class CNTEnumParm : public CEnumParm
{
    public:
        CNTEnumParm();
        CNTEnumParm(MethodContext* pMethodContext,
                    const WCHAR* pszDrive,
                    const WCHAR* pszPath,
                    const WCHAR* pszFile,
                    const WCHAR* pszExt,
                    bool bRecurse,
                    const WCHAR* szFSName,
                    DWORD dwReqProps,
                    bool bRoot,
                    void* pvMoreData);

        CNTEnumParm(CNTEnumParm& oldp);
        
        ~CNTEnumParm();

        const WCHAR* m_pszDrive;
        const WCHAR* m_pszPath;
        const WCHAR* m_pszFile;
        const WCHAR* m_pszExt;
        const WCHAR* m_szFSName;
};

inline CNTEnumParm::CNTEnumParm()
{
}

inline CNTEnumParm::~CNTEnumParm()
{
}

inline CNTEnumParm::CNTEnumParm(MethodContext* pMethodContext,
                    const WCHAR* pszDrive,
                    const WCHAR* pszPath,
                    const WCHAR* pszFile,
                    const WCHAR* pszExt,
                    bool bRecurse,
                    const WCHAR* szFSName,
                    DWORD dwReqProps,
                    bool bRoot,
                    void* pvMoreData) 
:   CEnumParm(pMethodContext, bRecurse, dwReqProps, bRoot, pvMoreData),
    m_pszDrive(pszDrive),
    m_pszPath(pszPath),
    m_pszFile(pszFile),
    m_pszExt(pszExt),
    m_szFSName(szFSName)
{
}

inline CNTEnumParm::CNTEnumParm(CNTEnumParm& oldp)
{
    m_pMethodContext = oldp.m_pMethodContext;
    m_bRecurse = oldp.m_bRecurse;
    m_dwReqProps = oldp.m_dwReqProps;
    m_bRoot = oldp.m_bRoot;
    m_pszDrive = oldp.m_pszDrive;
    m_pszPath = oldp.m_pszPath;
    m_pszFile = oldp.m_pszFile;
    m_pszExt = oldp.m_pszExt;
    m_szFSName = oldp.m_szFSName;
    m_pvMoreData = oldp.m_pvMoreData;               
}

#endif

//#define  PROPSET_NAME_FILE "CIM_LogicalFile"



class CImplement_LogicalFile: public CCIMLogicalFile
{    

    public:

        // Constructor/destructor
        //=======================

        CImplement_LogicalFile(LPCWSTR name, LPCWSTR pszNamespace);
       ~CImplement_LogicalFile() ;

        // Functions provide properties with current values
        //=================================================

        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery& pQuery);
        virtual HRESULT EnumerateInstances(MethodContext* pMethodContext, 
                                           long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext* pMethodContext, 
                                  CFrameworkQuery& pQuery, 
                                  long lFlags = 0L);



    protected:
		
        // Some derived association classes use these functions...
        void GetPathPieces(const CHString& chstrFullPath, 
                           CHString& chstrDrive, 
                           CHString& chstrPath,
                           CHString& chstrName, 
                           CHString& chstrExt);

        LONG DetermineReqProps(CFrameworkQuery& pQuery,
                               DWORD* pdwReqProps);

        void GetDrivesAndFS(
            std::vector<CDriveInfo*>& vecpDI, 
            bool fGetFS = false, 
            LPCTSTR tstrDriveSet = NULL);

        BOOL GetIndexOfDrive(const WCHAR* wstrDrive, 
                             std::vector<CDriveInfo*>& vecpDI, 
                             LONG* lDriveIndex);

        void FreeVector(std::vector<CDriveInfo*>& vecpDI);
        
        // Note: IsOneOfMe function used by derived classes to filter out what 
        // they allow to be reported as "one of them".  In this class, for instance,
        // it will always return true.  In classes derived from this one, such as
        // Win32_Directory, they will return true only if the file is a directory.
         
#ifdef WIN9XONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAA pstFindData,
                               const char* strFullPathName = 0) = 0;

        HRESULT EnumDirs95(C95EnumParm& p);

        virtual void LoadPropertyValues95(CInstance* pInstance,
                                          LPCTSTR pszDrive, 
                                          LPCTSTR pszPath, 
                                          LPCTSTR pszFSName, 
                                          LPWIN32_FIND_DATA pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);

#endif
#ifdef NTONLY
        virtual BOOL IsOneOfMe(LPWIN32_FIND_DATAW pstFindData,
                               const WCHAR* wstrFullPathName = 0) = 0;

        HRESULT EnumDirsNT(CNTEnumParm& p);

        virtual void LoadPropertyValuesNT(CInstance* pInstance,
                                          const WCHAR* pszDrive, 
                                          const WCHAR* pszPath, 
                                          const WCHAR* pszFSName, 
                                          LPWIN32_FIND_DATAW pstFindData,
                                          const DWORD dwReqProps,
                                          const void* pvMoreData);

#endif
        virtual void GetExtendedProperties(CInstance *pInstance, long lFlags = 0L);
        bool IsValidDrive(LPCTSTR szDrive);
        
        
    private:


        bool GetAllProps();
        bool IsClassShortcutFile();
		void EnumDrives(MethodContext* pMethodContext, LPCTSTR pszPath);
        bool IsValidPath(const WCHAR* wstrPath, bool fRoot);
        bool IsValidPath(const CHAR* strPath, bool fRoot);
        bool HasCorrectBackslashes(const WCHAR* wstrPath, bool fRoot);
        bool DrivePresent(LPCTSTR tstrDrive);
        
#ifdef WIN9XONLY
		HRESULT FindSpecificPath95(CInstance* pInstance,
                                   CHString& sDrive, 
                                   CHString& sDir,
                                   DWORD dwProperties);
#endif
#ifdef NTONLY
		HRESULT FindSpecificPathNT(CInstance* pInstance, 
                                   const WCHAR* sDrive, 
                                   const WCHAR* sDir,
                                   DWORD dwProperties);
#endif
};


#endif  // _IMPLEMENT_LOGICALFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\infrared.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  InfraRed.cpp
//
//  Purpose: InfraRed Controller property set provider
//
//***************************************************************************

#include "precomp.h"

#include "InfraRed.h"

// Property set declaration
//=========================

#define CONFIG_MANAGER_CLASS_INFRARED L"InfraRed"

CWin32_InfraRed s_InfraRed ( PROPSET_NAME_INFRARED, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_InfraRed::CWin32_InfraRed
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_InfraRed :: CWin32_InfraRed (

	LPCWSTR a_Name ,
	LPCWSTR a_Namespace

) : Provider( a_Name, a_Namespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_InfraRed::~CWin32_InfraRed
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_InfraRed :: ~CWin32_InfraRed ()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_InfraRed::GetObject
//
//  Inputs:     CInstance*      a_Instance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_InfraRed :: GetObject ( CInstance *a_Instance , long a_Flags , CFrameworkQuery &a_Query )
{
    HRESULT t_Result = WBEM_E_NOT_FOUND ;


    // Let's see if config manager recognizes this device at all

    CHString t_DeviceID;
    a_Instance->GetCHString ( IDS_DeviceID , t_DeviceID ) ;

    CConfigManager t_ConfigurationManager ;
    CConfigMgrDevicePtr t_Device;

    if ( t_ConfigurationManager.LocateDevice ( t_DeviceID , &t_Device ) )
    {
		// Ok, it knows about it.  Is it a InfraRed device?

		if ( t_Device->IsClass ( CONFIG_MANAGER_CLASS_INFRARED ) )
		{
			// Last chance, are you sure it's a controller?

			CHString t_Key ;
			a_Instance->GetCHString ( IDS_DeviceID , t_Key ) ;

            DWORD t_SpecifiedProperties = GetBitMask ( a_Query );

			t_Result = LoadPropertyValues ( a_Instance , t_Device , t_Key , t_SpecifiedProperties) ;
		}
    }

    return t_Result ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_InfraRed::EnumerateInstances
//
//  Inputs:     MethodContext*  pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////

HRESULT CWin32_InfraRed :: EnumerateInstances ( MethodContext *a_MethodContext , long a_Flags )
{
	HRESULT t_Result = Enumerate ( a_MethodContext , a_Flags ) ;
	return t_Result ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32CDROM::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_InfraRed :: ExecQuery ( MethodContext *a_MethodContext, CFrameworkQuery &a_Query, long a_Flags )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    DWORD t_SpecifiedProperties = GetBitMask ( a_Query );
	//if ( t_SpecifiedProperties )  //removed since would result in no query being executed if we didn't ask for any special props.
	{
		t_Result = Enumerate ( a_MethodContext , a_Flags , t_SpecifiedProperties ) ;
	}

    return t_Result ;
}

HRESULT CWin32_InfraRed :: Enumerate ( MethodContext *a_MethodContext , long a_Flags , DWORD a_SpecifiedProperties )
{
    HRESULT t_Result = WBEM_E_FAILED ;

    CConfigManager t_ConfigurationManager ;
    CDeviceCollection t_DeviceList ;

    // While it might be more performant to use FilterByGuid, it appears that at least some
    // 95 boxes will report InfraRed info if we do it this way.

    if ( t_ConfigurationManager.GetDeviceListFilterByClass ( t_DeviceList , CONFIG_MANAGER_CLASS_INFRARED ) )
    {
        REFPTR_POSITION t_Position ;

        if ( t_DeviceList.BeginEnum( t_Position ) )
        {
            CConfigMgrDevicePtr t_Device;

            t_Result = WBEM_S_NO_ERROR ;

            // Walk the list
            for (t_Device.Attach(t_DeviceList.GetNext ( t_Position ) );
                 SUCCEEDED ( t_Result ) && ( t_Device != NULL );
                 t_Device.Attach(t_DeviceList.GetNext ( t_Position ) ))
            {
				// Now to find out if this is the infrared controller

				CHString t_Key ;
				if ( t_Device->GetDeviceID ( t_Key ) )
				{
					CInstancePtr t_Instance (CreateNewInstance ( a_MethodContext ), false) ;
					if ( ( t_Result = LoadPropertyValues ( t_Instance , t_Device , t_Key , a_SpecifiedProperties) ) == WBEM_S_NO_ERROR )
					{
						t_Result = t_Instance->Commit (  ) ;
					}
				}
            }

            // Always call EndEnum().  For all Beginnings, there must be an End

            t_DeviceList.EndEnum () ;
        }
    }

    return t_Result;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_InfraRed::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : CInstance* a_Instance - Instance to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32_InfraRed :: LoadPropertyValues (

	CInstance *a_Instance ,
	CConfigMgrDevice *a_Device ,
	const CHString &a_DeviceName ,
	DWORD a_SpecifiedProperties
)
{
    HRESULT t_Result = WBEM_S_NO_ERROR;

/*
 *	 Set PNPDeviceID, ConfigManagerErrorCode, ConfigManagerUserConfig
 */

	if ( a_SpecifiedProperties & SPECIAL_CONFIGPROPERTIES )
	{
		SetConfigMgrProperties ( a_Device, a_Instance ) ;

/*
 * Set the status based on the config manager error code
 */

		if ( a_SpecifiedProperties & ( SPECIAL_PROPS_AVAILABILITY | SPECIAL_PROPS_STATUS | SPECIAL_PROPS_STATUSINFO ) )
		{
            CHString t_sStatus;
			if ( a_Device->GetStatus ( t_sStatus ) )
			{
				if (t_sStatus == IDS_STATUS_Degraded)
                {
					a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
					a_Instance->SetWBEMINT16 ( IDS_Availability , 10 ) ;
                }
                else if (t_sStatus == IDS_STATUS_OK)
                {

				    a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 3 ) ;
				    a_Instance->SetWBEMINT16 ( IDS_Availability,  3 ) ;
                }
                else if (t_sStatus == IDS_STATUS_Error)
                {
				    a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 4 ) ;
				    a_Instance->SetWBEMINT16 ( IDS_Availability , 4 ) ;
                }
                else
                {
					a_Instance->SetWBEMINT16 ( IDS_StatusInfo , 2 ) ;
					a_Instance->SetWBEMINT16 ( IDS_Availability , 2 ) ;
                }

                a_Instance->SetCHString(IDS_Status, t_sStatus);
			}
		}
	}
/*
 *	Use the PNPDeviceID for the DeviceID (key)
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_DEVICEID )
	{
		CHString t_Key ;

		if ( a_Device->GetDeviceID ( t_Key ) )
		{
			a_Instance->SetCHString ( IDS_DeviceID , t_Key ) ;
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONNAME )
	{
		a_Instance->SetWCHARSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_SYSTEMNAME )
	{
	    a_Instance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_CREATIONCLASSNAME )
	{
		SetCreationClassName ( a_Instance ) ;
	}

	if ( a_SpecifiedProperties & SPECIAL_DESC_CAP_NAME )
	{
		CHString t_Description ;
		if ( a_Device->GetDeviceDesc ( t_Description ) )
		{
			if ( a_SpecifiedProperties & SPECIAL_PROPS_DESCRIPTION )
			{
				a_Instance->SetCHString ( IDS_Description , t_Description ) ;
			}
		}

/*
 *	Use the friendly name for caption and name
 */

		if ( a_SpecifiedProperties & SPECIAL_CAP_NAME )
		{
			CHString t_FriendlyName ;
			if ( a_Device->GetFriendlyName ( t_FriendlyName ) )
			{
				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_FriendlyName ) ;
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_FriendlyName ) ;
				}
			}
			else
			{
		/*
		 *	If we can't get the name, settle for the description
		 */

				if ( a_SpecifiedProperties & SPECIAL_PROPS_CAPTION )
				{
					a_Instance->SetCHString ( IDS_Caption , t_Description );
				}

				if ( a_SpecifiedProperties & SPECIAL_PROPS_NAME )
				{
					a_Instance->SetCHString ( IDS_Name , t_Description );
				}
			}
		}
	}

	if ( a_SpecifiedProperties & SPECIAL_PROPS_MANUFACTURER )
	{
		CHString t_Manufacturer ;

		if ( a_Device->GetMfg ( t_Manufacturer ) )
		{
			a_Instance->SetCHString ( IDS_Manufacturer, t_Manufacturer ) ;
		}
	}

/*
 *	Fixed value from enumerated list
 */

	if ( a_SpecifiedProperties & SPECIAL_PROPS_PROTOCOLSSUPPORTED )
	{
	    a_Instance->SetWBEMINT16 ( IDS_ProtocolSupported, 45 ) ;
	}

    return t_Result ;
}

DWORD CWin32_InfraRed :: GetBitMask ( CFrameworkQuery &a_Query )
{
    DWORD t_SpecifiedProperties = SPECIAL_PROPS_NONE_REQUIRED ;

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_StatusInfo ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUSINFO ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_DeviceID ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DEVICEID ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemCreationClassName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_SystemName ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_SYSTEMNAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Description ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_DESCRIPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Caption ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_CAPTION ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Name ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_NAME ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Manufacturer ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_MANUFACTURER ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_ProtocolSupported ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_PROTOCOLSSUPPORTED ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_Status ) )
    {
		t_SpecifiedProperties |= SPECIAL_PROPS_STATUS ;
	}

    if ( a_Query.IsPropertyRequired ( IDS_CreationClassName ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CREATIONCLASSNAME ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_PNPDeviceID ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_PNPDEVICEID ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerErrorCode ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMERRORCODE ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_ConfigManagerUserConfig ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_CONFIGMUSERCONFIG ;
    }

    if ( a_Query.IsPropertyRequired ( IDS_Availability ) )
    {
        t_SpecifiedProperties |= SPECIAL_PROPS_AVAILABILITY ;
    }

    return t_SpecifiedProperties;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\ide.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  IDE.h
//
//  Purpose: IDE Controller property set provider
//
//***************************************************************************

// Property set identification
//============================
#ifndef _IDE_H
#define _IDE_H



#define IDE_ALL_PROPS                    0xFFFFFFFF
#define IDE_KEY_ONLY                     0x00000010
#define IDE_PROP_ConfigManagerErrorCode  0x00000001
#define IDE_PROP_ConfigManagerUserConfig 0x00000002
#define IDE_PROP_Status                  0x00000004
#define IDE_PROP_PNPDeviceID             0x00000008
#define IDE_PROP_DeviceID                0x00000010
#define IDE_PROP_SystemCreationClassName 0x00000020
#define IDE_PROP_SystemName              0x00000040
#define IDE_PROP_Description             0x00000080
#define IDE_PROP_Caption                 0x00000100
#define IDE_PROP_Name                    0x00000200
#define IDE_PROP_Manufacturer            0x00000400
#define IDE_PROP_ProtocolSupported       0x00000800
#define IDE_PROP_CreationClassName       0x00001000





#define	PROPSET_NAME_IDE	L"Win32_IDEController"

class CWin32IDE : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;

    protected:

        virtual bool IsOneOfMe
        (
            void* a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void* a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void* a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps = IDE_ALL_PROPS
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32IDE
        (
            LPCWSTR a_strName, 
            LPCWSTR a_pszNamespace
        );

        ~CWin32IDE();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance* a_pInstance, 
            long a_lFlags,
            CFrameworkQuery& pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext* a_pMethodContext, 
            CFrameworkQuery& a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext* a_pMethodContext, 
            long a_lFlags = 0L
        );        
} ;

// This is the base; it should always commit in the base.
inline bool CWin32IDE::ShouldBaseCommit
(
    void* pvData
)
{ 
    return true; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\irq.h ===
///////////////////////////////////////////////////////////////////////

//                                                                   //

// IRQ.h -- IRQ property set description for WBEM MO                 //

//                                                                   //

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved //
//                                                                   //
// 10/18/95     a-skaja     Prototype                                //
// 09/13/96     jennymc     Updated to meet current standards        //
// 09/12/97		a-sanjes	Added LocateNTOwnerDevice and added		 //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define PROPSET_NAME_IRQ L"Win32_IRQResource"


class CWin32IRQResource : public Provider{

    public:

        //=================================================
        // Constructor/destructor
        //=================================================

        CWin32IRQResource(LPCWSTR name, LPCWSTR pszNamespace);
       ~CWin32IRQResource() ;

        //=================================================
        // Functions provide properties with current values
        //=================================================
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);

#if NTONLY == 4
        HRESULT GetNTIRQ(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#endif
#if defined(WIN9XONLY)
        HRESULT GetWin9XIRQ(MethodContext*  pMethodContext,
                         CInstance *pSpecificInstance );
#endif

#if NTONLY > 4
        HRESULT GetW2KIRQ(
            MethodContext* pMethodContext,
            CInstance* pSpecificInstance);

        void SetNonKeyProps(
            CInstance* pInstance, 
            CDMADescriptor* pDMA);
        
        bool FoundAlready(
            ULONG ulKey,
            std::set<long>& S);

#endif

        //=================================================
        // Utility
        //=================================================
    private:
        bool BitSet(unsigned int iUsed[], ULONG iPos, DWORD iSize);
        void SetCommonProperties(
            CInstance *pInstance,
            DWORD dwIRQ,
            BOOL bHardware);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\implement_logicalfile.cpp ===
//=================================================================

//

// Implement_LogicalFile.CPP -- File property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//=================================================================

//NOTE: The CImplement_LogicalFile class is not exposed to the outside world through the mof. It now has implementations
//		of EnumerateInstances & GetObject which were earlier present in CCimLogicalFile. CImplement_LogicalFile can't be
//		instantiated since it has pure virtual declaration of the IsOneOfMe  method which the derived classes  should
//		implement.

#include "precomp.h"
#include <cregcls.h>
#include "file.h"
#include "Implement_LogicalFile.h"
#include "sid.h"
#include "ImpLogonUser.h"
#include <typeinfo.h>
#include <frqueryex.h>
#include <assertbreak.h>
#include <winioctl.h>
#include "CIMDataFile.h"
#include "Directory.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class
#include "securitydescriptor.h"
#include "securefile.h"

#include "accessentrylist.h"
#include <accctrl.h>
#include "AccessRights.h"
#include "ObjAccessRights.h"

#include "AdvApi32Api.h"
/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::CImplement_LogicalFile
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CImplement_LogicalFile::CImplement_LogicalFile(LPCWSTR setName,
                                 LPCWSTR pszNamespace)
    : CCIMLogicalFile(setName, pszNamespace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::~CImplement_LogicalFile
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CImplement_LogicalFile::~CImplement_LogicalFile()
{
}



CDriveInfo::CDriveInfo()
{
    memset(m_wstrDrive,'\0',sizeof(m_wstrDrive));
    memset(m_wstrFS,'\0',sizeof(m_wstrFS));
}

CDriveInfo::CDriveInfo(WCHAR* wstrDrive, WCHAR* wstrFS)
{
    memset(m_wstrDrive,'\0',sizeof(m_wstrDrive));
    memset(m_wstrFS,'\0',sizeof(m_wstrFS));
    if(wstrDrive != NULL)
    {
        wcsncpy(m_wstrDrive,wstrDrive,(sizeof(m_wstrDrive) - sizeof(WCHAR))/sizeof(WCHAR));

    }
    if(wstrFS != NULL)
    {
        wcsncpy(m_wstrFS,wstrFS,(sizeof(m_wstrFS) - sizeof(WCHAR))/sizeof(WCHAR));
    }
}

CDriveInfo::~CDriveInfo()
{
    long l = 9;   // what?
}


/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CImplement_LogicalFile::GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery& pQuery)
{
    CHString chstrName;
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chstrDrive;
    CHString chstrPathName;

    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // FindFirstFile looks at not only the DACL to
    // decide if a person has access, but at whether
    // that person has the SeTakeOwnershipPrivilege, 
    // because with that privilege, a person can 
    // take ownership and change the security to
    // grant themselves access.  In other words, they
    // have access even though they may not be in
    // the DACL yet, as they are able to change the
    // DACL by making themselves the owner.  Hence
    // the following call...
    EnablePrivilegeOnCurrentThread(SE_BACKUP_NAME);


    pInstance->GetCHString(IDS_Name, chstrName);

    //if(pwcName != NULL)
    if(chstrName.GetLength() > 0)
    {
        if ((chstrName.Find(L':') != -1) &&
            (wcspbrk((LPCWSTR)chstrName,L"?*") == NULL)) //don't want files with wildchars
	    {
            chstrDrive = chstrName.SpanExcluding(L":");
            chstrDrive += L":";
            chstrPathName = chstrName.Mid(chstrDrive.GetLength());

            // Determine whether certain other expensive properties are required:
            DWORD dwReqProps = PROP_NO_SPECIAL;
            DetermineReqProps(pQuery, &dwReqProps);

#ifdef NTONLY
		    {
			    if(chstrPathName.GetLength() == 1) // that is, the pathname is just "\", looking at root, so, actually, no path, or filename
                {
                    hr = FindSpecificPathNT(pInstance, chstrDrive, L"", dwReqProps);
                }
                else
                {
                    hr = FindSpecificPathNT(pInstance, chstrDrive, chstrPathName, dwReqProps);
                }
		    }
#endif
#ifdef WIN9XONLY
            {
			    if(chstrPathName.GetLength() == 1) // that is, the pathname is just "\", looking at root, so, actually, no path, or filename
                {
                    hr = FindSpecificPath95(pInstance, chstrDrive, CHString(_T("")), dwReqProps);
                }
                else
                {
                    hr = FindSpecificPath95(pInstance, chstrDrive, chstrPathName, dwReqProps);
                }
            }
#endif
        }
	}

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::ExecQuery
 *
 *  DESCRIPTION : Analyses query and returns appropriate instances
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CImplement_LogicalFile::ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& pQuery, long lFlags /*= 0L*/ )
{
    std::vector<_bstr_t> vectorNames;  // these are fully qualified path\name.extensions
    std::vector<_bstr_t> vectorDrives;
    std::vector<_bstr_t> vectorPaths;
    std::vector<_bstr_t> vectorFilenames;
    std::vector<_bstr_t> vectorExtensions;
    std::vector<_bstr_t> vector8dot3;
    LONG x;
    LONG y;
    DWORD dwNames;
    DWORD dwDrives;
    DWORD dwPaths;
    DWORD dwFilenames;
    DWORD dwExtensions;
    DWORD dw8dot3;
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL fOpName = FALSE;
    BOOL fOpDrive = FALSE;
    BOOL fOpPath = FALSE;
    BOOL fOpFilename = FALSE;
    BOOL fOpExtension = FALSE;
    BOOL fOp8dot3 = FALSE;
    BOOL fOpSpecificDrivePath = FALSE;
    LONG lDriveIndex;
    bool bRoot = false;
    bool fNeedFS = false;
    std::vector<CDriveInfo*> vecpDI;
    CFrameworkQueryEx *pQuery2 = static_cast <CFrameworkQueryEx *>(&pQuery);  // for use far below to check IfNTokenAnd
    CHStringArray achstrPropNames;
    CHPtrArray aptrPropValues;


    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // FindFirstFile looks at not only the DACL to
    // decide if a person has access, but at whether
    // that person has the SeTakeOwnershipPrivilege, 
    // because with that privilege, a person can 
    // take ownership and change the security to
    // grant themselves access.  In other words, they
    // have access even though they may not be in
    // the DACL yet, as they are able to change the
    // DACL by making themselves the owner.  Hence
    // the following call...
    EnablePrivilegeOnCurrentThread(SE_BACKUP_NAME);


    // Determine whether certain other expensive properties are required:
    DWORD dwReqProps = PROP_NO_SPECIAL;
    DetermineReqProps(pQuery, &dwReqProps);

    if(dwReqProps & PROP_FILE_SYSTEM ||
       dwReqProps & PROP_INSTALL_DATE)
    {
        fNeedFS = true;
    }

    hr = pQuery.GetValuesForProp(IDS_Name, vectorNames);
    // In the case of the name property only (the key), we will not accept anything other than WBEM_S_NO_ERROR.
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Drive, vectorDrives);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Path, vectorPaths);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Filename, vectorFilenames);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_Extension, vectorExtensions);
    }
    if(SUCCEEDED(hr))
    {
        hr = pQuery.GetValuesForProp(IDS_EightDotThreeFileName, vector8dot3);
    }

    if(SUCCEEDED(hr))
    {
        dwNames = vectorNames.size();
        dwDrives = vectorDrives.size();
        dwPaths = vectorPaths.size();
        dwFilenames = vectorFilenames.size();
        dwExtensions = vectorExtensions.size();
        dw8dot3 = vector8dot3.size();

        // Create minterms:
        //if(dwNames > 0 && dwDrives == 0 && dwPaths == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpName = TRUE;
        //if(dwDrives > 0 && dwNames == 0 && dwPaths == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpDrive = TRUE;
        //if(dwPaths > 0 && dwNames == 0 && dwDrives == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpPath = TRUE;
        //if(dwFilenames > 0 && dwNames == 0 && dwDrives == 0 && dwPaths == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpFilename = TRUE;
        //if(dwExtensions > 0 && dwNames == 0 && dwDrives == 0 && dwPaths == 0 && dwFilenames == 0 && dw8dot3 == 0) fOpExtension = TRUE;
        //if(dw8dot3 > 0 && dwNames == 0 && dwDrives == 0 && dwPaths == 0 && dwFilenames == 0 && dwExtensions == 0) fOp8dot3 = TRUE;

        if(dwNames > 0) fOpName = TRUE;
        if(dwDrives > 0) fOpDrive = TRUE;
        if(dwPaths > 0) fOpPath = TRUE;
        if(dwFilenames > 0) fOpFilename = TRUE;
        if(dwExtensions > 0) fOpExtension = TRUE;
        if(dw8dot3 > 0) fOp8dot3 = TRUE;

        // One special type: where we specify a unique path AND a drive:
        if(dwDrives == 1 && dwPaths == 1 && dwNames == 0 && dwFilenames == 0 && dwExtensions == 0 && dw8dot3 == 0) fOpSpecificDrivePath = TRUE;

        // Before proceeding: if drives were specified, we need to confirm that they
        // were specified using the correct syntax - namely, 'c:', not anything else,
        // such as 'c:\' (bug WMI RAID #676).
        if(dwDrives > 0)
        {
            _bstr_t bstrtCopy;
            for(long z = 0;
                z < dwDrives && SUCCEEDED(hr);
                z++)
            {
                bstrtCopy = vectorDrives[z];
                WCHAR wstrBuf[_MAX_DRIVE + 1] = { L'\0' };
                wcsncpy(wstrBuf, (LPWSTR)bstrtCopy, _MAX_DRIVE);
                if(wcslen(wstrBuf) != 2 ||
                    wstrBuf[1] != L':')
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }    
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        // We will optimize on the five optimization variables set above.  If none
        // were set, enumerate all instances and let CIMOM sort it out.

        // Our top candidate is the most restrictive case, where we are optimizing on a specific file(s)...
        if(fOpName)
        {
            // In this case we were given one or more fully qualified pathnames.
            // So we just need to look for those files.

            WCHAR* pwch;
            WCHAR* pwstrFS;
            // For all the specific files, get the info
            //for(x=0; (x < dwNames) && (SUCCEEDED(hr)); x++)
            for(x=0; x < dwNames; x++)
            {
                pwstrFS = NULL;
                // if the name contained a wildcard character, return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vectorNames[x],L"?*") != NULL)
                {
                    FreeVector(vecpDI);
                    return WBEM_E_INVALID_QUERY;
                }

                pwch = NULL;
                _bstr_t bstrtTemp = vectorNames[x];
                pwch = wcsstr((wchar_t*)bstrtTemp,L":");
                if(pwch != NULL)
                {
                    WCHAR wstrDrive[_MAX_PATH] = L"";
                    WCHAR wstrDir[_MAX_PATH] = L"";
                    WCHAR wstrFile[_MAX_PATH] = L"";
                    WCHAR wstrExt[_MAX_PATH] = L"";

                    _wsplitpath(bstrtTemp,wstrDrive,wstrDir,wstrFile,wstrExt);

                    // Get listing of drives and related info (only if the file system is needed - which it is, by the way, if AccessMask
                    // is needed, because accessmask setting logic depends on whether ntfs or fat. ibid the various dates. DetermineReqProps
                    // will account for this by modifying the dwReqProps value to include PROP_FILE_SYSTEM if necessary.):
                    if(fNeedFS)
                    {
                        GetDrivesAndFS(vecpDI, true, wstrDrive);

                        if(!GetIndexOfDrive(wstrDrive, vecpDI, &lDriveIndex))
                        {
                            FreeVector(vecpDI);
                            return WBEM_E_NOT_FOUND;
                        }
                        else
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // Find out if we are looking for the root directory
                    if(wcscmp(wstrDir,L"\\")==0 && wcslen(wstrFile)==0 && wcslen(wstrExt)==0)
                    {
                        bRoot = true;
                        // If we are looking for the root, our call to EnumDirs presumes that we specify
                        // that we are looking for the root directory with "" as the path, not "\\".
                        // Therefore...
                        wcscpy(wstrDir, L"");
                    }
                    else
                    {
                        bRoot = false;
                    }

                    // We should have been given the exact name of a file, with an extension.
                    // Therefore, the wstrDir now contains the path, filename, and extension.
                    // Thus, we can pass it into EnumDirsNT as the path, and an empty string
                    // as the completetionstring parameter, and still have a whole pathname
                    // for FindFirst (in EnumDirs) to work with.

                    //CInstance *pInstance = CreateNewInstance(pMethodContext);
#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        wstrDrive,
                                        wstrDir,
                                        wstrFile,
                                        wstrExt,
                                        false,                 // no recursion desired
                                        pwstrFS,
                                        dwReqProps,
                                        bRoot,
                                        NULL));
			        }
#endif
#ifdef WIN9XONLY
			        {
                        hr = EnumDirs95(C95EnumParm(pMethodContext,
                                        TOBSTRT(wstrDrive),
                                        TOBSTRT(wstrDir),
                                        TOBSTRT(wstrFile),
                                        TOBSTRT(wstrExt),
                                        false,                 // no recursion desired
                                        ((pwstrFS != NULL) ? (LPTSTR)TOBSTRT(pwstrFS) : NULL),
                                        dwReqProps,
                                        bRoot,
                                        NULL));
                    }
#endif
                }

            }
        }
        // Second choice is where we optimize on an EightDotThree filename(s) (which is just as restrictive as Name)...
        else if(fOp8dot3)
        {
            // In this case we were given one or more fully qualified pathnames.
            // So we just need to look for those files.

            WCHAR* pwch;
            WCHAR* pwstrFS;
            for(x=0; x < dw8dot3; x++)
            {
                pwstrFS = NULL;
                // if the name contained a wildcard character, return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vector8dot3[x],L"?*") != NULL)
                {
                    FreeVector(vecpDI);
                    return WBEM_E_INVALID_QUERY;
                }

                pwch = NULL;
			    _bstr_t bstrtTemp = vector8dot3[x];
                pwch = wcsstr((wchar_t*)bstrtTemp,L":");
                if(pwch != NULL)
                {
				    WCHAR wstrDrive[_MAX_PATH] = L"";
                    WCHAR wstrDir[_MAX_PATH] = L"";
                    WCHAR wstrFile[_MAX_PATH] = L"";
                    WCHAR wstrExt[_MAX_PATH] = L"";


                    _wsplitpath(bstrtTemp,wstrDrive,wstrDir,wstrFile,wstrExt);

                    // Get listing of drives and related info (only if the file system is needed - which it is, by the way, if AccessMask
                    // is needed, because accessmask setting logic depends on whether ntfs or fat. ibid the various dates. DetermineReqProps
                    // will account for this by modifying the dwReqProps value to include PROP_FILE_SYSTEM if necessary.):
                    if(fNeedFS)
                    {
                        GetDrivesAndFS(vecpDI, true, wstrDrive);

                        if(!GetIndexOfDrive(wstrDrive, vecpDI, &lDriveIndex))
                        {
                            FreeVector(vecpDI);
                            return WBEM_E_NOT_FOUND;
                        }
                        else
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // Find out if we are looking for the root directory
                    if(wcscmp(wstrDir,L"\\")==0 && wcslen(wstrFile)==0 && wcslen(wstrExt)==0)
                    {
                        bRoot = true;
                        // If we are looking for the root, our call to EnumDirs presumes that we specify
                        // that we are looking for the root directory with "" as the path, not "\\".
                        // Therefore...
                        wcscpy(wstrDir, L"");
                    }
                    else
                    {
                        bRoot = false;
                    }

                    // We should have been given the exact name of a file, with an extension.
                    // Therefore, the wstrDir now contains the path, filename, and extension.
                    // Thus, we can pass it into EnumDirsNT as the path, and an empty string
                    // as the completetionstring parameter, and still have a whole pathname
                    // for FindFirst (in EnumDirs) to work with.

                    //CInstance *pInstance = CreateNewInstance(pMethodContext);
#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        wstrDrive,
                                        wstrDir,
                                        wstrFile,
                                        wstrExt,
                                        false,       // no recursion desired
                                        pwstrFS,
                                        dwReqProps,
                                        bRoot,
                                        NULL));
			        }
#endif
#ifdef WIN9XONLY
			        {
                        hr = EnumDirs95(C95EnumParm(pMethodContext,
                                        TOBSTRT(wstrDrive),
                                        TOBSTRT(wstrDir),
                                        TOBSTRT(wstrFile),
                                        TOBSTRT(wstrExt),
                                        false,                 // no recursion desired
                                        ((pwstrFS != NULL) ? (LPCTSTR)TOBSTRT(pwstrFS) : NULL),
                                        dwReqProps,
                                        bRoot,
                                        NULL));
                    }
#endif
                }
            }
        }
        // Third choice is an NTokenAnd, since it might be more restrictive than any of the other styles that follow...
        else if(pQuery2->IsNTokenAnd(achstrPropNames, aptrPropValues))
        {
            // We got ourselves a good ol' fashioned NTokenAnd query.
            // Need to look at what we were given.  Will only accept as prop names any of the following:
            //   "Drive", "Path", "Filename", or "Extension".
            // So first, go through achstrPropNames and make sure each is one of the above...
            bool fSpecifiedDrive = false;
            bool fRecurse = true;
            long lDriveIndex = -1L;
            CHString chstrDrive = _T("");
            CHString chstrPath = _T("");
            CHString chstrFilename = _T("*");
            CHString chstrExtension = _T("*");

            for(short s = 0; s < achstrPropNames.GetSize(); s++)
            {
                // A note on the lines like if(dwDrives > 0) below:
                // An NTokenAnd query can only have AND expressions,
                // no ORs.  Therefore, the greatest the value any of 
                // the variables like dwDrives can be is 1.
                if(achstrPropNames[s].CompareNoCase(IDS_Drive) == 0)
                {
                    // We may have had a query like "select * from cim_logicalfile where extension = "txt" and drive = NULL",
                    // in which case dwDrives will be zero, and aptrPropValues will contain a variant of type VT_NULL.  VT_NULLs
                    // don't go into _bstr_t all that well, so protect ourselves.  Still do an ntokenand, as it is too late
                    // to attempt another optimization.
                    if(dwDrives > 0L)
                    {
                        chstrDrive = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                        fSpecifiedDrive = true;

                        if(fNeedFS)
                        {
                            GetDrivesAndFS(vecpDI, fNeedFS, chstrDrive);
                            if(!GetIndexOfDrive(TOBSTRT(chstrDrive), vecpDI, &lDriveIndex))
                            {
                                FreeVector(vecpDI);
                                return WBEM_E_NOT_FOUND;
                            }
                        }
                    }
                }
                else if(achstrPropNames[s].CompareNoCase(IDS_Path) == 0)
                {
                    if(dwPaths > 0L) // see the comment above
                    {
                        chstrPath = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                        fRecurse = false;
                    }
                }
                else if(achstrPropNames[s].CompareNoCase(IDS_Filename) == 0)
                {
                    if(dwFilenames > 0L)
                    {
                        chstrFilename = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                    }
                }
                else if(achstrPropNames[s].CompareNoCase(IDS_Extension) == 0)
                {
                    if(dwExtensions > 0L)
                    {
                        chstrExtension = (wchar_t*)_bstr_t(*((variant_t*)aptrPropValues[s]));
                    }
                }
            }

            // If no drive was specified, we need to get the set of drives.
            if(!fSpecifiedDrive)
            {
                GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?
            }


            unsigned int sNumDrives;
            (chstrDrive.GetLength() == 0) ? sNumDrives = vecpDI.size() : sNumDrives = 1;

            for(x = 0; x < sNumDrives; x++)
            {
#ifdef NTONLY
                hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                fSpecifiedDrive ? chstrDrive : (WCHAR*)vecpDI[x]->m_wstrDrive,
                                chstrPath,                         // start either at the root (path = "") or at wherever they specified
                                chstrFilename,                     // filename
                                chstrExtension,                    // extension
                                fRecurse,                          // recursion desired
                                fNeedFS ? (fSpecifiedDrive ? (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS : (WCHAR*)vecpDI[x]->m_wstrFS) : NULL,
                                dwReqProps,
                                (chstrPath.GetLength() == 0) ? true : false,
                                NULL));                            // no more data
#endif
#ifdef WIN9XONLY
                hr = EnumDirs95(C95EnumParm(pMethodContext,
                                fSpecifiedDrive ? TOBSTRT(chstrDrive) : (WCHAR*)vecpDI[x]->m_wstrDrive,
                                TOBSTRT(chstrPath),                // start either at the root (path = "") or at wherever they specified
                                TOBSTRT(chstrFilename),            // filename
                                TOBSTRT(chstrExtension),           // extension
                                fRecurse,                          // recursion desired
                                fNeedFS ? ( fSpecifiedDrive ? TOBSTRT( (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS ) : TOBSTRT( (WCHAR*)vecpDI[x]->m_wstrFS ) ) : TOBSTRT(_T("")),
                                dwReqProps,
                                (chstrPath.GetLength() == 0) ? true : false,
                                NULL));                            // no more data
#endif
            }  // for all drives required

            // Free up results of IsNTokenAnd call...
            for (s = 0; s < aptrPropValues.GetSize(); s++)
            {
                delete aptrPropValues[s];
            }
            aptrPropValues.RemoveAll();
        }

        // Fourth choice is where we optimize on a drive and a path(s)...
        else if(fOpSpecificDrivePath)
        {
            // This time we were given one or more specific paths to enumerate all
            // the files in (including subdirectories).  The paths look like:
            // "\\windows\\" or "\\system32\\", including the leading AND trailing
            // backslashes.  We need to look for these paths on all drives.

            WCHAR* pwstrFS;

            if(fNeedFS)
            {
                GetDrivesAndFS(vecpDI, true, vectorDrives[0]);
            }            

            //for(x = 0; x < vecpDI.size(); x++)     // for specified drive only
            {
                //for(y = 0; y < dwPaths; y++)         // for specified path only
                {
                    pwstrFS = NULL;
                    // If the path contained a wildcard character (you never know!),
                    if(wcspbrk((wchar_t*)vectorPaths[0],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    if(!GetIndexOfDrive(vectorDrives[0], vecpDI, &lDriveIndex))
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_NOT_FOUND;
                    }
                    else
                    {
                        if(fNeedFS)
                        {
                            pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                        }
                    }

                    // See if we are looking at the root:
                    if(wcscmp((wchar_t*)vectorPaths[0],L"") == 0)
                    {
                        bRoot = true;
                    }


#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (wchar_t*)vectorDrives[0],
                                        (wchar_t*)vectorPaths[0],   // use the given path
                                        L"*",                       // filename
                                        L"*",                       // extension
                                        false,                      // no recursion desired
                                        pwstrFS,
                                        dwReqProps,
                                        bRoot,
                                        NULL));
			        }
#endif
#ifdef WIN9XONLY
			        {
                        hr = EnumDirs95(C95EnumParm(pMethodContext,
                                        TOBSTRT((wchar_t*)vectorDrives[0]),
                                        TOBSTRT((wchar_t*)vectorPaths[0]),   // use the given path
                                        _T("*"),                              // filename
                                        _T("*"),                              // extension
                                        false,                                // no recursion desired
                                        ((pwstrFS != NULL) ? (LPCTSTR)TOBSTRT(pwstrFS) : NULL),
                                        dwReqProps,
                                        bRoot,
                                        NULL));
                    }
#endif
                }
            }
        }
        // Fifth choice is where we optimize on a specific path(s)...
        else if(fOpPath)
        {
            // This time we were given one or more specific paths to enumerate all
            // the files in (including subdirectories).  The paths look like:
            // "\\windows\\" or "\\system32\\", including the leading AND trailing
            // backslashes.  We need to look for these paths on all drives.

            GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?

            for(x = 0; x < vecpDI.size(); x++)     // for all drives
            {
                for(y = 0; y < dwPaths; y++)         // for all supplied paths
                {
                    // If the path contained a wildcard character (you never know!),
                    // return WBEM_E_INVALID_QUERY:
                    if(wcspbrk((wchar_t*)vectorPaths[y],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    // See if we are looking at the root:
                    if(wcscmp((wchar_t*)vectorPaths[y],L"") == 0)
                    {
                        bRoot = true;
                    }


#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (WCHAR*)vecpDI[x]->m_wstrDrive,
                                        (WCHAR*)vectorPaths[y],     // use the given path
                                        L"*",                       // filename
                                        L"*",                       // extension
                                        false,                      // no recursion desired
                                        fNeedFS ? (WCHAR*)vecpDI[x]->m_wstrFS : NULL,
                                        dwReqProps,
                                        bRoot,
                                        NULL));

			        }
#endif
#ifdef WIN9XONLY
			        {
                        hr = EnumDirs95(C95EnumParm(pMethodContext,
                                        TOBSTRT((WCHAR*)vecpDI[x]->m_wstrDrive),
                                        TOBSTRT((WCHAR*)vectorPaths[y]),     // use the given path
                                        _T("*"),                              // filename
                                        _T("*"),                              // extension
                                        false,                                // no recursion desired
                                        fNeedFS ? TOBSTRT((WCHAR*)vecpDI[x]->m_wstrFS) : TOBSTRT(_T("")),
                                        dwReqProps,
                                        bRoot,
                                        NULL));

                    }
#endif
                }
            }
        }
        // Fifth choice is where we optimize on a specific filename(s)...
        else if(fOpFilename)
        {
            // In this case we were given one or more file names.  The file name
            // is just the name - no extension, no path, no drive.  For example,
            // "autoexec", or "win".  So this time I want to examine all drives,
            // all paths (recursively), for all files of that name, with any
            // extension.
            
            GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?

            for(x = 0; x < vecpDI.size(); x++)     // for all drives
            {
                for(y = 0; y < dwFilenames; y++)     // for all supplied filenames
                {
                    // If the filename contained a wildcard character (you never know!),
                    if(wcspbrk((wchar_t*)vectorFilenames[y],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    // If we specified "" as the filename, the root qualifies. Otherwise it doesn't.
                    if(wcslen((wchar_t*)vectorFilenames[y]) == 0)
                    {
                        bRoot = true;
                    }
                    else
                    {
                        bRoot = false;
                    }

#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (WCHAR*)vecpDI[x]->m_wstrDrive,
                                        L"",                          // start at the root
                                        (wchar_t*)vectorFilenames[y], // filename
                                        L"*",                          // extension
                                        true,                         // recursion desired
                                        fNeedFS ? (WCHAR*)vecpDI[x]->m_wstrFS: NULL,
                                        dwReqProps,
                                        bRoot,
                                        NULL));

			        }
#endif
#ifdef WIN9XONLY
			        {
                        hr = EnumDirs95(C95EnumParm(pMethodContext,
                                        TOBSTRT((WCHAR*)vecpDI[x]->m_wstrDrive),
                                        _T(""),                                 // start at the root
                                        TOBSTRT((wchar_t*)vectorFilenames[y]), // filename
                                        _T("*"),                                 // extension
                                        true,                                   // recursion desired
                                        fNeedFS ? TOBSTRT((WCHAR*)vecpDI[x]->m_wstrFS) : TOBSTRT(_T("")),
                                        dwReqProps,
                                        bRoot,
                                        NULL));

                    }
#endif
                }
            }
        }
        // Sixth choice is where we optimize on a specific drive(s)...
        else if(fOpDrive)   // We are optimizing on a specific drive:
        {
            // In this case we were given one or more drive letters, so need to
            // enumerate all files in all paths on those drive(s).
            WCHAR* pwstrFS;

            for(x=0; x < dwDrives; x++)
            {
                pwstrFS = NULL;

                // If the drive contained a wildcard character (you never know!),
                // return WBEM_E_INVALID_QUERY:
                if(wcspbrk((wchar_t*)vectorDrives[x],L"?*") != NULL)
                {
                    FreeVector(vecpDI);
                    return WBEM_E_INVALID_QUERY;
                }

                GetDrivesAndFS(vecpDI, fNeedFS);

                if(!GetIndexOfDrive(vectorDrives[x], vecpDI, &lDriveIndex))
                {
                    FreeVector(vecpDI);
                    return WBEM_E_NOT_FOUND;
                }
                else
                {
                    if(fNeedFS)
                    {
                        pwstrFS = (WCHAR*)vecpDI[lDriveIndex]->m_wstrFS;
                    }
                }

#ifdef NTONLY
			    {
                    hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                    vectorDrives[x],
                                    L"",          // start at the root
                                    L"*",         // filename
                                    L"*",         // extension
                                    true,         // recursion desired
                                    pwstrFS,
                                    dwReqProps,
                                    true,
                                    NULL));        // true because we are starting at the root
			    }
#endif
#ifdef WIN9XONLY
			    {
                    hr = EnumDirs95(C95EnumParm(pMethodContext,
                                    TOBSTRT((wchar_t*)vectorDrives[x]),
                                    _T(""),       // start at the root
                                    _T("*"),      // filename
                                    _T("*"),      // extension
                                    true,         // recursion desired
                                    ((pwstrFS != NULL) ? (LPCTSTR)TOBSTRT(pwstrFS) : NULL),
                                    dwReqProps,
                                    true,
                                    NULL));        // true because we are starting at the root
                }
#endif
            }
        }
        // And the last choice is where we optimize on a specific extension(s)...
        else if(fOpExtension)
        {
            // In this case we were given one or more files with a given extension
            // to search for, on any drive, in any directory.  So again, examine
            // all drives, all directories (recursively) for all files with the
            // given extension.
            GetDrivesAndFS(vecpDI, fNeedFS);  // can't find files on all drives without knowing what drives there are now can we?

            for(x = 0; x < vecpDI.size(); x++)     // for all drives
            {
                for(y = 0; y < dwExtensions; y++)     // for all supplied extensions
                {
                    // If the extension contained a wildcard character (you never know!),
                    // return WBEM_E_FAILED:
                    if(wcspbrk((wchar_t*)vectorExtensions[y],L"?*") != NULL)
                    {
                        FreeVector(vecpDI);
                        return WBEM_E_INVALID_QUERY;
                    }

                    // If we specified "" as the extension, the root qualifies. Otherwise it doesn't.
                    if(wcslen((wchar_t*)vectorExtensions[y]) == 0)
                    {
                        bRoot = true;
                    }
                    else
                    {
                        bRoot = false;
                    }

#ifdef NTONLY
			        {
                        hr = EnumDirsNT(CNTEnumParm(pMethodContext,
                                        (WCHAR*)vecpDI[x]->m_wstrDrive,
                                        L"",                           // start at the root
                                        L"*",                          // filename
                                        (wchar_t*)vectorExtensions[y], // extension
                                        true,                          // recursion desired
                                        fNeedFS ? (WCHAR*)vecpDI[x]->m_wstrFS : NULL,
                                        dwReqProps,
                                        bRoot,
                                        NULL));                        // false because, if there is an extension, it can't be the root
			        }
#endif
#ifdef WIN9XONLY
			        {
                        hr = EnumDirs95(C95EnumParm(pMethodContext,
                                        TOBSTRT((WCHAR*)vecpDI[x]->m_wstrDrive),
                                        _T(""),                                      // start at the root
                                        _T("*"),                                     // filename
                                        TOBSTRT((wchar_t*)vectorExtensions[y]), // extension
                                        true,                                    // recursion desired
                                        fNeedFS ? TOBSTRT((WCHAR*)vecpDI[x]->m_wstrFS) : TOBSTRT(_T("")),
                                        dwReqProps,
                                        bRoot,
                                        NULL));                                  // false because, if there is an extension, it can't be the root
                    }
#endif
                }
            }
        }
        // Last choice: enumeration.
        else  // let CIMOM handle filtering; we'll hand back everything!
        {
            EnumerateInstances(pMethodContext);
        }
    } // succeeded on GetValuesForProp calls

    FreeVector(vecpDI);


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetDrivesAndFS
 *
 *  DESCRIPTION : Creates a list of valid drives and their respective file
 *                system.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : The caller must free the members of the array (pointers to
 *                CDriveInfo class).
 *
 *****************************************************************************/
void CImplement_LogicalFile::GetDrivesAndFS(
    std::vector<CDriveInfo*>& vecpDI, 
    bool fGetFS /*=false*/, 
    LPCTSTR tstrDriveSet /*= NULL*/)
{
    TCHAR tstrDrive[4];
    int x;
    DWORD dwDrives;
    bool bContinue = true;

    // Walk all the logical drives
    dwDrives = GetLogicalDrives();

    TCHAR tstrFSName[_MAX_PATH];

    for(x=0; (x < 32) && (bContinue); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            tstrDrive[0] = x + _T('A');
            tstrDrive[1] = _T(':');
            tstrDrive[2] = _T('\\');
            tstrDrive[3] = _T('\0');

            if(!tstrDriveSet)
            {
                // Only local drives
                if(IsValidDrive(tstrDrive))
                {
                    BOOL bRet = TRUE;
                    if(fGetFS)
                    {
                        try
                        {
                            bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                        }
                        catch ( ... )
                        {
                            bRet = FALSE;
                        }
                    }

                    if(bRet)
                    {
                        tstrDrive[2] = '\0';
                        CDriveInfo* pdi = (CDriveInfo*) new CDriveInfo((WCHAR*)_bstr_t((TCHAR*)tstrDrive),
                                                                       (fGetFS && bRet) ? (WCHAR*)_bstr_t((TCHAR*)tstrFSName) : NULL);
                        vecpDI.push_back(pdi);
                        // Notice that pdi is not destroyed - it gets
                        // destroyed by the caller!.
                    }
                }
            }
            else // We were given a set of drives to be concerned with (in the form a:c:f:z:)
            {
                CHString chstrDriveSet(tstrDriveSet);
                CHString chstrDrive(tstrDrive);
                chstrDriveSet.MakeUpper();
                chstrDrive = chstrDrive.Left(2);
                if(chstrDriveSet.Find(chstrDrive) != -1L)
                {
                    // Only local drives
                    if(IsValidDrive(tstrDrive))
                    {
                        BOOL bRet = TRUE;
                        if(fGetFS)
                        {
                            try
                            {
                                bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                            }
                            catch ( ... )
                            {
                                bRet = FALSE;
                            }
                        }

                        if(bRet)
                        {
                            tstrDrive[2] = '\0';
                            CDriveInfo* pdi = (CDriveInfo*) new CDriveInfo((WCHAR*)_bstr_t((TCHAR*)tstrDrive),
                                                                           (fGetFS && bRet) ? (WCHAR*)_bstr_t((TCHAR*)tstrFSName) : NULL);
                            vecpDI.push_back(pdi);
                            // Notice that pdi is not destroyed - it gets
                            // destroyed by the caller!.
                        }
                    }
                }
            }
        }
    }
}


/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::FreeVector
 *
 *  DESCRIPTION : Frees vector members and clears the vector.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
void CImplement_LogicalFile::FreeVector(std::vector<CDriveInfo*>& vecpDI)
{
    for(long l = 0L; l < vecpDI.size(); l++)
    {
          delete vecpDI[l];
    }
    vecpDI.clear();
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetIndexOfDrive
 *
 *  DESCRIPTION : Obtains the array index of the passed in drive
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
BOOL CImplement_LogicalFile::GetIndexOfDrive(const WCHAR* wstrDrive,
                                      std::vector<CDriveInfo*>& vecpDI,
                                      LONG* lDriveIndex)
{
    // Go through the vector of drive letters, looking for the one passed in.
    // If I find it, return the associated drive's array index.
    for(LONG j = 0; j < vecpDI.size(); j++)
    {
        if(_wcsicmp(wstrDrive, _bstr_t((vecpDI[j]->m_wstrDrive))) == 0)
        {
            *lDriveIndex = j;
            return TRUE;
        }
    }
    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CImplement_LogicalFile::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    // DEVNOTE: REMOVE FOR QUASAR!!!  Necessary for double hop access.
#ifdef NTONLY
    bool fImp = false;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif


    // FindFirstFile looks at not only the DACL to
    // decide if a person has access, but at whether
    // that person has the SeTakeOwnershipPrivilege, 
    // because with that privilege, a person can 
    // take ownership and change the security to
    // grant themselves access.  In other words, they
    // have access even though they may not be in
    // the DACL yet, as they are able to change the
    // DACL by making themselves the owner.  Hence
    // the following call...
    EnablePrivilegeOnCurrentThread(SE_BACKUP_NAME);

	EnumDrives(pMethodContext, NULL);


#ifdef NTONLY
    if(fImp)
    {
        icu.End();
        fImp = false;
    }
#endif


	return WBEM_S_NO_ERROR ;
}

void CImplement_LogicalFile::EnumDrives(MethodContext *pMethodContext, LPCTSTR pszPath)
{
    TCHAR tstrDrive[4];
    int x;
    DWORD dwDrives;
    TCHAR tstrFSName[_MAX_PATH];
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRoot = false;


    // Walk all the logical drives
    dwDrives = GetLogicalDrives();
    for (x=0; (x < 32) && SUCCEEDED(hr); x++)
    {
        // If the bit is set, the drive letter is active
        if (dwDrives & (1<<x))
        {
            tstrDrive[0] = x + _T('A');
            tstrDrive[1] = _T(':');
            tstrDrive[2] = _T('\\');
            tstrDrive[3] = _T('\0');

            // Only local drives
            if (IsValidDrive(tstrDrive))
            {
                BOOL bRet;
                try
                {
                    bRet = GetVolumeInformation(tstrDrive, NULL, 0, NULL, NULL, NULL, tstrFSName, sizeof(tstrFSName)/sizeof(TCHAR));
                }
                catch ( ... )
                {
                    bRet = FALSE;
                }

                if (bRet)
                {
                   tstrDrive[2] = '\0';
                    // If we were asked for a specific path, then we don't want to recurse, else
                    // start from the root.
                    if (pszPath == NULL)
                    {
#ifdef NTONLY
				        {
						    bstr_t bstrDrive(tstrDrive);
                            bstr_t bstrName(tstrFSName);
                            {
                                CNTEnumParm p(pMethodContext, bstrDrive, L"", L"*", L"*", true, bstrName, PROP_ALL_SPECIAL, true, NULL);
					            hr = EnumDirsNT(p);
                            }
				        }
#endif
#ifdef WIN9XONLY
                        {
                            C95EnumParm p(pMethodContext, tstrDrive, _T(""), _T("*"), _T("*"), true, tstrFSName, PROP_ALL_SPECIAL, true, NULL);
					 	    hr = EnumDirs95(p);
                        }
#endif
                    }
                    else
                    {
#ifdef NTONLY
				        {
						    bstr_t bstrName ( tstrFSName ) ;
						    bstr_t bstrDrive ( tstrDrive ) ;
					   	    bstr_t bstrPath ( pszPath ) ;
                            {
                                CNTEnumParm p(pMethodContext, bstrDrive, bstrPath, L"*", L"*", false, bstrName, PROP_ALL_SPECIAL, true, NULL);
					   	        hr = EnumDirsNT(p);
                            }
				        }
#endif
#ifdef WIN9XONLY
                        {
                            C95EnumParm p(pMethodContext, tstrDrive, pszPath, _T("*"), _T("*"), false, tstrFSName, PROP_ALL_SPECIAL, true, NULL);
					        hr = EnumDirs95(p);
                        }
#endif
                    }

                }
            }
        }
        // Under certain conditions, we want to continue enumerating other drives even if we
        // received certain errors.
        if(hr == WBEM_E_ACCESS_DENIED || hr == WBEM_E_NOT_FOUND)
		{
			hr = WBEM_S_NO_ERROR;
		}
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::EnumDirs
 *
 *  DESCRIPTION : Walks the dirs on a specific drive
 *
 *  INPUTS      : pszDrive is of the format "c:", path is of the format "\" or "\dos"
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : WBEM_E_FAILED (some generic problem - quit); WBEM_E_ACCESS_DENIED
 *                (access denied to file - continue along with next);
 *                WBEM_S_NO_ERROR (no problemo); WBEM_E_NOT_FOUND (couldn't find
 *                the file); WBEM_E_INVALID_PARAMETER (one or more parts of the
 *                file name was not valid).
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CImplement_LogicalFile::EnumDirs95(C95EnumParm& p)
{
    TCHAR szBuff[_MAX_PATH];
    WIN32_FIND_DATA stFindData;
    SmartFindClose hFind;
	CInstancePtr pInstance;
	TCHAR* pc = NULL;
	bool bWildFile = false;
	bool bWildExt = false;
	CHString chstrFullPathName;
	HRESULT hr = WBEM_S_NO_ERROR;
	bool fDone = false;

	// Before proceeding further:  if we are not looking at the root "directory",
	// then the path arguement must have BOTH leading AND trailing backslashes.
	// If not, it was misspecified, so get the @#%$^% out of Dodge:
	if(!IsValidPath(p.m_pszPath, p.m_bRoot))
	{
		return WBEM_E_INVALID_PARAMETER;
	}


	// Determine if filename and or extension are a wildchar:
	if(_tcscmp(p.m_pszFile, _T("*")) == 0) bWildFile = true;
	if(_tcscmp(p.m_pszExt, _T("*")) == 0) bWildExt = true;

	ZeroMemory(&stFindData,sizeof(stFindData));
	ZeroMemory(szBuff,sizeof(szBuff));

	// One simple case is where neither bWildFile nor bWildExt
	// are true.  In that case we are looking for a specific
	// file only. If this is the case, we are done once the
	// following block executes (whether the file is found or
	// not), so indicate as such at the end.

	if(!(bWildFile || bWildExt || p.m_bRoot) && !p.m_bRecurse)
	{
		// Assemble pathname - we have all the pieces.
		_tcscpy(szBuff,p.m_pszDrive);
		_tcscat(szBuff,p.m_pszPath);
		_tcscat(szBuff,p.m_pszFile);
        if(_tcslen(szBuff) > 0)
        {
		    _tcscat(szBuff,_T("."));
            _tcscat(szBuff,p.m_pszExt);
        }

		// Do the find
		hFind = FindFirstFile(szBuff, &stFindData);

		// If the find failed and we are not recursing (we were interested only in
		// looking at one particular path), indicate that we should not continue.
		//DWORD dw = GetLastError();
		if (hFind == INVALID_HANDLE_VALUE/* || dw != ERROR_SUCCESS*/)
		{
			hr = WinErrorToWBEMhResult(GetLastError());
		}

		if(SUCCEEDED(hr))
		{
			// We found it, so fill in the values and commit it.
			pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

			// FindClose(hFind);  // DONE AT BOTTOM
			chstrFullPathName = p.m_pszDrive;
			if(_tcslen(p.m_pszPath) == 0) // were dealing with the root dir; need "\\" before file name
			{
				chstrFullPathName += _T("\\");
			}
			else
			{
				chstrFullPathName += p.m_pszPath;
			}
			chstrFullPathName += stFindData.cFileName;

			// Return regardless (we were only looking for one file):
			if(IsOneOfMe(&stFindData,TOBSTRT(chstrFullPathName)))
			{
				// The following is done for compatability with cases in which we did an 8dot3 optimization.
				// Only szBuff contains the proper, 8dot3 filename (stfindData contains both - how would we
				// know which to use?).  Thus load it here, then extact it there, and use it if present.
                // Note that some derived classes (such as Win32LogicalFileSecuritySetting) may not have a
                // Name property to set - hence the following check.
                bool fHasNameProp = false;
                VARTYPE vt = VT_BSTR;
                if(pInstance->GetStatus(IDS_Name, fHasNameProp, vt) && fHasNameProp)
                {
					pInstance->SetCharSplat(IDS_Name,szBuff);
                }

				//LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				if(_tcslen(p.m_pszPath) == 0)
				{
					LoadPropertyValues95(pInstance, p.m_pszDrive, _T("\\"), p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				}
				else
				{
					LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				}
				hr = pInstance->Commit () ;
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
		}
		fDone = true;
	}
	if(p.m_bRoot && !fDone)
	{
		// Another simple case is where we are looking for the root directory itself.
		pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

        // If the szFSName parameter is NULL, we never got the file system name, perhaps
        // because that property was not required.  However, normally when we do get the
        // FSName, we call GetDrivesAndFS, and it is only through that call that we
        // confirm that the specified drive even exists!  Here, however, we can get away
        // with confirming that the specific drive of interest is valid via a call to IsValidDrive.
		if(p.m_szFSName == NULL || _tcslen(p.m_szFSName)==0)
        {
            _bstr_t bstrtTmp;
            bstrtTmp = p.m_pszDrive;
            bstrtTmp += _T("\\");
            if(!IsValidDrive(bstrtTmp))
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }

		if(SUCCEEDED(hr))
		{
			chstrFullPathName = p.m_pszDrive;
			chstrFullPathName += p.m_pszPath;
			if(IsOneOfMe((LPWIN32_FIND_DATA)NULL,TOBSTRT(chstrFullPathName)))
			{
				LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, NULL, p.m_dwReqProps, p.m_pvMoreData);
				hr = pInstance->Commit () ;
			}
		}

		// In this case, if we aren't recursing, we are done. Otherwise, continue.
		// NO! That would cause only the root to be returned; what if the query had
		// been "select * from cim_logicalfile where path = "\\" ?  Then we want
		// all files and directories off of the root directory, in addition to the root.
		// YES! (after revising root's path to be empty by definition, and after
		// revising the test that sets bRoot to compare to an empty string rather than
		// to "\\") Do want to stop if root, as now no ambiguity between the root dir
		// and files hanging off the root. Previously there was, since both had a path
		// of "\\".  Now the root's path is "", while the path of files off of the root
		// is "\\".  So, un-commenting out the following lines:
		if(!p.m_bRecurse)
		{
			fDone = true;
		}
	}


	// If we are recursing and all is well, we're not done yet!
	if(!fDone && SUCCEEDED(hr))
	{
		// The more involved case if that for which either bWildFile or bWildExt
		// is true.  We need to find matching files or extensions or both potentially
		// in all directories.

		// Start by assembling a path, but use wildcards for the filename and extension.
		_tcscpy(szBuff,p.m_pszDrive);
		if(_tcslen(p.m_pszPath) == 0)  // path was the root - need leading "\\"
		{
			_tcscat(szBuff,_T("\\"));
		}
		else
		{
			_tcscat(szBuff,p.m_pszPath);
		}
		_tcscat(szBuff,_T("*.*"));

		// Do the find
		hFind = FindFirstFile(szBuff, &stFindData);

		if(hFind == INVALID_HANDLE_VALUE)
		{
			// The intended logic here is as follows:  if we have an invalid handle, we
			// need to return at this point no matter what.  However, if we just got an
			// access denied error, we want to return a value that will allow us to keep
			// iterating (presumably at the next higher node in the directory structure),
			// as opposed to returning a false, which would get propegated out of all
			// recursed calls and prematurely abort the iteration unnescessarily.
			hr = WinErrorToWBEMhResult(GetLastError());
		}
		else
		{
			// Walk the directory tree
			do
			{
				if( (_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
					(_tcscmp(stFindData.cFileName, _T("..")) != 0))
				{
					// If both bWildFile and bWildExt are true, it is a file we want,
					// so copy values and commit it.
					if(bWildFile && bWildExt)
					{
						// Create the new instance and copy the values in:
						pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

						chstrFullPathName = p.m_pszDrive;
						if(_tcslen(p.m_pszPath) == 0)
						{
							chstrFullPathName += _T("\\");
						}
						else
						{
							chstrFullPathName += p.m_pszPath;
						}
						chstrFullPathName += stFindData.cFileName;
						if(IsOneOfMe(&stFindData,TOBSTRT(chstrFullPathName)))
						{
							if(_tcslen(p.m_pszPath) == 0)
							{
								LoadPropertyValues95(pInstance, p.m_pszDrive, _T("\\"), p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
							}
							else
							{
								LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
							}
							hr = pInstance->Commit () ;
						}

						if(SUCCEEDED(hr))
						{
							// Look for entries that are marked as Directory, and aren't . or ..
							// and recurse into them if recursing.
							if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
								(_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
								(_tcscmp(stFindData.cFileName, _T("..")) != 0) && p.m_bRecurse)
							{
								// Build path containing the directory we just found
								if(_tcslen(p.m_pszPath) == 0) // were working with root dir; need \\ before filename
								{
									_tcscpy(szBuff,_T("\\"));
								}
								else
								{
									_tcscpy(szBuff, p.m_pszPath);
								}
								_tcscat(szBuff, stFindData.cFileName);
								_tcscat(szBuff, _T("\\"));

								C95EnumParm newp(p);
								newp.m_pszPath = szBuff;
								newp.m_bRoot = false;

								hr = EnumDirs95(newp);
							}
						}
					}
					else
					{
						// The first alternative possibility is that we were looking
						// for all cases of a particular file with any extension:
						if(!bWildFile && bWildExt)
						{
							// in which case we need to compare the filename of
							// the file that was found with that which was asked for:
							_tcscpy(szBuff,stFindData.cFileName);
							pc = NULL;
							pc = _tcsrchr(szBuff, '.');
							if(pc != NULL)
							{
								*pc = '\0';
							}
							if(_tcsicmp(szBuff,p.m_pszFile)==0)
							{
								// The file is one of interest, so load values
								// and commit it.
								pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

								chstrFullPathName = p.m_pszDrive;
								chstrFullPathName += p.m_pszPath;
								chstrFullPathName += stFindData.cFileName;
								if(IsOneOfMe(&stFindData,TOBSTRT(chstrFullPathName)))
								{
									//LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									if(_tcslen(p.m_pszPath) == 0)
									{
										LoadPropertyValues95(pInstance, p.m_pszDrive, _T("\\"), p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									else
									{
										LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									hr = pInstance->Commit () ;
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								// and recurse into them if recursing.
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
									(_tcscmp(stFindData.cFileName, _T("..")) != 0) && p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(_tcslen(p.m_pszPath) == 0) // were working with root dir; need \\ before filename
									{
										_tcscpy(szBuff,_T("\\"));
									}
									else
									{
										_tcscpy(szBuff, p.m_pszPath);
									}
									_tcscat(szBuff, stFindData.cFileName);
									_tcscat(szBuff, _T("\\"));

									C95EnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									// If we are recursing
									hr = EnumDirs95(newp);
								}
							}
						}

						// The second alternative is that we were looking for all
						// cases of any given file, with a particular extension:
						if(bWildFile && !bWildExt)
						{
							// in which case we need to compare the extension of
							// the file that was found with that which was asked for:
							_tcscpy(szBuff,stFindData.cFileName);
							pc = NULL;
							pc = _tcsrchr(szBuff, '.');
							if(pc != NULL)
							{
								if(_tcsicmp(_tcsinc(pc),p.m_pszExt)==0)
								{
									// The file is one of interest, so load values
									// and commit it.
									pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

									chstrFullPathName = p.m_pszDrive;
									chstrFullPathName += p.m_pszPath;
									chstrFullPathName += stFindData.cFileName;
									if(IsOneOfMe(&stFindData,TOBSTRT(chstrFullPathName)))
									{
										//LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										if(_tcslen(p.m_pszPath) == 0)
										{
											LoadPropertyValues95(pInstance, p.m_pszDrive, _T("\\"), p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										}
										else
										{
											LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										}
										hr = pInstance->Commit () ;
									}
								}
							}
							else if(pc == NULL && _tcslen(p.m_pszExt) == 0) // there is no extension, but the query asked for files with no extension
							{
								// The file is one of interest, so load values
								// and commit it.
								pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

								chstrFullPathName = p.m_pszDrive;
								chstrFullPathName += p.m_pszPath;
								chstrFullPathName += stFindData.cFileName;
								if(IsOneOfMe(&stFindData,TOBSTRT(chstrFullPathName)))
								{
									//LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									if(_tcslen(p.m_pszPath) == 0)
									{
										LoadPropertyValues95(pInstance, p.m_pszDrive, _T("\\"), p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									else
									{
										LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									hr = pInstance->Commit () ;
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								// and recurse into them if recursing.
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
									(_tcscmp(stFindData.cFileName, _T("..")) != 0) && p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(_tcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										_tcscpy(szBuff,_T("\\"));
									}
									else
									{
										_tcscpy(szBuff, p.m_pszPath);
									}
									_tcscat(szBuff, stFindData.cFileName);
									_tcscat(szBuff, _T("\\"));

									C95EnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirs95(newp);
								}
							}
						}
						// A third alternative is that bWildExtension and bWildFilename are both false, but
						// we didn't specify a specific file either.  This might happen if a user did an NTokenAnd
						// query, and specified drive, filename, and extension, for instance, but no path. So...
						if(!bWildFile && !bWildExt && p.m_bRecurse)
						{
							// in which case we need to compare the filename of
							// the file that was found with that which was asked for,
							// and do the same with the asked for and found extension::
							_tcscpy(szBuff,stFindData.cFileName);
							pc = NULL;
							pc = _tcsrchr(szBuff, '.');
							if(pc != NULL)
							{
								*pc = '\0';
							}
							if(_tcsicmp(szBuff,p.m_pszFile)==0)
							{
								_tcscpy(szBuff,stFindData.cFileName);
								pc = NULL;
								pc = _tcsrchr(szBuff, '.');
								if(pc != NULL)
								{
									if(_tcsicmp(pc+1,p.m_pszExt)==0)
									{
										// The file is one of interest, so load values
										// and commit it.
										pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

										chstrFullPathName = p.m_pszDrive;
										chstrFullPathName += p.m_pszPath;
										chstrFullPathName += stFindData.cFileName;
										if(IsOneOfMe(&stFindData,TOBSTRT(chstrFullPathName)))
										{
											//LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											if(_tcslen(p.m_pszPath) == 0)
											{
												LoadPropertyValues95(pInstance, p.m_pszDrive, _T("\\"), p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											}
											else
											{
												LoadPropertyValues95(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											}
											hr = pInstance->Commit () ;
										}
									}
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								// and recurse into them if recursing.
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(_tcscmp(stFindData.cFileName, _T(".")) != 0) &&
									(_tcscmp(stFindData.cFileName, _T("..")) != 0) && p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(_tcslen(p.m_pszPath) == 0) // were working with root dir; need \\ before filename
									{
										_tcscpy(szBuff,_T("\\"));
									}
									else
									{
										_tcscpy(szBuff, p.m_pszPath);
									}
									_tcscat(szBuff, stFindData.cFileName);
									_tcscat(szBuff, _T("\\"));

									C95EnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									// If we are recursing
									hr = EnumDirs95(newp);
								}
							}
						}
					}
				}
				// Just before repeating, need to munge hr - if it was
				// WBEM_E_ACCESS_DENIED, we want to keep going anyway.
				if(hr == WBEM_E_ACCESS_DENIED)
				{
					hr = WBEM_S_NO_ERROR;
				}
			} while ((FindNextFile(hFind, &stFindData)) && (SUCCEEDED(hr)));
		} // hFind was valid
	}  // recursing and succeeded hr

	return hr;
}
#endif

#ifdef NTONLY
HRESULT CImplement_LogicalFile::EnumDirsNT(CNTEnumParm& p)
{
    WCHAR szBuff[_MAX_PATH];
    WIN32_FIND_DATAW stFindData;
    SmartFindClose hFind;

	CInstancePtr pInstance;
	WCHAR* pwc = NULL;
	bool bWildFile = false;
	bool bWildExt = false;
	_bstr_t bstrtFullPathName;
	HRESULT hr = WBEM_S_NO_ERROR;
	bool fDone = false;

	// Before proceeding further:  if we are not looking at the root "directory",
	// then the path arguement must have BOTH leading AND trailing backslashes.
	// If not, it was misspecified, so get the @#%$^% out of Dodge:
	if(!IsValidPath(p.m_pszPath, p.m_bRoot))
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Determine if filename and or extension are a wildchar:
	if(wcscmp(p.m_pszFile,L"*") == 0) bWildFile = true;
	if(wcscmp(p.m_pszExt,L"*") == 0) bWildExt = true;

	ZeroMemory(&stFindData,sizeof(stFindData));
	ZeroMemory(szBuff,sizeof(szBuff));

	// One simple case is where neither bWildFile nor bWildExt
	// are true.  In that case we are looking for a specific
	// file only. If this is the case, we are done onece the
	// following block executes (whether the file is found or
	// not), so indicate as such at the end.
	if(!(bWildFile || bWildExt || p.m_bRoot) && !p.m_bRecurse)
	{
		// Assemble pathname - we have all the pieces.
		wcscpy(szBuff,p.m_pszDrive);
		wcscat(szBuff,p.m_pszPath);
		wcscat(szBuff,p.m_pszFile);
        if(p.m_pszExt && wcslen(p.m_pszExt) > 0)
        {
		    if(p.m_pszExt[0] != L'.')
            {
                wcscat(szBuff, L".");
                wcscat(szBuff, p.m_pszExt);
            }
            else
            {
                wcscat(szBuff, p.m_pszExt);
            }
        }

		// Do the find
		hFind = FindFirstFileW(szBuff, &stFindData);

		// If the find failed and we are not recursing (we were interested only in
		// looking at one particular path), indicate that we should not continue.
		//DWORD dw = GetLastError();
		if(hFind == INVALID_HANDLE_VALUE/* || dw != ERROR_SUCCESS*/)
		{
			hr = WinErrorToWBEMhResult(GetLastError());
		}

		if(SUCCEEDED(hr))
		{
			// We found it, so fill in the values and commit it.
			pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

			// FindClose(hFind); // DONE AT BOTTOM
			bstrtFullPathName = p.m_pszDrive;
			if(wcslen(p.m_pszPath) == 0) // were dealing with the root dir; need "\\" before file name
			{
				bstrtFullPathName += L"\\";
			}
			else
			{
				bstrtFullPathName += p.m_pszPath;
			}
			bstrtFullPathName += stFindData.cFileName;
			if(IsOneOfMe(&stFindData,bstrtFullPathName))
			{
				// The following is done for compatability with cases in which we did an 8dot3 optimization.
				// Only szBuff contains the proper, 8dot3 filename (stfindData contains both - how would we
				// know which to use?).  Thus load it here, then extact it there, and use it if present.
                // Note that some derived classes (such as Win32LogicalFileSecuritySetting) may not have a
                // Name property to set - hence the following check.
                bool fHasNameProp = false;
                VARTYPE vt = VT_BSTR;
                if(pInstance->GetStatus(IDS_Name, fHasNameProp, vt) && fHasNameProp)
                {
					pInstance->SetWCHARSplat(IDS_Name,szBuff);
                }
				//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				if(wcslen(p.m_pszPath) == 0)
				{
					LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				}
				else
				{
					LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
				}
				hr = pInstance->Commit () ;
			}
			else
			{
				hr = WBEM_E_NOT_FOUND;
			}
		}
		fDone = TRUE;
	}

	// Another simple case is where we are looking for the root directory itself.
	if(p.m_bRoot && !fDone)
	{
		pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

		// If the szFSName parameter is NULL, we never got the file system name, perhaps
		// because that property was not required.  However, normally when we do get the
		// FSName, we call GetDrivesAndFS, and it is only through that call that we
		// confirm that the specified drive even exists!  Here, however, we can get away
        // with confirming that the specific drive of interest is valid via a call to IsValidDrive.
		if(p.m_szFSName == NULL || wcslen(p.m_szFSName)==0)
		{
            CHString chstrTmp;
            chstrTmp.Format(L"%s\\",p.m_pszDrive);
            if(!IsValidDrive(chstrTmp))
			{
				hr = WBEM_E_NOT_FOUND;
			}
			//FreeVector(vecpDI);
		}
		if(SUCCEEDED(hr))
		{
			bstrtFullPathName = p.m_pszDrive;
			bstrtFullPathName += p.m_pszPath;
			if(IsOneOfMe((LPWIN32_FIND_DATAW)NULL,bstrtFullPathName))
			{
				LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, NULL, p.m_dwReqProps, p.m_pvMoreData);
				hr = pInstance->Commit () ;
			}
		}
		// In this case, if we aren't recursing, we are done. Otherwise, continue.
		// NO! That would cause only the root to be returned; what if the query had
		// been "select * from cim_logicalfile where path = "\\" ?  Then we want
		// all files and directories off of the root directory, in addition to the root.
		// YES! (after revising root's path to be empty by definition, and after
		// revising the test that sets bRoot to compare to an empty string rather than
		// to "\\") Do want to stop if root, as now no ambiguity between the root dir
		// and files hanging off the root. Previously there was, since both had a path
		// of "\\".  Now the root's path is "", while the path of files off of the root
		// is "\\".  So, un-commenting out the following lines:
		if(!p.m_bRecurse)
		{
			fDone = true;
		}
	}

	// If we are recursing and all is well, we're not done yet!
	if(!fDone && SUCCEEDED(hr))
	{
		// The more involved case if that for which either bWildFile or bWildExt
		// is true.  We need to find matching files or extensions or both potentially
		// in all directories.

		// Start by assembling a path, but use wildcards for the filename and extension.
		wcscpy(szBuff,p.m_pszDrive);
		if(wcslen(p.m_pszPath) == 0)
		{
			wcscat(szBuff,L"\\");  // path was the root - need leading "\\"
		}
		else
		{
			wcscat(szBuff,p.m_pszPath);
		}
		wcscat(szBuff,L"*.*");

		// Do the find
		hFind = FindFirstFileW(szBuff, &stFindData);

		// If the find failed, quit.
		if(hFind == INVALID_HANDLE_VALUE)
		{
			// The intended logic here is as follows:  if we have an invalid handle, we
			// need to return at this point no matter what.  However, if we just got an
			// access denied error, we want to return a value that will allow us to keep
			// iterating (presumably at the next higher node in the directory structure),
			// as opposed to returning a false, which would get propegated out of all
			// recursed calls and prematurely abort the iteration unnescessarily.
			hr = WinErrorToWBEMhResult(GetLastError());
		}
		else
		{
			// Walk the directory tree
			do
			{
				if( (wcscmp(stFindData.cFileName, L".") != 0) &&
					(wcscmp(stFindData.cFileName, L"..") != 0))
				{
					// It was a file.
					// If both bWildFile and bWildExt are true, it is a file we are
					// interested in, so copy values and commit it.
					if(bWildFile && bWildExt)
					{
						// Create the new instance and copy the values in:
						pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

						bstrtFullPathName = p.m_pszDrive;
						if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
						{
							bstrtFullPathName += L"\\";
						}
						else
						{
							bstrtFullPathName += p.m_pszPath;
						}
						bstrtFullPathName += stFindData.cFileName;
						if(IsOneOfMe(&stFindData,bstrtFullPathName))
						{
							if(wcslen(p.m_pszPath) == 0)
							{
								LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
							}
							else
							{
								LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
							}
							hr = pInstance->Commit () ;
						}

						if(SUCCEEDED(hr))
						{
							// Look for entries that are marked as Directory, and aren't . or ..
							if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
								(wcscmp(stFindData.cFileName, L".") != 0) &&
								(wcscmp(stFindData.cFileName, L"..") != 0) && p.m_bRecurse)
							{
								// Build path containing the directory we just found
								if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
								{
									wcscpy(szBuff,L"\\");
								}
								else
								{
									wcscpy(szBuff, p.m_pszPath);
								}
								wcscat(szBuff, stFindData.cFileName);
								wcscat(szBuff, L"\\");

								CNTEnumParm newp(p);
								newp.m_pszPath = szBuff;
								newp.m_bRoot = false;

								hr = EnumDirsNT(newp);
							}
						}
					}
					else
					{
						// The first alternative possibility is that we were looking
						// for all cases of a particular file with any extension:
						if(!bWildFile && bWildExt)
						{
							// in which case we need to compare the filename of
							// the file that was found with that which was asked for:
							wcscpy(szBuff,stFindData.cFileName);
							pwc = NULL;
							pwc = wcsrchr(szBuff, L'.');
							if(pwc != NULL)
							{
								*pwc = '\0';
							}
							if(_wcsicmp(szBuff,p.m_pszFile)==0)
							{
								// The file is one of interest, so load values
								// and commit it.
								pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

								bstrtFullPathName = p.m_pszDrive;
								bstrtFullPathName += p.m_pszPath;
								bstrtFullPathName += stFindData.cFileName;
								if(IsOneOfMe(&stFindData,bstrtFullPathName))
								{
									//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									if(wcslen(p.m_pszPath) == 0)
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									else
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									hr = pInstance->Commit () ;
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(wcscmp(stFindData.cFileName, L".") != 0) &&
									(wcscmp(stFindData.cFileName, L"..") != 0) & p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										wcscpy(szBuff,L"\\");
									}
									else
									{
										wcscpy(szBuff, p.m_pszPath);
									}
									wcscat(szBuff, stFindData.cFileName);
									wcscat(szBuff, L"\\");

									CNTEnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirsNT(newp);
								}
							}
						}

						// The second alternative is that we were looking for all
						// cases of any given file, with a particular extension:
						if(bWildFile && !bWildExt)
						{
							// in which case we need to compare the extension of
							// the file that was found with that which was asked for:
							wcscpy(szBuff,stFindData.cFileName);
							pwc = NULL;
							pwc = wcsrchr(szBuff, L'.');
							if(pwc != NULL)
							{
								if(_wcsicmp(pwc+1,p.m_pszExt)==0)
								{
									// The file is one of interest, so load values
									// and commit it.
									pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

									bstrtFullPathName = p.m_pszDrive;
									bstrtFullPathName += p.m_pszPath;
									bstrtFullPathName += stFindData.cFileName;
									if(IsOneOfMe(&stFindData,bstrtFullPathName))
									{
										//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										if(wcslen(p.m_pszPath) == 0)
										{
											LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										}
										else
										{
											LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
										}
										hr = pInstance->Commit () ;
									}
								}
							}
							else if(pwc == NULL && wcslen(p.m_pszExt) == 0) // there was no extension, but our query asked for files with none
							{
								// The file is one of interest, so load values
								// and commit it.
								pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

								bstrtFullPathName = p.m_pszDrive;
								bstrtFullPathName += p.m_pszPath;
								bstrtFullPathName += stFindData.cFileName;
								if(IsOneOfMe(&stFindData,bstrtFullPathName))
								{
									//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									if(wcslen(p.m_pszPath) == 0)
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									else
									{
										LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
									}
									hr = pInstance->Commit () ;
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(wcscmp(stFindData.cFileName, L".") != 0) &&
									(wcscmp(stFindData.cFileName, L"..") != 0) && p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										wcscpy(szBuff,L"\\");
									}
									else
									{
										wcscpy(szBuff, p.m_pszPath);
									}
									wcscat(szBuff, stFindData.cFileName);
									wcscat(szBuff, L"\\");

									CNTEnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirsNT(newp);
								}
							}
						}
						// A third alternative is that bWildExtension and bWildFilename are both false, but
						// we didn't specify a specific file either.  This might happen if a user did an NTokenAnd
						// query, and specified drive, filename, and extension, for instance, but no path. So...
						if(!bWildFile && !bWildExt && p.m_bRecurse)
						{
							// in which case we need to compare the filename of
							// the file that was found with that which was asked for,
							// and do the same with the asked for and found extension:
							wcscpy(szBuff,stFindData.cFileName);
							pwc = NULL;
							pwc = wcsrchr(szBuff, L'.');
							if(pwc != NULL)
							{
								*pwc = '\0';
							}
							if(_wcsicmp(szBuff,p.m_pszFile)==0)
							{
								wcscpy(szBuff,stFindData.cFileName);
								pwc = NULL;
								pwc = wcsrchr(szBuff, L'.');
								if(pwc != NULL)
								{
									if(_wcsicmp(pwc+1,p.m_pszExt)==0)
									{
										// The file is one of interest, so load values
										// and commit it.
										pInstance.Attach ( CreateNewInstance ( p.m_pMethodContext ) ) ;

										bstrtFullPathName = p.m_pszDrive;
										bstrtFullPathName += p.m_pszPath;
										bstrtFullPathName += stFindData.cFileName;
										if(IsOneOfMe(&stFindData,bstrtFullPathName))
										{
											//LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											if(wcslen(p.m_pszPath) == 0)
											{
												LoadPropertyValuesNT(pInstance, p.m_pszDrive, L"\\", p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											}
											else
											{
												LoadPropertyValuesNT(pInstance, p.m_pszDrive, p.m_pszPath, p.m_szFSName, &stFindData, p.m_dwReqProps, p.m_pvMoreData);
											}
											hr = pInstance->Commit () ;
										}
									}
								}
							}
							if(SUCCEEDED(hr))
							{
								// Look for entries that are marked as Directory, and aren't . or ..
								if( (stFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
									(wcscmp(stFindData.cFileName, L".") != 0) &&
									(wcscmp(stFindData.cFileName, L"..") != 0) & p.m_bRecurse)
								{
									// Build path containing the directory we just found
									if(wcslen(p.m_pszPath) == 0)   // were working with root dir; need \\ before filename
									{
										wcscpy(szBuff,L"\\");
									}
									else
									{
										wcscpy(szBuff, p.m_pszPath);
									}
									wcscat(szBuff, stFindData.cFileName);
									wcscat(szBuff, L"\\");

									CNTEnumParm newp(p);
									newp.m_pszPath = szBuff;
									newp.m_bRoot = false;

									hr = EnumDirsNT(newp);
								}
							}
						}
					}
				}
				// Just before repeating, need to munge hr - if it was
				// WBEM_E_ACCESS_DENIED, we want to keep going anyway.
				if(hr == WBEM_E_ACCESS_DENIED)
				{
					hr = WBEM_S_NO_ERROR;
				}
			} while ((FindNextFileW(hFind, &stFindData)) && (SUCCEEDED(hr)));
		} // hFind was valid
	}  // recursing and succeeded hr

	return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::IsValidPath
 *
 *  DESCRIPTION : Checks to see whether the path contained both leading and
 *                trailing backslashes.
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

bool CImplement_LogicalFile::IsValidPath(const WCHAR* wstrPath, bool fRoot)
{
    return HasCorrectBackslashes(wstrPath,fRoot);
}

bool CImplement_LogicalFile::IsValidPath(const CHAR* strPath, bool fRoot)
{
    bool fRet = false;
    UINT uiACP = GetACP();
	WCHAR* pwstr = NULL ;
	try
	{
		// Make the string a wide string...
		DWORD dw = MultiByteToWideChar(uiACP, MB_PRECOMPOSED|MB_USEGLYPHCHARS, strPath, -1, NULL, 0);
		if(dw != 0)
		{
			pwstr = (WCHAR*) new WCHAR[dw];
			if(pwstr != NULL)
			{
				if(MultiByteToWideChar(uiACP, MB_PRECOMPOSED|MB_USEGLYPHCHARS, strPath, -1, pwstr, dw) != 0)
				{
					fRet = HasCorrectBackslashes(pwstr,fRoot);
				}				
			}
		}
	}
	catch ( ... )
	{
		if(pwstr != NULL)
		{
			delete pwstr;
			pwstr = NULL;
		}
		throw ;
	}


	if(pwstr != NULL)
	{
		delete pwstr;
		pwstr = NULL;
	}

	return fRet;

}

bool CImplement_LogicalFile::HasCorrectBackslashes(const WCHAR* wstrPath, bool fRoot)
{
    bool fRet = false;

    if(fRoot)
    {
        // Test for root directory; wstrPath should be empty.
        if(wcslen(wstrPath) == 0)
        {
            fRet = true;
        }
    }
    else
    {
        if(wcslen(wstrPath)==0)
        {
            // This is the case where we don't want to return an instance for the root
            // directory, so fRoot is false, but we do want to start the enumeration from
            // the root directory.
            fRet = true;
        }
        else if(wcslen(wstrPath)==1)
        {
            // If the path arguement is just \\ and nothing else
            // (as it would be in the case of c:\\autoexec.bat),
            // and this is not a test for the root directory, all is well.
            if(*wstrPath == L'\\')
            {
                fRet = true;
            }
        }
        else if(wcslen(wstrPath) >= 3)
        {
            if(*wstrPath == L'\\') // is the first char after the drive letter and the colon a backslash?
            {
                // Is the next letter NOT a backslash? (can't have two in a row)
                if(*(wstrPath+1) != L'\\')
                {
                    const WCHAR* pwc1 = wstrPath+1;
                    LONG m = wcslen(pwc1);
                    if(*(pwc1+m-1) == L'\\') // is the final char a backslash?
                    {
                        // Is the character just before the final one not a backslash? (can't have two in a row)
                        if(*(pwc1+m-2) != L'\\')
                        {
                            fRet = true;
                        }
                    }
                    pwc1 = NULL;
                }
            }
        }
    }
    return fRet;
}



/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
void CImplement_LogicalFile::LoadPropertyValues95(CInstance *pInstance,
                                                  LPCTSTR pszDrive,  // file drive:
                                                  LPCTSTR pszPath,   // \\file path\\name.extension
                                                  LPCTSTR szFSName,
                                                  LPWIN32_FIND_DATA pstFindData,
                                                  const DWORD dwReqProps,
                                                  const void* pvMoreData)
{
    // Need buffers to store parms so they can be lowercased...
    TCHAR tstrDrive[_MAX_DRIVE+1];
    TCHAR tstrPath[_MAX_PATH+1];
    // Copy data in...
    _tcsncpy(tstrDrive,pszDrive,(sizeof(tstrDrive)/sizeof(TCHAR))-1);
    _tcsncpy(tstrPath,pszPath,(sizeof(tstrPath)/sizeof(TCHAR))-1);
    // Lower case it...
    _tcslwr(tstrDrive);
    _tcslwr(tstrPath);

    TCHAR *pChar;
    TCHAR szBuff[_MAX_PATH]=_T("");
    TCHAR szBuff2[_MAX_PATH];
    TCHAR szFilename[_MAX_PATH];
    CHString chsSize;
    bool bRoot = false;

    if(pstFindData == NULL)
    {
        bRoot = true;
    }


    // The following (setting the Name property) needs to
    // always be done first.  The Name needs to be set since GetExtendedProps
    // functions often expect to be able to extract it.

    // szBuff is going to contain the string that becomes the name.  For consistency,
    // if the path to the file contains ~ characters (due to an 8dot3 query having been
    // used), the filename portion should be 8dot3 too, not long. If it was already
    // set in the instance, use that; otherwise, create it.
    if(!bRoot)
    {
        if(pInstance->IsNull(IDS_Name))
        {
            _stprintf(szBuff,_T("%s%s%s"),pszDrive,pszPath,pstFindData->cFileName);
        }
        else
        {
            CHString chstrTmp;
            pInstance->GetCHString(IDS_Name,chstrTmp);
            if(chstrTmp.GetLength() == 0)
            {
                _stprintf(szBuff,_T("%s%s%s"),pszDrive,pszPath,pstFindData->cFileName);
            }
            else
            {
                _tcsncpy(szBuff,TOBSTRT(chstrTmp),_MAX_PATH-1);
            }
        }
    }
    else
    {
        _stprintf(szBuff,_T("%s\\"),pszDrive);
    }
    _tcslwr(szBuff);
    pInstance->SetCharSplat(IDS_Name, szBuff);


    if(GetAllProps())  // that is, we want base class props plus derived class props
    {
        // Set attributes that are the same whether this was a root or not:
        if(szFSName != NULL && _tcslen(szFSName) > 0)
        {
            pInstance->SetCharSplat(IDS_FSName, szFSName);
        }
        pInstance->Setbool(IDS_Readable, true);
        pInstance->SetCharSplat(IDS_Drive, tstrDrive);
        pInstance->SetCharSplat(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
        pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
        pInstance->SetCharSplat(IDS_CreationClassName, PROPSET_NAME_FILE);
        pInstance->SetCharSplat(IDS_Status, _T("OK"));
        pInstance->SetCharSplat(IDS_FSCreationClassName, _T("Win32_FileSystem"));


        // Set attributes that depend on whether this was the root or not:
        if(!bRoot)
        {
            if(pstFindData->cAlternateFileName[0] == '\0')
            {
                _stprintf(szBuff2,_T("%s%s%s"),tstrDrive,tstrPath,_tcslwr(pstFindData->cFileName));
            }
            else
            {
                _stprintf(szBuff2,_T("%s%s%s"),tstrDrive,tstrPath,_tcslwr(pstFindData->cAlternateFileName));
            }
            pInstance->SetCharSplat(IDS_EightDotThreeFileName, szBuff2);

            pChar = _tcsrchr(pstFindData->cFileName, '.');

            pInstance->Setbool(IDS_Archive, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE);
            // In either case, we have FOUND an extension, so we need to return something other than null.
            if (pChar != NULL)
            {
                pInstance->SetCharSplat(IDS_Extension, _tcsinc(pChar) );
                // If this is a directory, set FileType to "File Folder".  Otherwise, get the Description
                // of Type for that extension from the registry.
                // Only bother to set the file type if we were asked to do so:
                if(dwReqProps & PROP_FILE_TYPE)
                {
                    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        pInstance->SetCharSplat(IDS_FileType, IDS_FileFolder);
                    }
                    else
                    {
                        CRegistry reg;
                        CHString chstrRegKey;
                        CHString chstrExtension = pChar+1;
                        CHString chstrRegNewSubkey;
                        CHString chstrFileType;
                        chstrFileType.Format(L"%s %s", chstrExtension, IDS_File); // this will be our default value
                        chstrRegKey.Format(L"%s.%s", IDS_FileTypeKeyNT4, chstrExtension);
                        if(reg.Open(HKEY_LOCAL_MACHINE,chstrRegKey,KEY_READ) == ERROR_SUCCESS)
                        {
                            if(reg.GetCurrentKeyValue(NULL,chstrRegNewSubkey) == ERROR_SUCCESS)
                            {
                                CRegistry reg2;
                                chstrRegKey.Format(L"%s%s", IDS_FileTypeKeyNT4, chstrRegNewSubkey);
                                if(reg2.Open(HKEY_LOCAL_MACHINE,chstrRegKey,KEY_READ) == ERROR_SUCCESS)
                                {
                                    CHString chstrTempFileType;
                                    if(reg2.GetCurrentKeyValue(NULL,chstrTempFileType) == ERROR_SUCCESS)
                                    {
                                        chstrFileType = chstrTempFileType;
                                    }
                                }
                            }
                        }
                        pInstance->SetCharSplat(IDS_FileType, chstrFileType);
                    }
                }
            }
            else
            {
                pInstance->SetCharSplat(IDS_Extension, _T(""));
                if(dwReqProps & PROP_FILE_TYPE)
                {
                    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        pInstance->SetCharSplat(IDS_FileType, IDS_FileFolder);
                    }
			        else
			        {
                        pInstance->SetCharSplat(IDS_FileType, IDS_File);
			        }
                }
            }

            _tcscpy(szFilename,pstFindData->cFileName);
            pChar = NULL;
            pChar = _tcsrchr(szFilename, '.');
            if(pChar != NULL)
            {
                *pChar = '\0';
            }

            pInstance->SetCharSplat(IDS_Filename, szFilename);

            pInstance->SetCharSplat(IDS_Caption, szBuff);
            pInstance->SetCharSplat(IDS_Path, tstrPath);
            pInstance->SetCharSplat(IDS_Description, szBuff);

            pInstance->Setbool(IDS_Writeable, !(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY));
            pInstance->Setbool(IDS_Hidden, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN);
            pInstance->Setbool(IDS_System, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM);
            if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)
            {
                pInstance->SetCharSplat(IDS_CompressionMethod, IDS_Compressed);
                // The following property is redundant with the above, but Win32_Directory shipped
                // with it, so we need to continue to support it
                pInstance->Setbool(IDS_Compressed, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED);
                // DEV NOTE: In the future, use the DeviceIOControl operation FSCTL_GET_COMPRESSION to
                // obtain the type of compression used.  For now (7/31/98) only one type of compression,
                // LZNT1 is supported, so no compression method string is available through this operation.
                // But it will be, once other compression methods are available.
            }
		    else
		    {
			    pInstance->Setbool(IDS_Compressed, false) ;
		    }

            if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
            {
                pInstance->SetCharSplat(IDS_Encrypted, IDS_Encrypted);
                // The following property is redundant with the above, but Win32_Directory shipped
                // with it, so we need to continue to support it
                pInstance->Setbool(IDS_Encrypted, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED);
            }
		    else
		    {
			    pInstance->Setbool(IDS_Encrypted, false) ;
		    }


            // Times differ between FAT and NTFS drives...
            if(szFSName != NULL && _tcslen(szFSName) > 0)
            {
                if(_tcsicmp(szFSName,_T("FAT")) == 0 || _tcsicmp(szFSName,_T("FAT32")) == 0)
                {
                    // on FAT, the times are possibly off by an hour...
                    if((dwReqProps & PROP_CREATION_DATE) || (dwReqProps & PROP_INSTALL_DATE))
                    {
                        if ((pstFindData->ftCreationTime.dwLowDateTime != 0) && (pstFindData->ftCreationTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftCreationTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_CreationDate, bstrRealTime);
                                pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                    if(dwReqProps & PROP_LAST_ACCESSED)
                    {
                        if ((pstFindData->ftLastAccessTime.dwLowDateTime != 0) && (pstFindData->ftLastAccessTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftLastAccessTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_LastAccessed, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                    if(dwReqProps & PROP_LAST_MODIFIED)
                    {
                        if ((pstFindData->ftLastWriteTime.dwLowDateTime != 0) && (pstFindData->ftLastWriteTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftLastWriteTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_LastModified, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                }
                else if(_tcsicmp(szFSName,_T("NTFS")) == 0)
                {
                    // on NTFS we can report it as we got it...
                    if((dwReqProps & PROP_CREATION_DATE) || (dwReqProps & PROP_INSTALL_DATE))
                    {
                        if ((pstFindData->ftCreationTime.dwLowDateTime != 0) && (pstFindData->ftCreationTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_CreationDate, pstFindData->ftCreationTime);
                            pInstance->SetDateTime(IDS_InstallDate, pstFindData->ftCreationTime);
                        }
                    }
                    if(dwReqProps & PROP_LAST_ACCESSED)
                    {
                        if ((pstFindData->ftLastAccessTime.dwLowDateTime != 0) && (pstFindData->ftLastAccessTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_LastAccessed, pstFindData->ftLastAccessTime);
                        }
                    }
                    if(dwReqProps & PROP_LAST_MODIFIED)
                    {
                        if ((pstFindData->ftLastWriteTime.dwLowDateTime != 0) && (pstFindData->ftLastWriteTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_LastModified, pstFindData->ftLastWriteTime);
                        }
                    }
                }
            }
        }
        else  // the root case
        {
            _stprintf(szBuff,_T("%s\\"),pszDrive);
            pInstance->SetCharSplat(IDS_EightDotThreeFileName, _T("")); // root directory has no 8dot3 filename
            pInstance->SetCharSplat(IDS_Caption, szBuff);
            pInstance->SetCharSplat(IDS_Path, _T(""));  // root directory has empty path
            pInstance->SetCharSplat(IDS_Filename, _T(""));  // root directory has empty filename
            pInstance->SetCharSplat(IDS_Extension, _T(""));  // root directory has empty extension
            pInstance->SetCharSplat(IDS_Description, szBuff);
            pInstance->SetCharSplat(IDS_FileType, IDS_LocalDisk);
        }
        // On 9x, with no security, return 0xffffffff (-1L) for the access mask...
        if(dwReqProps & PROP_ACCESS_MASK)
        {
            pInstance->SetDWORD(IDS_AccessMask, -1L);
        }
    }
   // get the extended (e.g., class specific) properties
    {
        GetExtendedProperties(pInstance, dwReqProps);
    }
}
#endif

bool CImplement_LogicalFile::IsValidDrive(const TCHAR* tstrDrive)
{
    DWORD dwDriveType;
    bool bRet = false;

    dwDriveType = GetDriveType(tstrDrive);

    if(((dwDriveType == DRIVE_REMOTE) ||       // NOTE: WITH BUG 43566, IT WAS DECIDED TO INCLUDE NETWORKED DRIVES WITH THIS CLASS AND ALL CLASSES DEPENDENT ON IT.
        (dwDriveType == DRIVE_FIXED) ||
        (dwDriveType == DRIVE_REMOVABLE) ||
        (dwDriveType == DRIVE_CDROM) ||
        (dwDriveType == DRIVE_RAMDISK)) &&
        (CHString(tstrDrive).GetLength() == 3))
    {
        if ((dwDriveType == DRIVE_REMOVABLE) || (dwDriveType == DRIVE_CDROM))
        {
            // Need to check if the drive is really there too...
            if(DrivePresent(tstrDrive))
            {
                bRet = true;
            }
        }
        else
        {
            bRet = true;
        }
    }
   return bRet;
}

#ifdef NTONLY
void CImplement_LogicalFile::LoadPropertyValuesNT(CInstance* pInstance,
                                                  const WCHAR* pszDrive,
                                                  const WCHAR* pszPath,
                                                  const WCHAR* szFSName,
                                                  LPWIN32_FIND_DATAW pstFindData,
                                                  const DWORD dwReqProps,
                                                  const void* pvMoreData)
{
    // Need buffers to store parms so they can be lowercased...
    WCHAR wstrDrive[_MAX_DRIVE+1];
    WCHAR wstrPath[_MAX_PATH+1];
    // Copy data in...
    wcsncpy(wstrDrive,pszDrive,(sizeof(wstrDrive)/sizeof(WCHAR))-1);
    wcsncpy(wstrPath,pszPath,(sizeof(wstrPath)/sizeof(WCHAR))-1);
    // Lower case it...
    _wcslwr(wstrDrive);
    _wcslwr(wstrPath);


    WCHAR* pChar;
    WCHAR szBuff[_MAX_PATH * 2] = L"";
	WCHAR szFName[(_MAX_PATH * 2) + 4] = L"\\\\?\\";
    WCHAR szBuff2[_MAX_PATH * 2];
    WCHAR wstrFilename[_MAX_PATH * 2];
    CHString chsSize;
    bool bRoot = false;

    if(pstFindData == NULL)
    {
        bRoot = true;
    }


    // The following (setting the Name property) needs to
    // always be done first.  The Name needs to be set since GetExtendedProps
    // functions often expect to be able to extract it.

    // szBuff is going to contain the string that becomes the name.  For consistency,
    // if the path to the file contains ~ characters (due to an 8dot3 query having been
    // used), the filename portion should be 8dot3 too, not long. If it was already
    // set in the instance, use that; otherwise, create it.
    if(!bRoot)
    {
        if (pInstance->IsNull(IDS_Name))
        {
            wsprintfW(szBuff,L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
        }
        else
        {
            CHString chstr;
            pInstance->GetCHString(IDS_Name,chstr);
            if(chstr.GetLength() == 0)
            {
                wsprintfW(szBuff,L"%s%s%s",pszDrive,pszPath,pstFindData->cFileName);
            }
            else
            {
                wcsncpy(szBuff,chstr,_MAX_PATH-1);
            }
        }
    }
    else
    {
        wsprintfW(szBuff,L"%s\\",pszDrive);
    }
    _wcslwr(szBuff);
    pInstance->SetWCHARSplat(IDS_Name, szBuff);
	wcsncat(szFName, szBuff, _MAX_PATH * 2);

    if(GetAllProps())  // that is, we want base class props plus derived class props
    {
        // Set attributes that are the same whether this was a root or not:
        if(szFSName != NULL && wcslen(szFSName) > 0)
        {
            pInstance->SetWCHARSplat(IDS_FSName, szFSName);
        }
        pInstance->Setbool(IDS_Readable, true);
        pInstance->SetWCHARSplat(IDS_Drive, wstrDrive);
        pInstance->SetCharSplat(IDS_CSCreationClassName, _T("Win32_ComputerSystem"));
        pInstance->SetCHString(IDS_CSName, GetLocalComputerName());
        pInstance->SetCharSplat(IDS_CreationClassName, PROPSET_NAME_FILE);
        pInstance->SetCharSplat(IDS_Status, _T("OK"));
        pInstance->SetCharSplat(IDS_FSCreationClassName, _T("Win32_FileSystem"));


        // Set attributes that depend on whether this was the root or not:
        if(!bRoot)
        {
            if (pstFindData->cAlternateFileName[0] == '\0')
            {
                wsprintfW(szBuff2,L"%s%s%s",wstrDrive,wstrPath,_wcslwr(pstFindData->cFileName));
            }
            else
            {
                wsprintfW(szBuff2,L"%s%s%s",wstrDrive,wstrPath,_wcslwr(pstFindData->cAlternateFileName));
            }
            pInstance->SetWCHARSplat(IDS_EightDotThreeFileName, szBuff2);

            pChar = wcsrchr(pstFindData->cFileName, '.');

            pInstance->Setbool(IDS_Archive, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE);
            // In either case, we have FOUND an extension, so we need to return something other than null.
            if (pChar != NULL)
            {
                pInstance->SetWCHARSplat(IDS_Extension, pChar+1);
                // If this is a directory, set FileType to "File Folder".  Otherwise, get the Description
                // of Type for that extension from the registry.
                if(dwReqProps & PROP_FILE_TYPE)
                {
                    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        pInstance->SetCharSplat(IDS_FileType, IDS_FileFolder);
                    }
                    else
                    {
                        CRegistry reg;
                        CHString chstrRegKey;
                        _bstr_t bstrtExtension(pChar+1);
                        CHString chstrExtension = (TCHAR*)bstrtExtension;
                        CHString chstrRegNewSubkey;
                        CHString chstrFileType;
                        chstrFileType.Format(_T("%s %s"), chstrExtension, IDS_File); // this will be our default value
                        chstrRegKey.Format(_T("%s.%s"), IDS_FileTypeKeyNT4, chstrExtension);
                        if(reg.Open(HKEY_LOCAL_MACHINE,chstrRegKey,KEY_READ) == ERROR_SUCCESS)
                        {
                            if(reg.GetCurrentKeyValue(NULL,chstrRegNewSubkey) == ERROR_SUCCESS)
                            {
                                CRegistry reg2;
                                chstrRegKey.Format(_T("%s%s"), IDS_FileTypeKeyNT4, chstrRegNewSubkey);
                                if(reg2.Open(HKEY_LOCAL_MACHINE,chstrRegKey,KEY_READ) == ERROR_SUCCESS)
                                {
                                    CHString chstrTempFileType;
                                    if(reg2.GetCurrentKeyValue(NULL,chstrTempFileType) == ERROR_SUCCESS)
                                    {
                                        chstrFileType = chstrTempFileType;
                                    }
                                }
                            }
                        }
                        pInstance->SetCharSplat(IDS_FileType, chstrFileType);
                    }
                }
            }
            else // the file had no extension
            {
                pInstance->SetWCHARSplat(IDS_Extension, L"");
                if(dwReqProps & PROP_FILE_TYPE)
                {
                    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        pInstance->SetCharSplat(IDS_FileType, IDS_FileFolder);
                    }
			        else
			        {
				        pInstance->SetCharSplat(IDS_FileType, IDS_File);
			        }
                }
            }

            wcscpy(wstrFilename,pstFindData->cFileName);
            pChar = NULL;
            pChar = wcsrchr(wstrFilename, '.');
            if(pChar != NULL)
            {
                *pChar = '\0';
            }

            pInstance->SetWCHARSplat(IDS_Filename, wstrFilename);

            pInstance->SetWCHARSplat(IDS_Caption, szBuff);
            pInstance->SetWCHARSplat(IDS_Path, wstrPath);
            pInstance->SetWCHARSplat(IDS_Description, szBuff);

            pInstance->Setbool(IDS_Writeable, !(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY));
            if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)
            {
                pInstance->SetWCHARSplat(IDS_CompressionMethod, IDS_Compressed);
                // The following property is redundant with the above, but Win32_Directory shipped
                // with it, so we need to continue to support it
                pInstance->Setbool(IDS_Compressed, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED);
                // DEV NOTE: In the future, use the DeviceIOControl operation FSCTL_GET_COMPRESSION to
                // obtain the type of compression used.  For now (7/31/98) only one type of compression,
                // LZNT1 is supported, so no compression method string is available through this operation.
                // But it will be, once other compression methods are available.
            }
		    else
		    {
			    pInstance->Setbool(IDS_Compressed, false) ;
		    }

		    if(pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
            {
                pInstance->SetWCHARSplat(IDS_EncryptionMethod, IDS_Encrypted);
                // The following property is redundant with the above, but Win32_Directory shipped
                // with it, so we need to continue to support it
                pInstance->Setbool(IDS_Encrypted, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED);
            }
		    else
		    {
			    pInstance->Setbool(IDS_Encrypted, false) ;
		    }

		    pInstance->Setbool(IDS_Hidden, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN);
            pInstance->Setbool(IDS_System, pstFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM);


            // Times differ between FAT and NTFS drives...
            if(szFSName != NULL && _tcslen(szFSName) > 0)
            {
                if(_wcsicmp(szFSName,L"NTFS") != 0)
                {
                    // on non-NTFS partitions, the times are possibly off by an hour...
                    if((dwReqProps & PROP_CREATION_DATE) || (dwReqProps & PROP_INSTALL_DATE))
                    {
                        if ((pstFindData->ftCreationTime.dwLowDateTime != 0) && (pstFindData->ftCreationTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftCreationTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_CreationDate, bstrRealTime);
                                pInstance->SetWCHARSplat(IDS_InstallDate, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                    if(dwReqProps & PROP_LAST_ACCESSED)
                    {
                        if ((pstFindData->ftLastAccessTime.dwLowDateTime != 0) && (pstFindData->ftLastAccessTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftLastAccessTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_LastAccessed, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                    if(dwReqProps & PROP_LAST_MODIFIED)
                    {
                        if ((pstFindData->ftLastWriteTime.dwLowDateTime != 0) && (pstFindData->ftLastWriteTime.dwHighDateTime != 0))
                        {
                            WBEMTime wbt(pstFindData->ftLastWriteTime);
                            BSTR bstrRealTime = wbt.GetDMTFNonNtfs();
                            if((bstrRealTime != NULL) && (SysStringLen(bstrRealTime) > 0))
                            {
                                pInstance->SetWCHARSplat(IDS_LastModified, bstrRealTime);
                                SysFreeString(bstrRealTime);
                            }
                        }
                    }
                }
                else  // on nt we can report the time as provided
                {
                    if((dwReqProps & PROP_CREATION_DATE) || (dwReqProps & PROP_INSTALL_DATE))
                    {
                        if((pstFindData->ftCreationTime.dwLowDateTime != 0) && (pstFindData->ftCreationTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_CreationDate, pstFindData->ftCreationTime);
                            pInstance->SetDateTime(IDS_InstallDate, pstFindData->ftCreationTime);
                        }
                    }
                    if(dwReqProps & PROP_LAST_ACCESSED)
                    {
                        if((pstFindData->ftLastAccessTime.dwLowDateTime != 0) && (pstFindData->ftLastAccessTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_LastAccessed, pstFindData->ftLastAccessTime);
                        }
                    }
                    if(dwReqProps & PROP_LAST_MODIFIED)
                    {
                        if((pstFindData->ftLastWriteTime.dwLowDateTime != 0) && (pstFindData->ftLastWriteTime.dwHighDateTime != 0))
                        {
                            pInstance->SetDateTime(IDS_LastModified, pstFindData->ftLastWriteTime);
                        }
                    }
                }
            }
        }
        else   // the root case
        {
            wsprintfW(szBuff,L"%s\\",pszDrive);
            pInstance->SetWCHARSplat(IDS_EightDotThreeFileName, L""); // root directory has no 8dot3 filename
            pInstance->SetWCHARSplat(IDS_Caption, szBuff);
            pInstance->SetWCHARSplat(IDS_Path, L"");  // root directory has empty path
            pInstance->SetWCHARSplat(IDS_Filename, L"");  // root directory has empty filename
            pInstance->SetWCHARSplat(IDS_Extension, L"");  // root directory has empty extension
            pInstance->SetWCHARSplat(IDS_Description, szBuff);
            pInstance->SetWCHARSplat(IDS_FileType, IDS_LocalDisk);
        }
        // Whether we are looking at the root or not, we may want the AccessMask property...
        if(dwReqProps & PROP_ACCESS_MASK)
        {
            if(szFSName != NULL && wcslen(szFSName) > 0)
            {
                if(_wcsicmp(szFSName,L"FAT") == 0 || _wcsicmp(szFSName,L"FAT32") == 0)
                {   // on fat volumes, indicate that no security has been set (e.g., full access for all)
                    pInstance->SetDWORD(IDS_AccessMask, -1L);
                }
                else
                {
					SmartCloseHandle hFile = CreateFile(szFName,
														MAXIMUM_ALLOWED,
														FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,
														NULL,
														OPEN_EXISTING,
														FILE_FLAG_BACKUP_SEMANTICS,
														NULL
														);

					if (hFile != INVALID_HANDLE_VALUE)
					{
						FILE_ACCESS_INFORMATION fai;
						IO_STATUS_BLOCK iosb;
						memset(&fai, 0, sizeof(FILE_ACCESS_INFORMATION));
						memset(&iosb, 0, sizeof(IO_STATUS_BLOCK));

						if ( NT_SUCCESS( NtQueryInformationFile( hFile,
                                             &iosb,
                                             &fai,
                                             sizeof( FILE_ACCESS_INFORMATION ),
                                             FileAccessInformation
                                           ) )
						)
						{
							pInstance->SetDWORD(IDS_AccessMask, fai.AccessFlags);
						}
					}
					else
					{
						DWORD dwErr = GetLastError();

						if (dwErr == ERROR_ACCESS_DENIED)
						{
							pInstance->SetDWORD( IDS_AccessMask, 0L );
						}
					}
                }
            }
        }
    }

    // Need the extended (e.g., class specific) properties
    GetExtendedProperties(pInstance, dwReqProps);
}
#endif

#ifdef WIN9XONLY
HRESULT CImplement_LogicalFile::FindSpecificPath95(CInstance *pInstance, CHString &sDrive, CHString &sDir, DWORD dwReqProps)
{
	WIN32_FIND_DATA     stFindData;
    WIN32_FIND_DATA*    pfdToLoadProp;
	SmartFindClose      hFind;
	TCHAR	            szFSName[_MAX_PATH] = _T("");
	BOOL	            bIsRoot = !wcscmp(sDir, L"");  // sDir contains the path and name of file, so if that combination is just empty, we are indeed looking at the root.
	CHString	        chstrFullPath;
    CHString            chstrRoot;

	chstrFullPath = sDrive;
	chstrFullPath += sDir;

	chstrRoot = sDrive;
	chstrRoot += _T("\\");

    bool fContinue = true;
    HRESULT hr = WBEM_E_NOT_FOUND;

	// if the directory contained a wildcard character, return WBEM_E_NOT_FOUND.
	if (wcspbrk(sDir,L"?*") != NULL)
    {
		fContinue = false;
    }

	// FindFirstW doesn't work with root dirs (since they're not real dirs.)
    if(fContinue)
    {
	    if (bIsRoot)
        {
		    pfdToLoadProp = NULL;
        }
	    else
	    {
		    pfdToLoadProp = &stFindData;
		    ZeroMemory(&stFindData, sizeof(stFindData));

		    hFind = FindFirstFile(TOBSTRT(chstrFullPath), &stFindData);
		    if (hFind == INVALID_HANDLE_VALUE)
            {
                fContinue = false; // removed call to return WinErrorToWBEMhResult(GetLastError()) since GetLastError was failing to report error under win9x
            }
	    }
    }

	// If GetVolumeInformation fails, only get out if we're trying
	// to get the root.
    BOOL fGotVolInfo = FALSE;

    if(fContinue)
    {
        try
        {
            if(dwReqProps & PROP_FILE_SYSTEM)
            {
                fGotVolInfo = GetVolumeInformation(TOBSTRT(chstrRoot), NULL, 0, NULL, NULL, NULL,
		            szFSName, sizeof(szFSName)/sizeof(szFSName[0]));
                if(!fGotVolInfo && bIsRoot)
                {
                    fContinue = false; // removed call to return WinErrorToWBEMhResult(GetLastError()) since GetLastError was failing to report error under win9x
                }
            }
        }
        catch(...)
        {
            if(!fGotVolInfo && bIsRoot)
            {
                fContinue = false; // removed call to return WinErrorToWBEMhResult(GetLastError()) since GetLastError was failing to report error under win9x
            }
        }
    }

    if(fContinue)
    {
	    if (!IsOneOfMe(pfdToLoadProp, TOBSTRT(chstrFullPath)))
        {
		    fContinue = false;
        }
    }

	if(fContinue)
    {
        if (bIsRoot)
        {
            LoadPropertyValues95(pInstance, TOBSTRT(sDrive), TOBSTRT(sDir), szFSName, NULL, dwReqProps, NULL);
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            // sDir contains \\path\\morepath\\filename.exe at this point, instead
            // of just \\path\\morepath\\, so need to hack off the last part.
		    WCHAR* strJustPath = NULL ;
            try
		    {
			    strJustPath = new WCHAR[wcslen(sDir) + 1];
			    WCHAR* pc = NULL;
			    ZeroMemory(strJustPath,(wcslen(sDir) + 1)*sizeof(TCHAR));
			    wcscpy(strJustPath,sDir);
			    pc = wcsrchr(strJustPath, '\\');
			    if(pc != NULL)
			    {
				    //pc = _tcsinc(pc) ;
				    pc++;
				    *(pc) = '\0';
			    }
			    LoadPropertyValues95(
				    pInstance,
				    TOBSTRT(sDrive),
				    TOBSTRT(strJustPath),
				    szFSName,
				    pfdToLoadProp,
				    dwReqProps, NULL);
			    delete strJustPath;
                hr = WBEM_S_NO_ERROR;
		    }
		    catch ( ... )
		    {
			    if ( strJustPath )
			    {
				    delete strJustPath ;
				    strJustPath = NULL ;
			    }
			    throw ;
		    }
        }
    }
	return hr;
}
#endif

#ifdef NTONLY
HRESULT CImplement_LogicalFile::FindSpecificPathNT(CInstance *pInstance,
                        const WCHAR* sDrive, const WCHAR* sDir, DWORD dwReqProps)
{
	WIN32_FIND_DATAW
				stFindData,
				*pfdToLoadProp;
	HANDLE	hFind;
	WCHAR		szFSName[_MAX_PATH] = L"";
	BOOL		bIsRoot = !wcscmp(sDir, L"");  // sDir contains the path and name of file, so if that combination is just empty, we are indeed looking at the root.
	_bstr_t	bstrFullPath,
				bstrRoot;

	bstrFullPath = sDrive;
	bstrFullPath += sDir;

	bstrRoot = sDrive;
	bstrRoot += L"\\";

    bool fContinue = true;
    HRESULT hr = WBEM_E_NOT_FOUND;

	// if the directory contained a wildcard character, return WBEM_E_NOT_FOUND.
	if (wcspbrk(sDir,L"?*") != NULL)
    {
    	fContinue = false;
    }

	// FindFirstW doesn't work with root dirs (since they're not real dirs.)
    DWORD dwErr = E_FAIL;

    if(fContinue)
    {
	    if (bIsRoot)
        {
		    pfdToLoadProp = NULL;
        }
	    else
	    {
		    pfdToLoadProp = &stFindData;
		    ZeroMemory(&stFindData, sizeof(stFindData));

		    hFind = FindFirstFileW((LPCWSTR) bstrFullPath, &stFindData);
            dwErr = ::GetLastError();
		    if (hFind == INVALID_HANDLE_VALUE)
            {
		        fContinue = false;
            }
		    FindClose(hFind);
	    }
    }

	// If GetVolumeInformationW fails, only get out if we're trying
	// to get the root.
    BOOL fGotVolInfo = FALSE;

    if(fContinue)
    {
        try
        {
            if(dwReqProps & PROP_FILE_SYSTEM)
            {
                fGotVolInfo = GetVolumeInformationW(bstrRoot, NULL, 0, NULL, NULL, NULL,
		        szFSName, sizeof(szFSName)/sizeof(WCHAR));
                dwErr = ::GetLastError();
                if(!fGotVolInfo && bIsRoot)
                {
                    fContinue = false;
                }
            }
        }
        catch(...)
        {
            if(!fGotVolInfo && bIsRoot)
            {
                fContinue = false;
            }
        }
    }

	if(fContinue)
    {
        if(!IsOneOfMe(pfdToLoadProp, bstrFullPath))
        {
		    fContinue = false;;
        }
    }

    if(fContinue)
    {
	    if (bIsRoot)
        {
            LoadPropertyValuesNT(pInstance, sDrive, sDir, szFSName, NULL, dwReqProps, NULL);
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            // sDir contains \\path\\morepath\\filename.exe at this point, instead
            // of just \\path\\morepath\\, so need to hack of the last part.
		    WCHAR* wstrJustPath = NULL ;
		    try
		    {
			    wstrJustPath = (WCHAR*) new WCHAR[wcslen(sDir) + 1];
			    WCHAR* pwc = NULL;
			    ZeroMemory(wstrJustPath,(wcslen(sDir) + 1)*sizeof(WCHAR));
			    wcscpy(wstrJustPath,sDir);
			    pwc = wcsrchr(wstrJustPath, L'\\');
			    if(pwc != NULL)
			    {
				    *(pwc+1) = L'\0';
			    }
			    LoadPropertyValuesNT(pInstance, sDrive, wstrJustPath, szFSName, pfdToLoadProp, dwReqProps, NULL);
                hr = WBEM_S_NO_ERROR;

		    }
		    catch ( ... )
		    {
                if ( wstrJustPath )
			    {
				    delete wstrJustPath ;
				    wstrJustPath = NULL ;
			    }
			    throw ;
		    }

			delete wstrJustPath;
			wstrJustPath = NULL ;
        }
    }

	return hr;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::DetermineReqProps
 *
 *  DESCRIPTION : Determines which of a certain set of properties are required
 *
 *  INPUTS      : Reference to query object, DWORD bit field
 *
 *  OUTPUTS     : None.
 *
 *  RETURNS     : Number of properties newly determined to be required
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
LONG CImplement_LogicalFile::DetermineReqProps(CFrameworkQuery& pQuery,
                                               DWORD* pdwReqProps)
{
    DWORD dwRet = PROP_NO_SPECIAL;
    LONG lNumNewPropsSet = 0L;
    dwRet |= *pdwReqProps;

    if(pQuery.KeysOnly())
    {
        dwRet |= PROP_KEY_ONLY;
        lNumNewPropsSet++;
    }
    else
    {
        if(pQuery.IsPropertyRequired(IDS_CompressionMethod))
        {
            dwRet |= PROP_COMPRESSION_METHOD;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_EncryptionMethod))
        {
            dwRet |= PROP_ENCRYPTION_METHOD;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_FileType))
        {
            dwRet |= PROP_FILE_TYPE;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Manufacturer))
        {
            dwRet |= PROP_MANUFACTURER;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Version))
        {
            dwRet |= PROP_VERSION;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Target))
        {
            dwRet |= PROP_TARGET;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_Filesize))
        {
            dwRet |= PROP_FILESIZE;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_FSName))
        {
            dwRet |= PROP_FILE_SYSTEM;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_AccessMask))
        {
            dwRet |= PROP_ACCESS_MASK;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_CreationDate))
        {
            dwRet |= PROP_CREATION_DATE;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_LastAccessed))
        {
            dwRet |= PROP_LAST_ACCESSED;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_LastModified))
        {
            dwRet |= PROP_LAST_MODIFIED;
            lNumNewPropsSet++;
        }
        if(pQuery.IsPropertyRequired(IDS_InstallDate))
        {
            dwRet |= PROP_INSTALL_DATE;
            lNumNewPropsSet++;
        }
        // Additionally, if certain items were asked for
        // for which we must get other info, change the flags
        // to suit.
        if((dwRet & PROP_ACCESS_MASK) ||
           (dwRet & PROP_CREATION_DATE) ||
           (dwRet & PROP_LAST_ACCESSED) ||
           (dwRet & PROP_LAST_MODIFIED) ||
           (dwRet & PROP_INSTALL_DATE))
        {
            dwRet |= PROP_FILE_SYSTEM;
        }

    }
    *pdwReqProps = dwRet;
    return lNumNewPropsSet;
}


/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetAllProps
 *
 *  DESCRIPTION : Determines if base class properties are required, or if only
 *                derived class properties will suffice.
 *
 *  INPUTS      : The name of the class that the request is satisfying
 *
 *  OUTPUTS     : None.
 *
 *  RETURNS     : true if base class properties are required
 *
 *  COMMENTS    : It should be noted that this function accomplishes something
 *                different from what DetermineReqProps supports.  This function gives us
 *                the ability to get all the properties for a given instance of,
 *                say, Win32_Shortcutfile only once when we specify * in the query,
 *                rather than twice (once in the Win32_Shortcutfile instance,
 *                and once in the Cim_DataFile instance).  It also allows us to
 *                intelligently modify queries in some cases (for instance, we
 *                can specify an extension of "lnk" (if we are looking for
 *                Win32_Shortcutfile instances) in ExecQuery.
 *
 *****************************************************************************/
bool CImplement_LogicalFile::GetAllProps()
{
    bool fRet = false;
    CHString chstr(GetProviderName());
    if(chstr.CompareNoCase(PROPSET_NAME_CIMDATAFILE)==0 ||
        chstr.CompareNoCase(PROPSET_NAME_DIRECTORY)==0)
    {
        fRet = true;
    }
    return fRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::IsClassShortcutFile
 *
 *  DESCRIPTION : Determines if the class passed in was a Win32_ShortcutFile.
 *
 *  INPUTS      : The name of the class that the request is satisfying
 *
 *  OUTPUTS     : None.
 *
 *  RETURNS     : true if class is Win32_ShortcutFile.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CImplement_LogicalFile::IsClassShortcutFile()
{
    bool fRet = false;
    CHString chstr(typeid(*this).name());
    if(chstr.CompareNoCase(L"class CShortcutFile")==0)
    {
        fRet = true;
    }
    return fRet;
}



/*****************************************************************************
 *
 *  FUNCTION    : CImplement_LogicalFile::GetPathPieces
 *
 *  DESCRIPTION : Helper that does splitpath work on chstrings.
 *
 *  INPUTS      : Full path name
 *
 *  OUTPUTS     : path components
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
void CImplement_LogicalFile::GetPathPieces(const CHString& chstrFullPathName,
                                           CHString& chstrDrive,
                                           CHString& chstrPath,
                                           CHString& chstrName,
                                           CHString& chstrExt)
{
    WCHAR* wstrDrive = NULL;
    WCHAR* wstrPath = NULL;
    WCHAR* wstrFile = NULL;
    WCHAR* wstrExt = NULL;

    try
    {
        wstrDrive = new WCHAR[_MAX_PATH];
        wstrPath = new WCHAR[_MAX_PATH];
        wstrFile = new WCHAR[_MAX_PATH];
        wstrExt = new WCHAR[_MAX_PATH];

		ZeroMemory(wstrDrive, _MAX_PATH*sizeof(WCHAR));
		ZeroMemory(wstrPath, _MAX_PATH*sizeof(WCHAR));
		ZeroMemory(wstrFile, _MAX_PATH*sizeof(WCHAR));
		ZeroMemory(wstrExt, _MAX_PATH*sizeof(WCHAR));

		if(wstrDrive != NULL && wstrPath != NULL && wstrFile != NULL && wstrExt != NULL)
		{

#ifdef WIN9XONLY
			_bstr_t bstrtFullPathName((LPCWSTR)chstrFullPathName);
			_wsplitpath(bstrtFullPathName,wstrDrive,wstrPath,wstrFile,wstrExt);
#endif
#ifdef NTONLY
		_wsplitpath((LPCTSTR)chstrFullPathName,wstrDrive,wstrPath,wstrFile,wstrExt);
#endif
			chstrDrive = wstrDrive;
			chstrPath = wstrPath;
			chstrName = wstrFile;
			chstrExt = wstrExt;
		}
    }
    catch(...)
    {
        if(wstrDrive != NULL)
        {
            delete wstrDrive;
            wstrDrive = NULL;
        }
        if(wstrPath != NULL)
        {
            delete wstrPath;
            wstrPath = NULL;
        }
        if(wstrFile != NULL)
        {
            delete wstrFile;
            wstrFile = NULL;
        }
        if(wstrExt != NULL)
        {
            delete wstrExt;
            wstrExt = NULL;
        }
        throw;
    }

    if(wstrDrive != NULL)
    {
        delete wstrDrive;
        wstrDrive = NULL;
    }
    if(wstrPath != NULL)
    {
        delete wstrPath;
        wstrPath = NULL;
    }
    if(wstrFile != NULL)
    {
        delete wstrFile;
        wstrFile = NULL;
    }
    if(wstrExt != NULL)
    {
        delete wstrExt;
        wstrExt = NULL;
    }
}

void CImplement_LogicalFile::GetExtendedProperties(CInstance* pInstance, long lFlags /*= 0L*/)
{
}


bool CImplement_LogicalFile::DrivePresent(LPCTSTR tstrDrive)
{
    bool fRet = false;
    // Convert the drive letter to a number (the indeces are 1 based)
	int nDrive = ( toupper(*tstrDrive) - 'A' ) + 1;

#ifdef NTONLY
	// The following code was lifted from Knowledge Base Article
	// Q163920.  The code uses DeviceIoControl to discover the
	// type of drive we are dealing with.

	TCHAR szDriveName[8];
	wsprintf(szDriveName, TEXT("\\\\.\\%c:"), TEXT('@') + nDrive);

    DWORD dwAccessMode = FILE_READ_ACCESS;

	SmartCloseHandle hVMWIN32 = CreateFile (szDriveName,
		                                    dwAccessMode,
		                                    FILE_SHARE_WRITE | FILE_SHARE_READ,
		                                    0,
		                                    OPEN_EXISTING,
		                                    0,
		                                    0);

	if ( hVMWIN32 != INVALID_HANDLE_VALUE )
	{
        // Verify media present...
		DWORD t_BytesReturned ;
		if(DeviceIoControl(hVMWIN32,
//#if NTONLY >= 5
//			               IOCTL_STORAGE_CHECK_VERIFY ,
//#else
                           IOCTL_DISK_CHECK_VERIFY,
//#endif
			               NULL,
			               0,
			               NULL,
			               0,
			               &t_BytesReturned,
			               0))
        {
            fRet = true;
        }
    }
#endif
#ifdef WIN9XONLY
    DEVICEPARMS dpb;
    EA_DEVICEPARAMETERS eadpb;
	dpb.btSpecialFunctions = 0;  // return default type; do not hit disk
    if(GetDeviceParms(&dpb, nDrive) || GetDeviceParmsFat32(&eadpb, nDrive))
    {
        fRet = true;
    }
#endif

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\irq.cpp ===
////////////////////////////////////////////////////////////////////

//

// IRQ.CPP -- IRQ managed object implementation

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
// 09/10/96     jennymc     Updated to current standards
// 09/12/97		a-sanjes	Added LocateNTOwnerDevice and added
//							change to get IRQ number from IRQ Level,
//	1/16/98		a-brads		Updated to V2 MOF
//
/////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <cregcls.h>

#include <ole2.h>
#include <conio.h>
#include <iostream.h>

#include "ntdevtosvcsearch.h"
#include "chwres.h"

#include "IRQ.h"
#include "resource.h"

// Property set declaration
//=========================
CWin32IRQResource MyCWin32IRQResourceSet(PROPSET_NAME_IRQ, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::CWin32IRQResource
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32IRQResource::CWin32IRQResource(

	LPCWSTR name,
	LPCWSTR pszNamespace

) :  Provider(name , pszNamespace)
{
}
/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::~CWin32IRQResource
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32IRQResource::~CWin32IRQResource()
{
}
/*****************************************************************************
 *
 *  FUNCTION    : GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
HRESULT CWin32IRQResource::GetObject(CInstance* pInstance, long lFlags /*= 0L*/)
{
    HRESULT hr = WBEM_E_FAILED;

#if NTONLY == 4

	hr = GetNTIRQ(NULL , pInstance);

#endif

#if defined(WIN9XONLY)

	hr = GetWin9XIRQ(NULL , pInstance);

#endif 

#if NTONLY > 4

    hr = GetW2KIRQ(NULL , pInstance);

#endif

    if (FAILED(hr))
	{
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32IRQResource::EnumerateInstances(

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_FAILED;

#if NTONLY == 4

	hr = GetNTIRQ(pMethodContext , NULL);

#endif

#if defined(WIN9XONLY)

	hr = GetWin9XIRQ(pMethodContext , NULL);

#endif

#if NTONLY > 4

	hr = GetW2KIRQ(pMethodContext , NULL);

#endif


    return hr;
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CWin32IRQResource::SetCommonProperties(
    CInstance *pInstance,
    DWORD dwIRQ,
    BOOL bHardware)
{
	WCHAR    szName[_MAX_PATH];
    CHString strDesc;

	swprintf(
        szName,
		L"IRQ%u",
		dwIRQ);

	pInstance->SetCharSplat(IDS_Name, szName);

	Format(strDesc,
		IDR_IRQFormat,
		dwIRQ);

    pInstance->SetDWORD(L"IRQNumber", dwIRQ);

	pInstance->SetCharSplat(IDS_Caption, strDesc);
	pInstance->SetCharSplat(IDS_Description, strDesc);
    pInstance->SetCharSplat(IDS_CSName, GetLocalComputerName());
	pInstance->SetCharSplat(IDS_CSCreationClassName, L"Win32_ComputerSystem");
    pInstance->SetCharSplat(IDS_Status, L"OK");
    pInstance->SetDWORD(L"TriggerLevel", 2); // 2 == Unknown
    pInstance->SetDWORD(L"TriggerType", 2); // 2 == Unknown

	SetCreationClassName(pInstance);

	// Indicate whether it's a software(Internal) or hardware IRQ.
    // This property is stupid, as all the interrupts we can detect
    // are associated with hardware.  Some interrupt channels
    // serve dual software and hardware roles (via the OS hooking
    // into them on bootup).  Since this property can only be either
    // true or false (and our data is either true or true + software, 
    // we'll go with true).
	pInstance->SetDWORD(L"Hardware", TRUE);

    // Set Availability to Unknown since there's no good way to get this.
    pInstance->SetDWORD(L"Availability", 2);
}


/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::GetxxxIRQ
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#if NTONLY > 4
HRESULT CWin32IRQResource::GetW2KIRQ(
    MethodContext* pMethodContext,
    CInstance* pSpecificInstance)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInstancePtr pInstanceAlias(pSpecificInstance);
    
    //=======================================
    // If we are refreshing a specific
    // instance, get which channel we are
    // going for
    //=======================================
	DWORD dwIndexToRefresh;
    if(pInstanceAlias)
	{
        pInstanceAlias->GetDWORD(L"IRQNumber", dwIndexToRefresh);
	}

    CConfigManager cfgManager;
    CDeviceCollection deviceList;
    std::set<long> setIRQ;
    bool fDone = false; 
    bool fFound = false;

    if(cfgManager.GetDeviceList(deviceList))
    {
        REFPTR_POSITION posDev;

        if(deviceList.BeginEnum(posDev))
        {
            // Walk the list
            CConfigMgrDevicePtr pDevice;
            for(pDevice.Attach(deviceList.GetNext(posDev));
                SUCCEEDED(hr) && (pDevice != NULL) && !fDone;
                pDevice.Attach(deviceList.GetNext(posDev)))
            {
				// Enumerate the device's IRQ resource usage...
                CIRQCollection DevIRQCollection;
                REFPTR_POSITION posIRQ;

                pDevice->GetIRQResources(DevIRQCollection);

                if(DevIRQCollection.BeginEnum(posIRQ))
                {
                    CIRQDescriptorPtr pIRQ(NULL);
                    // Walk the dma's
                    for(pIRQ.Attach(DevIRQCollection.GetNext(posIRQ));
                        pIRQ != NULL && !fDone && SUCCEEDED(hr);
                        pIRQ.Attach(DevIRQCollection.GetNext(posIRQ)))
                    {
                        ULONG ulIRQNum = pIRQ->GetInterrupt();

				        // If we are just trying to refresh a 
                        // specific one and it is NOT
				        // the one we want, get the next one...
				        if(!pMethodContext) // we were called by GetObject
				        {
					        if(dwIndexToRefresh != ulIRQNum)
					        {
						        continue;
					        }
                            else
                            {
                                SetCommonProperties(pInstanceAlias, ulIRQNum, TRUE);
                                fDone = fFound = true;
                            }
				        }
				        else  // We were called by enum
				        {
                            // If we don't have this IRQ already,
                            if(!FoundAlready(ulIRQNum, setIRQ))
				            {
					            // add it to the list,
                                setIRQ.insert(ulIRQNum);
                                // create a new instance,
                                pInstanceAlias.Attach(CreateNewInstance(pMethodContext));
                                SetCommonProperties(pInstanceAlias, ulIRQNum, TRUE);
                                // and commit it.
                                hr = pInstanceAlias->Commit();
                            }
                        }
                    }
                    DevIRQCollection.EndEnum();
				}
            }
            deviceList.EndEnum();
        }
    }

    if(!fFound)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr ;
}


bool CWin32IRQResource::FoundAlready(
    ULONG ulKey,
    std::set<long>& S)
{
    return (S.find(ulKey) != S.end());
}

#endif


#if NTONLY == 4

HRESULT CWin32IRQResource::GetNTIRQ(

	MethodContext *pMethodContext ,
    CInstance *pInstance
)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//=======================================
	// If we are refreshing a specific
	// instance, get which channel we are
	// going for
	//=======================================

	DWORD IndexToRefresh = 0;
	BOOL t_Found;

	if (!pMethodContext)
	{
		pInstance->GetDWORD(L"IRQNumber" , IndexToRefresh);
        t_Found  = FALSE;
	}
    else
    {
        t_Found = TRUE;
    }


	//=======================================
	// Create hardware system resource list &
	// get the head of the list
	//=======================================

	CHWResource HardwareResource;
	HardwareResource.CreateSystemResourceLists();

	SYSTEM_RESOURCES SystemResource;
	SystemResource = HardwareResource._SystemResourceList;
	unsigned int iUsed [8] = {0, 0, 0, 0, 0, 0, 0, 0};

	LPRESOURCE_DESCRIPTOR ResourceDescriptor;

	for (	ResourceDescriptor = SystemResource.InterruptHead;
			ResourceDescriptor != NULL && SUCCEEDED(hr);
			ResourceDescriptor = ResourceDescriptor->NextSame
	)
	{

		BOOL t_Status = BitSet(iUsed , ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level , sizeof(iUsed));
		if (!t_Status)
		{
			CInstancePtr pInstCreated;

            //===============================================================
			//  If we are just trying to refresh a specific one and it is NOT
			//  the one we want, get the next one...
			//===============================================================

			if (!pMethodContext)
			{
				if (IndexToRefresh != ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level)
				{
					continue;
				}
			}
			else
			{
                pInstance = CreateNewInstance(pMethodContext);
                pInstCreated.Attach(pInstance);
			}

			//=========================================================
			//  Now, we got here, so we want to get all of the info
			//=========================================================
            SetCommonProperties(
                pInstance,
                ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level,
                ResourceDescriptor->InterfaceType != Internal);

			pInstance->SetDWORD(L"Vector" , ResourceDescriptor->CmResourceDescriptor.u.Interrupt.Vector);

			//=========================================================
			// Interrupt Level and Actual IRQ Number appear to be the
			// same thing.
			//=========================================================

			//===============================================================
			//  If we just want this one, then break out of here, otherwise
			//  get them all
			//===============================================================

			if (!pMethodContext)
			{
                t_Found = TRUE;
                break;
			}
			else
			{
				hr = pInstance->Commit();
            }
		}
	}

    if (!t_Found)
    {
        hr = WBEM_E_NOT_FOUND;
    }

	return hr;
}

#endif



#if defined(WIN9XONLY)

HRESULT CWin32IRQResource::GetWin9XIRQ(

	MethodContext *pMethodContext ,
	CInstance *pInstance
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //=================================================================
    // If we are refreshing a specific instance, get which channel we
    // are going for
    //=================================================================

    DWORD IndexToRefresh;

    if (pInstance)
	{
        pInstance->GetDWORD(L"IRQNumber", IndexToRefresh);
    }

    //=================================================================
    // Get the latest IRQ info from the Configuration Manager
    //=================================================================

    CConfigManager CMgr(ResType_IRQ);

    if (CMgr.RefreshList())
	{
		unsigned int iUsed [8] = {0, 0, 0, 0, 0, 0, 0, 0};

        for (int i = 0; i < CMgr.GetTotal() && (SUCCEEDED(hr) ||
            hr == WBEM_E_NOT_FOUND); i++)
		{
            //=========================================================
            //  Get the instance to process
            //=========================================================
            IRQ_INFO *pIRQ = CMgr.GetIRQ(i);

			BOOL t_Status = BitSet(iUsed , pIRQ->IRQNumber , sizeof(iUsed));
            if (!t_Status)
			{
    			CInstancePtr pInstCreated;
                DWORD        dwIRQ = pIRQ->IRQNumber;

				//=========================================================
				//  If we are just trying to refresh a specific one and it
				//  is NOT the one we want, get the next one...
				//=========================================================

				if (!pMethodContext)
				{
					if (IndexToRefresh != dwIRQ)
					{
						continue;
					}
				}
				else
				{
                    pInstance = CreateNewInstance(pMethodContext);
                    pInstCreated.Attach(pInstance);
				}

				//  Get what we can
                SetCommonProperties(
                    pInstance,
                    dwIRQ,
                    dwIRQ);

				if (!pMethodContext)
				{
					return S_OK;
				}
				else
				{
					hr = pInstance->Commit();
				}
			}
		}

        // If we get here with a null pMethodContext, our GetObject failed to
        // find the requested IRQ.
        if (!pMethodContext)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32IRQResource::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each logical disk
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    : Bit number in iPos are zero based
 *
 *****************************************************************************/

bool CWin32IRQResource::BitSet(
	unsigned int iUsed[],
	ULONG iPos,
	DWORD iSize
)
{
	bool bRet;

    // iIndex is which DWORD to modify
	DWORD iIndex = iPos / (sizeof(iUsed[0]) * 8);

    // Make sure we have that many dwords
	if (iIndex < iSize)
	{
	    // I don't know why I need these, but if I don't use them, the compiler keeps
	    // adding code to extend the sign.  Once the optimizer gets this, it shouldn't
	    // matter anyway.
		unsigned int a1, a2;

        // a1 will tell how many bits over within the current dword
        // we need to move
		a1 =   iPos - (iIndex * (sizeof(iUsed[0]) * 8));

        // a2 will have set the bit we are trying to set
		a2 = 1 << a1;

        // The return value will indicate whether that bit had already been set.
		bRet = iUsed[iIndex] & a2;

		iUsed[iIndex] |= a2;
	}
	else
	{
		bRet = false;
		LogErrorMessage(L"Overflow on irq table");
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\keyboard.cpp ===
//=================================================================

//

// Keyboard.CPP --Keyboard property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97	 a-hhance       ported to new world order
//
//=================================================================

#include "precomp.h"

#include "Keyboard.h"
#include <vector>
#include "resource.h"

// Property set declaration
//=========================
Keyboard MyKeyboardSet ( PROPSET_NAME_KEYBOARD , IDS_CimWin32Namespace ) ;

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::Keyboard
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

Keyboard :: Keyboard (

	LPCWSTR name,
	LPCWSTR pszNamespace

) : Provider ( name , pszNamespace )
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::~Keyboard
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

Keyboard :: ~Keyboard ()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::GetObject
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    : Makes the assumption that there exists only one keyboard --
 *                this will be enhanced later
 *
 *****************************************************************************/

HRESULT Keyboard :: GetObject (

	CInstance *pInstance,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Make a list of the keyboards that exist

    std::vector<CHString> vecchstrKeyboardList ;
    GenerateKeyboardList ( vecchstrKeyboardList ) ;

    CHString chstrTemp;
    pInstance->GetCHString ( IDS_DeviceID , chstrTemp ) ;

    LONG lKeyboardIndex = -1 ;

    // Need to confirm that the keyboard really exists

    if ( ( lKeyboardIndex = ReallyExists ( chstrTemp , vecchstrKeyboardList ) ) != -1 )
    {
        // If so, first, load the PNPDeviceID out of the list

        pInstance->SetCHString ( IDS_PNPDeviceID , vecchstrKeyboardList [ lKeyboardIndex ] ) ;

        // then load the rest of the property values.

        hr = LoadPropertyValues ( pInstance ) ;
    }

    if ( FAILED ( hr ) )
    {
        hr = WBEM_E_NOT_FOUND ;
    }

	return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for each installed client
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : Number of instances created
 *
 *  COMMENTS    : Makes the assumption that there exists only one keyboard --
 *                this will be enhanced later
 *
 *****************************************************************************/

HRESULT Keyboard :: EnumerateInstances (

	MethodContext *pMethodContext,
	long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Make a list of keyboard PNPDeviceID's from config manager:

    std::vector<CHString> vecchstrKeyboardList;
    GenerateKeyboardList(vecchstrKeyboardList);

    for ( LONG m = 0L ; m < vecchstrKeyboardList.size () && SUCCEEDED ( hr ) ; m++ )
    {
        CInstancePtr pInstance(CreateNewInstance ( pMethodContext ), false) ;

		// Set keyboard data
		pInstance->SetCHString ( IDS_PNPDeviceID , vecchstrKeyboardList [ m ] ) ;
		pInstance->SetCharSplat ( IDS_DeviceID , vecchstrKeyboardList [ m ] ) ;

		// Commit the instance

		hr = LoadPropertyValues(pInstance);

		if ( SUCCEEDED ( hr ) )
		{
			hr = pInstance->Commit ( ) ;
        }
    }
    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to property set
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT Keyboard::LoadPropertyValues(CInstance* pInstance)
{

	// If we were able to get a Keyboard Type, assume the keyboard is
	// installed, otherwise not.

    // All we get here is type

    int nKeyboardType = GetKeyboardType ( 0 ) ;

	if ( 0 != nKeyboardType )
	{
        CHString sTemp2;

        switch ( nKeyboardType )
        {
			case 1:
			{
                LoadStringW(sTemp2, IDR_PCXT);
			}
			break ;

			case 2:
			{
                LoadStringW(sTemp2, IDR_ICO);
			}
			break ;

			case 3:
			{
                LoadStringW(sTemp2, IDR_PCAT);
			}
			break ;

			case 4:
			{
                LoadStringW(sTemp2, IDR_ENHANCED101102);
			}
			break ;

			case 5:
			{
                LoadStringW(sTemp2, IDR_NOKIA1050);
			}
			break ;

			case 6:
			{
                LoadStringW(sTemp2, IDR_NOKIA9140);
			}
			break ;

			case 7:
			{
                LoadStringW(sTemp2, IDR_Japanese);
			}
			break ;

			default:
			{
                LoadStringW(sTemp2, IDR_UnknownKeyboard);
			}
			break ;
		}

		pInstance->SetCHString(IDS_Name, sTemp2);
		pInstance->SetCHString(IDS_Caption, sTemp2);

		pInstance->SetDWORD ( IDS_NumberOfFunctionKeys , (DWORD) GetKeyboardType ( 2 ) ) ;

	    TCHAR szTemp [ _MAX_PATH ] ;
		if ( GetKeyboardLayoutName ( szTemp ) )
        {
			pInstance->SetCharSplat(IDS_Layout, szTemp);
		}

		pInstance->Setbool ( IDS_PowerManagementSupported , FALSE ) ;

        // Need the PNPDeviceID in order to get the device description:

        CHString chstrPNPDID;
        if ( pInstance->GetCHString ( IDS_PNPDeviceID , chstrPNPDID ) )
        {
            GetDevicePNPInformation ( pInstance , chstrPNPDID ) ;
        }

	    pInstance->SetCharSplat ( IDS_SystemCreationClassName , L"Win32_ComputerSystem" ) ;
  	    pInstance->SetCHString ( IDS_SystemName , GetLocalComputerName () ) ;

	    // Saves the creation class name

	    SetCreationClassName ( pInstance ) ;
	}

	// Returns whether or not we got an initial keyboard type
    return ( nKeyboardType ?  WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
}


/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::GetDeviceDescription
 *
 *  DESCRIPTION : helper to obtain a device's description given its PNPDeviceID.
 *
 *  INPUTS      : chstrPNPDevID - pnp device id of device of interest
 *
 *  OUTPUTS     : chstrDeviceDescription - Device description (which is what we
 *                   use as the DeviceID in the mof for this class).
 *
 *  RETURNS     : LONG: reference in array of the keyboard (zero based).
 *                   -1L will be returned if the element isn't in the array.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL Keyboard::GetDevicePNPInformation (

	CInstance *a_Instance,
	CHString& chstrPNPDevID
)
{
    BOOL fRet = FALSE;

    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pKeyboard;

    if ( cfgmgr.LocateDevice ( chstrPNPDevID, & pKeyboard ) )
    {
		CHString chstrDeviceDescription ;
		if ( pKeyboard->GetDeviceDesc ( chstrDeviceDescription ) )
		{
			a_Instance->SetCHString ( IDS_Description , chstrDeviceDescription ) ;

			fRet = TRUE;
		}

		SetConfigMgrProperties ( pKeyboard , a_Instance ) ;

		DWORD t_ConfigStatus = 0 ;
		DWORD t_ConfigError = 0 ;

		if ( pKeyboard->GetStatus ( &t_ConfigStatus , & t_ConfigError ) )
		{
			CHString t_chsTmp ;
			ConfigStatusToCimStatus ( t_ConfigStatus , t_chsTmp ) ;

			a_Instance->SetCHString ( IDS_Status, t_chsTmp ) ;
		}
    }

	if ( ! fRet )
	{
	    CHString chstrDeviceDescription ;

		a_Instance->GetCHString ( IDS_Caption , chstrDeviceDescription ) ;
		a_Instance->SetCHString ( IDS_Description , chstrDeviceDescription ) ;
	}

    return fRet;
}



/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::GenerateKeyboardList
 *
 *  DESCRIPTION : helper to construct a list of keyboards by their PNPDeviceIDs
 *
 *  INPUTS      : stl vector of CHStrings
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : none
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
VOID Keyboard::GenerateKeyboardList(std::vector<CHString>& vecchstrKeyboardList)
{

    BOOL fGotDevList = FALSE ;

    CConfigManager cfgmgr;
    CDeviceCollection deviceList ;

#ifdef NTONLY

    BOOL bIsNT5 = IsWinNT5 () ;
    if(bIsNT5)
    {
        //fGotDevList = cfgmgr.GetDeviceListFilterByClassGUID(deviceList, "{4D36E96B-E325-11CE-BFC1-08002BE10318}");

        // HID USB devices are returned this way, but without any bus information, which causes an enumeration
        // of what devices are on a USB bus to fail.  So we do it the following way:
        // 1) Get all the devices where the class is {4D36E96B-E325-11CE-BFC1-08002BE10318}.  Also get all devices where service is "HidUsb".
        // 2) Go through list of devices returned from "kbdclass", and see if the DeviceId for the device
        //    includes the string HID at the beginning.
        // 3) If one is found (format of string is HID\xxxxxxx\yyyyy), compare xxxxxx to the DeviceID of the
        //    devices returned from enumeration of devices where service is "HidUsb" from step 1 (format of these
        //    entries is similarly USB\zzzzzzz\qqqqq)
        //    a. If xxxxxx == zzzzzzz, then add device zzzzzzz to the vector.
        // 4) If we can't find a matching HID entry, use what we got

        CDeviceCollection HIDDeviceList;

        cfgmgr.GetDeviceListFilterByClassGUID(deviceList, _T("{4D36E96B-E325-11CE-BFC1-08002BE10318}"));
        cfgmgr.GetDeviceListFilterByService(HIDDeviceList, _T("HidUsb"));

        REFPTR_POSITION pos = 0;
        if ( deviceList.BeginEnum ( pos ) )
        {
            CConfigMgrDevicePtr pKeyboard;

            for (pKeyboard.Attach(deviceList.GetNext ( pos ));
                 pKeyboard != NULL;
                 pKeyboard.Attach(deviceList.GetNext ( pos )))
            {
				CHString chstrPNPDevID ;
				if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) != NULL )
				{
					CHString chstrPrefix = chstrPNPDevID.Left(3);
					BOOL fGotMatchingHID = FALSE;
					if(chstrPrefix == _T("HID"))
					{
						REFPTR_POSITION posHID = 0;
						if(chstrPNPDevID.GetLength() > 4)
						{
							CHString chstrMiddlePart = chstrPNPDevID.Mid(4);
							LONG m = chstrMiddlePart.ReverseFind(_T('\\'));
							if(m != -1)
							{
								chstrMiddlePart = chstrMiddlePart.Left(m);

								if(HIDDeviceList.BeginEnum(posHID))
								{
									CConfigMgrDevicePtr pHID;

                                    for (pHID.Attach(HIDDeviceList.GetNext ( posHID ) );
                                         (pHID != NULL) && ( ! fGotMatchingHID );
                                         pHID.Attach(HIDDeviceList.GetNext ( posHID ) ))
									{
										CHString chstrPNPHIDDevID ;
										if ( pHID->GetDeviceID ( chstrPNPHIDDevID ) != NULL )
										{
											if ( chstrPNPHIDDevID.GetLength () > 4 )
											{
												CHString chstrHIDMiddlePart = chstrPNPHIDDevID.Mid ( 4 ) ;

												m = chstrHIDMiddlePart.ReverseFind ( _T('\\') ) ;
												if ( m != -1 )
												{
													chstrHIDMiddlePart = chstrHIDMiddlePart.Left ( m ) ;

													if ( chstrHIDMiddlePart.CompareNoCase ( chstrMiddlePart ) == 0 )
													{
														fGotMatchingHID = TRUE ;
														vecchstrKeyboardList.push_back ( chstrPNPHIDDevID ) ;
													}
												}
											}
										}
									}

									HIDDeviceList.EndEnum();
								}
							}
						}
					}

					if ( ! fGotMatchingHID ) // Use what we got if couldn't find matching HID entry.
					{
						vecchstrKeyboardList.push_back ( chstrPNPDevID );
					}
				}

            }

            deviceList.EndEnum () ;
        }
    }
    else   // this works fine on Win 9x and NT4!
#endif
    {
        fGotDevList = cfgmgr.GetDeviceListFilterByClass ( deviceList, L"Keyboard" ) ;
    }



#ifdef NTONLY

    if ( fGotDevList && ! IsWinNT5 () )

#endif

#ifdef WIN9XONLY

    if ( fGotDevList )

#endif
    {
        REFPTR_POSITION pos ;
        if ( deviceList.BeginEnum ( pos ) )
        {
            CConfigMgrDevicePtr pKeyboard;
            for (pKeyboard.Attach(deviceList.GetNext ( pos ) );
                 pKeyboard != NULL;
                 pKeyboard.Attach(deviceList.GetNext ( pos ) ))
            {
				CHString chstrPNPDevID ;
				if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) )
				{
					vecchstrKeyboardList.push_back ( chstrPNPDevID ) ;
				}
            }

            deviceList.EndEnum () ;
		}
    }

#ifdef NTONLY

    // On nt4, the keyboard doesn't always get marked with class = Keyboard.  So, if the
    // code above didn't find anything, check for some common keyboard service names.

    if ( ( vecchstrKeyboardList.size () == 0 ) && ( IsWinNT4 () ) )
    {
        fGotDevList = cfgmgr.GetDeviceListFilterByService ( deviceList , _T("kbdclass") ) ;
        if ( fGotDevList )
        {
            REFPTR_POSITION pos ;
            if ( deviceList.BeginEnum ( pos ) )
            {
                CConfigMgrDevicePtr pKeyboard;
                for (pKeyboard.Attach(deviceList.GetNext ( pos ) );
                     pKeyboard != NULL;
                     pKeyboard.Attach(deviceList.GetNext ( pos ) ))
                {
					CHString chstrPNPDevID ;
					if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) )
					{
						vecchstrKeyboardList.push_back(chstrPNPDevID);
					}
                }

                deviceList.EndEnum();
            }
        }
    }

    // On nt4, the keyboard doesn't always get marked with class = Keyboard.  So, if the
    // code above didn't find anything, check for some common keyboard service names.

    if ( ( vecchstrKeyboardList.size () == 0 ) && ( IsWinNT4 () ) )
    {
        fGotDevList = cfgmgr.GetDeviceListFilterByService ( deviceList , _T("i8042prt") ) ;
        if ( fGotDevList )
        {
            REFPTR_POSITION pos ;
            if ( deviceList.BeginEnum ( pos ) )
            {
                CConfigMgrDevicePtr pKeyboard;
                for (pKeyboard.Attach(deviceList.GetNext ( pos ));
                     pKeyboard != NULL;
                     pKeyboard.Attach(deviceList.GetNext ( pos )))
                {
					CHString chstrPNPDevID;
					if ( pKeyboard->GetDeviceID ( chstrPNPDevID ) )
					{
						vecchstrKeyboardList.push_back ( chstrPNPDevID ) ;
					}
                }

                deviceList.EndEnum();
            }
        }
    }
#endif
}


/*****************************************************************************
 *
 *  FUNCTION    : Keyboard::ReallyExists
 *
 *  DESCRIPTION : helper to determine if a keyboard exists based on its mof
 *                   key.  Remember, DeviceID is the same as the PNPId.
 *
 *  INPUTS      : chsKeyboardDeviceDesc - DeviceID
 *                vecchstrKeyboardList - stl array of CHStrings containing
 *                   PNPDeviceIDs
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : LONG: reference in array of the keyboard (zero based).
 *                   -1L will be returned if the element isn't in the array.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

LONG Keyboard :: ReallyExists (

	CHString &chsKeyboardDeviceDesc ,
    std::vector<CHString>& vecchstrKeyboardList
)
{
    LONG lRet = -1;

    for ( LONG m = 0L ; ( ( m < vecchstrKeyboardList.size () ) && ( lRet == -1L ) ) ; m++ )
    {
        if ( vecchstrKeyboardList [ m ].CompareNoCase ( chsKeyboardDeviceDesc ) == 0 )
        {
            lRet = m ;
        }
    }

	return lRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\keyboard.h ===
//=================================================================

//

// Keyboard.h -- Keyboard property set provider

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    08/01/96    a-jmoon        Created
//				 10/23/97	 a-hhance       ported to new world order
//
//=================================================================

// Property set identification
//============================

#define  PROPSET_NAME_KEYBOARD  L"Win32_Keyboard"
//#define  PROPSET_UUID_KEYBOARD  L"{e0bb7140-3d11-11d0-939d-0000e80d7352}"

class Keyboard:public Provider {

    public:

        // Constructor/destructor
        //=======================

        Keyboard(LPCWSTR name, LPCWSTR pszNamespace) ;
       ~Keyboard() ;

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
       
	private:

        // Utility function(s)
        //====================
        HRESULT LoadPropertyValues(CInstance* pInstance) ;
        
        BOOL GetDevicePNPInformation (CInstance *a_Instance , CHString& chstrPNPDevID ) ;

        VOID GenerateKeyboardList(std::vector<CHString>& vecchstrKeyboardList);
        LONG ReallyExists(CHString& chsBus, std::vector<CHString>& vecchstrKeyboardList);


} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\loaddepends.cpp ===
//=================================================================

//

// LoadMember.CPP -- LoadOrderGroup to Service association provider

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    12/26/97    davwoh         Created
//
// Comments: Shows the load order groups that each service depends
//           on to start.
//
//=================================================================

#include "precomp.h"

#include "Loaddepends.h"
#include "loadorder.h"

// Property set declaration
//=========================

CWin32LoadGroupDependency MyLoadDepends(PROPSET_NAME_LOADORDERGROUPSERVICEDEPENDENCIES, IDS_CimWin32Namespace);

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::CWin32LoadGroupDependency
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32LoadGroupDependency::CWin32LoadGroupDependency(LPCWSTR setName, LPCWSTR pszNamespace)
:Provider(setName, pszNamespace)
{
   CHString sTemp(PROPSET_NAME_LOADORDERGROUP);

   sTemp += L".Name=\"";

   // Just saves us from having to constantly re-calculate this when sending
   // instances back.
   m_sGroupBase = MakeLocalPath(sTemp);
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::~CWin32LoadGroupDependency
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32LoadGroupDependency::~CWin32LoadGroupDependency()
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::GetObject
 *
 *  DESCRIPTION : Assigns values to property set according to key value
 *                already set by framework
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupDependency::GetObject(CInstance *pInstance, long lFlags /*= 0L*/)
{
   CHString sServicePath, sGroupPath;
   HRESULT hRet = WBEM_E_NOT_FOUND;
    CInstancePtr pPart;

   // Get the two paths
   pInstance->GetCHString(L"Dependent", sServicePath);
   pInstance->GetCHString(L"Antecedent", sGroupPath);

   // It is perfectly possible that a service is dependent on a group that doesn't exist
   if(SUCCEEDED(hRet = CWbemProviderGlue::GetInstanceByPath(sServicePath, &pPart, pInstance->GetMethodContext() ) ) )
   {
//      if(SUCCEEDED(CWbemProviderGlue::GetInstanceByPath( (LPCTSTR)sGroupPath, &pGroup ) ) ) {

         // Now we need to check to see if this service really is a Dependent
         CHString sServiceName;
         CHStringArray asGroupGot;
         DWORD dwSize;

         pPart->GetCHString(IDS_Name, sServiceName);

         // Get the dependent list for this service
         hRet = GetDependentsFromService(sServiceName, asGroupGot);

         if (SUCCEEDED(hRet)) 
         {
             // Haven't proveny anything yet.
             hRet = WBEM_E_NOT_FOUND;

             // Walk the list to see if we're there
             dwSize = asGroupGot.GetSize();
             for (int x=0; x < dwSize; x++) 
             {
                if (asGroupGot.GetAt(x).CompareNoCase(sGroupPath) == 0) 
                {
                   hRet = WBEM_S_NO_ERROR;
                   break;
                }
             }
         }
      }
//   }

   // There are no properties to set, if the endpoints exist, we be done

   return hRet;

}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::EnumerateInstances
 *
 *  DESCRIPTION : Creates instance of property set for cd rom
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32LoadGroupDependency::EnumerateInstances(MethodContext *pMethodContext, long lFlags /*= 0L*/)
{
    CHString sService, sServicePath;
    CHStringArray asGroupGot;
    DWORD dwSize, x;
    HRESULT hr = WBEM_S_NO_ERROR;

   // Get list of services
   //==================
   TRefPointerCollection<CInstance> Services;

//   if SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_Service"), &Services, IDS_CimWin32Namespace, pMethodContext))   {
   if SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select __relpath, Name from Win32_Service", &Services, pMethodContext, GetNamespace()))
   {
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pService;

      if (Services.BeginEnum(pos))
      {

         for (pService.Attach(Services.GetNext( pos )) ;
             (SUCCEEDED(hr)) && (pService != NULL) ;
              pService.Attach(Services.GetNext( pos )) )
             {

            pService->GetCHString(IDS_Name, sService) ;
            pService->GetCHString(L"__RELPATH", sServicePath) ;

            // See if there is a group for this service.  sGroupGot comes
            // back as a full path or as blank
            asGroupGot.RemoveAll();

            // If one service can't get its data, we still want to return the rest
            if (SUCCEEDED(GetDependentsFromService(sService, asGroupGot)))
            {

                dwSize = asGroupGot.GetSize();

                // Ok, turn the relpath into a complete path
                GetLocalInstancePath(pService, sServicePath);

                for (x=0; x < dwSize && SUCCEEDED(hr) ; x++) {
                   CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);
                   if (pInstance)
                   {
                       // Do the puts, and that's it
                       pInstance->SetCHString(L"Dependent", sServicePath);
                       pInstance->SetCHString(L"Antecedent", asGroupGot.GetAt(x));
                       hr = pInstance->Commit();
                   }
                   else
                       hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

         }

         Services.EndEnum();
      }
   }

   // GetAllInstances doesn't clear the old values, so I do it.
   Services.Empty();

//   if (SUCCEEDED(hr) &&
//      (SUCCEEDED(hr = CWbemProviderGlue::GetAllInstances(_T("Win32_SystemDriver"), &Services, IDS_CimWin32Namespace, pMethodContext))))   {

   if (SUCCEEDED(hr) &&
      (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"Select __relpath, Name from Win32_SystemDriver", &Services, pMethodContext, GetNamespace()))))
   {
      REFPTRCOLLECTION_POSITION pos;
      CInstancePtr pService;

      if (Services.BeginEnum(pos))
      {
         for (pService.Attach (Services.GetNext( pos ));
              (SUCCEEDED(hr)) && (pService != NULL);
              pService.Attach (Services.GetNext( pos )))
         {

            pService->GetCHString(L"Name", sService) ;
            pService->GetCHString(L"__RELPATH", sServicePath) ;

            // See if there is a group for this service.  sGroupGot comes
            // back as a full path or as blank
            asGroupGot.RemoveAll();
            GetDependentsFromService(sService, asGroupGot);

            dwSize = asGroupGot.GetSize();

            // Ok, turn the relpath into a complete path
            GetLocalInstancePath(pService, sServicePath);

            for (x=0; x < dwSize && SUCCEEDED(hr) ; x++)
            {
               CInstancePtr pInstance(CreateNewInstance(pMethodContext), false);

               if (pInstance)
               {
                   // Do the puts, and that's it
                   pInstance->SetCHString(L"Dependent", sServicePath);
                   pInstance->SetCHString(L"Antecedent", asGroupGot.GetAt(x));
                   hr = pInstance->Commit();
               }
               else
               {
                   hr = WBEM_E_OUT_OF_MEMORY;
               }
            }
         }

         Services.EndEnum();
      }
   }

   return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32LoadGroupDependency::GetDependentsFromService
 *
 *  DESCRIPTION : Given a service name, returns the DependOnGroup's
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : HRESULT
 *
 *  COMMENTS    : Returns empty array if no group, empty group, or bad
 *                service name.
 *
 *****************************************************************************/
HRESULT CWin32LoadGroupDependency::GetDependentsFromService(const CHString &sServiceName, CHStringArray &asArray)
{
    CRegistry RegInfo;
    CHString sGroupNames, sTemp;
    CHString sKeyName(L"SYSTEM\\CurrentControlSet\\Services\\");
    WCHAR *pszString, *pChar;
    HRESULT hr, res;

    sKeyName += sServiceName;

    // Open the key, get the name
    if ((res = RegInfo.Open(HKEY_LOCAL_MACHINE, sKeyName, KEY_READ)) == ERROR_SUCCESS) {
        if ((res = RegInfo.GetCurrentKeyValue(L"DependOnGroup", sGroupNames)) == ERROR_SUCCESS) {
            if (sGroupNames == _T("")) {
                sGroupNames.Empty();
            }
        }
    }

    // Determine what we're going to tell people
    if (res == ERROR_ACCESS_DENIED) {
        hr = WBEM_E_ACCESS_DENIED;
    } else if ((res != ERROR_SUCCESS) && (res != REGDB_E_INVALIDVALUE)) {
        hr = WBEM_E_FAILED;
    } else {
        hr = WBEM_S_NO_ERROR;
    }

    // If we found something, turn it into a full path.  m_sGroupbase
    // was set in constructor.
    if (!sGroupNames.IsEmpty()) {

        pszString = new WCHAR[(sGroupNames.GetLength() + 1)];
        if (pszString == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
        else
        {
            try
            {
                wcscpy(pszString, sGroupNames);
                pszString[lstrlenW(pszString) - 1] = 0;

                // Walk the returned string.  Note that this returns them
                // in reverse order from the registry entry.
                while (pChar = wcsrchr(pszString, '\n'))
                {
                    sTemp = m_sGroupBase + (pChar + 1); // L10N OK
                    sTemp += '"';
                    asArray.Add(sTemp);
                    *pChar = '\0';
                }

                // Get the last one
                sTemp = m_sGroupBase + pszString;
                sTemp += '"';
                asArray.Add(sTemp);
            }
            catch ( ... )
            {
                delete pszString;
                pszString = NULL;
                throw ;
            }

            delete pszString;
            pszString = NULL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\providers\kuserdata.h ===
//=================================================================

//

// KUserdata.h 

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/16/98	a-peterc        Created

//=================================================================
class KUserdata
{
    public:
	        
    BOOLEAN			IsNec98();
	ULONG			TickCountLow();
	ULONG			TickCountMultiplier();
#if defined(_WIN64)
#else
	LARGE_INTEGER	InterruptTime();
	LARGE_INTEGER	SystemTime();
	LARGE_INTEGER	TimeZoneBias();
#endif
	USHORT			ImageNumberLow();
	USHORT			ImageNumberHigh();
	WCHAR*			NtSystemRoot();
	ULONG			MaxStackTraceDepth();
	ULONG			CryptoExponent();
	ULONG			TimeZoneId();
	ULONG			NtProductType();
	BOOLEAN			ProductTypeIsValid();
	ULONG			NtMajorVersion();
	ULONG			NtMinorVersion();
	BOOLEAN			ProcessorFeatures(DWORD dwIndex, BOOLEAN& bFeature );
	ULONG			TimeSlip();
	LARGE_INTEGER	SystemExpirationDa