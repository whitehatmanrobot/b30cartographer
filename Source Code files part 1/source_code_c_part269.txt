       GlobalLog.Print( "AllocateAndInitializeSid(g_pSystemSid) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "AllocateAndInitializeSid(g_pSystemSid) succeeded" ); // + Convert.ToString( result ) );

            status =
            AllocateAndInitializeSid(
                                    pNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    ref g_pAdminSid );

            if (!status || (long)g_pAdminSid==0) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "AllocateAndInitializeSid(g_pAdminSid) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "AllocateAndInitializeSid(g_pAdminSid) succeeded" ); // + Convert.ToString( result ) );

            status =
            AllocateAndInitializeSid(
                                    pNtAuthority,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    ref pWorldAuthority );

            if (!status || (long)pWorldAuthority==0) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "AllocateAndInitializeSid(pWorldAuthority) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "AllocateAndInitializeSid(pWorldAuthority) succeeded" ); // + Convert.ToString( result ) );


            //
            // Allocate and initialize the security descriptor.
            //

            status =
            InitializeSecurityDescriptor(
                                        pSecurityDescriptor,
                                        SECURITY_DESCRIPTOR_REVISION );

            if (!status) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "InitializeSecurityDescriptor() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "InitializeSecurityDescriptor() succeeded" ); // + Convert.ToString( result ) );


            //
            // calculate the size of the DACL allocate and add all the ACLs
            //

            int daclSize
            = sizeofACL
              + sizeofACCESS_ALLOWED_ACE
              + sizeofACCESS_ALLOWED_ACE
              + sizeofACCESS_ALLOWED_ACE
              + GetLengthSid( pWorldAuthority )
              + GetLengthSid( g_pSystemSid )
              + GetLengthSid( g_pAdminSid );

            pDacl = Marshal.AllocHGlobal( daclSize );

            if ((long)pDacl == 0) {
                result = NativeMethods.ERROR_NOT_ENOUGH_MEMORY;
                GlobalLog.Print( "Marshal.AllocHGlobal() failed" );
                goto cleanup;
            }

            status =
            InitializeAcl(
                         pDacl,
                         daclSize,
                         ACL_REVISION );

            if (!status) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "InitializeAcl() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "InitializeAcl() succeeded" ); // + Convert.ToString( result ) );

            status =
            AddAccessAllowedAce(
                               pDacl,
                               ACL_REVISION,
                               FILE_ALL_ACCESS,
                               g_pSystemSid );

            if (!status) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "AddAccessAllowedAce(g_pSystemSid) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "AddAccessAllowedAce(g_pSystemSid) succeeded" ); // + Convert.ToString( result ) );

            status =
                AddAccessAllowedAce(
                               pDacl,
                               ACL_REVISION,
                               FILE_ALL_ACCESS,
                               g_pAdminSid );

            if (!status) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "AddAccessAllowedAce(g_pAdminSid) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "AddAccessAllowedAce(g_pAdminSid) succeeded" ); // + Convert.ToString( result ) );

            status =
                AddAccessAllowedAce(
                               pDacl,
                               ACL_REVISION,
                               FILE_ALL_ACCESS,
                               pWorldAuthority );

            if (!status) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "AddAccessAllowedAce(pWorldAuthority) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "AddAccessAllowedAce(pWorldAuthority) succeeded" ); // + Convert.ToString( result ) );

            //
            // Set the DACL into the security descriptor.
            //

            status =
                SetSecurityDescriptorDacl(
                                     pSecurityDescriptor,
                                     true,
                                     pDacl,
                                     false );

            if (!status) {
                result = Marshal.GetLastWin32Error();
                GlobalLog.Print( "SetSecurityDescriptorDacl() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "SetSecurityDescriptorDacl() succeeded" ); // + Convert.ToString( result ) );

            //
            // Initialize the security attributes.
            //

            Marshal.WriteInt32( pSecurityAttributes, 0, sizeofSECURITY_ATTRIBUTES ); // nLength = sizeof(SECURITY_ATTRIBUTES)
            Marshal.WriteInt32( pSecurityAttributes, 4, 0 ); // bInheritHandle = FALSE
            Marshal.WriteIntPtr( pSecurityAttributes, 8, pSecurityDescriptor ); // lpSecurityDescriptor = pSecurityDescriptor


            //
            // initialize ul.sys
            //

            result = UlInitialize(0);

            if (result != 0) {
                GlobalLog.Print( "UlInitialize() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlInitialize() succeeded" ); // + Convert.ToString( result ) );

            //
            // Open a control channel to the driver.
            //

            result =
                UlOpenControlChannel(
                                ref controlChannel,
                                0 );

            if (result != 0) {
                GlobalLog.Print( "UlOpenControlChannel() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlOpenControlChannel() succeeded" ); // + Convert.ToString( result ) );

            //
            // Create a configuration group.
            //

            result =
                UlCreateConfigGroup(
                               controlChannel,
                               ref configId );

            if (result != 0) {
                GlobalLog.Print( "UlCreateConfigGroup() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlCreateConfigGroup() succeeded" ); // + Convert.ToString( result ) );


            //
            // Add a URL to the configuration group.
            //

            result =
            UlAddUrlToConfigGroup(
                                 controlChannel,
                                 configId,
                                 uriPrefix,
                                 0 );

            if (result != 0) {
                GlobalLog.Print( "UlAddUrlToConfigGroup("+ uriPrefix + ") failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlAddUrlToConfigGroup(" + uriPrefix + ") succeeded" ); // + Convert.ToString( result ) );


            //
            // Set the config group state.
            //

            Marshal.WriteInt32( pConfigStruct, 0, 1 ); // Flags.Present = 1

            //
            // make sure which one makes sense
            //

            Marshal.WriteInt32( pConfigStruct, 4, UlEnabledStateInactive ); // State = UlEnabledStateInactive
            Marshal.WriteInt32( pConfigStruct, 4, UlEnabledStateActive ); // State = UlEnabledStateActive

            result =
                UlSetConfigGroupInformation(
                                       controlChannel,
                                       configId,
                                       UlConfigGroupStateInformation,
                                       pConfigStruct,
                                       sizeofUL_CONFIG_GROUP_STRUCT );

            if (result != 0) {
                GlobalLog.Print( "UlSetConfigGroupInformation(UlConfigGroupStateInformation) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlSetConfigGroupInformation(UlConfigGroupStateInformation) succeeded" ); // + Convert.ToString( result ) );


            //
            // Set security
            //

            Marshal.WriteInt32( pConfigStruct, 0, 1 ); // Flags.Present = 1
            Marshal.WriteIntPtr( pConfigStruct, 4, pSecurityDescriptor ); // pSecurityDescriptor = pSecurityDescriptor

            result =
            UlSetConfigGroupInformation(
                                       controlChannel,
                                       configId,
                                       UlConfigGroupSecurityInformation,
                                       pConfigStruct,
                                       sizeofUL_CONFIG_GROUP_STRUCT );

            if (result != 0) {
                GlobalLog.Print( "UlSetConfigGroupInformation(UlConfigGroupSecurityInformation) failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlSetConfigGroupInformation(UlConfigGroupSecurityInformation) succeeded" ); // + Convert.ToString( result ) );


            //
            // Throw the big switch.
            //

            int controlState = UlEnabledStateActive; // State = UlEnabledStateActive

            result =
                UlSetControlChannelInformation(
                                          controlChannel,
                                          UlControlChannelStateInformation,
                                          ref controlState,
                                          4 );

            if (result != 0) {
                GlobalLog.Print( "UlSetControlChannelInformation() failed, error:" + Convert.ToString( result ) );
                goto cleanup;
            }
            GlobalLog.Print( "UlSetControlChannelInformation(UlControlChannelStateInformation) succeeded" ); // + Convert.ToString( result ) );

            //
            // Success!
            //

            cleanup:

            if (result != 0) {
                //
                // there was an error, cleanup everything
                //

                if ((long)pSecurityAttributes != 0) {
                    Marshal.FreeHGlobal( pSecurityAttributes );
                }
                if ((long)pSecurityDescriptor != 0) {
                    Marshal.FreeHGlobal( pSecurityDescriptor );
                }

                //
                // delete config group
                //

                if (configId !=0) {
                    int result2 =
                    UlDeleteConfigGroup(
                                       controlChannel,
                                       configId );

                    if (result2 != 0) {
                        GlobalLog.Print( "UlDeleteConfigGroup() failed, error:" + Convert.ToString( result2 ) );
                    }
                }

                //
                // close handles
                //

                if ((long)appPool != 0) {
                    NativeMethods.CloseHandle( appPool );
                }

                if ((long)controlChannel != 0) {
                    NativeMethods.CloseHandle( controlChannel );
                }
            }

            //
            // free unmanaged memory we will not need anymore
            //

            if ((long)pConfigStruct != 0) {
                Marshal.FreeHGlobal( pConfigStruct );
            }
            if ((long)pDacl != 0) {
                Marshal.FreeHGlobal( pDacl );
            }
            if ((long)pWorldAuthority != 0) {
                Marshal.FreeHGlobal( pWorldAuthority );
            }
            if ((long)g_pAdminSid != 0) {
                FreeSid( g_pAdminSid );
            }
            if ((long)g_pSystemSid != 0) {
                FreeSid( g_pSystemSid );
            }
            if ((long)pNtAuthority != 0) {
                FreeSid( pNtAuthority );
            }

            return result;

        } // UlCreateRootConfigGroup()

    }; // internal class UlSysApi


} // namespace System.Net

#endif // COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_win32.cs ===
//------------------------------------------------------------------------------
// <copyright file="_Win32.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net {

    internal class Win32 {
        internal const int OverlappedInternalOffset     = 0;
        internal const int OverlappedInternalHighOffset = 4;
        internal const int OverlappedOffsetOffset       = 8;
        internal const int OverlappedOffsetHighOffset   = 12;
        internal const int OverlappedhEventOffset       = 16;
        internal const int OverlappedSize               = 20;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\_ulvxdapi.cs ===
//------------------------------------------------------------------------------
// <copyright file="_UlVxdApi.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if COMNET_LISTENER

namespace System.Net {

    using System.Collections;
    using System.IO;
    using System.Net.Sockets;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;

    internal class UlVxdApi {

        private static string VxdName = "UL.VXD";
        private static IntPtr hDevice = NativeMethods.INVALID_HANDLE_VALUE;
        private static bool bOK;

        public const int
            FILE_FLAG_WRITE_THROUGH = unchecked((int)0x80000000),
            FILE_FLAG_OVERLAPPED = 0x40000000,
            FILE_FLAG_NO_BUFFERING = 0x20000000,
            FILE_FLAG_RANDOM_ACCESS = 0x10000000,
            FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
            FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
            FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
            FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
            FILE_TYPE_UNKNOWN = 0x0000,
            FILE_TYPE_DISK = 0x0001,
            FILE_TYPE_CHAR = 0x0002,
            FILE_TYPE_PIPE = 0x0003,
            FILE_TYPE_REMOTE = unchecked((int)0x8000),
            ERROR_IO_INCOMPLETE = 996,
            ERROR_ALREADY_INITIALIZED = 1247,
            ERROR_IO_PENDING = 997,
            ERROR_MORE_DATA = 234,
            ERROR_INVALID_PARAMETER = 87,
            ERROR_HANDLE_EOF = 38,
            ERROR_NOT_ENOUGH_MEMORY = 8,
            ERROR_SUCCESS = 0;

        public const int IOCTL_UL_CREATE_APPPOOL                    = 0x20;
        public const int IOCTL_UL_CLOSE_APPPOOL                     = 0x22;
        public const int IOCTL_UL_REGISTER_URI                      = 0x24;
        public const int IOCTL_UL_UNREGISTER_URI                    = 0x26;
        public const int IOCTL_UL_UNREGISTER_ALL                    = 0x38;
        public const int IOCTL_UL_SEND_HTTP_REQUEST_HEADERS         = 0x28;
        public const int IOCTL_UL_SEND_HTTP_REQUEST_ENTITY_BODY     = 0x2A;
        public const int IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS      = 0x2C;
        public const int IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY  = 0x2E;
        public const int IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS        = 0x30;
        public const int IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY    = 0x32;
        public const int IOCTL_UL_RECEIVE_HTTP_RESPONSE_HEADERS     = 0x34;
        public const int IOCTL_UL_RECEIVE_HTTP_RESPONSE_ENTITY_BODY = 0x36;


        public static int UlInitialize() {
            GlobalLog.Print("Entering UlInitialize()" );

            if (hDevice != NativeMethods.INVALID_HANDLE_VALUE) {
                // or throw an exception?

                return NativeMethods.ERROR_ALREADY_INITIALIZED;
            }

            hDevice =
                NativeMethods.CreateFileA(
                             "\\\\.\\" + VxdName,
                             0,
                             0,
                             IntPtr.Zero,
                             0,
                             NativeMethods.FILE_FLAG_DELETE_ON_CLOSE | NativeMethods.FILE_FLAG_OVERLAPPED,
                             0 );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return Marshal.GetLastWin32Error();
            }

            return NativeMethods.ERROR_SUCCESS;

        }   // UlInitialize



        public static void UlTerminate() {
            GlobalLog.Print("Entering UlTerminate()" );

            if (hDevice != NativeMethods.INVALID_HANDLE_VALUE) {
                NativeMethods.CloseHandle( hDevice );
                hDevice = NativeMethods.INVALID_HANDLE_VALUE;
            }

            return;

        }   // UlTerminate



        public static int UlCreateAppPool(ref IntPtr AppPoolHandle) {
            GlobalLog.Print("Entering UlCreateAppPool()" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[1];
            int dummy = 0;

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_CREATE_APPPOOL,
                                 InIoctl,
                                 4,
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            AppPoolHandle = InIoctl[0];

            return bOK ? NativeMethods.ERROR_SUCCESS : Marshal.GetLastWin32Error();

        }   // UlCreateAppPool



        public static int UlCloseAppPool(IntPtr AppPoolHandle) {
            GlobalLog.Print("Entering UlCloseAppPool(" + Convert.ToString( AppPoolHandle ) + ")" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[1];
            int dummy = 0;

            InIoctl[0] = AppPoolHandle;

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_CLOSE_APPPOOL,
                                 InIoctl,
                                 4,
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            return bOK ? NativeMethods.ERROR_SUCCESS : Marshal.GetLastWin32Error();

        }   // UlCreateAppPool



        // The following APIs will just pack all the information passed in the
        // paramteres into the appropriate structure in memory and call
        // DeviceIoControl() with the appropriate IOCTL code passing down the
        // unmanaged pointer to the Input structure.

        // all the definitions of the unmanaged structures that are passed down
        // along with the IOCTL codes are to be found in
        // $(IISREARC)\ul\win9x\inc\structs.h
        // and the unmanaged equivalent is to be found in
        // $(IISREARC)\ul\win9x\src\library\ulapi.c

        public static int
        UlRegisterUri(
                     IntPtr AppPoolHandle,
                     string pUriToRegister
                     ) {
            GlobalLog.Print("Entering UlRegisterUri(" + Convert.ToString( AppPoolHandle ) + ",[" + pUriToRegister + "])" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int ulUriToRegisterLength = pUriToRegister.Length;

            if (ulUriToRegisterLength == 0) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[4];
            int dummy = 0;

            InIoctl[0] = 4*4;
            InIoctl[1] = AppPoolHandle;
            InIoctl[2] = ulUriToRegisterLength;
            InIoctl[3] = Marshal.AllocHGlobal( 2*(ulUriToRegisterLength+1) );

            Encoding myEncoder = Encoding.Unicode;
            Marshal.Copy( myEncoder.GetBytes( pUriToRegister.ToLower(CultureInfo.InvariantCulture) ), 0, InIoctl[3], 2*(ulUriToRegisterLength) );
            Marshal.WriteInt16( InIoctl[3], 2*(ulUriToRegisterLength), 0 );

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_REGISTER_URI,
                                 InIoctl,
                                 InIoctl[0],
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            Marshal.FreeHGlobal( InIoctl[3] );

            return bOK ? NativeMethods.ERROR_SUCCESS : Marshal.GetLastWin32Error();

        }   // UlRegisterUri



        // The following APIs will just pack all the information passed in the
        // paramteres into the appropriate structure in memory and call
        // DeviceIoControl() with the appropriate IOCTL code passing down the
        // unmanaged pointer to the Input structure.

        // all the definitions of the unmanaged structures that are passed down
        // along with the IOCTL codes are to be found in
        // $(IISREARC)\ul\win9x\inc\structs.h
        // and the unmanaged equivalent is to be found in
        // $(IISREARC)\ul\win9x\src\library\ulapi.c

        public static int
        UlUnregisterUri(
                       IntPtr AppPoolHandle,
                       string pUriToUnregister
                       ) {
            GlobalLog.Print("Entering UlUnregisterUri(" + Convert.ToString( AppPoolHandle ) + ",[" + pUriToUnregister + "])" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int ulUriToUnregisterLength = pUriToUnregister.Length;

            if (ulUriToUnregisterLength == 0) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[4];
            int dummy = 0;

            InIoctl[0] = 4*4;
            InIoctl[1] = AppPoolHandle;
            InIoctl[2] = ulUriToUnregisterLength;
            InIoctl[3] = Marshal.AllocHGlobal( 2*(ulUriToUnregisterLength+1) );

            Encoding myEncoder = Encoding.Unicode;
            Marshal.Copy( myEncoder.GetBytes( pUriToUnregister.ToLower(CultureInfo.InvariantCulture) ), 0, InIoctl[3], 2*(ulUriToUnregisterLength) );
            Marshal.WriteInt16( InIoctl[3], 2*(ulUriToUnregisterLength), 0 );

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_UNREGISTER_URI,
                                 InIoctl,
                                 InIoctl[0],
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            Marshal.FreeHGlobal( InIoctl[3] );

            return bOK ? NativeMethods.ERROR_SUCCESS : Marshal.GetLastWin32Error();

        }   // UlRegisterUri



        public static int
        UlGetOverlappedResult(
                             IntPtr pUnmanagedOverlapped, // pointer to overlapped structure
                             ref int pNumberOfBytesTransferred, // pointer to actual bytes count
                             bool bWait // wait flag
                             ) {
            GlobalLog.Print("Entering UlGetOverlappedResult(" + Convert.ToString( pUnmanagedOverlapped ) + ")" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            if ((long)pUnmanagedOverlapped == 0) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            if (bWait) {
                AutoResetEvent m_Event = new AutoResetEvent( false );

                m_Event.SetHandle( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedhEventOffset ) ) ;

                bOK = m_Event.WaitOne();

                pNumberOfBytesTransferred = Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalHighOffset );
            }
            else {
                pNumberOfBytesTransferred = Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalHighOffset );

                if (Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalOffset ) == NativeMethods.ERROR_IO_PENDING) {
                    return NativeMethods.ERROR_IO_INCOMPLETE;
                }
            }

            return Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalOffset );

        } // UlGetOverlappedResult



        public static int
        UlReceiveHttpRequestHeaders(
                                   IntPtr AppPoolHandle,
                                   long RequestId,
                                   int Flags,
                                   IntPtr pRequestBuffer, // unmanaged
                                   int RequestBufferLength,
                                   ref int pBytesReturned,
                                   IntPtr pOverlapped // unmanaged
                                   ) {
            GlobalLog.Print("Entering UlReceiveHttpRequestHeaders(" +
                           Convert.ToString( AppPoolHandle ) + "," +
                           Convert.ToString( RequestId ) + "," +
                           Convert.ToString( pOverlapped ) + ")" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[10];
            int dummy = 0;

            AutoResetEvent m_Event = null;
            IntPtr pUnmanagedOverlapped = pOverlapped;

            if ((long)pOverlapped == 0) {
                // this must be a blocking call, since the vxd doesn't support
                // synchronous I/Os we need to build an unmanaged OVERLAPPED
                // structure and wait on the event handle for I/O completion

                // allocate unmanaged memory

                pUnmanagedOverlapped = Marshal.AllocHGlobal( Win32.OverlappedSize );
                NativeMethods.FillMemory( pUnmanagedOverlapped, Win32.OverlappedSize, 0 );

                // create an Event

                m_Event = new AutoResetEvent( false );

                // copy the Event handle to the overlapped structure

                Marshal.WriteIntPtr( pUnmanagedOverlapped, Win32.OverlappedhEventOffset, m_Event.Handle );

                GlobalLog.Print("syncronous call created unmanaged overlapped structure: " +
                               Convert.ToString( pUnmanagedOverlapped ) + "," +
                               Convert.ToString( m_Event.Handle ) + ")" );
            }

            // sizeof(IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS):40

            InIoctl[0] = 10*4;
            InIoctl[1] = AppPoolHandle;
            InIoctl[2] = Convert.ToInt32( RequestId&0xFFFFFFFF );
            InIoctl[3] = Convert.ToInt32( RequestId>>32 );
            InIoctl[4] = Flags;
            InIoctl[5] = pRequestBuffer; // this needs to be already unmanaged memory
            InIoctl[6] = RequestBufferLength;
            InIoctl[7] = Marshal.AllocHGlobal( 4 );
            InIoctl[8] = pUnmanagedOverlapped; // this needs to be already unmanaged memory
            InIoctl[9] = 0; // padding for 64 bit alignment

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_RECEIVE_HTTP_REQUEST_HEADERS,
                                 InIoctl,
                                 InIoctl[0],
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            int result = NativeMethods.ERROR_SUCCESS;

            if (!bOK) {
                //
                // if DeviceIoControl failed save the returned error
                //

                result = Marshal.GetLastWin32Error();
            }

            GlobalLog.Print("DeviceIoControl returns:" + Convert.ToString( result ) );

            if ((long)pOverlapped == 0 && ( result == NativeMethods.ERROR_SUCCESS || result == NativeMethods.ERROR_IO_PENDING )) {
                //
                // check the return value
                //

                if (result == NativeMethods.ERROR_IO_PENDING) {
                    //
                    // if the IO pended we need to wait
                    //

                    bOK = m_Event.WaitOne();

                    if (!bOK) {
                        //
                        // if the Wait fails just throw
                        //
                        // Consider: move all Exception string to system.txt for localization
                        //
                        throw new InvalidOperationException( "WaitOne() failed, err#" + Convert.ToString( Marshal.GetLastWin32Error() ) );
                    }
                }

                GlobalLog.Print("pOverlapped" +
                               " Internal:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalOffset ) ) +
                               " InternalHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalHighOffset ) ) +
                               " Offset:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetOffset ) ) +
                               " OffsetHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetHighOffset ) ) +
                               " hEvent:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedhEventOffset ) ) );

                //
                // get the asynchronous result
                //

                result =
                UlGetOverlappedResult(
                                     pUnmanagedOverlapped,
                                     ref pBytesReturned,
                                     false );
            }

            if ((long)pOverlapped == 0) {
                //
                // free unmanaged memory
                //

                Marshal.FreeHGlobal( pUnmanagedOverlapped );
            }

            Marshal.FreeHGlobal( InIoctl[7] );

            return result;

        }   // UlReceiveHttpRequestHeaders



        public static int
        UlReceiveHttpRequestEntityBody(
                                      IntPtr AppPoolHandle,
                                      long RequestId,
                                      int Flags,
                                      IntPtr pEntityBuffer, // unmanaged
                                      int EntityBufferLength,
                                      ref int pBytesReturned,
                                      IntPtr pOverlapped // unmanaged
                                      ) {
            GlobalLog.Print("Entering UlReceiveHttpRequestEntityBody(" +
                           Convert.ToString( AppPoolHandle ) + "," +
                           Convert.ToString( RequestId ) + "," +
                           Convert.ToString( pOverlapped ) + ")" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[10];
            int dummy = 0;

            AutoResetEvent m_Event = null;
            IntPtr pUnmanagedOverlapped = pOverlapped;

            if ((long)pOverlapped == 0) {
                // this must be a blocking call, since the vxd doesn't support
                // synchronous I/Os we need to build an unmanaged OVERLAPPED
                // structure and wait on the event handle for I/O completion

                // allocate unmanaged memory

                pUnmanagedOverlapped = Marshal.AllocHGlobal( Win32.OverlappedSize );
                NativeMethods.FillMemory( pUnmanagedOverlapped, Win32.OverlappedSize, 0 );

                // create an Event

                m_Event = new AutoResetEvent( false );

                // copy the Event handle to the overlapped structure

                Marshal.WriteIntPtr( pUnmanagedOverlapped, Win32.OverlappedhEventOffset, m_Event.Handle );
            }

            // sizeof(IN_IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY):40

            InIoctl[0] = 10*4;
            InIoctl[1] = AppPoolHandle;
            InIoctl[2] = Convert.ToInt32( RequestId&0xFFFFFFFF );
            InIoctl[3] = Convert.ToInt32( RequestId>>32 );
            InIoctl[4] = Flags;
            InIoctl[5] = pEntityBuffer; // this needs to be already unmanaged memory
            InIoctl[6] = EntityBufferLength;
            InIoctl[7] = Marshal.AllocHGlobal( 4 );
            InIoctl[8] = pUnmanagedOverlapped; // this needs to be already unmanaged memory
            InIoctl[9] = 0; // padding for 64 bit alignment

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_RECEIVE_HTTP_REQUEST_ENTITY_BODY,
                                 InIoctl,
                                 InIoctl[0],
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            int result = NativeMethods.ERROR_SUCCESS;

            if (!bOK) {
                //
                // if DeviceIoControl failed save the returned error
                //

                result = Marshal.GetLastWin32Error();
            }

            GlobalLog.Print("DeviceIoControl returns:" + Convert.ToString( result ) );

            if ((long)pOverlapped == 0 && ( result == NativeMethods.ERROR_SUCCESS || result == NativeMethods.ERROR_IO_PENDING )) {
                //
                // check the return value
                //

                if (result == NativeMethods.ERROR_IO_PENDING) {
                    //
                    // if the IO pended we need to wait
                    //

                    bOK = m_Event.WaitOne();

                    if (!bOK) {
                        //
                        // if the Wait fails just throw
                        //

                        throw new InvalidOperationException( "WaitOne() failed, err#" + Convert.ToString( Marshal.GetLastWin32Error() ) );
                    }
                }

                GlobalLog.Print("pOverlapped" +
                               " Internal:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalOffset ) ) +
                               " InternalHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalHighOffset ) ) +
                               " Offset:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetOffset ) ) +
                               " OffsetHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetHighOffset ) ) +
                               " hEvent:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedhEventOffset ) ) );

                //
                // get the asynchronous result
                //

                result =
                UlGetOverlappedResult(
                                     pUnmanagedOverlapped,
                                     ref pBytesReturned,
                                     false );
            }

            if ((long)pOverlapped == 0) {
                //
                // free unmanaged memory
                //

                Marshal.FreeHGlobal( pUnmanagedOverlapped );
            }

            Marshal.FreeHGlobal( InIoctl[7] );

            return result;

        }   // UlReceiveHttpRequestHeaders




        public static int
        UlSendHttpResponseHeaders(
                                 IntPtr AppPoolHandle,
                                 long RequestId,
                                 int Flags,
                                 IntPtr pResponseBuffer, // PUL_HTTP_RESPONSE
                                 int ResponseBufferLength,
                                 int EntityChunkCount, // OPTIONAL,
                                 IntPtr pEntityChunks, // OPTIONAL,
                                 IntPtr pCachePolicy, // OPTIONAL
                                 ref int pBytesSent, // OPTIONAL
                                 IntPtr pOverlapped // OPTIONAL
                                 ) {
            GlobalLog.Print("Entering UlSendHttpResponseHeaders(" +
                           Convert.ToString( AppPoolHandle ) + "," +
                           Convert.ToString( RequestId ) + "," +
                           Convert.ToString( pOverlapped ) + ")" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[12];
            int dummy = 0;

            AutoResetEvent m_Event = null;
            IntPtr pUnmanagedOverlapped = pOverlapped;

            if ((long)pOverlapped == 0) {
                // this must be a blocking call, since the vxd doesn't support
                // synchronous I/Os we need to build an unmanaged OVERLAPPED
                // structure and wait on the event handle for I/O completion

                // allocate unmanaged memory

                pUnmanagedOverlapped = Marshal.AllocHGlobal( Win32.OverlappedSize );
                NativeMethods.FillMemory( pUnmanagedOverlapped, Win32.OverlappedSize, 0 );

                // create an Event

                m_Event = new AutoResetEvent( false );

                // copy the Event handle to the overlapped structure

                Marshal.WriteIntPtr( pUnmanagedOverlapped, Win32.OverlappedhEventOffset, m_Event.Handle );
            }

            // sizeof(IN_IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS):48

            InIoctl[0] = 12*4;
            InIoctl[1] = AppPoolHandle;
            InIoctl[2] = Convert.ToInt32( RequestId&0xFFFFFFFF );
            InIoctl[3] = Convert.ToInt32( RequestId>>32 );
            InIoctl[4] = Flags;
            InIoctl[5] = pResponseBuffer; // this needs to be already unmanaged memory
            InIoctl[6] = ResponseBufferLength;
            InIoctl[7] = EntityChunkCount;
            InIoctl[8] = pEntityChunks;
            InIoctl[9] = pCachePolicy;
            InIoctl[10] = Marshal.AllocHGlobal( 4 );
            InIoctl[11] = pUnmanagedOverlapped; // this needs to be already unmanaged memory

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_SEND_HTTP_RESPONSE_HEADERS,
                                 InIoctl,
                                 InIoctl[0],
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            int result = NativeMethods.ERROR_SUCCESS;

            if (!bOK) {
                //
                // if DeviceIoControl failed save the returned error
                //

                result = Marshal.GetLastWin32Error();
            }

            GlobalLog.Print("DeviceIoControl returns:" + Convert.ToString( result ) );

            if ((long)pOverlapped == 0 && ( result == NativeMethods.ERROR_SUCCESS || result == NativeMethods.ERROR_IO_PENDING )) {
                //
                // check the return value
                //

                if (result == NativeMethods.ERROR_IO_PENDING) {
                    //
                    // if the IO pended we need to wait
                    //

                    bOK = m_Event.WaitOne();

                    if (!bOK) {
                        //
                        // if the Wait fails just throw
                        //

                        throw new InvalidOperationException( "WaitOne() failed, err#" + Convert.ToString( Marshal.GetLastWin32Error() ) );
                    }
                }

                GlobalLog.Print("pOverlapped" +
                               " Internal:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalOffset ) ) +
                               " InternalHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalHighOffset ) ) +
                               " Offset:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetOffset ) ) +
                               " OffsetHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetHighOffset ) ) +
                               " hEvent:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedhEventOffset ) ) );

                //
                // get the asynchronous result
                //

                result =
                    UlGetOverlappedResult(
                                     pUnmanagedOverlapped,
                                     ref pBytesSent,
                                     false );
            }

            if ((long)pOverlapped == 0) {
                //
                // free unmanaged memory
                //

                Marshal.FreeHGlobal( pUnmanagedOverlapped );
            }

            Marshal.FreeHGlobal( InIoctl[10] );

            return result;

        }   // UlSendHttpResponseHeaders



        public static int
        UlSendHttpResponseEntityBody(
                                    IntPtr AppPoolHandle,
                                    long RequestId,
                                    int Flags,
                                    int EntityChunkCount,
                                    IntPtr pEntityChunks, // unmanaged
                                    ref int pBytesSent,
                                    IntPtr pOverlapped // unmanaged
                                    ) {
            GlobalLog.Print("Entering UlSendHttpResponseEntityBody(" +
                           Convert.ToString( AppPoolHandle ) + "," +
                           Convert.ToString( RequestId ) + "," +
                           Convert.ToString( pOverlapped ) + "," +
                           Convert.ToString( EntityChunkCount ) + "," +
                           Convert.ToString( pEntityChunks ) + ")" );

            if (hDevice == NativeMethods.INVALID_HANDLE_VALUE) {
                return NativeMethods.ERROR_INVALID_PARAMETER;
            }

            int[] InIoctl = new int[10];
            int dummy = 0;

            AutoResetEvent m_Event = null;
            IntPtr pUnmanagedOverlapped = pOverlapped;

            if ((long)pOverlapped == 0) {
                // this must be a blocking call, since the vxd doesn't support
                // synchronous I/Os we need to build an unmanaged OVERLAPPED
                // structure and wait on the event handle for I/O completion

                // allocate unmanaged memory

                pUnmanagedOverlapped = Marshal.AllocHGlobal( Win32.OverlappedSize );
                NativeMethods.FillMemory( pUnmanagedOverlapped, Win32.OverlappedSize, 0 );

                // create an Event

                m_Event = new AutoResetEvent( false );

                // copy the Event handle to the overlapped structure

                Marshal.WriteIntPtr( pUnmanagedOverlapped, Win32.OverlappedhEventOffset, m_Event.Handle );
            }

            // sizeof(IN_IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY):40

            InIoctl[0] = 10*4;
            InIoctl[1] = AppPoolHandle;
            InIoctl[2] = Convert.ToInt32( RequestId&0xFFFFFFFF );
            InIoctl[3] = Convert.ToInt32( RequestId>>32 );
            InIoctl[4] = Flags;
            InIoctl[5] = EntityChunkCount;
            InIoctl[6] = pEntityChunks; // this needs to be already unmanaged memory
            InIoctl[7] = Marshal.AllocHGlobal( 4 );
            InIoctl[8] = pUnmanagedOverlapped; // this needs to be already unmanaged memory
            InIoctl[9] = 0; // padding for 64 bit alignment

            bOK =
                NativeMethods.DeviceIoControl(
                                 hDevice,
                                 IOCTL_UL_SEND_HTTP_RESPONSE_ENTITY_BODY,
                                 InIoctl,
                                 InIoctl[0],
                                 null,
                                 0,
                                 ref dummy,
                                 IntPtr.Zero );

            int result = NativeMethods.ERROR_SUCCESS;

            if (!bOK) {
                //
                // if DeviceIoControl failed save the returned error
                //

                result = Marshal.GetLastWin32Error();
            }

            GlobalLog.Print("DeviceIoControl returns:" + Convert.ToString( result ) );

            if ((long)pOverlapped == 0 && ( result == NativeMethods.ERROR_SUCCESS || result == NativeMethods.ERROR_IO_PENDING )) {
                //
                // check the return value
                //

                if (result == NativeMethods.ERROR_IO_PENDING) {
                    //
                    // if the IO pended we need to wait
                    //

                    bOK = m_Event.WaitOne();

                    if (!bOK) {
                        //
                        // if the Wait fails just throw
                        //

                        throw new InvalidOperationException( "WaitOne() failed, err#" + Convert.ToString( Marshal.GetLastWin32Error() ) );
                    }
                }

                GlobalLog.Print("pOverlapped" +
                               " Internal:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalOffset ) ) +
                               " InternalHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedInternalHighOffset ) ) +
                               " Offset:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetOffset ) ) +
                               " OffsetHigh:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedOffsetHighOffset ) ) +
                               " hEvent:" + Convert.ToString( Marshal.ReadInt32( pUnmanagedOverlapped + Win32.OverlappedhEventOffset ) ) );

                //
                // get the asynchronous result
                //

                result = UlGetOverlappedResult(
                                     pUnmanagedOverlapped,
                                     ref pBytesSent,
                                     false );
            }

            if ((long)pOverlapped == 0) {
                //
                // free unmanaged memory
                //

                Marshal.FreeHGlobal( pUnmanagedOverlapped );
            }

            Marshal.FreeHGlobal( InIoctl[7] );

            return result;

        }   // UlSendHttpResponseEntityBody

    }; // internal class UlVxdApi


} // namespace System.Net

#endif // COMNET_LISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\configuration\connectionmanagmenthandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConnectionManagmentHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Net.Configuration { 

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Diagnostics;
    //using System.Xml;
    using System.Net;
    using System.Configuration;
    using System.Globalization;

    //
    // ConnectionManagementHandler - 
    //
    // Simple Collection config list, based on inherited 
    //  behavior from CollectionSectionHandler, uses
    //  a HashTable to keep collection information
    //
    // config is a dictionary mapping key->value
    //
    // <add address="name" maxconnection="12">  sets key=text
    // <set address="name" maxconnection="8">   sets key=text
    // <remove address="name">                  removes the definition of key
    // <clear>                                  removes all definitions
    //
    internal class ConnectionManagementHandler : CollectionSectionHandler {    

        private Hashtable _hashTable;

        //
        // Create - creates internal hashtable of connection address/
        //  connection count
        //
        protected override void Create(Object obj)
        {
            if (obj == null)
                _hashTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            else
                _hashTable = (Hashtable)((Hashtable)obj).Clone();
        }

        //
        // Clear - Clears the internal collection
        //       
        protected override void Clear()
        {
            _hashTable.Clear();
        }

        //
        // Remove - Removes the specified key from the collection
        //
        protected override void Remove(string key)
        {
            _hashTable.Remove(key);
        }

        //
        // Add - Adds/Updates the collection 
        //
        protected override void Add(string key, string value)
        {
             int maxConnections = 0;             
             
             try {
                Uri uriKey;                
                if ( key != "*" ) {
                    uriKey = new Uri(key);
                    key = uriKey.Scheme + "://" + uriKey.Host + ":" + uriKey.Port.ToString();
                }
                maxConnections = Int32.Parse(value);
             } catch (Exception) {
                return;
             }

             _hashTable[key] = maxConnections;
        }

        //
        // Get - called before returning to Configuration code,
        //   used to generate the output collection object, 
        //   just returns a hashtable
        //
        protected override Object Get()
        {
            return (Object) _hashTable;
        }
    
        //
        // KeyAttributeName - 
        //   Make the name of the key attribute configurable by derived classes
        //
        protected override string KeyAttributeName {
            get { return "address";}
        }

        //
        // ValueAttributeName - 
        //   Make the name of the value attribute configurable by derived classes
        //
        protected override string ValueAttributeName {
            get { return "maxconnection";}
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\configuration\collectionsectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Net.Configuration { 

    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Diagnostics;
	using System.Xml;
    using System.Configuration;

    //
    // CollectionSectionHandler - a basic wrapper on Config Handler.
    //   This impliments a base class for storing and parsing
    //   an XMLNode Config object.
    //    
    internal class CollectionSectionHandler : IConfigurationSectionHandler {


        //
        // Create - Creates an internal representation of the collection
        //     object being implimented
        //
        //  Input:
        //      obj - Nested object that may be created earlier
        //       
        protected virtual void Create(Object obj)
        {
        }

        //
        // Clear - Clears the internal collection
        //       
        protected virtual void Clear()
        {
        }


        //
        // Remove - Removes the specified key from the collection
        //
        // Input:
        //     key          - string of key to search on
        //      
        protected virtual void Remove(string key)
        {
        }

        //
        // Add - Adds/Updates the collection 
        //
        protected virtual void Add(string key, string value)
        {
        }


        //
        // Get - called before returning to Configuration code,
        //   used to generate the output collection object
        //
        protected virtual Object Get()
        {
            return null;
        }


        //
        // WalkXmlNodeList - Walks list of XML nodes,
        //  and processes them for by calling Add, Clear, Remove
        //  to cause them to update the config object we are processing
        //       
        protected virtual void WalkXmlNodeList(XmlNode section) {

            foreach (XmlNode child in section.ChildNodes) {

                // skip whitespace and comments
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                // handle <set>, <remove>, <clear> tags
                if (child.Name == "add") {
                    String key = HandlerBase.RemoveRequiredAttribute(child, KeyAttributeName);
                    String value = HandlerBase.RemoveAttribute(child, ValueAttributeName);

                    HandlerBase.CheckForUnrecognizedAttributes(child);

                    if (value == null)
                        value = "";
                
                    Add(key, value);
                }
                else if (child.Name == "remove") {
                    String key = HandlerBase.RemoveRequiredAttribute(child, KeyAttributeName);
                    HandlerBase.CheckForUnrecognizedAttributes(child);

                    Remove(key);
                }
                else if (child.Name.Equals("clear")) {
                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    Clear();
                }
                else {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }
            } // foreach
        }

        //
        // Create - Given a partially composed config object (possibly null)
        // and some input from the config system, return a
        // further partially composed config object
        //
        public virtual object Create(Object parent, Object configContext, XmlNode section) {

            // start res off as a shallow clone of the parent

            Create(parent);

            // process XML

            HandlerBase.CheckForUnrecognizedAttributes(section);

            WalkXmlNodeList(section);

            return Get();
        }


        //
        // KeyAttributeName - 
        //   Make the name of the key attribute configurable by derived classes
        //
        protected virtual string KeyAttributeName {
             get { return "key";}
        }

        //
        // ValueAttributeName - Make the name of the value attribute configurable 
        //    by derived classes
        //
        protected virtual string ValueAttributeName {
             get { return "value";}
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\configuration\netconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="NetConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#if !LIB

namespace System.Net.Configuration {

    using System;
    using System.Configuration;
    using System.Xml;

    internal class NetConfigurationHandler : IConfigurationSectionHandler {

        public virtual object Create(Object parent, object configContext, XmlNode section) {

            NetConfiguration netConfig;

            if (parent == null)
                netConfig = new NetConfiguration();
            else
                netConfig = (NetConfiguration)((NetConfiguration)parent).Clone();

            // process XML
            foreach (XmlNode child in section.ChildNodes) {

                // skip whitespace and comments
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                switch (child.Name) {
                    case "servicePointManager":
                        HandlerBase.GetAndRemoveBooleanAttribute(child, "checkCertificateName", ref netConfig.checkCertName);
                        HandlerBase.GetAndRemoveBooleanAttribute(child, "checkCertificateRevocationList", ref netConfig.checkCertRevocationList);
                        HandlerBase.GetAndRemoveBooleanAttribute(child, "useNagleAlgorithm", ref netConfig.useNagleAlgorithm);
                        HandlerBase.GetAndRemoveBooleanAttribute(child, "expect100Continue", ref netConfig.expect100Continue);
	                        break;
                    case "ipv6":
                        HandlerBase.GetAndRemoveBooleanAttribute(child, "enabled", ref netConfig.ipv6Enabled);
                        break;
                    case "httpWebRequest":
                        HandlerBase.GetAndRemoveIntegerAttribute(child, "maximumResponseHeadersLength", ref netConfig.maximumResponseHeadersLength);
                        break;
                    default:
                        HandlerBase.ThrowUnrecognizedElement(child);
                        break;
                }
                HandlerBase.CheckForUnrecognizedAttributes(child);
            }
            return netConfig;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\addressfamily.cs ===
//------------------------------------------------------------------------------
// <copyright file="AddressFamily.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {

    /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the address families that an instance of the <see cref='System.Net.Sockets.Socket'/>
    ///       class can use.
    ///    </para>
    /// </devdoc>
    public enum AddressFamily {
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown             = -1,   // Unknown
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Unspecified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unspecified         = 0,    // unspecified
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Unix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unix                = 1,    // local to host (pipes, portals)
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.InterNetwork"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InterNetwork        = 2,    // internetwork: UDP, TCP, etc.
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.ImpLink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ImpLink             = 3,    // arpanet imp addresses
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Pup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pup                 = 4,    // pup protocols: e.g. BSP
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Chaos"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Chaos               = 5,    // mit CHAOS protocols
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.NS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NS                  = 6,    // XEROX NS protocols
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Ipx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ipx                 = NS,   // IPX and SPX
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Iso"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Iso                 = 7,    // ISO protocols
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Osi"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Osi                 = Iso,  // OSI is ISO
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Ecma"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ecma                = 8,    // european computer manufacturers
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.DataKit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DataKit             = 9,    // datakit protocols
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Ccitt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ccitt               = 10,   // CCITT protocols, X.25 etc
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Sna"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sna                 = 11,   // IBM SNA
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.DecNet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DecNet              = 12,   // DECnet
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.DataLink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DataLink            = 13,   // Direct data link interface
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Lat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Lat                 = 14,   // LAT
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.HyperChannel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HyperChannel        = 15,   // NSC Hyperchannel
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.AppleTalk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AppleTalk           = 16,   // AppleTalk
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.NetBios"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NetBios             = 17,   // NetBios-style addresses
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.VoiceView"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VoiceView           = 18,   // VoiceView
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.FireFox"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FireFox             = 19,   // FireFox
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Banyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Banyan              = 21,   // Banyan
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Atm"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Atm                 = 22,   // Native ATM Services
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.InterNetworkV6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InterNetworkV6      = 23,   // Internetwork Version 6
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Cluster"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cluster             = 24,   // Microsoft Wolfpack
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Ieee12844"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ieee12844           = 25,   // IEEE 1284.4 WG AF
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Irda"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Irda                = 26,   // IrDA
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.NetworkDesigners"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NetworkDesigners    = 28,   // Network Designers OSI & gateway enabled protocols
        /// <include file='doc\AddressFamily.uex' path='docs/doc[@for="AddressFamily.Max"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Max                 = 29,   // Max


/*
#define AF_UNSPEC       0               // unspecified 

// Although  AF_UNSPEC  is  defined for backwards compatibility, using
// AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
// DISCOURAGED.    The  interpretation  of  the  "protocol"  parameter
// depends  on the actual address family chosen.  As environments grow
// to  include  more  and  more  address families that use overlapping
// protocol  values  there  is  more  and  more  chance of choosing an
// undesired address family when AF_UNSPEC is used.

#define AF_UNIX         1               // local to host (pipes, portals) 
#define AF_INET         2               // internetwork: UDP, TCP, etc. 
#define AF_IMPLINK      3               // arpanet imp addresses 
#define AF_PUP          4               // pup protocols: e.g. BSP 
#define AF_CHAOS        5               // mit CHAOS protocols 
#define AF_NS           6               // XEROX NS protocols 
#define AF_IPX          AF_NS           // IPX protocols: IPX, SPX, etc. 
#define AF_ISO          7               // ISO protocols 
#define AF_OSI          AF_ISO          // OSI is ISO 
#define AF_ECMA         8               // european computer manufacturers 
#define AF_DATAKIT      9               // datakit protocols 
#define AF_CCITT        10              // CCITT protocols, X.25 etc 
#define AF_SNA          11              // IBM SNA 
#define AF_DECnet       12              // DECnet 
#define AF_DLI          13              // Direct data link interface 
#define AF_LAT          14              // LAT 
#define AF_HYLINK       15              // NSC Hyperchannel 
#define AF_APPLETALK    16              // AppleTalk 
#define AF_NETBIOS      17              // NetBios-style addresses 
#define AF_VOICEVIEW    18              // VoiceView 
#define AF_FIREFOX      19              // Protocols from Firefox 
#define AF_UNKNOWN1     20              // Somebody is using this! 
#define AF_BAN          21              // Banyan 
#define AF_ATM          22              // Native ATM Services 
#define AF_INET6        23              // Internetwork Version 6 
#define AF_CLUSTER      24              // Microsoft Wolfpack 
#define AF_12844        25              // IEEE 1284.4 WG AF 
#define AF_IRDA         26              // IrDA 
#define AF_NETDES       28              // Network Designers OSI & gateway enabled protocols 
#define AF_MAX          29
*/

    }; // enum AddressFamily


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\lingeroption.cs ===
//------------------------------------------------------------------------------
// <copyright file="LingerOption.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Net.Sockets {
    using System;
    
    
    /// <include file='doc\LingerOption.uex' path='docs/doc[@for="LingerOption"]/*' />
    /// <devdoc>
    ///    <para>Contains information for a socket's linger time, the amount of time it will
    ///       remain after closing if data remains to be sent.</para>
    /// </devdoc>
    public class LingerOption {
        bool enabled;
        int lingerTime;

        /// <include file='doc\LingerOption.uex' path='docs/doc[@for="LingerOption.LingerOption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='Sockets.LingerOption'/> class.
        ///    </para>
        /// </devdoc>
        public LingerOption(bool enable, int seconds) {
            Enabled = enable;
            LingerTime = seconds;
        }
        
        /// <include file='doc\LingerOption.uex' path='docs/doc[@for="LingerOption.Enabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables or disables lingering after
        ///       close.
        ///    </para>
        /// </devdoc>
        public bool Enabled {
            get {
                return enabled;
            }
            set {
                enabled = value;
            }
        }

        /// <include file='doc\LingerOption.uex' path='docs/doc[@for="LingerOption.LingerTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The amount of time, in seconds, to remain connected after a close.
        ///    </para>
        /// </devdoc>
        public int LingerTime {
            get {
                return lingerTime;
            }
            set {
                lingerTime = value;
            }
        }

    } // class LingerOption
} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\configuration\netauthenticationmodulehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="NetAuthenticationModuleHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Net.Configuration { 


    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.Net;
    using System.Configuration;

    //
    // NetAuthenticationModuleHandler - 
    //
    // Simple Array config list, based on inherited 
    //  behavior from CollectionSectionHandler, uses
    //  an array of Types that can be used
    //  to create Authentication handlers
    //
    // config is a dictionary mapping key->value
    //
    // <add type="name">        sets key=text
    // <set type="name">        sets key=text
    // <remove type="name">     removes the definition of key
    // <clear>                  removes all definitions
    //
    internal class NetAuthenticationModuleHandler : CollectionSectionHandler {    

        private ArrayList _res;

        //
        // Create - creates internal hashtable of connection address/
        //  connection count
        //
        protected override void Create(Object obj)
        {
            if (obj == null)
                _res = new ArrayList();
            else
                _res = new ArrayList(((NetAuthenticationWrapper)obj).ModuleList);
        }

        //
        // Clear - Clears the internal collection
        //       
        protected override void Clear()
        {
            _res.Clear();
        }

        //
        // Remove - Removes the specified key from the collection
        //
        protected override void Remove(string key)
        {
            Type type = Type.GetType(key, false, true);
            if ( type == null ) {
                return;
            }           
            _res.Remove(type);
        }

        //
        // Add - Adds/Updates the collection 
        //
        protected override void Add(string key, string value)
        {           
            Type type = null;

            try {
                type = Type.GetType(key, true, true);

                // verify that its of the proper type of object
                if (!typeof(IAuthenticationModule).IsAssignableFrom(type)) {
                    throw new InvalidCastException ("IAuthenticationModule") ;
                }
            } catch (Exception e) {
                throw new ConfigurationException("NetAuthenticationModuleHandler", e);                                                 
            }

            _res.Add(type); 
        }

        //
        // Get - called before returning to Configuration code,
        //   used to generate the output collection object
        //
        protected override Object Get()
        {            
            return (Object) new NetAuthenticationWrapper(_res);
        }

        //
        // KeyAttributeName - 
        //   Make the name of the key attribute configurable by derived classes
        //
        protected override string KeyAttributeName {
            get { return "type";}
        }

        //
        // ValueAttributeName - 
        //   Make the name of the value attribute configurable by derived classes
        //
        protected override string ValueAttributeName {
            get { return "weight";}    
        }

    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\multicastoption.cs ===
//------------------------------------------------------------------------------
// <copyright file="MulticastOption.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Security.Permissions;
    using System.Security.Util;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;


    /// <include file='doc\MulticastOption.uex' path='docs/doc[@for="MulticastOption"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains option values
    ///       for IP multicast packets.
    ///    </para>
    /// </devdoc>
    public class MulticastOption {
        IPAddress group;
        IPAddress localAddress;

        /// <include file='doc\MulticastOption.uex' path='docs/doc[@for="MulticastOption.MulticastOption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the MulticaseOption class with the specified IP
        ///       address group and local address.
        ///    </para>
        /// </devdoc>
        public MulticastOption(IPAddress group, IPAddress mcint) {

            if (group == null) {
                throw new ArgumentNullException("group");
            }

            if (mcint == null) {
                throw new ArgumentNullException("mcint");
            }

            Group = group;
            LocalAddress = mcint;
        }

        /// <include file='doc\MulticastOption.uex' path='docs/doc[@for="MulticastOption.MulticastOption1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new version of the MulticastOption class for the specified
        ///       group.
        ///    </para>
        /// </devdoc>
        public MulticastOption(IPAddress group) {

            if (group == null) {
                throw new ArgumentNullException("group");
            }

            Group = group;

            LocalAddress = IPAddress.Any;
        }
        
        /// <include file='doc\MulticastOption.uex' path='docs/doc[@for="MulticastOption.Group"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the IP address of a multicast group.
        ///    </para>
        /// </devdoc>
        public IPAddress Group {
            get {
                return group;
            }
            set {
                group = value;
            }
        }

        /// <include file='doc\MulticastOption.uex' path='docs/doc[@for="MulticastOption.LocalAddress"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the local address of a multicast group.
        ///    </para>
        /// </devdoc>
        public IPAddress LocalAddress {
            get {
                return localAddress;
            }
            set {
                localAddress = value;
            }
        }

    } // class MulticastOption

    /// <devdoc>
    ///    <para>
    ///       Contains option values for joining an IPv6 multicast group.
    ///    </para>
    /// </devdoc>
    public class IPv6MulticastOption {
        IPAddress m_Group;
        long      m_Interface;

        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the MulticaseOption class with the specified IP
        ///       address group and local address.
        ///    </para>
        /// </devdoc>
        public IPv6MulticastOption(IPAddress group, long ifindex) {

            if (group == null) {
                throw new ArgumentNullException("group");
            }

            if ( ifindex < 0 || ifindex > 0x00000000FFFFFFFF ) {
                throw new ArgumentOutOfRangeException("ifindex");
            }

            Group          = group;
            InterfaceIndex = ifindex;
        }

        /// <devdoc>
        ///    <para>
        ///       Creates a new version of the MulticastOption class for the specified
        ///       group.
        ///    </para>
        /// </devdoc>
        public IPv6MulticastOption(IPAddress group) {

            if (group == null) {
                throw new ArgumentNullException("group");
            }

            Group          = group;
            InterfaceIndex = 0;
        }
        
        /// <devdoc>
        ///    <para>
        ///       Sets the IP address of a multicast group.
        ///    </para>
        /// </devdoc>
        public IPAddress Group {
            get {
                return m_Group;
            }
            set {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }

                m_Group = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Sets the interface index.
        ///    </para>
        /// </devdoc>
        public long InterfaceIndex {
            get {
                return m_Interface;
            }
            set {
                if ( value < 0 || value > 0x00000000FFFFFFFF ) {
                    throw new ArgumentOutOfRangeException("value");
                }

                m_Interface = value;
            }
        }

    } // class MulticastOptionIPv6

} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\configuration\webrequestmodulehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebRequestModuleHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Net.Configuration { 

    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Reflection;

    //
    // WebRequestModuleHandler - 
    //
    // Simple Array config list, based on inherited 
    //  behavior from CollectionSectionHandler, uses
    //  builds an array of Types that can be used
    //  inside WebRequest handlers, to map prefixs
    //
    // config is a dictionary mapping key->value
    //
    // <add prefix="name" type="">  sets key=text
    // <set prefix="name" type="">  sets key=text
    // <remove prefix="name">       removes the definition of key
    // <clear>                      removes all definitions
    //
    internal class WebRequestModuleHandler : CollectionSectionHandler {    

        private ArrayList _res;
       
        //
        // Create - creates internal hashtable of connection address/
        //  connection count
        //
        protected override void Create(Object obj)
        {
            if (obj == null)
                _res = new ArrayList();
            else
                _res = new ArrayList((ArrayList)obj);
        }

        //
        // Clear - Clears the internal collection
        //       
        protected override void Clear()
        {
            _res.Clear();
        }

        //
        // Remove - Removes the specified key from the collection
        //
        protected override void Remove(string prefix)
        {
            bool matched = false;
            int i = FindPrefix(prefix, ref matched);
            if ( matched ) {
                _res.Remove(i);
            }
        }

        //
        // Get - returns the collection 
        //
        protected override Object Get()
        {            
            return (Object) _res;
        }

        //
        // Add - Adds/Updates the collection 
        //
        protected override void Add(string prefix, string type)
        {                   
            IWebRequestCreate moduleToRegister = null;

            if (type == null ) {
                return;
            }

            // converts a type an object of type

            try {
                moduleToRegister = (IWebRequestCreate)Activator.CreateInstance(
                                                Type.GetType(type, true, true),
                                                BindingFlags.CreateInstance
                                                | BindingFlags.Instance
                                                | BindingFlags.NonPublic
                                                | BindingFlags.Public,
                                                null,          // Binder
                                                new object[0], // no arguments
                                                CultureInfo.InvariantCulture
                                                );            
            }
            catch (Exception e)  {
                //
                // throw exception for config debugging
                //

                throw new ConfigurationException("WebRequestModuleHandler", e);                
            }

           
            bool matched = false; 
            int indexToInsertAt = FindPrefix(prefix, ref matched);

            // When we get here either i contains the index to insert at or
            // we've had an error if we've already found it matched

            if (!matched) {
                // no adding on duplicates
                _res.Insert(indexToInsertAt,
                            new WebRequestPrefixElement(prefix, moduleToRegister)
                           );
            } else {
                // update
                _res[indexToInsertAt] =                    
                            new WebRequestPrefixElement(prefix, moduleToRegister);
                
            }

            return;
        }

        //
        // KeyAttributeName - 
        //   Make the name of the key attribute configurable by derived classes
        //
        protected override string KeyAttributeName {
             get { return "prefix";}
        }

        //
        // ValueAttributeName - 
        //   Make the name of the value attribute configurable by derived classes
        //
        protected override string ValueAttributeName {
            get { return "type";}
        }

        //
        // FindPrefix - matches a prefix against the ArrayList
        //   collection, returns 
        //
        private int FindPrefix(string prefix, ref bool match) {

            int returnVal = -1;
            int i;
            int ListSize;
            int PrefixSize;
            WebRequestPrefixElement Current;

            match = false;

            PrefixSize = prefix.Length;

            // down list looking for a place to
            // to insert this prefix.
        
            ListSize = _res.Count;
            i = 0;

            // The prefix list is sorted with longest entries at the front. We
            // walk down the list until we find a prefix shorter than this
            // one, then we insert in front of it. Along the way we check
            // equal length prefixes to make sure this isn't a dupe.

            while (i < ListSize) {
                Current = (WebRequestPrefixElement)_res[i];

                // See if the new one is longer than the one we're looking at.

                if (PrefixSize > Current.Prefix.Length) {
                    // It is. Break out of the loop here.
                    break;
                }

                // If these are of equal length, compare them.

                if (PrefixSize == Current.Prefix.Length) {
                    // They're the same length.
                    if (String.Compare(Current.Prefix, prefix, true, CultureInfo.InvariantCulture) == 0) {
                        // ...and the strings are identical. This is an error.

                        match = true;
                        returnVal = i;
                        break;
                    }
                }
                i++;
            }

            // When we get here either i contains the index to insert at or  
            // or if we're matching just return, if we found an exact match

            if (! match) {
                returnVal = i;
            }

            return returnVal;

        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\configuration\defaultproxyhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultProxyHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Net.Configuration { 

    using System.Collections;
    using System.Configuration;
    using System.Globalization;
    using System.Reflection;
    using System.Xml;

    //
    // DefaultProxyHandler - 
    //
    // Simple Array config list, based on inherited 
    //  behavior from CollectionSectionHandler, uses
    //  builds an array of Types that can be used
    //  inside WebRequest handlers, to map prefixs
    //
    // config is a dictionary mapping key->value
    //
    // <add prefix="name" type="">  sets key=text
    // <set prefix="name" type="">  sets key=text
    // <remove prefix="name">       removes the definition of key
    // <clear>                      removes all definitions
    //
    internal class DefaultProxyHandler : CollectionSectionHandler {

        private IWebProxy m_IWebProxy;

        //
        // Create - creates internal WebProxy that stores proxy info
        //  
        protected override void Create(Object obj)
        {
            if (obj == null)
                m_IWebProxy = new WebProxy();
            else
                m_IWebProxy = ((DefaultProxyHandlerWrapper)obj).WebProxy;
        }

        //
        // Clear - 
        // Remove -
        // Add -
        //  used for updating the Bypasslist,
        //  called by WalkXmlNodeList as its enumerating
        //
        protected override void Clear()
        {
            // called by WalkXmlNodeList, which validates type as WebProxy
            ((WebProxy)m_IWebProxy).BypassArrayList.Clear();
        }

        protected override void Remove(string proxyBypassList)
        {
            // called by WalkXmlNodeList, which validates type as WebProxy
            ((WebProxy)m_IWebProxy).BypassArrayList.Remove((string)proxyBypassList);
        }

        protected override void Add(string proxyBypassList, string unused)
        {           
            // called by WalkXmlNodeList, which validates type as WebProxy
            ((WebProxy)m_IWebProxy).BypassArrayList.Add((string)proxyBypassList); 
        }

        protected override Object Get()
        {            
            return (Object) new DefaultProxyHandlerWrapper(m_IWebProxy);
        }

        //
        // IsNormalWebProxy - true if we're using
        //   our normal built-in type
        //

        bool IsNormalWebProxy(IWebProxy IwebProxy) {
            if ((IwebProxy as System.Net.WebProxy) != null) {
                return true; 
            } else {
                return false;
            }
        }

        //
        // ReadModuleType - determines what kinda of type
        //  the proxy object will be, anything outside of 
        //  WebProxy will loose its default handling
        //

        bool ReadModuleType(string typeString, ref IWebProxy IwebProxy)
        {
            if (typeString != null) {
                try {
                    // note: expect cast to fail, if user gives bad type

                    IwebProxy = (IWebProxy)Activator.CreateInstance(
                                        Type.GetType(typeString, true, true),
                                        BindingFlags.CreateInstance
                                        | BindingFlags.Instance
                                        | BindingFlags.NonPublic
                                        | BindingFlags.Public,
                                        null,          // Binder
                                        new object[0], // no arguments
                                        CultureInfo.InvariantCulture
                                        );            
                }
                catch (Exception e)  {
                    //
                    // throw exception for config debugging
                    //

                    throw new ConfigurationException("DefaultProxyHandler", e);                
                }

                return true;
            }            
            return false;
        }


        //
        // ReadBoolValue - reads true if processed value from parse
        //
        private bool ReadBoolValue(string attribute, ref bool result)
        {
            result = false;
            bool attributeProcessed = false;

            try {
                if (attribute == null) { 
                    result = false; 
                } else {
                    result = bool.Parse(attribute);
                    attributeProcessed = true;
                }
            } catch (Exception) { }       

            return attributeProcessed;
        }

        //
        // Create
        //
        // Given a partially composed config object (possibly null)
        // and some input from the config system, return a
        // further partially composed config object
        //
        public override object Create(Object parent, Object configContext, XmlNode section) {

            // start res off as a shallow clone of the parent
            Create(parent);

            // process XML
            foreach (XmlNode child in section.ChildNodes) {

                // skip whitespace and comments
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                // reject nonelements
                HandlerBase.CheckForNonElement(child);

                string listName = child.Name;
                bool result = false;
                string attribute;               

                if ( listName == "proxy" ) {

                    // read usersystemdefault="true/false"
                    attribute = HandlerBase.RemoveAttribute(child, "usesystemdefault");                    
                           
                    //
                    // If an earlier config entry specified a usersystemdefault,
                    //   that meant that we would pick up our config settings
                    //   from IE.  If someone later on, wants to turn that off,
                    //   we need to recreate a blank WebProxy entry to override
                    //   the orginial IE settings
                    //

                    if ( ReadBoolValue(attribute, ref result) ) {
                        if (result) {
                            m_IWebProxy = ProxyRegBlob.GetIEProxy();
                        } else { 
                            m_IWebProxy = new WebProxy();
                        }
                    }

                    WebProxy webProxy = m_IWebProxy as System.Net.WebProxy;
                    if (webProxy != null) {
                        // read bypassonlocal="true/false"
                        attribute = HandlerBase.RemoveAttribute(child, "bypassonlocal");

                        if ( ReadBoolValue(attribute, ref result) ) {
                            webProxy.BypassProxyOnLocal = result;
                        }
    
                        // read proxyaddress="http://sampleproxy"
                        attribute = HandlerBase.RemoveAttribute(child, "proxyaddress");                    
                    
                        if (attribute != null) { 
                            try {
                                webProxy.Address = new Uri(attribute);
                            } catch (Exception) {}
                        }
                    }
                    
                } else if ( listName == "bypasslist" ) {
                    if ( IsNormalWebProxy(m_IWebProxy) ) {
                        WalkXmlNodeList(child);
                    } 
                } else if ( listName == "module" ) {
                    WebProxy webProxy = m_IWebProxy as System.Net.WebProxy;
                    attribute = HandlerBase.RemoveAttribute(child, "type");                    
                    if ( ReadModuleType(attribute, ref m_IWebProxy) ) {
                        WebProxy webProxyNew = m_IWebProxy as System.Net.WebProxy;
                        if (webProxy != null && webProxyNew!=null) {
                            webProxyNew.Address            = webProxy.Address;
                            webProxyNew.BypassProxyOnLocal = webProxy.BypassProxyOnLocal;
                            webProxyNew.BypassList         = webProxy.BypassList;
                        }
                    }
                }
            }

            return Get();
        }

        //
        // Make the name of the key attribute configurable by derived classes
        //
        protected override string KeyAttributeName {
             get { return "address";}
        }

    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\internal.cs ===
//------------------------------------------------------------------------------
// <copyright file="Internal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Net;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Security.Permissions;
    using System.Security.Util;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;


    //
    // IO-Control operations are not directly exposed.
    // blocking is controlled by "Blocking" property on socket (FIONBIO)
    // amount of data available is queried by "Available" property (FIONREAD)
    // The other flags are not exposed currently
    //
    internal class IoctlSocketConstants {

        public const int FIONREAD   = 0x4004667F;
        public const int FIONBIO    = unchecked((int)0x8004667E);
        public const int FIOASYNC   = unchecked((int)0x8004667D);

        //
        // not likely to block (sync IO ok)
        //
        // FIONBIO
        // FIONREAD
        // SIOCATMARK
        // SIO_RCVALL
        // SIO_RCVALL_MCAST
        // SIO_RCVALL_IGMPMCAST
        // SIO_KEEPALIVE_VALS
        // SIO_ASSOCIATE_HANDLE (opcode setting: I, T==1)
        // SIO_ENABLE_CIRCULAR_QUEUEING (opcode setting: V, T==1)
        // SIO_GET_BROADCAST_ADDRESS (opcode setting: O, T==1)
        // SIO_GET_EXTENSION_FUNCTION_POINTER (opcode setting: O, I, T==1)
        // SIO_MULTIPOINT_LOOPBACK (opcode setting: I, T==1)
        // SIO_MULTICAST_SCOPE (opcode setting: I, T==1)
        // SIO_TRANSLATE_HANDLE (opcode setting: I, O, T==1)
        // SIO_ROUTING_INTERFACE_QUERY (opcode setting: I, O, T==1)
        //
        // likely to block (reccommended for async IO)
        //
        // SIO_FIND_ROUTE (opcode setting: O, T==1)
        // SIO_FLUSH (opcode setting: V, T==1)
        // SIO_GET_QOS (opcode setting: O, T==1)
        // SIO_GET_GROUP_QOS (opcode setting: O, I, T==1)
        // SIO_SET_QOS (opcode setting: I, T==1)
        // SIO_SET_GROUP_QOS (opcode setting: I, T==1)
        // SIO_ROUTING_INTERFACE_CHANGE (opcode setting: I, T==1)
        // SIO_ADDRESS_LIST_CHANGE (opcode setting: T==1)
    }

    //
    // WinSock 2 extension -- bit values and indices for FD_XXX network events
    //
    [Flags]
    internal enum AsyncEventBits {
        FdNone                     = 0,
        FdRead                     = 1 << 0,
        FdWrite                    = 1 << 1,
        FdOob                      = 1 << 2,    
        FdAccept                   = 1 << 3,
        FdConnect                  = 1 << 4,
        FdClose                    = 1 << 5,
        FdQos                      = 1 << 6,
        FdGroupQos                 = 1 << 7,
        FdRoutingInterfaceChange   = 1 << 8,
        FdAddressListChange        = 1 << 9,
        FdAllEvents                = (1 << 10) - 1,
    }


    [StructLayout(LayoutKind.Sequential)]
    internal struct FileDescriptorSet {
        //
        // how many are set?
        //
        public int Count;
        //
        // an array of Socket handles
        //
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=MaxCount)]
        public IntPtr[] Array; 

        public static readonly int Size = Marshal.SizeOf(typeof(FileDescriptorSet));
        public static readonly FileDescriptorSet Empty = new FileDescriptorSet(0);
        public const int MaxCount = 64;

        public FileDescriptorSet(int count) {
            Count = count;
            Array = count == 0 ? null : new IntPtr[MaxCount];
        }


    } // class FileDescriptorSet

    //
    // Structure used in select() call, taken from the BSD file sys/time.h.
    //
    [StructLayout(LayoutKind.Sequential)]
    internal struct TimeValue {
        public int Seconds;  // seconds
        public int Microseconds; // and microseconds

    } // struct TimeValue


    internal class ComNetOS {

        internal static readonly bool IsWin9x;
        internal static readonly bool IsWinNt;
        internal static readonly bool IsWinNt4;
        internal static readonly bool IsWin2K;
        internal static readonly bool IsPostWin2K; // ie: XP or later but not Win2K
        internal static readonly bool IsAspNetServer; // ie: running under ASP+

        // We use it safe so assert
        [EnvironmentPermission(SecurityAction.Assert,Unrestricted=true)]
        static ComNetOS() {
            OperatingSystem operatingSystem = Environment.OSVersion;

            GlobalLog.Print("ComNetOS::.ctor(): " + operatingSystem.ToString());

            if (operatingSystem.Platform == PlatformID.Win32Windows) {
                IsWin9x = true;
                return;
            }

            //
            // Detect ASP+ as a platform running under NT
            //
            
            try {            
                IsAspNetServer = (Thread.GetDomain().GetData(".appDomain") != null);
            } catch {
            }

            //
            // Platform is Windows NT or later
            // NT4: 4.0
            // 2000: 5.0
            // XP: 5.1
            //
            IsWinNt = true;

            if (operatingSystem.Version.Major==4) {
                IsWinNt4 = true;
                return;
            }

            //
            // Platform is Windows NT 2K or later
            // operatingSystem.Version.Major>=5
            //
            IsWin2K = true;

            if (operatingSystem.Version.Major==5 && operatingSystem.Version.Minor==0) {
                return;
            }

            IsPostWin2K = true;
        }

    } // class ComNetOS


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\protocolfamily.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProtocolFamily.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {

    /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of protocol that an instance of the <see cref='System.Net.Sockets.Socket'/>
    ///       class can use.
    ///    </para>
    /// </devdoc>
    public enum ProtocolFamily {
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown             = AddressFamily.Unknown,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Unspecified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unspecified         = AddressFamily.Unspecified,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Unix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unix                = AddressFamily.Unix,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.InterNetwork"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InterNetwork        = AddressFamily.InterNetwork,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.ImpLink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ImpLink             = AddressFamily.ImpLink,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Pup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pup                 = AddressFamily.Pup,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Chaos"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Chaos               = AddressFamily.Chaos,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.NS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NS                  = AddressFamily.NS,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Ipx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ipx                 = AddressFamily.Ipx,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Iso"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Iso                 = AddressFamily.Iso,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Osi"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Osi                 = AddressFamily.Osi,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Ecma"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ecma                = AddressFamily.Ecma,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.DataKit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DataKit             = AddressFamily.DataKit,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Ccitt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ccitt               = AddressFamily.Ccitt,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Sna"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sna                 = AddressFamily.Sna,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.DecNet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DecNet              = AddressFamily.DecNet,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.DataLink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DataLink            = AddressFamily.DataLink,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Lat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Lat                 = AddressFamily.Lat,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.HyperChannel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HyperChannel        = AddressFamily.HyperChannel,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.AppleTalk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AppleTalk           = AddressFamily.AppleTalk,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.NetBios"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NetBios             = AddressFamily.NetBios,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.VoiceView"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VoiceView           = AddressFamily.VoiceView,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.FireFox"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FireFox             = AddressFamily.FireFox,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Banyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Banyan              = AddressFamily.Banyan,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Atm"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Atm                 = AddressFamily.Atm,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.InterNetworkV6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InterNetworkV6      = AddressFamily.InterNetworkV6,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Cluster"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cluster             = AddressFamily.Cluster,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Ieee12844"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ieee12844           = AddressFamily.Ieee12844,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Irda"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Irda                = AddressFamily.Irda,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.NetworkDesigners"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NetworkDesigners    = AddressFamily.NetworkDesigners,
        /// <include file='doc\ProtocolFamily.uex' path='docs/doc[@for="ProtocolFamily.Max"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Max                 = AddressFamily.Max,

    }; // enum ProtocolFamily


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\networkstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="NetworkStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System.IO;
    using System.Runtime.InteropServices;

    /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides the underlying stream of data for network access.
    ///    </para>
    /// </devdoc>
    public class NetworkStream : Stream, IDisposable {
        /// <devdoc>
        ///    <para>
        ///       Used by the class to hold the underlying socket the stream uses.
        ///    </para>
        /// </devdoc>
        internal  Socket    m_StreamSocket;

        /// <devdoc>
        ///    <para>
        ///       Used by the class to indicate that the stream is m_Readable.
        ///    </para>
        /// </devdoc>
        private bool      m_Readable;

        /// <devdoc>
        ///    <para>
        ///       Used by the class to indicate that the stream is writable.
        ///    </para>
        /// </devdoc>
        private bool      m_Writeable;

        internal bool     m_OwnsSocket;

        // Can be constructed directly out of a socket
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.NetworkStream"]/*' />
        /// <devdoc>
        /// <para>Creates a new instance of the <see cref='System.Net.Sockets.NetworkStream'/> class for the specified <see cref='System.Net.Sockets.Socket'/>.</para>
        /// </devdoc>
        public NetworkStream(Socket socket) {
            if (socket == null) {
                throw new ArgumentNullException("socket");
            }
            InitNetworkStream(socket, FileAccess.ReadWrite);
        }
        //UEUE (see FileStream)
        // ownsHandle: true if the file handle will be owned by this NetworkStream instance; otherwise, false.
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.NetworkStream2"]/*' />
        public NetworkStream(Socket socket, bool ownsSocket) {
            if (socket == null) {
                throw new ArgumentNullException("socket");
            }
            InitNetworkStream(socket, FileAccess.ReadWrite);
            m_OwnsSocket = ownsSocket;
        }


        // Create with a socket and access mode
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.NetworkStream1"]/*' />
        /// <devdoc>
        /// <para>Creates a new instance of the <see cref='System.Net.Sockets.NetworkStream'/> class for the specified <see cref='System.Net.Sockets.Socket'/> with the specified access rights.</para>
        /// </devdoc>
        public NetworkStream(Socket socket, FileAccess access) {
            if (socket == null) {
                throw new ArgumentNullException("socket");
            }
            InitNetworkStream(socket, access);
        }
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.NetworkStream3"]/*' />
        public NetworkStream(Socket socket, FileAccess access, bool ownsSocket) {
            if (socket == null) {
                throw new ArgumentNullException("socket");
            }
            InitNetworkStream(socket, access);
            m_OwnsSocket = ownsSocket;
        }

        //
        // Socket - provides access to socket for stream closing
        //
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Socket"]/*' />
        protected Socket Socket {
            get {
                return m_StreamSocket;
            }
        }

        internal Socket StreamSocket {
            get {
                return m_StreamSocket;
            }
            set {
                m_StreamSocket = value;
            }
        }

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Readable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to indicate that the stream is m_Readable.
        ///    </para>
        /// </devdoc>
        protected bool Readable {
            get {
                return m_Readable;
            }
            set {
                m_Readable = value;
            }
        }

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Writeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to indicate that the stream is writable.
        ///    </para>
        /// </devdoc>
        protected bool Writeable {
            get {
                return m_Writeable;
            }
            set {
                m_Writeable = value;
            }
        }

        /*++

            Read property for this class. We return the readability of this
            stream. This is a read only property.

            Input: Nothing.

            Returns: True if stream is m_Readable, false otherwise.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.CanRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that data can be read from the stream.
        ///    </para>
        /// </devdoc>
        public override bool CanRead {
            get {
                return m_Readable;
            }
        }

        /*++

            Seek property for this class. Since this stream is not
            seekable, we just return false. This is a read only property.

            Input: Nothing.

            Returns: false

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.CanSeek"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that the stream can seek a specific location
        ///       in the stream. This property always returns <see langword='false'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public override bool CanSeek {
            get {
                return false;
            }
        }

        /*++

            Write property for this class.  We return the writeability of this
            stream. This is a read only property.

            Input: Nothing.

            Returns: True if stream is m_Writeable, false otherwise.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.CanWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that data can be written to the stream.
        ///    </para>
        /// </devdoc>
        public override bool CanWrite {
            get {
                return m_Writeable;
            }
        }


        /*++

            DataAvailable property for this class. This property check to see
            if at least one byte of data is currently available. This is a read
            only property.

            Input: Nothing.

            Returns: True if data is available, false otherwise.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.DataAvailable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates data is available on the stream to be read.
        ///    </para>
        /// </devdoc>
        public virtual bool DataAvailable {
            get {

                if (m_CleanedUp){
                    throw new ObjectDisposedException(this.GetType().FullName);
                }

                Socket chkStreamSocket = m_StreamSocket;
                if(chkStreamSocket == null) {
                    throw new IOException(SR.GetString(SR.net_io_readfailure));
                }

                // Ask the socket how many bytes are available. If it's
                // not zero, return true.

                return chkStreamSocket.Available != 0;
            }
        }

        /*++

            Length property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Length"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The length of data available on the stream. Always throws <see cref='NotSupportedException'/>.
        ///    </para>
        /// </devdoc>
        public override long Length {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
        }

        /*++

            Position property for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input: Nothing.

            Returns: Throws exception.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Position"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the position in the stream. Always throws <see cref='NotSupportedException'/>.
        ///    </para>
        /// </devdoc>
        public override long Position {
            get {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }

            set {
                throw new NotSupportedException(SR.GetString(SR.net_noseek));
            }
        }


        /*++

            Seek method for this class. Since we don't support seeking,
            this property just throws a NotSupportedException.

            Input:
                    offset          - Offset to see to.
                    origin          - origin of seek.

            Returns: Throws exception.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Seek"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Seeks a specific position in the stream. This method is not supported by the
        ///    <see cref='NetworkStream'/> class.
        ///    </para>
        /// </devdoc>
        public override long Seek(long offset, SeekOrigin origin) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));
        }


        /*++

            InitNetworkStream - initialize a network stream.

            This is the common NetworkStream constructor, called whenever a
            network stream is created. We validate the socket, set a few
            options, and call our parent's initializer.

            Input:

                S           - Socket to be used.
                Access      - Access type desired.


            Returns:

                Nothing, but may throw an exception.
        --*/

        private void InitNetworkStream(Socket socket, FileAccess Access) {
            //
            // parameter validation
            //
            if (!socket.Blocking) {
                throw new IOException(SR.GetString(SR.net_sockets_blocking));
            }
            if (!socket.Connected) {
                throw new IOException(SR.GetString(SR.net_notconnected));
            }
            if (socket.SocketType != SocketType.Stream) {
                throw new IOException(SR.GetString(SR.net_notstream));
            }

            m_StreamSocket = socket;

            switch (Access) {
                case FileAccess.Read:
                    m_Readable = true;
                    break;
                case FileAccess.Write:
                    m_Writeable = true;
                    break;
                case FileAccess.ReadWrite:
                default: // assume FileAccess.ReadWrite
                    m_Readable = true;
                    m_Writeable = true;
                    break;
            }

        }

        /*++
            Read - provide core Read functionality.

            Provide core read functionality. All we do is call through to the
            socket Receive functionality.

            Input:

                Buffer  - Buffer to read into.
                Offset  - Offset into the buffer where we're to read.
                Count   - Number of bytes to read.

            Returns:

                Number of bytes we read, or 0 if the socket is closed.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Read"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Reads data from the stream.
        ///    </para>
        /// </devdoc>
        //UEUE
        public override int Read([In, Out] byte[] buffer, int offset, int size) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if (chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_readfailure));
            }

            try {
                int bytesTransferred = chkStreamSocket.Receive(buffer, offset, size, 0);
                return bytesTransferred;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_readfailure), exception);
            }
        }

        /*++
            Write - provide core Write functionality.

            Provide core write functionality. All we do is call through to the
            socket Send method..

            Input:

                Buffer  - Buffer to write from.
                Offset  - Offset into the buffer from where we'll start writing.
                Count   - Number of bytes to write.

            Returns:

                Number of bytes written. We'll throw an exception if we
                can't write everything. It's brutal, but there's no other
                way to indicate an error.
        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Write"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes data to the stream..
        ///    </para>
        /// </devdoc>
        public override void Write(byte[] buffer, int offset, int size) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_writefailure));
            }

            try {
                //
                // since the socket is in blocking mode this will always complete
                // after ALL the requested number of bytes was transferred
                //
                chkStreamSocket.Send(buffer, offset, size, SocketFlags.None);
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_writefailure), exception);
            }
        }

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the stream, and then closes the underlying socket.
        ///    </para>
        /// </devdoc>
        public override void Close() {
            GlobalLog.Print("NetworkStream::Close()");
            ((IDisposable)this).Dispose();
        }

        private bool m_CleanedUp = false;
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (m_CleanedUp) {
                return;
            }

            if (disposing) {
                //no managed objects to cleanup
            }
            //
            // only resource we need to free is the network stream, since this
            // is based on the client socket, closing the stream will cause us
            // to flush the data to the network, close the stream and (in the
            // NetoworkStream code) close the socket as well.
            //
            if (m_StreamSocket!=null) {
                m_Readable = false;
                m_Writeable = false;
                if (m_OwnsSocket) {
                    //
                    // if we own the Socket (false by default), close it
                    // swallowing possible exceptions (eg: the user told us
                    // that we own the Socket but it closed at some point of time,
                    // here we would get an ObjectDisposedException)
                    //
                    Socket chkStreamSocket = m_StreamSocket;
                    if (chkStreamSocket!=null) {
                        chkStreamSocket.InternalShutdown(SocketShutdown.Both);
                        chkStreamSocket.Close();
                    }
                }
                //
                // at this point dereference the Socket anyway
                //
                m_StreamSocket = null;
            }
            m_CleanedUp = true;
        }

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Finalize"]/*' />
        ~NetworkStream() {
            Dispose(false);
        }



        /*++
            BeginRead - provide async read functionality.

            This method provides async read functionality. All we do is
            call through to the underlying socket async read.

            Input:

                buffer  - Buffer to read into.
                offset  - Offset into the buffer where we're to read.
                size   - Number of bytes to read.

            Returns:

                An IASyncResult, representing the read.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.BeginRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Begins an asychronous read from a stream.
        ///    </para>
        /// </devdoc>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, Object state) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_readfailure));
            }

            try {
                IAsyncResult asyncResult =
                    chkStreamSocket.BeginReceive(
                        buffer,
                        offset,
                        size,
                        SocketFlags.None,
                        callback,
                        state);

                return asyncResult;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_readfailure), exception);
            }
        }

        /*++
            EndRead - handle the end of an async read.

            This method is called when an async read is completed. All we
            do is call through to the core socket EndReceive functionality.
            Input:

                buffer  - Buffer to read into.
                offset  - Offset into the buffer where we're to read.
                size   - Number of bytes to read.

            Returns:

                The number of bytes read. May throw an exception.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.EndRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Handle the end of an asynchronous read.
        ///    </para>
        /// </devdoc>
        public override int EndRead(IAsyncResult asyncResult) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_readfailure));
            }

            try {
                int bytesTransferred = chkStreamSocket.EndReceive(asyncResult);
                return bytesTransferred;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_readfailure), exception);
            }
        }

        /*++
            BeginWrite - provide async write functionality.

            This method provides async write functionality. All we do is
            call through to the underlying socket async send.

            Input:

                buffer  - Buffer to write into.
                offset  - Offset into the buffer where we're to write.
                size   - Number of bytes to written.

            Returns:

                An IASyncResult, representing the write.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.BeginWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Begins an asynchronous write to a stream.
        ///    </para>
        /// </devdoc>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, Object state) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_writefailure));
            }

            try {
                //
                // call BeginSend on the Socket.
                //
                IAsyncResult asyncResult =
                    chkStreamSocket.BeginSend(
                        buffer,
                        offset,
                        size,
                        SocketFlags.None,
                        callback,
                        state);

                return asyncResult;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_writefailure), exception);
            }
        }


        /*++
            EndWrite - handle the end of an async write.

            This method is called when an async write is completed. All we
            do is call through to the core socket EndSend functionality.
            Input:

            Returns:

                The number of bytes read. May throw an exception.

        --*/

        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.EndWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Handle the end of an asynchronous write.
        ///    </para>
        /// </devdoc>
        public override void EndWrite(IAsyncResult asyncResult) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_writefailure));
            }

            try {
                chkStreamSocket.EndSend(asyncResult);
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_writefailure), exception);
            }
        }


        /// <devdoc>
        ///    <para>
        ///       Performs a sync Write of an array of buffers.
        ///    </para>
        /// </devdoc>
        internal virtual void MultipleWrite(
            BufferOffsetSize[] buffers
            ) {

            //
            // parameter validation
            //
            if (buffers == null) {
                throw new ArgumentNullException("buffers");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_writefailure));
            }

            try {
                buffers = ConcatenateBuffersOnWin9x(buffers);

                chkStreamSocket.MultipleSend(
                    buffers,
                    SocketFlags.None);

            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_writefailure), exception);
            }
        }
        

        /// <devdoc>
        ///    <para>
        ///       Starts off an async Write of an array of buffers.
        ///    </para>
        /// </devdoc>
        internal virtual IAsyncResult BeginMultipleWrite(
            BufferOffsetSize[] buffers,
            AsyncCallback callback,
            Object state) {
            //
            // parameter validation
            //
            if (buffers == null) {
                throw new ArgumentNullException("buffers");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_writefailure));
            }

            try {
                buffers = ConcatenateBuffersOnWin9x(buffers);
                //
                // call BeginMultipleSend on the Socket.
                //
                IAsyncResult asyncResult =
                    chkStreamSocket.BeginMultipleSend(
                        buffers,
                        SocketFlags.None,
                        callback,
                        state);

                return asyncResult;
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_writefailure), exception);
            }
        }

        internal virtual void EndMultipleWrite(IAsyncResult asyncResult) {
            //
            // parameter validation
            //
            if (asyncResult == null) {
                throw new ArgumentNullException("asyncResult");
            }

            Socket chkStreamSocket = m_StreamSocket;
            if(chkStreamSocket == null) {
                throw new IOException(SR.GetString(SR.net_io_writefailure));
            }

            try {
                chkStreamSocket.EndMultipleSend(asyncResult);
            }
            catch (Exception exception) {
                //
                // some sort of error occured on the socket call,
                // set the SocketException as InnerException and throw
                //
                throw new IOException(SR.GetString(SR.net_io_writefailure), exception);
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Due to Winsock restrictions
        ///       If on Win9x platforms and the number of buffers are more than 16, performs 
        ///         concatenation of the buffers, so that we have 16 buffers. 
        ///    </para>
        /// </devdoc>
        private BufferOffsetSize[] ConcatenateBuffersOnWin9x(BufferOffsetSize[] buffers) {
            if (ComNetOS.IsWin9x && buffers.Length > 16) {
                // We met the limitation of winsock on Win9x
                // Combine buffers after the 15th into one so overall number does not exceed 16
                BufferOffsetSize[] newBuffers = new BufferOffsetSize[16];
                int i;
                for (i = 0; i < 16; ++i) {
                    newBuffers[i] = buffers[i];
                }
                int size = 0;
                for (i = 15; i < buffers.Length; ++i) {
                    size += buffers[i].Size;
                }
                if (size > 0) {
                    newBuffers[15] = new BufferOffsetSize(new byte[size], 0, size, false);
                    for (size = 0, i = 15; i < buffers.Length; size+=buffers[i].Size, ++i) {
                        System.Buffer.BlockCopy(buffers[i].Buffer, buffers[i].Offset, newBuffers[15].Buffer, size, buffers[i].Size);
                    }
                }
                buffers = newBuffers;
            }
            return buffers;
        }


        /*++
            Flush - Flush the stream

            Called when the user wants to flush the stream. This is meaningless to
            us, so we just ignore it.

            Input:

                Nothing.

            Returns:

                Nothing.



        --*/
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.Flush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Flushes data from the stream.
        ///    </para>
        /// </devdoc>
        public override void Flush() {
        }

        /*++
            SetLength - Set the length on the stream

            Called when the user wants to set the stream length. Since we don't
            support seek, we'll throw an exception.

            Input:

                value       - length of stream to set

            Returns:

                Throws exception



        --*/
        /// <include file='doc\NetworkStream.uex' path='docs/doc[@for="NetworkStream.SetLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the length of the stream. Always throws <see cref='NotSupportedException'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public override void SetLength(long value) {
            throw new NotSupportedException(SR.GetString(SR.net_noseek));
        }

    }; // class NetworkStream


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\socket.cs ===
//------------------------------------------------------------------------------
// <copyright file="Socket.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Net;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Security.Permissions;
    using System.ComponentModel;
    using System.Diagnostics;
    using Microsoft.Win32;
    using SecurityException=System.Security.SecurityException;


    /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket"]/*' />
    /// <devdoc>
    /// <para>The <see cref='Sockets.Socket'/> class implements the Berkeley sockets
    ///    interface.</para>
    /// </devdoc>
    public class Socket : IDisposable {

        // static bool variable activates static socket initializing method
        private static bool m_Initialized = InitializeSockets();
        //
        // IPv6 Changes: These are initialized in InitializeSockets - don't set them here or
        //               there will be an ordering problem with the call above that will
        //               result in both being set to false !
        //
        private static bool m_SupportsIPv4;
        private static bool m_SupportsIPv6;

        // bool In Callback Accept
        internal bool       incallback;

        // AcceptQueue - queued list of accept requests for BeginAccept
        private ArrayList   m_AcceptQueue; // = new ArrayList();

        // the following 8 members represent the state of the socket
        internal IntPtr     m_Handle;
        internal EndPoint   m_RightEndPoint;
        private EndPoint    m_LocalEndPoint;
        private EndPoint    m_RemoteEndPoint;
        // this flags monitor if the socket was ever connected at any time and if it still is.
        private bool        m_WasConnected; //  = false;
        private bool        m_WasDisconnected; // = false;
        // when the socket is created it will be in blocking mode
        // we'll only be able to Accept or Connect, so we only need
        // to handle one of these cases at a time
        private bool        willBlock = true; // desired state of the socket for the user
        private bool        willBlockInternal = true; // actual win32 state of the socket

        // These are constants initialized by constructor
        private AddressFamily   addressFamily;
        private SocketType      socketType;
        private ProtocolType    protocolType;

        // Bool marked true if the native socket m_Handle was bound to the ThreadPool
        private bool        m_Bound; // = false;

        // Event used for async Connect/Accept calls
        internal AutoResetEvent m_AsyncEvent;
        internal AsyncEventBits m_BlockEventBits = AsyncEventBits.FdNone;

        //These members are to cache permission checks
        private SocketAddress   m_PermittedRemoteAddress = null;

#if CALEB
private static int counter;
#endif

        //
        // socketAddress must always be the result of remoteEP.Serialize()
        //
        private void CheckCacheRemote(SocketAddress socketAddress, EndPoint remoteEP, bool isOverwrite) {
            // We remember the first peer we have communicated with
            if (m_PermittedRemoteAddress != null && m_PermittedRemoteAddress.Equals(socketAddress)) {
                return;
            }
            //
            // for now SocketPermission supports only IPEndPoint
            //
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                //
                // cast the EndPoint to IPEndPoint
                //
                IPEndPoint remoteIPEndPoint = (IPEndPoint)remoteEP;
                //
                // create the permissions the user would need for the call
                //
                SocketPermission socketPermission
                    = new SocketPermission(
                        NetworkAccess.Connect,
                        Transport,
                        remoteIPEndPoint.Address.ToString(),
                        remoteIPEndPoint.Port);
                //
                // demand for them
                //
                socketPermission.Demand();
            }
            else {
                //
                // for V1 we will demand permission to run UnmanagedCode for
                // an EndPoint that is not an IPEndPoint until we figure out how these fit
                // into the whole picture of SocketPermission
                //

                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();
            }
            //cache only the first peer we communicated with
            if (m_PermittedRemoteAddress == null || isOverwrite) {
                m_PermittedRemoteAddress = socketAddress;
            }
        }

        //------------------------------------

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Socket"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='Sockets.Socket'/> class.
        ///    </para>
        /// </devdoc>
        public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType) {
            m_Handle =
                UnsafeNclNativeMethods.OSSOCK.WSASocket(
                    addressFamily,
                    socketType,
                    protocolType,
                    IntPtr.Zero,
                    0,
                    SocketConstructorFlags.WSA_FLAG_OVERLAPPED );

            if (m_Handle==SocketErrors.InvalidSocketIntPtr) {
                //
                // failed to create the win32 socket, throw
                //
                throw new SocketException();
            }

#if CALEB
Interlocked.Increment(ref counter);
Console.WriteLine("created new socket(handle#" + m_Handle.ToString() + ") opened:" + counter.ToString());
#endif

            this.addressFamily = addressFamily;
            this.socketType = socketType;
            this.protocolType = protocolType;
        }

        /// <devdoc>
        ///    <para>
        ///       Called by the class to create a socket to accept an
        ///       incoming request.
        ///    </para>
        /// </devdoc>
        //protected Socket(IntPtr fd) {
        private Socket(IntPtr fd) {
            //new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            //
            // consider v.next: if this ctor is re-publicized/protected, check
            // that fd is valid socket handle.
            // getsockopt(fd, SOL_SOCKET, SO_ERROR, &dwError, &dwErrorSize)
            // would work
            //

            //
            // this should never happen, let's check anyway
            //
            if (fd==SocketErrors.InvalidSocketIntPtr) {
                throw new ArgumentException(SR.GetString(SR.net_InvalidSocketHandle, fd.ToString()));
            }

            m_Handle = fd;

            addressFamily = Sockets.AddressFamily.Unknown;
            socketType = Sockets.SocketType.Unknown;
            protocolType = Sockets.ProtocolType.Unknown;

#if CALEB
Interlocked.Increment(ref counter);
Console.WriteLine("accepted new socket(handle#" + m_Handle.ToString() + ") opened:" + counter.ToString());
#endif
        }


        //
        // Overlapped constants.
        //
        internal static bool UseOverlappedIO;

        internal static bool InitializeSockets() {
            if (m_Initialized) {
                return true;
            }

            WSAData wsaData = new WSAData();

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSAStartup(
                    (short)0x0202, // we need 2.2
                    out wsaData );

            if (errorCode!=SocketErrors.Success) {
                //
                // failed to initialize, throw
                //
                throw new SocketException();
            }

            //
            // at this point we need to figure out if we're going to use CompletionPort,
            // which are supported only on WinNT, or classic Win32 OverlappedIO, so
            //
            if (ComNetOS.IsWinNt) {
                //
                // we're on WinNT4 or greater, we could use CompletionPort if we
                // wanted. check if the user has disabled this functionality in
                // the registry, otherwise use CompletionPort.
                //

#if DEBUG
                BooleanSwitch disableCompletionPortSwitch =
                    new BooleanSwitch("DisableNetCompletionPort", "System.Net disabling of Completion Port");

                //
                // the following will be true if they've disabled the completionPort
                //
                UseOverlappedIO = disableCompletionPortSwitch.Enabled;
#endif
            }
            else {
                UseOverlappedIO = true;
            }

            //
            //
            // IPv6 Changes: Get a list of the supported address families for sockets on this
            //               machine so we can indicate whether IPv4 and IPv6 are supported.
            //
            bool   ipv4      = false; // No external state change during execution
            bool   ipv6      = false; // No external state change during execution
            uint   bufferlen = (uint)Marshal.SizeOf(typeof(WSAPROTOCOL_INFO)) * 50;
            IntPtr buffer    = Marshal.AllocHGlobal((int)bufferlen);

            errorCode = UnsafeNclNativeMethods.OSSOCK.WSAEnumProtocols(null,buffer,ref bufferlen);

            if ( errorCode == SocketErrors.WSAENOBUFS ) {
                //
                // Buffer was too small. Re-allocate and try once more
                //
                Marshal.FreeHGlobal(buffer);

                buffer    = Marshal.AllocHGlobal((int)bufferlen);
                errorCode = UnsafeNclNativeMethods.OSSOCK.WSAEnumProtocols(null,buffer,ref bufferlen);
            }

            if ( errorCode == SocketErrors.SocketError ) {
                Marshal.FreeHGlobal(buffer); // no leaks here !
                throw new SocketException();
            }

            long ptr = buffer.ToInt64();

            for ( int i = 0; i < errorCode; i++ ) {
                WSAPROTOCOL_INFO info = (WSAPROTOCOL_INFO)Marshal.PtrToStructure((IntPtr)ptr,typeof(WSAPROTOCOL_INFO));

                if ( info.iAddressFamily == (int)AddressFamily.InterNetwork ) {
                    ipv4 = true;
                }
                else if ( info.iAddressFamily == (int)AddressFamily.InterNetworkV6 ) {
                    ipv6 = true;
                }

                ptr += Marshal.SizeOf(typeof(WSAPROTOCOL_INFO));
            }

            Marshal.FreeHGlobal(buffer);

            //
            // CONSIDER: Checking that the platforms supports at least one of IPv4 or IPv6.
            //

#if COMNET_DISABLEIPV6
            //
            // Turn off IPv6 support
            //
            ipv6 = false;
#else
            //
            // Revisit IPv6 support based on the OS platform
            //
            ipv6 = ( ipv6 && ComNetOS.IsPostWin2K );

            //
            // Now read the switch as the final check: by checking the current value for IPv6
            // support we may be able to avoid a painful configuration file read.
            //
            if (ipv6) {
                NetConfiguration config = (NetConfiguration)System.Configuration.ConfigurationSettings.GetConfig("system.net/settings");
                if (config != null) {
                    ipv6 = config.ipv6Enabled;
                }
                else {
                    ipv6 = false;
                }
            }
#endif
            //
            // Update final state
            //
            m_SupportsIPv4 = ipv4;
            m_SupportsIPv6 = ipv6;

            return true;
        }

        /// <devdoc>
        ///    <para>Indicates whether IPv4 support is available and enabled on this machine.</para>
        /// </devdoc>
        public static bool SupportsIPv4 {
            get {
                if ( !InitializeSockets() ) {
                    return false;
                }

                return m_SupportsIPv4;
            }
        }

        /// <devdoc>
        ///    <para>Indicates whether IPv6 support is available and enabled on this machine.</para>
        /// </devdoc>
        public static bool SupportsIPv6 {
            get {
                if ( !InitializeSockets() ) {
                    return false;
                }

                return m_SupportsIPv6;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Bind"]/*' />
        /// <devdoc>
        ///    <para>Associates a socket with an end point.</para>
        /// </devdoc>
        public void Bind(EndPoint localEP) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (localEP==null) {
                throw new ArgumentNullException("localEP");
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Bind() localEP:" + localEP.ToString());

            EndPoint endPointSnapshot = localEP;
            //
            // for now security is implemented only on IPEndPoint
            // If EndPoint is of other type - unmanaged code permisison is demanded
            //
            if (endPointSnapshot.GetType()==typeof(IPEndPoint)) {
                //
                // cast the EndPoint to IPEndPoint
                //
                endPointSnapshot = new IPEndPoint(((IPEndPoint)localEP).Address, ((IPEndPoint)localEP).Port);
                IPEndPoint localIPEndPoint = (IPEndPoint)endPointSnapshot;
                //
                // create the permissions the user would need for the call
                //
                SocketPermission socketPermission
                    = new SocketPermission(
                        NetworkAccess.Accept,
                        Transport,
                        localIPEndPoint.Address.ToString(),
                        localIPEndPoint.Port);
                //
                // demand for them
                //
                socketPermission.Demand();

                // Here the permission check has succeded.
                // NB: if local port is 0, then winsock will assign some>1024,
                //     so assuming that this is safe. We will not check the
                //     NetworkAccess.Accept permissions in Receive.
            }
            else {
                //
                // for V1 we will demand permission to run UnmanagedCode for
                // an EndPoint that is not an IPEndPoint until we figure out how these fit
                // into the whole picture of SocketPermission
                //

                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Demand();
            }

            //
            // ask the EndPoint to generate a SocketAddress that we
            // can pass down to winsock
            //
            SocketAddress socketAddress = endPointSnapshot.Serialize();

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.bind(
                    m_Handle,
                    socketAddress.m_Buffer,
                    socketAddress.m_Size );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            if (m_RightEndPoint==null) {
                //
                // save a copy of the EndPoint so we can use it for Create()
                //
                m_RightEndPoint = endPointSnapshot;
            }

        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Connect"]/*' />
        /// <devdoc>
        ///    <para>Establishes a connection to a remote system.</para>
        /// </devdoc>
        public void Connect(EndPoint remoteEP) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }
            ValidateBlockingMode();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Connect() remoteEP:" + remoteEP.ToString());

            //
            // ask the EndPoint to generate a SocketAddress that we
            // can pass down to winsock
            //
            EndPoint endPointSnapshot = remoteEP;
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                endPointSnapshot = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);
            }
            SocketAddress socketAddress = endPointSnapshot.Serialize();

            //This will check the permissions for connect
            CheckCacheRemote(socketAddress, endPointSnapshot, true);

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.connect(
                    m_Handle,
                    socketAddress.m_Buffer,
                    socketAddress.m_Size );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            if (m_RightEndPoint==null) {
                //
                // save a copy of the EndPoint so we can use it for Create()
                //
                m_RightEndPoint = endPointSnapshot;
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Connect() now connected to:" + endPointSnapshot.ToString());

            //
            // update state and performance counter
            //
            SetToConnected();
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Connected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the connection state of the Socket. This property will return the latest
        ///       known state of the Socket. When it returns false, the Socket was either never connected
        ///       or it is not connected anymore. When it returns true, though, there's no guarantee that the Socket
        ///       is still connected, but only that it was connected at the time of the last IO operation.
        ///    </para>
        /// </devdoc>
        public bool Connected {
            get {
                return m_WasConnected && !m_WasDisconnected;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.AddressFamily"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the socket's address family.
        ///    </para>
        /// </devdoc>
        public AddressFamily AddressFamily {
            get {
                return addressFamily;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SocketType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the socket's socketType.
        ///    </para>
        /// </devdoc>
        public SocketType SocketType {
            get {
                return socketType;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.ProtocolType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the socket's protocol socketType.
        ///    </para>
        /// </devdoc>
        public ProtocolType ProtocolType {
            get {
                return protocolType;
            }
        }

        internal ArrayList AcceptQueue {
            get {
                if (m_AcceptQueue==null) {
                    lock (this) {
                        if (m_AcceptQueue==null) {
                            m_AcceptQueue = new ArrayList();
                        }
                    }
                }
                return m_AcceptQueue;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Forces a socket connection to close.
        ///    </para>
        /// </devdoc>
        public void Close() {
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Close()");
            ((IDisposable)this).Dispose();
        }

        private int m_IntCleanedUp;                 // 0 if not completed >0 otherwise.
        internal bool CleanedUp { 
            get {
                return (m_IntCleanedUp > 0);
            }
        }


        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Dispose() disposing:" + disposing.ToString() + " CleanedUp:" + CleanedUp.ToString());

            // make sure we're the first call to Dispose
            if (Interlocked.Increment(ref m_IntCleanedUp) != 1) {
                return;
            }

            if (disposing) {
                //no managed objects to cleanup
            }

            AutoResetEvent asyncEvent = m_AsyncEvent;

            //
            // need to free socket handle and event select handle
            //
            if (m_Handle!=SocketErrors.InvalidSocketIntPtr) {
                //
                // if the Socket is in non-blocking mode we might get a WSAEWOULDBLOCK failure.
                // to prevent that just put it back in blocking mode, since if the app is
                // calling close it probably really wants to close and it doesn't matter if it blocks.
                //
                InternalSetBlocking(true);

                int errorCode =
                    UnsafeNclNativeMethods.OSSOCK.closesocket(
                        m_Handle);

#if CALEB
Interlocked.Decrement(ref counter);
Console.WriteLine("closesocket socket(handle#" + m_Handle.ToString() + ") opened:" + counter.ToString() + " returned:" + errorCode.ToString());
#endif

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Close() closesocket returned errorCode:" + errorCode.ToString());

                //
                // disregard any kind of failures at this point.
                //
                m_Handle = SocketErrors.InvalidSocketIntPtr;

                SetToDisconnected();
            }

            // 
            // Finally set Event, in case someone is still waiting on the event to fire
            //
            if (asyncEvent!=null) {
                if (disposing) {
                    try {
                        asyncEvent.Set();
                    }
                    catch {
                    }
                }
                m_AsyncEvent=null;
            }
        }
        
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Finalize"]/*' />
        ~Socket() {
            Dispose(false);
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Shutdown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disables sends and receives on a socket.
        ///    </para>
        /// </devdoc>
        public void Shutdown(SocketShutdown how) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Shutdown() how:" + how.ToString());

            if (m_Handle==SocketErrors.InvalidSocketIntPtr) {
                //
                // oh well, we really can't do a lot here
                //
                return;
            }

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.shutdown(
                    m_Handle,
                    (int)how);

            //
            // if the native call fails we'll throw a SocketException
            //
            errorCode = errorCode!=SocketErrors.SocketError ? 0 : Marshal.GetLastWin32Error();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Close() shutdown returned errorCode:" + errorCode.ToString());

            //
            // skip good cases: success, socket already closed
            //
            if (errorCode!=SocketErrors.Success && errorCode!=SocketErrors.WSAENOTSOCK) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(errorCode);
            }

            SetToDisconnected();
        }

        // this version does not throw.
        internal void InternalShutdown(SocketShutdown how) {
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::InternalShutdown() how:" + how.ToString());
            if (CleanedUp || m_Handle==SocketErrors.InvalidSocketIntPtr) {
                return;
            }
            UnsafeNclNativeMethods.OSSOCK.shutdown(m_Handle, (int)how);
        }


        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Listen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Places a socket in a listening state.
        ///    </para>
        /// </devdoc>
        public void Listen(int backlog) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Listen() backlog:" + backlog.ToString());

            // No access permissions are necessary here because
            // the verification is done for Bind

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.listen(
                    m_Handle,
                    backlog);

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Accept"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='Sockets.Socket'/> instance to m_Handle an incoming
        ///       connection.
        ///    </para>
        /// </devdoc>
        public Socket Accept() {

            //
            // parameter validation
            //

            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            if (m_RightEndPoint==null) {
                throw new InvalidOperationException(SR.GetString(SR.net_sockets_mustbind));
            }

            ValidateBlockingMode();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Accept()");

            SocketAddress socketAddress = m_RightEndPoint.Serialize();

            IntPtr acceptedSocketHandle =
                UnsafeNclNativeMethods.OSSOCK.accept(
                    m_Handle,
                    socketAddress.m_Buffer,
                    ref socketAddress.m_Size );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (acceptedSocketHandle==SocketErrors.InvalidSocketIntPtr) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            Socket socket = CreateAcceptSocket(acceptedSocketHandle, m_RightEndPoint.Create(socketAddress));

            return socket;
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Send"]/*' />
        /// <devdoc>
        ///    <para>Sends a data buffer to a connected socket.</para>
        /// </devdoc>
        public int Send(byte[] buffer, int size, SocketFlags socketFlags) {
            return Send(buffer, 0, size, socketFlags);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Send1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Send(byte[] buffer, SocketFlags socketFlags) {
            return Send(buffer, 0, buffer!=null ? buffer.Length : 0, socketFlags);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Send2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Send(byte[] buffer) {
            return Send(buffer, 0, buffer!=null ? buffer.Length : 0, SocketFlags.None);
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Send3"]/*' />
        /// <devdoc>
        ///    <para>Sends data to
        ///       a connected socket, starting at the indicated location in the
        ///       data.</para>
        /// </devdoc>
        public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            ValidateBlockingMode();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this)
                            + " [SRC="+ValidationHelper.ToString(LocalEndPoint as IPEndPoint)
                            + " DST="+ValidationHelper.ToString(RemoteEndPoint as IPEndPoint)
                            + "]::Send() size:" + size.ToString());

            GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            IntPtr pinnedBuffer = Marshal.UnsafeAddrOfPinnedArrayElement(buffer, offset);

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.send(
                    m_Handle,
                    pinnedBuffer,
                    size,
                    socketFlags);

#if COMNET_PERFLOGGING
long timer = 0;
Microsoft.Win32.SafeNativeMethods.QueryPerformanceCounter(out timer);
Console.WriteLine(timer + ", Socket#" + this.m_Handle + "::send() returns:" + errorCode);
#endif // #if COMNET_PERFLOGGING

            gcHandle.Free();

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            if (errorCode>0) {
                NetworkingPerfCounters.AddBytesSent(errorCode);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsSent();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Send() UnsafeNclNativeMethods.OSSOCK.send returns:" + errorCode.ToString());

            return errorCode;
        }


        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SendTo"]/*' />
        /// <devdoc>
        ///    <para>Sends data to a specific end point, starting at the indicated location in the
        ///       data.</para>
        /// </devdoc>
        public int SendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            ValidateBlockingMode();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::SendTo() size:" + size.ToString() + " remoteEP:" + remoteEP.ToString());

            //
            // ask the EndPoint to generate a SocketAddress that we
            // can pass down to winsock
            //
            EndPoint endPointSnapshot = remoteEP;
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                endPointSnapshot = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);
            }
            SocketAddress socketAddress = endPointSnapshot.Serialize();

            //That will check ConnectPermission for remoteEP
            CheckCacheRemote(socketAddress, endPointSnapshot, false);

            GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            IntPtr pinnedBuffer = Marshal.UnsafeAddrOfPinnedArrayElement(buffer, offset);

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.sendto(
                    m_Handle,
                    pinnedBuffer,
                    size,
                    socketFlags,
                    socketAddress.m_Buffer,
                    socketAddress.m_Size );

            gcHandle.Free();

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            if (m_RightEndPoint==null) {
                //
                // save a copy of the EndPoint so we can use it for Create()
                //
                m_RightEndPoint = endPointSnapshot;
            }

            if (errorCode>0) {
                NetworkingPerfCounters.AddBytesSent(errorCode);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsSent();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::SendTo() returning errorCode:" + errorCode.ToString());

            return errorCode;
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SendTo1"]/*' />
        /// <devdoc>
        ///    <para>Sends data to a specific end point, starting at the indicated location in the data.</para>
        /// </devdoc>
        public int SendTo(byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP) {
            return SendTo(buffer, 0, size, socketFlags, remoteEP);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SendTo2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP) {
            return SendTo(buffer, 0, buffer!=null ? buffer.Length : 0, socketFlags, remoteEP);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SendTo3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int SendTo(byte[] buffer, EndPoint remoteEP) {
            return SendTo(buffer, 0, buffer!=null ? buffer.Length : 0, SocketFlags.None, remoteEP);
        }


        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Receive"]/*' />
        /// <devdoc>
        ///    <para>Receives data from a connected socket.</para>
        /// </devdoc>
        public int Receive(byte[] buffer, int size, SocketFlags socketFlags) {
            return Receive(buffer, 0, size, socketFlags);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Receive1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Receive(byte[] buffer, SocketFlags socketFlags) {
            return Receive(buffer, 0, buffer!=null ? buffer.Length : 0, socketFlags);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Receive2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Receive(byte[] buffer) {
            return Receive(buffer, 0, buffer!=null ? buffer.Length : 0, SocketFlags.None);
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Receive3"]/*' />
        /// <devdoc>
        ///    <para>Receives data from a connected socket into a specific location of the receive
        ///       buffer.</para>
        /// </devdoc>
        public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            ValidateBlockingMode();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::Receive() size:" + size.ToString());

            GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            IntPtr pinnedBuffer = Marshal.UnsafeAddrOfPinnedArrayElement(buffer, offset);

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.recv(
                    m_Handle,
                    pinnedBuffer,
                    size,
                    socketFlags);

#if COMNET_PERFLOGGING
long timer = 0;
Microsoft.Win32.SafeNativeMethods.QueryPerformanceCounter(out timer);
Console.WriteLine(timer + ", Socket#" + this.m_Handle + "::recv() returns:" + errorCode);
#endif // #if COMNET_PERFLOGGING

            gcHandle.Free();

            //
            // if the native call fails we'll throw a SocketException
            //
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this)
                            + " [SRC="+ValidationHelper.ToString(LocalEndPoint as IPEndPoint)
                            + " DST="+ValidationHelper.ToString(RemoteEndPoint as IPEndPoint)
                            + "]::Receive() UnsafeNclNativeMethods.OSSOCK.recv returns " + errorCode.ToString());

            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            bool peek = ((int)socketFlags & (int)SocketFlags.Peek)!=0;

            if (errorCode>0 && !peek) {
                NetworkingPerfCounters.AddBytesReceived(errorCode);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsReceived();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this)
                            + " [SRC="+ValidationHelper.ToString(LocalEndPoint as IPEndPoint)
                            + " DST="+ValidationHelper.ToString(RemoteEndPoint as IPEndPoint)
                            + "]::Receive() returns " + errorCode.ToString());

            return errorCode;
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.ReceiveFrom"]/*' />
        /// <devdoc>
        ///    <para>Receives a datagram into a specific location in the data buffer and stores
        ///       the end point.</para>
        /// </devdoc>
        public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            ValidateBlockingMode();

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::ReceiveFrom() remoteEP:" + remoteEP.ToString());

            EndPoint endPointSnapshot = remoteEP;
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                endPointSnapshot = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);
            }
            SocketAddress socketAddressOriginal = endPointSnapshot.Serialize();
            SocketAddress socketAddress = endPointSnapshot.Serialize();

            // This will check the permissions for connect.
            // We need this because remoteEP may differ from one used in Connect or
            // there was no Connect called.
            CheckCacheRemote(socketAddress, endPointSnapshot, false);

            GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            IntPtr pinnedBuffer = Marshal.UnsafeAddrOfPinnedArrayElement(buffer, offset);

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.recvfrom(
                    m_Handle,
                    pinnedBuffer,
                    size,
                    socketFlags,
                    socketAddress.m_Buffer,
                    ref socketAddress.m_Size );

            gcHandle.Free();

            if (!socketAddressOriginal.Equals(socketAddress)) {
                try {
                    remoteEP = endPointSnapshot.Create(socketAddress);
                }
                catch {
                }
                if (m_RightEndPoint==null) {
                    //
                    // save a copy of the EndPoint so we can use it for Create()
                    //
                    m_RightEndPoint = endPointSnapshot;
                }
            }

            if (errorCode>0) {
                NetworkingPerfCounters.AddBytesReceived(errorCode);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsReceived();
                }
            }

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            return errorCode;
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.ReceiveFrom1"]/*' />
        /// <devdoc>
        ///    <para>Receives a datagram and stores the source end point.</para>
        /// </devdoc>
        public int ReceiveFrom(byte[] buffer, int size, SocketFlags socketFlags, ref EndPoint remoteEP) {
            return ReceiveFrom(buffer, 0, size, socketFlags, ref remoteEP);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.ReceiveFrom2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ReceiveFrom(byte[] buffer, SocketFlags socketFlags, ref EndPoint remoteEP) {
            return ReceiveFrom(buffer, 0, buffer!=null ? buffer.Length : 0, socketFlags, ref remoteEP);
        }
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.ReceiveFrom3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP) {
            return ReceiveFrom(buffer, 0, buffer!=null ? buffer.Length : 0, SocketFlags.None, ref remoteEP);
        }

        // UE
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.IOControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IOControl(int ioControlCode, byte[] optionInValue, byte[] optionOutValue) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (ioControlCode==IoctlSocketConstants.FIONBIO) {
                throw new InvalidOperationException(SR.GetString(SR.net_sockets_useblocking));
            }

            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            int realOptionLength = 0;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSAIoctl(
                    m_Handle,
                    ioControlCode,
                    optionInValue,
                    optionInValue!=null ? optionInValue.Length : 0,
                    optionOutValue,
                    optionOutValue!=null ? optionOutValue.Length : 0,
                    out realOptionLength,
                    IntPtr.Zero,
                    IntPtr.Zero );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            return realOptionLength;
        }

        private void CheckSetOptionPermissions(SocketOptionLevel optionLevel, SocketOptionName optionName) {
            // freely allow only those below
            if (  !(optionLevel == SocketOptionLevel.Tcp &&
                  (optionName == SocketOptionName.NoDelay   ||
                   optionName == SocketOptionName.BsdUrgent ||
                   optionName == SocketOptionName.Expedited))
                  &&
                  !(optionLevel == SocketOptionLevel.Udp &&
                    (optionName == SocketOptionName.NoChecksum||
                     optionName == SocketOptionName.ChecksumCoverage))
                  &&
                  !(optionLevel == SocketOptionLevel.Socket &&
                  (optionName == SocketOptionName.KeepAlive     ||
                   optionName == SocketOptionName.Linger        ||
                   optionName == SocketOptionName.DontLinger    ||
                   optionName == SocketOptionName.SendBuffer    ||
                   optionName == SocketOptionName.ReceiveBuffer ||
                   optionName == SocketOptionName.SendTimeout   ||
                   optionName == SocketOptionName.ReceiveTimeout))) {

                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SetSocketOption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the specified option to the specified value.
        ///    </para>
        /// </devdoc>
        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            CheckSetOptionPermissions(optionLevel, optionName);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::SetSocketOption(): optionLevel:" + optionLevel.ToString() + " optionName:" + optionName.ToString() + " optionValue:" + optionValue.ToString());

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.setsockopt(
                    m_Handle,
                    optionLevel,
                    optionName,
                    ref optionValue,
                    Marshal.SizeOf(optionValue));

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SetSocketOption1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            CheckSetOptionPermissions(optionLevel, optionName);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::SetSocketOption(): optionLevel:" + optionLevel.ToString() + " optionName:" + optionName.ToString() + " optionValue:" + optionValue.ToString());

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.setsockopt(
                    m_Handle,
                    optionLevel,
                    optionName,
                    optionValue,
                    optionValue!=null ? optionValue.Length : 0 );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.SetSocketOption2"]/*' />
        /// <devdoc>
        ///    <para>Sets the specified option to the specified value.</para>
        /// </devdoc>
        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Object optionValue) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (optionValue==null) {
                throw new ArgumentNullException("optionValue");
            }

            CheckSetOptionPermissions(optionLevel, optionName);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::SetSocketOption(): optionLevel:" + optionLevel.ToString() + " optionName:" + optionName.ToString() + " optionValue:" + optionValue.ToString());

            if (optionLevel==SocketOptionLevel.Socket && optionName==SocketOptionName.Linger) {
                LingerOption lingerOption = optionValue as LingerOption;
                if (lingerOption==null) {
                    throw new ArgumentException("optionValue");
                }
                if (lingerOption.LingerTime < 0 || lingerOption.LingerTime>(int)UInt16.MaxValue) {
                    throw new ArgumentException("optionValue.LingerTime");
                }
                setLingerOption(lingerOption);
            }
            else if (optionLevel==SocketOptionLevel.IP && (optionName==SocketOptionName.AddMembership || optionName==SocketOptionName.DropMembership)) {
                MulticastOption multicastOption = optionValue as MulticastOption;
                if (multicastOption==null) {
                    throw new ArgumentException("optionValue");
                }
                setMulticastOption(optionName, multicastOption);
            }
            //
            // IPv6 Changes: Handle IPv6 Multicast Add / Drop
            //
            else if (optionLevel==SocketOptionLevel.IPv6 && (optionName==SocketOptionName.AddMembership || optionName==SocketOptionName.DropMembership)) {
                IPv6MulticastOption multicastOption = optionValue as IPv6MulticastOption;
                if (multicastOption==null) {
                    throw new ArgumentException("optionValue");
                }
                setIPv6MulticastOption(optionName, multicastOption);
            }
            else {
                throw new ArgumentException("optionValue");
            }
        }

        private void setMulticastOption(SocketOptionName optionName, MulticastOption MR) {
            IPMulticastRequest ipmr = new IPMulticastRequest();

            ipmr.MulticastAddress = unchecked((int)MR.Group.m_Address);
            ipmr.InterfaceAddress = unchecked((int)MR.LocalAddress.m_Address);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::setMulticastOption(): optionName:" + optionName.ToString() + " MR:" + MR.ToString() + " ipmr:" + ipmr.ToString() + " IPMulticastRequest.Size:" + IPMulticastRequest.Size.ToString());

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.setsockopt(
                    m_Handle,
                    SocketOptionLevel.IP,
                    optionName,
                    ref ipmr,
                    IPMulticastRequest.Size );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        /// <devdoc>
        ///     <para>
        ///         IPv6 setsockopt for JOIN / LEAVE multicast group
        ///     </para>
        /// </devdoc>
        private void setIPv6MulticastOption(SocketOptionName optionName, IPv6MulticastOption MR) {
            IPv6MulticastRequest ipmr = new IPv6MulticastRequest();

            ipmr.MulticastAddress = MR.Group.GetAddressBytes();
            ipmr.InterfaceIndex   = unchecked((int)MR.InterfaceIndex);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::setIPv6MulticastOption(): optionName:" + optionName.ToString() + " MR:" + MR.ToString() + " ipmr:" + ipmr.ToString() + " IPv6MulticastRequest.Size:" + IPv6MulticastRequest.Size.ToString());

            int errorCode = UnsafeNclNativeMethods.OSSOCK.setsockopt(
                m_Handle,
                SocketOptionLevel.IPv6,
                optionName,
                ref ipmr,
                IPv6MulticastRequest.Size);

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        private void setLingerOption(LingerOption lref) {
            Linger lngopt = new Linger();
            lngopt.OnOff = lref.Enabled ? (short)1 : (short)0;
            lngopt.Time = (short)lref.LingerTime;

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::setLingerOption(): lref:" + lref.ToString());

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.setsockopt(
                    m_Handle,
                    SocketOptionLevel.Socket,
                    SocketOptionName.Linger,
                    ref lngopt,
                    Linger.Size);

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.GetSocketOption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of a socket option.
        ///    </para>
        /// </devdoc>
        // UE
        public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (optionLevel==SocketOptionLevel.Socket && optionName==SocketOptionName.Linger) {
                return getLingerOpt();
            }
            else if (optionLevel==SocketOptionLevel.IP && (optionName==SocketOptionName.AddMembership || optionName==SocketOptionName.DropMembership)) {
                return getMulticastOpt(optionName);
            }
            //
            // Handle IPv6 case
            //
            else if (optionLevel==SocketOptionLevel.IPv6 && (optionName==SocketOptionName.AddMembership || optionName==SocketOptionName.DropMembership)) {
                return getIPv6MulticastOpt(optionName);
            }
            else {
                int optionValue = 0;
                int optionLength = 4;

                int errorCode =
                    UnsafeNclNativeMethods.OSSOCK.getsockopt(
                        m_Handle,
                        optionLevel,
                        optionName,
                        out optionValue,
                        ref optionLength );

                //
                // if the native call fails we'll throw a SocketException
                //
                if (errorCode==SocketErrors.SocketError) {
                    //
                    // update our internal state after this socket error and throw
                    //
                    SocketException socketException = new SocketException();
                    UpdateStatusAfterSocketError();
                    throw socketException;
                }

                return optionValue;
            }
        }

        // UE
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.GetSocketOption1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            int optionLength = optionValue!=null ? optionValue.Length : 0;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.getsockopt(
                    m_Handle,
                    optionLevel,
                    optionName,
                    optionValue,
                    ref optionLength );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }
        }

        // UE
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.GetSocketOption2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            byte[] optionValue = new byte[optionLength];
            int realOptionLength = optionLength;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.getsockopt(
                    m_Handle,
                    optionLevel,
                    optionName,
                    optionValue,
                    ref realOptionLength );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            if (optionLength!=realOptionLength) {
                byte[] newOptionValue = new byte[realOptionLength];
                Buffer.BlockCopy(optionValue, 0, newOptionValue, 0, realOptionLength);
                optionValue = newOptionValue;
            }

            return optionValue;
        }

        private LingerOption getLingerOpt() {
            Linger lngopt = new Linger();
            int optlen = Linger.Size;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.getsockopt(
                    m_Handle,
                    SocketOptionLevel.Socket,
                    SocketOptionName.Linger,
                    out lngopt,
                    ref optlen );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            LingerOption lingerOption = new LingerOption(lngopt.OnOff!=0, (int)lngopt.Time);

            return lingerOption;
        }

        private MulticastOption getMulticastOpt(SocketOptionName optionName) {
            IPMulticastRequest ipmr = new IPMulticastRequest();
            int optlen = IPMulticastRequest.Size;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.getsockopt(
                    m_Handle,
                    SocketOptionLevel.IP,
                    optionName,
                    out ipmr,
                    ref optlen );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            IPAddress multicastAddr = new IPAddress(ipmr.MulticastAddress);
            IPAddress multicastIntr = new IPAddress(ipmr.InterfaceAddress);

            MulticastOption multicastOption = new MulticastOption(multicastAddr, multicastIntr);

            return multicastOption;
        }

        /// <devdoc>
        ///     <para>
        ///         IPv6 getsockopt for JOIN / LEAVE multicast group
        ///     </para>
        /// </devdoc>
        private IPv6MulticastOption getIPv6MulticastOpt(SocketOptionName optionName) {
            IPv6MulticastRequest ipmr = new IPv6MulticastRequest();

            int optlen = IPv6MulticastRequest.Size;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.getsockopt(
                    m_Handle,
                    SocketOptionLevel.IP,
                    optionName,
                    out ipmr,
                    ref optlen );

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            IPv6MulticastOption multicastOption = new IPv6MulticastOption(new IPAddress(ipmr.MulticastAddress),ipmr.InterfaceIndex);

            return multicastOption;
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Available"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the amount of data pending in the network's input buffer that can be
        ///       read from the socket.
        ///    </para>
        /// </devdoc>
        public int Available {
            get {
                if (CleanedUp) {
                    throw new ObjectDisposedException(this.GetType().FullName);
                }

                long argp = 0;

                int errorCode =
                    UnsafeNclNativeMethods.OSSOCK.ioctlsocket(
                        m_Handle,
                        IoctlSocketConstants.FIONREAD,
                        ref argp );

                //
                // if the native call fails we'll throw a SocketException
                //
                if (errorCode==SocketErrors.SocketError) {
                    //
                    // update our internal state after this socket error and throw
                    //
                    SocketException socketException = new SocketException();
                    UpdateStatusAfterSocketError();
                    throw socketException;
                }

                return (int)argp;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Poll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines the status of the socket.
        ///    </para>
        /// </devdoc>
        public bool Poll(int microSeconds, SelectMode mode) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            FileDescriptorSet fileDescriptorSet = new FileDescriptorSet(1);
            fileDescriptorSet.Array[0] = m_Handle;

            TimeValue IOwait = new TimeValue();

            //
            // negative timeout value implies indefinite wait
            //
            if (microSeconds>=0) {
                MicrosecondsToTimeValue(microSeconds, ref IOwait);
            }

            int errorCode;

            switch (mode) {
                case SelectMode.SelectRead:
                    errorCode = (microSeconds>=0)
                            ? UnsafeNclNativeMethods.OSSOCK.select(
                                0,
                                ref fileDescriptorSet,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                ref IOwait)
                            : UnsafeNclNativeMethods.OSSOCK.select(
                                0,
                                ref fileDescriptorSet,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                IntPtr.Zero);
                    break;
                case SelectMode.SelectWrite:
                    errorCode = (microSeconds>=0)
                            ? UnsafeNclNativeMethods.OSSOCK.select(
                                0,
                                IntPtr.Zero,
                                ref fileDescriptorSet,
                                IntPtr.Zero,
                                ref IOwait)
                            : UnsafeNclNativeMethods.OSSOCK.select(
                                0,
                                IntPtr.Zero,
                                ref fileDescriptorSet,
                                IntPtr.Zero,
                                IntPtr.Zero);
                    break;
                case SelectMode.SelectError:
                    errorCode = (microSeconds>=0)
                            ? UnsafeNclNativeMethods.OSSOCK.select(
                                0,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                ref fileDescriptorSet,
                                ref IOwait)
                            : UnsafeNclNativeMethods.OSSOCK.select(
                                0,
                                IntPtr.Zero,
                                IntPtr.Zero,
                                ref fileDescriptorSet,
                                IntPtr.Zero);
                    break;
                default:
                    throw new NotSupportedException(SR.GetString(SR.net_SelectModeNotSupportedException, mode.ToString()));
            };

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error and throw
                //
                SocketException socketException = new SocketException();
                UpdateStatusAfterSocketError();
                throw socketException;
            }

            if (fileDescriptorSet.Count==0) {
                return false;
            }

            //return (fileDescriptorSet.Count!=0);

            return fileDescriptorSet.Array[0]==m_Handle;
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Select"]/*' />
        /// <devdoc>
        ///    <para>Determines the status of a socket.</para>
        /// </devdoc>
        public static void Select(
            IList checkRead,
            IList checkWrite,
            IList checkError,
            int microSeconds) {
            //
            // parameter validation
            //
            if ((checkRead==null || checkRead.Count==0) && (checkWrite==null || checkWrite.Count==0) && (checkError==null || checkError.Count==0)) {
                throw new ArgumentNullException(SR.GetString(SR.net_sockets_empty_select));
            }

            FileDescriptorSet readfileDescriptorSet, writefileDescriptorSet, errfileDescriptorSet;

            readfileDescriptorSet   = SocketListToFileDescriptorSet(checkRead);
            writefileDescriptorSet  = SocketListToFileDescriptorSet(checkWrite);
            errfileDescriptorSet    = SocketListToFileDescriptorSet(checkError);

            TimeValue IOwait = new TimeValue();

            MicrosecondsToTimeValue(microSeconds, ref IOwait);

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.select(
                    0, // ignored value
                    ref readfileDescriptorSet,
                    ref writefileDescriptorSet,
                    ref errfileDescriptorSet,
                    ref IOwait);

            //
            // if the native call fails we'll throw a SocketException
            //
            if (errorCode==SocketErrors.SocketError) {
                throw new SocketException();
            }

            //
            // call SelectFileDescriptor to update the IList instances,
            // and keep count of how many sockets are ready
            //
            int totalReadySockets = 0;

            totalReadySockets += SelectFileDescriptor(checkRead, readfileDescriptorSet);
            totalReadySockets += SelectFileDescriptor(checkWrite, writefileDescriptorSet);
            totalReadySockets += SelectFileDescriptor(checkError, errfileDescriptorSet);
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.LocalEndPoint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the local end point.
        ///    </para>
        /// </devdoc>
        public EndPoint LocalEndPoint {
            get {
                if (CleanedUp) {
                    throw new ObjectDisposedException(this.GetType().FullName);
                }

                if (m_LocalEndPoint==null) {
                    if (m_RightEndPoint==null) {
                        return null;
                    }

                    SocketAddress socketAddress = m_RightEndPoint.Serialize();

                    int errorCode =
                        UnsafeNclNativeMethods.OSSOCK.getsockname(
                            m_Handle,
                            socketAddress.m_Buffer,
                            ref socketAddress.m_Size);

                    if (errorCode!=SocketErrors.Success) {
                        //
                        // update our internal state after this socket error and throw
                        //
                        SocketException socketException = new SocketException();
                        UpdateStatusAfterSocketError();
                        throw socketException;
                    }

                    try {
                        m_LocalEndPoint = m_RightEndPoint.Create(socketAddress);
                    }
                    catch {
                    }
                }

                return m_LocalEndPoint;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.RemoteEndPoint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the remote end point
        ///    </para>
        /// </devdoc>
        public EndPoint RemoteEndPoint {
            get {
                if (CleanedUp) {
                    throw new ObjectDisposedException(this.GetType().FullName);
                }

                if (m_RemoteEndPoint==null) {
                    if (m_RightEndPoint==null) {
                        return null;
                    }

                    SocketAddress socketAddress = m_RightEndPoint.Serialize();

                    int errorCode =
                        UnsafeNclNativeMethods.OSSOCK.getpeername(
                            m_Handle,
                            socketAddress.m_Buffer,
                            ref socketAddress.m_Size);

                    if (errorCode!=SocketErrors.Success) {
                        //
                        // update our internal state after this socket error and throw
                        //
                        SocketException socketException = new SocketException();
                        UpdateStatusAfterSocketError();
                        throw socketException;
                    }

                    try {
                        m_RemoteEndPoint = m_RightEndPoint.Create(socketAddress);
                    }
                    catch {
                    }
                }

                return m_RemoteEndPoint;
            }
        }

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Handle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the operating system m_Handle for the socket.
        ///    </para>
        /// </devdoc>
        public IntPtr Handle {
            get {
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
                return m_Handle;
            }
        }


        // Non-blocking I/O control
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.Blocking"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets and sets the blocking mode of a socket.
        ///    </para>
        /// </devdoc>
        public bool Blocking {
            get {
                //
                // return the user's desired blocking behaviour (not the actual win32 state)
                //
                return willBlock;
            }
            set {
                if (CleanedUp) {
                    throw new ObjectDisposedException(this.GetType().FullName);
                }

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::set_Blocking() value:" + value.ToString() + " willBlock:" + willBlock.ToString() + " willBlockInternal:" + willBlockInternal.ToString());

                bool current;

                int errorCode = InternalSetBlocking(value, out current);

                if (errorCode!=SocketErrors.Success) {
                    //
                    // update our internal state after this socket error and throw
                    //
                    UpdateStatusAfterSocketError();
                    throw new SocketException(errorCode);
                }

                //
                // win32 call succeeded, update desired state
                //
                willBlock = current;
            }
        }

        //
        // this version will ignore failures but it returns the win32
        // error code, and it will update internal state on success.
        //
        internal int InternalSetBlocking(bool desired, out bool current) {
            GlobalLog.Enter("Socket#" + ValidationHelper.HashString(this) + "::InternalSetBlocking", "desired:" + desired.ToString() + " willBlock:" + willBlock.ToString() + " willBlockInternal:" + willBlockInternal.ToString());

            if (CleanedUp) {
                GlobalLog.Leave("Socket#" + ValidationHelper.HashString(this) + "::InternalSetBlocking", "ObjectDisposed");
                current = willBlock;
                return SocketErrors.Success;
            }

            long intBlocking = desired ? 0 : -1;

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.ioctlsocket(
                    m_Handle,
                    IoctlSocketConstants.FIONBIO,
                    ref intBlocking);

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::InternalSetBlocking() ioctlsocket() returned errorCode:" + errorCode.ToString());

            //
            // we will update only internal state but only on successfull win32 call
            // so if the native call fails, the state will remain the same.
            //
            if (errorCode==SocketErrors.Success) {
                //
                // success, update internal state
                //
                willBlockInternal = intBlocking==0;
            }

            GlobalLog.Leave("Socket#" + ValidationHelper.HashString(this) + "::InternalSetBlocking", "errorCode:" + errorCode.ToString() + " willBlock:" + willBlock.ToString() + " willBlockInternal:" + willBlockInternal.ToString());

            current = willBlockInternal;
            return errorCode;
        }
        //
        // this version will ignore all failures.
        //
        internal void InternalSetBlocking(bool desired) {
            bool current;
            InternalSetBlocking(desired, out current);
        }


        internal TransportType Transport {
            get {
                return
                    protocolType==Sockets.ProtocolType.Tcp ?
                        TransportType.Tcp :
                        protocolType==Sockets.ProtocolType.Udp ?
                            TransportType.Udp :
                            TransportType.All;
            }
        }

        private static FileDescriptorSet SocketListToFileDescriptorSet(IList socketList) {
            if (socketList==null || socketList.Count==0) {
                return FileDescriptorSet.Empty;
            }
            if (socketList.Count>FileDescriptorSet.Size) {
                throw new ArgumentOutOfRangeException("socketList.Count");
            }

            FileDescriptorSet fileDescriptorSet = new FileDescriptorSet(socketList.Count);

            for (int current = 0; current < fileDescriptorSet.Count; current++) {
                if (!(socketList[current] is Socket)) {
                    throw new ArgumentException(SR.GetString(SR.net_sockets_select, socketList[current].GetType().FullName, typeof(System.Net.Sockets.Socket).FullName));
                }

                fileDescriptorSet.Array[current] = ((Socket)socketList[current]).m_Handle;
            }

            return fileDescriptorSet;
        }

        /*
         * This function servers to isolate the Select/Poll functionality
         * from the representation used by the FileDescriptorSet structure by converting
         * into a flat array of integers.
         * Assumption: the descriptors in the set are always placed as a contigious
         *             block at the beginning of the file descriptor array.
         */
        private static IntPtr[] FileDescriptorSetToFileDescriptorArray(FileDescriptorSet fileDescriptorSet) {
            if (fileDescriptorSet.Count==0) {
                return null;
            }

            IntPtr[] fileDescriptorArray = new IntPtr[fileDescriptorSet.Count];

            for (int current = 0; current < fileDescriptorSet.Count; current++) {
                fileDescriptorArray[current] = fileDescriptorSet.Array[current];
            }

            return fileDescriptorArray;
        }

        //
        // Transform the list socketList such that the only sockets left are those
        // with a file descriptor contained in the array "fileDescriptorArray"
        //
        private static int SelectFileDescriptor(IList socketList, FileDescriptorSet fileDescriptorSet) {
            //
            // Walk the list in order
            // Note that the counter is not necessarily incremented at each step;
            // when the socket is removed, advancing occurs automatically as the
            // other elements are shifted down.
            //
            Socket socket;
            int currentSocket, currentFileDescriptor;

            if (socketList==null) {
                return 0;
            }

            if (fileDescriptorSet.Count==0) {
                //
                // no socket present, will never find it, remove all sockets
                //
                socketList.Clear();
            }

            if (socketList.Count==0) {
                //
                // list is already empty
                //
                return 0;
            }

            lock (socketList) {

                for (currentSocket = 0; currentSocket < socketList.Count; currentSocket++) {
                    //
                    // parameter validation: only Socket should be here
                    //
                    if (!(socketList[currentSocket] is Socket)) {
                        throw new ArgumentException("socketList");
                    }

                    socket = (Socket)socketList[currentSocket];

                    //
                    // Look for the file descriptor in the array
                    //
                    for (currentFileDescriptor = 0; currentFileDescriptor < fileDescriptorSet.Count; currentFileDescriptor++) {
                        if (fileDescriptorSet.Array[currentFileDescriptor]==socket.m_Handle) {
                            break;
                        }
                    }

                    if (currentFileDescriptor==fileDescriptorSet.Count) {
                        //
                        // descriptor not found: remove the current socket and start again
                        //
                        socketList.RemoveAt(currentSocket--);
                    }
                }
            }

            return socketList.Count;
        }

        private const int microcnv = 1000000;

        private static void MicrosecondsToTimeValue(long microSeconds, ref TimeValue socketTime) {
            socketTime.Seconds   = (int) (microSeconds / microcnv);
            socketTime.Microseconds  = (int) (microSeconds % microcnv);
        }

        //
        // Async Winsock Support, the following functions use either
        //   the Async Winsock support to do overlapped I/O WSASend/WSARecv
        //   or a WSAEventSelect call to enable selection and non-blocking mode
        //   of otherwise normal Winsock calls.
        //
        //   Currently the following Async Socket calls are supported:
        //      Send, Recv, SendTo, RecvFrom, Connect, Accept
        //

        /*++

        Routine Description:

           BeginConnect - Does a async winsock connect, by calling
           WSAEventSelect to enable Connect Events to signal an event and
           wake up a callback which involkes a callback.

            So note: This routine may go pending at which time,
            but any case the callback Delegate will be called upon completion

        Arguments:

           remoteEP - status line that we wish to parse
           Callback - Async Callback Delegate that is called upon Async Completion
           State - State used to track callback, set by caller, not required

        Return Value:

           IAsyncResult - Async result used to retreive result

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.BeginConnect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, Object state) {
            
            EndPoint oldEndPoint = m_RightEndPoint;
            
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginConnect() remoteEP:" + remoteEP.ToString());

            //
            // ask the EndPoint to generate a SocketAddress that we
            // can pass down to winsock
            //
            EndPoint endPointSnapshot = remoteEP;
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                endPointSnapshot = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);
            }
            
            SocketAddress socketAddress = endPointSnapshot.Serialize();

            // This will check the permissions for connect.
            CheckCacheRemote(socketAddress, endPointSnapshot, true);

            // get async going
            SetAsyncEventSelect(AsyncEventBits.FdConnect);

            ConnectAsyncResult asyncResult = new ConnectAsyncResult(this, state, callback);

            //we should fix this in Whidbey.
            if (m_RightEndPoint == null) {
                  m_RightEndPoint = endPointSnapshot;
            }
 
            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.connect(
                    m_Handle,
                    socketAddress.m_Buffer,
                    socketAddress.m_Size );

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginConnect() UnsafeNclNativeMethods.OSSOCK.connect returns:" + errorCode.ToString());

            if (errorCode==SocketErrors.Success) {
                SetToConnected();
            }
 
            asyncResult.CheckAsyncCallResult(errorCode);

            //
            // if the asynchronous native call fails synchronously
            // we'll throw a SocketException
            //
            if (asyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                m_RightEndPoint = oldEndPoint;
                UpdateStatusAfterSocketError();
                throw new SocketException(asyncResult.ErrorCode);
            }

             GlobalLog.Print( "BeginConnect() to:" + endPointSnapshot.ToString() + " returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            return asyncResult;
        }

        /*++

        Routine Description:

           EndConnect - Called addressFamilyter receiving callback from BeginConnect,
            in order to retrive the result of async call

        Arguments:

           AsyncResult - the AsyncResult Returned fron BeginConnect call

        Return Value:

           int - Return code from aync Connect, 0 for success, SocketErrors.WSAENOTCONN otherwise

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.EndConnect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EndConnect(IAsyncResult asyncResult) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            ConnectAsyncResult castedAsyncResult = asyncResult as ConnectAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndConnect"));
            }

            castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::EndConnect() asyncResult:" + ValidationHelper.HashString(asyncResult));

            if (castedAsyncResult.Result is Exception) {
                throw (Exception)castedAsyncResult.Result;
            }
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }
        }


        /*++

        Routine Description:

           BeginSend - Async implimentation of Send call, mirrored addressFamilyter BeginReceive
           This routine may go pending at which time,
           but any case the callback Delegate will be called upon completion

        Arguments:

           WriteBuffer - status line that we wish to parse
           Index - Offset into WriteBuffer to begin sending from
           Size - Size of Buffer to transmit
           Callback - Delegate function that holds callback, called on completeion of I/O
           State - State used to track callback, set by caller, not required

        Return Value:

           IAsyncResult - Async result used to retreive result

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.BeginSend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, Object state) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this)
                            + " [SRC="+ValidationHelper.ToString(LocalEndPoint as IPEndPoint)
                            + " DST="+ValidationHelper.ToString(RemoteEndPoint as IPEndPoint)
                            + "]::BeginSend() size:" + size.ToString());

            //
            // Allocate the async result and the event we'll pass to the
            // thread pool.
            //
            OverlappedAsyncResult asyncResult =
                new OverlappedAsyncResult(
                    this,
                    state,
                    callback );

            //
            // Set up asyncResult for overlapped WSASend.
            // This call will use
            // completion ports on WinNT and Overlapped IO on Win9x.
            //

            asyncResult.SetUnmanagedStructures(
                                          buffer,
                                          offset,
                                          size,
                                          socketFlags,
                                          null,
                                          false // don't pin null remoteEP
                                          );

            //
            // Get the Send going.
            //

            GlobalLog.Print("BeginSend: asyncResult:" + ValidationHelper.HashString(asyncResult) + " size:" + size.ToString());

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSASend(
                    m_Handle,
                    ref asyncResult.m_WSABuffer,
                    1, // only ever 1 buffer being sent
                    OverlappedAsyncResult.m_BytesTransferred,
                    asyncResult.m_Flags,
                    asyncResult.IntOverlapped,
                    IntPtr.Zero );

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }

#if COMNET_PERFLOGGING
long timer = 0;
Microsoft.Win32.SafeNativeMethods.QueryPerformanceCounter(out timer);
Console.WriteLine(timer + ", Socket#" + this.m_Handle + "::WSASend(" + asyncResult.GetHashCode() + " 0x" + ((long)asyncResult.IntOverlapped).ToString("X8") + ") returns:" + errorCode);
#endif // #if COMNET_PERFLOGGING

            asyncResult.CheckAsyncCallOverlappedResult(errorCode);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginSend() UnsafeNclNativeMethods.OSSOCK.WSASend returns:" + errorCode.ToString() + " size:" + size.ToString() + " returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            //
            // if the asynchronous native call fails synchronously
            // we'll throw a SocketException
            //
            if (asyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(asyncResult.ErrorCode);
            }

            return asyncResult;
        }

        internal void MultipleSend(
            BufferOffsetSize[] buffers,
            SocketFlags socketFlags
            ) {
            //
            // parameter validation
            //
            GlobalLog.Assert(buffers!=null, "Socket:BeginMultipleSend(): buffers==null", "");

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginMultipleSend() buffers.Length:" + buffers.Length.ToString());

            //
            // Allocate the async result that will hold our unmanaged ptrs.
            //
            OverlappedAsyncResult asyncResult =
                new OverlappedAsyncResult(
                    this );

            asyncResult.UsingMultipleSend = true;

            asyncResult.SetUnmanagedStructures(
                                          buffers,
                                          socketFlags);

            //
            // Get the Send going.
            //
            
            try {
                int errorCode =
                    UnsafeNclNativeMethods.OSSOCK.WSASend(
                        m_Handle,
                        asyncResult.m_WSABuffers,
                        asyncResult.m_WSABuffers.Length,
                        OverlappedAsyncResult.m_BytesTransferred,
                        asyncResult.m_Flags,
                        IntPtr.Zero,
                        IntPtr.Zero );

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginMultipleSend() UnsafeNclNativeMethods.OSSOCK.WSASend returns:" + errorCode.ToString() + " size:" + buffers.Length.ToString());

                if (errorCode!=SocketErrors.Success) {
                    errorCode = Marshal.GetLastWin32Error();
                    UpdateStatusAfterSocketError();
                    throw new SocketException(errorCode);
                }
            } finally {
                asyncResult.ReleaseUnmanagedStructures();
            }
            
        }


        internal IAsyncResult BeginMultipleSend(
            BufferOffsetSize[] buffers,
            SocketFlags socketFlags,
            AsyncCallback callback,
            Object state) {
            //
            // parameter validation
            //
            GlobalLog.Assert(buffers!=null, "Socket:BeginMultipleSend(): buffers==null", "");

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginMultipleSend() buffers.Length:" + buffers.Length.ToString());

            //
            // Allocate the async result and the event we'll pass to the
            // thread pool.
            //
            OverlappedAsyncResult asyncResult =
                new OverlappedAsyncResult(
                    this,
                    state,
                    callback );

            asyncResult.UsingMultipleSend = true;

            //
            // Set up asyncResult for overlapped WSASend.
            // This call will use
            // completion ports on WinNT and Overlapped IO on Win9x.
            //
            asyncResult.SetUnmanagedStructures(
                                          buffers,
                                          socketFlags);

            //
            // Get the Send going.
            //
            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSASend(
                    m_Handle,
                    asyncResult.m_WSABuffers,
                    asyncResult.m_WSABuffers.Length,
                    OverlappedAsyncResult.m_BytesTransferred,
                    asyncResult.m_Flags,
                    asyncResult.IntOverlapped,
                    IntPtr.Zero );

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }

            asyncResult.CheckAsyncCallOverlappedResult(errorCode);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginMultipleSend() UnsafeNclNativeMethods.OSSOCK.WSASend returns:" + errorCode.ToString() + " size:" + buffers.Length.ToString() + " returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            //
            // if the asynchronous native call fails synchronously
            // we'll throw a SocketException
            //
            if (asyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(asyncResult.ErrorCode);
            }

            return asyncResult;
        }

        /*++

        Routine Description:

           EndSend -  Called by user code addressFamilyter I/O is done or the user wants to wait.
                        until Async completion, needed to retrieve error result from call

        Arguments:

           AsyncResult - the AsyncResult Returned fron BeginSend call

        Return Value:

           int - Number of bytes transferred

        --*/
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.EndSend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int EndSend(IAsyncResult asyncResult) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            OverlappedAsyncResult castedAsyncResult = asyncResult as OverlappedAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndSend"));
            }

            int bytesTransferred = (int)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            if (bytesTransferred>0) {
                NetworkingPerfCounters.AddBytesSent(bytesTransferred);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsSent();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::EndSend() bytesTransferred:" + bytesTransferred.ToString());

            //
            // if the asynchronous native call failed asynchronously
            // we'll throw a SocketException
            //
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }

            return bytesTransferred;
        }

        internal int EndMultipleSend(IAsyncResult asyncResult) {
            //
            // parameter validation
            //
            GlobalLog.Assert(asyncResult!=null, "Socket:EndMultipleSend(): asyncResult==null", "");

            OverlappedAsyncResult castedAsyncResult = asyncResult as OverlappedAsyncResult;

            GlobalLog.Assert(castedAsyncResult!=null, "Socket:EndMultipleSend(): castedAsyncResult==null", "");
            GlobalLog.Assert(castedAsyncResult.AsyncObject==this, "Socket:EndMultipleSend(): castedAsyncResult.AsyncObject!=this", "");
            GlobalLog.Assert(!castedAsyncResult.EndCalled, "Socket:EndMultipleSend(): castedAsyncResult.EndCalled", "");

            int bytesTransferred = (int)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            if (bytesTransferred>0) {
                NetworkingPerfCounters.AddBytesSent(bytesTransferred);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsSent();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::EndMultipleSend() bytesTransferred:" + bytesTransferred.ToString());

            //
            // if the asynchronous native call failed asynchronously
            // we'll throw a SocketException
            //
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }

            return bytesTransferred;
        }


        /*++

        Routine Description:

           BeginSendTo - Async implimentation of SendTo,

           This routine may go pending at which time,
           but any case the callback Delegate will be called upon completion

        Arguments:

           WriteBuffer - Buffer to transmit
           Index - Offset into WriteBuffer to begin sending from
           Size - Size of Buffer to transmit
           Flags - Specific Socket flags to pass to winsock
           remoteEP - EndPoint to transmit To
           Callback - Delegate function that holds callback, called on completeion of I/O
           State - State used to track callback, set by caller, not required

        Return Value:

           IAsyncResult - Async result used to retreive result

        --*/
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.BeginSendTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IAsyncResult BeginSendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, Object state) {
            
            EndPoint oldEndPoint = m_RightEndPoint;
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginSendTo() size:" + size.ToString());

            //
            // Allocate the async result and the event we'll pass to the
            // thread pool.
            //
            OverlappedAsyncResult asyncResult =
                new OverlappedAsyncResult(
                    this,
                    state,
                    callback );

            //
            // Set up asyncResult for overlapped WSASendTo.
            // This call will use
            // completion ports on WinNT and Overlapped IO on Win9x.
            //
            EndPoint endPointSnapshot = remoteEP;
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                endPointSnapshot = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);
            }

            asyncResult.SetUnmanagedStructures(
                                          buffer,
                                          offset,
                                          size,
                                          socketFlags,
                                          endPointSnapshot,
                                          false // don't pin RemoteEP
                                          );

            // This will check the permissions for connect.
            CheckCacheRemote(asyncResult.m_SocketAddress, endPointSnapshot, false);

            //
            // Get the SendTo going.
            //
            if (m_RightEndPoint == null) {
                m_RightEndPoint = endPointSnapshot;
            }
            
            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSASendTo(
                    m_Handle,
                    ref asyncResult.m_WSABuffer,
                    1, // only ever 1 buffer being sent
                    OverlappedAsyncResult.m_BytesTransferred,
                    asyncResult.m_Flags,
                    asyncResult.m_SocketAddress.m_Buffer,
                    asyncResult.m_SocketAddress.m_Size,
                    asyncResult.IntOverlapped,
                    IntPtr.Zero );

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }
 
            asyncResult.CheckAsyncCallOverlappedResult(errorCode);

            //
            // if the asynchronous native call fails synchronously
            // we'll throw a SocketException
            //
            if (asyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
				
                m_RightEndPoint = oldEndPoint;
                UpdateStatusAfterSocketError();
                throw new SocketException(asyncResult.ErrorCode);
            }

       
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginSendTo() size:" + size.ToString() + " returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            return asyncResult;
        }

        /*++

        Routine Description:

           EndSendTo -  Called by user code addressFamilyter I/O is done or the user wants to wait.
                        until Async completion, needed to retrieve error result from call

        Arguments:

           AsyncResult - the AsyncResult Returned fron BeginSend call

        Return Value:

           int - Number of bytes transferred

        --*/
        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.EndSendTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int EndSendTo(IAsyncResult asyncResult) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            OverlappedAsyncResult castedAsyncResult = asyncResult as OverlappedAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndSendTo"));
            }

            int bytesTransferred = (int)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            if (bytesTransferred>0) {
                NetworkingPerfCounters.AddBytesSent(bytesTransferred);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsSent();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::EndSendTo() bytesTransferred:" + bytesTransferred.ToString());

            //
            // if the asynchronous native call failed asynchronously
            // we'll throw a SocketException
            //
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }

            return bytesTransferred;
        }


        /*++

        Routine Description:

           BeginReceive - Async implimentation of Recv call,

           Called when we want to start an async receive.
           We kick off the receive, and if it completes synchronously we'll
           call the callback. Otherwise we'll return an IASyncResult, which
           the caller can use to wait on or retrieve the final status, as needed.

           Uses Winsock 2 overlapped I/O.

        Arguments:

           ReadBuffer - status line that we wish to parse
           Index - Offset into ReadBuffer to begin reading from
           Size - Size of Buffer to recv
           Callback - Delegate function that holds callback, called on completeion of I/O
           State - State used to track callback, set by caller, not required

        Return Value:

           IAsyncResult - Async result used to retreive result

        --*/


        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.BeginReceive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, Object state) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginReceive() size:" + size.ToString());

            //
            // Allocate the async result and the event we'll pass to the
            // thread pool.
            //
            OverlappedAsyncResult asyncResult =
                new OverlappedAsyncResult(
                    this,
                    state,
                    callback );

            //
            // Set up asyncResult for overlapped WSARecv.
            // This call will use
            // completion ports on WinNT and Overlapped IO on Win9x.
            //

            asyncResult.SetUnmanagedStructures(
                                          buffer,
                                          offset,
                                          size,
                                          socketFlags,
                                          null,
                                          false // don't pin null RemoteEP
                                          );

            //
            // Get the Receive going.
            //

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSARecv(
                    m_Handle,
                    ref asyncResult.m_WSABuffer,
                    1,
                    OverlappedAsyncResult.m_BytesTransferred,
                    ref asyncResult.m_Flags,
                    asyncResult.IntOverlapped,
                    IntPtr.Zero );

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }

#if COMNET_PERFLOGGING
long timer = 0;
Microsoft.Win32.SafeNativeMethods.QueryPerformanceCounter(out timer);
Console.WriteLine(timer + ", Socket#" + this.m_Handle + "::WSARecv(" + asyncResult.GetHashCode() + " 0x" + ((long)asyncResult.IntOverlapped).ToString("X8") + ") returns:" + errorCode);
#endif // #if COMNET_PERFLOGGING

            asyncResult.CheckAsyncCallOverlappedResult(errorCode);

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginReceive() UnsafeNclNativeMethods.OSSOCK.WSARecv returns:" + errorCode.ToString() + " size:" + size.ToString() + " returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            //
            // if the asynchronous native call fails synchronously
            // we'll throw a SocketException
            //
            if (asyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(asyncResult.ErrorCode);
            }

            return asyncResult;
        }

        /*++

        Routine Description:

           EndReceive -  Called when I/O is done or the user wants to wait. If
                     the I/O isn't done, we'll wait for it to complete, and then we'll return
                     the bytes of I/O done.

        Arguments:

           AsyncResult - the AsyncResult Returned fron BeginSend call

        Return Value:

           int - Number of bytes transferred

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.EndReceive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int EndReceive(IAsyncResult asyncResult) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            OverlappedAsyncResult castedAsyncResult = asyncResult as OverlappedAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndReceive"));
            }

            int bytesTransferred = (int)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            if (bytesTransferred>0) {
                NetworkingPerfCounters.AddBytesReceived(bytesTransferred);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsReceived();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this)
                            + " [SRC="+ValidationHelper.ToString(LocalEndPoint as IPEndPoint)
                            + " DST="+ValidationHelper.ToString(RemoteEndPoint as IPEndPoint)
                            + "]::EndReceive() bytesTransferred:" + bytesTransferred.ToString());


            //
            // if the asynchronous native call failed asynchronously
            // we'll throw a SocketException
            //
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }

            return bytesTransferred;
        }


        /*++

        Routine Description:

           BeginReceiveFrom - Async implimentation of RecvFrom call,

           Called when we want to start an async receive.
           We kick off the receive, and if it completes synchronously we'll
           call the callback. Otherwise we'll return an IASyncResult, which
           the caller can use to wait on or retrieve the final status, as needed.

           Uses Winsock 2 overlapped I/O.

        Arguments:

           ReadBuffer - status line that we wish to parse
           Index - Offset into ReadBuffer to begin reading from
           Request - Size of Buffer to recv
           Flags - Additonal Flags that may be passed to the underlying winsock call
           remoteEP - EndPoint that are to receive from
           Callback - Delegate function that holds callback, called on completeion of I/O
           State - State used to track callback, set by caller, not required

        Return Value:

           IAsyncResult - Async result used to retreive result

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.BeginReceiveFrom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IAsyncResult BeginReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP, AsyncCallback callback, Object state) {

            EndPoint oldEndPoint = m_RightEndPoint;
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (buffer==null) {
                throw new ArgumentNullException("buffer");
            }
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }
            if (offset<0 || offset>buffer.Length) {
                throw new ArgumentOutOfRangeException("offset");
            }
            if (size<0 || size>buffer.Length-offset) {
                throw new ArgumentOutOfRangeException("size");
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginReceiveFrom() size:" + size.ToString());

            //
            // Allocate the async result and the event we'll pass to the
            // thread pool.
            //
            OverlappedAsyncResult asyncResult =
                new OverlappedAsyncResult(
                    this,
                    state,
                    callback );

            //
            // Set up asyncResult for overlapped WSARecvFrom.
            // This call will use
            // completion ports on WinNT and Overlapped IO on Win9x.
            //
            EndPoint endPointSnapshot = remoteEP;
            if (remoteEP.GetType()==typeof(IPEndPoint)) {
                endPointSnapshot = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);
            }
            
            asyncResult.SetUnmanagedStructures(
                                          buffer,
                                          offset,
                                          size,
                                          socketFlags,
                                          endPointSnapshot,
                                          true // pin remoteEP
                                          );

            // save a copy of the original EndPoint in the asyncResult
            asyncResult.m_SocketAddressOriginal = endPointSnapshot.Serialize();

            // This will check the permissions for connect.
            CheckCacheRemote(asyncResult.m_SocketAddress, endPointSnapshot, false);

            if (m_RightEndPoint == null) {
                m_RightEndPoint = endPointSnapshot;
            }

            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSARecvFrom(
                    m_Handle,
                    ref asyncResult.m_WSABuffer,
                    1,
                    OverlappedAsyncResult.m_BytesTransferred,
                    ref asyncResult.m_Flags,
                    asyncResult.m_GCHandleSocketAddress.AddrOfPinnedObject(),
                    asyncResult.m_GCHandleSocketAddressSize.AddrOfPinnedObject(),
                    asyncResult.IntOverlapped,
                    IntPtr.Zero );

            if (errorCode!=SocketErrors.Success) {
                errorCode = Marshal.GetLastWin32Error();
            }

            asyncResult.CheckAsyncCallOverlappedResult(errorCode);

            //
            // if the asynchronous native call fails synchronously
            // we'll throw a SocketException
            //
            if (asyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                m_RightEndPoint = oldEndPoint;
                UpdateStatusAfterSocketError();
                throw new SocketException(asyncResult.ErrorCode);
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginReceiveFrom() size:" + size.ToString() + " returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            return asyncResult;
        }


        /*++

        Routine Description:

           EndReceiveFrom -  Called when I/O is done or the user wants to wait. If
                     the I/O isn't done, we'll wait for it to complete, and then we'll return
                     the bytes of I/O done.

        Arguments:

           AsyncResult - the AsyncResult Returned fron BeginReceiveFrom call

        Return Value:

           int - Number of bytes transferred

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.EndReceiveFrom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int EndReceiveFrom(IAsyncResult asyncResult, ref EndPoint endPoint) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (endPoint==null) {
                throw new ArgumentNullException("endPoint");
            }
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            OverlappedAsyncResult castedAsyncResult = asyncResult as OverlappedAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndReceiveFrom"));
            }

            int bytesTransferred = (int)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            // pick up the saved copy of the original EndPoint from the asyncResult
            if (!castedAsyncResult.m_SocketAddressOriginal.Equals(castedAsyncResult.m_SocketAddress)) {
                try {
                    endPoint = endPoint.Create(castedAsyncResult.m_SocketAddress);
                }
                catch {
                }
            }

            if (bytesTransferred>0) {
                NetworkingPerfCounters.AddBytesReceived(bytesTransferred);
                if (Transport==TransportType.Udp) {
                    NetworkingPerfCounters.IncrementDatagramsReceived();
                }
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::EndReceiveFrom() bytesTransferred:" + bytesTransferred.ToString());

            //
            // if the asynchronous native call failed asynchronously
            // we'll throw a SocketException
            //
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }

            return bytesTransferred;
        }


        /*++

        Routine Description:

           BeginAccept - Does a async winsock accept, creating a new socket on success

            Works by creating a pending accept request the first time,
            and subsequent calls are queued so that when the first accept completes,
            the next accept can be resubmitted in the callback.
            this routine may go pending at which time,
            but any case the callback Delegate will be called upon completion

        Arguments:

           Callback - Async Callback Delegate that is called upon Async Completion
           State - State used to track callback, set by caller, not required

        Return Value:

           IAsyncResult - Async result used to retreive resultant new socket

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.BeginAccept"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IAsyncResult BeginAccept(AsyncCallback callback, object state) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            if (m_RightEndPoint==null) {
                throw new InvalidOperationException(SR.GetString(SR.net_sockets_mustbind));
            }

            //
            // We keep a queue, which lists the set of requests that want to
            //  be called when an accept queue completes.  We call accept
            //  once, and then as it completes asyncrounsly we pull the
            //  requests out of the queue and call their callback.
            //
            // We start by grabbing Critical Section, then attempt to
            //  determine if we haven an empty Queue of Accept Sockets
            //  or if its in a Callback on the Callback thread.
            //
            // If its in the callback thread proocessing of the callback, then we
            //  just need to notify the callback by adding an additional request
            //   to the queue.
            //
            // If its an empty queue, and its not in the callback, then
            //   we just need to get the Accept going, make it go async
            //   and leave.
            //
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginAccept()");

            AcceptAsyncResult asyncResult = new AcceptAsyncResult(this, state, callback);

            Monitor.Enter(this);

            if (AcceptQueue.Count==0 && !incallback) {
                //
                // if the accept queue is empty
                //
                AcceptQueue.Add(asyncResult);

                SocketAddress socketAddress = m_RightEndPoint.Serialize();

                // get async going
                SetAsyncEventSelect(AsyncEventBits.FdAccept);

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginAccept() queue is empty calling UnsafeNclNativeMethods.OSSOCK.accept");

                IntPtr acceptedSocketHandle =
                    UnsafeNclNativeMethods.OSSOCK.accept(
                        m_Handle,
                        socketAddress.m_Buffer,
                        ref socketAddress.m_Size );

                int errorCode = acceptedSocketHandle!=SocketErrors.InvalidSocketIntPtr ? 0 : Marshal.GetLastWin32Error();

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginAccept() UnsafeNclNativeMethods.OSSOCK.accept returns:" + errorCode.ToString());

                if (errorCode==SocketErrors.Success) {
                    asyncResult.Result = CreateAcceptSocket(acceptedSocketHandle, m_RightEndPoint.Create(socketAddress));
                }
                //
                // the following code will call Monitor.Exit(this) as soon as possible
                //
                asyncResult.CheckAsyncCallResult(errorCode);

                //
                // if the asynchronous native call fails synchronously
                // we'll throw a SocketException
                //
                if (asyncResult.ErrorCode!=SocketErrors.Success) {
                    //
                    // update our internal state after this socket error and throw
                    //
                    UpdateStatusAfterSocketError();
                    throw new SocketException(asyncResult.ErrorCode);
                }
            }
            else {
                AcceptQueue.Add(asyncResult);

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginAccept() queue is not empty Count:" + AcceptQueue.Count.ToString());

                Monitor.Exit(this);
            }

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BeginAccept() returning AsyncResult:" + ValidationHelper.HashString(asyncResult));

            return asyncResult;
        }

        /*++

        Routine Description:

           EndAccept -  Called by user code addressFamilyter I/O is done or the user wants to wait.
                        until Async completion, so it provides End handling for aync Accept calls,
                        and retrieves new Socket object

        Arguments:

           AsyncResult - the AsyncResult Returned fron BeginAccept call

        Return Value:

           Socket - a valid socket if successful

        --*/

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.EndAccept"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Socket EndAccept(IAsyncResult asyncResult) {
            if (CleanedUp) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            //
            // parameter validation
            //
            if (asyncResult==null) {
                throw new ArgumentNullException("asyncResult");
            }
            AcceptAsyncResult castedAsyncResult = asyncResult as AcceptAsyncResult;
            if (castedAsyncResult==null || castedAsyncResult.AsyncObject!=this) {
                throw new ArgumentException(SR.GetString(SR.net_io_invalidasyncresult));
            }
            if (castedAsyncResult.EndCalled) {
                throw new InvalidOperationException(SR.GetString(SR.net_io_invalidendcall, "EndAccept"));
            }

            Socket acceptedSocket = (Socket)castedAsyncResult.InternalWaitForCompletion();
            castedAsyncResult.EndCalled = true;

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::EndAccept() acceptedSocket:" + ValidationHelper.HashString(acceptedSocket));

            //
            // if the asynchronous native call failed asynchronously
            // we'll throw a SocketException
            //
            if (castedAsyncResult.Result is Exception) {
                throw (Exception)castedAsyncResult.Result;
            }
            if (castedAsyncResult.ErrorCode!=SocketErrors.Success) {
                //
                // update our internal state after this socket error and throw
                //
                UpdateStatusAfterSocketError();
                throw new SocketException(castedAsyncResult.ErrorCode);
            }

            return acceptedSocket;
        }


        //
        // CreateAcceptSocket - pulls unmanaged results and assembles them
        //   into a new Socket object
        //
        internal Socket CreateAcceptSocket(IntPtr fd, EndPoint remoteEP) {
            //
            // Internal state of the socket is inherited from listener
            //
            Socket socket           = new Socket(fd);
            socket.addressFamily    = addressFamily;
            socket.socketType       = socketType;
            socket.protocolType     = protocolType;
            socket.m_RightEndPoint  = m_RightEndPoint;
            socket.m_RemoteEndPoint = remoteEP;
            //
            // the socket is connected
            //
            socket.SetToConnected();
            //
            // if the socket is returned by an EndAccept(), the socket might have
            // inherited the WSAEventSelect() call from the accepting socket.
            // we need to cancel this otherwise the socket will be in non-blocking
            // mode and we cannot force blocking mode using the ioctlsocket() in
            // Socket.set_Blocking(), since it fails returing 10022 as documented in MSDN.
            // (note that the m_AsyncEvent event will not be created in this case.
            //
            socket.m_BlockEventBits = m_BlockEventBits;
            socket.SetAsyncEventSelect(AsyncEventBits.FdNone);
            //
            // the new socket will inherit the win32 blocking mode from the accepting socket.
            // if the user desired blocking mode is different from the win32 blocking mode
            // we need to force the desired blocking behaviour.
            //
            socket.willBlock = willBlock;
            if (willBlock!=willBlockInternal) {
                socket.InternalSetBlocking(willBlock);
            }

            return socket;
        }

        //
        // SetToConnected - updates the status of the socket to connected
        //
        internal void SetToConnected() {
            if (m_WasConnected) {
                //
                // socket was already connected
                //
                return;
            }
            //
            // update the status: this socket was indeed connected at
            // some point in time update the perf counter as well.
            //
            m_WasConnected = true;
            NetworkingPerfCounters.IncrementConnectionsEstablished();
        }

        //
        // SetToDisconnected - updates the status of the socket to disconnected
        //
        internal void SetToDisconnected() {
            if (m_WasDisconnected) {
                //
                // socket was already disconnected
                //
                return;
            }
            //
            // update the status: this socket was indeed disconnected at
            // some point in time, clear any async select bits.
            //
            m_WasDisconnected = true;

            if (m_Handle!=SocketErrors.InvalidSocketIntPtr) {
                //
                // if socket is still alive cancel WSAEventSelect()
                //
                GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::SetToDisconnected()");

                SetAsyncEventSelect(AsyncEventBits.FdNone);
            }
        }

        //
        // UpdateStatusAfterSocketError - updates the status of a connected socket
        // on which a failure occured. it'll go to winsock and check if the connection
        // is still open and if it needs to update our internal state.
        //
        internal void UpdateStatusAfterSocketError() {
            //
            // if we already know the socket is disconnected
            // we don't need to do anything else.
            //
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::UpdateStatusAfterSocketError()");

            if (m_WasConnected && !m_WasDisconnected) {
                //
                // we need to put the socket in non-blocking mode, so lock it.
                //
                lock (this) {
                    if (m_Handle!=SocketErrors.InvalidSocketIntPtr) {
                        //
                        // save internal blocking state since we might be changing it.
                        //
                        bool savedBlockingState = willBlockInternal;

                        if (savedBlockingState) {
                            //
                            // the socket is in win32 blocking mode, go non blocking
                            //
                            InternalSetBlocking(false);
                        }

                        int errorCode =
                            UnsafeNclNativeMethods.OSSOCK.recv(
                                m_Handle,
                                IntPtr.Zero,
                                0,
                                SocketFlags.Peek);

                        if (errorCode!=SocketErrors.Success) {
                            errorCode = Marshal.GetLastWin32Error();
                        }

                        GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::UpdateStatusAfterSocketError() UnsafeNclNativeMethods.OSSOCK.recv errorCode:" + errorCode.ToString());

                        if (errorCode!=SocketErrors.Success && errorCode!=SocketErrors.WSAEWOULDBLOCK) {
                            //
                            // only clean up if the socket was connected at some point
                            // and it's not anymore. update the status.
                            //
                            SetToDisconnected();
                        }

                        //
                        // cancel blocking mode before returning
                        //
                        if (savedBlockingState) {
                            //
                            // the socket was in win32 blocking mode, go blocking again
                            //
                            InternalSetBlocking(true);
                        }
                    }
                    else {
                        //
                        // the socket is no longer a socket
                        //
                        GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::UpdateStatusAfterSocketError() m_Handle==SocketErrors.InvalidSocketIntPtr");
                        SetToDisconnected();
                    }
                }
            }
        }


        //
        // Does internal initalization before async winsock
        // call to BeginConnect() or BeginAccept().
        //
        internal void SetAsyncEventSelect(AsyncEventBits blockEventBits) {
            GlobalLog.Enter("Socket#" + ValidationHelper.HashString(this) + "::SetAsyncEventSelect", "blockEventBits:" + blockEventBits.ToString() + " m_BlockEventBits:" + m_BlockEventBits.ToString() + " willBlockInternal:" + willBlockInternal.ToString());

            if (blockEventBits==m_BlockEventBits) {
                //
                // nothing for us to do, nothing is going to change
                //
                GlobalLog.Leave("Socket#" + ValidationHelper.HashString(this) + "::SetAsyncEventSelect", "nothing to do");
                return;
            }

            //
            // We need to select socket first, enabling us to listen to events
            // then submit the event to the thread pool, and then finally
            // call the function we wish to call.
            // the following event is not used in Send/Receive async APIs
            //
            IntPtr eventHandle;
            if (blockEventBits==AsyncEventBits.FdNone) {
                //
                // this will cancel any previous WSAEventSelect() and will put us back
                // into blocking mode. custom build the native parameters
                //
                if (m_AsyncEvent!=null) {
                    m_AsyncEvent = null;
                }
                eventHandle = IntPtr.Zero;
            }
            else {
                //
                // this will put us into non-blocking mode.
                // we'll need the real pointer here
                //
                if (m_AsyncEvent==null) {
                    m_AsyncEvent = new AutoResetEvent(false);
                }
                eventHandle = m_AsyncEvent.Handle;
            }

            //
            // save blockEventBits
            //
            m_BlockEventBits = blockEventBits;

            //
            // issue the native call
            //
            int errorCode =
                UnsafeNclNativeMethods.OSSOCK.WSAEventSelect(
                    m_Handle,
                    eventHandle,
                    m_BlockEventBits );

            if (errorCode==SocketErrors.SocketError) {
                //
                // update our internal state after this socket error
                // we won't throw since this is an internal method
                //
                UpdateStatusAfterSocketError();
            }

            //
            // the call to WSAEventSelect might have caused us to change
            // blocking mode, hence we need update internal status
            //
            willBlockInternal = willBlockInternal && m_BlockEventBits==AsyncEventBits.FdNone;

            GlobalLog.Leave("Socket#" + ValidationHelper.HashString(this) + "::SetAsyncEventSelect", "m_BlockEventBits:" + m_BlockEventBits.ToString() + " willBlockInternal:" + willBlockInternal.ToString());
        }

        //
        // ValidateBlockingMode - called before synchronous calls to validate
        // the fact that we are in blocking mode (not in non-blocking mode) so the
        // call will actually be synchronous
        //
        private void ValidateBlockingMode() {
            if (willBlock && !willBlockInternal) {
                throw new InvalidOperationException(SR.GetString(SR.net_invasync));
            }
        }


        //
        // This Method binds the Socket Win32 Handle to the ThreadPool's CompletionPort
        // (make sure we only bind once per socket)
        //
        // It is safe to Assert unmanaged code security for this entire method
        [SecurityPermissionAttribute( SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
        internal void BindToCompletionPort() {
            //
            // Check to see if the socket native m_Handle is already
            // bound to the ThreadPool's completion port.
            //
            if (!m_Bound && !UseOverlappedIO) {
                lock (this) {
                    if (!m_Bound) { 
                        m_Bound = true;
                        //
                        // bind the socket native m_Handle to the ThreadPool
                        //
                        GlobalLog.Print("Socket#" + ValidationHelper.HashString(this) + "::BindToCompletionPort() calling ThreadPool.BindHandle()");

                        try {
                            ThreadPool.BindHandle(m_Handle);                            
                        }
                        catch {
                            GlobalLog.Assert(false, "BindHandle threw an Exception", string.Empty);
                            Close();
                            throw;
                        }                        
                    }
                }
            }

        } // BindToCompletionPort

        /// <include file='doc\Socket.uex' path='docs/doc[@for="Socket.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return unchecked((int)m_Handle);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        internal void Debug() {
            Console.WriteLine("m_Handle:" + m_Handle.ToString() );
            Console.WriteLine("m_WasConnected: " + m_WasConnected);
            Console.WriteLine("m_WasDisconnected: " + m_WasDisconnected);
        }


    }; // class Socket


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\selectmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    /// <include file='doc\SelectMode.uex' path='docs/doc[@for="SelectMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the mode for polling the status of a socket.
    ///    </para>
    /// </devdoc>
    public enum SelectMode {
        /// <include file='doc\SelectMode.uex' path='docs/doc[@for="SelectMode.SelectRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Poll the read status of a socket.
        ///    </para>
        /// </devdoc>
        SelectRead     = 0,
        /// <include file='doc\SelectMode.uex' path='docs/doc[@for="SelectMode.SelectWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Poll the write status of a socket.
        ///    </para>
        /// </devdoc>
        SelectWrite    = 1,
        /// <include file='doc\SelectMode.uex' path='docs/doc[@for="SelectMode.SelectError"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Poll the error status of a socket.
        ///    </para>
        /// </devdoc>
        SelectError    = 2
    } // enum SelectMode
} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\protocoltype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProtocolType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the protocols that the <see cref='System.Net.Sockets.Socket'/> class supports.
    ///    </para>
    /// </devdoc>
    public enum ProtocolType {
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.IP"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IP             = 0,    // dummy for IP
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Icmp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Icmp           = 1,    // control message protocol
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Igmp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Igmp           = 2,    // group management protocol
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Ggp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ggp            = 3,    // gateway^2 (deprecated)
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Tcp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tcp            = 6,    // tcp
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Pup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pup            = 12,   // pup
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Udp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Udp            = 17,   // user datagram protocol
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Idp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Idp            = 22,   // xns idp
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IPv6           = 41,   // IPv6
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.ND"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ND             = 77,   // UNOFFICIAL net disk proto
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Raw"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Raw            = 255,  // raw IP packet

        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Unspecified"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unspecified    = 0,
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Ipx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ipx            = 1000,
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Spx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Spx            = 1256,
        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.SpxII"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SpxII          = 1257,

        /// <include file='doc\ProtocolType.uex' path='docs/doc[@for="ProtocolType.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown        = -1,   // unknown protocol type

/*
consider adding:

#define IPPROTO_RSVP                0x2e 
#define DNPROTO_NSP                 1               // DECnet NSP transport protocol
#define ISOPROTO_TP_CONS            25              // Transport over CONS
#define ISOPROTO_CLTP_CONS          tba             // Connectionless Transport over CONS
#define ISOPROTO_TP4_CLNS           29              // Transport class 4 over CLNS
#define ISOPROTO_CLTP_CLNS          30              // Connectionless Transport over CLNS
#define ISOPROTO_X25                32              // X.25
#define ISOPROTO_X25PVC             tba             // Permanent Virtual Circuit
#define ISOPROTO_X25SVC             ISOPROTO_X25    // Switched Virtual Circuit
#define ISOPROTO_TP                 ISOPROTO_TP4_CLNS
#define ISOPROTO_CLTP               ISOPROTO_CLTP_CLNS
#define ISOPROTO_TP0_TCP            tba             // Transport class 0 over TCP (RFC1006)
#define ATMPROTO_AALUSER            0x00            // User-defined AAL
#define ATMPROTO_AAL1               0x01            // AAL 1
#define ATMPROTO_AAL2               0x02            // AAL 2
#define ATMPROTO_AAL34              0x03            // AAL 3/4
#define ATMPROTO_AAL5               0x05            // AAL 5
*/


    } // enum ProtocolType


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\socketerrors.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketErrors.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines socket error constants.
    ///    </para>
    /// </devdoc>
    internal class SocketErrors {

        public const int Success                = 0;

        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.InvalidSocket"]/*' />
        /// <devdoc>
        ///    <para>The socket is invalid.</para>
        /// </devdoc>
        // SocketErrors.InvalidSocket
        // SocketErrors.InvalidSocket
        public const int InvalidSocket          = (~0);
        public static readonly IntPtr InvalidSocketIntPtr = (IntPtr)SocketErrors.InvalidSocket;
        
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.SocketError"]/*' />
        /// <devdoc>
        ///    <para>The socket has an error.</para>
        /// </devdoc>
        // SocketErrors.SocketError
        // SocketErrors.SocketError
        public const int SocketError            = (-1);


        /*
         * All Windows Sockets error constants are biased by WSABASEERR from
         * the "normal"
         */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSABASEERR"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The base value of all socket error constants. All other socket errors are
        ///       offset from this value.
        ///    </para>
        /// </devdoc>
        public const int WSABASEERR             = 10000;
        /*
         * Windows Sockets definitions of regular Microsoft C error constants
         */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEINTR"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A blocking socket call was canceled.
        ///    </para>
        /// </devdoc>
        public const int WSAEINTR               = (WSABASEERR+4);
        public const int WSAEBADF               = (WSABASEERR+9);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEACCES"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Permission denied.
        ///    </para>
        /// </devdoc>
        public const int WSAEACCES              = (WSABASEERR+13);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEFAULT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Bad address.
        ///    </para>
        /// </devdoc>
        public const int WSAEFAULT              = (WSABASEERR+14);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEINVAL"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invalid argument.
        ///    </para>
        /// </devdoc>
        public const int WSAEINVAL              = (WSABASEERR+22);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEMFILE"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Too many open
        ///       files.
        ///    </para>
        /// </devdoc>
        public const int WSAEMFILE              = (WSABASEERR+24);
        
        /*
         * Windows Sockets definitions of regular Berkeley error constants
         */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEWOULDBLOCK"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resource temporarily
        ///       unavailable.
        ///    </para>
        /// </devdoc>
        public const int WSAEWOULDBLOCK         = (WSABASEERR+35);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEINPROGRESS"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Operation now in progress.
        ///    </para>
        /// </devdoc>
        public const int WSAEINPROGRESS         = (WSABASEERR+36);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEALREADY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Operation already in progress.
        ///    </para>
        /// </devdoc>
        public const int WSAEALREADY            = (WSABASEERR+37);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENOTSOCK"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Socket operation on nonsocket.
        ///    </para>
        /// </devdoc>
        public const int WSAENOTSOCK            = (WSABASEERR+38);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEDESTADDRREQ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Destination address required.
        ///    </para>
        /// </devdoc>
        public const int WSAEDESTADDRREQ        = (WSABASEERR+39);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEMSGSIZE"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Message too long.
        ///    </para>
        /// </devdoc>
        public const int WSAEMSGSIZE            = (WSABASEERR+40);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEPROTOTYPE"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Protocol wrong type for socket.
        ///    </para>
        /// </devdoc>
        public const int WSAEPROTOTYPE          = (WSABASEERR+41);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENOPROTOOPT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Bad protocol option.
        ///    </para>
        /// </devdoc>
        public const int WSAENOPROTOOPT         = (WSABASEERR+42);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEPROTONOSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Protocol not supported.
        ///    </para>
        /// </devdoc>
        public const int WSAEPROTONOSUPPORT     = (WSABASEERR+43);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAESOCKTNOSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Socket type not supported.
        ///    </para>
        /// </devdoc>
        public const int WSAESOCKTNOSUPPORT     = (WSABASEERR+44);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEOPNOTSUPP"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Operation not supported.
        ///    </para>
        /// </devdoc>
        public const int WSAEOPNOTSUPP          = (WSABASEERR+45);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEPFNOSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Protocol family not supported.
        ///    </para>
        /// </devdoc>
        public const int WSAEPFNOSUPPORT        = (WSABASEERR+46);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEAFNOSUPPORT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Address family not supported by protocol family.
        ///    </para>
        /// </devdoc>
        public const int WSAEAFNOSUPPORT        = (WSABASEERR+47);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEADDRINUSE"]/*' />
        /// <devdoc>
        ///    Address already in use.
        /// </devdoc>
        public const int WSAEADDRINUSE          = (WSABASEERR+48);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEADDRNOTAVAIL"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Cannot assign requested address.
        ///    </para>
        /// </devdoc>
        public const int WSAEADDRNOTAVAIL       = (WSABASEERR+49);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENETDOWN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Network is down.
        ///    </para>
        /// </devdoc>
        public const int WSAENETDOWN            = (WSABASEERR+50);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENETUNREACH"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Network is unreachable.
        ///    </para>
        /// </devdoc>
        public const int WSAENETUNREACH         = (WSABASEERR+51);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENETRESET"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Network dropped connection on reset.
        ///    </para>
        /// </devdoc>
        public const int WSAENETRESET           = (WSABASEERR+52);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAECONNABORTED"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Software caused connection to abort.
        ///    </para>
        /// </devdoc>
        public const int WSAECONNABORTED        = (WSABASEERR+53);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAECONNRESET"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Connection reset by peer.
        ///    </para>
        /// </devdoc>
        public const int WSAECONNRESET          = (WSABASEERR+54);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENOBUFS"]/*' />
        /// <devdoc>
        ///    No buffer space available.
        /// </devdoc>
        public const int WSAENOBUFS             = (WSABASEERR+55);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEISCONN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Socket is already connected.
        ///    </para>
        /// </devdoc>
        public const int WSAEISCONN             = (WSABASEERR+56);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAENOTCONN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Socket is not connected.
        ///    </para>
        /// </devdoc>
        public const int WSAENOTCONN            = (WSABASEERR+57);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAESHUTDOWN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Cannot send after socket shutdown.
        ///    </para>
        /// </devdoc>
        public const int WSAESHUTDOWN           = (WSABASEERR+58);
        public const int WSAETOOMANYREFS        = (WSABASEERR+59);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAETIMEDOUT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Connection timed out.
        ///    </para>
        /// </devdoc>
        public const int WSAETIMEDOUT           = (WSABASEERR+60);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAECONNREFUSED"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Connection refused.
        ///    </para>
        /// </devdoc>
        public const int WSAECONNREFUSED        = (WSABASEERR+61);
        public const int WSAELOOP               = (WSABASEERR+62);
        public const int WSAENAMETOOLONG        = (WSABASEERR+63);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEHOSTDOWN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Host is down.
        ///    </para>
        /// </devdoc>
        public const int WSAEHOSTDOWN           = (WSABASEERR+64);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEHOSTUNREACH"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No route to host.
        ///    </para>
        /// </devdoc>
        public const int WSAEHOSTUNREACH        = (WSABASEERR+65);
        public const int WSAENOTEMPTY           = (WSABASEERR+66);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEPROCLIM"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Too many processes.
        ///    </para>
        /// </devdoc>
        public const int WSAEPROCLIM            = (WSABASEERR+67);
        public const int WSAEUSERS              = (WSABASEERR+68);
        public const int WSAEDQUOT              = (WSABASEERR+69);
        public const int WSAESTALE              = (WSABASEERR+70);
        public const int WSAEREMOTE             = (WSABASEERR+71);

        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAEDISCON"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Graceful shutdown in progress.
        ///    </para>
        /// </devdoc>
        public const int WSAEDISCON             = (WSABASEERR+101);

        /*
         * Extended Windows Sockets error constant definitions
         */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSASYSNOTREADY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Network subsystem is unavailable.
        ///    </para>
        /// </devdoc>
        public const int WSASYSNOTREADY         = (WSABASEERR+91);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAVERNOTSUPPORTED"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Winsock.dll out of range.
        ///    </para>
        /// </devdoc>
        public const int WSAVERNOTSUPPORTED     = (WSABASEERR+92);
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSANOTINITIALISED"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Successful startup not yet performed.
        ///    </para>
        /// </devdoc>
        public const int WSANOTINITIALISED      = (WSABASEERR+93);

        /*
         * Winsock 2 Defines this value just to be ERROR_IO_PENDING or 997
         */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSA_IO_PENDING"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Overlapped operations will complete later.
        ///    </para>
        /// </devdoc>
        public const int WSA_IO_PENDING         = (997);

        /*
         * Error return codes from gethostbyname() and gethostbyaddr()
         *              = (when using the resolver). Note that these errors are
         * retrieved via WSAGetLastError() and must therefore follow
         * the rules for avoiding clashes with error numbers from
         * specific implementations or language run-time systems.
         * For this reason the codes are based at WSABASEERR+1001.
         * Note also that [WSA]NO_ADDRESS is defined only for
         * compatibility purposes.
         */


        /* Authoritative Answer: Host not found */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSAHOST_NOT_FOUND"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Host not found.
        ///    </para>
        /// </devdoc>
        public const int WSAHOST_NOT_FOUND      = (WSABASEERR+1001);

        /* Non-Authoritative: Host not found; or SERVERFAIL */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSATRY_AGAIN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Nonauthoritative host not found.
        ///    </para>
        /// </devdoc>
        public const int WSATRY_AGAIN           = (WSABASEERR+1002);

        /* Non recoverable errors; FORMERR, REFUSED, NOTIMP */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSANO_RECOVERY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       This is a nonrecoverable error.
        ///    </para>
        /// </devdoc>
        public const int WSANO_RECOVERY         = (WSABASEERR+1003);

        /* Valid name, no data record of requested type */
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.WSANO_DATA"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Valid name, no data record of requested type.
        ///    </para>
        /// </devdoc>
        public const int WSANO_DATA             = (WSABASEERR+1004);

        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.HOST_NOT_FOUND"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Host not found.
        ///    </para>
        /// </devdoc>
        public const int HOST_NOT_FOUND         = WSAHOST_NOT_FOUND;
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.TRY_AGAIN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Nonauthoritative host not found.
        ///    </para>
        /// </devdoc>
        public const int TRY_AGAIN              = WSATRY_AGAIN;
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.NO_RECOVERY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       This is a nonrecoverable error.
        ///    </para>
        /// </devdoc>
        public const int NO_RECOVERY            = WSANO_RECOVERY;
        /// <include file='doc\SocketErrors.uex' path='docs/doc[@for="SocketErrors.NO_DATA"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Valid name, no data record of requested type.
        ///    </para>
        /// </devdoc>
        public const int NO_DATA                = WSANO_DATA;
        /* no address; look for MX record */
        public const int WSANO_ADDRESS          = WSANO_DATA;
        public const int NO_ADDRESS             = WSANO_ADDRESS;


        /*
        public const int HostNotFound                           = HOST_NOT_FOUND;
        public const int NoAddress                              = NO_ADDRESS;
        public const int NoData                                 = NO_DATA;
        public const int NoRecovery                             = NO_RECOVERY;
        public const int TryAgain                               = TRY_AGAIN;
        public const int WsaIOPending                           = WSA_IO_PENDING;
        public const int WsaBaseError                           = WSABASEERR;
        public const int WsaErrorAccess                         = WSAEACCES;
        public const int WsaErrorAddressInUse                   = WSAEADDRINUSE;
        public const int WsaErrorAddressNotAvailable            = WSAEADDRNOTAVAIL;
        public const int WsaErrorAddressFamilyNoSupported       = WSAEAFNOSUPPORT;
        public const int WsaErrorAlready                        = WSAEALREADY;
        public const int WsaErrorBadFileHandle                  = WSAEBADF;
        public const int WsaErrorConnectionAbosrted             = WSAECONNABORTED;
        public const int WsaErrorConnectionRefused              = WSAECONNREFUSED;
        public const int WsaErrorConnectionReset                = WSAECONNRESET;
        public const int WsaErrorDestinationAddressRequested    = WSAEDESTADDRREQ;
        public const int WsaErrorDisconnected                   = WSAEDISCON;
        public const int WsaErrorOutOfDiskQuota                 = WSAEDQUOT;
        public const int WsaErrorFault                          = WSAEFAULT;
        public const int WsaErrorHostDown                       = WSAEHOSTDOWN;
        public const int WsaErrorHostUnreachable                = WSAEHOSTUNREACH;
        public const int WsaErrorInProgress                     = WSAEINPROGRESS;
        public const int WsaErrorInterrupted                    = WSAEINTR;
        public const int WsaErrorInvalid                        = WSAEINVAL;
        public const int WsaErrorISConnection                   = WSAEISCONN;
        public const int WsaErrorLoop                           = WSAELOOP;
        public const int WsaErrorTooManyOpenSockets             = WSAEMFILE;
        public const int WsaErrorMessageSize                    = WSAEMSGSIZE;
        public const int WsaErrorNameTooLong                    = WSAENAMETOOLONG;
        public const int WsaErrorNetDown                        = WSAENETDOWN;
        public const int WsaErrorNetReset                       = WSAENETRESET;
        public const int WsaErrorNetUnreachable                 = WSAENETUNREACH;
        public const int WsaErrorNoBuffers                      = WSAENOBUFS;
        public const int WsaErrorNoProtocolOption               = WSAENOPROTOOPT;
        public const int WsaErrorNotConnected                   = WSAENOTCONN;
        public const int WsaErrorNotEmpty                       = WSAENOTEMPTY;
        public const int WsaErrorNotSocket                      = WSAENOTSOCK;
        public const int WsaErrorOperationNotSupported          = WSAEOPNOTSUPP;
        public const int WsaErrorProtocolFamilyNoSupported      = WSAEPFNOSUPPORT;
        public const int WsaErrorProcessLimit                   = WSAEPROCLIM;
        public const int WsaErrorPotocolNotSupported            = WSAEPROTONOSUPPORT;
        public const int WsaErrorProtocolType                   = WSAEPROTOTYPE;
        public const int WsaErrorRemote                         = WSAEREMOTE;
        public const int WsaErrorShutdown                       = WSAESHUTDOWN;
        public const int WsaErrorSocketNotSupported             = WSAESOCKTNOSUPPORT;
        public const int WsaErrorStale                          = WSAESTALE;
        public const int WsaErrorTimedOut                       = WSAETIMEDOUT;
        public const int WsaErrorTooManyRefuses                 = WSAETOOMANYREFS;
        public const int WsaErrorUsers                          = WSAEUSERS;
        public const int WsaErrorWouldBlock                     = WSAEWOULDBLOCK;
        public const int WsaHostNotFound                        = WSAHOST_NOT_FOUND;
        public const int WsaNoAddress                           = WSANO_ADDRESS;
        public const int WsaNoData                              = WSANO_DATA;
        public const int WsaNoRecovery                          = WSANO_RECOVERY;
        public const int WsaNotInitialized                      = WSANOTINITIALISED;
        public const int WsaSystemNotReady                      = WSASYSNOTREADY;
        public const int WsaTryAgain                            = WSATRY_AGAIN;
        public const int WsaVersionNotSupported                 = WSAVERNOTSUPPORTED;
        */


    } // class SocketErrors


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\socketoptionlevel.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketOptionLevel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    //
    // Option flags per-socket.
    //

    /// <include file='doc\SocketOptionLevel.uex' path='docs/doc[@for="SocketOptionLevel"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines socket option levels for the <see cref='System.Net.Sockets.Socket'/> class.
    ///    </para>
    /// </devdoc>
    //UEUE
    public enum SocketOptionLevel {

        /// <include file='doc\SocketOptionLevel.uex' path='docs/doc[@for="SocketOptionLevel.Socket"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates socket options apply to the socket itself.
        ///    </para>
        /// </devdoc>
        Socket = 0xffff,

        /// <include file='doc\SocketOptionLevel.uex' path='docs/doc[@for="SocketOptionLevel.IP"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates socket options apply to IP sockets.
        ///    </para>
        /// </devdoc>
        IP = ProtocolType.IP,

        /// <devdoc>
        ///    <para>
        ///       Indicates socket options apply to IPv6 sockets.
        ///    </para>
        /// </devdoc>
        IPv6 = ProtocolType.IPv6,

        /// <include file='doc\SocketOptionLevel.uex' path='docs/doc[@for="SocketOptionLevel.Tcp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates socket options apply to Tcp sockets.
        ///    </para>
        /// </devdoc>
        Tcp = ProtocolType.Tcp,

        /// <include file='doc\SocketOptionLevel.uex' path='docs/doc[@for="SocketOptionLevel.Udp"]/*' />
        /// <devdoc>
        /// <para>
        /// Indicates socket options apply to Udp sockets.
        /// </para>
        /// </devdoc>
        //UEUE
        Udp = ProtocolType.Udp,

    }; // enum SocketOptionLevel


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\socketflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides constant values for socket messages.
    ///    </para>
    /// </devdoc>
    //UEUE
    [Flags]
    public enum SocketFlags {

        /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use no flags for this call.
        ///    </para>
        /// </devdoc>
        None                = 0x0000,

        /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags.OutOfBand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Process out-of-band data.
        ///    </para>
        /// </devdoc>
        OutOfBand           = 0x0001,

        /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags.Peek"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Peek at incoming message.
        ///    </para>
        /// </devdoc>
        Peek                = 0x0002,

        /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags.DontRoute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Send without using routing tables.
        ///    </para>
        /// </devdoc>
        DontRoute           = 0x0004,

        /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags.MaxIOVectorLength"]/*' />
        // see: http://as400bks.rochester.ibm.com/pubs/html/as400/v4r5/ic2978/info/apis/recvms.htm
        MaxIOVectorLength   = 0x0010,

        /// <include file='doc\SocketFlags.uex' path='docs/doc[@for="SocketFlags.Partial"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Partial send or recv for message.
        ///    </para>
        /// </devdoc>
        Partial             = 0x8000,

    }; // enum SocketFlags


/*
MSG_DONTROUTE
Specifies that the data should not be subject to routing. A WinSock service 
provider may choose to ignore this flag;.

MSG_OOB
Send out-of-band data (stream style socket such as SOCK_STREAM only).

MSG_PARTIAL
Specifies that lpBuffers only contains a partial message. Note 
that the error code WSAEOPNOTSUPP will be returnedthis flag is ignored by 
transports which do not support partial message transmissions.

MSG_INTERRUPT // not supported (Win16)
Specifies that the function is being called in interrupt context.
The service provider must not make any Windows systems calls. Note that 
this is applicable only to Win16 environments and only for protocols that 
have the XP1_INTERRUPT bit set in the PROTOCOL_INFO struct.
*/  


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\socketshutdown.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketShutdown.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    /// <include file='doc\SocketShutdown.uex' path='docs/doc[@for="SocketShutdown"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines constants used by the <see cref='System.Net.Sockets.Socket.Shutdown'/> method.
    ///    </para>
    /// </devdoc>
    public enum SocketShutdown {
        /// <include file='doc\SocketShutdown.uex' path='docs/doc[@for="SocketShutdown.Receive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shutdown sockets for receive.
        ///    </para>
        /// </devdoc>
        Receive   = 0x00,
        /// <include file='doc\SocketShutdown.uex' path='docs/doc[@for="SocketShutdown.Send"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shutdown socket for send.
        ///    </para>
        /// </devdoc>
        Send      = 0x01,
        /// <include file='doc\SocketShutdown.uex' path='docs/doc[@for="SocketShutdown.Both"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shutdown socket for both send and receive.
        ///    </para>
        /// </devdoc>
        Both      = 0x02,

    }; // enum SocketShutdown


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\tcpclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="TCPClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net.Sockets {

    /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient"]/*' />
    /// <devdoc>
    /// <para>The <see cref='System.Net.Sockets.TcpClient'/> class provide TCP services at a higher level
    ///    of abstraction than the <see cref='System.Net.Sockets.Socket'/> class. <see cref='System.Net.Sockets.TcpClient'/>
    ///    is used to create a Client connection to a remote host.</para>
    /// </devdoc>
    public class TcpClient : IDisposable {

        Socket m_ClientSocket;
        bool m_Active;
        NetworkStream m_DataStream;
        bool m_DataStreamCreated;
        //
        // IPv6: Maintain address family for the client
        //
        AddressFamily m_Family = AddressFamily.InterNetwork;

        // specify local IP and port
        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.TcpClient"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.Sockets.TcpClient'/>
        ///       class with the specified end point.
        ///    </para>
        /// </devdoc>
        public TcpClient(IPEndPoint localEP) {
            if (localEP==null) {
                throw new ArgumentNullException("localEP");
            }
            //
            // IPv6: Establish address family before creating a socket
            //
            m_Family = localEP.AddressFamily;

            initialize();
            Client.Bind(localEP);
        }

        // TcpClient(IPaddress localaddr); // port is arbitrary
        // TcpClient(int outgoingPort); // local IP is arbitrary

        // address+port is arbitrary
        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.TcpClient1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.Sockets.TcpClient'/> class.
        ///    </para>
        /// </devdoc>
        public TcpClient() : this(AddressFamily.InterNetwork) {
        }

        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.Sockets.TcpClient'/> class.
        ///    </para>
        /// </devdoc>
#if COMNET_DISABLEIPV6
        private TcpClient(AddressFamily family) {
#else
        public TcpClient(AddressFamily family) {
#endif
            //
            // Validate parameter
            //
            if ( family != AddressFamily.InterNetwork && family != AddressFamily.InterNetworkV6) {
                throw new ArgumentException("family");
            }

            m_Family = family;

            initialize();
        }

        // bind and connect
        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.TcpClient2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Net.Sockets.TcpClient'/> class and connects to the
        ///    specified port on the specified host.</para>
        /// </devdoc>
        public TcpClient(string hostname, int port) {
            if (hostname==null) {
                throw new ArgumentNullException("hostname");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            //
            // IPv6: Delay creating the client socket until we have
            //       performed DNS resolution and know which address
            //       families we can use.
            //
            //initialize();

            Connect(hostname, port);
        }

        //
        // used by TcpListener.Accept()
        //
        internal TcpClient(Socket acceptedSocket) {
            Client = acceptedSocket;
            m_Active = true;
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Client"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to provide
        ///       the underlying network socket.
        ///    </para>
        /// </devdoc>
        protected Socket Client {
            get {
                return m_ClientSocket;
            }
            set {
                m_ClientSocket = value;
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Active"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to indicate that a connection has been made.
        ///    </para>
        /// </devdoc>
        protected bool Active {
            get {
                return m_Active;
            }
            set {
                m_Active = value;
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Connect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Connects the Client to the specified port on the specified host.
        ///    </para>
        /// </devdoc>
        public void Connect(string hostname, int port) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (hostname==null) {
                throw new ArgumentNullException("hostname");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            //
            // Check for already connected and throw here. This check
            // is not required in the other connect methods as they
            // will throw from WinSock. Here, the situation is more
            // complex since we have to resolve a hostname so it's
            // easier to simply block the request up front.
            //
            if ( m_Active ) {
                throw new SocketException(SocketErrors.WSAEISCONN);
            }

            //
            // IPv6: We need to process each of the addresses return from
            //       DNS when trying to connect. Use of AddressList[0] is
            //       bad form.
            //
            IPHostEntry host   = Dns.Resolve(hostname);
            Exception   lastex = null;

            foreach ( IPAddress address in host.AddressList ) {
                if ( m_ClientSocket == null ) {
                    //
                    // We came via the <hostname,port> constructor. Set the
                    // address family appropriately, create the socket and
                    // try to connect.
                    //
                    m_Family = address.AddressFamily;

                    initialize();

                    try
                    {
                        //
                        // Attempt to connect to the host
                        //
                        Connect( new IPEndPoint(address,port) );

                        break;
                    }
                    catch ( Exception ex )
                    {
                        //
                        // Destroy the client socket here for retry with
                        // the next address.
                        //
                        m_ClientSocket.InternalShutdown(SocketShutdown.Both);
                        m_ClientSocket.Close();
                        m_ClientSocket = null;
                        //
                        // Save the exception for rethrow if we fail to connect
                        //
                        lastex = ex;
                    }
                }
                else if ( address.AddressFamily == m_Family ) {
                    //
                    // Only use addresses with a matching family
                    //
                    try
                    {
                        //
                        // Attempt to connect to the host
                        //
                        Connect( new IPEndPoint(address,port) );

                        break;
                    }
                    catch ( Exception ex )
                    {
                        //
                        // Save the exception for rethrow if we fail to connect
                        //
                        lastex = ex;
                    }
                }
            }
            //
            // m_Active tells us whether we managed to connect
            //
            if ( !m_Active ) {
                //
                // The connect failed - rethrow the last error we had
                //
                if ( lastex != null )
                    throw lastex;
                else
                    throw new SocketException(SocketErrors.WSAENOTCONN);
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Connect1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Connects the Client to the specified port on the specified host.
        ///    </para>
        /// </devdoc>
        public void Connect(IPAddress address, int port) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (address==null) {
                throw new ArgumentNullException("address");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            IPEndPoint remoteEP = new IPEndPoint(address, port);
            Connect(remoteEP);
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Connect2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Connect the Client to the specified end point.
        ///    </para>
        /// </devdoc>
        public void Connect(IPEndPoint remoteEP) {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (remoteEP==null) {
                throw new ArgumentNullException("remoteEP");
            }
            Client.Connect(remoteEP);
            m_Active = true;
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.GetStream"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the stream used to read and write data to the
        ///       remote host.
        ///    </para>
        /// </devdoc>
        public NetworkStream GetStream() {
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (!Client.Connected) {
                throw new InvalidOperationException(SR.GetString(SR.net_notconnected));
            }
            if (m_DataStream==null) {
                m_DataStream = new NetworkStream(Client, true);
                m_DataStreamCreated = true;
            }
            return m_DataStream;
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes the Tcp connection.
        ///    </para>
        /// </devdoc>
        //UEUE
        public void Close() {
            GlobalLog.Print("TcpClient::Close()");
            ((IDisposable)this).Dispose();
        }

        private bool m_CleanedUp = false;

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (m_CleanedUp) {
                return;
            }

            if (disposing) {
                //no managed objects to cleanup
            }

            if (!m_DataStreamCreated) {
                //
                // if the NetworkStream wasn't created, the Socket might
                // still be there and needs to be closed. In the case in which
                // we are bound to a local IPEndPoint this will remove the
                // binding and free up the IPEndPoint for later uses.
                //
                Socket chkClientSocket = Client;
                if (chkClientSocket!= null) {
                    chkClientSocket.InternalShutdown(SocketShutdown.Both);
                    chkClientSocket.Close();
                    Client = null;
                }
            }
            //
            // wether the NetworkStream was created or not, we need to
            // lose its internal reference so that this TcpClient can be
            // collected and the NetworkStream can still be used.
            // note that the NetworkStream was created as owning the Socket,
            // so we lose the internal reference to the Socket above as well.
            //
            m_DataStream = null;
            m_CleanedUp = true;
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.Finalize"]/*' />
        ~TcpClient() {
            Dispose(false);
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.ReceiveBufferSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the size of the receive buffer in bytes.
        ///    </para>
        /// </devdoc>
        public int ReceiveBufferSize {
            get {
                return numericOption(SocketOptionLevel.Socket,
                                     SocketOptionName.ReceiveBuffer);
            }
            set {
                Client.SetSocketOption(SocketOptionLevel.Socket,
                                  SocketOptionName.ReceiveBuffer, value);
            }
        }


        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.SendBufferSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the size of the send buffer in bytes.
        ///    </para>
        /// </devdoc>
        public int SendBufferSize {
            get {
                return numericOption(SocketOptionLevel.Socket,
                                     SocketOptionName.SendBuffer);
            }

            set {
                Client.SetSocketOption(SocketOptionLevel.Socket,
                                  SocketOptionName.SendBuffer, value);
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.ReceiveTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the receive time out value of the connection in seconds.
        ///    </para>
        /// </devdoc>
        public int ReceiveTimeout {
            get {
                return numericOption(SocketOptionLevel.Socket,
                                     SocketOptionName.ReceiveTimeout);
            }
            set {
                Client.SetSocketOption(SocketOptionLevel.Socket,
                                  SocketOptionName.ReceiveTimeout, value);
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.SendTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the send time out value of the connection in seconds.
        ///    </para>
        /// </devdoc>
        public int SendTimeout {
            get {
                return numericOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout);
            }

            set {
                Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, value);
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.LingerState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the connection's linger option.
        ///    </para>
        /// </devdoc>
        public LingerOption LingerState {
            get {
                return (LingerOption)Client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger);
            }
            set {
                Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, value);
            }
        }

        /// <include file='doc\TCPClient.uex' path='docs/doc[@for="TcpClient.NoDelay"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables or disables delay when send or receive buffers are full.
        ///    </para>
        /// </devdoc>
        public bool NoDelay {
            get {
                return numericOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay) != 0 ? true : false;
            }
            set {
                Client.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, value ? 1 : 0);
            }
        }

        private void initialize() {
            //
            // IPv6: Use the address family from the constructor (or Connect method)
            //
            Client = new Socket(m_Family, SocketType.Stream, ProtocolType.Tcp);
            m_Active = false;
        }

        private int numericOption(SocketOptionLevel optionLevel, SocketOptionName optionName) {
            return (int)Client.GetSocketOption(optionLevel, optionName);
        }

    }; // class TCPClient


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\tcplistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="TCPListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.Net;

    /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener"]/*' />
    /// <devdoc>
    /// <para>The <see cref='System.Net.Sockets.TcpListener'/> class provide TCP services at a higher level of abstraction than the <see cref='System.Net.Sockets.Socket'/>
    /// class. <see cref='System.Net.Sockets.TcpListener'/> is used to create a host process that
    /// listens for connections from TCP clients.</para>
    /// </devdoc>
    public class TcpListener {

        IPEndPoint m_ServerSocketEP;
        Socket m_ServerSocket;
        bool m_Active;

         /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.TcpListener"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the TcpListener class with the specified local
        ///       end point.
        ///    </para>
        /// </devdoc>
        public TcpListener(IPEndPoint localEP) {
            if (localEP == null) {
                throw new ArgumentNullException("localEP");
            }
            m_ServerSocketEP = localEP;
            m_ServerSocket   = new Socket(m_ServerSocketEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        }

        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.TcpListener1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the TcpListener class that listens to the
        ///       specified IP address and port.
        ///    </para>
        /// </devdoc>
        public TcpListener(IPAddress localaddr, int port) {
            if (localaddr == null) {
                throw new ArgumentNullException("localaddr");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            m_ServerSocketEP = new IPEndPoint(localaddr, port);
            m_ServerSocket   = new Socket(m_ServerSocketEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        }

        // implementation picks an address for client
        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.TcpListener2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initiailizes a new instance of the TcpListener class
        ///       that listens on the specified
        ///       port.
        ///    </para>
        /// </devdoc>
        /// 

        [Obsolete("Use TcpListener(IPAddress localaddr, int port).")]
        public TcpListener(int port){

            if (!ValidationHelper.ValidateTcpPort(port)) 
                throw new ArgumentOutOfRangeException("port");
            
            m_ServerSocketEP = new IPEndPoint(IPAddress.Any, port);
            m_ServerSocket = new Socket(m_ServerSocketEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        }

        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.Server"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to provide the underlying network socket.
        ///    </para>
        /// </devdoc>
        protected Socket Server {
            get {
                return m_ServerSocket;
            }
        }

        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.Active"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used
        ///       by the class to indicate that the listener's socket has been bound to a port
        ///       and started listening.
        ///    </para>
        /// </devdoc>
        protected bool Active {
            get {
                return m_Active;
            }
        }
                
        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.LocalEndpoint"]/*' />
        /// <devdoc>
        ///    <para>
        ///        Gets the m_Active EndPoint for the local listener socket.
        ///    </para>
        /// </devdoc>
        public EndPoint LocalEndpoint {
            get {
                return m_Active ? m_ServerSocket.LocalEndPoint : m_ServerSocketEP;
            }
        }

        // Start/stop the listener
        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.Start"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts listening to network requests.
        ///    </para>
        /// </devdoc>
        public void Start() {
            GlobalLog.Print("TCPListener::Start()");

            if (m_ServerSocket == null) 
                throw new InvalidOperationException(SR.GetString(SR.net_InvalidSocketHandle));

            //already listening
            if (m_Active)
                return;

            m_ServerSocket.Bind(m_ServerSocketEP);
            m_ServerSocket.Listen((int)SocketOptionName.MaxConnections);
            m_Active = true;
        }

        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.Stop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the network connection.
        ///    </para>
        /// </devdoc>
        public void Stop() {
            GlobalLog.Print("TCPListener::Stop()");

            if (m_ServerSocket != null) {
                m_ServerSocket.Close();
                m_ServerSocket = null;
            }
            m_Active = false;
            m_ServerSocket = new Socket(m_ServerSocketEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        }

        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.Finalize"]/*' />
        ~TcpListener() {
            if (m_ServerSocket != null) 
                m_ServerSocket.Close();
        }


        // Determine if there are pending connections
        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.Pending"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determine if there are pending connection requests.
        ///    </para>
        /// </devdoc>
        public bool Pending() {
            if (!m_Active) 
                throw new InvalidOperationException(SR.GetString(SR.net_stopped));
            return m_ServerSocket.Poll(0, SelectMode.SelectRead);
        }

        // Accept the first pending connection
        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.AcceptSocket"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Accepts a pending connection request.
        ///    </para>
        /// </devdoc>
        public Socket AcceptSocket() {
            if (!m_Active) 
                throw new InvalidOperationException(SR.GetString(SR.net_stopped));
            return m_ServerSocket.Accept();
        }

        // UEUE
        /// <include file='doc\TCPListener.uex' path='docs/doc[@for="TcpListener.AcceptTcpClient"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TcpClient AcceptTcpClient() {
            if (!m_Active) 
                throw new InvalidOperationException(SR.GetString(SR.net_stopped));
            
            Socket acceptedSocket = m_ServerSocket.Accept();
            TcpClient returnValue = new TcpClient(acceptedSocket);
            return returnValue;
        }

    }; // class TcpListener


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\sockettype.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {

    /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of socket an instance of the <see cref='System.Net.Sockets.Socket'/> class represents.
    ///    </para>
    /// </devdoc>
    public enum SocketType {

        /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType.Stream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Stream      = 1,    // stream socket
        /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType.Dgram"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dgram       = 2,    // datagram socket
        /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType.Raw"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Raw         = 3,    // raw-protocolinterface
        /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType.Rdm"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rdm         = 4,    // reliably-delivered message
        /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType.Seqpacket"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Seqpacket   = 5,    // sequenced packet stream
        /// <include file='doc\SocketType.uex' path='docs/doc[@for="SocketType.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown     = -1,   // Unknown socket type

    } // enum SocketType

} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\socketoptionname.cs ===
//------------------------------------------------------------------------------
// <copyright file="SocketOptionName.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;

    //
    // Option names per-socket.
    //

    /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines socket option names for the <see cref='System.Net.Sockets.Socket'/> class.
    ///    </para>
    /// </devdoc>
    //UEUE
    public enum SocketOptionName {

        //
        // good for SocketOptionLevel.Socket
        //

        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.Debug"]/*' />
        /// <devdoc>
        ///    <para>Record debugging information.</para>
        /// </devdoc>
        Debug                   = 0x0001,           // turn on debugging info recording 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.AcceptConnection"]/*' />
        /// <devdoc>
        ///    <para>Socket is listening.</para>
        /// </devdoc>
        AcceptConnection        = 0x0002,           // socket has had listen() 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.ReuseAddress"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows the socket to be bound to an address that is already in use.
        ///    </para>
        /// </devdoc>
        ReuseAddress            = 0x0004,           // allow local address reuse 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.KeepAlive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Send keep-alives.
        ///    </para>
        /// </devdoc>
        KeepAlive               = 0x0008,           // keep connections alive 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.DontRoute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Do not route, send directly to interface addresses.
        ///    </para>
        /// </devdoc>
        DontRoute               = 0x0010,           // just use interface addresses 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.Broadcast"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Permit sending broadcast messages on the socket.
        ///    </para>
        /// </devdoc>
        Broadcast               = 0x0020,           // permit sending of broadcast msgs 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.UseLoopback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Bypass hardware when possible.
        ///    </para>
        /// </devdoc>
        UseLoopback             = 0x0040,           // bypass hardware when possible 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.Linger"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Linger on close if unsent data is present.
        ///    </para>
        /// </devdoc>
        Linger                  = 0x0080,           // linger on close if data present 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.OutOfBandInline"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives out-of-band data in the normal data stream.
        ///    </para>
        /// </devdoc>
        OutOfBandInline         = 0x0100,           // leave received OOB data in line 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.DontLinger"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Close socket gracefully without lingering.
        ///    </para>
        /// </devdoc>
        DontLinger              = ~Linger,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.ExclusiveAddressUse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enables a socket to be bound for exclusive access.
        ///    </para>
        /// </devdoc>
        ExclusiveAddressUse     = ~ReuseAddress,    // disallow local address reuse
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.SendBuffer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the total per-socket buffer space reserved for sends. This is
        ///       unrelated to the maximum message size or the size of a TCP window.
        ///    </para>
        /// </devdoc>
        SendBuffer              = 0x1001,           // send buffer size
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.ReceiveBuffer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Send low water mark.
        ///    </para>
        /// </devdoc>
        ReceiveBuffer           = 0x1002,           // receive buffer size
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.SendLowWater"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the total per-socket buffer space reserved for receives. This is unrelated to the maximum message size or the size of a TCP window.
        ///    </para>
        /// </devdoc>
        SendLowWater            = 0x1003,           // send low-water mark
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.ReceiveLowWater"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receive low water mark.
        ///    </para>
        /// </devdoc>
        ReceiveLowWater         = 0x1004,           // receive low-water mark
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.SendTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Send timeout.
        ///    </para>
        /// </devdoc>
        SendTimeout             = 0x1005,           // send timeout
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.ReceiveTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receive timeout.
        ///    </para>
        /// </devdoc>
        ReceiveTimeout         = 0x1006,           // receive timeout 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Get error status and clear.
        ///    </para>
        /// </devdoc>
        Error                   = 0x1007,          // get error status and clear 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Get socket type.
        ///    </para>
        /// </devdoc>
        Type                    = 0x1008,           // get socket type 
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.MaxConnections"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maximum queue length that can be specified by <see cref='System.Net.Sockets.Socket.Listen'/>.
        ///    </para>
        /// </devdoc>
        MaxConnections          = 0x7fffffff,       // Maximum queue length specifiable by listen.


        //
        // the following values are taken from ws2tcpip.h,
        // note that these are understood only by ws2_32.dll and are not backwards compatible
        // with the values found in winsock.h which are understood by wsock32.dll.
        //

        //
        // good for SocketOptionLevel.IP
        //

        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.IPOptions"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IP options.
        ///    </para>
        /// </devdoc>
        IPOptions               = 1,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.HeaderIncluded"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Header is included with data.
        ///    </para>
        /// </devdoc>
        HeaderIncluded          = 2,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.TypeOfService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IP type of service and preced.
        ///    </para>
        /// </devdoc>
        TypeOfService           = 3,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.IpTimeToLive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IP time to live.
        ///    </para>
        /// </devdoc>
        IpTimeToLive            = 4,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.MulticastInterface"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IP multicast interface.
        ///       - Additional comments by mbolien:
        ///         multicast interface  You provide it with an SOCKADDR_IN, and that tells the 
        ///         system that it should receive multicast messages on that interface (if you 
        ///         have more than one interface).  Binding the socket is not sufficient, since 
        ///         if the Ethernet hardware isnt set up to grab the multicast packets, it wont 
        ///         do good to bind the socket.  Kinda like raw sockets.  Unless you 
        ///         put the Ethernet card in promiscuous mode, youll only get stuff sent to and 
        ///         from your machine.
        ///    </para>
        /// </devdoc>
        MulticastInterface      = 9,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.MulticastTimeToLive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IP multicast time to live.
        ///    </para>
        /// </devdoc>
        MulticastTimeToLive     = 10,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.MulticastLoopback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       IP Multicast loopback.
        ///    </para>
        /// </devdoc>
        MulticastLoopback       = 11,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.AddMembership"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Add an IP group membership.
        ///    </para>
        /// </devdoc>
        AddMembership           = 12,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.DropMembership"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Drop an IP group membership.
        ///    </para>
        /// </devdoc>
        DropMembership          = 13,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.DontFragment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Don't fragment IP datagrams.
        ///    </para>
        /// </devdoc>
        DontFragment            = 14,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.AddSourceMembership"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Join IP group/source.
        ///    </para>
        /// </devdoc>
        AddSourceMembership     = 15,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.DropSourceMembership"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Leave IP group/source.
        ///    </para>
        /// </devdoc>
        DropSourceMembership    = 16,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.BlockSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Block IP group/source.
        ///    </para>
        /// </devdoc>
        BlockSource             = 17,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.UnblockSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Unblock IP group/source.
        ///    </para>
        /// </devdoc>
        UnblockSource           = 18,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.PacketInformation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receive packet information for ipv4.
        ///    </para>
        /// </devdoc>
        PacketInformation       = 19,



        //
        // good for SocketOptionLevel.Tcp
        //

        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.NoDelay"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disables the Nagle algorithm for send coalescing.
        ///    </para>
        /// </devdoc>
        NoDelay                 = 1,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.BsdUrgent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BsdUrgent               = 2,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.Expedited"]/*' />
        Expedited               = 2,


        //
        // good for SocketOptionLevel.Udp
        //

        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.NoChecksum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoChecksum              = 1,
        /// <include file='doc\SocketOptionName.uex' path='docs/doc[@for="SocketOptionName.ChecksumCoverage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Udp-Lite checksum coverage.
        ///    </para>
        /// </devdoc>
        ChecksumCoverage        = 20,

    }; // enum SocketOptionName


} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\_acceptasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_AcceptAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.Net;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Threading;


    internal class AcceptAsyncResult : LazyAsyncResult {

        private static readonly WaitOrTimerCallback m_AcceptCallback = new WaitOrTimerCallback(AcceptCallback);

        //
        // internal Constructor
        //
        internal AcceptAsyncResult(Socket asyncObject, object asyncState, AsyncCallback asyncCallback)
            : base(asyncObject, asyncState, asyncCallback) {
        }

        //
        // This method is called after an asynchronous call is made for the user,
        // it checks and acts accordingly if the IO:
        // 1) completed synchronously.
        // 2) was pended.
        // 3) failed.
        //
        internal void CheckAsyncCallResult(int status) {

            Socket socket = (Socket)AsyncObject;

            GlobalLog.Print("Socket#" + ValidationHelper.HashString(socket) + "::CheckAsyncCallResult() status:" + status.ToString());

            switch (status) {
                
                case SocketErrors.Success:
                    //
                    // the Async IO call completed synchronously:
                    //
                    break;

                case SocketErrors.WSAEWOULDBLOCK:
                    //
                    // the Async IO call was pended:
                    // Queue our event to the thread pool.
                    //
                    Monitor.Exit(socket);

                    GlobalLog.Assert(
                        socket.m_AsyncEvent!=null,
                        "ConnectAsyncResult: m_AsyncAcceptEvent == null", string.Empty);

                    ThreadPool.RegisterWaitForSingleObject(
                                                          socket.m_AsyncEvent,
                                                          m_AcceptCallback,
                                                          this,
                                                          -1,
                                                          true );

                    //
                    // we're done, return
                    //
                    return;

                default:
                    //
                    // the Async IO call failed:
                    // set the Result to the Win32 error
                    //
                    ErrorCode = status;
                    break;
            }
            //
            // dequeue from the accept list since the accept completed
            //
            socket.AcceptQueue.RemoveAt(socket.AcceptQueue.Count - 1);
            if (socket.AcceptQueue.Count==0) {
                //
                // if the queue is now empty
                // cancel async event
                //
                socket.SetAsyncEventSelect(AsyncEventBits.FdNone);
                //
                // go back to blocking mode
                //
                socket.InternalSetBlocking(true);
            }
            Monitor.Exit(socket);

            if (status==SocketErrors.Success) {
                //
                // synchronously complete the IO and call the user's callback.
                //
                InvokeCallback(true);
            }
        }



        //
        // AcceptCallback - called by WaitCallback to do special Accept handling
        //   this involves searching through a queue of queued Accept requests
        //   and handling them if there are available accept sockets to handle them,
        //   or rewaiting if they are not
        //
        //  The overlapped function called by the thread pool 
        //   when IO completes.
        //

        internal static void AcceptCallback(object stateObject, bool Signaled) {
            AcceptAsyncResult thisAsyncResult = (AcceptAsyncResult)stateObject;
            Socket socket = (Socket)thisAsyncResult.AsyncObject;
            Exception unhandledException = null;

            Monitor.Enter(socket);
            //
            // Accept Callback - called on the callback path, when we expect to release
            //  an accept socket that winsock says has completed.
            //
            //  While we still have items in our Queued list of Accept Requests,
            //   we recall the Winsock accept, to attempt to gather new
            //   results, and then match them again the queued items,
            //   when accept call returns would_block, we reinvoke ourselves
            //   and rewait for the next asyc callback.
            //
            //  If we have emptied the queue, then disable the queue and go back
            //   to sync.
            //
            socket.incallback = true;

            //
            //  Attempt to process queued Accept async
            //
            while (socket.AcceptQueue.Count != 0) {  // if ! empty
                //
                // pick an element from the head of the list
                //
                AcceptAsyncResult AResult = (AcceptAsyncResult)socket.AcceptQueue[0];
                socket.AcceptQueue.RemoveAt(0);

                Monitor.Exit(socket);

                int Status = SocketErrors.WSAENOTSOCK;
                SocketAddress socketAddress = null;
                IntPtr AcceptResult = (IntPtr) 0;

                if (!socket.CleanedUp) 
                {
                    socketAddress = socket.m_RightEndPoint.Serialize();

                    AcceptResult =
                        UnsafeNclNativeMethods.OSSOCK.accept(
                            socket.m_Handle,
                            socketAddress.m_Buffer,
                            ref socketAddress.m_Size );

                    Status = AcceptResult == SocketErrors.InvalidSocketIntPtr ? Marshal.GetLastWin32Error() : 0;
                }                

                GlobalLog.Print("Socket#" + ValidationHelper.HashString(socket) + "::AcceptCallback() UnsafeNclNativeMethods.OSSOCK.accept returns:" + Status.ToString());

                //
                // now check for synchronous completion
                //
                if (Status == 0) {
                    //
                    // on synchronous completion give our async callback
                    // the accepted Socket right away
                    //

                    try {
                        AResult.InvokeCallback(false, socket.CreateAcceptSocket(AcceptResult, socket.m_RightEndPoint.Create(socketAddress)));
                    } catch (Exception exception) {
                        unhandledException = new InvalidOperationException("AcceptCallback", exception);
                    }
                }
                else if (Status == SocketErrors.WSAEWOULDBLOCK) {

                    Monitor.Enter(socket);

                    socket.AcceptQueue.Add(AResult);

                    ThreadPool.RegisterWaitForSingleObject(
                                                          socket.m_AsyncEvent,
                                                          new WaitOrTimerCallback(AcceptCallback),
                                                          thisAsyncResult,
                                                          -1,
                                                          true );

                    socket.incallback = false;
                    Monitor.Exit(socket);
                    return;
                }
                else
                {
                    try {
                        AResult.ErrorCode = Status;
                        AResult.InvokeCallback(false, null);
                    } catch (Exception exception) {
                        unhandledException = new InvalidOperationException("AcceptCallback", exception);
                    }
                }
                //
                // Attempt to accept another socket
                //
                Monitor.Enter(socket);
            }

            socket.incallback = false;
            //
            // the accept queue is empty.
            // cancel async event
            //
            socket.SetAsyncEventSelect(AsyncEventBits.FdNone);
            //
            // go back to blocking mode
            //
            socket.InternalSetBlocking(true);

            Monitor.Exit(socket);

            if (unhandledException != null) {
                throw unhandledException;
            }
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

    } // class AcceptAsyncResult




} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\_connectasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_ConnectAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.Net.Sockets;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Threading;

    internal enum AsyncEventBitsPos {
        FdReadBit                     = 0,
        FdWriteBit                    = 1,
        FdOobBit                      = 2,    
        FdAcceptBit                   = 3,
        FdConnectBit                  = 4,
        FdCloseBit                    = 5,
        FdQosBit                      = 6,
        FdGroupQosBit                 = 7,
        FdRoutingInterfaceChangeBit   = 8,
        FdAddressListChangeBit        = 9,
        FdMaxEvents                   = 10,
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NetworkEvents {
        //
        // Indicates which of the FD_XXX network events have occurred.
        //
        public AsyncEventBits Events;
        //
        // An array that contains any associated error codes, with an array index that corresponds to the position of event bits in lNetworkEvents. The identifiers FD_READ_BIT, FD_WRITE_BIT and other can be used to index the iErrorCode array.
        //
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=(int)AsyncEventBitsPos.FdMaxEvents)]
        public int[] ErrorCodes; 
    }

    internal class ConnectAsyncResult : LazyAsyncResult {

        private static readonly WaitOrTimerCallback m_ConnectCallback = new WaitOrTimerCallback(ConnectCallback);

        //
        // internal Constructor
        //
        internal ConnectAsyncResult(Socket socket, object stateObject, AsyncCallback callback)
            : base(socket, stateObject, callback) {
        }

        //
        // This method is called after an asynchronous call is made for the user,
        // it checks and acts accordingly if the IO:
        // 1) completed synchronously.
        // 2) was pended.
        // 3) failed.
        //
        internal void CheckAsyncCallResult(int status) {

            Socket socket = (Socket)AsyncObject;

            switch (status) {
                
                case SocketErrors.Success:
                    //
                    // the Async IO call completed synchronously:
                    //
                    break;

                case SocketErrors.WSAEWOULDBLOCK:
                    //
                    // the Async IO call was pended:
                    // Queue our event to the thread pool.
                    //
                    GlobalLog.Assert(
                        socket.m_AsyncEvent!=null,
                        "ConnectAsyncResult: m_AsyncConnectEvent == null", string.Empty);

                    ThreadPool.RegisterWaitForSingleObject(
                                                          socket.m_AsyncEvent,
                                                          m_ConnectCallback,
                                                          this,
                                                          -1,
                                                          true );

                    //
                    // we're done, return
                    //
                    return;

                default:
                    //
                    // the Async IO call failed:
                    // set the Result to the Win32 error
                    //
                    ErrorCode = status;
                    break;
            }
            //
            // cancel async event
            //
            socket.SetAsyncEventSelect(AsyncEventBits.FdNone);
            //
            // go back to blocking mode
            //
            socket.InternalSetBlocking(true);
            if (status==SocketErrors.Success) {
                //
                // synchronously complete the IO and call the user's callback.
                //
                InvokeCallback(true);
            }
        }


        //
        // This is the static internal callback that will be called when
        // the IO we issued for the user to winsock has completed, either
        // synchronously (Signaled=false) or asynchronously (Signaled=true)
        // when this function gets called it must:
        // 1) update the AsyncResult object with the results of the completed IO
        // 2) signal events that the user might be waiting on
        // 3) cal the callback function that the user might have specified
        //
        internal static void ConnectCallback(object stateObject, bool Signaled) {
            ConnectAsyncResult asyncResult = stateObject as ConnectAsyncResult;
            Socket socket = asyncResult.AsyncObject as Socket;

            GlobalLog.Enter("Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback", "Signaled:" + Signaled.ToString());

            GlobalLog.Assert(!asyncResult.IsCompleted, "Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback() asyncResult.IsCompleted", "");

            //
            // we now need to get the status of the async completion, we had an easy implementation
            // that uses GetSocketOption(), but VadimE suggested not to use this 'cause it may be
            // buggy on some platforms, so we use WSAEnumNetworkEvents() instead:
            //
            // The best way to do this is to call WSAEnumNetworkEvents and use the error code iError
            // array corresponding to FD_CONNECT. getsockopt (SO_ERROR) may return NO_ERROR under
            // stress even in case of error at least on Winnt4.0 (I don't remember whether I fixed
            // it on Win2000 or WinXP).
            //

            //
            // get async completion
            //
            /*
            int errorCode = (int)socket.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Error);
            GlobalLog.Print("Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback() GetSocketOption() returns errorCode:" + errorCode.ToString());
            */

            NetworkEvents networkEvents = new NetworkEvents();
            networkEvents.Events = AsyncEventBits.FdConnect;

            AutoResetEvent chkAsyncEvent = socket.m_AsyncEvent;

            int errorCode = SocketErrors.WSAENOTSOCK;

            if (chkAsyncEvent!=null) {
                errorCode =
                    UnsafeNclNativeMethods.OSSOCK.WSAEnumNetworkEvents(
                        socket.m_Handle,
                        chkAsyncEvent.Handle,
                        ref networkEvents );

                if (errorCode!=SocketErrors.Success) {
                    errorCode = Marshal.GetLastWin32Error();
                    GlobalLog.Print("Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback() WSAEnumNetworkEvents() failed with errorCode:" + errorCode.ToString());
                }
                else {
                    errorCode = networkEvents.ErrorCodes[(int)AsyncEventBitsPos.FdConnectBit];
                    GlobalLog.Print("Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback() ErrorCodes(FdConnect) got errorCode:" + errorCode.ToString());
                }
            }

            try {
                //
                // cancel async event
                //
                socket.SetAsyncEventSelect(AsyncEventBits.FdNone);
                //
                // go back to blocking mode
                //
                socket.InternalSetBlocking(true);
            }
            catch (Exception exception) {
                GlobalLog.Print("Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback() caught exception::" + exception.Message);
                asyncResult.Result = exception;
            }

            //
            // if the native non-blocking call failed we'll throw a SocketException in EndConnect()
            //
            if (errorCode!=SocketErrors.Success) {
                //
                // just save the error code, the SocketException will be thrown in EndConnect()
                //
                asyncResult.ErrorCode = errorCode;
            }
            else {
                //
                // the Socket is connected, update our state and performance counter
                //
                socket.SetToConnected();
            }

            //
            // call the user's callback now, if there is one.
            //
            asyncResult.InvokeCallback(false);

            GlobalLog.Leave("Socket#" + ValidationHelper.HashString(socket) + "::ConnectCallback", errorCode.ToString());
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

    }; // class ConnectAsyncResult



} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\udpclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="UDPClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Net.Sockets {

    /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The <see cref='System.Net.Sockets.UdpClient'/> class provides access to UDP services at a
    ///       higher abstraction level than the <see cref='System.Net.Sockets.Socket'/> class. <see cref='System.Net.Sockets.UdpClient'/>
    ///       is used to connect to a remote host and to receive connections from a remote
    ///       Client.
    ///    </para>
    /// </devdoc>
    public class UdpClient : IDisposable {

        private const int MaxUDPSize = 0x10000;  
        private Socket m_ClientSocket;
        private bool m_Active;
        private byte[] m_Buffer = new byte[MaxUDPSize];
        /// <devdoc>
        ///    <para>
        ///       Address family for the client, defaults to IPv4.
        ///    </para>
        /// </devdoc>
        private AddressFamily m_Family = AddressFamily.InterNetwork;

        // bind to arbitrary IP+Port
        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.UdpClient"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.Sockets.UdpClient'/>class.
        ///    </para>
        /// </devdoc>
        public UdpClient() : this(AddressFamily.InterNetwork) {
        }

        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Net.Sockets.UdpClient'/>class.
        ///    </para>
        /// </devdoc>
#if COMNET_DISABLEIPV6
        private UdpClient(AddressFamily family) {
#else
        public UdpClient(AddressFamily family) {
#endif
            //
            // Validate the address family
            //
            if ( family != AddressFamily.InterNetwork && family != AddressFamily.InterNetworkV6 ) {
                throw new ArgumentException("family");
            }

            m_Family = family;

            createClientSocket();
        }

        // bind specific port, arbitrary IP
        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.UdpClient1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the UdpClient class that communicates on the
        ///       specified port number.
        ///    </para>
        /// </devdoc>
        public UdpClient(int port) : this(port,AddressFamily.InterNetwork) {
        }

        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the UdpClient class that communicates on the
        ///       specified port number.
        ///    </para>
        /// </devdoc>
#if COMNET_DISABLEIPV6
        private UdpClient(int port,AddressFamily family) {
#else
        public UdpClient(int port,AddressFamily family) {
#endif
            //
            // parameter validation
            //
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            //
            // Validate the address family
            //
            if ( family != AddressFamily.InterNetwork && family != AddressFamily.InterNetworkV6 ) {
                throw new ArgumentException("family");
            }

            IPEndPoint localEP;
            m_Family = family;
             
            if ( m_Family == AddressFamily.InterNetwork ) {
                localEP = new IPEndPoint(IPAddress.Any, port);
            }
            else {
                localEP = new IPEndPoint(IPAddress.IPv6Any, port);
            }

            createClientSocket();

            Client.Bind(localEP);
        }

        // bind to given local endpoint
        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.UdpClient2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the UdpClient class that communicates on the
        ///       specified end point.
        ///    </para>
        /// </devdoc>
        public UdpClient(IPEndPoint localEP) {
            //
            // parameter validation
            //
            if (localEP == null) {
                throw new ArgumentNullException("localEP");
            }
            //
            // IPv6 Changes: Set the AddressFamily of this object before
            //               creating the client socket.
            //
            m_Family = localEP.AddressFamily;

            createClientSocket();

            Client.Bind(localEP);
        }

        // bind and connect
        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.UdpClient3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Net.Sockets.UdpClient'/> class and connects to the
        ///       specified remote host on the specified port.
        ///    </para>
        /// </devdoc>
        public UdpClient(string hostname, int port) {
            //
            // parameter validation
            //
            if (hostname == null) {
                throw new ArgumentNullException("hostname");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }
            //
            // NOTE: Need to create different kinds of sockets based on the addresses
            //       returned from DNS. As a result, we defer the creation of the 
            //       socket until the Connect method.
            //
            //createClientSocket();
            Connect(hostname, port);
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Client"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to provide the underlying network socket.
        ///    </para>
        /// </devdoc>
        protected Socket Client {
            get {
                return m_ClientSocket;
            }
            set {
                m_ClientSocket = value;
            }
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Active"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used by the class to indicate that a connection to a remote host has been
        ///       made.
        ///    </para>
        /// </devdoc>
        protected bool Active {
            get {
                return m_Active;
            }
            set {
                m_Active = value;
            }
        }

        //UEUE
        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Close"]/*' />
        public void Close() {
            GlobalLog.Print("UdpClient::Close()");
            this.FreeResources();
            GC.SuppressFinalize(this);
        }
        private bool m_CleanedUp = false;
        private void FreeResources() {
            //
            // only resource we need to free is the network stream, since this
            // is based on the client socket, closing the stream will cause us
            // to flush the data to the network, close the stream and (in the
            // NetoworkStream code) close the socket as well.
            //
            if (m_CleanedUp) {
                return;
            }

            Socket chkClientSocket = Client;
            if (chkClientSocket!=null) {
                //
                // if the NetworkStream wasn't retrieved, the Socket might
                // still be there and needs to be closed to release the effect
                // of the Bind() call and free the bound IPEndPoint.
                //
                chkClientSocket.InternalShutdown(SocketShutdown.Both);
                chkClientSocket.Close();
                Client = null;
            }
            m_CleanedUp = true;
        }
        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            this.Close();
        }


        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Connect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Establishes a connection to the specified port on the
        ///       specified host.
        ///    </para>
        /// </devdoc>
        public void Connect(string hostname, int port) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }

            //
            // IPv6 Changes: instead of just using the first address in the list,
            //               we must now look for addresses that use a compatible
            //               address family to the client socket.
            //               However, in the case of the <hostname,port> constructor
            //               we will have deferred creating the socket and will
            //               do that here instead.
            //               In addition, the redundant CheckForBroadcast call was
            //               removed here since it is called from Connect().
            //
            IPHostEntry host = Dns.Resolve(hostname);

            foreach (IPAddress address in host.AddressList) {
                if ( m_ClientSocket == null ) {
                    //
                    // We came via the <hostname,port> constructor. Set the
                    // address family appropriately, create the socket and
                    // try to connect.
                    //
                    m_Family = address.AddressFamily;

                    createClientSocket();

                    try
                    {
                        //
                        // Attempt to connect to the host
                        //
                        Connect( new IPEndPoint(address,port) );

                        break;
                    }
                    catch ( SocketException )
                    {
                        //
                        // Destroy the client socket here for retry with
                        // the next address.
                        //
                        m_ClientSocket.InternalShutdown(SocketShutdown.Both);
                        m_ClientSocket.Close();
                        m_ClientSocket = null;
                    }
                }
                else if ( address.AddressFamily == m_Family ) {
                    //
                    // Only use addresses with a matching family
                    //
                    try
                    {
                        //
                        // Attempt to connect to the host
                        //
                        Connect( new IPEndPoint(address,port) );

                        break;
                    }
                    catch ( SocketException )
                    {
                        //
                        // Intentionally empty - all set to retry the next address
                        //
                    }
                }
            }
            //
            // m_Active tells us whether we managed to connect
            //
            if ( !m_Active ) {
                //
                // UNDONE: The Connect failed, we need to throw and exception
                //         here. Need to determine which is the correct error
                //         code to throw.
                //
                throw new SocketException(SocketErrors.WSAENOTCONN);
            }
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Connect1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Establishes a connection with the host at the specified address on the
        ///       specified port.
        ///    </para>
        /// </devdoc>
        public void Connect(IPAddress addr, int port) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (addr==null){
                throw new ArgumentNullException("addr");
            }
            if (!ValidationHelper.ValidateTcpPort(port)) {
                throw new ArgumentOutOfRangeException("port");
            }

            //
            // IPv6 Changes: Removed redundant call to CheckForBroadcast() since
            //               it is made in the real Connect() method.
            //
            IPEndPoint endPoint = new IPEndPoint(addr, port);

            Connect(endPoint);
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Connect2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Establishes a connection to a remote end point.
        ///    </para>
        /// </devdoc>
        public void Connect(IPEndPoint endPoint) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (endPoint==null){
                throw new ArgumentNullException("endPoint");
            }
            //
            // IPv6 Changes: Actually, no changes but we might want to check for 
            //               compatible protocols here rather than push it down
            //               to WinSock.
            //
            CheckForBroadcast(endPoint.Address);
            Client.Connect(endPoint);
            m_Active = true;
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Send"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends a UDP datagram to the host at the remote end point.
        ///    </para>
        /// </devdoc>
        public int Send(byte[] dgram, int bytes, IPEndPoint endPoint) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (dgram==null){
                throw new ArgumentNullException("dgram");
            }
            if (m_Active && endPoint!=null) {
                //
                // Do not allow sending packets to arbitrary host when connected
                //
                throw new InvalidOperationException(SR.GetString(SR.net_udpconnected));
            }

            if (endPoint==null) {
                return Client.Send(dgram, 0, bytes, SocketFlags.None);
            }

            CheckForBroadcast(endPoint.Address);

            return Client.SendTo(dgram, 0, bytes, SocketFlags.None, endPoint);
        }

        private bool m_IsBroadcast;
        private void CheckForBroadcast(IPAddress ipAddress) {
            //
            // RAID#83173
            // mauroot: 05/01/2001 here we check to see if the user is trying to use a Broadcast IP address
            // we only detect IPAddress.Broadcast (which is not the only Broadcast address)
            // and in that case we set SocketOptionName.Broadcast on the socket to allow its use.
            // if the user really wants complete control over Broadcast addresses he needs to
            // inherit from UdpClient and gain control over the Socket and do whatever is appropriate.
            //
            if (Client!=null && !m_IsBroadcast && ipAddress.IsBroadcast) {
                //
                // we need to set the Broadcast socket option.
                // note that, once we set the option on the Socket, we never reset it.
                //
                m_IsBroadcast = true;
                Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, 1);
            }
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Send1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends a UDP datagram to the specified port on the specified remote host.
        ///    </para>
        /// </devdoc>
        public int Send(byte[] dgram, int bytes, string hostname, int port) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (dgram==null){
                throw new ArgumentNullException("dgram");
            }
            if (m_Active && ((hostname != null) || (port != 0))) {
                //
                // Do not allow sending packets to arbitrary host when connected
                //
                throw new InvalidOperationException(SR.GetString(SR.net_udpconnected));
            }

            if (hostname==null || port==0) {
                return Client.Send(dgram, 0, bytes, SocketFlags.None);
            }

            IPAddress address = Dns.Resolve(hostname).AddressList[0];

            CheckForBroadcast(address);

            IPEndPoint ipEndPoint = new IPEndPoint(address, port);

            return Client.SendTo(dgram, 0, bytes, SocketFlags.None, ipEndPoint);
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Send2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends a UDP datagram to a
        ///       remote host.
        ///    </para>
        /// </devdoc>
        public int Send(byte[] dgram, int bytes) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (dgram==null){
                throw new ArgumentNullException("dgram");
            }
            if (!m_Active) {
                //
                // only allowed on connected socket
                //
                throw new InvalidOperationException(SR.GetString(SR.net_notconnected));
            }

            return Client.Send(dgram, 0, bytes, SocketFlags.None);

        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.Receive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a datagram sent by a server.
        ///    </para>
        /// </devdoc>
        public byte[] Receive(ref IPEndPoint remoteEP) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            // this is a fix due to the nature of the ReceiveFrom() call and the 
            // ref parameter convention, we need to cast an IPEndPoint to it's base
            // class EndPoint and cast it back down to IPEndPoint. ugly but it works.
            //
            EndPoint tempRemoteEP;
            
            if ( m_Family == AddressFamily.InterNetwork ) {
                tempRemoteEP = IPEndPoint.Any;
            }
            else {
                tempRemoteEP = IPEndPoint.IPv6Any;
            }

            int received = Client.ReceiveFrom(m_Buffer, MaxUDPSize, 0 , ref tempRemoteEP);
            remoteEP = (IPEndPoint)tempRemoteEP;


            // because we don't return the actual length, we need to ensure the returned buffer
            // has the appropriate length.

            if (received < MaxUDPSize) {
                byte[] newBuffer = new byte[received];
                Buffer.BlockCopy(m_Buffer,0,newBuffer,0,received);
                return newBuffer;
            }
            return m_Buffer;
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.JoinMulticastGroup"]/*' />
        ///     <devdoc>
        ///         <para>
        ///             Joins a multicast address group.
        ///         </para>
        ///     </devdoc>
        public void JoinMulticastGroup(IPAddress multicastAddr) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            //
            // IPv6 Changes: we need to create the correct MulticastOption and
            //               must also check for address family compatibility
            //
            if ( multicastAddr.AddressFamily != m_Family ) {
                throw new ArgumentException("multicastAddr");
            }

            if ( m_Family == AddressFamily.InterNetwork ) {
                MulticastOption mcOpt = new MulticastOption(multicastAddr);

                Client.SetSocketOption(
                    SocketOptionLevel.IP,
                    SocketOptionName.AddMembership,
                    mcOpt );
            }
            else {
                IPv6MulticastOption mcOpt = new IPv6MulticastOption(multicastAddr);

                Client.SetSocketOption(
                    SocketOptionLevel.IPv6,
                    SocketOptionName.AddMembership,
                    mcOpt );
            }
        }

        ///     <devdoc>
        ///         <para>
        ///             Joins an IPv6 multicast address group.
        ///         </para>
        ///     </devdoc>
#if COMNET_DISABLEIPV6
        private void JoinMulticastGroup(int ifindex,IPAddress multicastAddr) {
#else
        public void JoinMulticastGroup(int ifindex,IPAddress multicastAddr) {
#endif
            //
            // parameter validation
            //
            if ( m_CleanedUp ){
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            if ( multicastAddr==null ) {
                throw new ArgumentNullException("multicastAddr");
            }

            if ( ifindex < 0 ) {
                throw new ArgumentException("ifindex");
            }

            //
            // Ensure that this is an IPv6 client, otherwise throw WinSock 
            // Operation not supported socked exception.
            //
            if ( m_Family != AddressFamily.InterNetworkV6 ) {
                throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
            }

            IPv6MulticastOption mcOpt = new IPv6MulticastOption(multicastAddr,ifindex);

            Client.SetSocketOption(
                SocketOptionLevel.IPv6,
                SocketOptionName.AddMembership,
                mcOpt );
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.JoinMulticastGroup1"]/*' />
        /// <devdoc>
        ///     <para>
        ///         Joins a multicast address group with the specified time to live (TTL).
        ///     </para>
        /// </devdoc>
        public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive) {
            //
            // parameter validation;
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (multicastAddr==null){
                throw new ArgumentNullException("multicastAddr");
            }
            if (!ValidationHelper.ValidateRange(timeToLive, 0, 255)) {
                throw new ArgumentOutOfRangeException("timeToLive");
            }

            //
            // join the Multicast Group
            //
            JoinMulticastGroup(multicastAddr);

            //
            // set Time To Live (TLL)
            //
            Client.SetSocketOption(
                (m_Family == AddressFamily.InterNetwork) ? SocketOptionLevel.IP : SocketOptionLevel.IPv6,
                SocketOptionName.MulticastTimeToLive,
                timeToLive );
        }

        /// <include file='doc\UDPClient.uex' path='docs/doc[@for="UdpClient.DropMulticastGroup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Leaves a multicast address group.
        ///    </para>
        /// </devdoc>
        public void DropMulticastGroup(IPAddress multicastAddr) {
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }
            if (multicastAddr==null){
                throw new ArgumentNullException("multicastAddr");
            }

            //
            // IPv6 Changes: we need to create the correct MulticastOption and
            //               must also check for address family compatibility
            //
            if ( multicastAddr.AddressFamily != m_Family ) {
                throw new ArgumentException("multicastAddr");
            }

            if ( m_Family == AddressFamily.InterNetwork ) {
                MulticastOption mcOpt = new MulticastOption(multicastAddr);

                Client.SetSocketOption(
                    SocketOptionLevel.IP,
                    SocketOptionName.DropMembership,
                    mcOpt );
            }
            else {
                IPv6MulticastOption mcOpt = new IPv6MulticastOption(multicastAddr);

                Client.SetSocketOption(
                    SocketOptionLevel.IPv6,
                    SocketOptionName.DropMembership,
                    mcOpt );
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Leaves an IPv6 multicast address group.
        ///    </para>
        /// </devdoc>
#if COMNET_DISABLEIPV6
        private void DropMulticastGroup(IPAddress multicastAddr,int ifindex) {
#else
        public void DropMulticastGroup(IPAddress multicastAddr,int ifindex) {
#endif
            //
            // parameter validation
            //
            if (m_CleanedUp){
                throw new ObjectDisposedException(this.GetType().FullName);
            }

            if ( multicastAddr==null ) {
                throw new ArgumentNullException("multicastAddr");
            }

            if ( ifindex < 0 ) {
                throw new ArgumentException("ifindex");
            }

            //
            // Ensure that this is an IPv6 client, otherwise throw WinSock 
            // Operation not supported socked exception.
            //
            if ( m_Family != AddressFamily.InterNetworkV6 ) {
                throw new SocketException(SocketErrors.WSAEOPNOTSUPP);
            }

            IPv6MulticastOption mcOpt = new IPv6MulticastOption(multicastAddr,ifindex);

            Client.SetSocketOption(
                SocketOptionLevel.IPv6,
                SocketOptionName.DropMembership,
                mcOpt );
        }

        private void createClientSocket() {
            //
            // common initialization code
            //
            // IPv6 Changes: Use the AddressFamily of this class rather than hardcode.
            //
            Client = new Socket(m_Family, SocketType.Dgram, ProtocolType.Udp);
        }

    } // class UdpClient



} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\public\tools\inc\private\version\main\version.h ===
#define rmj              1
#define rmm              1
#define rup              4322
#define rpt              573
#define szVerName        ""
#define szVerUser        ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\public\tools\inc\private\version\version.h ===
#define rmj              1
#define rmm              1
#define rup              4322
#define rpt              573
#define szVerName        ""
#define szVerUser        ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexboyermoore.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexBoyerMoore.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The RegexBoyerMoore object precomputes the Boyer-Moore
 * tables for fast string scanning. These tables allow
 * you to scan for the first occurance of a string within
 * a large body of text without examining every character.
 * The performance of the heuristic depends on the actual
 * string and the text being searched, but usually, the longer
 * the string that is being searched for, the fewer characters
 * need to be examined.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      6/05/99 (dbau)      First draft
 */

namespace System.Text.RegularExpressions
{

    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;

    internal sealed class RegexBoyerMoore {
        internal int[] _positive;
        internal int[] _negativeASCII;
        internal int[][] _negativeUnicode;
        internal String _pattern;
        internal int _lowASCII;
        internal int _highASCII;
        internal bool _rightToLeft;
        internal bool _caseInsensitive;
        internal CultureInfo _culture;

        internal const int infinite = 0x7FFFFFFF;

        /*
         * Constructs a Boyer-Moore state machine for searching for the string
         * pattern. The string must not be zero-length.
         */
        internal RegexBoyerMoore(String pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture) {
            /*
             * Sorry,  you just can't use Boyer-Moore to find an empty pattern.
             * We're doing this for your own protection. (Really, for speed.)
             */
            Debug.Assert(pattern.Length != 0, "RegexBoyerMoore called with an empty string.  This is bad for perf");

            int beforefirst;
            int last;
            int bump;
            int examine;
            int scan;
            int match;
            char ch;

            
            if (caseInsensitive)
                pattern = pattern.ToLower(culture);

            _pattern = pattern;
            _rightToLeft = rightToLeft;
            _caseInsensitive = caseInsensitive;
            _culture = culture;
            
            if (!rightToLeft) {
                beforefirst = -1;
                last = pattern.Length - 1;
                bump = 1;
            }
            else {
                beforefirst = pattern.Length;
                last = 0;
                bump = -1;
            }

            /*
             * PART I - the good-suffix shift table
             * 
             * compute the positive requirement:
             * if char "i" is the first one from the right that doesn't match,
             * then we know the matcher can advance by _positive[i].
             *
             * Davidgut 8/2001: This algorithm appears to be a simplified variant of the 
             *                  standard Boyer-Moore good suffix calculation.  It could
             *                  be one of D.M. Sunday's variations, but I have not found which one.
             *
             * CONSIDER: Maybe in v2 rewrite this with the real Boyer-Moore algorithm and split it
             *           out into a separate piece of code in the BCL.
             */
            _positive = new int[pattern.Length];

            examine = last;
            ch = pattern[examine];
            _positive[examine] = bump;
            examine -= bump;

            for (;;) {
                // find an internal char (examine) that matches the tail

                for (;;) {
                    if (examine == beforefirst)
                        goto OuterloopBreak;
                    if (pattern[examine] == ch)
                        break;
                    examine -= bump;
                }

                match = last;
                scan = examine;

                // find the length of the match

                for (;;) {
                    if (scan == beforefirst || pattern[match] != pattern[scan]) {
                        // at the end of the match, note the difference in _positive
                        // this is not the length of the match, but the distance from the internal match
                        // to the tail suffix. 
                        if (_positive[match] == 0)
                            _positive[match] = match - scan;

                        // System.Diagnostics.Debug.WriteLine("Set positive[" + match + "] to " + (match - scan));

                        break;
                    }

                    scan -= bump;
                    match -= bump;
                }

                examine -= bump;
            }

            OuterloopBreak:

            match = last - bump;

            // scan for the chars for which there are no shifts that yield a different candidate

            /* 
             *  Davidgut 8/2001: The inside of the if statement used to say 
             *                   "_positive[match] = last - beforefirst;"
             *                   Per bug ASURT 101422, I've changed it to the below code.  This
             *                   is slightly less agressive in how much we skip, but at worst it 
             *                   should mean a little more work rather than skipping a potential
             *                   match.
             */
            while (match != beforefirst) {
                if (_positive[match] == 0)
                    _positive[match] = bump;

                match -= bump;
            }

            //System.Diagnostics.Debug.WriteLine("good suffix shift table:");
            //for (int i=0; i<_positive.Length; i++)
            //    System.Diagnostics.Debug.WriteLine("\t_positive[" + i + "] = " + _positive[i]);
                

            /*
             * PART II - the bad-character shift table
             * 
             * compute the negative requirement:
             * if char "ch" is the reject character when testing position "i",
             * we can slide up by _negative[ch];
             * (_negative[ch] = str.Length - 1 - str.LastIndexOf(ch))
             *
             * the lookup table is divided into ASCII and Unicode portions;
             * only those parts of the Unicode 16-bit code set that actually
             * appear in the string are in the table. (Maximum size with
             * Unicode is 65K; ASCII only case is 512 bytes.)
             */

            _negativeASCII = new int[128];

            for (int i = 0; i < 128; i++)
                _negativeASCII[i] = last - beforefirst;

            _lowASCII = 127;
            _highASCII = 0;

            for (examine = last; examine != beforefirst; examine -= bump) {
                ch = pattern[examine];

                // HACKHACK: chars are signed!!

                if (ch >= 0 && ch < 128) {
                    if (_lowASCII > ch)
                        _lowASCII = ch;

                    if (_highASCII < ch)
                        _highASCII = ch;

                    if (_negativeASCII[ch] == last - beforefirst)
                        _negativeASCII[ch] = last - examine;
                }
                else {
                    int i = ch >> 8;
                    int j = ch & 0xFF;

                    if (_negativeUnicode == null) {
                        _negativeUnicode = new int[256][];

                        // HACKHACK: SMC inits all entries to int[0]s instead of null!

                        for (int k = 0; k < 256; k++)
                            _negativeUnicode[k] = null;
                    }

                    if (_negativeUnicode[i] == null) {
                        int[] newarray = new int[256];

                        for (int k = 0; k < 256; k++)
                            newarray[k] = last - beforefirst;

                        if (i == 0) {
                            System.Array.Copy(_negativeASCII, newarray, 128);
                            _negativeASCII = newarray;
                        }

                        _negativeUnicode[i] = newarray;
                    }

                    if (_negativeUnicode[i][j] == last - beforefirst)
                        _negativeUnicode[i][j] = last - examine;
                }
            }
        }

        /*
         * When a regex is anchored, we can do a quick IsMatch test instead of a Scan
         */
        internal bool IsMatch(String text, int index, int beglimit, int endlimit) {
           
            if (!_rightToLeft) {
                if (index < beglimit || endlimit - index < _pattern.Length)
                    return false;

                return(0 == String.Compare(_pattern, 0, text, index, _pattern.Length, _caseInsensitive, _culture));
            }
            else {
                if (index > endlimit || index - beglimit < _pattern.Length)
                    return false;

                return(0 == String.Compare(_pattern, 0, text, index - _pattern.Length, _pattern.Length, _caseInsensitive, _culture));
            }
        }


        /*
         * Scan uses the Boyer-Moore algorithm to find the first occurrance
         * of the specified string within text, beginning at index, and
         * constrained within beglimit and endlimit.
         *
         * The direction and case-sensitivity of the match is determined
         * by the arguments to the RegexBoyerMoore constructor.
         */
        internal int Scan(String text, int index, int beglimit, int endlimit) {
            int test;
            int test2;
            int match;
            int startmatch;
            int endmatch;
            int advance;
            int defadv;
            int bump;
            char chMatch;
            char chTest;
            int[] unicodeLookup;

            if (!_rightToLeft) {
                defadv = _pattern.Length;
                startmatch = _pattern.Length - 1;
                endmatch = 0;
                test = index + defadv - 1;
                bump = 1;
            }
            else {
                defadv = -_pattern.Length;
                startmatch = 0;
                endmatch = -defadv - 1;
                test = index + defadv;
                bump = -1;
            }

            chMatch = _pattern[startmatch];

            for (;;) {
                if (test >= endlimit || test < beglimit)
                    return -1;

                chTest = text[test];

                if (_caseInsensitive)
                    chTest = Char.ToLower(chTest, _culture);

                if (chTest != chMatch) {
                    // HACKHACK chars should be unsigned (dbau)
                    // so this should just read "if (ch < 128)"

                    if ((chTest & 0xFF80) == 0)
                        advance = _negativeASCII[chTest];
                    else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))
                        advance = unicodeLookup[chTest & 0xFF];
                    else
                        advance = defadv;

                    test += advance;
                }
                else { // if (chTest == chMatch)
                    test2 = test;
                    match = startmatch;

                    for (;;) {
                        if (match == endmatch)
                            return(_rightToLeft ? test2 + 1 : test2);

                        match -= bump;
                        test2 -= bump;

                        chTest = text[test2];

                        if (_caseInsensitive)
                            chTest = Char.ToLower(chTest, _culture);

                        if (chTest != _pattern[match]) {
                            advance = _positive[match];
                            if ((chTest & 0xFF80) == 0)
                                test2 = (match - startmatch) + _negativeASCII[chTest];
                            else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))
                                test2 = (match - startmatch) + unicodeLookup[chTest & 0xFF];
                            else {
                                test += advance;
                                break;
                            }

                            if (_rightToLeft ? test2 < advance : test2 > advance)
                                advance = test2;

                            test += advance;
                            break;
                        }
                    }
                }
            }
        }

        /*
         * Used when dumping for debugging.
         */
        public override String ToString() {
            return _pattern;
        }

#if DBG
        public String Dump(String indent) {
            StringBuilder sb = new StringBuilder();

            sb.Append(indent + "BM Pattern: " + _pattern + "\n");
            sb.Append(indent + "Positive: ");
            for (int i = 0; i < _positive.Length; i++) {
                sb.Append(_positive[i].ToString() + " ");
            }
            sb.Append("\n");

            if (_negativeASCII != null) {
                sb.Append(indent + "Negative table\n");
                for (int i = 0; i < _negativeASCII.Length; i++) {
                    if (_negativeASCII[i] != _pattern.Length) {
                        sb.Append(indent + "  " + Regex.Escape(Convert.ToString((char)i)) + " " + _negativeASCII[i].ToString() + "\n");
                    }
                }
            }

            return sb.ToString();
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regex.cs ===
//------------------------------------------------------------------------------
// <copyright file="Regex.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The Regex class represents a single compiled instance of a regular
 * expression.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *  5/04/99 (dbau)      First draft
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System;
    using System.Threading;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Globalization;
    using System.Security.Policy;

    /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an immutable, compiled regular expression. Also
    ///       contains static methods that allow use of regular expressions without instantiating
    ///       a Regex explicitly.
    ///    </para>
    /// </devdoc>
    [ Serializable() ] 
    public class Regex : ISerializable {

        // Fields used by precompiled regexes
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.pattern"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal string pattern;
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.factory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal RegexRunnerFactory factory;       // if compiled, this is the RegexRunner subclass
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.roptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal RegexOptions roptions;            // the top-level options from the options string
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.caps"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal Hashtable caps;                   // if captures are sparse, this is the hashtable capnum->index
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.capnames"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal Hashtable capnames;               // if named captures are used, this maps names->index
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.capslist"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal String[]  capslist;               // if captures are sparse or named captures are used, this is the sorted list of names
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.capsize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal int       capsize;                // the size of the capture array

        internal  ExclusiveReference runnerref;              // cached runner
        internal  SharedReference    replref;                // cached parsed replacement pattern
        internal  RegexCode          code;                   // if interpreted, this is the code for RegexIntepreter
        internal  CachedCodeEntry    cachedentry;
        internal  bool refsInitialized = false;

        internal static Hashtable livecode = new Hashtable();// the cached of code and factories that are currently loaded

#if ECMA
        internal const int MaxOptionShift = 10;
#else 
        internal const int MaxOptionShift = 9;
#endif

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Regex2"]/*' />
        protected Regex() {
        }

        /*
         * Compiles and returns a Regex object corresponding to the given pattern
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Regex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates and compiles a regular expression object for the specified regular
        ///       expression.
        ///    </para>
        /// </devdoc>
        public Regex(String pattern) : this(pattern, RegexOptions.None) {
        }

        /*
         * Returns a Regex object corresponding to the given pattern, compiled with
         * the specified options.
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Regex1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates and compiles a regular expression object for the
        ///       specified regular expression
        ///       with options that modify the pattern.
        ///    </para>
        /// </devdoc>
        public Regex(String pattern, RegexOptions options) {
            RegexTree tree;
            CachedCodeEntry cached;

            if (pattern == null) 
                throw new ArgumentNullException("pattern");


            if (options < RegexOptions.None || ( ((int) options) >> MaxOptionShift) != 0)
                throw new ArgumentOutOfRangeException("options");
#if ECMA
            if ((options &   RegexOptions.ECMAScript) != 0
             && (options & ~(RegexOptions.ECMAScript | RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled | RegexOptions.CultureInvariant
#if DBG
                           | RegexOptions.Debug
#endif
                                               )) != 0)
                throw new ArgumentOutOfRangeException("options");
#endif

            String key = ((int) options).ToString(NumberFormatInfo.InvariantInfo) + ":" + pattern;

            cached = LookupCached(key);

            this.pattern = pattern;
            this.roptions = options;

            if (cached == null) {
                // Parse the input
                tree = RegexParser.Parse(pattern, roptions);

                // Extract the relevant information
                capnames   = tree._capnames;
                capslist   = tree._capslist;
                code       = RegexWriter.Write(tree);
                caps       = code._caps;
                capsize    = code._capsize;

                InitializeReferences();

                tree = null;
                cachedentry= CacheCode(key);
            }
            else {
                caps       = cached._caps;
                capnames   = cached._capnames;
                capslist   = cached._capslist;
                capsize    = cached._capsize;
                code       = cached._code;
                factory    = cached._factory;
                runnerref  = cached._runnerref;
                replref    = cached._replref;
                refsInitialized = true;

                cachedentry     = cached;
            }

            // if the compile option is set, then compile the code if it's not already
            if (UseOptionC() && factory == null) {
                factory = Compile(code, roptions);
                cachedentry.AddCompiled(factory);
                code = null;
            }
        }

        /* 
         *  ISerializable constructor
         */
        private Regex(SerializationInfo info, StreamingContext context) : this(info.GetString("pattern"), (RegexOptions) info.GetInt32("options")) {
        }

        /* 
         *  ISerializable method
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            si.AddValue("pattern", this.ToString());
            si.AddValue("options", this.Options);
        }

        /* 
        * This method is here for perf reasons: if the call to RegexCompiler is NOT in the 
        * Regex constructor, we don't load RegexCompiler and its reflection classes when
        * instantiating a non-compiled regex
        * This method is internal virtual so the jit does not inline it.
        */
        internal virtual RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions) {
            return RegexCompiler.Compile(code, roptions);
        }

        /*
         * No refs -> we can release our ref on the cached code
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Finalize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ~Regex() {
            UncacheCode();
        }

        /*
         * Escape metacharacters within the string
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Escape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Escapes 
        ///          a minimal set of metacharacters (\, *, +, ?, |, {, [, (, ), ^, $, ., #, and
        ///          whitespace) by replacing them with their \ codes. This converts a string so that
        ///          it can be used as a constant within a regular expression safely. (Note that the
        ///          reason # and whitespace must be escaped is so the string can be used safely
        ///          within an expression parsed with x mode. If future Regex features add
        ///          additional metacharacters, developers should depend on Escape to escape those
        ///          characters as well.)
        ///       </para>
        ///    </devdoc>
        public static String Escape(String str) {
            if (str==null)
                throw new ArgumentNullException("str");
            
            return RegexParser.Escape(str);
        }

        /*
         * Unescape character codes within the string
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Unescape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Unescapes any escaped characters in the input string.
        ///    </para>
        /// </devdoc>
        public static String Unescape(String str) {
            if (str==null)
                throw new ArgumentNullException("str");
            
            return RegexParser.Unescape(str);
        }

        /*
         * True if the regex is leftward
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.RightToLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the regular expression matches from right to
        ///       left.
        ///    </para>
        /// </devdoc>
        public bool RightToLeft {
            get {
                return UseOptionR();
            }
        }

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the regular expression pattern passed into the constructor
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return pattern;
        }

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Options"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the options passed into the constructor
        ///    </para>
        /// </devdoc>
        public RegexOptions Options {
            get { return roptions;}
        }

        /*
         * Returns an array of the group names that are used to capture groups
         * in the regular expression. Only needed if the regex is not known until
         * runtime, and one wants to extract captured groups. (Probably unusual,
         * but supplied for completeness.)
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.GetGroupNames"]/*' />
        /// <devdoc>
        ///    Returns 
        ///       the GroupNameCollection for the regular expression. This collection contains the
        ///       set of strings used to name capturing groups in the expression. 
        ///    </devdoc>
        public String[] GetGroupNames() {
            String[] result;

            if (capslist == null) {
                int max = capsize;
                result = new String[max];

                for (int i = 0; i < max; i++) {
                    result[i] = Convert.ToString(i);
                }
            }
            else {
                result = new String[capslist.Length];

                System.Array.Copy(capslist, 0, result, 0, capslist.Length);
            }

            return result;
        }

        /*
         * Returns an array of the group numbers that are used to capture groups
         * in the regular expression. Only needed if the regex is not known until
         * runtime, and one wants to extract captured groups. (Probably unusual,
         * but supplied for completeness.)
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.GetGroupNumbers"]/*' />
        /// <devdoc>
        ///    returns 
        ///       the integer group number corresponding to a group name. 
        ///    </devdoc>
        public int[] GetGroupNumbers() {
            int[] result;

            if (caps == null) {
                int max = capsize;
                result = new int[max];

                for (int i = 0; i < max; i++) {
                    result[i] = i;
                }
            }
            else {
                result = new int[caps.Count];

                IDictionaryEnumerator de = caps.GetEnumerator();
                while (de.MoveNext()) {
                    result[(int)de.Value] = (int)de.Key;
                }
            }

            return result;
        }

        /*
         * Given a group number, maps it to a group name. Note that nubmered
         * groups automatically get a group name that is the decimal string
         * equivalent of its number.
         *
         * Returns null if the number is not a recognized group number.
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.GroupNameFromNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a group name that corresponds to a group number.
        ///    </para>
        /// </devdoc>
        public String GroupNameFromNumber(int i) {
            if (capslist == null) {
                if (i >= 0 && i < capsize)
                    return i.ToString();

                return String.Empty;
            }
            else {
                if (caps != null) {
                    Object obj = caps[i];
                    if (obj == null)
                        return String.Empty;

                    i = (int)obj;
                }

                if (i >= 0 && i < capslist.Length)
                    return capslist[i];

                return String.Empty;
            }
        }

        /*
         * Given a group name, maps it to a group number. Note that nubmered
         * groups automatically get a group name that is the decimal string
         * equivalent of its number.
         *
         * Returns -1 if the name is not a recognized group name.
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.GroupNumberFromName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a group number that corresponds to a group name.
        ///    </para>
        /// </devdoc>
        public int GroupNumberFromName(String name) {
            int result = -1;

            if (name == null)
                throw new ArgumentNullException("name");

            // look up name if we have a hashtable of names
            if (capnames != null) {
                Object ret = capnames[name];

                if (ret == null)
                    return -1;

                return(int)ret;
            }

            // convert to an int if it looks like a number
            result = 0;
            for (int i = 0; i < name.Length; i++) {
                char ch = name[i];

                if (ch > '9' || ch < '0')
                    return -1;

                result *= 10;
                result += (ch - '0');
            }

            // return int if it's in range
            if (result >= 0 && result < capsize)
                return result;

            return -1;
        }

        /*
         * Static version of simple IsMatch call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.IsMatch"]/*' />
        ///    <devdoc>
        ///       <para>
        ///          Searches the input 
        ///             string for one or more occurrences of the text supplied in the pattern
        ///             parameter.
        ///       </para>
        ///    </devdoc>
        public static bool IsMatch(String input, String pattern) {
            return new Regex(pattern).IsMatch(input);
        }

        /*
         * Static version of simple IsMatch call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.IsMatch1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches the input string for one or more occurrences of the text 
        ///          supplied in the pattern parameter with matching options supplied in the options
        ///          parameter.
        ///       </para>
        ///    </devdoc>
        public static bool IsMatch(String input, String pattern, RegexOptions options) {
            return new Regex(pattern, options).IsMatch(input);
        }

        /*
         * Returns true if the regex finds a match within the specified string
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.IsMatch2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches the input string for one or 
        ///          more matches using the previous pattern, options, and starting
        ///          position.
        ///       </para>
        ///    </devdoc>
        public bool IsMatch(String input) {
            if (input == null)
                throw new ArgumentNullException("input");

            return(null == Run(true, -1, input, 0, input.Length, UseOptionR() ? input.Length : 0));
        }

        /*
         * Returns true if the regex finds a match after the specified position
         * (proceeding leftward if the regex is leftward and rightward otherwise)
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.IsMatch3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches the input 
        ///          string for one or more matches using the previous pattern and options, with
        ///          a new starting position.
        ///    </para>
        /// </devdoc>
        public bool IsMatch(String input, int startat) {
            if (input == null)
                throw new ArgumentNullException("input");

            return(null == Run(true, -1, input, 0, input.Length, startat));
        }

        /*
         * Static version of simple Match call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Match"]/*' />
        ///    <devdoc>
        ///       <para>
        ///          Searches the input string for one or more occurrences of the text 
        ///             supplied in the pattern parameter.
        ///       </para>
        ///    </devdoc>
        public static Match Match(String input, String pattern) {
            return new Regex(pattern).Match(input);
        }

        /*
         * Static version of simple Match call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Match1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches the input string for one or more occurrences of the text 
        ///          supplied in the pattern parameter. Matching is modified with an option
        ///          string.
        ///       </para>
        ///    </devdoc>
        public static Match Match(String input, String pattern, RegexOptions options) {
            return new Regex(pattern, options).Match(input);
        }

        /*
         * Finds the first match for the regular expression starting at the beginning
         * of the string (or at the end of the string if the regex is leftward)
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Match2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Matches a regular expression with a string and returns
        ///       the precise result as a RegexMatch object.
        ///    </para>
        /// </devdoc>
        public Match Match(String input) {
            if (input == null)
                throw new ArgumentNullException("input");

            return Run(false, -1, input, 0, input.Length, UseOptionR() ? input.Length : 0);
        }

        /*
         * Finds the first match, starting at the specified position
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Match3"]/*' />
        /// <devdoc>
        ///    Matches a regular expression with a string and returns
        ///    the precise result as a RegexMatch object.
        /// </devdoc>
        public Match Match(String input, int startat) {
            if (input == null)
                throw new ArgumentNullException("input");

            return Run(false, -1, input, 0, input.Length, startat);
        }

        /*
         * Finds the first match, restricting the search to the specified interval of
         * the char array.
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Match4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Matches a
        ///       regular expression with a string and returns the precise result as a
        ///       RegexMatch object.
        ///    </para>
        /// </devdoc>
        public Match Match(String input, int beginning, int length) {
            if (input == null)
                throw new ArgumentNullException("input");

            return Run(false, -1, input, beginning, length, UseOptionR() ? beginning + length : beginning);
        }

        /*
         * Static version of simple Matches call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Matches"]/*' />
        ///    <devdoc>
        ///       <para>
        ///          Returns all the successful matches as if Match were
        ///          called iteratively numerous times.
        ///       </para>
        ///    </devdoc>
        public static MatchCollection Matches(String input, String pattern) {
            return new Regex(pattern).Matches(input);
        }

        /*
         * Static version of simple Matches call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Matches1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns all the successful matches as if Match were called iteratively
        ///       numerous times.
        ///    </para>
        /// </devdoc>
        public static MatchCollection Matches(String input, String pattern, RegexOptions options) {
            return new Regex(pattern, options).Matches(input);
        }

        /*
         * Finds the first match for the regular expression starting at the beginning
         * of the string Enumerator(or at the end of the string if the regex is leftward)
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Matches2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       all the successful matches as if Match was called iteratively numerous
        ///       times.
        ///    </para>
        /// </devdoc>
        public MatchCollection Matches(String input) {
            if (input == null)
                throw new ArgumentNullException("input");

            return new MatchCollection(this, input, 0, input.Length, UseOptionR() ? input.Length : 0);
        }

        /*
         * Finds the first match, starting at the specified position
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Matches3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns
        ///       all the successful matches as if Match was called iteratively numerous
        ///       times.
        ///    </para>
        /// </devdoc>
        public MatchCollection Matches(String input, int startat) {
            if (input == null)
                throw new ArgumentNullException("input");

            return new MatchCollection(this, input, 0, input.Length, startat);
        }

        /*
         * Static version of simple Replace call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Replaces 
        ///          all occurrences of the pattern with the <paramref name="replacement"/> pattern, starting at
        ///          the first character in the input string. 
        ///       </para>
        ///    </devdoc>
        public static String Replace(String input, String pattern, String replacement) {
            return new Regex(pattern).Replace(input, replacement);
        }

        /*
         * Static version of simple Replace call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Replaces all occurrences of 
        ///          the <paramref name="pattern "/>with the <paramref name="replacement "/>
        ///          pattern, starting at the first character in the input string. 
        ///       </para>
        ///    </devdoc>
        public static String Replace(String input, String pattern, String replacement, RegexOptions options) {
            return new Regex(pattern, options).Replace(input, replacement);
        }

        /*
         * Does the replacement
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Replaces all occurrences of 
        ///          the <paramref name="pattern "/> with the <paramref name="replacement"/> pattern, starting at the
        ///          first character in the input string, using the previous patten. 
        ///       </para>
        ///    </devdoc>
        public String Replace(String input, String replacement) {
            if (input == null)
                throw new ArgumentNullException("input");

            return Replace(input, replacement, -1, UseOptionR() ? input.Length : 0);
        }

        /*
         * Does the replacement
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace3"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the (previously defined) <paramref name="pattern "/>with the 
        ///    <paramref name="replacement"/> pattern, starting at the first character in the input string. 
        /// </para>
        /// </devdoc>
        public String Replace(String input, String replacement, int count) {
            if (input == null)
                throw new ArgumentNullException("input");

            return Replace(input, replacement, count, UseOptionR() ? input.Length : 0);
        }

        /*
         * Does the replacement
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace4"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the <paramref name="pattern "/>with the recent 
        ///    <paramref name="replacement"/> pattern, starting at the character position 
        ///    <paramref name="startat."/>
        /// </para>
        /// </devdoc>
        public String Replace(String input, String replacement, int count, int startat) {
            RegexReplacement repl;

            if (input == null)
                throw new ArgumentNullException("input");
            if (replacement == null)
                throw new ArgumentNullException("replacement");

            // a little code to grab a cached parsed replacement object
            repl = (RegexReplacement)replref.Get();

            if (repl == null || !repl.Pattern.Equals(replacement)) {
                repl = RegexParser.ParseReplacement(replacement, caps, capsize, capnames, this.roptions);
                replref.Cache(repl);
            }

            return repl.Replace(this, input, count, startat);
        }

        /*
         * Static version of simple Replace call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace5"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the <paramref name="pattern "/>with the 
        ///    <paramref name="replacement"/> pattern 
        ///    <paramref name="."/>
        /// </para>
        /// </devdoc>
        public static String Replace(String input, String pattern, MatchEvaluator evaluator) {
            return new Regex(pattern).Replace(input, evaluator);
        }

        /*
         * Static version of simple Replace call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace6"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the <paramref name="pattern "/>with the recent 
        ///    <paramref name="replacement"/> pattern, starting at the first character<paramref name="."/>
        /// </para>
        /// </devdoc>
        public static String Replace(String input, String pattern, MatchEvaluator evaluator, RegexOptions options) {
            return new Regex(pattern, options).Replace(input, evaluator);
        }

        /*
         * Does the replacement
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace7"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the <paramref name="pattern "/>with the recent 
        ///    <paramref name="replacement"/> pattern, starting at the first character 
        ///    position<paramref name="."/>
        /// </para>
        /// </devdoc>
        public String Replace(String input, MatchEvaluator evaluator) {
            if (input==null)
                throw new ArgumentNullException("input");

            return Replace(input, evaluator, -1, UseOptionR() ? input.Length : 0);
        }

        /*
         * Does the replacement
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace8"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the <paramref name="pattern "/>with the recent 
        ///    <paramref name="replacement"/> pattern, starting at the first character 
        ///    position<paramref name="."/>
        /// </para>
        /// </devdoc>
        public String Replace(String input, MatchEvaluator evaluator, int count) {
            if (input==null)
                throw new ArgumentNullException("input");

            return Replace(input, evaluator, count, UseOptionR() ? input.Length : 0);
        }

        /*
         * Does the replacement
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Replace9"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Replaces all occurrences of the (previouly defined) <paramref name="pattern "/>with 
        ///       the recent <paramref name="replacement"/> pattern, starting at the character
        ///    position<paramref name=" startat."/> 
        /// </para>
        /// </devdoc>
        public String Replace(String input, MatchEvaluator evaluator, int count, int startat) {
            if (input==null)
                throw new ArgumentNullException("input");

            return RegexReplacement.Replace(evaluator, this, input, count, startat);
        }

        /*
         * Static version of simple Split call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Split"]/*' />
        ///    <devdoc>
        ///       <para>
        ///          Splits the <paramref name="input "/>string at the position defined
        ///          by <paramref name="pattern"/>.
        ///       </para>
        ///    </devdoc>
        public static String[] Split(String input, String pattern) {
            return new Regex(pattern).Split(input);
        }

        /*
         * Static version of simple Split call
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Split1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Splits the <paramref name="input "/>string at the position defined by <paramref name="pattern"/>.
        ///    </para>
        /// </devdoc>
        public static String[] Split(String input, String pattern, RegexOptions options) {
            return new Regex(pattern, options).Split(input);
        }

        /*
         * Does a split
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Split2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Splits the <paramref name="input "/>string at the position defined by
        ///       a previous <paramref name="pattern"/>
        ///       .
        ///    </para>
        /// </devdoc>
        public String[] Split(String input) {
            if (input==null)
                throw new ArgumentNullException("input");

            return Split(input, 0, UseOptionR() ? input.Length : 0);
        }

        /*
         * Does a split
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Split3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Splits the <paramref name="input "/>string at the position defined by a previous
        ///    <paramref name="pattern"/> . 
        ///    </para>
        /// </devdoc>
        public String[] Split(String input, int count) {
            if (input==null)
                throw new ArgumentNullException("input");
            
            return RegexReplacement.Split(this, input, count, UseOptionR() ? input.Length : 0);
        }

        /*
         * Does a split
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Split4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Splits the <paramref name="input "/>string at the position defined by a previous
        ///    <paramref name="pattern"/> . 
        ///    </para>
        /// </devdoc>
        public String[] Split(String input, int count, int startat) {
            if (input==null)
                throw new ArgumentNullException("input");

            return RegexReplacement.Split(this, input, count, startat);
        }
        
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.CompileToAssembly"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname) {
        
            CompileToAssemblyInternal(regexinfos, assemblyname, null, null, Assembly.GetCallingAssembly().Evidence);
        }

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.CompileToAssembly1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes) {
            CompileToAssemblyInternal(regexinfos, assemblyname, attributes, null, Assembly.GetCallingAssembly().Evidence);
        }

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.CompileToAssembly2"]/*' />
        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, String resourceFile) {
            CompileToAssemblyInternal(regexinfos, assemblyname, attributes, resourceFile, Assembly.GetCallingAssembly().Evidence);
        }

        private static void CompileToAssemblyInternal (RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, String resourceFile, Evidence evidence) {
            if (assemblyname == null)
                throw new ArgumentNullException("assemblyname");

            if (regexinfos == null)
                throw new ArgumentNullException("regexinfos");
        
            RegexCompiler.CompileToAssembly(regexinfos, assemblyname, attributes, resourceFile, evidence);
        }
        
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.InitializeReferences"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected void InitializeReferences() {
            if (refsInitialized)
                throw new NotSupportedException(SR.GetString(SR.OnlyAllowedOnce));
            
            refsInitialized = true;
            runnerref  = new ExclusiveReference();
            replref    = new SharedReference();
        }

        /*
         * Internal worker called by all the public APIs
         */
        internal Match Run(bool quick, int prevlen, String input, int beginning, int length, int startat) {
            Match match;
            RegexRunner runner = null;

            if (startat < 0 || startat > input.Length)
                throw new ArgumentOutOfRangeException("start", SR.GetString(SR.BeginIndexNotNegative));

            if (length < 0 || length > input.Length)
                throw new ArgumentOutOfRangeException("length", SR.GetString(SR.LengthNotNegative));

            // There may be a cached runner; grab ownership of it if we can.

            runner = (RegexRunner)runnerref.Get();

            // Create a RegexRunner instance if we need to

            if (runner == null) {
                // Use the compiled RegexRunner factory if the code was compiled to MSIL

                if (factory != null)
                    runner = factory.CreateInstance();
                else
                    runner = new RegexInterpreter(code, UseOptionInvariant() ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture);
            }

            // Do the scan starting at the requested position

            match = runner.Scan(this, input, beginning, beginning + length, startat, prevlen, quick);

            // Release or fill the cache slot

            runnerref.Release(runner);

#if DBG
            if (UseOptionDebug())
                match.Dump();
#endif
            return match;
        }

        /*
         * Find code cache based on options+pattern
         */
        private static CachedCodeEntry LookupCached(String key) {
            CachedCodeEntry cached;

            lock (livecode) {
                cached = (CachedCodeEntry)livecode[key];
                if (cached != null)
                    cached.AddRef();
            }

            return cached;
        }

        /*
         * Add current code to the cache
         */
        private CachedCodeEntry CacheCode(String key) {
            CachedCodeEntry newcached;

            newcached = new CachedCodeEntry(roptions, capnames, capslist, code, caps, capsize, runnerref, replref);

            lock (livecode) {
                livecode[key] = newcached;
            }

            return newcached;
        }

        /*
         * Release current code (and remove from cache if last ref)
         */
        private void UncacheCode() {
            // Note that cachedentry can be null if the constructor never
            // completed because of an exception. The finalizer can
            // still be called.

            if (cachedentry == null)
                return;

            cachedentry.Release();
            String key = ((int) roptions).ToString(NumberFormatInfo.InvariantInfo) + ":" + pattern;

            if (cachedentry.NoReferences()) {
                lock (livecode) {
                    if (cachedentry.NoReferences()) {
                        if (livecode[key] == cachedentry)
                            livecode.Remove(key);
                    }
                }
            }
        }

        /*
         * True if the O option was set
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.UseOptionC"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected bool UseOptionC() {
            return(roptions & RegexOptions.Compiled) != 0;
        }

        /*
         * True if the L option was set
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.UseOptionR"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected bool UseOptionR() {
            return(roptions & RegexOptions.RightToLeft) != 0;
        }

        internal bool UseOptionInvariant() {
            return(roptions & RegexOptions.CultureInvariant) != 0;
        }
            

#if DBG
        /*
         * True if the regex has debugging enabled
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Debug"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public virtual bool Debug {
            get {
                return UseOptionDebug();
            }
        }

        /*
         * True if the Debug option was set
         */
        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.UseOptionDebug"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected bool UseOptionDebug() {
            return(roptions & RegexOptions.Debug) != 0;
        }

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Dump"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public virtual String Dump() {
            String key = roptions + ":" + pattern;
            if (key[0] == ':')
                return key.Substring(1, key.Length - 1);

            return key;
        }

        /// <include file='doc\Regex.uex' path='docs/doc[@for="Regex.Dump1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public virtual String Dump(String indent) {
            return indent + Dump() + "\n";
        }
#endif
    }


    /*
     * Callback class
     */
    /// <include file='doc\Regex.uex' path='docs/doc[@for="MatchEvaluator"]/*' />
    /// <devdoc>
    /// </devdoc>
    [ Serializable() ] 
    public delegate String MatchEvaluator(Match match);


    /*
     * Used to cache byte codes or compiled factories
     */
    internal sealed class CachedCodeEntry {
        internal int _references;

        internal RegexCode _code;
        internal RegexOptions _options;
        internal Hashtable _caps;
        internal Hashtable _capnames;
        internal String[]  _capslist;
        internal int       _capsize;
        internal RegexRunnerFactory _factory;
        internal ExclusiveReference _runnerref;
        internal SharedReference _replref;

        internal CachedCodeEntry(RegexOptions options, Hashtable capnames, String[] capslist, RegexCode code, Hashtable caps, int capsize, ExclusiveReference runner, SharedReference repl) {

            _options    = options;
            _capnames   = capnames;
            _capslist   = capslist;

            _code       = code;
            _caps       = caps;
            _capsize    = capsize;

            _runnerref     = runner;
            _replref       = repl;

            _references = 1;
        }

        internal CachedCodeEntry AddRef() {
            lock(this) {
                _references += 1;
                return this;
            }
        }

        internal void Release() {
            lock(this) {
                _references -= 1;
            }
        }

        internal bool NoReferences() {
            return(_references == 0);
        }

        internal void AddCompiled(RegexRunnerFactory factory) {
            lock(this) {
                _code = null;
                _factory = factory;
                _references += 1;   // will never be balanced since we never unload the type
                // CONSIDER: unload the type when this is possible
            }
        }
    }

    /*
     * Used to cache one exclusive weak reference
     */
    internal sealed class ExclusiveReference {
        WeakReference _ref = new WeakReference(null);
        Object _obj;
        int _locked;

        /*
         * Return an object and grab an exclusive lock.
         *
         * If the exclusive lock can't be obtained, null is returned;
         * if the object can't be returned, the lock is released.
         *
         * Note that _ref.Target is referenced only under the protection
         * of the lock. (Is this necessary?)
         */
        internal Object Get() {
            // try to obtain the lock

            if (0 == Interlocked.Exchange(ref _locked, 1)) {
                // grab reference

                Object obj = _ref.Target;

                // release the lock and return null if no reference

                if (obj == null) {
                    _locked = 0;
                    return null;
                }

                // remember the reference and keep the lock

                _obj = obj;
                return obj;
            }

            return null;
        }

        /*
         * Release an object back to the cache
         *
         * If the object is the one that's under lock, the lock
         * is released.
         *
         * If there is no cached object, then the lock is obtained
         * and the object is placed in the cache.
         *
         * Note that _ref.Target is referenced only under the protection
         * of the lock. (Is this necessary?)
         */
        internal void Release(Object obj) {
            if (obj == null)
                throw new ArgumentNullException("obj");

            // if this reference owns the lock, release it

            if (_obj == obj) {
                _obj = null;
                _locked = 0;
                return;
            }

            // if no reference owns the lock, try to cache this reference

            if (_obj == null) {
                // try to obtain the lock

                if (0 == Interlocked.Exchange(ref _locked, 1)) {
                    // if there's really no reference, cache this reference

                    if (_ref.Target == null)
                        _ref.Target = obj;

                    // release the lock

                    _locked = 0;
                    return;
                }
            }
        }
    }

    /*
     * Used to cache a weak reference in a threadsafe way
     */
    internal sealed class SharedReference {
        WeakReference _ref = new WeakReference(null);
        int _locked;

        /*
         * Return an object from a weakref, protected by a lock.
         *
         * If the exclusive lock can't be obtained, null is returned;
         *
         * Note that _ref.Target is referenced only under the protection
         * of the lock. (Is this necessary?)
         */
        internal  Object Get() {
            if (0 == Interlocked.Exchange(ref _locked, 1)) {
                Object obj = _ref.Target;
                _locked = 0;
                return obj;
            }

            return null;
        }

        /*
         * Suggest an object into a weakref, protected by a lock.
         *
         * Note that _ref.Target is referenced only under the protection
         * of the lock. (Is this necessary?)
         */
        internal void Cache(Object obj) {
            if (0 == Interlocked.Exchange(ref _locked, 1)) {
                _ref.Target = obj;
                _locked = 0;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexcapture.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexCapture.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Capture is just a location/length pair that indicates the
 * location of a regular expression match. A single regexp
 * search may return multiple Capture within each capturing
 * RegexGroup.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/28/99 (dbau)      First draft
 *
 */

namespace System.Text.RegularExpressions {

    /// <include file='doc\RegexCapture.uex' path='docs/doc[@for="Capture"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Represents the results from a single subexpression capture. The object represents
    ///       one substring for a single successful capture.</para>
    /// </devdoc>
    [ Serializable() ] 
    public class Capture {
        internal String _text;
        internal int _index;
        internal int _length;

        internal Capture(String text, int i, int l) {
            _text = text;
            _index = i;
            _length = l;
        }

        /*
         * The index of the beginning of the matched capture
         */
        /// <include file='doc\RegexCapture.uex' path='docs/doc[@for="Capture.Index"]/*' />
        /// <devdoc>
        ///    <para>Returns the position in the original string where the first character of
        ///       captured substring was found.</para>
        /// </devdoc>
        public int Index {
            get {
                return _index;
            }
        }

        /*
         * The length of the matched capture
         */
        /// <include file='doc\RegexCapture.uex' path='docs/doc[@for="Capture.Length"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the length of the captured substring.
        ///    </para>
        /// </devdoc>
        public int Length {
            get {
                return _length;
            }
        }

        /// <include file='doc\RegexCapture.uex' path='docs/doc[@for="Capture.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Value {
            get {
                return _text.Substring(_index, _length);
            }
        }

        /*
         * The capture as a string
         */
        /// <include file='doc\RegexCapture.uex' path='docs/doc[@for="Capture.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns 
        ///          the substring that was matched.
        ///       </para>
        ///    </devdoc>
        override public String ToString() {
            return Value;
        }

        /*
         * The original string
         */
        internal String GetOriginalString() {
            return _text;
        }

        /*
         * The substring to the left of the capture
         */
        internal String GetLeftSubstring() {
            return _text.Substring(0, _index);
        }

        /*
         * The substring to the right of the capture
         */
        internal String GetRightSubstring() {
            return _text.Substring(_index + _length, _text.Length - _index - _length);
        }

#if DBG
        internal virtual String Description() {
            StringBuilder Sb = new StringBuilder();

            Sb.Append("(I = ");
            Sb.Append(_index);
            Sb.Append(", L = ");
            Sb.Append(_length);
            Sb.Append("): ");
            Sb.Append(_text, _index, _length);

            return Sb.ToString();
        }
#endif
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexcode.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexCode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexCode class is internal to the regular expression package.
 * It provides operator constants for use by the Builder and the Machine.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/22/99 (dbau)      First draft
 */

/*
 * Implementation notes:
 *
 * Regexps are built into RegexCodes, which contain an operation array,
 * a string table, and some constants.
 *
 * Each operation is one of the codes below, followed by the integer
 * operands specified for each op.
 *
 * Strings and sets are indices into a string table.
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Diagnostics;

    internal sealed class RegexCode {
        // the following primitive operations come directly from the parser

        // lef/back operands        description

        internal const int Onerep         = 0;    // lef,back char,min,max    a {n}
        internal const int Notonerep      = 1;    // lef,back char,min,max    .{n}
        internal const int Setrep         = 2;    // lef,back set,min,max     [\d]{n}

        internal const int Oneloop        = 3;    // lef,back char,min,max    a {,n}
        internal const int Notoneloop     = 4;    // lef,back char,min,max    .{,n}
        internal const int Setloop        = 5;    // lef,back set,min,max     [\d]{,n}

        internal const int Onelazy        = 6;    // lef,back char,min,max    a {,n}?
        internal const int Notonelazy     = 7;    // lef,back char,min,max    .{,n}?
        internal const int Setlazy        = 8;    // lef,back set,min,max     [\d]{,n}?

        internal const int One            = 9;    // lef      char            a
        internal const int Notone         = 10;   // lef      char            [^a]
        internal const int Set            = 11;   // lef      set             [a-z\s]  \w \s \d

        internal const int Multi          = 12;   // lef      string          abcd
        internal const int Ref            = 13;   // lef      group           \#

        internal const int Bol            = 14;   //                          ^
        internal const int Eol            = 15;   //                          $
        internal const int Boundary       = 16;   //                          \b
        internal const int Nonboundary    = 17;   //                          \B
        internal const int Beginning      = 18;   //                          \A
        internal const int Start          = 19;   //                          \G
        internal const int EndZ           = 20;   //                          \Z
        internal const int End            = 21;   //                          \Z

        internal const int Nothing        = 22;   //                          Reject!

        // primitive control structures

        internal const int Lazybranch     = 23;   // back     jump            straight first
        internal const int Branchmark     = 24;   // back     jump            branch first for loop
        internal const int Lazybranchmark = 25;   // back     jump            straight first for loop
        internal const int Nullcount      = 26;   // back     val             set counter, null mark
        internal const int Setcount       = 27;   // back     val             set counter, make mark
        internal const int Branchcount    = 28;   // back     jump,limit      branch++ if zero<=c<limit
        internal const int Lazybranchcount= 29;   // back     jump,limit      same, but straight first
        internal const int Nullmark       = 30;   // back                     save position
        internal const int Setmark        = 31;   // back                     save position
        internal const int Capturemark    = 32;   // back     group           define group
        internal const int Getmark        = 33;   // back                     recall position
        internal const int Setjump        = 34;   // back                     save backtrack state
        internal const int Backjump       = 35;   //                          zap back to saved state
        internal const int Forejump       = 36;   //                          zap backtracking state
        internal const int Testref        = 37;   //                          backtrack if ref undefined
        internal const int Goto           = 38;   //          jump            just go

        internal const int Prune          = 39;   //                          prune it baby
        internal const int Stop           = 40;   //                          done!

#if ECMA
        internal const int ECMABoundary   = 41;   //                          \b
        internal const int NonECMABoundary= 42;   //                          \B
#endif

        // modifiers for alternate modes

        internal const int Mask           = 63;   // Mask to get unmodified ordinary operator
        internal const int Rtl            = 64;   // bit to indicate that we're reverse scanning.
        internal const int Back           = 128;  // bit to indicate that we're backtracking.
        internal const int Back2          = 256;  // bit to indicate that we're backtracking on a second branch.
        internal const int Ci             = 512;  // bit to indicate that we're case-insensitive.

        internal const int infinite = RegexNode.infinite;

        // the code

        internal int[]           _codes;                 // the code
        internal String[]        _strings;               // the string/set table
        // not used! internal int[]           _sparseIndex;           // a list of the groups that are used
        internal int             _trackcount;            // how many instructions use backtracking
        internal Hashtable       _caps;                  // mapping of user group numbers -> impl group slots
        internal int             _capsize;               // number of impl group slots
        internal RegexPrefix     _fcPrefix;              // the set of candidate first characters (may be null)
        internal RegexPrefix     _scPrefix;              // the set of scanned characters (may be null)
        internal RegexBoyerMoore _bmPrefix;              // the fixed prefix string as a Boyer-Moore machine (may be null)
        internal int             _anchors;               // the set of zero-length start anchors (RegexFCD.Bol, etc)
        internal bool         _rightToLeft;           // true if right to left

        // optimizations

        // constructor

        internal RegexCode(int [] codes, ArrayList stringlist, int trackcount,
                           Hashtable caps, int capsize,
                           RegexBoyerMoore bmPrefix, RegexPrefix fcPrefix, RegexPrefix scPrefix,
                           int anchors, bool rightToLeft) {
            _codes = codes;
            _strings = new String[stringlist.Count];
            _trackcount = trackcount;
            _caps = caps;
            _capsize = capsize;
            _bmPrefix = bmPrefix;
            _fcPrefix = fcPrefix;
            _scPrefix = scPrefix;
            _anchors = anchors;
            _rightToLeft = rightToLeft;
            stringlist.CopyTo(0, _strings, 0, stringlist.Count);
        }

        internal static bool OpcodeBacktracks(int Op) {
            Op &= Mask;

            switch (Op) {
                case Oneloop:
                case Notoneloop:
                case Setloop:
                case Onelazy:
                case Notonelazy:
                case Setlazy:
                case Lazybranch:
                case Branchmark:
                case Lazybranchmark:
                case Nullcount: 
                case Setcount: 
                case Branchcount:
                case Lazybranchcount:
                case Setmark:
                case Capturemark:
                case Getmark:
                case Setjump:
                case Backjump:
                case Forejump:
                case Goto:
                    return true;

                default:
                    return false;
            }
        }

        internal static int OpcodeSize(int Opcode) {
            Opcode &= Mask;

            switch (Opcode) {
                case Nothing:
                case Bol:
                case Eol:
                case Boundary:
                case Nonboundary:
#if ECMA
                case ECMABoundary:
                case NonECMABoundary:
#endif
                case Beginning:
                case Start:
                case EndZ:
                case End:

                case Nullmark:
                case Setmark:
                case Getmark:
                case Setjump:
                case Backjump:
                case Forejump:
                case Stop:

                    return 1;

                case One:
                case Notone:
                case Multi:
                case Ref:
                case Testref:


                case Goto:
                case Nullcount:
                case Setcount:
                case Lazybranch:
                case Branchmark:
                case Lazybranchmark:
                case Prune:

                    return 2;

                case Capturemark:
                case Branchcount:
                case Lazybranchcount:
                case Set:

                case Onerep:
                case Notonerep:
                case Oneloop:
                case Notoneloop:
                case Onelazy:
                case Notonelazy:

                    return 3;

                case Setlazy:
                case Setrep:
                case Setloop:

                    return 4;

                default:

                    throw MakeException(SR.GetString(SR.UnexpectedOpcode, Opcode.ToString()));
            }
        }

        internal static ArgumentException MakeException(String message) {
            return new ArgumentException(message);
        }

        // Debug only code below

#if DBG
        internal static String[] CodeStr = new String[]
        {
            "Onerep", "Notonerep", "Setrep",
            "Oneloop", "Notoneloop", "Setloop",
            "Onelazy", "Notonelazy", "Setlazy",
            "One", "Notone", "Set",
            "Multi", "Ref",
            "Bol", "Eol", "Boundary", "Nonboundary", "Beginning", "Start", "EndZ", "End",
            "Nothing",
            "Lazybranch", "Branchmark", "Lazybranchmark",
            "Nullcount", "Setcount", "Branchcount", "Lazybranchcount",
            "Nullmark", "Setmark", "Capturemark", "Getmark",
            "Setjump", "Backjump", "Forejump", "Testref", "Goto",
            "Prune", "Stop",
#if ECMA
            "ECMABoundary", "NonECMABoundary",
#endif
        };

        internal static String OperatorDescription(int Opcode) {
            bool isCi   = ((Opcode & Ci) != 0);
            bool isRtl  = ((Opcode & Rtl) != 0);
            bool isBack = ((Opcode & Back) != 0);
            bool isBack2 = ((Opcode & Back2) != 0);

            return CodeStr[Opcode & Mask] +
            (isCi ? "-Ci" : "") + (isRtl ? "-Rtl" : "") + (isBack ? "-Back" : "") + (isBack2 ? "-Back2" : "");
        }

        internal String OpcodeDescription(int offset) {
            StringBuilder sb = new StringBuilder();
            int opcode = _codes[offset];

            sb.AppendFormat("{0:D6} ", offset);
            sb.Append(OpcodeBacktracks(opcode & Mask) ? '*' : ' ');
            sb.Append(OperatorDescription(opcode));
            sb.Append('(');

            opcode &= Mask;

            switch (opcode) {
                case One:
                case Notone:
                case Onerep:
                case Notonerep:
                case Oneloop:
                case Notoneloop:
                case Onelazy:
                case Notonelazy:
                    sb.Append("Ch = ");
                    sb.Append(RegexCharClass.CharDescription((char)_codes[offset+1]));
                    break;

                case Set:
                case Setrep:
                case Setloop:
                case Setlazy:
                    sb.Append("Set = ");
                    sb.Append(RegexCharClass.SetDescription(_strings[_codes[offset+1]]));
                    break;

                case Multi:
                    sb.Append("String = ");
                    sb.Append(_strings[_codes[offset+1]]);
                    break;

                case Ref:
                case Testref:
                    sb.Append("Index = ");
                    sb.Append(_codes[offset+1]);
                    break;

                case Capturemark:
                    sb.Append("Index = ");
                    sb.Append(_codes[offset+1]);
                    if (_codes[offset+2] != -1) {
                        sb.Append(", Unindex = ");
                        sb.Append(_codes[offset+2]);
                    }
                    break;

                case Nullcount:
                case Setcount:
                    sb.Append("Value = ");
                    sb.Append(_codes[offset+1]);
                    break;

                case Goto:
                case Lazybranch:
                case Branchmark:
                case Lazybranchmark:
                case Branchcount:
                case Lazybranchcount:
                    sb.Append("Addr = ");
                    sb.Append(_codes[offset+1]);
                    break;
            }

            switch (opcode) {
                case Onerep:
                case Notonerep:
                case Oneloop:
                case Notoneloop:
                case Onelazy:
                case Notonelazy:
                case Setrep:
                case Setloop:
                case Setlazy:
                    sb.Append(", Rep = ");
                    if (_codes[offset + 2] == infinite)
                        sb.Append("inf");
                    else
                        sb.Append(_codes[offset + 2]);
                    break;

                case Branchcount:
                case Lazybranchcount:
                    sb.Append(", Limit = ");
                    if (_codes[offset + 2] == infinite)
                        sb.Append("inf");
                    else
                        sb.Append(_codes[offset + 2]);
                    break;
            }

            sb.Append(")");

            return sb.ToString();
        }

        internal void Dump() {
            int i;

            Debug.WriteLine("Direction:  " + (_rightToLeft ? "right-to-left" : "left-to-right"));
            Debug.WriteLine("Firstchars: " + (_fcPrefix == null ? "n/a" : RegexCharClass.SetDescription(_fcPrefix.Prefix)));
            Debug.WriteLine("Prefix:     " + (_bmPrefix == null ? "n/a" : Regex.Escape(_bmPrefix.ToString())));
            Debug.WriteLine("Anchors:    " + RegexFCD.AnchorDescription(_anchors));
            Debug.WriteLine("Scanchars:  " + (_scPrefix == null ? "n/a" : RegexCharClass.SetDescription(_scPrefix.Prefix)));
            Debug.WriteLine("");
            /*
            if (_bmPrefix != null) {
                Debug.WriteLine("BoyerMoore:");
                Debug.WriteLine(_bmPrefix.Dump("    "));
            }
            */
            for (i = 0; i < _codes.Length;) {
                Debug.WriteLine(OpcodeDescription(i));
                i += OpcodeSize(_codes[i]);
            }

            Debug.WriteLine("");
        }
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\net\system\net\sockets\_overlappedasyncresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="_OverlappedAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Net.Sockets {
    using System;
    using System.Runtime.InteropServices;
    using System.Threading;
    using Microsoft.Win32;

    //
    //  OverlappedAsyncResult - used to take care of storage for async Socket operation
    //   from the BeginSend, BeginSendTo, BeginReceive, BeginReceiveFrom calls.
    //
    internal class OverlappedAsyncResult : LazyAsyncResult {

        //
        // internal class members
        //

        //
        // note: this fixes a possible AV caused by a race condition
        // between the Completion Port and the Winsock API, if the Completion
        // Port

        //
        // set bytes transferred explicitly to 0.
        // this fixes a possible race condition in NT.
        // note that (in NT) we don't look
        // at this value. passing in a NULL pointer, though, would save memory
        // and some time, but would cause an AV in winsock.
        //
        // note: this call could actually be avoided, because
        // when unmanaged memory is allocate the runtime will set it to 0.
        // furthermore, the memory pointed by m_BytesRead will be used only
        // for this single async call, and will not be reused. in the end there's
        // no reason for it to be set to something different than 0. we set
        // it explicitly to make the code more readable and to avoid
        // bugs in the future caused by code misinterpretation.
        //

        //
        // Memory for BytesTransferred pointer int.
        //
        internal static IntPtr  m_BytesTransferred = Marshal.AllocHGlobal( 4 );

        private IntPtr          m_UnmanagedBlob;    // Handle for global memory.
        private AutoResetEvent  m_OverlappedEvent;
        private int             m_CleanupCount;
        internal SocketAddress  m_SocketAddress;
        internal SocketAddress  m_SocketAddressOriginal; // needed for partial BeginReceiveFrom/EndReceiveFrom completion
        internal SocketFlags    m_Flags;

        //
        // these are used in alternative
        //
        internal WSABuffer      m_WSABuffer;
        private GCHandle        m_GCHandle; // Handle for pinned buffer.

        internal GCHandle        m_GCHandleSocketAddress; // Handle to FromAddress buffer
        internal GCHandle        m_GCHandleSocketAddressSize; // Handle to From Address size

        internal WSABuffer[]    m_WSABuffers;
        private GCHandle[]      m_GCHandles; // Handles for pinned buffers.
        
        private bool            m_UsingMultipleSend; // used by _tlsstream.cs to reroute EndSend to EndSendMultiple
        private bool            m_DisableOverlapped; // used to disable Overlapped Async behavior

        //
        // the following two will be used only on WinNT to enable completion ports
        //
        private Overlapped                 m_Overlapped;       // Overlapped structure.
        private unsafe NativeOverlapped*   m_NativeOverlapped; // Native Overlapped structure.
        private unsafe static readonly IOCompletionCallback s_IOCallback = new IOCompletionCallback(CompletionPortCallback);

        //
        // Constructor. We take in the socket that's creating us, the caller's
        // state object, and the buffer on which the I/O will be performed.
        // We save the socket and state, pin the callers's buffer, and allocate
        // an event for the WaitHandle.
        //
        internal OverlappedAsyncResult(Socket socket, Object asyncState, AsyncCallback asyncCallback)
        : base(socket, asyncState, asyncCallback) {
            //
            // BeginAccept() allocates and returns an AcceptAsyncResult that will call
            // this constructor passign in a null buffer. no memory is allocated, so we
            // set m_UnmanagedBlob to 0 in order for the Cleanup function to know if it
            // needs to free unmanaged memory
            //
            m_UnmanagedBlob = IntPtr.Zero;

            if (Socket.UseOverlappedIO) {
                //
                // we're using overlapped IO, allocate an overlapped structure
                // consider using a static growing pool of allocated unmanaged memory.
                //
                m_UnmanagedBlob = Marshal.AllocHGlobal(Win32.OverlappedSize);
                //
                // since the binding between the event handle and the callback
                // happens after the IO was queued to the OS, there is no race
                // condition and the Cleanup code can be called at most once.
                //
                m_CleanupCount = 1;
            }
            else {
                //
                // Create an Overlapped object that will be used for native
                // Win32 asynchronous IO.
                //
                m_Overlapped = new Overlapped();
                //
                // Keep a reference to the AsyncResult in the Overlapped object
                // to rebuild state in the Callback function.
                //
                m_Overlapped.AsyncResult = this;
                //
                // since the binding between the event handle and the callback
                // has already happened there is a race condition and so the
                // Cleanup code can be called more than once and at most twice.
                //
                m_CleanupCount = 2;
            }
        }

        //
        // Constructor. We take in the socket that's creating us, and turn off Async
        // We save the socket and state, pin the callers's buffer
        //
        internal OverlappedAsyncResult(Socket socket)
        : base(socket, null, null) {

            m_UnmanagedBlob = IntPtr.Zero;
            m_CleanupCount = 1;
            m_DisableOverlapped = true;
        }


        //
        // This method enables completion ports on the AsyncResult
        //
        internal unsafe void EnableCompletionPort() {
            //
            // Bind the Win32 Socket Handle to the ThreadPool
            //
            ((Socket)AsyncObject).BindToCompletionPort();
            m_NativeOverlapped = m_Overlapped.Pack(s_IOCallback);            

            GlobalLog.Print("OverlappedAsyncResult#" + ValidationHelper.HashString(this) + "::EnableCompletionPort() m_Overlapped:" + ValidationHelper.HashString(m_Overlapped) + " m_NativeOverlapped = " + ((int)m_NativeOverlapped).ToString());
        }


        //
        // This method will be called by us when the IO completes synchronously and
        // by the ThreadPool when the IO completes asynchronously. (only called on WinNT)
        //

        private unsafe static void CompletionPortCallback(uint errorCode, uint numBytes, NativeOverlapped* nativeOverlapped) {
            //
            // Create an Overlapped object out of the native pointer we're provided with.
            // (this will NOT free the unmanaged memory in the native overlapped structure)
            //
            Overlapped callbackOverlapped = Overlapped.Unpack(nativeOverlapped);
            //
            // The Overlapped object contains the SocketAsyncResult object
            // that was used for the IO that just completed.
            //
            OverlappedAsyncResult asyncResult = (OverlappedAsyncResult)callbackOverlapped.AsyncResult;

            GlobalLog.Assert(!asyncResult.IsCompleted, "OverlappedAsyncResult#" + ValidationHelper.HashString(asyncResult) + "::CompletionPortCallback() asyncResult.IsCompleted", "");

#if COMNET_PERFLOGGING
long timer = 0;
Microsoft.Win32.SafeNativeMethods.QueryPerformanceCounter(out timer);
Console.WriteLine(timer + ", CompletionPortCallback(" + asyncResult.GetHashCode() + " 0x" + ((long)nativeOverlapped).ToString("X8") + ") numBytes:" + numBytes);
#endif // #if COMNET_PERFLOGGING

            GlobalLog.Print("OverlappedAsyncResult#" + ValidationHelper.HashString(asyncResult) + "::CompletionPortCallback" +
                             " errorCode:" + errorCode.ToString() +
                             " numBytes:" + numBytes.ToString() +
                             " pOverlapped:" + ((int)nativeOverlapped).ToString());

            //
            // complete the IO and invoke the user's callback
            //
            if (errorCode != 0) {
                //
                // The Async IO completed with a failure.
                // here we need to call WSAGetOverlappedResult() just so WSAGetLastError() will return the correct error. 
                //
                bool success =
                    UnsafeNclNativeMethods.OSSOCK.WSAGetOverlappedResult(
                        ((Socket)asyncResult.AsyncObject).Handle,
                        (IntPtr)nativeOverlapped,
                        out numBytes,
                        false,
                        IntPtr.Zero);

                GlobalLog.Assert(!success, "OverlappedAsyncResult#" + ValidationHelper.HashString(asyncResult) + "::CompletionPortCallback() success: errorCode:" + errorCode + " numBytes:" + numBytes, "");

                errorCode = UnsafeNclNativeMethods.OSSOCK.WSAGetLastError();

                GlobalLog.Assert(errorCode!=0, "OverlappedAsyncResult#" + ValidationHelper.HashString(asyncResult) + "::CompletionPortCallback() errorCode is 0 numBytes:" + numBytes, "");
            }

            //
            // this will release the unmanaged pin handles and unmanaged overlapped ptr
            //
            asyncResult.ReleaseUnmanagedStructures();
            asyncResult.ErrorCode = (int)errorCode;
            asyncResult.InvokeCallback(false, (int)numBytes);
        }

        //
        // The overlapped function called (either by the thread pool or the socket)
        // when IO completes. (only called on Win9x)
        //
        internal void OverlappedCallback(object stateObject, bool Signaled) {
            OverlappedAsyncResult asyncResult = (OverlappedAsyncResult)stateObject;

            GlobalLog.Assert(!asyncResult.IsCompleted, "OverlappedAsyncResult#" + ValidationHelper.HashString(asyncResult) + "::OverlappedCallback() asyncResult.IsCompleted", "");
            //
            // the IO completed asynchronously, see if there was a failure the Internal
            // field in the Overlapped structure will be non zero. to optimize the non
            // error case, we look at it without calling WSAGetOverlappedResult().
            //
            uint errorCode = (uint)Marshal.ReadInt32(IntPtrHelper.Add(asyncResult.m_UnmanagedBlob, Win32.OverlappedInternalOffset));
            uint numBytes = errorCode!=0 ? unchecked((uint)-1) : (uint)Marshal.ReadInt32(IntPtrHelper.Add(asyncResult.m_UnmanagedBlob, Win32.OverlappedInternalHighOffset));
            //
            // this will release the unmanaged pin handles and unmanaged overlapped ptr
            //
            asyncResult.ReleaseUnmanagedStructures();
            asyncResult.ErrorCode = (int)errorCode;
            asyncResult.InvokeCallback(false, (int)numBytes);
        }


        //
        // SetUnmanagedStructures -
        // Fills in Overlapped Structures used in an Async Overlapped Winsock call
        //   these calls are outside the runtime and are unmanaged code, so we need
        //   to prepare specific structures and ints that lie in unmanaged memory
        //   since the Overlapped calls can be Async
        //
        internal void SetUnmanagedStructures(
            byte[] buffer,
            int offset,
            int size,
            SocketFlags socketFlags,
            EndPoint remoteEP,
            bool pinRemoteEP ) {


            if (!m_DisableOverlapped) {
                if (Socket.UseOverlappedIO) {
                    //
                    // create the event handle
                    //

                    m_OverlappedEvent = new AutoResetEvent(false);

                    //
                    // fill in the overlapped structure with the event handle.
                    //

                    Marshal.WriteIntPtr(
                        m_UnmanagedBlob,
                        Win32.OverlappedhEventOffset,
                        m_OverlappedEvent.Handle );
                }
                else {
                    //
                    // use completion ports
                    //
                    EnableCompletionPort();
                }
            }

            //
            // Fill in Buffer Array structure that will be used for our send/recv Buffer
            //
            m_WSABuffer = new WSABuffer();
            m_GCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            m_WSABuffer.Length = size;
            m_WSABuffer.Pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buffer, offset);

            //
            // fill in flags if we use it.
            //
            m_Flags = socketFlags;

            //
            // if needed fill end point
            //
            if (remoteEP != null) {
                m_SocketAddress = remoteEP.Serialize();
                if (pinRemoteEP) {
                    m_GCHandleSocketAddress = GCHandle.Alloc(m_SocketAddress.m_Buffer, GCHandleType.Pinned);
                    m_GCHandleSocketAddressSize = GCHandle.Alloc(m_SocketAddress.m_Size, GCHandleType.Pinned);                
                }
            }

        } // SetUnmanagedStructures()

        internal void SetUnmanagedStructures(
            BufferOffsetSize[] buffers,
            SocketFlags socketFlags) {

            if (!m_DisableOverlapped) {
                if (Socket.UseOverlappedIO) {
                    //
                    // create the event handle
                    //
                    m_OverlappedEvent = new AutoResetEvent(false);

                    //
                    // fill in the overlapped structure with the event handle.
                    //
                    Marshal.WriteIntPtr(
                        m_UnmanagedBlob,
                        Win32.OverlappedhEventOffset,
                        m_OverlappedEvent.Handle );
                }
                else {
                    //
                    // use completion ports
                    //
                    EnableCompletionPort();
                }
            }

            //
            // Fill in Buffer Array structure that will be used for our send/recv Buffer
            //
            m_WSABuffers = new WSABuffer[buffers.Length];
            m_GCHandles = new GCHandle[buffers.Length];
            for (int i = 0; i < buffers.Length; i++) {
                m_GCHandles[i] = GCHandle.Alloc(buffers[i].Buffer, GCHandleType.Pinned);
                m_WSABuffers[i].Length = buffers[i].Size;
                m_WSABuffers[i].Pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buffers[i].Buffer, buffers[i].Offset);
            }
            //
            // fill in flags if we use it.
            //
            m_Flags = socketFlags;
        }


        //
        // This method is called after an asynchronous call is made for the user,
        // it checks and acts accordingly if the IO:
        // 1) completed synchronously.
        // 2) was pended.
        // 3) failed.
        //
        internal unsafe void CheckAsyncCallOverlappedResult(int errorCode) {
            //
            // Check if the Async IO call:
            // 1) was pended.
            // 2) completed synchronously.
            // 3) failed.
            //

            if (Socket.UseOverlappedIO) {
                //
                // we're using overlapped IO under Win9x (or NT with registry setting overriding
                // completion port usage)
                //
                switch (errorCode) {

                case 0:
                case SocketErrors.WSA_IO_PENDING:

                    //
                    // the Async IO call was pended:
                    // Queue our event to the thread pool.
                    //
                    ThreadPool.RegisterWaitForSingleObject(
                                                          m_OverlappedEvent,
                                                          new WaitOrTimerCallback(OverlappedCallback),
                                                          this,
                                                          -1,
                                                          true );

                    //
                    // we're done, completion will be asynchronous
                    // in the callback. return
                    //
                    return;

                default:
                    //
                    // the Async IO call failed:
                    // set the number of bytes transferred to -1 (error)
                    //
                    ErrorCode = errorCode;
                    Result = -1;
                    ReleaseUnmanagedStructures();

                    break;
                }

            }
            else {
                //
                // we're using completion ports under WinNT
                //
                switch (errorCode) {
                //
                // ignore cases in which a completion packet will be queued:
                // we'll deal with this IO in the callback
                //
                case 0:
                case SocketErrors.WSA_IO_PENDING:
                    //
                    // ignore, do nothing
                    //
                    ReleaseUnmanagedStructures();
                    return;
                    //
                    // in the remaining cases a completion packet will NOT be queued:
                    // we'll have to call the callback explicitly signaling an error
                    //
                default:
                    //
                    // call the callback with error code
                    //
                    ErrorCode = errorCode;
                    Result = -1;
                    ForceReleaseUnmanagedStructures();
                    break;
                }
            }
        } // CheckAsyncCallOverlappedResult()

        //
        // The following property returns the Win32 unsafe pointer to
        // whichever Overlapped structure we're using for IO.
        //
        internal unsafe IntPtr IntOverlapped {
            get {
                if (Socket.UseOverlappedIO) {
                    //
                    // on Win9x we allocate our own overlapped structure
                    // and we use a win32 event for IO completion
                    // return the native pointer to unmanaged memory
                    //
                    return m_UnmanagedBlob;
                }
                else {
                    //
                    // on WinNT we need to use (due to the current implementation)
                    // an Overlapped object in order to bind the socket to the
                    // ThreadPool's completion port, so return the native handle
                    //
                    return (IntPtr)m_NativeOverlapped;
                }
            }

        } // IntOverlapped

        //
        // used by _tlsstream.cs to reroute EndSend to EndSendMultiple,
        //  returns true when BeginSendMultiple has been called.
        //
        internal bool UsingMultipleSend {
            get { 
                return m_UsingMultipleSend;
            }
            set {
                m_UsingMultipleSend = value;
            }
        }

        private int m_HashCode = 0;
        private bool m_ComputedHashCode = false;
        public override int GetHashCode() {
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }


        //
        // Utility cleanup routine. Frees pinned and unmanged memory.
        //
        private void CleanupUnmanagedStructures() {
            //
            // free the unmanaged memory if allocated.
            //
            if (((long)m_UnmanagedBlob) != 0) {
                Marshal.FreeHGlobal(m_UnmanagedBlob);
                m_UnmanagedBlob = IntPtr.Zero;
            }
            //
            // free handles to pinned buffers
            //
            if (m_GCHandle.IsAllocated) {
                m_GCHandle.Free();
            }

            if (m_GCHandleSocketAddress.IsAllocated) {
                m_GCHandleSocketAddress.Free();
            }

            if (m_GCHandleSocketAddressSize.IsAllocated) {
                m_GCHandleSocketAddressSize.Free();
            }

            if (m_GCHandles != null) {
                for (int i = 0; i < m_GCHandles.Length; i++) {
                    if (m_GCHandles[i].IsAllocated) {
                        m_GCHandles[i].Free();
                    }
                }
            }
            //
            // clenaup base class
            //
            base.Cleanup();

        } // CleanupUnmanagedStructures()


        private void ForceReleaseUnmanagedStructures() {
            OverlappedFree();
            CleanupUnmanagedStructures();
        }

        internal void ReleaseUnmanagedStructures() {
            if (Interlocked.Decrement(ref m_CleanupCount) == 0) {
                ForceReleaseUnmanagedStructures();
            }
        }

        private unsafe void OverlappedFree() {
            //
            // make sure Overlapped.Free() is only called once.
            // note that if UseOverlappedIO is true m_NativeOverlapped is null
            // and this call will just return
            //
            if (m_NativeOverlapped != null) {
                lock(this) {
                    if (m_NativeOverlapped != null) {
                        Overlapped.Free(m_NativeOverlapped);
                        m_NativeOverlapped = null;
                    }
                }
            }
        }

    }; // class OverlappedAsyncResult




} // namespace System.Net.Sockets
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexcharclass.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexCharClass.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexCharClass class provides the "set of Unicode chars" functionality
 * used by the regexp engine.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *  3/27/99 (dbau)      First draft
 *
 */

/*
 * RegexCharClass supports a "string representation" of a character class.
 * The string representation is NOT human-readable. It is a sequence of
 * strictly increasing Unicode characters that begin ranges of characters
 * that are alternately included in and excluded from the class.
 *
 * Membership of a character in the class can be determined by binary
 * searching the string representation and determining if the including
 * range is at an even or odd index.
 *
 * The RegexCharClass class itself is a builder class. One can add char ranges
 * or sets or invert the class; then, the class can be converted to its
 * string representation via RegexCharClass.ToSet().
 *
 * CONSIDER: this class must be amended to allow for the situation where
 * a range of even or odd characters is included (for Unicode character
 * classes).
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Globalization;
    using System.Diagnostics;

    internal sealed class RegexCharClass {
        internal const char   Nullchar   = '\0';
        internal const char   Lastchar   = '\uFFFF';

        internal const String Any      = "\0";
        internal const String Empty    = "";
        internal const char GroupChar = (char) 0;
        internal static readonly RegexCharClass AnyClass      = new RegexCharClass("\0");
        internal static readonly RegexCharClass EmptyClass    = new RegexCharClass(String.Empty);

        internal static readonly String Word;
        internal static readonly String NotWord;

        internal const short SpaceConst = 100;
        internal const short NotSpaceConst = -100;
        internal static readonly String Space = ((char) SpaceConst).ToString();
        internal static readonly String NotSpace = NegateCategory(Space);
        
#if ECMA
        internal const String ECMASpace    = "\u0009\u000E\u0020\u0021";
        internal const String NotECMASpace = "\0\u0009\u000E\u0020\u0021";
        internal const String ECMAWord     = "\u0030\u003A\u0041\u005B\u005F\u0060\u0061\u007B\u0130\u0131";
        internal const String NotECMAWord  = "\0\u0030\u003A\u0041\u005B\u005F\u0060\u0061\u007B\u0130\u0131";
        internal const String ECMADigit    = "\u0030\u003A";
        internal const String NotECMADigit = "\0\u0030\u003A";
#endif

        internal static Hashtable          _definedCategories;

        internal ArrayList          _rangelist;
        internal StringBuilder      _categories;
        internal bool               _canonical;
        internal bool               _negate;

        
        static RegexCharClass() {
            _definedCategories = new Hashtable(31);
            
            char[] groups = new char[9];
            StringBuilder word = new StringBuilder(11);

            word.Append(GroupChar);
            groups[0] = GroupChar;

            // We need the UnicodeCategory enum values as a char so we can put them in a string
            // in the hashtable.  In order to get there, we first must cast to an int, 
            // then cast to a char
            // Also need to distinguish between positive and negative values.  UnicodeCategory is zero 
            // based, so we add one to each value and subtract it off later

            // Others
            groups[1] = (char) ((int) UnicodeCategory.Control + 1);
            _definedCategories["Cc"] = groups[1].ToString();     // Control 
            groups[2] = (char) ((int) UnicodeCategory.Format + 1);
            _definedCategories["Cf"] = groups[2].ToString();     // Format
            groups[3] = (char) ((int) UnicodeCategory.OtherNotAssigned + 1);
            _definedCategories["Cn"] = groups[3].ToString();     // Not assigned
            groups[4] = (char) ((int) UnicodeCategory.PrivateUse + 1);
            _definedCategories["Co"] = groups[4].ToString();     // Private use
            groups[5] = (char) ((int) UnicodeCategory.Surrogate + 1);
            _definedCategories["Cs"] = groups[5].ToString();     // Surrogate

            groups[6] = GroupChar;
            _definedCategories["C"] = new String(groups, 0, 7);

            // Letters
            groups[1] = (char) ((int) UnicodeCategory.LowercaseLetter + 1);
            _definedCategories["Ll"] = groups[1].ToString();     // Lowercase
            groups[2] = (char) ((int) UnicodeCategory.ModifierLetter + 1);
            _definedCategories["Lm"] = groups[2].ToString();     // Modifier
            groups[3] = (char) ((int) UnicodeCategory.OtherLetter + 1);
            _definedCategories["Lo"] = groups[3].ToString();     // Other 
            groups[4] = (char) ((int) UnicodeCategory.TitlecaseLetter + 1);
            _definedCategories["Lt"] = groups[4].ToString();     // Titlecase
            groups[5] = (char) ((int) UnicodeCategory.UppercaseLetter + 1);
            _definedCategories["Lu"] = groups[5].ToString();     // Uppercase

            //groups[6] = GroupChar;
            _definedCategories["L"] = new String(groups, 0, 7);
            word.Append(groups[1]);
            word.Append(new String(groups, 3, 3));

            // Marks        
            groups[1] = (char) ((int) UnicodeCategory.SpacingCombiningMark + 1);
            _definedCategories["Mc"] = groups[1].ToString();     // Spacing combining
            groups[2] = (char) ((int) UnicodeCategory.EnclosingMark + 1);
            _definedCategories["Me"] = groups[2].ToString();     // Enclosing
            groups[3] = (char) ((int) UnicodeCategory.NonSpacingMark + 1);
            _definedCategories["Mn"] = groups[3].ToString();     // Non-spacing
            
            groups[4] = GroupChar;
            _definedCategories["M"] = new String(groups, 0, 5);
            //word.Append(groups[1]);
            //word.Append(groups[3]);

            // Numbers
            groups[1] = (char) ((int) UnicodeCategory.DecimalDigitNumber + 1);
            _definedCategories["Nd"] = groups[1].ToString();     // Decimal digit
            groups[2] = (char) ((int) UnicodeCategory.LetterNumber + 1);
            _definedCategories["Nl"] = groups[2].ToString();     // Letter
            groups[3] = (char) ((int) UnicodeCategory.OtherNumber + 1);
            _definedCategories["No"] = groups[3].ToString();     // Other 

            //groups[4] = GroupChar;
            _definedCategories["N"] = new String(groups, 0, 5);
            word.Append(groups[1]);
            //word.Append(new String(groups, 1, 3));

            // Punctuation
            groups[1] = (char) ((int) UnicodeCategory.ConnectorPunctuation + 1);
            _definedCategories["Pc"] = groups[1].ToString();     // Connector
            groups[2] = (char) ((int) UnicodeCategory.DashPunctuation + 1);
            _definedCategories["Pd"] = groups[2].ToString();     // Dash
            groups[3] = (char) ((int) UnicodeCategory.ClosePunctuation + 1);
            _definedCategories["Pe"] = groups[3].ToString();     // Close
            groups[4] = (char) ((int) UnicodeCategory.OtherPunctuation + 1);
            _definedCategories["Po"] = groups[4].ToString();     // Other
            groups[5] = (char) ((int) UnicodeCategory.OpenPunctuation + 1);
            _definedCategories["Ps"] = groups[5].ToString();     // Open
            groups[6] = (char) ((int) UnicodeCategory.FinalQuotePunctuation + 1);
            _definedCategories["Pi"] = groups[6].ToString();     // Inital quote
            groups[7] = (char) ((int) UnicodeCategory.InitialQuotePunctuation + 1);
            _definedCategories["Pf"] = groups[7].ToString();     // Final quote

            groups[8] = GroupChar;
            _definedCategories["P"] = new String(groups, 0, 9);
            word.Append(groups[1]);
            
            // Symbols
            groups[1] = (char) ((int) UnicodeCategory.CurrencySymbol + 1);
            _definedCategories["Sc"] = groups[1].ToString();     // Currency
            groups[2] = (char) ((int) UnicodeCategory.ModifierSymbol + 1);
            _definedCategories["Sk"] = groups[2].ToString();     // Modifier
            groups[3] = (char) ((int) UnicodeCategory.MathSymbol + 1);
            _definedCategories["Sm"] = groups[3].ToString();     // Math
            groups[4] = (char) ((int) UnicodeCategory.OtherSymbol + 1);
            _definedCategories["So"] = groups[4].ToString();     // Other

            groups[5] = GroupChar;
            _definedCategories["S"] = new String(groups, 0, 6);

            // Separators
            groups[1] = (char) ((int) UnicodeCategory.LineSeparator + 1);
            _definedCategories["Zl"] = groups[1].ToString();     // Line
            groups[2] = (char) ((int) UnicodeCategory.ParagraphSeparator + 1);
            _definedCategories["Zp"] = groups[2].ToString();     // Paragraph
            groups[3] = (char) ((int) UnicodeCategory.SpaceSeparator + 1);
            _definedCategories["Zs"] = groups[3].ToString();     // Space
            
            groups[4] = GroupChar;
            _definedCategories["Z"] = new String(groups, 0, 5);


            word.Append(GroupChar);
            Word = word.ToString();
            NotWord = NegateCategory(Word);

#if DBG
            // make sure the _propTable is correctly ordered
            int len = _propTable.GetLength(0);
            for (int i=0; i<len-1; i++)
                Debug.Assert(String.Compare(_propTable[i,0], _propTable[i+1,0], false, CultureInfo.InvariantCulture) < 0, "RegexCharClass _propTable is out of order at (" + _propTable[i,0] +", " + _propTable[i+1,0] + ")");
#endif            
        }

        /*
         * RegexCharClass()
         *
         * Creates an empty character class.
         */
        internal RegexCharClass() {
            _rangelist = new ArrayList(6);
            _canonical = true;
            _categories = new StringBuilder();

        }

        /*
         * RegexCharClass()
         *
         * Creates a character class out of a string representation.
         */
        internal RegexCharClass(String set) {
            _rangelist = new ArrayList((set.Length + 1) / 2);
            _canonical = true;
            _categories = new StringBuilder();

            AddSet(set);
        }

        /*
         * RegexCharClass()
         *
         * Creates a character class with a single range.
         */
        internal RegexCharClass(char first, char last) {
            _rangelist = new ArrayList(1);
            _rangelist.Add(new SingleRange(first, last));
            _canonical = true;
            _categories = new StringBuilder();
        }

        internal static RegexCharClass CreateFromCategory(string categoryName, bool invert, bool caseInsensitive, string pattern) {
            RegexCharClass cc = new RegexCharClass();
            cc.AddCategoryFromName(categoryName, invert, caseInsensitive, pattern);
            return cc;
        }


        /*
         * AddCharClass()
         *
         * Adds a regex char class
         */
        internal void AddCharClass(RegexCharClass cc) {
            int i;

            if (_canonical && RangeCount() > 0 && cc.RangeCount() > 0 && 
                cc.Range(cc.RangeCount() - 1)._last <= Range(RangeCount() - 1)._last)
                _canonical = false;

            for (i = 0; i < cc.RangeCount(); i += 1) {
                _rangelist.Add(cc.Range(i));
            }

            _categories.Append(cc._categories.ToString());
        }

        /*
         * AddSet()
         *
         * Adds a set (specified by its string represenation) to the class.
         */
        internal void AddSet(String set) {
            int i;

            if (_canonical && RangeCount() > 0 && set.Length > 0 && 
                set[0] <= Range(RangeCount() - 1)._last)
                _canonical = false;

            for (i = 0; i < set.Length - 1; i += 2) {
                _rangelist.Add(new SingleRange(set[i], (char)(set[i + 1] - 1)));
            }

            if (i < set.Length) {
                _rangelist.Add(new SingleRange(set[i], Lastchar));
            }
        }

        /*
         * AddRange()
         *
         * Adds a single range of characters to the class.
         */
        internal void AddRange(char first, char last) {
            _rangelist.Add(new SingleRange(first, last));
            if (_canonical && _rangelist.Count > 0 &&
                first <= ((SingleRange)_rangelist[_rangelist.Count - 1])._last) {
                _canonical = false;
            }
        }

        internal string Category {
            get { 
                //if (_negate)
                //    return NegateCategory(_categories.ToString());
                //else
                    return _categories.ToString(); 
            }
        }

        internal bool Negate {
            set { _negate = value; }
        }

        internal void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern) {

            object cat = _definedCategories[categoryName];
            if (cat != null) {
                string catstr = (string) cat;

                if (caseInsensitive) {
                    if (categoryName.Equals("Lu") || categoryName.Equals("Lt"))
                        catstr = /*catstr +*/ (string) _definedCategories["Ll"];
                }
            
                if (invert)
                    catstr = NegateCategory(catstr); // negate the category

                _categories.Append((string) catstr);
            }
            else
                AddSet(SetFromProperty(categoryName, invert, pattern));
        }

        internal void AddCategory(string category) {
            _categories.Append(category);
        }

        /*
         * Returns RegexCharClass set string for sets with a one-char \ code.
         */
        /*internal static String SetFromCode(char ch) {
            switch (ch) {
                case 'd':
                    return Digit;
                case 'w':
                //    return Word;
                case 's':
                    return Space;
                case 'D':
                    return NotDigit;
                case 'W':
                //    return NotWord;
                case 'S':
                    return NotSpace;
                default:
                    return Empty;
            }
        }*/


        /**************************************************************************
            Let U be the set of Unicode character values and let L be the lowercase
            function, mapping from U to U. To perform case insensitive matching of
            character sets, we need to be able to map an interval I in U, say
    
                I = [chMin, chMax] = { ch : chMin <= ch <= chMax }
    
            to a set A such that A contains L(I) and A is contained in the union of
            I and L(I).
    
            The table below partitions U into intervals on which L is non-decreasing.
            Thus, for any interval J = [a, b] contained in one of these intervals,
            L(J) is contained in [L(a), L(b)].
    
            It is also true that for any such J, [L(a), L(b)] is contained in the
            union of J and L(J). This does not follow from L being non-decreasing on
            these intervals. It follows from the nature of the L on each interval.
            On each interval, L has one of the following forms:
    
                (1) L(ch) = constant            (LowercaseSet)
                (2) L(ch) = ch + offset         (LowercaseAdd)
                (3) L(ch) = ch | 1              (LowercaseBor)
                (4) L(ch) = ch + (ch & 1)       (LowercaseBad)
    
            It is easy to verify that for any of these forms [L(a), L(b)] is
            contained in the union of [a, b] and L([a, b]).
        ***************************************************************************/

        internal const int LowercaseSet = 0;    // Set to arg.
        internal const int LowercaseAdd = 1;    // Add arg.
        internal const int LowercaseBor = 2;    // Bitwise or with 1.
        internal const int LowercaseBad = 3;    // Bitwise and with 1 and add original.

        // Lower case mapping descriptor.
        private sealed class LC {
            internal LC(char chMin, char chMax, int lcOp, int data) {
                _chMin = chMin;
                _chMax = chMax;
                _lcOp  = lcOp;
                _data  = data;
            }

            internal char _chMin;
            internal char _chMax;
            internal int _lcOp;
            internal int _data;
        }


        private static readonly LC[] _lcTable = new LC[]
        {
            new LC('\u0041', '\u005A', LowercaseAdd, 32),
            new LC('\u00C0', '\u00DE', LowercaseAdd, 32),
            new LC('\u0100', '\u012E', LowercaseBor, 0),
            new LC('\u0130', '\u0130', LowercaseSet, 0x0069),
            new LC('\u0132', '\u0136', LowercaseBor, 0),
            new LC('\u0139', '\u0147', LowercaseBad, 0),
            new LC('\u014A', '\u0176', LowercaseBor, 0),
            new LC('\u0178', '\u0178', LowercaseSet, 0x00FF),
            new LC('\u0179', '\u017D', LowercaseBad, 0),
            new LC('\u0181', '\u0181', LowercaseSet, 0x0253),
            new LC('\u0182', '\u0184', LowercaseBor, 0),
            new LC('\u0186', '\u0186', LowercaseSet, 0x0254),
            new LC('\u0187', '\u0187', LowercaseSet, 0x0188),
            new LC('\u0189', '\u018A', LowercaseAdd, 205),
            new LC('\u018B', '\u018B', LowercaseSet, 0x018C),
            new LC('\u018E', '\u018F', LowercaseAdd, 202),
            new LC('\u0190', '\u0190', LowercaseSet, 0x025B),
            new LC('\u0191', '\u0191', LowercaseSet, 0x0192),
            new LC('\u0193', '\u0193', LowercaseSet, 0x0260),
            new LC('\u0194', '\u0194', LowercaseSet, 0x0263),
            new LC('\u0196', '\u0196', LowercaseSet, 0x0269),
            new LC('\u0197', '\u0197', LowercaseSet, 0x0268),
            new LC('\u0198', '\u0198', LowercaseSet, 0x0199),
            new LC('\u019C', '\u019C', LowercaseSet, 0x026F),
            new LC('\u019D', '\u019D', LowercaseSet, 0x0272),
            new LC('\u01A0', '\u01A4', LowercaseBor, 0),
            new LC('\u01A7', '\u01A7', LowercaseSet, 0x01A8),
            new LC('\u01A9', '\u01A9', LowercaseSet, 0x0283),
            new LC('\u01AC', '\u01AC', LowercaseSet, 0x01AD),
            new LC('\u01AE', '\u01AE', LowercaseSet, 0x0288),
            new LC('\u01AF', '\u01AF', LowercaseSet, 0x01B0),
            new LC('\u01B1', '\u01B2', LowercaseAdd, 217),
            new LC('\u01B3', '\u01B5', LowercaseBad, 0),
            new LC('\u01B7', '\u01B7', LowercaseSet, 0x0292),
            new LC('\u01B8', '\u01B8', LowercaseSet, 0x01B9),
            new LC('\u01BC', '\u01BC', LowercaseSet, 0x01BD),
            new LC('\u01C4', '\u01C5', LowercaseSet, 0x01C6),
            new LC('\u01C7', '\u01C8', LowercaseSet, 0x01C9),
            new LC('\u01CA', '\u01CB', LowercaseSet, 0x01CC),
            new LC('\u01CD', '\u01DB', LowercaseBad, 0),
            new LC('\u01DE', '\u01EE', LowercaseBor, 0),
            new LC('\u01F1', '\u01F2', LowercaseSet, 0x01F3),
            new LC('\u01F4', '\u01F4', LowercaseSet, 0x01F5),
            new LC('\u01FA', '\u0216', LowercaseBor, 0),
            new LC('\u0386', '\u0386', LowercaseSet, 0x03AC),
            new LC('\u0388', '\u038A', LowercaseAdd, 37),
            new LC('\u038C', '\u038C', LowercaseSet, 0x03CC),
            new LC('\u038E', '\u038F', LowercaseAdd, 63),
            new LC('\u0391', '\u03AB', LowercaseAdd, 32),
            new LC('\u03E2', '\u03EE', LowercaseBor, 0),
            new LC('\u0401', '\u040F', LowercaseAdd, 80),
            new LC('\u0410', '\u042F', LowercaseAdd, 32),
            new LC('\u0460', '\u0480', LowercaseBor, 0),
            new LC('\u0490', '\u04BE', LowercaseBor, 0),
            new LC('\u04C1', '\u04C3', LowercaseBad, 0),
            new LC('\u04C7', '\u04C7', LowercaseSet, 0x04C8),
            new LC('\u04CB', '\u04CB', LowercaseSet, 0x04CC),
            new LC('\u04D0', '\u04EA', LowercaseBor, 0),
            new LC('\u04EE', '\u04F4', LowercaseBor, 0),
            new LC('\u04F8', '\u04F8', LowercaseSet, 0x04F9),
            new LC('\u0531', '\u0556', LowercaseAdd, 48),
            new LC('\u10A0', '\u10C5', LowercaseAdd, 48),
            new LC('\u1E00', '\u1EF8', LowercaseBor, 0),
            new LC('\u1F08', '\u1F0F', LowercaseAdd, -8),
            new LC('\u1F18', '\u1F1F', LowercaseAdd, -8),
            new LC('\u1F28', '\u1F2F', LowercaseAdd, -8),
            new LC('\u1F38', '\u1F3F', LowercaseAdd, -8),
            new LC('\u1F48', '\u1F4D', LowercaseAdd, -8),
            new LC('\u1F59', '\u1F59', LowercaseSet, 0x1F51),
            new LC('\u1F5B', '\u1F5B', LowercaseSet, 0x1F53),
            new LC('\u1F5D', '\u1F5D', LowercaseSet, 0x1F55),
            new LC('\u1F5F', '\u1F5F', LowercaseSet, 0x1F57),
            new LC('\u1F68', '\u1F6F', LowercaseAdd, -8),
            new LC('\u1F88', '\u1F8F', LowercaseAdd, -8),
            new LC('\u1F98', '\u1F9F', LowercaseAdd, -8),
            new LC('\u1FA8', '\u1FAF', LowercaseAdd, -8),
            new LC('\u1FB8', '\u1FB9', LowercaseAdd, -8),
            new LC('\u1FBA', '\u1FBB', LowercaseAdd, -74),
            new LC('\u1FBC', '\u1FBC', LowercaseSet, 0x1FB3),
            new LC('\u1FC8', '\u1FCB', LowercaseAdd, -86),
            new LC('\u1FCC', '\u1FCC', LowercaseSet, 0x1FC3),
            new LC('\u1FD8', '\u1FD9', LowercaseAdd, -8),
            new LC('\u1FDA', '\u1FDB', LowercaseAdd, -100),
            new LC('\u1FE8', '\u1FE9', LowercaseAdd, -8),
            new LC('\u1FEA', '\u1FEB', LowercaseAdd, -112),
            new LC('\u1FEC', '\u1FEC', LowercaseSet, 0x1FE5),
            new LC('\u1FF8', '\u1FF9', LowercaseAdd, -128),
            new LC('\u1FFA', '\u1FFB', LowercaseAdd, -126),
            new LC('\u1FFC', '\u1FFC', LowercaseSet, 0x1FF3),
            new LC('\u2160', '\u216F', LowercaseAdd, 16),
            new LC('\u24B6', '\u24D0', LowercaseAdd, 26),
            new LC('\uFF21', '\uFF3A', LowercaseAdd, 32),
        };

        /*
         * AddLowerCase()
         *
         * Adds to the class any lowercase versions of characters already
         * in the class. Used for case-insensitivity.
         */
        internal void AddLowercase(CultureInfo culture) {
            int i;
            int origSize;
            SingleRange range;

            _canonical = false;

            for (i = 0, origSize = _rangelist.Count; i < origSize; i++) {
                range = (SingleRange)_rangelist[i];
                if (range._first == range._last)
                    range._first = range._last = Char.ToLower(range._first, culture);
                else
                    AddLowercaseImpl(range._first, range._last, culture);
            }
        }

        /*
         * AddLowerCaseImpl()
         *
         * For a single range that's in the set, adds any additional ranges
         * necessary to ensure that lowercase equivalents are also included.
         */
        internal void AddLowercaseImpl(char chMin, char chMax, CultureInfo culture) {
            int i, iMax, iMid;
            char chMinT, chMaxT;
            LC lc;

            if (chMin == chMax) {
                chMin = Char.ToLower(chMin, culture);
                if (chMin != chMax)
                    AddRange(chMin, chMin);
                return;
            }

            for (i = 0, iMax = _lcTable.Length; i < iMax; ) {
                iMid = (i + iMax) / 2;
                if (_lcTable[iMid]._chMax < chMin)
                    i = iMid + 1;
                else
                    iMax = iMid;
            }

            if (i >= _lcTable.Length)
                return;

            for ( ; i < _lcTable.Length && (lc = _lcTable[i])._chMin <= chMax; i++) {
                if ((chMinT = lc._chMin) < chMin)
                    chMinT = chMin;

                if ((chMaxT = lc._chMax) > chMax)
                    chMaxT = chMax;

                switch (lc._lcOp) {
                    case LowercaseSet:
                        chMinT = (char)lc._data;
                        chMaxT = (char)lc._data;
                        break;
                    case LowercaseAdd:
                        chMinT += (char)lc._data;
                        chMaxT += (char)lc._data;
                        break;
                    case LowercaseBor:
                        chMinT |= (char)1;
                        chMaxT |= (char)1;
                        break;
                    case LowercaseBad:
                        chMinT += (char)(chMinT & 1);
                        chMaxT += (char)(chMaxT & 1);
                        break;
                }

                if (chMinT < chMin || chMaxT > chMax)
                    AddRange(chMinT, chMaxT);
            }
        }


        /*
         * Invert()
         *
         * Inverts the class.
         */
        /*
        internal void Invert() {
            int i;

            if (!_canonical)
                Canonicalize();

            if (_rangelist.Count == 0) {
                _rangelist.Insert(0, new SingleRange(Nullchar, Lastchar));
                return;
            }

            if (((SingleRange)_rangelist[0])._first != 0) {
                _rangelist.Insert(0, new SingleRange(Nullchar, (char)(((SingleRange)_rangelist[0])._first - 1)));
                i = 1;
            }
            else {
                i = 0;
            }

            for (; i < _rangelist.Count - 1; i++) {
                ((SingleRange)_rangelist[i])._first = (char)(((SingleRange)_rangelist[i])._last + 1);
                ((SingleRange)_rangelist[i])._last = (char)(((SingleRange)_rangelist[i + 1])._first - 1);
            }

            if (((SingleRange)_rangelist[i])._last == Lastchar)
                _rangelist.RemoveAt(i);
            else {
                ((SingleRange)_rangelist[i])._first = (char)(((SingleRange)_rangelist[i])._last + 1);
                ((SingleRange)_rangelist[i])._last = Lastchar;
            }
        }
        */

        /*
         * ToSet()
         *
         * Constructs the string representation of the class.
         */
        internal String ToSet() {
            int i;
            StringBuilder sb;

            if (!_canonical)
                Canonicalize();

            if (_negate) {
                sb = new StringBuilder(_rangelist.Count * 2 + 2);
                sb.Append(Nullchar);
                sb.Append(Nullchar);
            }
            else
                sb = new StringBuilder(_rangelist.Count * 2);


            for (i = 0; i < _rangelist.Count; i++) {
                sb.Append(((SingleRange)_rangelist[i])._first);

                if (((SingleRange)_rangelist[i])._last != Lastchar)
                    sb.Append((char)(((SingleRange)_rangelist[i])._last + 1));
            }

            return sb.ToString();
        }

        /*
         * ToSetCi()
         *
         * Constructs the string representation of the class.
         */
        internal String ToSetCi(bool caseInsensitive, CultureInfo culture) {
            if (caseInsensitive)
                AddLowercase(culture);

            return ToSet();
        }

        /*
         * SetSize()
         *
         * Returns the number of characters included in the set.
         */
        internal static int SetSize(String set) {
            int i;
            int c;

            c = 0;

            for (i = 0; i < set.Length - 1; i += 2) {
                c += set[i + 1] - set[i];
            }

            if (i < set.Length) {
                c += 0x10000 - set[i];
            }

            return c;
        }

        /*
         * SetInverse()
         *
         * Inverts a string representation of a class directly.
         */
        internal static String SetInverse(String set) {
            if (set.Length == 0 || set[0] != Nullchar)
                return Any + set;

            if (set.Length == 1)
                return Empty;

            return set.Substring(1, set.Length - 1);
        }

        /*
         * SetIntersect()
         *
         * Builds the intersection of two string representations of a class.
         */
        /*internal static String SetIntersect(String setI, String setJ) {
            if (setI.Equals(Empty) || setJ.Equals(Any))
                return setI;

            if (setJ.Equals(Empty) || setI.Equals(Any))
                return setJ;

            if (setI == setJ)
                return setI;

            return SetInverse(SetUnion(SetInverse(setI), SetInverse(setJ)));
        }*/

        /*
         * SetUnion()
         *
         * Builds the union of two string representations of a class directly.
         */
        internal static String SetUnion(String setI, String setJ) {
            int i;
            int j;
            int s;
            String swap;
            StringBuilder sb;
            char chExc;

            if (setI.Equals(Empty) || setJ.Equals(Any))
                return setJ;

            if (setJ.Equals(Empty) || setI.Equals(Any))
                return setI;

            if (setI == setJ)
                return setI;

            i = 0;
            j = 0;
            sb = new StringBuilder(setI.Length + setJ.Length);

            for (;;) {
                if (j == setJ.Length) {
                    sb.Append(setI, i, setI.Length - i);
                    break;
                }

                if (i == setI.Length) {
                    sb.Append(setJ, j, setJ.Length - j);
                    break;
                }

                if (setJ[j] > setI[i]) {
                    s = i;
                    i = j;
                    j = s;
                    swap = setI;
                    setI = setJ;
                    setJ = swap;
                }

                sb.Append(setJ[j++]);
                if (j == setJ.Length)
                    break;

                chExc = setJ[j++];

                for (;;) {
                    while (i < setI.Length && setI[i] <= chExc)
                        i++;

                    if ((i & 0x1) == 0) {
                        sb.Append(chExc);
                        goto OuterContinue;
                    }
                    else {
                        if (i == setI.Length)
                            goto OuterBreak;

                        chExc = setI[i++];
                    }

                    s = i;
                    i = j;
                    j = s;
                    swap = setI;
                    setI = setJ;
                    setJ = swap;
                }

                OuterContinue: 
                ;
            }

            OuterBreak: 
            ;

            return sb.ToString();
        }

        internal static String CategoryUnion(string catI, string catJ) {
            return catI + catJ;
        }
        
        /*
         * SetFromChar()
         *
         * Builds the string representations of a class with a single character.
         */
        internal static String SetFromChar(char ch) {
            StringBuilder sb = new StringBuilder(2);

            sb.Append(ch);

            if (ch != Lastchar)
                sb.Append((char)(ch + 1));

            return sb.ToString();
        }

        /*
         * SetInverseFromChar()
         *
         * Builds the string representation of a class that omits a single character.
         */
        internal static String SetInverseFromChar(char ch) {
            StringBuilder sb = new StringBuilder(3);

            if (ch != Nullchar) {
                sb.Append(Nullchar);
                sb.Append(ch);
            }

            if (ch != Lastchar)
                sb.Append((char)(ch + 1));

            return sb.ToString();
        }

        /*
         * IsSingleton()
         *
         * True if the set contains a single character only
         */
        internal static bool IsSingleton(String set) {
            return(set.Length == 2 && set[0] == set[1] - 1); // && _categories.Length == 0);
        }

        /*
         * SingletonChar()
         *
         * Returns the char
         */
        internal static char SingletonChar(String set) {
            return set[0];
        }

#if ECMA
        internal static bool IsECMAWordChar(char ch) {
            return CharInSet(ch, ECMAWord, String.Empty);
        }
#endif

        internal static bool IsWordChar(char ch) {
            return CharInCategory(ch, Word);
        }

        internal static bool CharInSet(char ch, String set, String category) {
            bool b = CharInSetInternal(ch, set, category);
            
            if (set.Length >= 2 && (set[0] == 0) && (set[1] == 0))
                return !b;
            else
                return b;
        }

        /*
         * CharInSet()
         *
         * Determines a character's membership in a character class (via the
         * string representation of the class).
         */
        internal static bool CharInSetInternal(char ch, string set, String category) {
            int min;
            int max;
            int mid;
            min = 0;
            max = set.Length;

            while (min != max) {
                mid = (min + max) / 2;
                if (ch < set[mid])
                    max = mid;
                else
                    min = mid + 1;
            }

            if ((min & 0x1) != 0) 
                return true;
            else 
                return CharInCategory(ch, category);
        }

        internal static bool CharInCategory(char ch, string category) {
            
            if (category.Length == 0)
                return false;

            UnicodeCategory chcategory = char.GetUnicodeCategory(ch);

            int i=0;
            while (i<category.Length) {
                int curcat = (short) category[i];

                if (curcat == 0) {
                    // zero is our marker for a group of categories - treated as a unit
                    if (CharInCategoryGroup(ch, chcategory, category, ref i))
                        return true;
                }
                else if (curcat > 0) {
                    // greater than zero is a positive case

                    if (curcat  == SpaceConst) {
                        if (Char.IsWhiteSpace(ch))
                            return true;
                        else  {
                            i++;
                            continue;
                        }
                    }
                    --curcat;

                    if (chcategory == (UnicodeCategory) curcat)
                        return true;
                }
                else {
                    // less than zero is a negative case
                    if (curcat == NotSpaceConst) {
                        if (!Char.IsWhiteSpace(ch))
                            return true;
                        else  {
                            i++;
                            continue;
                        }
                    }
                    
                    curcat = -curcat;
                    --curcat;

                    if (chcategory != (UnicodeCategory) curcat)
                        return true;
                }
                i++;
            }
            return false;
        }

        /*
        *  CharInCategoryGroup
        *  This is used for categories which are composed of other categories - L, N, Z, W...
        *  These groups need special treatment when they are negated
        */
        private static bool CharInCategoryGroup(char ch, UnicodeCategory chcategory, string category, ref int i) {
            i++;

            int curcat = (short) category[i];
            if (curcat > 0) {
                // positive case - the character must be in ANY of the categories in the group
                bool answer = false;

                while (curcat != 0) {
                    if (!answer) {
                        --curcat;
                        if (chcategory == (UnicodeCategory) curcat)
                            answer = true;
                    }
                    i++;
                    curcat = (short) category[i];
                }
                return answer;
            }
            else {

                // negative case - the character must be in NONE of the categories in the group
                bool answer = true;

                while (curcat != 0) {
                    if (answer) {
                        curcat = -curcat;
                        --curcat;
                        if (chcategory == (UnicodeCategory) curcat)
                            answer = false;
                    }
                    i++;
                    curcat = (short) category[i];
                }
                return answer;
            }
        }

        internal static string NegateCategory(string category) {
            if (category == null)
                return null;

            StringBuilder sb = new StringBuilder();

            for (int i=0; i<category.Length; i++) {
                short ch = (short) category[i];
                sb.Append( (char) -ch);
            }
            return sb.ToString();
        }

        /*
         * RangeCount()
         *
         * The number of single ranges that have been accumulated so far.
         */
        private int RangeCount() {
            return _rangelist.Count;
        }

        /*
         * Range(int i)
         *
         * The ith range.
         */
        private SingleRange Range(int i) {
            return(SingleRange)_rangelist[i];
        }

        /*
         * SingleRangeComparer
         *
         * For sorting ranges; compare based on the first char in the range.
         */
        private sealed class SingleRangeComparer : IComparer {
            public int Compare(Object x, Object y) {
                return(((SingleRange)x)._first < ((SingleRange)y)._first ? -1
                       : (((SingleRange)x)._first > ((SingleRange)y)._first ? 1 : 0));
            }
        }

        /*
         * SingleRange
         *
         * A first/last pair representing a single range of characters.
         */
        private sealed class SingleRange {
            internal SingleRange(char first, char last) {
                _first = first;
                _last = last;
            }

            internal char _first;
            internal char _last;
        }

        /*
         * Canonicalize()
         *
         * Logic to reduce a character class to a unique, sorted form.
         */
        private void Canonicalize() {
            SingleRange CurrentRange;
            int i;
            int j;
            char last;
            bool Done;

            _canonical = true;
            _rangelist.Sort(0, _rangelist.Count, new SingleRangeComparer());

            //
            // Find and eliminate overlapping or abutting ranges
            //

            if (_rangelist.Count > 1) {
                Done = false;

                for (i = 1, j = 0; ; i++) {
                    for (last = ((SingleRange)_rangelist[j])._last; ; i++) {
                        if (i == _rangelist.Count || last == Lastchar) {
                            Done = true;
                            break;
                        }

                        if ((CurrentRange = (SingleRange)_rangelist[i])._first > last + 1)
                            break;

                        if (last < CurrentRange._last)
                            last = CurrentRange._last;
                    }

                    ((SingleRange)_rangelist[j])._last = last;

                    j++;

                    if (Done)
                        break;

                    if (j < i)
                        _rangelist[j] = _rangelist[i];
                }
                _rangelist.RemoveRange(j, _rangelist.Count - j);
            }
        }

        /*
         *   The property table contains all the block definitions defined in the 
         *   XML schema spec (http://www.w3.org/TR/2001/PR-xmlschema-2-20010316/#charcter-classes), Unicode 3.0 spec (www.unicode.org), 
         *   and Perl 5.6 (see Programming Perl, 3rd edition page 167).   Three blocks defined by Perl (and here) may 
         *   not be in the Unicode: IsHighPrivateUseSurrogates, IsHighSurrogates, and IsLowSurrogates.   
         *   
         *   In addition, there was some inconsistency in the definition of IsTibetan and IsArabicPresentationForms-B.  
         *   Regex goes with with the XML spec on both of these, since it seems to be (oddly enough) more correct than the Unicode spec!
         *
         *   This is what we use:
         *   IsTibetan:  0xF00 - 0x0FFF
         *   IsArabicPresentationForms-B: 0xFE70-0xFEFE
         *
         *   The Unicode spec is inconsistent for IsTibetan.  Its range is 0x0F00 - 0x0FBF.  However, it clearly defines 
         *   Tibetan characters above 0x0FBF.  This appears to be an error between the 2.0 and 3.0 spec.
         *
         *   The Unicode spec is also unclear on IsArabicPresentationForms-B, defining it as 0xFE70-0xFEFF.  
         *   There is only one character different here, 0xFEFF, which is a byte-order mark character and 
         *   is labeled in the spec as special.  I have excluded it from IsArabicPresentationForms-B and left it in IsSpecial.
        **/
        // Has to be sorted by the first column
        private static readonly String[,] _propTable = {
            {"_xmlC", /* Name Char              */   "\u002D\u002F\u0030\u003B\u0041\u005B\u005F\u0060\u0061\u007B\u00AA\u00AB\u00B2\u00B4\u00B5\u00B6\u00B9\u00BB\u00BC\u00BF\u00C0\u00D7\u00D8\u00F7\u00F8\u01AA\u01AB\u01BB\u01BC\u01BE\u01C4\u01F6\u01FA\u0218\u0250\u02A9\u0386\u0387\u0388\u038B\u038C\u038D\u038E\u03A2\u03A3\u03CF\u03D0\u03D7\u03DA\u03DB\u03DC\u03DD\u03DE\u03DF\u03E0\u03E1\u03E2\u03F3\u0401\u040D\u040E\u0450\u0451\u045D\u045E\u0482\u0490\u04C0\u04C1\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04EC\u04EE\u04F6\u04F8\u04FA\u0531\u0557\u0561\u0588\u0660\u066A\u06F0\u06FA\u0966\u0970\u09E6\u09F0\u09F4\u09FA\u0A66\u0A70\u0AE6\u0AF0\u0B66\u0B70\u0BE7\u0BF3\u0C66\u0C70\u0CE6\u0CF0\u0D66\u0D70\u0E50\u0E5A\u0ED0\u0EDA\u0F20\u0F34\u10A0\u10C6\u10D0\u10F7\u1E00\u1E9C\u1EA0\u1EFA\u1F00\u1F16\u1F18\u1F1E\u1F20\u1F46\u1F48\u1F4E\u1F50\u1F58\u1F59\u1F5A\u1F5B\u1F5C\u1F5D\u1F5E\u1F5F\u1F7E\u1F80\u1FB5\u1FB6\u1FBD\u1FBE\u1FBF\u1FC2\u1FC5\u1FC6\u1FCD\u1FD0\u1FD4\u1FD6\u1FDC\u1FE0\u1FED\u1FF2\u1FF5\u1FF6\u1FFD\u2070\u2071\u2074"
                +"\u207A\u207F\u208A\u20A8\u20A9\u2102\u2103\u2107\u2108\u210A\u2114\u2115\u211E\u2120\u2123\u2124\u2125\u2126\u2127\u2128\u2129\u212A\u2132\u2133\u2135\u2153\u2183\u2460\u249C\u24B6\u24EB\u2776\u2794\u3007\u3008\u3021\u302A\u3280\u328A\u3372\u3375\u3376\u3377\u3385\u338A\u338D\u3391\u3399\u339F\u33A9\u33AA\u33AD\u33AE\u33B0\u33B4\u33B9\u33BA\u33BF\u33C0\u33C1\u33C2\u33C3\u33C6\u33C7\u33C8\u33C9\u33D8\u33D9\u33DE"},
            {"_xmlD",                                "\u0030\u003A\u0660\u066A\u06F0\u06FA\u0966\u0970\u09E6\u09F0\u0A66\u0A70\u0AE6\u0AF0\u0B66\u0B70\u0BE7\u0BF0\u0C66\u0C70\u0CE6\u0CF0\u0D66\u0D70\u0E50\u0E5A\u0ED0\u0EDA\u0F20\u0F2A\u2070\u2071\u2074\u207A\u2080\u208A"},
            {"_xmlI", /* Start Name Char       */   "\u003A\u003B\u0041\u005B\u005F\u0060\u0061\u007B\u00A8\u00A9\u00AA\u00AB\u00AF\u00B0\u00B4\u00B6\u00B8\u00B9\u00BA\u00BB\u00C0\u00D7\u00D8\u00F7\u00F8\u01F6\u01FA\u0218\u0250\u02A9\u02B0\u02DF\u02E0\u02EA\u0374\u0375\u037A\u037B\u0384\u0387\u0388\u038B\u038C\u038D\u038E\u03A2\u03A3\u03CF\u03D0\u03D7\u03DA\u03DB\u03DC\u03DD\u03DE\u03DF\u03E0\u03E1\u03E2\u03F4\u0401\u040D\u040E\u0450\u0451\u045D\u045E\u0482\u0490\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04EC\u04EE\u04F6\u04F8\u04FA\u0531\u0557\u0559\u055A\u0561\u0588\u05D0\u05EB\u05F0\u05F3\u0621\u063B\u0640\u064B\u0671\u06B8\u06BA\u06BF\u06C0\u06CF\u06D0\u06D4\u06D5\u06D6\u06E5\u06E7\u0905\u093A\u0958\u0962\u0985\u098D\u098F\u0991\u0993\u09A9\u09AA\u09B1\u09B2\u09B3\u09B6\u09BA\u09DC\u09DE\u09DF\u09E2\u09F0\u09F2\u0A05\u0A0B\u0A0F\u0A11\u0A13\u0A29\u0A2A\u0A31\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A59\u0A5D\u0A5E\u0A5F\u0A85\u0A8C\u0A8D\u0A8E\u0A8F\u0A92\u0A93\u0AA9\u0AAA\u0AB1\u0AB2\u0AB4\u0AB5\u0ABA\u0AE0\u0AE1\u0B05"
                +"\u0B0D\u0B0F\u0B11\u0B13\u0B29\u0B2A\u0B31\u0B32\u0B34\u0B36\u0B3A\u0B5C\u0B5E\u0B5F\u0B62\u0B85\u0B8B\u0B8E\u0B91\u0B92\u0B96\u0B99\u0B9B\u0B9C\u0B9D\u0B9E\u0BA0\u0BA3\u0BA5\u0BA8\u0BAB\u0BAE\u0BB6\u0BB7\u0BBA\u0C05\u0C0D\u0C0E\u0C11\u0C12\u0C29\u0C2A\u0C34\u0C35\u0C3A\u0C60\u0C62\u0C85\u0C8D\u0C8E\u0C91\u0C92\u0CA9\u0CAA\u0CB4\u0CB5\u0CBA\u0CDE\u0CDF\u0CE0\u0CE2\u0D05\u0D0D\u0D0E\u0D11\u0D12\u0D29\u0D2A\u0D3A\u0D60\u0D62\u0E01\u0E31\u0E32\u0E34\u0E40\u0E47\u0E4F\u0E50\u0E5A\u0E5C\u0E81\u0E83\u0E84\u0E85\u0E87\u0E89\u0E8A\u0E8B\u0E8D\u0E8E\u0E94\u0E98\u0E99\u0EA0\u0EA1\u0EA4\u0EA5\u0EA6\u0EA7\u0EA8\u0EAA\u0EAC\u0EAD\u0EAF\u0EB0\u0EB1\u0EB2\u0EB4\u0EBD\u0EBE\u0EC0\u0EC5\u0EDC\u0EDE\u0F18\u0F1A\u0F40\u0F48\u0F49\u0F6A\u10A0\u10C6\u10D0\u10F7\u1100\u115A\u115F\u11A3\u11A8\u11FA\u1E00\u1E9C\u1EA0\u1EFA\u1F00\u1F16\u1F18\u1F1E\u1F20\u1F46\u1F48\u1F4E\u1F50\u1F58\u1F59\u1F5A\u1F5B\u1F5C\u1F5D\u1F5E\u1F5F\u1F7E\u1F80\u1FB5\u1FB6\u1FC5\u1FC6\u1FD4\u1FD6\u1FDC\u1FDD\u1FF0"
                +"\u1FF2\u1FF5\u1FF6\u1FFF\u207F\u2080\u20A8\u20A9\u2102\u2103\u2107\u2108\u210A\u2114\u2115\u211E\u2120\u2123\u2124\u2125\u2126\u2127\u2128\u2129\u212A\u2132\u2133\u2139\u24B6\u24EA\u3041\u3095\u309B\u309F\u30A1\u30FB\u30FC\u30FF\u3105\u312D\u3131\u318F\u3192\u31A0\u3260\u327C\u328A\u32B1\u32D0\u32FF\u3300\u3358\u3371\u3377\u337B\u3395\u3399\u339F\u33A9\u33AE\u33B0\u33C2\u33C3\u33C6\u33C7\u33D8\u33D9\u33DE\u4E00\u4E01\u9FA5\u9FA6\uAC00\uAC01\uD7A3\uD7A4\uF900"},
            {"_xmlW",                                "\u0023\u0025\u0026\u0027\u002A\u002C\u0030\u003A\u003C\u003F\u0040\u005B\u005E\u007B\u007C\u007D\u007E\u007F\u00A2\u00AB\u00AC\u00AD\u00AE\u00B7\u00B8\u00BB\u00BC\u00BF\u00C0\u037E\u037F\u0387\u0388\u055A\u0560\u0589\u058A\u05BE\u05BF\u05C0\u05C1\u05C3\u05C4\u05F3\u05F5\u060C\u060D\u061B\u061C\u061F\u0620\u06D4\u06D5\u093D\u093E\u0970\u0971\u0ABD\u0ABE\u0B3D\u0B3E\u0EAF\u0EB0\u0F04\u0F13\u0F3A\u0F3E\u0F85\u0F86\u10FB\u10FC\u2000\u202F\u2030\u203D\u2045\u2047\u206A\u2070\u207D\u207F\u208D\u208F\u2329\u232B\u3000\u3004\u3005\u3007\u3008\u3012\u3014\u301D\u3030\u3031\u30FB\u30FC\uD800\uD801\uDB7F\uDB81\uDBFF\uDC01\uDFFF\uE001\uF8FF\uF900\uFD3E\uFD40\uFE30\uFE33\uFE35\uFE45\uFE50\uFE53\uFE54\uFE5F\uFE63\uFE64\uFE68\uFE69\uFE6A\uFE6B\uFEFF\uFF00\uFF01\uFF03\uFF05\uFF06\uFF07\uFF0A\uFF0C\uFF10\uFF1A\uFF1C\uFF1F\uFF20\uFF3B\uFF3E\uFF5B\uFF5C\uFF5D\uFF5E\uFF61\uFF66"},

            {"IsAlphabeticPresentationForms",       "\uFB00\uFB50"},
            {"IsArabic",                            "\u0600\u0700"},
            {"IsArabicPresentationForms-A",         "\uFB50\uFE00"},
            {"IsArabicPresentationForms-B",         "\uFE70\uFEFF"},
            {"IsArmenian",                          "\u0530\u0590"},
            {"IsArrows",                            "\u2190\u2200"},
            {"IsBasicLatin",                        "\u0000\u0080"},
            {"IsBengali",                           "\u0980\u0A00"},
            {"IsBlockElements",                     "\u2580\u25A0"},
            {"IsBopomofo",                          "\u3100\u3130"},
            {"IsBopomofoExtended",                  "\u31A0\u31C0"},
            {"IsBoxDrawing",                        "\u2500\u2580"},
            {"IsBraillePatterns",                   "\u2800\u2900"},
            {"IsCherokee",                          "\u13A0\u1400"},
            {"IsCJKCompatibility",                  "\u3300\u3400"},
            {"IsCJKCompatibilityForms",             "\uFE30\uFE50"},
            {"IsCJKCompatibilityIdeographs",        "\uF900\uFB00"},
            {"IsCJKRadicalsSupplement",             "\u2E80\u2F00"},
            {"IsCJKSymbolsandPunctuation",          "\u3000\u3040"},
            {"IsCJKUnifiedIdeographs",              "\u4E00\uA000"},
            {"IsCJKUnifiedIdeographsExtensionA",    "\u3400\u4DB6"},
            {"IsCombiningDiacriticalMarks",         "\u0300\u0370"},
            {"IsCombiningHalfMarks",                "\uFE20\uFE30"},
            {"IsCombiningMarksforSymbols",          "\u20D0\u2100"},
            {"IsControlPictures",                   "\u2400\u2440"},
            {"IsCurrencySymbols",                   "\u20A0\u20D0"},
            {"IsCyrillic",                          "\u0400\u0500"},
            {"IsDevanagari",                        "\u0900\u0980"},
            {"IsDingbats",                          "\u2700\u27C0"},
            {"IsEnclosedAlphanumerics",             "\u2460\u2500"},
            {"IsEnclosedCJKLettersandMonths",       "\u3200\u3300"},
            {"IsEthiopic",                          "\u1200\u1380"},
            {"IsGeneralPunctuation",                "\u2000\u2070"},
            {"IsGeometricShapes",                   "\u25A0\u2600"},
            {"IsGeorgian",                          "\u10A0\u1100"},
            {"IsGreek",                             "\u0370\u0400"},
            {"IsGreekExtended",                     "\u1F00\u2000"},
            {"IsGujarati",                          "\u0A80\u0B00"},
            {"IsGurmukhi",                          "\u0A00\u0A80"},
            {"IsHalfwidthandFullwidthForms",        "\uFF00\uFFF0"},
            {"IsHangulCompatibilityJamo",           "\u3130\u3190"},
            {"IsHangulJamo",                        "\u1100\u1200"},
            {"IsHangulSyllables",                   "\uAC00\uD7A4"},
            {"IsHebrew",                            "\u0590\u0600"},
            {"IsHighPrivateUseSurrogates",          "\uDB80\uDC00"},
            {"IsHighSurrogates",                    "\uD800\uDB80"},
            {"IsHiragana",                          "\u3040\u30A0"},
            {"IsIdeographicDescriptionCharacters",  "\u2FF0\u3000"},
            {"IsIPAExtensions",                     "\u0250\u02B0"},
            {"IsKanbun",                            "\u3190\u31A0"},
            {"IsKangxiRadicals",                    "\u2F00\u2FE0"},
            {"IsKannada",                           "\u0C80\u0D00"},
            {"IsKatakana",                          "\u30A0\u3100"},
            {"IsKhmer",                             "\u1780\u1800"},
            {"IsLao",                               "\u0E80\u0F00"},
            {"IsLatin-1Supplement",                 "\u0080\u0100"},
            {"IsLatinExtended-A",                   "\u0100\u0180"},
            {"IsLatinExtendedAdditional",           "\u1E00\u1F00"},
            {"IsLatinExtended-B",                   "\u0180\u0250"},
            {"IsLetterlikeSymbols",                 "\u2100\u2150"},
            {"IsLowSurrogates",                     "\uDC00\uE000"},
            {"IsMalayalam",                         "\u0D00\u0D80"},
            {"IsMathematicalOperators",             "\u2200\u2300"},
            {"IsMiscellaneousSymbols",              "\u2600\u2700"},
            {"IsMiscellaneousTechnical",            "\u2300\u2400"},
            {"IsMongolian",                         "\u1800\u18B0"},
            {"IsMyanmar",                           "\u1000\u10A0"},
            {"IsNumberForms",                       "\u2150\u2190"},
            {"IsOgham",                             "\u1680\u16A0"},
            {"IsOpticalCharacterRecognition",       "\u2440\u2460"},
            {"IsOriya",                             "\u0B00\u0B80"},
            {"IsPrivateUse",                        "\uE000\uF900"},
            {"IsRunic",                             "\u16A0\u1700"},
            {"IsSinhala",                           "\u0D80\u0E00"},
            {"IsSmallFormVariants",                 "\uFE50\uFE70"},
            {"IsSpacingModifierLetters",            "\u02B0\u0300"},
            {"IsSpecials",                          "\uFEFF\uFF00\uFFF0\uFFFE"},
            {"IsSuperscriptsandSubscripts",         "\u2070\u20A0"},
            {"IsSyriac",                            "\u0700\u0750"},
            {"IsTamil",                             "\u0B80\u0C00"},
            {"IsTelugu",                            "\u0C00\u0C80"},
            {"IsThaana",                            "\u0780\u07C0"},
            {"IsThai",                              "\u0E00\u0E80"},
            {"IsTibetan",                           "\u0F00\u1000"},
            {"IsUnifiedCanadianAboriginalSyllabics","\u1400\u1680"},
            {"IsYiRadicals",                        "\uA490\uA4D0"},
            {"IsYiSyllables",                       "\uA000\uA490"},
        };

        internal static String SetFromProperty(String capname, bool invert, string pattern) {
            int min = 0;
            int max = _propTable.GetLength(0);
            while (min != max) {
                int mid = (min + max) / 2;
                int res = String.Compare(capname, _propTable[mid,0], false, CultureInfo.InvariantCulture);
                if (res < 0)
                    max = mid;
                else if (res > 0)
                    min = mid + 1;
                else {
                    String set = _propTable[mid,1];
                    return invert ? SetInverse(set): set;
                }
            }
            throw new ArgumentException(SR.GetString(SR.MakeException, pattern, SR.GetString(SR.UnknownProperty, capname)), pattern); 
            //return invert ? Any : Empty ;
        }

#if DBG
        /*
         * SetDescription()
         *
         * Produces a human-readable description for a set string.
         */
        internal static String SetDescription(String set) {
            if (set.Equals(Any))
                return "[^]";

            if (set.Equals(Empty))
                return "[]";

            StringBuilder desc = new StringBuilder("[");

            int index;
            char ch1;
            char ch2;

            if (set[0] == Nullchar) {
                index = 1;
                desc.Append('^');
            }
            else {
                index = 0;
            }

            while (index < set.Length) {
                ch1 = set[index];
                if (index + 1 < set.Length)
                    ch2 = (char)(set[index + 1] - 1);
                else
                    ch2 = Lastchar;

                desc.Append(CharDescription(ch1));

                if (ch2 != ch1) {
                    if (ch1 + 1 != ch2)
                        desc.Append('-');
                    desc.Append(CharDescription(ch2));
                }
                index += 2;
            }

            desc.Append(']');

            return desc.ToString();
        }

        internal static readonly char [] Hex = new char [] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

        /*
         * CharDescription()
         *
         * Produces a human-readable description for a single character.
         */
        internal static String CharDescription(char ch) {
            StringBuilder sb = new StringBuilder();
            int shift;

            if (ch == '\\')
                return "\\\\";

            if (ch >= ' ' && ch <= '~') {
                sb.Append(ch);
                return sb.ToString();
            }

            if (ch < 256) {
                sb.Append("\\x");
                shift = 8;
            }
            else {
                sb.Append("\\u");
                shift = 16;
            }

            while (shift > 0) {
                shift -= 4;
                sb.Append(Hex[(ch >> shift) & 0xF]);
            }

            return sb.ToString();
        }
#endif

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexcompilationinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexCompilationInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Text.RegularExpressions {
    using System;

    /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo"]/*' />
    /// <devdoc>
    ///    <para>
    ///       [To be supplied]
    ///    </para>
    /// </devdoc>
    [ Serializable() ] 
    public class RegexCompilationInfo { 
        private String           pattern;
        private RegexOptions     options;
        private String           name;
        private String           nspace;
        private bool             isPublic;

        /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo.RegexCompilationInfo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       [To be supplied]
        ///    </para>
        /// </devdoc>
        public RegexCompilationInfo(String pattern, RegexOptions options, String name, String fullnamespace, bool ispublic) {
            Pattern = pattern;
            Name = name;
            Namespace = fullnamespace;
            this.options = options;
            isPublic = ispublic;
        }

        /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo.Pattern"]/*' />
        /// <devdoc>
        ///    <para>
        ///       [To be supplied]
        ///    </para>
        /// </devdoc>
        public String Pattern {
            get { return pattern; }
            set { 
                if (value == null)
                    throw new ArgumentNullException("value");
                pattern = value;
            }
        }

        /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo.Options"]/*' />
        /// <devdoc>
        ///    <para>
        ///       [To be supplied]
        ///    </para>
        /// </devdoc>
        public RegexOptions Options {
            get { return options; }
            set { options = value;}
        }

        /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       [To be supplied]
        ///    </para>
        /// </devdoc>
        public String Name {
            get { return name; }
            set { 
                if (value == null)
                    throw new ArgumentNullException("value");
                name = value;
            }
        }

        /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo.Namespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       [To be supplied]
        ///    </para>
        /// </devdoc>
        public String Namespace {
            get { return nspace; }
            set { 
                if (value == null)
                    throw new ArgumentNullException("value");
                nspace = value;
            }
        }

        /// <include file='doc\RegexCompilationInfo.uex' path='docs/doc[@for="RegexCompilationInfo.IsPublic"]/*' />
        /// <devdoc>
        ///    <para>
        ///       [To be supplied]
        ///    </para>
        /// </devdoc>
        public bool IsPublic {
            get { return isPublic; }
            set { isPublic = value;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexcapturecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexCaptureCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The CaptureCollection lists the captured Capture numbers
 * contained in a compiled Regex.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *  6/01/99 (dbau)      First draft
 */

namespace System.Text.RegularExpressions {

    using System.Collections;

    /*
     * This collection returns the Captures for a group
     * in the order in which they were matched (left to right
     * or right to left). It is created by Group.Captures
     */
    /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a sequence of capture substrings. The object is used
    ///       to return the set of captures done by a single capturing group.
    ///    </para>
    /// </devdoc>
    [ Serializable() ] 
    public class CaptureCollection : ICollection {
        internal Group _group;
        internal int _capcount;
        internal Capture[] _captures;

        /*
         * Nonpublic constructor
         */
        internal CaptureCollection(Group group) {
            _group = group;
            _capcount = _group._capcount;
        }

        /*
         * The object on which to synchronize
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Object SyncRoot {
            get {
                return _group;
            }
        }

        /*
         * ICollection
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /*
         * ICollection
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return true;
            }
        }

        /*
         * The number of captures for the group
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the number of captures.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return _capcount;
            }
        }

        /*
         * The ith capture in the group
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a means of accessing a specific capture in the collection.
        ///    </para>
        /// </devdoc>
        public Capture this[int i]
        {
            get {
                return GetCapture(i);
            }
        }

        /*
         * As required by ICollection
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies all the elements of the collection to the given array
        ///       beginning at the given index.
        ///    </para>
        /// </devdoc>
        public void CopyTo(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");

            for (int i = arrayIndex, j = 0; j < Count; i++, j++) {
                array.SetValue(this[j], i);
            }
        }

        /*
         * As required by ICollection
         */
        /// <include file='doc\RegexCaptureCollection.uex' path='docs/doc[@for="CaptureCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides an enumerator in the same order as Item[].
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new CaptureEnumerator(this);
        }

        /*
         * Nonpublic code to return set of captures for the group
         */
        internal Capture GetCapture(int i) {
            if (i == _capcount - 1 && i >= 0)
                return _group;

            if (i >= _capcount || i < 0)
                throw new ArgumentOutOfRangeException("i");

            // first time a capture is accessed, compute them all
            if (_captures == null) {
                _captures = new Capture[_capcount];
                for (int j = 0; j < _capcount - 1; j++) {
                    _captures[j] = new Capture(_group._text, _group._caps[j * 2], _group._caps[j * 2 + 1]);
                }
            }

            return _captures[i];
        }
    }


    /*
     * This non-public enumerator lists all the captures
     * Should it be public?
     */
    [ Serializable() ] 
    internal class CaptureEnumerator : IEnumerator {
        internal CaptureCollection _rcc;
        internal int _curindex;

        /*
         * Nonpublic constructor
         */
        internal CaptureEnumerator(CaptureCollection rcc) {
            _curindex = -1;
            _rcc = rcc;
        }

        /*
         * As required by IEnumerator
         */
        public bool MoveNext() {
            int size = _rcc.Count;

            if (_curindex >= size)
                return false;

            _curindex++;

            return(_curindex < size);
        }

        /*
         * As required by IEnumerator
         */
        public Object Current {
            get { return Capture;}
        }

        /*
         * Returns the current capture
         */
        public Capture Capture {
            get {
                if (_curindex < 0 || _curindex > _rcc.Count)
                    throw new InvalidOperationException(SR.GetString(SR.EnumNotStarted));

                return _rcc[_curindex];
            }
        }

        /*
         * Reset to before the first item
         */
        public void Reset() {
            _curindex = -1;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexfcd.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexFCD.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexFCD class is internal to the Regex package.
 * It builds a bunch of FC information (RegexFC) about
 * the regex for optimization purposes.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/26/99 (dbau)      First draft
 *      5/11/99 (dbau)      Added comments
 */

/*
 * Implementation notes:
 * 
 * This step is as simple as walking the tree and emitting
 * sequences of codes.
 *
 * CONSIDER: perhaps we should generate MSIL directly from a tree walk?
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Globalization;
    
    internal sealed class RegexFCD {
        internal int[]      _intStack;
        internal int        _intDepth;    
        internal RegexFC[]  _fcStack;
        internal int        _fcDepth;
        internal bool    _earlyexit;
        internal bool    _skipchild;

        internal const int BeforeChild = 64;
        internal const int AfterChild = 128;

        // where the regex can be pegged

        internal const int Beginning  = 0x0001;
        internal const int Bol        = 0x0002;
        internal const int Start      = 0x0004;
        internal const int Eol        = 0x0008;
        internal const int EndZ       = 0x0010;
        internal const int End        = 0x0020;
        internal const int Boundary   = 0x0040;
#if ECMA
        internal const int ECMABoundary = 0x0080;
#endif

        internal const int infinite = RegexCode.infinite;

        /*
         * This is the one of the only two functions that should be called from outside.
         * It takes a RegexTree and computes the set of chars that can start it.
         */
        internal static RegexPrefix FirstChars(RegexTree t) {
            RegexFCD s = new RegexFCD();
            RegexFC fc = s.RegexFCFromRegexTree(t);

            if (fc._nullable)
                return null;
            
            CultureInfo culture = ((t._options & RegexOptions.CultureInvariant) != 0) ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture;
            return new RegexPrefix(fc.GetFirstChars(culture), fc.IsCaseInsensitive());
        }

        /*
         * This is a related computation: it takes a RegexTree and computes the
         * leading substring if it see one. It's quite trivial and gives up easily.
         */
        internal static RegexPrefix Prefix(RegexTree tree) {
            RegexNode curNode;
            RegexNode concatNode = null;
            int nextChild = 0;

            curNode = tree._root;

            for (;;) {
                switch (curNode._type) {
                    case RegexNode.Concatenate:
                        if (curNode.ChildCount() > 0) {
                            concatNode = curNode;
                            nextChild = 0;
                        }
                        break;

                    case RegexNode.Greedy:
                    case RegexNode.Capture:
                        curNode = curNode.Child(0);
                        concatNode = null;
                        continue;

                    case RegexNode.Oneloop:
                    case RegexNode.Onelazy:
                    case RegexNode.Multi:
                        goto OuterloopBreak;

                    case RegexNode.Bol:
                    case RegexNode.Eol:
                    case RegexNode.Boundary:
#if ECMA
                    case RegexNode.ECMABoundary:
#endif
                    case RegexNode.Beginning:
                    case RegexNode.Start:
                    case RegexNode.EndZ:
                    case RegexNode.End:
                    case RegexNode.Empty:
                    case RegexNode.Require:
                    case RegexNode.Prevent:
                        break;

                    default:
                        return RegexPrefix.Empty;
                }

                if (concatNode == null || nextChild >= concatNode.ChildCount())
                    return RegexPrefix.Empty;

                curNode = concatNode.Child(nextChild++);
            }

            OuterloopBreak:
            ;

            switch (curNode._type) {
                case RegexNode.Multi:
                    return new RegexPrefix(curNode._str, 0 != (curNode._options & RegexOptions.IgnoreCase));

                case RegexNode.Oneloop:
                    goto
                case RegexNode.Onelazy;
                case RegexNode.Onelazy:
                    if (curNode._m > 0) {
                        StringBuilder sb = new StringBuilder();
                        sb.Append(curNode._ch, curNode._m);
                        return new RegexPrefix(sb.ToString(), 0 != (curNode._options & RegexOptions.IgnoreCase));
                    }
                    // else fallthrough
                    goto default;

                default:
                    return RegexPrefix.Empty;
            }
        }

        /*
         * This is a related computation: it takes a RegexTree and computes the
         * leading []* construct if it see one. It's quite trivial and gives up easily.
         */
        internal static RegexPrefix ScanChars(RegexTree tree) {
            RegexNode curNode;
            RegexNode concatNode = null;
            int nextChild = 0;
            String foundSet = null;
            bool caseInsensitive = false;

            curNode = tree._root;

            for (;;) {
                switch (curNode._type) {
                    case RegexNode.Concatenate:
                        if (curNode.ChildCount() > 0) {
                            concatNode = curNode;
                            nextChild = 0;
                        }
                        break;

                    case RegexNode.Greedy:
                    case RegexNode.Capture:
                        curNode = curNode.Child(0);
                        concatNode = null;
                        continue;

                    case RegexNode.Bol:
                    case RegexNode.Eol:
                    case RegexNode.Boundary:
#if ECMA
                    case RegexNode.ECMABoundary:
#endif
                    case RegexNode.Beginning:
                    case RegexNode.Start:
                    case RegexNode.EndZ:
                    case RegexNode.End:
                    case RegexNode.Empty:
                    case RegexNode.Require:
                    case RegexNode.Prevent:
                        break;

                    case RegexNode.Oneloop:
                    case RegexNode.Onelazy:
                        if (curNode._n != infinite)
                            return null;

                        foundSet = RegexCharClass.SetFromChar(curNode._ch);
                        caseInsensitive = (0 != (curNode._options & RegexOptions.IgnoreCase));
                        break;

                    case RegexNode.Notoneloop:
                    case RegexNode.Notonelazy:
                        if (curNode._n != infinite)
                            return null;

                        foundSet = RegexCharClass.SetInverseFromChar(curNode._ch);
                        caseInsensitive = (0 != (curNode._options & RegexOptions.IgnoreCase));
                        break;

                    case RegexNode.Setloop:
                    case RegexNode.Setlazy:
                        if (curNode._n != infinite || (curNode._str2 != null && curNode._str2.Length != 0))
                            return null;

                        foundSet = curNode._str;
                        caseInsensitive = (0 != (curNode._options & RegexOptions.IgnoreCase));
                        break;

                    default:
                        return null;
                }

                if (foundSet != null)
                    return new RegexPrefix(foundSet, caseInsensitive);

                if (concatNode == null || nextChild >= concatNode.ChildCount())
                    return null;

                curNode = concatNode.Child(nextChild++);
            }
        }

        /*
         * Yet another related computation: it takes a RegexTree and computes the
         * leading anchors that it encounters.
         */
        internal static int Anchors(RegexTree tree) {
            RegexNode curNode;
            RegexNode concatNode = null;
            int nextChild = 0;
            int result = 0;

            curNode = tree._root;

            for (;;) {
                switch (curNode._type) {
                    case RegexNode.Concatenate:
                        if (curNode.ChildCount() > 0) {
                            concatNode = curNode;
                            nextChild = 0;
                        }
                        break;

                    case RegexNode.Greedy:
                    case RegexNode.Capture:
                        curNode = curNode.Child(0);
                        concatNode = null;
                        continue;

                    case RegexNode.Bol:
                    case RegexNode.Eol:
                    case RegexNode.Boundary:
#if ECMA
                    case RegexNode.ECMABoundary:
#endif
                    case RegexNode.Beginning:
                    case RegexNode.Start:
                    case RegexNode.EndZ:
                    case RegexNode.End:
                        return result | AnchorFromType(curNode._type);

                    case RegexNode.Empty:
                    case RegexNode.Require:
                    case RegexNode.Prevent:
                        break;

                    default:
                        return result;
                }

                if (concatNode == null || nextChild >= concatNode.ChildCount())
                    return result;

                curNode = concatNode.Child(nextChild++);
            }
        }

        /*
         * Convert anchor type to anchor bit.
         */
        internal static int AnchorFromType(int type) {
            switch (type) {
                case RegexNode.Bol:             return Bol;         
                case RegexNode.Eol:             return Eol;         
                case RegexNode.Boundary:        return Boundary;    
#if ECMA
                case RegexNode.ECMABoundary:    return ECMABoundary;
#endif
                case RegexNode.Beginning:       return Beginning;   
                case RegexNode.Start:           return Start;       
                case RegexNode.EndZ:            return EndZ;        
                case RegexNode.End:             return End;         
                default:                        return 0;
            }
        }

#if DBG
        internal static String AnchorDescription(int anchors) {
            StringBuilder sb = new StringBuilder();

            if (0 != (anchors & Beginning))     sb.Append(", Beginning");
            if (0 != (anchors & Start))         sb.Append(", Start");
            if (0 != (anchors & Bol))           sb.Append(", Bol");
            if (0 != (anchors & Boundary))      sb.Append(", Boundary");
#if ECMA
            if (0 != (anchors & ECMABoundary))  sb.Append(", ECMABoundary");
#endif
            if (0 != (anchors & Eol))           sb.Append(", Eol");
            if (0 != (anchors & End))           sb.Append(", End");
            if (0 != (anchors & EndZ))          sb.Append(", EndZ");

            if (sb.Length >= 2)
                return(sb.ToString(2, sb.Length - 2));

            return "None";
        }
#endif

        /*
         * private constructor; can't be created outside
         */
        private RegexFCD() {
            _fcStack = new RegexFC[32];
            _intStack = new int[32];
        }

        /*
         * To avoid recursion, we use a simple integer stack.
         * This is the push.
         */
        internal void PushInt(int I) {
            if (_intDepth >= _intStack.Length) {
                int [] expanded = new int[_intDepth * 2];

                System.Array.Copy(_intStack, 0, expanded, 0, _intDepth);

                _intStack = expanded;
            }

            _intStack[_intDepth++] = I;
        }

        /*
         * True if the stack is empty.
         */
        internal bool EmptyInt() {
            return _intDepth == 0;
        }

        /*
         * This is the pop.
         */
        internal int PopInt() {
            return _intStack[--_intDepth];
        }

        /*
          * We also use a stack of RegexFC objects.
          * This is the push.
          */
        internal void PushFC(RegexFC fc) {
            if (_fcDepth >= _fcStack.Length) {
                RegexFC[] expanded = new RegexFC[_fcDepth * 2];

                System.Array.Copy(_fcStack, 0, expanded, 0, _fcDepth);
                _fcStack = expanded;
            }

            _fcStack[_fcDepth++] = fc;
        }

        /*
         * True if the stack is empty.
         */
        internal bool EmptyFC() {
            return _fcDepth == 0;
        }

        /*
         * This is the pop.
         */
        internal RegexFC PopFC() {
            return _fcStack[--_fcDepth];
        }

        /*
         * This is the top.
         */
        internal RegexFC TopFC() {
            return _fcStack[_fcDepth - 1];
        }

        /*
         * The main FC computation. It does a shortcutted depth-first walk
         * through the tree and calls CalculateFC to emits code before
         * and after each child of an interior node, and at each leaf.
         */
        internal RegexFC RegexFCFromRegexTree(RegexTree tree) {
            RegexNode curNode;
            int curChild;

            curNode = tree._root;
            curChild = 0;

            for (;;) {
                if (curNode._children == null) {
                    CalculateFC(curNode._type, curNode, 0);
                }
                else if (curChild < curNode._children.Count && !_earlyexit) {
                    CalculateFC(curNode._type | BeforeChild, curNode, curChild);

                    if (!_skipchild) {
                        curNode = (RegexNode)curNode._children[curChild];
                        PushInt(curChild);
                        curChild = 0;
                    }
                    else {
                        curChild++;
                        _skipchild = false;
                    }
                    continue;
                }

                _earlyexit = false;

                if (EmptyInt())
                    break;

                curChild = PopInt();
                curNode = curNode._next;

                CalculateFC(curNode._type | AfterChild, curNode, curChild);
                curChild++;
            }

            if (EmptyFC())
                return new RegexFC(RegexCharClass.Any, true, false);

            return PopFC();
        }

        /*
         * Called in AfterChild to prevent processing of the rest of the children at the current level
         */
        internal void EarlyExit() {
            _earlyexit = true;
        }

        /*
         * Called in Beforechild to prevent further processing of the current child
         */
        internal void SkipChild() {
            _skipchild = true;
        }

        /*
         * FC computation and shortcut cases for each node type
         */
        internal void CalculateFC(int NodeType, RegexNode node, int CurIndex) {
            bool ci = false;
            bool rtl = false;

            if (NodeType <= RegexNode.Ref) {
                if ((node._options & RegexOptions.IgnoreCase) != 0)
                    ci = true;
                if ((node._options & RegexOptions.RightToLeft) != 0)
                    rtl = true;
            }

            switch (NodeType) {
                case RegexNode.Concatenate | BeforeChild:
                case RegexNode.Alternate | BeforeChild:
                case RegexNode.Testref | BeforeChild:
                case RegexNode.Loop | BeforeChild:
                case RegexNode.Lazyloop | BeforeChild:
                    break;

                case RegexNode.Testgroup | BeforeChild:
                    if (CurIndex == 0)
                        SkipChild();
                    break;

                case RegexNode.Empty:
                    PushFC(new RegexFC(true));
                    break;

                case RegexNode.Concatenate | AfterChild:
                    if (CurIndex != 0) {
                        RegexFC child = PopFC();
                        RegexFC cumul = TopFC();

                        cumul.AddFC(child, true);
                    }

                    if (!TopFC()._nullable)
                        EarlyExit();
                    break;

                case RegexNode.Testgroup | AfterChild:
                    if (CurIndex > 1) {
                        RegexFC child = PopFC();
                        RegexFC cumul = TopFC();

                        cumul.AddFC(child, false);
                    }
                    break;

                case RegexNode.Alternate | AfterChild:
                case RegexNode.Testref | AfterChild:
                    if (CurIndex != 0) {
                        RegexFC child = PopFC();
                        RegexFC cumul = TopFC();

                        cumul.AddFC(child, false);
                    }
                    break;

                case RegexNode.Loop | AfterChild:
                case RegexNode.Lazyloop | AfterChild:
                    if (node._m == 0)
                        TopFC()._nullable = true;
                    break;

                case RegexNode.Group | BeforeChild:
                case RegexNode.Group | AfterChild:
                case RegexNode.Capture | BeforeChild:
                case RegexNode.Capture | AfterChild:
                case RegexNode.Greedy | BeforeChild:
                case RegexNode.Greedy | AfterChild:
                    break;

                case RegexNode.Require | BeforeChild:
                case RegexNode.Prevent | BeforeChild:
                    SkipChild();
                    PushFC(new RegexFC(true));
                    break;

                case RegexNode.Require | AfterChild:
                case RegexNode.Prevent | AfterChild:
                    break;

                case RegexNode.One:
                case RegexNode.Notone:
                    PushFC(new RegexFC(node._ch, NodeType == RegexNode.Notone, false, ci));
                    break;

                case RegexNode.Oneloop:
                case RegexNode.Onelazy:
                    PushFC(new RegexFC(node._ch, false, node._m == 0, ci));
                    break;

                case RegexNode.Notoneloop:
                case RegexNode.Notonelazy:
                    PushFC(new RegexFC(node._ch, true, node._m == 0, ci));
                    break;

                case RegexNode.Multi:
                    if (node._str.Length == 0)
                        PushFC(new RegexFC(true));
                    else if (!rtl)
                        PushFC(new RegexFC(node._str[0], false, false, ci));
                    else
                        PushFC(new RegexFC(node._str[node._str.Length - 1], false, false, ci));
                    break;

                case RegexNode.Set:
                    // mark this node as nullable if we have some categories
                    PushFC(new RegexFC(node._str, !(node._str2 == null || node._str2.Length == 0), ci));
                    break;

                case RegexNode.Setloop:
                case RegexNode.Setlazy:
                    // don't need to worry about categories since this is nullable
                    PushFC(new RegexFC(node._str, true, ci));
                    break;

                case RegexNode.Ref:
                    PushFC(new RegexFC(RegexCharClass.Any, true, false));
                    break;

                case RegexNode.Nothing:
                case RegexNode.Bol:
                case RegexNode.Eol:
                case RegexNode.Boundary:
                case RegexNode.Nonboundary:
#if ECMA
                case RegexNode.ECMABoundary:
                case RegexNode.NonECMABoundary:
#endif
                case RegexNode.Beginning:
                case RegexNode.Start:
                case RegexNode.EndZ:
                case RegexNode.End:
                    PushFC(new RegexFC(true));
                    break;

                default:
                    throw new ArgumentException(SR.GetString(SR.UnexpectedOpcode, NodeType.ToString()));
            }
        }
    }

    internal sealed class RegexFC {
        internal RegexCharClass _cc;
        internal bool _nullable;
        internal bool _caseInsensitive;

        internal RegexFC(bool nullable) {
            _cc = new RegexCharClass();
            _nullable = nullable;
        }

        internal RegexFC(char ch, bool not, bool nullable, bool caseInsensitive) {
            _cc = new RegexCharClass();

            if (not) {
                if (ch > 0)
                    _cc.AddRange('\0', (char)(ch - 1));
                if (ch < 0xFFFF)
                    _cc.AddRange((char)(ch + 1), '\uFFFF');
            }
            else {
                _cc.AddRange(ch, ch);
            }

            _caseInsensitive = caseInsensitive;
            _nullable = nullable;
        }

        internal RegexFC(String set, bool nullable, bool caseInsensitive) {
            _cc = new RegexCharClass();

            _cc.AddSet(set);
            _nullable = nullable;
            _caseInsensitive = caseInsensitive;
        }

        internal void AddFC(RegexFC fc, bool concatenate) {
            if (concatenate) {
                if (!_nullable)
                    return;

                if (!fc._nullable)
                    _nullable = false;
            }
            else {
                if (fc._nullable)
                    _nullable = true;
            }

            _caseInsensitive |= fc._caseInsensitive;
            _cc.AddCharClass(fc._cc);
        }

        internal String GetFirstChars(CultureInfo culture) {
            return _cc.ToSetCi(_caseInsensitive, culture);
        }
        
        internal bool IsCaseInsensitive() {
            return _caseInsensitive;
        }
    }

    internal sealed class RegexPrefix {
        internal RegexPrefix(String prefix, bool ci) {
            _prefix = prefix;
            _caseInsensitive = ci;
        }

        internal String Prefix {
            get {
                return _prefix;
            }
        }

        internal bool CaseInsensitive {
            get {
                return _caseInsensitive;
            }
        }

        internal String _prefix;
        internal bool _caseInsensitive;

        internal static RegexPrefix _empty = new RegexPrefix(String.Empty, false);

        internal static RegexPrefix Empty {
            get {
                return _empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexinterpreter.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexInterpreter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexInterpreter class is internal to the RegularExpression package.
 * It executes a block of regular expression codes while consuming
 * input.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/28/99 (dbau)      First draft
 *
 */

/*
 * Implementation notes:
 * 
 *
 */
#define ECMA

namespace System.Text.RegularExpressions
{

    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
        
    internal sealed class RegexInterpreter : RegexRunner {
        internal int runoperator;
        internal int [] runcodes;
        internal int runcodepos;
        internal String [] runstrings;
        internal RegexCode runcode;
        internal RegexPrefix runfcPrefix;
        internal RegexPrefix runscPrefix;
        internal RegexBoyerMoore runbmPrefix;
        internal int runanchors;
        internal bool runrtl;
        internal bool runci;
        internal CultureInfo runculture;

        internal const int infinite = RegexNode.infinite;

        internal RegexInterpreter(RegexCode code, CultureInfo culture) {
            runcode       = code;
            runcodes      = code._codes;
            runstrings    = code._strings;
            runfcPrefix   = code._fcPrefix;
            runscPrefix   = code._scPrefix;
            runbmPrefix   = code._bmPrefix;
            runanchors    = code._anchors;
            runculture    = culture;
        }

        protected override void InitTrackCount() {
            runtrackcount = runcode._trackcount;
        }

        private void Advance() {
            Advance(0);
        }

        private void Advance(int i) {
            runcodepos += (i + 1);
            SetOperator(runcodes[runcodepos]);
        }

        private void Goto(int newpos) {
            // when branching backward, ensure storage
            if (newpos < runcodepos)
                EnsureStorage();

            SetOperator(runcodes[newpos]);
            runcodepos = newpos;
        }

        private void Textto(int newpos) {
            runtextpos = newpos;
        }

        private void Trackto(int newpos) {
            runtrackpos = runtrack.Length - newpos;
        }

        private int Textstart() {
            return runtextstart;
        }

        private int Textpos() {
            return runtextpos;
        }

        // push onto the backtracking stack
        private int Trackpos() {
            return runtrack.Length - runtrackpos;
        }

        private void Track() {
            runtrack[--runtrackpos] = runcodepos;
        }

        private void Track(int I1) {
            runtrack[--runtrackpos] = I1;
            runtrack[--runtrackpos] = runcodepos;
        }

        private void Track(int I1, int I2) {
            runtrack[--runtrackpos] = I1;
            runtrack[--runtrackpos] = I2;
            runtrack[--runtrackpos] = runcodepos;
        }

        private void Track(int I1, int I2, int I3) {
            runtrack[--runtrackpos] = I1;
            runtrack[--runtrackpos] = I2;
            runtrack[--runtrackpos] = I3;
            runtrack[--runtrackpos] = runcodepos;
        }

        private void Track2(int I1) {
            runtrack[--runtrackpos] = I1;
            runtrack[--runtrackpos] = -runcodepos;
        }

        private void Track2(int I1, int I2) {
            runtrack[--runtrackpos] = I1;
            runtrack[--runtrackpos] = I2;
            runtrack[--runtrackpos] = -runcodepos;
        }

        private void Backtrack() {
            int newpos = runtrack[runtrackpos++];
            if (newpos < 0) {
                newpos = -newpos;
                SetOperator(runcodes[newpos] | RegexCode.Back2);
            }
            else {
                SetOperator(runcodes[newpos] | RegexCode.Back);
            }

            // When branching backward, ensure storage
            if (newpos < runcodepos)
                EnsureStorage();

            runcodepos = newpos;
        }

        private void SetOperator(int op) {
            runci         = (0 != (op & RegexCode.Ci));
            runrtl        = (0 != (op & RegexCode.Rtl));
            runoperator   = op & ~(RegexCode.Rtl | RegexCode.Ci);
        }

        // pop framesize items from the backtracking stack
        private void Trackframe(int framesize) {
            runtrackpos += framesize;
        }

        // get the ith element down on the backtracking stack
        private int Tracked(int i) {
            return runtrack[runtrackpos - i - 1];
        }

        // Push onto the grouping stack
        private void Stack(int I1) {
            runstack[--runstackpos] = I1;
        }

        private void Stack(int I1, int I2) {
            runstack[--runstackpos] = I1;
            runstack[--runstackpos] = I2;
        }

        // pop framesize items from the grouping stack
        private void Stackframe(int framesize) {
            runstackpos += framesize;
        }

        // get the ith element down on the grouping stack
        private int Stacked(int i) {
            return runstack[runstackpos - i - 1];
        }

        private int Operator() {
            return runoperator;
        }

        private int Operand(int i) {
            return runcodes[runcodepos + i + 1];
        }

        private int Leftchars() {
            return runtextpos - runtextbeg;
        }

        private int Rightchars() {
            return runtextend - runtextpos;
        }

        private int Bump() {
            return runrtl ? -1 : 1;
        }

        private int Forwardchars() {
            return runrtl ? runtextpos - runtextbeg : runtextend - runtextpos;
        }

        private char Forwardcharnext() {
            char ch = (runrtl ? runtext[--runtextpos] : runtext[runtextpos++]);

            return(runci ? Char.ToLower(ch, runculture) : ch);
        }

        private bool Stringmatch(String str) {
            int c;
            int pos;

            if (!runrtl) {
                if (runtextend - runtextpos < (c = str.Length))
                    return false;

                pos = runtextpos + c;
            }
            else {
                if (runtextpos - runtextbeg < (c = str.Length))
                    return false;

                pos = runtextpos;
            }

            if (!runci) {
                while (c != 0)
                    if (str[--c] != runtext[--pos])
                        return false;
            }
            else {
                while (c != 0)
                    if (str[--c] != Char.ToLower(runtext[--pos], runculture))
                        return false;
            }

            if (!runrtl) {
                pos += str.Length;
            }

            runtextpos = pos;

            return true;
        }

        private bool Refmatch(int index, int len) {
            int c;
            int pos;
            int cmpos;

            if (!runrtl) {
                if (runtextend - runtextpos < len)
                    return false;

                pos = runtextpos + len;
            }
            else {
                if (runtextpos - runtextbeg < len)
                    return false;

                pos = runtextpos;
            }
            cmpos = index + len;

            c = len;

            if (!runci) {
                while (c-- != 0)
                    if (runtext[--cmpos] != runtext[--pos])
                        return false;
            }
            else {
                while (c-- != 0)
                    if (Char.ToLower(runtext[--cmpos], runculture) != Char.ToLower(runtext[--pos], runculture))
                        return false;
            }

            if (!runrtl) {
                pos += len;
            }

            runtextpos = pos;

            return true;
        }

        private void Backwardnext() {
            runtextpos += runrtl ? 1 : -1;
        }

        private char CharAt(int j) {
            return runtext[j];
        }

        protected override bool FindFirstChar() {
            int i;
            String set;

            if (0 != (runanchors & (RegexFCD.Beginning | RegexFCD.Start | RegexFCD.EndZ | RegexFCD.End))) {
                if (!runcode._rightToLeft) {
                    if ((0 != (runanchors & RegexFCD.Beginning) && runtextpos > runtextbeg) ||
                        (0 != (runanchors & RegexFCD.Start) && runtextpos > runtextstart)) {
                        runtextpos = runtextend;
                        return false;
                    }
                    if (0 != (runanchors & RegexFCD.EndZ) && runtextpos < runtextend - 1) {
                        runtextpos = runtextend - 1;
                    }
                    else if (0 != (runanchors & RegexFCD.End) && runtextpos < runtextend) {
                        runtextpos = runtextend;
                    }
                }
                else {
                    if ((0 != (runanchors & RegexFCD.End) && runtextpos < runtextend) ||
                        (0 != (runanchors & RegexFCD.EndZ) && (runtextpos < runtextend - 1 ||
                                                               (runtextpos == runtextend - 1 && CharAt(runtextpos) != '\n'))) ||
                        (0 != (runanchors & RegexFCD.Start) && runtextpos < runtextstart)) {
                        runtextpos = runtextbeg;
                        return false;
                    }
                    if (0 != (runanchors & RegexFCD.Beginning) && runtextpos > runtextbeg) {
                        runtextpos = runtextbeg;
                    }
                }

                if (runbmPrefix != null) {
                    return runbmPrefix.IsMatch(runtext, runtextpos, runtextbeg, runtextend);
                }
            }
            else if (runbmPrefix != null) {
                runtextpos = runbmPrefix.Scan(runtext, runtextpos, runtextbeg, runtextend);

                if (runtextpos == -1) {
                    runtextpos = (runcode._rightToLeft ? runtextbeg : runtextend);
                    return false;
                }

                return true;
            }

            if (runfcPrefix == null)
                return true;

            runrtl = runcode._rightToLeft;
            runci = runfcPrefix.CaseInsensitive;
            set = runfcPrefix.Prefix;

            if (RegexCharClass.IsSingleton(set)) {
                char ch = RegexCharClass.SingletonChar(set);

                for (i = Forwardchars(); i > 0; i--) {
                    if (ch == Forwardcharnext()) {
                        Backwardnext();
                        return true;
                    }
                }
            }
            else {
                for (i = Forwardchars(); i > 0; i--) {
                    if (RegexCharClass.CharInSet(Forwardcharnext(), set, String.Empty)) {
                        Backwardnext();
                        return true;
                    }
                }
            }
            return false;
        }

        protected override void Go() {
            Goto(0);

            for (;;) {
#if DBG
                if (runmatch.Debug) {
                    DumpState();
                }
#endif

                switch (Operator()) {
                    case RegexCode.Stop:
                        return;

                    case RegexCode.Nothing:
                        break;

                    case RegexCode.Goto:
                        Goto(Operand(0));
                        continue;

                    case RegexCode.Testref:
                        if (!IsMatched(Operand(0)))
                            break;
                        Advance(1);
                        continue;

                    case RegexCode.Lazybranch:
                        Track(Textpos());
                        Advance(1);
                        continue;

                    case RegexCode.Lazybranch | RegexCode.Back:
                        Trackframe(1);
                        Textto(Tracked(0));
                        Goto(Operand(0));
                        continue;

                    case RegexCode.Setmark:
                        Stack(Textpos());
                        Track();
                        Advance();
                        continue;

                    case RegexCode.Nullmark:
                        Stack(-1);
                        Track();
                        Advance();
                        continue;

                    case RegexCode.Setmark | RegexCode.Back:
                    case RegexCode.Nullmark | RegexCode.Back:
                        Stackframe(1);
                        break;

                    case RegexCode.Getmark:
                        Stackframe(1);
                        Track(Stacked(0));
                        Textto(Stacked(0));
                        Advance();
                        continue;

                    case RegexCode.Getmark | RegexCode.Back:
                        Trackframe(1);
                        Stack(Tracked(0));
                        break;

                    case RegexCode.Capturemark:
                        if (Operand(1) != -1 && !IsMatched(Operand(1)))
                            break;
                        Stackframe(1);
                        if (Operand(1) != -1)
                            TransferCapture(Operand(0), Operand(1), Stacked(0), Textpos());
                        else
                            Capture(Operand(0), Stacked(0), Textpos());
                        Track(Stacked(0));

                        Advance(2);
                        
                        /*  This is code for ASURT 78559
                            Also need to "uncapture" the groups in 'runstrings[Operand(2)]'
                            in 'case RegexCode.Capturemark | RegexCode.Back'
                        string groups = runstrings[Operand(2)];
                        for (int i=0; i<groups.Length; i++) {
                            int g = (int) groups[i];
                            if (runmatch.GroupCaptureCount(g) < runmatch.GroupCaptureCount(Operand(0)))
                                Capture(g, Textpos(), Textpos());
                        }                                
                       
                        Advance(3);
                        */
                        continue;

                    case RegexCode.Capturemark | RegexCode.Back:
                        Trackframe(1);
                        Stack(Tracked(0));
                        Uncapture();
                        if (Operand(0) != -1 && Operand(1) != -1)
                            Uncapture();

                        break;

                    case RegexCode.Branchmark:
                        {
                            int matched;
                            Stackframe(1);

                            matched = Textpos() - Stacked(0);

                            if (matched != 0) {                                   // Nonempty match -> loop now
                                Track(Stacked(0), Textpos());   // Save old mark, textpos
                                Stack(Textpos());               // Make new mark
                                Goto(Operand(0));               // Loop
                            }
                            else {                                   // Empty match -> straight now
                                Track2(Stacked(0));             // Save old mark
                                Advance(1);                     // Straight
                            }
                            continue;
                        }

                    case RegexCode.Branchmark | RegexCode.Back:
                        Trackframe(2);
                        Stackframe(1);
                        Textto(Tracked(1));                     // Recall position
                        Track2(Tracked(0));                     // Save old mark
                        Advance(1);                             // Straight
                        continue;

                    case RegexCode.Branchmark | RegexCode.Back2:
                        Trackframe(1);
                        Stack(Tracked(0));                      // Recall old mark
                        break;                                  // Backtrack

                    case RegexCode.Lazybranchmark:
                        {
                            int matched;
                            Stackframe(1);

                            matched = Textpos() - Stacked(0);

                            if (matched != 0) {                                   // Nonempty match -> next loop
                                Track(Stacked(0), Textpos());   // Save old mark, textpos
                            }
                            else {                                   // Empty match -> no loop
                                Track2(Stacked(0));             // Save old mark
                            }
                            Advance(1);
                            continue;
                        }

                    case RegexCode.Lazybranchmark | RegexCode.Back:
                        {
                            int pos;

                            Trackframe(2);
                            pos = Tracked(1);
                            Track2(Tracked(0));                 // Save old mark
                            Stack(pos);                         // Make new mark
                            Textto(pos);                        // Recall position
                            Goto(Operand(0));                   // Loop
                            continue;
                        }

                    case RegexCode.Lazybranchmark | RegexCode.Back2:
                        Stackframe(1);
                        Trackframe(1);
                        Stack(Tracked(0));                      // Recall old mark
                        break;

                    case RegexCode.Setcount:
                        Stack(Textpos(), Operand(0));
                        Track();
                        Advance(1);
                        continue;

                    case RegexCode.Nullcount:
                        Stack(-1, Operand(0));
                        Track();
                        Advance(1);
                        continue;

                    case RegexCode.Setcount | RegexCode.Back:
                        Stackframe(2);
                        break;

                    case RegexCode.Nullcount | RegexCode.Back:
                        Stackframe(2);
                        break;

                    case RegexCode.Branchcount:
                        // Stack:
                        //  0: Mark
                        //  1: Count
                        {
                            Stackframe(2);
                            int mark = Stacked(0);
                            int count = Stacked(1);
                            int matched = Textpos() - mark;

                            if (count >= Operand(1) || (matched == 0 && count >= 0)) {                                   // Max loops or empty match -> straight now
                                Track2(mark, count);            // Save old mark, count
                                Advance(2);                     // Straight
                            }
                            else {                                   // Nonempty match -> count+loop now
                                Track(mark);                    // remember mark
                                Stack(Textpos(), count + 1);    // Make new mark, incr count
                                Goto(Operand(0));               // Loop
                            }
                            continue;
                        }

                    case RegexCode.Branchcount | RegexCode.Back:
                        // Track:
                        //  0: Previous mark
                        // Stack:
                        //  0: Mark (= current pos, discarded)
                        //  1: Count
                        Trackframe(1);
                        Stackframe(2);
                        if (Stacked(1) > 0) {                     // Positive -> can go straight
                            Textto(Stacked(0));                 // Zap to mark
                            Track2(Tracked(0), Stacked(1) - 1); // Save old mark, old count
                            Advance(2);                         // Straight
                            continue;
                        }
                        Stack(Tracked(0), Stacked(1) - 1);      // recall old mark, old count
                        break;

                    case RegexCode.Branchcount | RegexCode.Back2:
                        // Track:
                        //  0: Previous mark
                        //  1: Previous count
                        Trackframe(2);
                        Stack(Tracked(0), Tracked(1));          // Recall old mark, old count
                        break;                                  // Backtrack


                    case RegexCode.Lazybranchcount:
                        // Stack:
                        //  0: Mark
                        //  1: Count
                        {
                            Stackframe(2);
                            int mark = Stacked(0);
                            int count = Stacked(1);

                            if (count < 0) {                                   // Negative count -> loop now
                                Track2(mark);                   // Save old mark
                                Stack(Textpos(), count + 1);    // Make new mark, incr count
                                Goto(Operand(0));               // Loop
                            }
                            else {                                   // Nonneg count -> straight now
                                Track(mark, count, Textpos());  // Save mark, count, position
                                Advance(2);                     // Straight
                            }
                            continue;
                        }

                    case RegexCode.Lazybranchcount | RegexCode.Back:
                        // Track:
                        //  0: Mark
                        //  1: Count
                        //  2: Textpos
                        {
                            Trackframe(3);
                            int mark = Tracked(0);
                            int textpos = Tracked(2);
                            if (Tracked(1) <= Operand(1) && textpos != mark) {                                       // Under limit and not empty match -> loop
                                Textto(textpos);                    // Recall position
                                Stack(textpos, Tracked(1) + 1);     // Make new mark, incr count
                                Track2(mark);                       // Save old mark
                                Goto(Operand(0));                   // Loop
                                continue;
                            }
                            else {                                       // Max loops or empty match -> backtrack
                                Stack(Tracked(0), Tracked(1));      // Recall old mark, count
                                break;                              // backtrack
                            }
                        }

                    case RegexCode.Lazybranchcount | RegexCode.Back2:
                        // Track:
                        //  0: Previous mark
                        // Stack:
                        //  0: Mark (== current pos, discarded)
                        //  1: Count
                        Trackframe(1);
                        Stackframe(2);
                        Stack(Tracked(0), Stacked(1) - 1);  // Recall old mark, count
                        break;                              // Backtrack

                    case RegexCode.Setjump:
                        Stack(Trackpos(), Crawlpos());
                        Track();
                        Advance();
                        continue;

                    case RegexCode.Setjump | RegexCode.Back:
                        Stackframe(2);
                        break;

                    case RegexCode.Backjump:
                        // Stack:
                        //  0: Saved trackpos
                        //  1: Crawlpos
                        Stackframe(2);
                        Trackto(Stacked(0));

                        while (Crawlpos() != Stacked(1))
                            Uncapture();

                        break;

                    case RegexCode.Forejump:
                        // Stack:
                        //  0: Saved trackpos
                        //  1: Crawlpos
                        Stackframe(2);
                        Trackto(Stacked(0));
                        Track(Stacked(1));
                        Advance();
                        continue;

                    case RegexCode.Forejump | RegexCode.Back:
                        // Track:
                        //  0: Crawlpos
                        Trackframe(1);

                        while (Crawlpos() != Tracked(0))
                            Uncapture();

                        break;

                    case RegexCode.Bol:
                        if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')
                            break;
                        Advance();
                        continue;

                    case RegexCode.Eol:
                        if (Rightchars() > 0 && CharAt(Textpos()) != '\n')
                            break;
                        Advance();
                        continue;

                    case RegexCode.Boundary:
                        if (!IsBoundary(Textpos(), runtextbeg, runtextend))
                            break;
                        Advance();
                        continue;

                    case RegexCode.Nonboundary:
                        if (IsBoundary(Textpos(), runtextbeg, runtextend))
                            break;
                        Advance();
                        continue;

#if ECMA
                    case RegexCode.ECMABoundary:
                        if (!IsECMABoundary(Textpos(), runtextbeg, runtextend))
                            break;
                        Advance();
                        continue;

                    case RegexCode.NonECMABoundary:
                        if (IsECMABoundary(Textpos(), runtextbeg, runtextend))
                            break;
                        Advance();
                        continue;
#endif

                    case RegexCode.Beginning:
                        if (Leftchars() > 0)
                            break;
                        Advance();
                        continue;

                    case RegexCode.Start:
                        if (Textpos() != Textstart())
                            break;
                        Advance();
                        continue;

                    case RegexCode.EndZ:
                        if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')
                            break;
                        Advance();
                        continue;

                    case RegexCode.End:
                        if (Rightchars() > 0)
                            break;
                        Advance();
                        continue;

                    case RegexCode.One:
                        if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))
                            break;

                        Advance(1);
                        continue;

                    case RegexCode.Notone:
                        if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))
                            break;

                        Advance(1);
                        continue;

                    case RegexCode.Set:
                        if (Forwardchars() < 1 || !RegexCharClass.CharInSet(Forwardcharnext(), runstrings[Operand(0)], runstrings[Operand(1)]))
                            break;

                        Advance(2);
                        continue;

                    case RegexCode.Multi:
                        {
                            if (!Stringmatch(runstrings[Operand(0)]))
                                break;

                            Advance(1);
                            continue;
                        }

                    case RegexCode.Ref:
                        {
                            int capnum = Operand(0);

                            if (IsMatched(capnum)) {
                                if (!Refmatch(MatchIndex(capnum), MatchLength(capnum)))
                                    break;
                            } else {
#if ECMA
                                if ((runregex.roptions & RegexOptions.ECMAScript) == 0)
#endif
                                    break;
                            }

                            Advance(1);
                            continue;
                        }

                    case RegexCode.Onerep:
                        {
                            int c = Operand(1);

                            if (Forwardchars() < c)
                                break;

                            char ch = (char)Operand(0);

                            while (c-- > 0)
                                if (Forwardcharnext() != ch)
                                    goto BreakBackward;

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Notonerep:
                        {
                            int c = Operand(1);

                            if (Forwardchars() < c)
                                break;

                            char ch = (char)Operand(0);

                            while (c-- > 0)
                                if (Forwardcharnext() == ch)
                                    goto BreakBackward;

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Setrep:
                        {
                            int c = Operand(2);

                            if (Forwardchars() < c)
                                break;

                            String set = runstrings[Operand(0)];
                            String cat = runstrings[Operand(1)];

                            while (c-- > 0)
                                if (!RegexCharClass.CharInSet(Forwardcharnext(), set, cat))
                                    goto BreakBackward;

                            Advance(3);
                            continue;
                        }

                    case RegexCode.Oneloop:
                        {
                            int c = Operand(1);

                            if (c > Forwardchars())
                                c = Forwardchars();

                            char ch = (char)Operand(0);
                            int i;

                            for (i = c; i > 0; i--) {
                                if (Forwardcharnext() != ch) {
                                    Backwardnext();
                                    break;
                                }
                            }

                            if (c > i)
                                Track(c - i - 1, Textpos() - Bump());

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Notoneloop:
                        {
                            int c = Operand(1);

                            if (c > Forwardchars())
                                c = Forwardchars();

                            char ch = (char)Operand(0);
                            int i;

                            for (i = c; i > 0; i--) {
                                if (Forwardcharnext() == ch) {
                                    Backwardnext();
                                    break;
                                }
                            }

                            if (c > i)
                                Track(c - i - 1, Textpos() - Bump());

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Setloop:
                        {
                            int c = Operand(2);

                            if (c > Forwardchars())
                                c = Forwardchars();

                            String set = runstrings[Operand(0)];
                            String cat = runstrings[Operand(1)];
                            int i;

                            for (i = c; i > 0; i--) {
                                if (!RegexCharClass.CharInSet(Forwardcharnext(), set, cat)) {
                                    Backwardnext();
                                    break;
                                }
                            }

                            if (c > i)
                                Track(c - i - 1, Textpos() - Bump());

                            Advance(3);
                            continue;
                        }

                    case RegexCode.Oneloop | RegexCode.Back:
                    case RegexCode.Notoneloop | RegexCode.Back:
                        {
                            Trackframe(2);
                            int i   = Tracked(0);
                            int pos = Tracked(1);

                            Textto(pos);

                            if (i > 0)
                                Track(i - 1, pos - Bump());

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Setloop | RegexCode.Back:
                        {
                            Trackframe(2);
                            int i   = Tracked(0);
                            int pos = Tracked(1);

                            Textto(pos);

                            if (i > 0)
                                Track(i - 1, pos - Bump());

                            Advance(3);
                            continue;
                        }

                    case RegexCode.Onelazy:
                    case RegexCode.Notonelazy:
                        {
                            int c = Operand(1);

                            if (c > Forwardchars())
                                c = Forwardchars();

                            if (c > 0)
                                Track(c - 1, Textpos());

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Setlazy:
                        {
                            int c = Operand(2);

                            if (c > Forwardchars())
                                c = Forwardchars();

                            if (c > 0)
                                Track(c - 1, Textpos());

                            Advance(3);
                            continue;
                        }

                    case RegexCode.Onelazy | RegexCode.Back:
                        {
                            Trackframe(2);
                            int pos = Tracked(1);
                            Textto(pos);

                            if (Forwardcharnext() != (char)Operand(0))
                                break;

                            int i = Tracked(0);

                            if (i > 0)
                                Track(i - 1, pos + Bump());

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Notonelazy | RegexCode.Back:
                        {
                            Trackframe(2);
                            int pos = Tracked(1);
                            Textto(pos);

                            if (Forwardcharnext() == (char)Operand(0))
                                break;

                            int i = Tracked(0);

                            if (i > 0)
                                Track(i - 1, pos + Bump());

                            Advance(2);
                            continue;
                        }

                    case RegexCode.Setlazy | RegexCode.Back:
                        {
                            Trackframe(2);
                            int pos = Tracked(1);
                            Textto(pos);

                            if (!RegexCharClass.CharInSet(Forwardcharnext(), runstrings[Operand(0)], runstrings[Operand(1)]))
                                break;

                            int i = Tracked(0);

                            if (i > 0)
                                Track(i - 1, pos + Bump());

                            Advance(3);
                            continue;
                        }

                    default:
                        throw new NotImplementedException(SR.GetString(SR.UnimplementedState));
                }

                BreakBackward: 
                ;

                // "break Backward" comes here:
                Backtrack();
            }

        }

#if DBG
        public override void DumpState() {
            base.DumpState();
            Debug.WriteLine("       " + runcode.OpcodeDescription(runcodepos) +
                              ((runoperator & RegexCode.Back) != 0 ? " Back" : "") +
                              ((runoperator & RegexCode.Back2) != 0 ? " Back2" : ""));
        }
#endif

    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexgroup.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Group represents the substring or substrings that
 * are captured by a single capturing group after one
 * regular expression match.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/28/99 (dbau)      First draft
 *
 */

namespace System.Text.RegularExpressions {

    /// <include file='doc\RegexGroup.uex' path='docs/doc[@for="Group"]/*' />
    /// <devdoc>
    ///    Group 
    ///       represents the results from a single capturing group. A capturing group can
    ///       capture zero, one, or more strings in a single match because of quantifiers, so
    ///       Group supplies a collection of Capture objects. 
    ///    </devdoc>
    [ Serializable() ] 
    public class Group : Capture {
        // the empty group object
        internal static Group   _emptygroup = new Group(String.Empty, new int[0], 0);
        
        internal int[] _caps;
        internal int _capcount;
        internal CaptureCollection _capcoll;

        internal Group(String text, int[] caps, int capcount)

        : base(text, capcount == 0 ? 0 : caps[(capcount - 1) * 2],
               capcount == 0 ? 0 : caps[(capcount * 2) - 1]) {

            _caps = caps;
            _capcount = capcount;
        }

        /*
         * True if the match was successful
         */
        /// <include file='doc\RegexGroup.uex' path='docs/doc[@for="Group.Success"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the match is successful.</para>
        /// </devdoc>
        public bool Success {
            get {
                return _capcount != 0;
            }
        }

        /*
         * The collection of all captures for this group
         */
        /// <include file='doc\RegexGroup.uex' path='docs/doc[@for="Group.Captures"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a collection of all the captures matched by the capturing
        ///       group, in innermost-leftmost-first order (or innermost-rightmost-first order if
        ///       compiled with the "r" option). The collection may have zero or more items.
        ///    </para>
        /// </devdoc>
        public CaptureCollection Captures {
            get {
                if (_capcoll == null)
                    _capcoll = new CaptureCollection(this);

                return _capcoll;
            }
        }

        /*
         * Convert to a thread-safe object by precomputing cache contents
         */
        /// <include file='doc\RegexGroup.uex' path='docs/doc[@for="Group.Synchronized"]/*' />
        /// <devdoc>
        ///    <para>Returns 
        ///       a Group object equivalent to the one supplied that is safe to share between
        ///       multiple threads.</para>
        /// </devdoc>
        static public Group Synchronized(Group inner) {
            if (inner == null)
                throw new ArgumentNullException("inner");

            // force Captures to be computed.

            CaptureCollection capcoll;
            Capture dummy;

            capcoll = inner.Captures;

            if (inner._capcount > 0)
                dummy = capcoll[0];

            return inner;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexnode.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexNode class is internal to the Regex package.
 * It is built into a parsed tree for a regular expression.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/22/99 (dbau)      First draft
 *
 */

/*
 * Implementation notes:
 * 
 * Since the node tree is a temporary data structure only used
 * during compilation of the regexp to integer codes, it's
 * designed for clarity and convenience rather than
 * space efficiency.
 *
 * RegexNodes are built into a tree, linked by the _children list.
 * Each node also has a _parent and _ichild member indicating
 * its parent and which child # it is in its parent's list.
 *
 * RegexNodes come in as many types as there are constructs in
 * a regular expression, for example, "concatenate", "alternate",
 * "one", "rept", "group". There are also node types for basic
 * peephole optimizations, e.g., "onerep", "notsetrep", etc.
 *
 * Because perl 5 allows "lookback" groups that scan backwards,
 * each node also gets a "direction". Normally the value of
 * boolean _backward = false.
 *
 * During parsing, top-level nodes are also stacked onto a parse
 * stack (a stack of trees). For this purpose we have a _next
 * pointer. [Note that to save a few bytes, we could overload the
 * _parent pointer instead.]
 *
 * On the parse stack, each tree has a "role" - basically, the
 * nonterminal in the grammar that the parser has currently
 * assigned to the tree. That code is stored in _role.
 *
 * Finally, some of the different kinds of nodes have data.
 * Two integers (for the looping constructs) are stored in
 * _operands, an an object (either a string or a set)
 * is stored in _data
 *
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Diagnostics;

    internal sealed class RegexNode {
        /*
         * RegexNode types
         * 
         */

        // the following are leaves, and correspond to primitive operations

        //    static final int Onerep     = RegexCode.Onerep;     // c,n      a {n}
        //    static final int Notonerep  = RegexCode.Notonerep;  // c,n      .{n}
        //    static final int Setrep     = RegexCode.Setrep;     // set,n    \d {n}

        internal const int Oneloop    = RegexCode.Oneloop;    // c,n      a*
        internal const int Notoneloop = RegexCode.Notoneloop; // c,n      .*
        internal const int Setloop    = RegexCode.Setloop;    // set,n    \d*

        internal const int Onelazy    = RegexCode.Onelazy;    // c,n      a*?
        internal const int Notonelazy = RegexCode.Notonelazy; // c,n      .*?
        internal const int Setlazy    = RegexCode.Setlazy;    // set,n    \d*?

        internal const int One        = RegexCode.One;        // char     a
        internal const int Notone     = RegexCode.Notone;     // char     . [^a]
        internal const int Set        = RegexCode.Set;        // set      [a-z] \w \s \d

        internal const int Multi      = RegexCode.Multi;      // string   abcdef
        internal const int Ref        = RegexCode.Ref;        // index    \1

        internal const int Bol        = RegexCode.Bol;        //          ^
        internal const int Eol        = RegexCode.Eol;        //          $
        internal const int Boundary   = RegexCode.Boundary;   //          \b
        internal const int Nonboundary= RegexCode.Nonboundary;//          \B
#if ECMA
        internal const int ECMABoundary   = RegexCode.ECMABoundary;    // \b
        internal const int NonECMABoundary= RegexCode.NonECMABoundary; // \B
#endif
        internal const int Beginning  = RegexCode.Beginning;  //          \A
        internal const int Start      = RegexCode.Start;      //          \G
        internal const int EndZ       = RegexCode.EndZ;       //          \Z
        internal const int End        = RegexCode.End;        //          \z

        // (note: End               = 21;)

        // interior nodes do not correpond to primitive operations, but
        // control structures compositing other operations

        // concat and alternate take n children, and can run forward or backwards

        internal const int Nothing    = 22;                   //          []
        internal const int Empty      = 23;                   //          ()

        internal const int Alternate  = 24;                   //          a|b
        internal const int Concatenate= 25;                   //          ab

        internal const int Loop       = 26;                   // m,x      * + ? {,}
        internal const int Lazyloop   = 27;                   // m,x      *? +? ?? {,}?

        internal const int Capture    = 28;                   // n        ()
        internal const int Group      = 29;                   //          (?:)
        internal const int Require    = 30;                   //          (?=) (?<=)
        internal const int Prevent    = 31;                   //          (?!) (?<!)
        internal const int Greedy     = 32;                   //          (?>) (?<)
        internal const int Testref    = 33;                   //          (?(n) | )
        internal const int Testgroup  = 34;                   //          (?(...) | )

        internal const int infinite = 0x7FFFFFFF;

        /*
         * RegexNode data members
         * 
         */

        internal int            _type;

        internal ArrayList      _children;

        internal String         _str;
        internal String         _str2;
        internal char           _ch;
        internal int            _m;
        internal int            _n;
        internal RegexOptions   _options;

        internal RegexNode   _next;

        internal RegexNode(int type, RegexOptions options) {
            _type = type;
            _options = options;
        }

        internal RegexNode(int type, RegexOptions options, char ch) {
            _type = type;
            _options = options;
            _ch = ch;
        }

        internal RegexNode(int type, RegexOptions options, String str) {
            _type = type;
            _options = options;
            _str = str;
        }

        internal RegexNode(int type, RegexOptions options, String str, String str2) {
            _type = type;
            _options = options;
            _str = str;
            _str2 = str2;
        }

        internal RegexNode(int type, RegexOptions options, int m) {
            _type = type;
            _options = options;
            _m = m;
        }

        internal RegexNode(int type, RegexOptions options, int m, int n) {
            _type = type;
            _options = options;
            _m = m;
            _n = n;
        }

        internal RegexNode() {
        }

        internal bool UseOptionR() {
            return(_options & RegexOptions.RightToLeft) != 0;
        }

        internal RegexNode ReverseLeft() {
            if (UseOptionR() && _type == Concatenate && _children != null) {
                _children.Reverse(0, _children.Count);
            }

            return this;
        }


        // Pass type as OneLazy or OneLoop
        internal void MakeRep(int type, int min, int max) {
            _type += (type - One);
            _m = min;
            _n = max;
        }

        /*
         * Reduce
         *
         * Removes redundant nodes from the subtree, and returns a reduced subtree.
         */
        internal RegexNode Reduce() {
            RegexNode n;

            switch (Type()) {
                case Alternate:
                    n = ReduceAlternation();
                    break;

                case Concatenate:
                    n = ReduceConcatenation();
                    break;

                case Loop:
                case Lazyloop:
                    n = ReduceRep();
                    break;

                case Group:
                    n = ReduceGroup();
                    break;

                case Set:
                case Setloop:
                    n = ReduceSet();
                    break;

                default:
                    n = this;
                    break;
            }

            return n;
        }


        /*
         * StripEnation:
         *
         * Simple optimization. If a concatenation or alternation has only
         * one child strip out the intermediate node. If it has zero children,
         * turn it into an empty.
         * 
         */

        internal RegexNode StripEnation(int emptyType) {
            switch (ChildCount()) {
                case 0:
                    return new RegexNode(emptyType, _options);
                case 1:
                    return Child(0);
                default:
                    return this;
            }
        }

        /*
         * ReduceGroup:
         *
         * Simple optimization. Once parsed into a tree, noncapturing groups
         * serve no function, so strip them out.
         */

        internal RegexNode ReduceGroup() {
            RegexNode u;

            for (u = this; u.Type() == Group; )
                u = u.Child(0);

            return u;
        }

        /*
         * ReduceRep:
         *
         * Nested repeaters just get multiplied with each other if they're not
         * too lumpy
         */

        internal RegexNode ReduceRep() {
            RegexNode u;
            RegexNode child;
            int type;
            int min;
            int max;

            u = this;
            type = Type();
            min = _m;
            max = _n;

            for (;;) {
                if (u.ChildCount() == 0)
                    break;

                child = u.Child(0);

                // multiply reps of the same type only
                if (child.Type() != type) {
                    int childType = child.Type();

                    if (!(childType >= Oneloop && childType <= Setloop && type == Loop ||
                          childType >= Onelazy && childType <= Setlazy && type == Lazyloop))
                        break;
                }

                // child can be too lumpy to blur, e.g., (a {100,105}) {3} or (a {2,})?
                // [but things like (a {2,})+ are not too lumpy...]
                if (u._m == 0 && child._m > 1 || child._n < child._m * 2)
                    break;

                u = child;
                if (u._m > 0)
                    u._m = min = ((infinite - 1) / u._m < min) ? infinite : u._m * min;
                if (u._n > 0)
                    u._n = max = ((infinite - 1) / u._n < max) ? infinite : u._n * max;
            }

            return min == infinite ? new RegexNode(Nothing, _options) : u;
        }

        /*
         * ReduceSet:
         *
         * Simple optimization. If a set is a singleton, an inverse singleton,
         * or empty, it's transformed accordingly.
         */

        internal RegexNode ReduceSet() {
            // Extract empty-set, one and not-one case as special

            if (_str2 == String.Empty) {
                if (_str == RegexCharClass.Empty) {
                    _type = Nothing;
                    _str = null;
                }
                else if (_str.Length == 2 && _str[0] + 1 == _str[1]) {
                    _ch = _str[0];
                    _str = null;
                    _type += (One - Set);
                }
                else if (_str.Length == 3 && _str[0] == '\0' && (char)(_str[1] + 1) == _str[2]) {
                    _ch = _str[1];
                    _str = null;
                    _type += (Notone - Set);
                }
            }

            return this;
        }

        /*
         * ReduceAlternation:
         *
         * Basic optimization. Single-letter alternations can be replaced
         * by faster set specifications, and nested alternations with no
         * intervening operators can be flattened:
         *
         * a|b|c|def|g|h -> [a-c]|def|[gh]
         * apple|(?:orange|pear)|grape -> apple|orange|pear|grape
         *
         * CONSIDER: common prefix reductions such as winner|windows -> win(?:ner|dows)
         */

        internal RegexNode ReduceAlternation() {
            // Combine adjacent sets/chars

            bool wasLastSet;
            RegexOptions optionsLast;
            RegexOptions optionsAt;
            int i;
            int j;
            RegexNode at;
            RegexNode prev;

            if (_children == null)
                return new RegexNode(RegexNode.Nothing, _options);

            wasLastSet = false;
            optionsLast = 0;

            for (i = 0, j = 0; i < _children.Count; i++, j++) {
                at = (RegexNode)_children[i];

                if (j < i)
                    _children[j] = at;

                for (;;) {
                    if (at._type == Alternate) {
                        for (int k = 0; k < at._children.Count; k++)
                            ((RegexNode)at._children[k])._next = this;

                        _children.InsertRange(i + 1, at._children);
                        j--;
                    }
                    else if (at._type == Set || at._type == One) {
                        // Cannot merge sets if L or I options differ
                        optionsAt = at._options & (RegexOptions.RightToLeft | RegexOptions.IgnoreCase);

                        if (!wasLastSet || optionsLast != optionsAt) {
                            wasLastSet = true;
                            optionsLast = optionsAt;
                            break;
                        }

                        // The last node was a Set or a One, we're a Set or One and our options are the same.
                        // Merge the two nodes.
                        prev = (RegexNode)_children[--j];

                        if (prev._type == RegexNode.One) {
                            prev._type = RegexNode.Set;
                            prev._str = RegexCharClass.SetFromChar(prev._ch);
                        }

                        if (at._type == RegexNode.One) 
                            prev._str = RegexCharClass.SetUnion(prev._str, RegexCharClass.SetFromChar(at._ch)); // no categories to worry about
                        else {
                            prev._str  = RegexCharClass.SetUnion(prev._str, at._str);
                            prev._str2 = RegexCharClass.CategoryUnion(prev._str2, at._str2);
                        }
                    }
                    else if (at._type == RegexNode.Nothing) {
                        j--;
                    }
                    else {
                        wasLastSet = false;
                    }
                    break;
                }
            }

            if (j < i)
                _children.RemoveRange(j, i - j);

            return StripEnation(RegexNode.Nothing);
        }

        /*
         * ReduceConcatenation:
         *
         * Basic optimization. Adjacent strings can be concatenated.
         *
         * (?:abc)(?:def) -> abcdef
         */

        internal RegexNode ReduceConcatenation() {
            // Eliminate empties and concat adjacent strings/chars

            bool wasLastString;
            RegexOptions optionsLast;
            RegexOptions optionsAt;
            int i;
            int j;

            if (_children == null)
                return new RegexNode(RegexNode.Empty, _options);

            wasLastString = false;
            optionsLast = 0;

            for (i = 0, j = 0; i < _children.Count; i++, j++) {
                RegexNode at;
                RegexNode prev;

                at = (RegexNode)_children[i];

                if (j < i)
                    _children[j] = at;

                if (at._type == RegexNode.Concatenate &&
                    ((at._options & RegexOptions.RightToLeft) == (_options & RegexOptions.RightToLeft))) {
                    for (int k = 0; k < at._children.Count; k++)
                        ((RegexNode)at._children[k])._next = this;

                    _children.InsertRange(i + 1, at._children);
                    j--;
                }
                else if (at._type == RegexNode.Multi ||
                         at._type == RegexNode.One) {
                    // Cannot merge strings if L or I options differ
                    optionsAt = at._options & (RegexOptions.RightToLeft | RegexOptions.IgnoreCase);

                    if (!wasLastString || optionsLast != optionsAt) {
                        wasLastString = true;
                        optionsLast = optionsAt;
                        continue;
                    }

                    prev = (RegexNode)_children[--j];

                    if (prev._type == RegexNode.One) {
                        prev._type = RegexNode.Multi;
                        prev._str = Convert.ToString(prev._ch);
                    }

                    if ((optionsAt & RegexOptions.RightToLeft) == 0) {
                        if (at._type == RegexNode.One)
                            prev._str += at._ch.ToString();
                        else
                            prev._str += at._str;
                    }
                    else {
                        if (at._type == RegexNode.One)
                            prev._str = at._ch.ToString() + prev._str;
                        else
                            prev._str = at._str + prev._str;
                    }

                }
                else if (at._type == RegexNode.Empty) {
                    j--;
                }
                else {
                    wasLastString = false;
                }
            }

            if (j < i)
                _children.RemoveRange(j, i - j);

            return StripEnation(RegexNode.Empty);
        }

        internal RegexNode MakeQuantifier(bool lazy, int min, int max) {
            RegexNode result;

            if (min == 0 && max == 0)
                return new RegexNode(RegexNode.Empty, _options);

            if (min == 1 && max == 1)
                return this;

            switch (_type) {
                case RegexNode.One:
                case RegexNode.Notone:
                case RegexNode.Set:

                    MakeRep(lazy ? RegexNode.Onelazy : RegexNode.Oneloop, min, max);
                    return this;

                default:
                    result = new RegexNode(lazy ? RegexNode.Lazyloop : RegexNode.Loop, _options, min, max);
                    result.AddChild(this);
                    return result;
            }
        }

        /*  This is code for ASURT 78559
        internal void AddToCaptureList(RegexNode capture) {
            if (_str == null)
                _str = ((char) capture._m).ToString();
            else
                _str = _str + ((char) capture._m);
        }
        */
        
        internal void AddChild(RegexNode newChild) {
            RegexNode reducedChild;

            if (_children == null)
                _children = new ArrayList(4);

            reducedChild = newChild.Reduce();

            _children.Add(reducedChild);
            reducedChild._next = this;
        }
        internal RegexNode Child(int i) {
            return(RegexNode)_children[i];
        }

        internal int ChildCount() {
            return _children == null ? 0 : _children.Count;
        }

        internal int Type() {
            return _type;
        }

#if DBG
        internal static String[] TypeStr = new String[] {
            "Onerep", "Notonerep", "Setrep",
            "Oneloop", "Notoneloop", "Setloop",
            "Onelazy", "Notonelazy", "Setlazy",
            "One", "Notone", "Set",
            "Multi", "Ref",
            "Bol", "Eol", "Boundary", "Nonboundary",
#if ECMA
            "ECMABoundary", "NonECMABoundary",
#endif
            "Beginning", "Start", "EndZ", "End",
            "Nothing", "Empty",
            "Alternate", "Concatenate",
            "Loop", "Lazyloop",
            "Capture", "Group", "Require", "Prevent", "Greedy",
            "Testref", "Testgroup"};

        internal String Description() {

            StringBuilder ArgSb = new StringBuilder();

            ArgSb.Append(TypeStr[_type]);

            if ((_options & RegexOptions.ExplicitCapture) != 0)
                ArgSb.Append("-C");
            if ((_options & RegexOptions.IgnoreCase) != 0)
                ArgSb.Append("-I");
            if ((_options & RegexOptions.RightToLeft) != 0)
                ArgSb.Append("-L");
            if ((_options & RegexOptions.Multiline) != 0)
                ArgSb.Append("-M");
            if ((_options & RegexOptions.Singleline) != 0)
                ArgSb.Append("-S");
            if ((_options & RegexOptions.IgnorePatternWhitespace) != 0)
                ArgSb.Append("-X");
#if ECMA
            if ((_options & RegexOptions.ECMAScript) != 0)
                ArgSb.Append("-E");
#endif

            switch (_type) {
                case Oneloop:
                case Notoneloop:
                case Onelazy:
                case Notonelazy:
                case One:
                case Notone:
                    ArgSb.Append("(Ch = " + RegexCharClass.CharDescription(_ch) + ")");
                    break;
                case Capture:
                    ArgSb.Append("(index = " + _m.ToString() + ", unindex = " + _n.ToString() + ")");
                    break;
                case Ref:
                case Testref:
                    ArgSb.Append("(index = " + _m.ToString() + ")");
                    break;
                case Multi:
                    ArgSb.Append("(String = " + _str + ")");
                    break;
                case Set:
                case Setloop:
                case Setlazy:
                    ArgSb.Append("(Set = " + RegexCharClass.SetDescription(_str) + ")");
                    break;
            }

            switch (_type) {
                case Oneloop:
                case Notoneloop:
                case Onelazy:
                case Notonelazy:
                case Setloop:
                case Setlazy:
                case Loop:
                case Lazyloop:
                    ArgSb.Append("(Min = " + _m.ToString() + ", Max = " + (_n == infinite ? "inf" : Convert.ToString(_n)) + ")");
		    break;
            }

            return ArgSb.ToString();
        }

        internal const String Space = "                                ";

        internal void Dump() {
            ArrayList Stack = new ArrayList();
            RegexNode CurNode;
            int CurChild;

            CurNode = this;
            CurChild = 0;

            Debug.WriteLine(CurNode.Description());

            for (;;) {
                if (CurNode._children != null && CurChild < CurNode._children.Count) {
                    Stack.Add(CurChild + 1);
                    CurNode = (RegexNode)CurNode._children[CurChild];
                    CurChild = 0;

                    int Depth = Stack.Count;
                    if (Depth > 32)
                        Depth = 32;

                    Debug.WriteLine(Space.Substring(0, Depth) + CurNode.Description());
                }
                else {
                    if (Stack.Count == 0)
                        break;

                    CurChild = (Int32)Stack[Stack.Count - 1];
                    Stack.RemoveAt(Stack.Count - 1);
                    CurNode = CurNode._next;
                }
            }
        }
#endif

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexmatch.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexMatch.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Match is the result class for a regex search.
 * It returns the location, length, and substring for
 * the entire match as well as every captured group.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/28/99 (dbau)      First draft
 *
 */

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents 
    ///          the results from a single regular expression match.
    ///       </para>
    ///    </devdoc>
    [ Serializable() ] 
    public class Match : Group {
        internal static Match _empty = new Match(null, 1, String.Empty, 0, 0, 0);
        internal GroupCollection _groupcoll;
        
        // input to the match
        internal Regex               _regex;
        internal int                 _textbeg;
        internal int                 _textpos;
        internal int                 _textend;
        internal int                 _textstart;

        // output from the match
        internal int[][]             _matches;
        internal int[]               _matchcount;
        internal bool                _balancing;

        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.Empty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an empty Match object.
        ///    </para>
        /// </devdoc>
        public static Match Empty {
            get {
                return _empty;
            }
        }

        /*
         * Nonpublic constructor
         */
        internal Match(Regex regex, int capcount, String text, int begpos, int len, int startpos)

        : base(text, new int[2], 0) {

            _regex      = regex;
            _matchcount = new int[capcount];

            _matches    = new int[capcount][];
            _matches[0] = _caps;
            _textbeg    = begpos;
            _textend    = begpos + len;
            _textstart  = startpos;
            _balancing  = false;

            // No need for an exception here.  This is only called internally, so we'll use an Assert instead
            //if (_textbeg < 0 || _textstart < _textbeg || _textend < _textstart || _text.Length < _textend)
            //    throw new ArgumentOutOfRangeException();

            System.Diagnostics.Debug.Assert(!(_textbeg < 0 || _textstart < _textbeg || _textend < _textstart || _text.Length < _textend), 
                                            "The parameters are out of range.");
            
        }

        /*
         * Nonpublic set-text method
         */
        internal virtual void Reset(Regex regex, String text, int textbeg, int textend, int textstart) {
            _regex = regex;
            _text = text;
            _textbeg = textbeg;
            _textend = textend;
            _textstart = textstart;

            for (int i = 0; i < _matchcount.Length; i++) {
                _matchcount[i] = 0;
            }

            _balancing = false;
        }

        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.Groups"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual GroupCollection Groups {
            get {
                if (_groupcoll == null)
                    _groupcoll = new GroupCollection(this, null);

                return _groupcoll;
            }
        }

        /*
         * Returns the next match
         */
        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.NextMatch"]/*' />
        /// <devdoc>
        ///    <para>Returns a new Match with the results for the next match, starting
        ///       at the position at which the last match ended (at the character beyond the last
        ///       matched character).</para>
        /// </devdoc>
        public Match NextMatch() {
            if (_regex == null)
                return this;

            return _regex.Run(false, _length, _text, _textbeg, _textend - _textbeg, _textpos);
        }


        /*
         * Return the result string (using the replacement pattern)
         */
        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.Result"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the expansion of the passed replacement pattern. For
        ///       example, if the replacement pattern is ?$1$2?, Result returns the concatenation
        ///       of Group(1).ToString() and Group(2).ToString().
        ///    </para>
        /// </devdoc>
        public virtual String Result(String replacement) {
            RegexReplacement repl;

            if (replacement == null)
                throw new ArgumentNullException("replacement");

            if (_regex == null)
                throw new NotSupportedException(SR.GetString(SR.NoResultOnFailed));

            repl = (RegexReplacement)_regex.replref.Get();

            if (repl == null || !repl.Pattern.Equals(replacement)) {
                repl = RegexParser.ParseReplacement(replacement, _regex.caps, _regex.capsize, _regex.capnames, _regex.roptions);
                _regex.replref.Cache(repl);
            }

            return repl.Replacement(this);
        }

        /*
         * Used by the replacement code
         */
        internal virtual String GroupToStringImpl(int groupnum) {
            int c = _matchcount[groupnum];
            if (c == 0)
                return String.Empty;

            int [] matches = _matches[groupnum];

            return _text.Substring(matches[(c - 1) * 2], matches[(c * 2) - 1]);
        }

        /*
         * Used by the replacement code
         */
        internal String LastGroupToStringImpl() {
            return GroupToStringImpl(_matchcount.Length - 1);
        }


        /*
         * Convert to a thread-safe object by precomputing cache contents
         */
        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.Synchronized"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a Match instance equivalent to the one supplied that is safe to share
        ///       between multiple threads.
        ///    </para>
        /// </devdoc>
        static public Match Synchronized(Match inner) {
            if (inner == null)
                throw new ArgumentNullException("inner");

            int numgroups = inner._matchcount.Length;

            // Populate all groups by looking at each one
            for (int i = 0; i < numgroups; i++) {
                Group group = inner.Groups[i];

                // Depends on the fact that Group.Synchronized just
                // operates on and returns the same instance
                System.Text.RegularExpressions.Group.Synchronized(group);
            }

            return inner;
        }

        /*
         * Nonpublic builder: adds a group match by capnum
         */
        internal virtual void AddMatch(int cap, int i, int l) {
            int capcount;

            if (_matches[cap] == null)
                _matches[cap] = new int[2];

            capcount = _matchcount[cap];

            if (capcount * 2 + 2 > _matches[cap].Length) {
                int[] oldmatches = _matches[cap];
                int[] newmatches = new int[capcount * 8];
                for (int j = 0; j < capcount * 2; j++)
                    newmatches[j] = oldmatches[j];
                _matches[cap] = newmatches;
            }

            _matches[cap][capcount * 2] = i;
            _matches[cap][capcount * 2 + 1] = l;
            _matchcount[cap] = capcount + 1;
        }

        /*
         * Nonpublic builder: adds a group match by capnum
         */
        internal virtual void BalanceMatch(int cap) {
            int capcount;
            int target;

            _balancing = true;

            capcount = _matchcount[cap];

            target = capcount * 2 - 2;

            if (_matches[cap][target] < 0)
                target = -3 - _matches[cap][target];

            target -= 2;

            if (target >= 0 && _matches[cap][target] < 0)
                target = -3 - _matches[cap][target];

            AddMatch(cap, -3 - target, -4 - target);
        }

        /*
         * Nonpublic builder: removes a group match by capnum
         */
        internal virtual void RemoveMatch(int cap) {
            _matchcount[cap]--;
        }

        /*
         * Nonpublic: tells if a group was matched by capnum
         */
        internal virtual bool IsMatched(int cap) {
            return cap < _matchcount.Length && _matchcount[cap] > 0 && _matches[cap][_matchcount[cap] * 2 - 1] != (-3 + 1);
        }

        /*
         * Nonpublic: returns the index of the last specified matched group by capnum
         */
        internal virtual int MatchIndex(int cap) {
            int i = _matches[cap][_matchcount[cap] * 2 - 2];
            if (i >= 0)
                return i;

            return _matches[cap][-3 - i];
        }

        /*
         * Nonpublic: returns the length of the last specified matched group by capnum
         */
        internal virtual int MatchLength(int cap) {
            int i = _matches[cap][_matchcount[cap] * 2 - 1];
            if (i >= 0)
                return i;

            return _matches[cap][-3 - i];
        }

        /*  This is code for ASURT 78559
        internal int GroupCaptureCount(int group) {
            return _matchcount[group];
        }
        */
        

        /*
         * Nonpublic: tidy the match so that it can be used as an immutable result
         */
        internal virtual void Tidy(int textpos) {
            int[] interval;

            interval  = _matches[0];
            _index    = interval[0];
            _length   = interval[1];
            _textpos  = textpos;
            _capcount = _matchcount[0];

            if (_balancing) {
                for (int cap = 0; cap < _matchcount.Length; cap++) {
                    int limit;
                    int[] matcharray;

                    limit = _matchcount[cap] * 2;
                    matcharray = _matches[cap];

                    int i = 0;
                    int j;

                    for (i = 0; i < limit; i++) {
                        if (matcharray[i] < 0)
                            break;
                    }

                    for (j = i; i < limit; i++) {
                        if (matcharray[i] < 0) {
                            j--;
                        }
                        else {
                            if (i != j)
                                matcharray[j] = matcharray[i];
                            j++;
                        }
                    }

                    _matchcount[cap] = j / 2;
                }

                _balancing = false;
            }
        }

#if DBG
        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.Debug"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public bool Debug {
            get {
                if (_regex == null)
                    return false; // CONSIDER: what value?

                return _regex.Debug;
            }
        }

        /// <include file='doc\RegexMatch.uex' path='docs/doc[@for="Match.Dump"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public virtual void Dump() {
            int i,j;

            for (i = 0; i < _matchcount.Length; i++) {
                System.Diagnostics.Debug.WriteLine("Capnum " + i.ToString() + ":");

                for (j = 0; j < _matchcount[i]; j++) {
                    String text = "";

                    if (_matches[i][j * 2] >= 0)
                        text = _text.Substring(_matches[i][j * 2], _matches[i][j * 2 + 1]);

                    System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString() + "," + _matches[i][j * 2 + 1].ToString() + ") " + text);
                }
            }
        }
#endif
    }


    /*
     * MatchSparse is for handling the case where slots are
     * sparsely arranged (e.g., if somebody says use slot 100000)
     */
    internal class MatchSparse : Match {
        // the lookup hashtable
        new internal Hashtable _caps;

        /*
         * Nonpublic constructor
         */
        internal MatchSparse(Regex regex, Hashtable caps, int capcount,
                             String text, int begpos, int len, int startpos)

        : base(regex, capcount, text, begpos, len, startpos) {

            _caps = caps;
        }

        public override GroupCollection Groups {
            get {
                if (_groupcoll == null)
                    _groupcoll = new GroupCollection(this, _caps);

                return _groupcoll;
            }
        }

#if DBG
        public override void Dump() {
            if (_caps != null) {
                IEnumerator e = _caps.Keys.GetEnumerator();

                while (e.MoveNext()) {
                    System.Diagnostics.Debug.WriteLine("Slot " + e.Current.ToString() + " -> " + _caps[e.Current].ToString());
                }
            }

            base.Dump();
        }
#endif

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexgroupcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexGroupCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The GroupCollection lists the captured Capture numbers
 * contained in a compiled Regex.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *  6/01/99 (dbau)      First draft
 */

namespace System.Text.RegularExpressions {

    using System.Collections;

    /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a sequence of capture substrings. The object is used
    ///       to return the set of captures done by a single capturing group.
    ///    </para>
    /// </devdoc>
    [ Serializable() ] 
    public class GroupCollection : ICollection {
        internal Match _match;
        internal Hashtable _captureMap;

        // cache of Group objects fed to the user
        internal Group[]             _groups;

        /*
         * Nonpublic constructor
         */
        internal GroupCollection(Match match, Hashtable caps) {
            _match = match;
            _captureMap = caps;
        }

        /*
         * The object on which to synchronize
         */
        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Object SyncRoot {
            get {
                return _match;
            }
        }

        /*
         * ICollection
         */
        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /*
         * ICollection
         */
        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return true;
            }
        }

        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the number of groups.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return _match._matchcount.Length;
            }
        }

        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Group this[int groupnum]
        {
            get {
                return GetGroup(groupnum);
            }
        }

        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Group this[String groupname] {
            get {
                if (_match._regex == null)
                    return Group._emptygroup;

                return GetGroup(_match._regex.GroupNumberFromName(groupname));
            }
        }

        internal Group GetGroup(int groupnum) {
            if (_captureMap != null) {
                Object o;

                o = _captureMap[groupnum];
                if (o == null)
                    return Group._emptygroup;
                    //throw new ArgumentOutOfRangeException("groupnum"); 

                return GetGroupImpl((int)o);
            }
            else {
                //if (groupnum >= _match._regex.CapSize || groupnum < 0)
                //   throw new ArgumentOutOfRangeException("groupnum"); 
                if (groupnum >= _match._matchcount.Length || groupnum < 0)
                    return Group._emptygroup;

                return GetGroupImpl(groupnum);
            }
        }


        /*
         * Caches the group objects
         */
        internal Group GetGroupImpl(int groupnum) {
            if (groupnum == 0)
                return _match;

            // Construct all the Group objects the first time GetGroup is called

            if (_groups == null) {
                _groups = new Group[_match._matchcount.Length - 1];
                for (int i = 0; i < _groups.Length; i++) {
                    _groups[i] = new Group(_match._text, _match._matches[i + 1], _match._matchcount[i + 1]);
                }
            }

            return _groups[groupnum - 1];
        }

        /*
         * As required by ICollection
         */
        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies all the elements of the collection to the given array
        ///       beginning at the given index.
        ///    </para>
        /// </devdoc>
        public void CopyTo(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");

            for (int i = arrayIndex, j = 0; j < Count; i++, j++) {
                array.SetValue(this[j], i);
            }
        }

        /*
         * As required by ICollection
         */
        /// <include file='doc\RegexGroupCollection.uex' path='docs/doc[@for="GroupCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides an enumerator in the same order as Item[].
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new GroupEnumerator(this);
        }
    }


    /*
     * This non-public enumerator lists all the captures
     * Should it be public?
     */
    internal class GroupEnumerator : IEnumerator {
        internal GroupCollection _rgc;
        internal int _curindex;

        /*
         * Nonpublic constructor
         */
        internal GroupEnumerator(GroupCollection rgc) {
            _curindex = -1;
            _rgc = rgc;
        }

        /*
         * As required by IEnumerator
         */
        public bool MoveNext() {
            int size = _rgc.Count;

            if (_curindex >= size)
                return false;

            _curindex++;

            return(_curindex < size);
        }

        /*
         * As required by IEnumerator
         */
        public Object Current {
            get { return Capture;}
        }

        /*
         * Returns the current capture
         */
        public Capture Capture {
            get {
                if (_curindex < 0 || _curindex > _rgc.Count)
                    throw new InvalidOperationException(SR.GetString(SR.EnumNotStarted));

                return _rgc[_curindex];
            }
        }

        /*
         * Reset to before the first item
         */
        public void Reset() {
            _curindex = -1;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexcompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The RegexCompiler class is internal to the Regex package.
 * It translates a block of RegexCode to MSIL, and creates a
 * subclass of the RegexRunner type.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/26/99 (dbau)      First draft
 *      5/11/99 (dbau)      Got it working, cleaned it up
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Threading;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Diagnostics;
    using System.Globalization;
    
    /*
     * RegexDynamicModule
     *
     * Because dynamic modules are expensive and not thread-safe, we create
     * one dynamic module per-thread, and cache as much information about it
     * as we can.
     *
     * While we're at it, we just create one RegexCompiler per thread
     * as well, and have RegexCompiler inherit from RegexDynamicModule.
     */
    internal class RegexDynamicModule {
        internal AssemblyBuilder _assembly;
        internal ModuleBuilder  _module;

        // fields that never change (making them saves about 6% overall running time)

        internal static FieldInfo      _textbegF;
        internal static FieldInfo      _textendF;
        internal static FieldInfo      _textstartF;
        internal static FieldInfo      _textposF;
        internal static FieldInfo      _textF;
        internal static FieldInfo      _trackposF;
        internal static FieldInfo      _trackF;
        internal static FieldInfo      _stackposF;
        internal static FieldInfo      _stackF;
        internal static FieldInfo      _crawlposF;
        internal static FieldInfo      _crawlF;
        internal static FieldInfo      _matchF;
        internal static FieldInfo      _trackcountF;

        // note some methods

        internal static MethodInfo     _ensurestorageM;
        internal static MethodInfo     _captureM;
        internal static MethodInfo     _transferM;
        internal static MethodInfo     _uncaptureM;
        internal static MethodInfo     _ismatchedM;
        internal static MethodInfo     _matchlengthM;
        internal static MethodInfo     _matchindexM;
        internal static MethodInfo     _isboundaryM;
#if ECMA
        internal static MethodInfo     _isECMABoundaryM;
#endif
        internal static MethodInfo     _chartolowerM; 
        internal static MethodInfo     _getcharM; 
        internal static MethodInfo     _crawlposM; 
        internal static MethodInfo     _charInSetM;
        internal static MethodInfo     _getCurrentCulture;
        internal static MethodInfo     _getInvariantCulture;
    #if DBG
        internal static MethodInfo     _dumpstateM;
    #endif


        protected RegexDynamicModule(int moduleNum, AssemblyName an, CustomAttributeBuilder[] attribs, String resourceFile, Evidence evidence) {            // SECREVIEW : Regex only generates string manipulation, so this is
            //           : ok.
            //
            new ReflectionPermission(PermissionState.Unrestricted).Assert();
            try {
                if (an == null) {
                    an = new AssemblyName();
                    an.Name = "RegexAssembly" +  AppDomain.CurrentDomain.GetHashCode().ToString() + "_" + moduleNum.ToString();
                    _assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(an, AssemblyBuilderAccess.Run);
                }
                else {
                    _assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(an, AssemblyBuilderAccess.RunAndSave, evidence);
                }

                _module = _assembly.DefineDynamicModule(an.Name + ".dll");

                if (attribs != null) {
                    for (int i=0; i<attribs.Length; i++) {
                        _assembly.SetCustomAttribute(attribs[i]);
                    }
                }

                if (resourceFile != null)
                    _assembly.DefineUnmanagedResource(resourceFile);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
        }

        static RegexDynamicModule() {
            // SECREVIEW : Regex only generates string manipulation, so this is
            //           : ok.
            //
            new ReflectionPermission(PermissionState.Unrestricted).Assert();
            try {
                // note some fields
                _textbegF       = RegexRunnerField("runtextbeg");
                _textendF       = RegexRunnerField("runtextend");
                _textstartF     = RegexRunnerField("runtextstart");
                _textposF       = RegexRunnerField("runtextpos");
                _textF          = RegexRunnerField("runtext");
                _trackposF      = RegexRunnerField("runtrackpos");
                _trackF         = RegexRunnerField("runtrack");
                _stackposF      = RegexRunnerField("runstackpos");
                _stackF         = RegexRunnerField("runstack");
                _crawlposF      = RegexRunnerField("runcrawlpos");
                _crawlF         = RegexRunnerField("runcrawl");
                _matchF         = RegexRunnerField("runmatch");
                _trackcountF    = RegexRunnerField("runtrackcount");

                // note some methods
                _ensurestorageM = RegexRunnerMethod("EnsureStorage");
                _captureM       = RegexRunnerMethod("Capture");
                _transferM      = RegexRunnerMethod("TransferCapture");
                _uncaptureM     = RegexRunnerMethod("Uncapture");
                _ismatchedM     = RegexRunnerMethod("IsMatched");
                _matchlengthM   = RegexRunnerMethod("MatchLength");
                _matchindexM    = RegexRunnerMethod("MatchIndex");
                _isboundaryM    = RegexRunnerMethod("IsBoundary");
                _charInSetM     = RegexRunnerMethod("CharInSet");
#if ECMA
                _isECMABoundaryM= RegexRunnerMethod("IsECMABoundary");
#endif
                _crawlposM      = RegexRunnerMethod("Crawlpos");

                _chartolowerM   = typeof(Char).GetMethod("ToLower", new Type[] {typeof(Char), typeof(CultureInfo)});
                _getcharM       = typeof(String).GetMethod("get_Chars", new Type[] {typeof(int)});
                _getCurrentCulture   = typeof(CultureInfo).GetMethod("get_CurrentCulture");
                _getInvariantCulture = typeof(CultureInfo).GetMethod("get_InvariantCulture");
                

    #if DBG
                _dumpstateM     = RegexRunnerMethod("DumpState");
    #endif
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
        }

        private static FieldInfo RegexRunnerField(String fieldname) {
            return typeof(RegexRunner).GetField(fieldname, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
        }

        private static MethodInfo RegexRunnerMethod(String methname) {
            return typeof(RegexRunner).GetMethod(methname, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
        }
    }


    internal sealed class RegexCompiler : RegexDynamicModule {
        internal static Object _syncObject = new Object();
        internal static int _typeCount = 0;
        internal static int _moduleCount = 0;
        internal static LocalDataStoreSlot _moduleSlot = Thread.AllocateDataSlot();

        // state of the type builder
        internal TypeBuilder     _typebuilder;
        internal MethodBuilder   _methbuilder;
        internal ILGenerator     _ilg;

        // tokens representing local variables
        internal LocalBuilder      _textstartV;
        internal LocalBuilder      _textbegV;
        internal LocalBuilder      _textendV;
        internal LocalBuilder      _textposV;
        internal LocalBuilder      _textV;
        internal LocalBuilder      _trackposV;
        internal LocalBuilder      _trackV;
        internal LocalBuilder      _stackposV;
        internal LocalBuilder      _stackV;
        internal LocalBuilder      _tempV;
        internal LocalBuilder      _temp2V;
        internal LocalBuilder      _temp3V;


        internal RegexCode       _code;              // the RegexCode object (used for debugging only)
        internal int[]           _codes;             // the RegexCodes being translated
        internal String[]        _strings;           // the stringtable associated with the RegexCodes
        internal RegexPrefix     _fcPrefix;          // the possible first chars computed by RegexFCD
        internal RegexPrefix     _scPrefix;          // the set of eaten prefix chars
        internal RegexBoyerMoore _bmPrefix;          // a prefix as a boyer-moore machine
        internal int             _anchors;           // the set of anchors

        internal Label[]         _labels;            // a label for every operation in _codes
        internal BacktrackNote[] _notes;             // a list of the backtracking states to be generated
        internal int             _notecount;         // true count of _notes (allocation grows exponentially)
        internal int             _trackcount;        // count of backtracking states (used to reduce allocations)

        internal Label           _backtrack;         // label for backtracking


        internal int             _regexopcode;       // the current opcode being processed
        internal int             _codepos;           // the current code being translated
        internal int             _backpos;           // the current backtrack-note being translated

        internal RegexOptions    _options;           // options

        internal const int infinite = RegexNode.infinite; // an infinity

        // special code fragments
        internal int[]           _uniquenote;        // _notes indices for code that should be emitted <= once
        internal int[]           _goto;              // indices for forward-jumps-through-switch (for allocations)

        // indices for unique code fragments
        internal const int stackpop               = 0;    // pop one
        internal const int stackpop2              = 1;    // pop two
        internal const int stackpop3              = 2;    // pop three
        internal const int capback                = 3;    // uncapture
        internal const int capback2               = 4;    // uncapture 2
        internal const int branchmarkback2        = 5;    // back2 part of branchmark
        internal const int lazybranchmarkback2    = 6;    // back2 part of lazybranchmark
        internal const int branchcountback2       = 7;    // back2 part of branchcount
        internal const int lazybranchcountback2   = 8;    // back2 part of lazybranchcount
        internal const int forejumpback           = 9;    // back part of forejump
        internal const int uniquecount            = 10;


        private RegexCompiler(int moduleNum) : base(moduleNum, null, null, null, null) {
        }

        private RegexCompiler(int moduleNum, AssemblyName an, CustomAttributeBuilder[] attribs, String resourceFile, Evidence evidence) : base(moduleNum, an, attribs, resourceFile, evidence) {
        }

        /* 
         * Entry point to dynamically compile a regular expression.  The expression is compiled to 
         * an in memory assembly.
         */
        internal static RegexRunnerFactory Compile(RegexCode code, RegexOptions options) {
            RegexCompiler c;

            c = GetThreadCompiler();

            Type factory;
            RegexRunnerFactory rrf;
            // SECREVIEW : Regex only generates string manipulation, so this is
            //           : ok.
            //
            new ReflectionPermission(PermissionState.Unrestricted).Assert();
            try {
                factory = c.FactoryFromCode(code, options, "Regex");
                rrf = (RegexRunnerFactory)(Activator.CreateInstance(factory, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null));
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return rrf;
        }

        /* 
         * Compile regular expressions into an assembly on disk.
         */
        internal static void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName an, CustomAttributeBuilder[] attribs, String resourceFile, Evidence evidence) {
            RegexCompiler c = new RegexCompiler(0, an, attribs, resourceFile, evidence);

            for (int i=0; i<regexes.Length; i++) {
                String pattern = regexes[i].Pattern;
                RegexOptions options = regexes[i].Options;
                String fullname = regexes[i].Namespace + "." + regexes[i].Name;

                RegexTree tree = RegexParser.Parse(pattern, options);
                RegexCode code = RegexWriter.Write(tree);

                Type factory;

                new ReflectionPermission(PermissionState.Unrestricted).Assert();
                try {
                    factory = c.FactoryFromCode(code, options, fullname);
                    c.GenerateRegexType(pattern, options, fullname, regexes[i].IsPublic, code, tree, factory);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }

            c.Save();
        }

        /*
         * The top-level driver. Initializes everything then calls the Generate* methods.
         */
        internal Type FactoryFromCode(RegexCode code, RegexOptions options, String typeprefix) {
            String runnertypename;
            String runnerfactoryname;
            Type runnertype;
            Type factory;

            _code       = code;
            _codes      = code._codes;
            _strings    = code._strings;
            _fcPrefix   = code._fcPrefix;
            _scPrefix   = code._scPrefix;
            _bmPrefix   = code._bmPrefix;
            _anchors    = code._anchors;
            _trackcount = code._trackcount;
            _options    = options;

            // pick a name for the class

            lock (_syncObject) {

                // Note: Class names must be unique within assemblies, not just 
                // within modules.  We append the modulename to the runner name 
                // to make our name unique across the assembly

                runnertypename = typeprefix + "Runner" + _typeCount.ToString();
                runnerfactoryname = typeprefix + "Factory" + _typeCount.ToString();
                _typeCount++;
            }

            // Generate a RegexRunner class
            // (blocks are simply illustrative)

            DefineType(runnertypename, false, typeof(RegexRunner));
            {
                DefineMethod("Go", null);
                {
                    GenerateGo();
                    BakeMethod();
                }

                DefineMethod("FindFirstChar", typeof(bool));
                {
                    GenerateFindFirstChar();
                    BakeMethod();
                }

                DefineMethod("InitTrackCount", null);
                {
                    GenerateInitTrackCount();
                    BakeMethod();
                }

                runnertype = BakeType();
            }

            // Generate a RegexRunnerFactory class

            DefineType(runnerfactoryname, false, typeof(RegexRunnerFactory));
            {
                DefineMethod("CreateInstance", typeof(RegexRunner));
                {
                    GenerateCreateInstance(runnertype);
                    BakeMethod();
                }

                factory = BakeType();
            }

            return factory;
        }


        internal void GenerateRegexType(String pattern, RegexOptions opts, String name, bool ispublic, RegexCode code, RegexTree tree, Type factory) {
            FieldInfo patternF   = RegexField("pattern");
            FieldInfo optionsF   = RegexField("roptions");
            FieldInfo factoryF   = RegexField("factory");
            FieldInfo capsF      = RegexField("caps");
            FieldInfo capnamesF  = RegexField("capnames");
            FieldInfo capslistF  = RegexField("capslist");
            FieldInfo capsizeF   = RegexField("capsize");
            Type[] noTypeArray   = new Type[0];
            ConstructorBuilder cbuilder;

            DefineType(name, ispublic, typeof(Regex));
            {
                // define constructor
                _methbuilder = null;
                MethodAttributes ma = System.Reflection.MethodAttributes.Public;
                cbuilder = _typebuilder.DefineConstructor(ma, CallingConventions.Standard, noTypeArray);
                _ilg = cbuilder.GetILGenerator();
                {
                    // call base constructor
                    Ldthis();
                    _ilg.Emit(OpCodes.Call, typeof(Regex).GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, 
                                                                         null, new Type[0], new ParameterModifier[0]));
                    // set pattern
                    Ldthis();
                    Ldstr(pattern);
                    Stfld(patternF);

                    // set options
                    Ldthis();
                    Ldc((int) opts);
                    Stfld(optionsF);

                    // set factory
                    Ldthis();
                    Newobj(factory.GetConstructor(noTypeArray));
                    Stfld(factoryF);

                    // set caps
                    if (code._caps != null)
                        GenerateCreateHashtable(capsF, code._caps);

                    // set capnames
                    if (tree._capnames != null)
                        GenerateCreateHashtable(capnamesF, tree._capnames);

                    // set capslist
                    if (tree._capslist != null) {
                        Ldthis();
                        Ldc(tree._capslist.Length);
                        _ilg.Emit(OpCodes.Newarr, typeof(String));  // create new string array
                        Stfld(capslistF);

                        for (int i=0; i< tree._capslist.Length; i++) {
                            Ldthisfld(capslistF);

                            Ldc(i);
                            Ldstr(tree._capslist[i]);
                            _ilg.Emit(OpCodes.Stelem_Ref);
                        }
                    }

                    // set capsize
                    Ldthis();
                    Ldc(code._capsize);
                    Stfld(capsizeF);

                    // set runnerref and replref by calling InitializeReferences()
                    Ldthis();
                    Call(typeof(Regex).GetMethod("InitializeReferences", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));


                    Ret();
                }
            }

            // bake the constructor and type, then save the assembly
            cbuilder = null;
            _typebuilder.CreateType();
            _ilg = null;
            _typebuilder = null;
        }

        internal void GenerateCreateHashtable(FieldInfo field, Hashtable ht) {
            MethodInfo addMethod = typeof(Hashtable).GetMethod("Add", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
            
            Ldthis();
            Newobj(typeof(Hashtable).GetConstructor(new Type[0]));
            Stfld(field);

            IDictionaryEnumerator en = ht.GetEnumerator();
            while (en.MoveNext()) {
                Ldthisfld(field);
        
                if (en.Key is int) {
                    Ldc((int) en.Key);  
                    _ilg.Emit(OpCodes.Box, typeof(Int32));
                }
                else 
                    Ldstr((String) en.Key);

                Ldc((int) en.Value);    
                _ilg.Emit(OpCodes.Box, typeof(Int32));
                Callvirt(addMethod);
            }
        }

        private FieldInfo RegexField(String fieldname) {
            return typeof(Regex).GetField(fieldname, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
        }

        internal void Save() {
            _assembly.Save(_assembly.GetName().Name + ".dll");
        }

        /*
         * Keeps track of an operation that needs to be referenced in the backtrack-jump
         * switch table, and that needs backtracking code to be emitted (if flags != 0)
         */
        internal sealed class BacktrackNote {
            internal BacktrackNote(int flags, Label label, int codepos) {
                _codepos = codepos;
                _flags = flags;
                _label = label;
            }

            internal int _codepos;
            internal int _flags;
            internal Label _label;
        }

        /*
         * Adds a backtrack note to the list of them, and returns the index of the new
         * note (which is also the index for the jump used by the switch table)
         */
        internal int AddBacktrackNote(int flags, Label l, int codepos) {
            if (_notes == null || _notecount >= _notes.Length) {
                BacktrackNote[] newnotes = new BacktrackNote[_notes == null ? 16 : _notes.Length * 2];
                if (_notes != null)
                    System.Array.Copy(_notes, 0, newnotes, 0, _notecount);
                _notes = newnotes;
            }

            _notes[_notecount] = new BacktrackNote(flags, l, codepos);

            return _notecount++;
        }

        /*
         * Adds a backtrack note for the current operation; creates a new label for
         * where the code will be, and returns the switch index.
         */
        internal int AddTrack() {
            return AddTrack(RegexCode.Back);
        }

        /*
         * Adds a backtrack note for the current operation; creates a new label for
         * where the code will be, and returns the switch index.
         */
        internal int AddTrack(int flags) {
            return AddBacktrackNote(flags, DefineLabel(), _codepos);
        }

        /*
         * Adds a switchtable entry for the specified position (for the forward
         * logic; does not cause backtracking logic to be generated)
         */
        internal int AddGoto(int destpos) {
            if (_goto[destpos] == -1)
                _goto[destpos] = AddBacktrackNote(0, _labels[destpos], destpos);

            return _goto[destpos];
        }

        /*
         * Adds a note for backtracking code that only needs to be generated once;
         * if it's already marked to be generated, returns the switch index
         * for the unique piece of code.
         */
        internal int AddUniqueTrack(int i) {
            return AddUniqueTrack(i, RegexCode.Back);
        }

        /*
         * Adds a note for backtracking code that only needs to be generated once;
         * if it's already marked to be generated, returns the switch index
         * for the unique piece of code.
         */
        internal int AddUniqueTrack(int i, int flags) {
            if (_uniquenote[i] == -1)
                _uniquenote[i] = AddTrack(flags);

            return _uniquenote[i];
        }

        /*
         * A macro for _ilg.DefineLabel
         */
        internal Label DefineLabel() {
            return _ilg.DefineLabel();
        }

        /*
         * A macro for _ilg.MarkLabel
         */
        internal void MarkLabel(Label l) {
            _ilg.MarkLabel(l);
        }

        /*
         * Returns the ith operand of the current operation
         */
        internal int Operand(int i) {
            return _codes[_codepos + i + 1];
        }

        /*
         * True if the current operation is marked for the leftward direction
         */
        internal bool IsRtl() {
            return(_regexopcode & RegexCode.Rtl) != 0;
        }

        /*
         * True if the current operation is marked for the leftward direction
         */
        internal bool IsCi() {
            return(_regexopcode & RegexCode.Ci) != 0;
        }

#if DBG
        /*
         * True if we need to do the backtrack logic for the current operation
         */
        internal bool IsBack() {
            return(_regexopcode & RegexCode.Back) != 0;
        }

        /*
         * True if we need to do the second-backtrack logic for the current operation
         */
        internal bool IsBack2() {
            return(_regexopcode & RegexCode.Back2) != 0;
        }
#endif

        /*
         * Returns the raw regex opcode (masking out Back and Rtl)
         */
        internal int Code() {
            return _regexopcode & RegexCode.Mask;
        }

        internal void Ldstr(string str) {
            _ilg.Emit(OpCodes.Ldstr, str);
        }

        /*
         * A macro for the various forms of Ldc
         */
        internal void Ldc(int i) {
            //REVIEW: can we enable the commented code for a small(tiny) 
            //perf gain?
            //jruiz - Ldc_I4_0 is no 
            //longer a short, it is a value class.
            //Note: There is a bug in the commented
            //code, when i == -1 the OpCode is undefined.
            //if (i <= 8 && i >= -1)
            //    _ilg.Emit((short)(OpCodes.Ldc_I4_0 + i));
            if (i <= 127 && i >= -128)
                _ilg.Emit(OpCodes.Ldc_I4_S, (byte)i);
            else
                _ilg.Emit(OpCodes.Ldc_I4, i);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Dup)
         */
        internal void Dup() {
            _ilg.Emit(OpCodes.Dup);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Ret)
         */
        internal void Ret() {
            _ilg.Emit(OpCodes.Ret);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Pop)
         */
        internal void Pop() {
            _ilg.Emit(OpCodes.Pop);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Add)
         */
        internal void Add() {
            _ilg.Emit(OpCodes.Add);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Add); a true flag can turn it into a Sub
         */
        internal void Add(bool negate) {
            if (negate)
                _ilg.Emit(OpCodes.Sub);
            else
                _ilg.Emit(OpCodes.Add);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Sub)
         */
        internal void Sub() {
            _ilg.Emit(OpCodes.Sub);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Sub); a true flag can turn it into a Add
         */
        internal void Sub(bool negate) {
            if (negate)
                _ilg.Emit(OpCodes.Add);
            else
                _ilg.Emit(OpCodes.Sub);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Ldloc);
         */
        internal void Ldloc(LocalBuilder lt) {
            _ilg.Emit(OpCodes.Ldloc_S, lt);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Stloc);
         */
        internal void Stloc(LocalBuilder lt) {
            _ilg.Emit(OpCodes.Stloc_S, lt);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Ldarg_0);
         */
        internal void Ldthis() {
            _ilg.Emit(OpCodes.Ldarg_0);
        }

        /*
         * A macro for Ldthis(); Ldfld();
         */
        internal void Ldthisfld(FieldInfo ft) {
            Ldthis();
            _ilg.Emit(OpCodes.Ldfld, ft);
        }

        /*
         * A macro for Ldthis(); Ldfld(); Stloc();
         */
        internal void Mvfldloc(FieldInfo ft, LocalBuilder lt) {
            Ldthisfld(ft);
            Stloc(lt);
        }

        /*
         * A macro for Ldthis(); Ldthisfld(); Stloc();
         */
        internal void Mvlocfld(LocalBuilder lt, FieldInfo ft) {
            Ldthis();
            Ldloc(lt);
            Stfld(ft);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Stfld);
         */
        internal void Stfld(FieldInfo ft) {
            _ilg.Emit(OpCodes.Stfld, ft);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Callvirt);
         */
        internal void Callvirt(MethodInfo mt) {
            _ilg.Emit(OpCodes.Callvirt, mt);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Call);
         */
        internal void Call(MethodInfo mt) {
            _ilg.Emit(OpCodes.Call, mt);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Newobj);
         */
        internal void Newobj(ConstructorInfo ct) {
            _ilg.Emit(OpCodes.Newobj, ct);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Brfalse) (long form)
         */
        internal void BrfalseFar(Label l) {
            _ilg.Emit(OpCodes.Brfalse, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Brtrue) (long form)
         */
        internal void BrtrueFar(Label l) {
            _ilg.Emit(OpCodes.Brtrue, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Br) (long form)
         */
        internal void BrFar(Label l) {
            _ilg.Emit(OpCodes.Br, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Ble) (long form)
         */
        internal void BleFar(Label l) {
            _ilg.Emit(OpCodes.Ble, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Blt) (long form)
         */
        internal void BltFar(Label l) {
            _ilg.Emit(OpCodes.Blt, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bge) (long form)
         */
        internal void BgeFar(Label l) {
            _ilg.Emit(OpCodes.Bge, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bgt) (long form)
         */
        internal void BgtFar(Label l) {
            _ilg.Emit(OpCodes.Bgt, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bne) (long form)
         */
        internal void BneFar(Label l) {
            _ilg.Emit(OpCodes.Bne_Un, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Beq) (long form)
         */
        internal void BeqFar(Label l) {
            _ilg.Emit(OpCodes.Beq, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Brfalse_S) (short jump)
         */
        internal void Brfalse(Label l) {
            _ilg.Emit(OpCodes.Brfalse_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Br_S) (short jump)
         */
        internal void Br(Label l) {
            _ilg.Emit(OpCodes.Br_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Ble_S) (short jump)
         */
        internal void Ble(Label l) {
            _ilg.Emit(OpCodes.Ble_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Blt_S) (short jump)
         */
        internal void Blt(Label l) {
            _ilg.Emit(OpCodes.Blt_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bge_S) (short jump)
         */
        internal void Bge(Label l) {
            _ilg.Emit(OpCodes.Bge_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bgt_S) (short jump)
         */
        internal void Bgt(Label l) {
            _ilg.Emit(OpCodes.Bgt_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bleun_S) (short jump)
         */
        internal void Bgtun(Label l) {
            _ilg.Emit(OpCodes.Bgt_Un_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Bne_S) (short jump)
         */
        internal void Bne(Label l) {
            _ilg.Emit(OpCodes.Bne_Un_S, l);
        }

        /*
         * A macro for _ilg.Emit(OpCodes.Beq_S) (short jump)
         */
        internal void Beq(Label l) {
            _ilg.Emit(OpCodes.Beq_S, l);
        }

        /*
         * A macro for the Ldlen instruction
         */
        internal void Ldlen() {
            _ilg.Emit(OpCodes.Ldlen);
        }

        /*
         * Loads the char to the right of the current position
         */
        internal void Rightchar() {
            Ldloc(_textV);
            Ldloc(_textposV);
            Callvirt(_getcharM);
        }

        /*
         * Loads the char to the right of the current position and advances the current position
         */
        internal void Rightcharnext() {
            Ldloc(_textV);
            Ldloc(_textposV);
            Dup();
            Ldc(1);
            Add();
            Stloc(_textposV);
            Callvirt(_getcharM);
        }

        /*
         * Loads the char to the left of the current position
         */
        internal void Leftchar() {
            Ldloc(_textV);
            Ldloc(_textposV);
            Ldc(1);
            Sub();
            Callvirt(_getcharM);
        }

        /*
         * Loads the char to the left of the current position and advances (leftward)
         */
        internal void Leftcharnext() {
            Ldloc(_textV);
            Ldloc(_textposV);
            Ldc(1);
            Sub();
            Dup();
            Stloc(_textposV);
            Callvirt(_getcharM);
        }

        /*
         * Creates a backtrack note and pushes the switch index it on the tracking stack
         */
        internal void Track() {
            ReadyPushTrack();
            Ldc(AddTrack());
            DoPush();
        }

        /*
         * Pushes the current switch index on the tracking stack so the backtracking
         * logic will be repeated again next time we backtrack here.
         *
         * CONSIDER: perhaps we can just "unpop" the tracking stack because _backpos
         * should aways be there already?
         */
        internal void Trackagain() {
            ReadyPushTrack();
            Ldc(_backpos);
            DoPush();
        }

        /*
         * Saves the value of a local variable on the tracking stack
         */
        internal void PushTrack(LocalBuilder lt) {
            ReadyPushTrack();
            Ldloc(lt);
            DoPush();
        }

        /*
         * Creates a backtrack note for a piece of code that should only be generated once,
         * and emits code that pushes the switch index on the backtracking stack.
         */
        internal void TrackUnique(int i) {
            ReadyPushTrack();
            Ldc(AddUniqueTrack(i));
            DoPush();
        }

        /*
         * Creates a second-backtrack note for a piece of code that should only be
         * generated once, and emits code that pushes the switch index on the
         * backtracking stack.
         */
        internal void TrackUnique2(int i) {
            ReadyPushTrack();
            Ldc(AddUniqueTrack(i, RegexCode.Back2));
            DoPush();
        }

        /*
         * Prologue to code that will push an element on the tracking stack
         */
        internal void ReadyPushTrack() {
            _ilg.Emit(OpCodes.Ldloc_S, _trackV);
            _ilg.Emit(OpCodes.Ldloc_S, _trackposV);
            _ilg.Emit(OpCodes.Ldc_I4_1);
            _ilg.Emit(OpCodes.Sub);
            _ilg.Emit(OpCodes.Dup);
            _ilg.Emit(OpCodes.Stloc_S, _trackposV);
        }

        /*
         * Pops an element off the tracking stack (leave it on the operand stack)
         */
        internal void PopTrack() {
            _ilg.Emit(OpCodes.Ldloc_S, _trackV);
            _ilg.Emit(OpCodes.Ldloc_S, _trackposV);
            _ilg.Emit(OpCodes.Dup);
            _ilg.Emit(OpCodes.Ldc_I4_1);
            _ilg.Emit(OpCodes.Add);
            _ilg.Emit(OpCodes.Stloc_S, _trackposV);
            _ilg.Emit(OpCodes.Ldelem_I4);
        }

        /*
         * Retrieves the top entry on the tracking stack without popping
         */
        internal void TopTrack() {
            _ilg.Emit(OpCodes.Ldloc_S, _trackV);
            _ilg.Emit(OpCodes.Ldloc_S, _trackposV);
            _ilg.Emit(OpCodes.Ldelem_I4);
        }

        /*
         * Saves the value of a local variable on the grouping stack
         */
        internal void PushStack(LocalBuilder lt) {
            ReadyPushStack();
            _ilg.Emit(OpCodes.Ldloc_S, lt);
            DoPush();
        }

        /*
         * Prologue to code that will replace the ith element on the grouping stack
         */
        internal void ReadyReplaceStack(int i) {
            _ilg.Emit(OpCodes.Ldloc_S, _stackV);
            _ilg.Emit(OpCodes.Ldloc_S, _stackposV);
            if (i != 0) {
                Ldc(i);
                _ilg.Emit(OpCodes.Add);
            }
        }

        /*
         * Prologue to code that will push an element on the grouping stack
         */
        internal void ReadyPushStack() {
            _ilg.Emit(OpCodes.Ldloc_S, _stackV);
            _ilg.Emit(OpCodes.Ldloc_S, _stackposV);
            _ilg.Emit(OpCodes.Ldc_I4_1);
            _ilg.Emit(OpCodes.Sub);
            _ilg.Emit(OpCodes.Dup);
            _ilg.Emit(OpCodes.Stloc_S, _stackposV);
        }

        /*
         * Retrieves the top entry on the stack without popping
         */
        internal void TopStack() {
            _ilg.Emit(OpCodes.Ldloc_S, _stackV);
            _ilg.Emit(OpCodes.Ldloc_S, _stackposV);
            _ilg.Emit(OpCodes.Ldelem_I4);
        }

        /*
         * Pops an element off the grouping stack (leave it on the operand stack)
         */
        internal void PopStack() {
            _ilg.Emit(OpCodes.Ldloc_S, _stackV);
            _ilg.Emit(OpCodes.Ldloc_S, _stackposV);
            _ilg.Emit(OpCodes.Dup);
            _ilg.Emit(OpCodes.Ldc_I4_1);
            _ilg.Emit(OpCodes.Add);
            _ilg.Emit(OpCodes.Stloc_S, _stackposV);
            _ilg.Emit(OpCodes.Ldelem_I4);
        }

        /*
         * Pops 1 element off the grouping stack and discards it
         */
        internal void PopDiscardStack() {
            PopDiscardStack(1);
        }

        /*
         * Pops i elements off the grouping stack and discards them
         */
        internal void PopDiscardStack(int i) {
            _ilg.Emit(OpCodes.Ldloc_S, _stackposV);
            Ldc(i);
            _ilg.Emit(OpCodes.Add);
            _ilg.Emit(OpCodes.Stloc_S, _stackposV);
        }

        /*
         * Epilogue to code that will replace an element on a stack (use Ld* in between)
         */
        internal void DoReplace() {
            _ilg.Emit(OpCodes.Stelem_I4);
        }

        /*
         * Epilogue to code that will push an element on a stack (use Ld* in between)
         */
        internal void DoPush() {
            _ilg.Emit(OpCodes.Stelem_I4);
        }

        /*
         * Jump to the backtracking switch
         */
        internal void Back() {
            _ilg.Emit(OpCodes.Br, _backtrack);
        }

        /*
         * Branch to the MSIL corresponding to the regex code at i
         *
         * A trick: since track and stack space is gobbled up unboundedly
         * only as a result of branching backwards, this is where we check
         * for sufficient space and trigger reallocations.
         *
         * If the "goto" is backwards, we generate code that checks
         * available space against the amount of space that would be needed
         * in the worst case by code that will only go forward; if there's
         * not enough, we push the destination on the tracking stack, then
         * we jump to the place where we invoke the allocator.
         *
         * Since forward gotos pose no threat, they just turn into a Br.
         */
        internal void Goto(int i) {
            if (i < _codepos) {
                Label l1 = DefineLabel();

                // When going backwards, ensure enough space.
                Ldloc(_trackposV);
                Ldc(_trackcount * 4);
                Ble(l1);
                Ldloc(_stackposV);
                Ldc(_trackcount * 3);
                BgtFar(_labels[i]);
                MarkLabel(l1); 
                ReadyPushTrack();
                Ldc(AddGoto(i));
                DoPush();
                BrFar(_backtrack);
            }
            else {
                BrFar(_labels[i]);
            }
        }

        /*
         * Returns the position of the next operation in the regex code, taking
         * into account the different numbers of arguments taken by operations
         */
        internal int NextCodepos() {
            return _codepos + RegexCode.OpcodeSize(_codes[_codepos]);
        }

        /*
         * The label for the next (forward) operation
         */
        internal Label AdvanceLabel() {
            return _labels[NextCodepos()];
        }

        /*
         * Goto the next (forward) operation
         */
        internal void Advance() {
            _ilg.Emit(OpCodes.Br, AdvanceLabel());
        }

        internal void CallToLower()
        {
            if ((_options & RegexOptions.CultureInvariant) != 0)
                Call(_getInvariantCulture);
            else
                Call(_getCurrentCulture);
            
            Call(_chartolowerM);
        }

        /*
         * Generates the first section of the MSIL. This section contains all
         * the forward logic, and corresponds directly to the regex codes.
         *
         * In the absence of backtracking, this is all we would need.
         */
        internal void GenerateForwardSection() {
            int codepos;

            _labels = new Label[_codes.Length];
            _goto   = new int[_codes.Length];

            // initialize

            for (codepos = 0; codepos < _codes.Length; codepos += RegexCode.OpcodeSize(_codes[codepos])) {
                _goto[codepos]   = -1;
                _labels[codepos] = _ilg.DefineLabel();
            }

            _uniquenote   = new int[uniquecount];
            for (int i = 0; i < uniquecount; i++)
                _uniquenote[i] = -1;

            // emit variable initializers

            Mvfldloc(_textF,      _textV);
            Mvfldloc(_textstartF, _textstartV);
            Mvfldloc(_textbegF,   _textbegV);
            Mvfldloc(_textendF,   _textendV);
            Mvfldloc(_textposF,   _textposV);
            Mvfldloc(_trackF,     _trackV);
            Mvfldloc(_trackposF,  _trackposV);
            Mvfldloc(_stackF,     _stackV);
            Mvfldloc(_stackposF,  _stackposV);

            _backpos = -1;

            for (codepos = 0; codepos < _codes.Length; codepos += RegexCode.OpcodeSize(_codes[codepos])) {
                MarkLabel(_labels[codepos]);
                _codepos = codepos;
                _regexopcode = _codes[codepos];
                GenerateOneCode();
            }
        }

        /*
         * Generates the middle section of the MSIL. This section contains the
         * big switch jump that allows us to simulate a stack of addresses,
         * and it also contains the calls that expand the tracking and the
         * grouping stack when they get too full.
         */
        internal void GenerateMiddleSection() {
            Label l1 = DefineLabel();
            Label[] table;
            int i;

            // Backtrack switch
            MarkLabel(_backtrack);

            // first call EnsureStorage 
            Mvlocfld(_trackposV, _trackposF);
            Mvlocfld(_stackposV, _stackposF);
            Ldthis();
            Callvirt(_ensurestorageM);
            Mvfldloc(_trackposF, _trackposV);
            Mvfldloc(_stackposF, _stackposV);
            Mvfldloc(_trackF, _trackV);
            Mvfldloc(_stackF, _stackV);


            PopTrack();

            table = new Label[_notecount];
            for (i = 0; i < _notecount; i++)
                table[i] = _notes[i]._label;

            _ilg.Emit(OpCodes.Switch, table);

        }

        /*
         * Generates the last section of the MSIL. This section contains all of
         * the backtracking logic.
         */
        internal void GenerateBacktrackSection() {
            int i;

            for (i = 0; i < _notecount; i++) {
                BacktrackNote n = _notes[i];
                if (n._flags != 0) {
                    _ilg.MarkLabel(n._label);
                    _codepos = n._codepos;
                    _backpos = i;
                    _regexopcode = _codes[n._codepos] | n._flags;
                    GenerateOneCode();
                }
            }
        }

        /*
         * Generates FindFirstChar
         */
        internal void GenerateFindFirstChar() {
            _textposV       = DeclareInt();
            _textV          = DeclareString();
            _tempV          = DeclareInt();
            _temp2V         = DeclareInt();

            if (0 != (_anchors & (RegexFCD.Beginning | RegexFCD.Start | RegexFCD.EndZ | RegexFCD.End))) {
                if (!_code._rightToLeft) {
                    if (0 != (_anchors & RegexFCD.Beginning)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textbegF);
                        Ble(l1);
                        Ldthis();
                        Ldthisfld(_textendF);
                        Stfld(_textposF);
                        Ldc(0);
                        Ret();
                        MarkLabel(l1);
                    }

                    if (0 != (_anchors & RegexFCD.Start)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textstartF);
                        Ble(l1);
                        Ldthis();
                        Ldthisfld(_textendF);
                        Stfld(_textposF);
                        Ldc(0);
                        Ret();
                        MarkLabel(l1);
                    }

                    if (0 != (_anchors & RegexFCD.EndZ)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textendF);
                        Ldc(1);
                        Sub();
                        Bge(l1);
                        Ldthis();
                        Ldthisfld(_textendF);
                        Ldc(1);
                        Sub();
                        Stfld(_textposF);
                        MarkLabel(l1);
                    }

                    if (0 != (_anchors & RegexFCD.End)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textendF);
                        Bge(l1);
                        Ldthis();
                        Ldthisfld(_textendF);
                        Stfld(_textposF);
                        MarkLabel(l1);
                    }
                }
                else {
                    if (0 != (_anchors & RegexFCD.End)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textendF);
                        Bge(l1);
                        Ldthis();
                        Ldthisfld(_textbegF);
                        Stfld(_textposF);
                        Ldc(0);
                        Ret();
                        MarkLabel(l1);
                    }

                    if (0 != (_anchors & RegexFCD.EndZ)) {
                        Label l1 = DefineLabel();
                        Label l2 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textendF);
                        Ldc(1);
                        Sub();
                        Blt(l1);
                        Ldthisfld(_textposF);
                        Ldthisfld(_textendF);
                        Beq(l2);
                        Ldthisfld(_textF);
                        Ldthisfld(_textposF);
                        Callvirt(_getcharM);
                        Ldc((int)'\n');
                        Beq(l2);
                        MarkLabel(l1);
                        Ldthis();
                        Ldthisfld(_textbegF);
                        Stfld(_textposF);
                        Ldc(0);
                        Ret();
                        MarkLabel(l2);
                    }

                    if (0 != (_anchors & RegexFCD.Start)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textstartF);
                        Bge(l1);
                        Ldthis();
                        Ldthisfld(_textbegF);
                        Stfld(_textposF);
                        Ldc(0);
                        Ret();
                        MarkLabel(l1);
                    }

                    if (0 != (_anchors & RegexFCD.Beginning)) {
                        Label l1 = DefineLabel();
                        Ldthisfld(_textposF);
                        Ldthisfld(_textbegF);
                        Ble(l1);
                        Ldthis();
                        Ldthisfld(_textbegF);
                        Stfld(_textposF);
                        MarkLabel(l1);
                    }
                }

                // CONSIDER: even in anchored case, we should check for the
                // prefix, but we currently do not.

                Ldc(1);
                Ret();
            }
            else if (_bmPrefix != null && _bmPrefix._negativeUnicode == null) {
                // Compiled Boyer-Moore string matching
                // CONSIDER: not done yet - must add Unicode support
                // CONSIDER: right-to-left support not tested yet

                LocalBuilder chV      = _tempV;
                LocalBuilder testV    = _tempV;
                LocalBuilder limitV   = _temp2V;
                Label      lDefaultAdvance  = DefineLabel();
                Label      lAdvance         = DefineLabel();
                Label      lFail            = DefineLabel();
                Label      lStart           = DefineLabel();
                Label      lOutOfRange      = DefineLabel();
                Label      lPartialMatch    = DefineLabel();


                int chLast;
                int i;
                int beforefirst;
                int last;
                Label[] table;

                if (!_code._rightToLeft) {
                    beforefirst = -1;
                    last = _bmPrefix._pattern.Length - 1;
                }
                else {
                    beforefirst = _bmPrefix._pattern.Length;
                    last = 0;
                }

                // HACKHACK: SMC treats chars as signed (dbau)
                chLast = _bmPrefix._pattern[last];
                if (chLast < 0)
                    chLast += 0x10000;

                Mvfldloc(_textF, _textV);
                if (!_code._rightToLeft)
                    Ldthisfld(_textendF);
                else
                    Ldthisfld(_textbegF);
                Stloc(limitV);

                Ldthisfld(_textposF);
                if (!_code._rightToLeft) {
                    Ldc(_bmPrefix._pattern.Length - 1);
                    Add();
                }
                else {
                    Ldc(_bmPrefix._pattern.Length);
                    Sub();
                }
                Stloc(_textposV);
                Br(lStart);

                MarkLabel(lDefaultAdvance);

                if (!_code._rightToLeft)
                    Ldc(_bmPrefix._pattern.Length);
                else
                    Ldc(-_bmPrefix._pattern.Length);

                MarkLabel(lAdvance);

                Ldloc(_textposV);
                Add();
                Stloc(_textposV);

                MarkLabel(lStart);

                Ldloc(_textposV);
                Ldloc(limitV);
                if (!_code._rightToLeft)
                    BgeFar(lFail);
                else
                    BltFar(lFail);

                Rightchar();
                if (_bmPrefix._caseInsensitive)
                    CallToLower();

                Dup();
                Stloc(chV);
                Ldc(chLast);
                BeqFar(lPartialMatch);

                Ldloc(chV);
                Ldc(_bmPrefix._lowASCII);
                Sub();
                Dup();
                Stloc(chV);
                Ldc(_bmPrefix._highASCII - _bmPrefix._lowASCII);
                Bgtun(lDefaultAdvance);

                table = new Label[_bmPrefix._highASCII - _bmPrefix._lowASCII + 1];

                for (i = _bmPrefix._lowASCII; i <= _bmPrefix._highASCII; i++) {
                    if (_bmPrefix._negativeASCII[i] == beforefirst)
                        table[i - _bmPrefix._lowASCII] = lDefaultAdvance;
                    else
                        table[i - _bmPrefix._lowASCII] = DefineLabel();
                }

                Ldloc(chV);
                _ilg.Emit(OpCodes.Switch, table);

                for (i = _bmPrefix._lowASCII; i <= _bmPrefix._highASCII; i++) {
                    if (_bmPrefix._negativeASCII[i] == beforefirst)
                        continue;

                    MarkLabel(table[i - _bmPrefix._lowASCII]);

                    Ldc(_bmPrefix._negativeASCII[i]);
                    BrFar(lAdvance);
                }

                MarkLabel(lPartialMatch);

                Ldloc(_textposV);
                Stloc(testV);

                for (i = _bmPrefix._pattern.Length - 2; i >= 0; i--) {
                    Label lNext = DefineLabel();
                    int charindex;

                    if (!_code._rightToLeft)
                        charindex = i;
                    else
                        charindex = _bmPrefix._pattern.Length - 1 - i;

                    Ldloc(_textV);
                    Ldloc(testV);
                    Ldc(1);
                    Sub(_code._rightToLeft);
                    Dup();
                    Stloc(testV);
                    Callvirt(_getcharM);
                    if (_bmPrefix._caseInsensitive)
                        CallToLower();
                    
                    Ldc(_bmPrefix._pattern[charindex]);
                    Beq(lNext);
                    Ldc(_bmPrefix._positive[charindex]);
                    BrFar(lAdvance);

                    MarkLabel(lNext);

                }

                Ldthis();
                Ldloc(testV);
                if (_code._rightToLeft) {
                    Ldc(1);
                    Add();
                }
                Stfld(_textposF);
                Ldc(1);
                Ret();

                MarkLabel(lFail);

                Ldthis();
                if (!_code._rightToLeft)
                    Ldthisfld(_textendF);
                else
                    Ldthisfld(_textbegF);
                Stfld(_textposF);
                Ldc(0);
                Ret();
            }
            else if (_fcPrefix == null) {
                Ldc(1);
                Ret();
            }
            else {
                LocalBuilder cV   = _temp2V;
                LocalBuilder chV  = _tempV;
                Label      l1   = DefineLabel();
                Label      l2   = DefineLabel();
                Label      l3   = DefineLabel();
                Label      l4   = DefineLabel();
                Label      l5   = DefineLabel();

                Mvfldloc(_textposF, _textposV);
                Mvfldloc(_textF, _textV);

                if (!_code._rightToLeft) {
                    Ldthisfld(_textendF);
                    Ldloc(_textposV);
                }
                else {
                    Ldloc(_textposV);
                    Ldthisfld(_textbegF);
                }
                Sub();
                Stloc(cV);

                Ldloc(cV);
                Ldc(0);
                BleFar(l4);

                MarkLabel(l1);

                Ldloc(cV);
                Ldc(1);
                Sub();
                Stloc(cV);

                if (_code._rightToLeft)
                    Leftcharnext();
                else
                    Rightcharnext();

                if (_fcPrefix.CaseInsensitive)
                    CallToLower();
                
                if (!RegexCharClass.IsSingleton(_fcPrefix.Prefix)) {
                    Ldstr(_fcPrefix.Prefix);
                    Ldstr(String.Empty);
                    Call(_charInSetM);

                    BrtrueFar(l2);
                }
                else {
                    Ldc(RegexCharClass.SingletonChar(_fcPrefix.Prefix));
                    Beq(l2);
                }

                MarkLabel(l5);

                Ldloc(cV);
                Ldc(0);
                if (!RegexCharClass.IsSingleton(_fcPrefix.Prefix))
                    BgtFar(l1);
                else
                    Bgt(l1);

                Ldc(0);
                BrFar(l3);

                MarkLabel(l2);

                /*          // CURRENTLY DISABLED
                            // If for some reason we have a prefix we didn't use, use it now.
                
                            if (_bmPrefix != null) {
                                if (!_code._rightToLeft) {
                                    Ldthisfld(_textendF);
                                    Ldloc(_textposV);
                                }
                                else {
                                    Ldloc(_textposV);
                                    Ldthisfld(_textbegF);
                                }
                                Sub();
                                Ldc(_bmPrefix._pattern.Length - 1);
                                BltFar(l5);
                                
                                for (int i = 1; i < _bmPrefix._pattern.Length; i++) {
                                    Ldloc(_textV);
                                    Ldloc(_textposV);
                                    if (!_code._rightToLeft) {
                                        Ldc(i - 1);
                                        Add();
                                    }
                                    else {
                                        Ldc(i);
                                        Sub();
                                    }
                                    Callvirt(_getcharM);
                                    if (!_code._rightToLeft)
                                        Ldc(_bmPrefix._pattern[i]);
                                    else
                                        Ldc(_bmPrefix._pattern[_bmPrefix._pattern.Length - 1 - i]);
                                    BneFar(l5);
                                }
                            }
                */

                Ldloc(_textposV);
                Ldc(1);
                Sub(_code._rightToLeft);
                Stloc(_textposV);
                Ldc(1);

                MarkLabel(l3);

                Mvlocfld(_textposV, _textposF);
                Ret();

                MarkLabel(l4);
                Ldc(0);
                Ret();
            }

        }

        /*
         * Generates a very simple method that sets the _trackcount field.
         */
        internal void GenerateInitTrackCount() {
            Ldthis();
            Ldc(_trackcount);
            Stfld(_trackcountF);
            Ret();
        }

        /*
         * Generates a very simple factory method.
         */
        internal void GenerateCreateInstance(Type newtype) {
            Newobj(newtype.GetConstructor(new Type[0]));
            Ret();
        }

        /*
         * Gets the unique-for-regex dynamic module for this thread
         */
        internal static RegexCompiler GetThreadCompiler() {
            RegexCompiler compiler = (RegexCompiler)Thread.GetData(_moduleSlot);

            if (compiler == null) {
                int moduleNum;

                lock (_syncObject) {
                    moduleNum = _moduleCount++;
                }

                compiler = new RegexCompiler(moduleNum);
                Thread.SetData(_moduleSlot, compiler);
            }

            return compiler;
        }

        /*
         * Begins the definition of a new type with a specified base class
         */
        internal void DefineType(String typename, bool ispublic, Type inheritfromclass) {
            if (ispublic)
                _typebuilder = _module.DefineType(typename, TypeAttributes.Class | TypeAttributes.Public, inheritfromclass);
            else
                _typebuilder = _module.DefineType(typename, TypeAttributes.Class | TypeAttributes.NotPublic, inheritfromclass);

        }

        /*
         * Begins the definition of a new method (no args) with a specified return value
         */
        internal void DefineMethod(String methname, Type returntype) {
            MethodAttributes ma = System.Reflection.MethodAttributes.Public | System.Reflection.MethodAttributes.Virtual;

            _methbuilder = _typebuilder.DefineMethod(methname, ma, returntype, null);
            _ilg = _methbuilder.GetILGenerator();
        }

        /*
         * Ends the definition of a method
         */
        internal void BakeMethod() {
            _methbuilder = null;
        }

        /*
         * Ends the definition of a class and returns the type
         */
        internal Type BakeType() {
            Type retval = _typebuilder.CreateType();
            _typebuilder = null;

            return retval;
        }

        /*
         * Declares a local int
         */
        internal LocalBuilder DeclareInt() {
            return _ilg.DeclareLocal(typeof(int));            
        }

        /*
         * Declares a local int array
         */
        internal LocalBuilder DeclareIntArray() {
            return _ilg.DeclareLocal(typeof(int[]));
        }

        /*
         * Declares a local char array
         */
        internal LocalBuilder DeclareCharArray() {
            return _ilg.DeclareLocal(typeof(char[]));
        }

        /*
         * Declares a local string
         */
        internal LocalBuilder DeclareString() {
            return _ilg.DeclareLocal(typeof(string));
        }
        
        /*
         * Generates the code for "RegexRunner.Go"
         */
        internal void GenerateGo() {
            // declare some locals

            _textposV       = DeclareInt();
            _textV          = DeclareString();
            _trackposV      = DeclareInt();
            _trackV         = DeclareIntArray();
            _stackposV      = DeclareInt();
            _stackV         = DeclareIntArray();
            _tempV          = DeclareInt();
            _temp2V         = DeclareInt();
            _temp3V         = DeclareInt();
            _textbegV       = DeclareInt();
            _textendV       = DeclareInt();
            _textstartV     = DeclareInt();

            // clear some tables

            _labels = null;
            _notes = null;
            _notecount = 0;

            // globally used labels

            _backtrack = DefineLabel();

            // emit the code!

            GenerateForwardSection();
            GenerateMiddleSection();
            GenerateBacktrackSection();
        }

#if DBG
        /*
         * Some simple debugging stuff
         */
        internal static char[] Hex = new char[] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
        internal static MethodInfo _debugWriteLine = typeof(Debug).GetMethod("WriteLine", new Type[] {typeof(string)});

        internal static String BaDescription(byte[] ba) {
            StringBuilder sb = new StringBuilder();

            sb.Append("Length " + ba.Length.ToString() + "\n");

            for (int i = 0; i < ba.Length; i++) {
                sb.Append(Hex[ba[i] >> 4]);
                sb.Append(Hex[ba[i] & 0xF]);
                sb.Append(' ');
            }
            return sb.ToString();
        }

        /*
         * Debug only: emit code to print out a message
         */
        internal void Message(String str) {
            Ldstr(str);
            Call(_debugWriteLine);
        }

#endif

        /*
         * The main translation function. It translates the logic for a single opcode at
         * the current position. The structure of this function exactly mirrors
         * the structure of the inner loop of RegexInterpreter.Go().
         *
         * The C# code from RegexInterpreter.Go() that corresponds to each case is
         * included as a comment.
         *
         * Note that since we're generating code, we can collapse many cases that are
         * dealt with one-at-a-time in RegexIntepreter. We can also unroll loops that
         * iterate over constant strings or sets.
         */
        internal void GenerateOneCode() {
#if DBG
            if ((_options & RegexOptions.Debug) != 0) {
                Mvlocfld(_textposV, _textposF);
                Mvlocfld(_trackposV, _trackposF);
                Mvlocfld(_stackposV, _stackposF);
                Ldthis();
                Callvirt(_dumpstateM);
                StringBuilder sb = new StringBuilder();
                if (_backpos > 0)
                    sb.AppendFormat("{0:D6} ", _backpos);
                else
                    sb.Append("       ");
                sb.Append(_code.OpcodeDescription(_codepos));
                if (IsBack())
                    sb.Append(" Back");
                if (IsBack2())
                    sb.Append(" Back2");
                Message(sb.ToString());
            }
#endif

            switch (_regexopcode) {
                case RegexCode.Stop:
                    //: return;
                    Mvlocfld(_textposV, _textposF);       // update _textpos
                    Ret();
                    break;

                case RegexCode.Nothing:
                    //: break Backward;
                    Back();
                    break;

                case RegexCode.Goto:
                    //: Goto(Operand(0));
                    Goto(Operand(0));
                    break;

                case RegexCode.Testref:
                    //: if (!_match.IsMatched(Operand(0)))
                    //:     break Backward;
                    Ldthis();
                    Ldc(Operand(0));
                    Callvirt(_ismatchedM);
                    BrfalseFar(_backtrack);
                    break;

                case RegexCode.Lazybranch:
                    //: Track(Textpos());
                    PushTrack(_textposV);
                    Track();
                    break;

                case RegexCode.Lazybranch | RegexCode.Back:
                    //: Trackframe(1);
                    //: Textto(Tracked(0));
                    //: Goto(Operand(0));
                    PopTrack();
                    Stloc(_textposV);
                    Goto(Operand(0));
                    break;

                case RegexCode.Nullmark:
                    //: Stack(-1);
                    //: Track();
                    ReadyPushStack();
                    Ldc(-1);
                    DoPush();
                    TrackUnique(stackpop);
                    break;

                case RegexCode.Setmark:
                    //: Stack(Textpos());
                    //: Track();
                    PushStack(_textposV);
                    TrackUnique(stackpop);
                    break;

                case RegexCode.Nullmark | RegexCode.Back:
                case RegexCode.Setmark | RegexCode.Back:
                    //: Stackframe(1);
                    //: break Backward;
                    PopDiscardStack();
                    Back();
                    break;

                case RegexCode.Getmark:
                    //: Stackframe(1);
                    //: Track(Stacked(0));
                    //: Textto(Stacked(0));
                    ReadyPushTrack();
                    PopStack();
                    Dup();
                    Stloc(_textposV);
                    DoPush();

                    Track();
                    break;

                case RegexCode.Getmark | RegexCode.Back:
                    //: Trackframe(1);
                    //: Stack(Tracked(0));
                    //: break Backward;
                    ReadyPushStack();
                    PopTrack();
                    DoPush();
                    Back();
                    break;

                case RegexCode.Capturemark:
                    //: if (!IsMatched(Operand(1)))
                    //:     break Backward;
                    //: Stackframe(1);
                    //: if (Operand(1) != -1)
                    //:     TransferCapture(Operand(0), Operand(1), Stacked(0), Textpos());
                    //: else
                    //:     Capture(Operand(0), Stacked(0), Textpos());
                    //: Track(Stacked(0));

                    //: Stackframe(1);
                    //: Capture(Operand(0), Stacked(0), Textpos());
                    //: Track(Stacked(0));

                    if (Operand(1) != -1) {
                        Ldthis();
                        Ldc(Operand(1));
                        Callvirt(_ismatchedM);
                        BrfalseFar(_backtrack);
                    }

                    PopStack();
                    Stloc(_tempV);

                    if (Operand(1) != -1) {
                        Ldthis();
                        Ldc(Operand(0));
                        Ldc(Operand(1));
                        Ldloc(_tempV);
                        Ldloc(_textposV);
                        Callvirt(_transferM);
                    }
                    else {
                        Ldthis();
                        Ldc(Operand(0));
                        Ldloc(_tempV);
                        Ldloc(_textposV);
                        Callvirt(_captureM);
                    }

                    PushTrack(_tempV);

                    if (Operand(0) != -1 && Operand(1) != -1)
                        TrackUnique(capback2);
                    else
                        TrackUnique(capback);

                    break;


                case RegexCode.Capturemark | RegexCode.Back:
                    //: Trackframe(1);
                    //: Stack(Tracked(0));
                    //: Uncapture();
                    //: if (Operand(0) != -1 && Operand(1) != -1)
                    //:     Uncapture();
                    //: break Backward;
                    ReadyPushStack();
                    PopTrack();
                    DoPush();
                    Ldthis();
                    Callvirt(_uncaptureM);
                    if (Operand(0) != -1 && Operand(1) != -1) {
                        Ldthis();
                        Callvirt(_uncaptureM);
                    }
                    Back();
                    break;

                case RegexCode.Branchmark:
                    //: Stackframe(1);
                    //: 
                    //: if (Textpos() != Stacked(0))
                    //: {                                   // Nonempty match -> loop now
                    //:     Track(Stacked(0), Textpos());   // Save old mark, textpos
                    //:     Stack(Textpos());               // Make new mark
                    //:     Goto(Operand(0));               // Loop
                    //: }
                    //: else
                    //: {                                   // Empty match -> straight now
                    //:     Track2(Stacked(0));             // Save old mark
                    //:     Advance(1);                     // Straight
                    //: }
                    //: continue Forward;
                    {
                        LocalBuilder mark = _tempV;
                        Label      l1   = DefineLabel();

                        PopStack();
                        Dup();
                        Stloc(mark);                            // Stacked(0) -> temp
                        PushTrack(mark);
                        Ldloc(_textposV);
                        Beq(l1);                                // mark == textpos -> branch

                        // (matched != 0)

                        PushTrack(_textposV);
                        PushStack(_textposV);
                        Track();
                        Goto(Operand(0));                       // Goto(Operand(0))

                        // else

                        MarkLabel(l1);
                        TrackUnique2(branchmarkback2);
                        break;
                    }

                case RegexCode.Branchmark | RegexCode.Back:
                    //: Trackframe(2);
                    //: Stackframe(1);
                    //: Textto(Tracked(1));                     // Recall position
                    //: Track2(Tracked(0));                     // Save old mark
                    //: Advance(1);
                    PopTrack();
                    Stloc(_textposV);
                    PopStack();
                    Pop();
                    // track spot 0 is already in place
                    TrackUnique2(branchmarkback2);
                    Advance();
                    break;

                case RegexCode.Branchmark | RegexCode.Back2:
                    //: Trackframe(1);
                    //: Stack(Tracked(0));                      // Recall old mark
                    //: break Backward;                         // Backtrack
                    ReadyPushStack();
                    PopTrack();
                    DoPush();
                    Back();
                    break;


                case RegexCode.Lazybranchmark:
                    //: Stackframe(1);
                    //: 
                    //: if (Textpos() != Stacked(0))
                    //: {                                   // Nonempty match -> next loop
                    //:     Track(Stacked(0), Textpos());   // Save old mark, textpos
                    //: }
                    //: else
                    //: {                                   // Empty match -> no loop
                    //:     Track2(Stacked(0));             // Save old mark
                    //: }
                    //: Advance(1);
                    //: continue Forward;
                    {
                        LocalBuilder mark = _tempV;
                        Label      l1   = DefineLabel();

                        PopStack();
                        Dup();
                        Stloc(mark);                            // Stacked(0) -> temp
                        PushTrack(mark);
                        Ldloc(_textposV);
                        Beq(l1);                                // mark == textpos -> branch

                        // (matched != 0)

                        PushTrack(_textposV);
                        Track();
                        Br(AdvanceLabel());                     // Advance (near)

                        // else

                        MarkLabel(l1);
                        TrackUnique2(lazybranchmarkback2);
                        break;
                    }

                case RegexCode.Lazybranchmark | RegexCode.Back:
                    //: Trackframe(2);
                    //: Track2(Tracked(0));                     // Save old mark
                    //: Stack(Textpos());                       // Make new mark
                    //: Textto(Tracked(1));                     // Recall position
                    //: Goto(Operand(0));                       // Loop

                    PopTrack();
                    Stloc(_textposV);
                    PushStack(_textposV);
                    TrackUnique2(lazybranchmarkback2);
                    Goto(Operand(0));
                    break;

                case RegexCode.Lazybranchmark | RegexCode.Back2:
                    //: Stackframe(1);
                    //: Trackframe(1);
                    //: Stack(Tracked(0));                  // Recall old mark
                    //: break Backward;
                    ReadyReplaceStack(0);
                    PopTrack();
                    DoReplace();
                    Back();
                    break;

                case RegexCode.Nullcount:
                    //: Stack(-1, Operand(0));
                    //: Track();
                    ReadyPushStack();
                    Ldc(-1);
                    DoPush();
                    ReadyPushStack();
                    Ldc(Operand(0));
                    DoPush();
                    TrackUnique(stackpop2);
                    break;

                case RegexCode.Setcount:
                    //: Stack(Textpos(), Operand(0));
                    //: Track();
                    PushStack(_textposV);
                    ReadyPushStack();
                    Ldc(Operand(0));
                    DoPush();
                    TrackUnique(stackpop2);
                    break;


                case RegexCode.Nullcount | RegexCode.Back:
                case RegexCode.Setcount | RegexCode.Back:
                    //: Stackframe(2);
                    //: break Backward;
                    PopDiscardStack(2);
                    Back();
                    break;


                case RegexCode.Branchcount:
                    //: Stackframe(2);
                    //: int mark = Stacked(0);
                    //: int count = Stacked(1);
                    //: 
                    //: if (count >= Operand(1) || Textpos() == mark && count >= 0)
                    //: {                                   // Max loops or empty match -> straight now
                    //:     Track2(mark, count);            // Save old mark, count
                    //:     Advance(2);                     // Straight
                    //: }
                    //: else
                    //: {                                   // Nonempty match -> count+loop now
                    //:     Track(mark);                    // remember mark
                    //:     Stack(Textpos(), count + 1);    // Make new mark, incr count
                    //:     Goto(Operand(0));               // Loop
                    //: }
                    //: continue Forward;
                    {
                        LocalBuilder count = _tempV;
                        LocalBuilder mark  = _temp2V;
                        Label      l1    = DefineLabel();
                        Label      l2    = DefineLabel();

                        PopStack();
                        Stloc(count);                           // count -> temp
                        PopStack();
                        Dup();
                        Stloc(mark);                            // mark -> temp2
                        PushTrack(mark);

                        Ldloc(_textposV);
                        Bne(l1);                                // mark != textpos -> l1
                        Ldloc(count);
                        Ldc(0);
                        Bge(l2);                                // count >= 0 && mark == textpos -> l2

                        MarkLabel(l1);
                        Ldloc(count);
                        Ldc(Operand(1));
                        Bge(l2);                                // count >= Operand(1) -> l2

                        // else
                        PushStack(_textposV);
                        ReadyPushStack();
                        Ldloc(count);                           // mark already on track
                        Ldc(1);
                        Add();
                        DoPush();
                        Track();
                        Goto(Operand(0));

                        // if (count >= Operand(1) || Textpos() == mark)
                        MarkLabel(l2);
                        PushTrack(count);                       // mark already on track
                        TrackUnique2(branchcountback2);
                        break;
                    }

                case RegexCode.Branchcount | RegexCode.Back:
                    //: Trackframe(1);
                    //: Stackframe(2);
                    //: if (Stacked(1) > 0)                     // Positive -> can go straight
                    //: {
                    //:     Textto(Stacked(0));                 // Zap to mark
                    //:     Track2(Tracked(0), Stacked(1) - 1); // Save old mark, old count
                    //:     Advance(2);                         // Straight
                    //:     continue Forward;
                    //: }
                    //: Stack(Tracked(0), Stacked(1) - 1);      // recall old mark, old count
                    //: break Backward;
                    {

                        LocalBuilder count = _tempV;
                        Label      l1    = DefineLabel();
                        PopStack();
                        Ldc(1);
                        Sub();
                        Dup();
                        Stloc(count);
                        Ldc(0);
                        Blt(l1);

                        // if (count >= 0)
                        PopStack();
                        Stloc(_textposV);
                        PushTrack(count);                       // Tracked(0) is alredy on the track
                        TrackUnique2(branchcountback2);
                        Advance();

                        // else
                        MarkLabel(l1);
                        ReadyReplaceStack(0);
                        PopTrack();
                        DoReplace();
                        PushStack(count);
                        Back();
                        break;
                    }

                case RegexCode.Branchcount | RegexCode.Back2:
                    //: Trackframe(2);
                    //: Stack(Tracked(0), Tracked(1));      // Recall old mark, old count
                    //: break Backward;                     // Backtrack

                    PopTrack();
                    Stloc(_tempV);
                    ReadyPushStack();
                    PopTrack();
                    DoPush();
                    PushStack(_tempV);
                    Back();
                    break;

                case RegexCode.Lazybranchcount:
                    //: Stackframe(2);
                    //: int mark = Stacked(0);
                    //: int count = Stacked(1);
                    //:
                    //: if (count < 0)
                    //: {                                   // Negative count -> loop now
                    //:     Track2(mark);                   // Save old mark
                    //:     Stack(Textpos(), count + 1);    // Make new mark, incr count
                    //:     Goto(Operand(0));               // Loop
                    //: }
                    //: else
                    //: {                                   // Nonneg count or empty match -> straight now
                    //:     Track(mark, count, Textpos());  // Save mark, count, position
                    //: }
                    {
                        LocalBuilder count = _tempV;
                        LocalBuilder mark  = _temp2V;
                        Label      l1    = DefineLabel();
                        Label      l2    = DefineLabel();
                        Label      l3    = _labels[NextCodepos()];

                        PopStack();
                        Stloc(count);                           // count -> temp
                        PopStack();
                        Stloc(mark);                            // mark -> temp2

                        Ldloc(count);
                        Ldc(0);
                        Bge(l1);                                // count >= 0 -> l1

                        // if (count < 0)
                        PushTrack(mark);
                        PushStack(_textposV);
                        ReadyPushStack();
                        Ldloc(count);
                        Ldc(1);
                        Add();
                        DoPush();
                        TrackUnique2(lazybranchcountback2);
                        Goto(Operand(0));

                        // else
                        MarkLabel(l1);
                        PushTrack(mark);
                        PushTrack(count);
                        PushTrack(_textposV);
                        Track();
                        break;
                    }

                case RegexCode.Lazybranchcount | RegexCode.Back:
                    //: Trackframe(3);
                    //: int mark = Tracked(0);
                    //: int textpos = Tracked(2);
                    //: if (Tracked(1) <= Operand(1) && textpos != mark)
                    //: {
                    //:     Textto(Tracked(2));                 // Recall position
                    //:     Stack(Textpos(), Tracked(1) + 1);   // Make new mark, incr count
                    //:     Track2(Tracked(0));                 // Save old mark
                    //:     Goto(Operand(0));                   // Loop
                    //:     continue Forward;
                    //: }
                    //: else
                    //: {
                    //:     Stack(Tracked(0), Tracked(1));      // Recall old mark, count
                    //:     break Backward;                     // backtrack
                    //: }
                    {
                        Label       l1 = DefineLabel();
                        LocalBuilder  cV = _tempV;
                        PopTrack();
                        Stloc(_textposV);
                        PopTrack();
                        Dup();
                        Stloc(cV);
                        Ldc(Operand(1));
                        Bgt(l1);                                // Tracked(1) > Operand(1) -> l1

                        Ldloc(_textposV);
                        TopTrack();
                        Beq(l1);                                // textpos == mark -> l1

                        PushStack(_textposV);
                        ReadyPushStack();
                        Ldloc(cV);
                        Ldc(1);
                        Add();
                        DoPush();
                        TrackUnique2(lazybranchcountback2);
                        Goto(Operand(0));

                        MarkLabel(l1);
                        ReadyPushStack();
                        PopTrack();
                        DoPush();
                        PushStack(cV);
                        Back();
                        break;
                    }

                case RegexCode.Lazybranchcount | RegexCode.Back2:
                    // CONSIDER: update to match interpreter lazybranchcount
                    //: Trackframe(1);
                    //: Stackframe(2);
                    //: Stack(Tracked(0), Stacked(1) - 1);  // Recall old mark, count
                    //: break Backward;                     // Backtrack

                    ReadyReplaceStack(1);
                    PopTrack();
                    DoReplace();
                    ReadyReplaceStack(0);
                    TopStack();
                    Ldc(1);
                    Sub();
                    DoReplace();
                    Back();
                    break;


                case RegexCode.Setjump:
                    //: Stack(Trackpos(), Crawlpos());
                    //: Track();
                    ReadyPushStack();
                    Ldthisfld(_trackF);
                    Ldlen();
                    Ldloc(_trackposV);
                    Sub();
                    DoPush();
                    ReadyPushStack();
                    Ldthis();
                    Callvirt(_crawlposM);
                    DoPush();
                    TrackUnique(stackpop2);
                    break;

                case RegexCode.Setjump | RegexCode.Back:
                    //: Stackframe(2);
                    PopDiscardStack(2);
                    Back();
                    break;


                case RegexCode.Backjump:
                    //: Stackframe(2);
                    //: Trackto(Stacked(0));
                    //: while (Crawlpos() != Stacked(1))
                    //:     Uncapture();
                    //: break Backward;
                    {
                        Label      l1    = DefineLabel();
                        Label      l2    = DefineLabel();

                        PopStack();
                        Ldthisfld(_trackF);
                        Ldlen();
                        PopStack();
                        Sub();
                        Stloc(_trackposV);
                        Dup();
                        Ldthis();
                        Callvirt(_crawlposM);
                        Beq(l2);

                        MarkLabel(l1);
                        Ldthis();
                        Callvirt(_uncaptureM);
                        Dup();
                        Ldthis();
                        Callvirt(_crawlposM);
                        Bne(l1);

                        MarkLabel(l2);
                        Pop();
                        Back();
                        break;
                    }

                case RegexCode.Forejump:
                    //: Stackframe(2);
                    //: Trackto(Stacked(0));
                    //: Track(Stacked(1));
                    PopStack();
                    Stloc(_tempV);
                    Ldthisfld(_trackF);
                    Ldlen();
                    PopStack();
                    Sub();
                    Stloc(_trackposV);
                    PushTrack(_tempV);
                    TrackUnique(forejumpback);
                    break;

                case RegexCode.Forejump | RegexCode.Back:
                    //: Trackframe(1);
                    //: while (Crawlpos() != Tracked(0))
                    //:     Uncapture();
                    //: break Backward;
                    {
                        Label      l1    = DefineLabel();
                        Label      l2    = DefineLabel();

                        PopTrack();

                        Dup();
                        Ldthis();
                        Callvirt(_crawlposM);
                        Beq(l2);

                        MarkLabel(l1);
                        Ldthis();
                        Callvirt(_uncaptureM);
                        Dup();
                        Ldthis();
                        Callvirt(_crawlposM);
                        Bne(l1);

                        MarkLabel(l2);
                        Pop();
                        Back();
                        break;
                    }

                case RegexCode.Bol:
                    //: if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')
                    //:     break Backward;
                    {
                        Label      l1    = _labels[NextCodepos()];
                        Ldloc(_textposV);
                        Ldloc(_textbegV);
                        Ble(l1);
                        Leftchar();
                        Ldc((int)'\n');
                        BneFar(_backtrack);
                        break;
                    }

                case RegexCode.Eol:
                    //: if (Rightchars() > 0 && CharAt(Textpos()) != '\n')
                    //:     break Backward;
                    {
                        Label      l1    = _labels[NextCodepos()];
                        Ldloc(_textposV);
                        Ldloc(_textendV);
                        Bge(l1);
                        Rightchar();
                        Ldc((int)'\n');
                        BneFar(_backtrack);
                        break;
                    }

                case RegexCode.Boundary:
                case RegexCode.Nonboundary:
                    //: if (!IsBoundary(Textpos(), _textbeg, _textend))
                    //:     break Backward;
                    Ldthis();
                    Ldloc(_textposV);
                    Ldloc(_textbegV);
                    Ldloc(_textendV);
                    Callvirt(_isboundaryM);
                    if (Code() == RegexCode.Boundary)
                        BrfalseFar(_backtrack);
                    else
                        BrtrueFar(_backtrack);
                    break;

#if ECMA
                case RegexCode.ECMABoundary:
                case RegexCode.NonECMABoundary:
                    //: if (!IsECMABoundary(Textpos(), _textbeg, _textend))
                    //:     break Backward;
                    Ldthis();
                    Ldloc(_textposV);
                    Ldloc(_textbegV);
                    Ldloc(_textendV);
                    Callvirt(_isECMABoundaryM);
                    if (Code() == RegexCode.ECMABoundary)
                        BrfalseFar(_backtrack);
                    else
                        BrtrueFar(_backtrack);
                    break;
#endif

                case RegexCode.Beginning:
                    //: if (Leftchars() > 0)
                    //:    break Backward;
                    Ldloc(_textposV);
                    Ldloc(_textbegV);
                    BgtFar(_backtrack);
                    break;

                case RegexCode.Start:
                    //: if (Textpos() != Textstart())
                    //:    break Backward;
                    Ldloc(_textposV);
                    Ldthisfld(_textstartF);
                    BneFar(_backtrack);
                    break;

                case RegexCode.EndZ:
                    //: if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')
                    //:    break Backward;
                    Ldloc(_textposV);
                    Ldloc(_textendV);
                    Ldc(1);
                    Sub();
                    BltFar(_backtrack);
                    Ldloc(_textposV);
                    Ldloc(_textendV);
                    Bge(_labels[NextCodepos()]);
                    Rightchar();
                    Ldc((int)'\n');
                    BneFar(_backtrack);
                    break;

                case RegexCode.End:
                    //: if (Rightchars() > 0)
                    //:    break Backward;
                    Ldloc(_textposV);
                    Ldloc(_textendV);
                    BltFar(_backtrack);
                    break;

                case RegexCode.One:
                case RegexCode.Notone:
                case RegexCode.Set:
                case RegexCode.One      | RegexCode.Rtl:
                case RegexCode.Notone   | RegexCode.Rtl:
                case RegexCode.Set      | RegexCode.Rtl:
                case RegexCode.One      | RegexCode.Ci:
                case RegexCode.Notone   | RegexCode.Ci:
                case RegexCode.Set      | RegexCode.Ci:
                case RegexCode.One      | RegexCode.Ci  | RegexCode.Rtl:
                case RegexCode.Notone   | RegexCode.Ci  | RegexCode.Rtl:
                case RegexCode.Set      | RegexCode.Ci  | RegexCode.Rtl:

                    //: if (Rightchars() < 1 || Rightcharnext() != (char)Operand(0))
                    //:    break Backward;
                    Ldloc(_textposV);

                    if (!IsRtl()) {
                        Ldloc(_textendV);
                        BgeFar(_backtrack);
                        Rightcharnext();
                    }
                    else {
                        Ldloc(_textbegV);
                        BleFar(_backtrack);
                        Leftcharnext();
                    }

                    if (IsCi())
                        CallToLower();

                    if (Code() == RegexCode.Set) {

                        Ldstr(_strings[Operand(0)]);
                        Ldstr(_strings[Operand(1)]);
                        Call(_charInSetM);

                        BrfalseFar(_backtrack);
                    }
                    else {
                        Ldc(Operand(0));
                        if (Code() == RegexCode.One)
                            BneFar(_backtrack);
                        else
                            BeqFar(_backtrack);
                    }
                    break;

                case RegexCode.Multi:
                case RegexCode.Multi | RegexCode.Ci:
                    //
                    // CONSIDER: there is a nice optimization opportunity here. Instead of testing
                    // a constant string starting from the first character, we should first
                    // test characters that are unique in the string, starting from the character
                    // that we deem to be the "rarest" (i.e., test the letter q before testing
                    // the letter e).
                    //

                    //: String Str = _strings[Operand(0)];
                    //: int i, c;
                    //: if (Rightchars() < (c = Str.Length))
                    //:     break Backward;
                    //: for (i = 0; c > 0; i++, c--)
                    //:     if (Str[i] != Rightcharnext())
                    //:         break Backward;
                    {
                        int i;
                        String str;

                        str = _strings[Operand(0)];

                        Ldc(str.Length);
                        Ldloc(_textendV);
                        Ldloc(_textposV);
                        Sub();
                        BgtFar(_backtrack);

                        // unroll the string
                        for (i = 0; i < str.Length; i++) {
                            Ldloc(_textV);
                            Ldloc(_textposV);
                            if (i != 0) {
                                Ldc(i);
                                Add();
                            }
                            Callvirt(_getcharM);
                            if (IsCi())
                                CallToLower();
                            
                            Ldc((int)str[i]);
                            BneFar(_backtrack);
                        }

                        Ldloc(_textposV);
                        Ldc(str.Length);
                        Add();
                        Stloc(_textposV);
                        break;
                    }


                case RegexCode.Multi | RegexCode.Rtl:
                case RegexCode.Multi | RegexCode.Ci  | RegexCode.Rtl:
                    //: String Str = _strings[Operand(0)];
                    //: int c;
                    //: if (Leftchars() < (c = Str.Length))
                    //:     break Backward;
                    //: while (c > 0)
                    //:     if (Str[--c] != Leftcharnext())
                    //:         break Backward;
                    {
                        int i;
                        String str;

                        str = _strings[Operand(0)];

                        Ldc(str.Length);
                        Ldloc(_textposV);
                        Ldloc(_textbegV);
                        Sub();
                        BgtFar(_backtrack);

                        // unroll the string
                        for (i = str.Length; i > 0;) {
                            i--;
                            Ldloc(_textV);
                            Ldloc(_textposV);
                            Ldc(str.Length - i);
                            Sub();
                            Callvirt(_getcharM);
                            if (IsCi()) 
                            {
                                CallToLower();
                            }
                            Ldc((int)str[i]);
                            BneFar(_backtrack);
                        }

                        Ldloc(_textposV);
                        Ldc(str.Length);
                        Sub();
                        Stloc(_textposV);

                        break;
                    }

                case RegexCode.Ref:
                case RegexCode.Ref | RegexCode.Rtl:
                case RegexCode.Ref | RegexCode.Ci:
                case RegexCode.Ref | RegexCode.Ci | RegexCode.Rtl:
                    //: int capnum = Operand(0);
                    //: int j, c;
                    //: if (!_match.IsMatched(capnum)) {
                    //: #if ECMA
                    //:     if (!RegexOptions.ECMAScript)
                    //: #endif
                    //:         break Backward;
                    //: } else {
                    //:     if (Rightchars() < (c = _match.MatchLength(capnum)))
                    //:         break Backward;
                    //:     for (j = _match.MatchIndex(capnum); c > 0; j++, c--)
                    //:         if (CharAt(j) != Rightcharnext())
                    //:             break Backward;
                    //: }
                    {
                        LocalBuilder lenV     = _tempV;
                        LocalBuilder indexV   = _temp2V;
                        Label      l1       = DefineLabel();

                        Ldthis();
                        Ldc(Operand(0));
                        Callvirt(_ismatchedM);
#if ECMA
                        if ((_options & RegexOptions.ECMAScript) != 0)
                            Brfalse(AdvanceLabel());
                        else
#endif
                            BrfalseFar(_backtrack); // !IsMatched() -> back

                        Ldthis();
                        Ldc(Operand(0));
                        Callvirt(_matchlengthM);
                        Dup();
                        Stloc(lenV);
                        if (!IsRtl()) {
                            Ldloc(_textendV);
                            Ldloc(_textposV);
                        }
                        else {
                            Ldloc(_textposV);
                            Ldloc(_textbegV);
                        }
                        Sub();
                        BgtFar(_backtrack);         // Matchlength() > Rightchars() -> back

                        Ldthis();
                        Ldc(Operand(0));
                        Callvirt(_matchindexM);
                        if (!IsRtl()) {
                            Ldloc(lenV);
                            Add(IsRtl());
                        }
                        Stloc(indexV);              // index += len

                        Ldloc(_textposV);
                        Ldloc(lenV);
                        Add(IsRtl());
                        Stloc(_textposV);           // texpos += len

                        MarkLabel(l1);
                        Ldloc(lenV);
                        Ldc(0);
                        Ble(AdvanceLabel());
                        Ldloc(_textV);
                        Ldloc(indexV);
                        Ldloc(lenV);
                        if (IsRtl()) {
                            Ldc(1);
                            Sub();
                            Dup();
                            Stloc(lenV);
                        }
                        Sub(IsRtl());
                        Callvirt(_getcharM);
                        if (IsCi())
                            CallToLower();
                        
                        Ldloc(_textV);
                        Ldloc(_textposV);
                        Ldloc(lenV);
                        if (!IsRtl()) {
                            Dup();
                            Ldc(1);
                            Sub();
                            Stloc(lenV);
                        }
                        Sub(IsRtl());
                        Callvirt(_getcharM);
                        if (IsCi())
                            CallToLower();
                        
                        Beq(l1);
                        Back();
                        break;
                    }


                case RegexCode.Onerep:
                case RegexCode.Notonerep:
                case RegexCode.Setrep:
                case RegexCode.Onerep | RegexCode.Rtl:
                case RegexCode.Notonerep | RegexCode.Rtl:
                case RegexCode.Setrep | RegexCode.Rtl:
                case RegexCode.Onerep | RegexCode.Ci:
                case RegexCode.Notonerep | RegexCode.Ci:
                case RegexCode.Setrep | RegexCode.Ci:
                case RegexCode.Onerep | RegexCode.Ci | RegexCode.Rtl:
                case RegexCode.Notonerep | RegexCode.Ci | RegexCode.Rtl:
                case RegexCode.Setrep | RegexCode.Ci | RegexCode.Rtl:
                    //: int c = Operand(1);
                    //: if (Rightchars() < c)
                    //:     break Backward;
                    //: char ch = (char)Operand(0);
                    //: while (c-- > 0)
                    //:     if (Rightcharnext() != ch)
                    //:         break Backward;
                    {
                        LocalBuilder lenV = _tempV;
                        Label      l1   = DefineLabel();

                        int c = (Code() == RegexCode.Setrep) ? Operand(2): Operand(1);

                        if (c == 0)
                            break;

                        Ldc(c);
                        if (!IsRtl()) {
                            Ldloc(_textendV);
                            Ldloc(_textposV);
                        }
                        else {
                            Ldloc(_textposV);
                            Ldloc(_textbegV);
                        }
                        Sub();
                        BgtFar(_backtrack);         // Matchlength() > Rightchars() -> back

                        Ldloc(_textposV);
                        Ldc(c);
                        Add(IsRtl());
                        Stloc(_textposV);           // texpos += len

                        Ldc(c);
                        Stloc(lenV);

                        MarkLabel(l1);
                        Ldloc(_textV);
                        Ldloc(_textposV);
                        Ldloc(lenV);
                        if (IsRtl()) {
                            Ldc(1);
                            Sub();
                            Dup();
                            Stloc(lenV);
                            Add();
                        }
                        else {
                            Dup();
                            Ldc(1);
                            Sub();
                            Stloc(lenV);
                            Sub();
                        }
                        Callvirt(_getcharM);
                        if (IsCi())
                            CallToLower();
                        
                        if (Code() == RegexCode.Setrep) {
                            Ldstr(_strings[Operand(0)]);
                            Ldstr(_strings[Operand(1)]);
                            Call(_charInSetM);

                            BrfalseFar(_backtrack);
                        }
                        else {
                            Ldc(Operand(0));
                            if (Code() == RegexCode.Onerep)
                                BneFar(_backtrack);
                            else
                                BeqFar(_backtrack);
                        }
                        Ldloc(lenV);
                        Ldc(0);
                        if (Code() == RegexCode.Setrep)
                            BgtFar(l1);
                        else
                            Bgt(l1);
                        break;
                    }


                case RegexCode.Oneloop:
                case RegexCode.Notoneloop:
                case RegexCode.Setloop:
                case RegexCode.Oneloop | RegexCode.Rtl:
                case RegexCode.Notoneloop | RegexCode.Rtl:
                case RegexCode.Setloop | RegexCode.Rtl:
                case RegexCode.Oneloop | RegexCode.Ci:
                case RegexCode.Notoneloop | RegexCode.Ci:
                case RegexCode.Setloop | RegexCode.Ci:
                case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl:
                case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl:
                case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl:
                    //: int c = Operand(1);
                    //: if (c > Rightchars())
                    //:     c = Rightchars();
                    //: char ch = (char)Operand(0);
                    //: int i;
                    //: for (i = c; i > 0; i--)
                    //: {
                    //:     if (Rightcharnext() != ch)
                    //:     {
                    //:         Leftnext();
                    //:         break;
                    //:     }
                    //: }
                    //: if (c > i)
                    //:     Track(c - i - 1, Textpos() - 1);

                    {
                        LocalBuilder cV   = _tempV;
                        LocalBuilder lenV = _temp2V;
                        Label      l1   = DefineLabel();
                        Label      l2   = DefineLabel();

                        int c = (Code() == RegexCode.Setloop) ? Operand(2): Operand(1);

                        if (c == 0)
                            break;
                        if (!IsRtl()) {
                            Ldloc(_textendV);
                            Ldloc(_textposV);
                        }
                        else {
                            Ldloc(_textposV);
                            Ldloc(_textbegV);
                        }
                        Sub();
                        if (c != infinite) {
                            Label l4 = DefineLabel();
                            Dup();
                            Ldc(c);
                            Blt(l4);
                            Pop();
                            Ldc(c);
                            MarkLabel(l4);
                        }
                        Dup();
                        Stloc(lenV);
                        Ldc(1);
                        Add();
                        Stloc(cV);

                        MarkLabel(l1);
                        Ldloc(cV);
                        Ldc(1);
                        Sub();
                        Dup();
                        Stloc(cV);
                        Ldc(0);
                        if (Code() == RegexCode.Setloop)
                            BleFar(l2);
                        else
                            Ble(l2);

                        if (IsRtl())
                            Leftcharnext();
                        else
                            Rightcharnext();
                        if (IsCi()) 
                            CallToLower();
                        
                        if (Code() == RegexCode.Setloop) {
                            Ldstr(_strings[Operand(0)]);
                            Ldstr(_strings[Operand(1)]);
                            Call(_charInSetM);

                            BrtrueFar(l1);
                        }
                        else {
                            Ldc(Operand(0));
                            if (Code() == RegexCode.Oneloop)
                                Beq(l1);
                            else
                                Bne(l1);
                        }

                        Ldloc(_textposV);
                        Ldc(1);
                        Sub(IsRtl());
                        Stloc(_textposV);

                        MarkLabel(l2);
                        Ldloc(lenV);
                        Ldloc(cV);
                        Ble(AdvanceLabel());

                        ReadyPushTrack();
                        Ldloc(lenV);
                        Ldloc(cV);
                        Sub();
                        Ldc(1);
                        Sub();
                        DoPush();

                        ReadyPushTrack();
                        Ldloc(_textposV);
                        Ldc(1);
                        Sub(IsRtl());
                        DoPush();

                        Track();
                        break;
                    }

                case RegexCode.Oneloop | RegexCode.Back:
                case RegexCode.Notoneloop | RegexCode.Back:
                case RegexCode.Setloop | RegexCode.Back:
                case RegexCode.Oneloop | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Notoneloop | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Setloop | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Back:
                case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Back:
                case RegexCode.Setloop | RegexCode.Ci | RegexCode.Back:
                case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                    //: Trackframe(2);
                    //: int i   = Tracked(0);
                    //: int pos = Tracked(1);
                    //: Textto(pos);
                    //: if (i > 0)
                    //:     Track(i - 1, pos - 1);
                    //: Advance(2);
                    PopTrack();
                    Stloc(_textposV);
                    PopTrack();
                    Stloc(_tempV);
                    Ldloc(_tempV);
                    Ldc(0);
                    BleFar(AdvanceLabel());
                    ReadyPushTrack();
                    Ldloc(_tempV);
                    Ldc(1);
                    Sub();
                    DoPush();
                    ReadyPushTrack();
                    Ldloc(_textposV);
                    Ldc(1);
                    Sub(IsRtl());
                    DoPush();
                    Trackagain();
                    Advance();
                    break;

                case RegexCode.Onelazy:
                case RegexCode.Notonelazy:
                case RegexCode.Setlazy:
                case RegexCode.Onelazy | RegexCode.Rtl:
                case RegexCode.Notonelazy | RegexCode.Rtl:
                case RegexCode.Setlazy | RegexCode.Rtl:
                case RegexCode.Onelazy | RegexCode.Ci:
                case RegexCode.Notonelazy | RegexCode.Ci:
                case RegexCode.Setlazy | RegexCode.Ci:
                case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl:
                case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl:
                case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl:
                    //: int c = Operand(1);
                    //: if (c > Rightchars())
                    //:     c = Rightchars();
                    //: if (c > 0)
                    //:     Track(c - 1, Textpos());
                    {
                        LocalBuilder cV   = _tempV;

                        int c = (Code() == RegexCode.Setlazy) ? Operand(2): Operand(1);

                        if (c == 0)
                            break;

                        if (!IsRtl()) {
                            Ldloc(_textendV);
                            Ldloc(_textposV);
                        }
                        else {
                            Ldloc(_textposV);
                            Ldloc(_textbegV);
                        }
                        Sub();
                        if (c != infinite) {
                            Label l4 = DefineLabel();
                            Dup();
                            Ldc(c);
                            Blt(l4);
                            Pop();
                            Ldc(c);
                            MarkLabel(l4);
                        }
                        Dup();
                        Stloc(cV);
                        Ldc(0);
                        Ble(AdvanceLabel());
                        ReadyPushTrack();
                        Ldloc(cV);
                        Ldc(1);
                        Sub();
                        DoPush();
                        PushTrack(_textposV);
                        Track();
                        break;
                    }

                case RegexCode.Onelazy | RegexCode.Back:
                case RegexCode.Notonelazy | RegexCode.Back:
                case RegexCode.Setlazy | RegexCode.Back:
                case RegexCode.Onelazy | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Notonelazy | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Setlazy | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Back:
                case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Back:
                case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Back:
                case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:
                    //: Trackframe(2);
                    //: int pos = Tracked(1);
                    //: Textto(pos);
                    //: if (Rightcharnext() != (char)Operand(0))
                    //:     break Backward;
                    //: int i = Tracked(0);
                    //: if (i > 0)
                    //:     Track(i - 1, pos + 1);

                    PopTrack();
                    Stloc(_textposV);
                    PopTrack();
                    Stloc(_temp2V);

                    if (!IsRtl())
                        Rightcharnext();
                    else
                        Leftcharnext();

                    if (IsCi())
                        CallToLower();

                    if (Code() == RegexCode.Setlazy) {
                        Ldstr(_strings[Operand(0)]);
                        Ldstr(_strings[Operand(1)]);
                        Call(_charInSetM);

                        BrfalseFar(_backtrack);
                    }
                    else {
                        Ldc(Operand(0));
                        if (Code() == RegexCode.Onelazy)
                            BneFar(_backtrack);
                        else
                            BeqFar(_backtrack);
                    }

                    Ldloc(_temp2V);
                    Ldc(0);
                    BleFar(AdvanceLabel());
                    ReadyPushTrack();
                    Ldloc(_temp2V);
                    Ldc(1);
                    Sub();
                    DoPush();
                    PushTrack(_textposV);
                    Trackagain();
                    Advance();
                    break;

                default:
                    throw new NotImplementedException(SR.GetString(SR.UnimplementedState));
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexoptions.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexOptions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
#define ECMA


namespace System.Text.RegularExpressions {

using System;

    /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum RegexOptions {
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None =                     0x0000,  

        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.IgnoreCase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IgnoreCase =               0x0001,      // "i"

        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.Multiline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Multiline =                0x0002,      // "m"
        
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.ExplicitCapture"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ExplicitCapture =          0x0004,      // "n"
        
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.Compiled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Compiled =                 0x0008,      // "c"
        
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.Singleline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Singleline =               0x0010,      // "s"
        
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.IgnorePatternWhitespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IgnorePatternWhitespace =  0x0020,      // "x"
        
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.RightToLeft"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RightToLeft =              0x0040,      // "r"

#if DBG
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.Debug"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Debug=                     0x0080,      // "d"
#endif

#if ECMA
        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.ECMAScript"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ECMAScript =                  0x0100,      // "e"
#endif

        /// <include file='doc\RegexOptions.uex' path='docs/doc[@for="RegexOptions.CultureInvariant"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CultureInvariant =                  0x0200,
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexParser class is internal to the Regex package.
 * It builds a tree of RegexNodes from a regular expression
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/22/99 (dbau)      First draft
 *
 */

/*
 * Implementation notes:
 *
 * It would be nice to get rid of the comment modes, since the
 * ScanBlank() calls are just kind of duct-taped in.
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Globalization;
        
    internal sealed class RegexParser {
        internal RegexNode _stack;
        internal RegexNode _group;
        internal RegexNode _alternation;
        internal RegexNode _concatenation;
        internal RegexNode _unit;

        internal String _pattern;
        internal int _currentPos;
        internal CultureInfo _culture;
        
        internal int _autocap;
        internal int _capcount;
        internal int _captop;
        internal int _capsize;
        internal Hashtable _caps;
        internal Hashtable _capnames;
        internal Object[] _capnumlist;
        internal ArrayList _capnamelist;

        internal RegexOptions _options;
        internal ArrayList _optionsStack;

        internal bool _ignoreNextParen = false;
        
        internal const int infinite = RegexNode.infinite;

        /*
         * This static call constructs a RegexTree from a regular expression
         * pattern string and an option string.
         *
         * The method creates, drives, and drops a parser instance.
         */
        internal static RegexTree Parse(String re, RegexOptions op) {
            RegexParser p;
            RegexNode root;
            String[] capnamelist;

            p = new RegexParser((op & RegexOptions.CultureInvariant) != 0 ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture);

            p._options = op;

            p.SetPattern(re);
            p.CountCaptures();
            p.Reset(op);
            root = p.ScanRegex();

            if (p._capnamelist == null)
                capnamelist = null;
            else
                capnamelist = (String[])p._capnamelist.ToArray(typeof(String));

            return new RegexTree(root, p._caps, p._capnumlist, p._captop, p._capnames, capnamelist, op);
        }

        /*
         * This static call constructs a flat concatenation node given
         * a replacement pattern.
         */
        internal static RegexReplacement ParseReplacement(String rep, Hashtable caps, int capsize, Hashtable capnames, RegexOptions op) {
            RegexParser p;
            RegexNode root;

            p = new RegexParser((op & RegexOptions.CultureInvariant) != 0 ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture);

            p._options = op;

            p.NoteCaptures(caps, capsize, capnames);
            p.SetPattern(rep);
            root = p.ScanReplacement();

            return new RegexReplacement(rep, root, caps);
        }

        /*
         * Escapes all metacharacters (including |,(,),[,{,|,^,$,*,+,?,\, spaces and #)
         */
        internal static String Escape(String input) {
            for (int i = 0; i < input.Length; i++) {
                if (IsMetachar(input[i])) {
                    StringBuilder sb = new StringBuilder();
                    char ch = input[i];
                    int lastpos;

                    sb.Append(input, 0, i);
                    do {
                        sb.Append('\\');
                        switch (ch) {
                            case '\n':
                                ch = 'n';
                                break;
                            case '\r':
                                ch = 'r';
                                break;
                            case '\t':
                                ch = 't';
                                break;
                            case '\f':
                                ch = 'f';
                                break;
                        }
                        sb.Append(ch);
                        i++;
                        lastpos = i;

                        while (i < input.Length) {
                            ch = input[i];
                            if (IsMetachar(ch))
                                break;

                            i++;
                        }

                        sb.Append(input, lastpos, i - lastpos);

                    } while (i < input.Length);

                    return sb.ToString();
                }
            }

            return input;
        }

        /*
         * Escapes all metacharacters (including (,),[,],{,},|,^,$,*,+,?,\, spaces and #)
         */
        internal static String Unescape(String input) {
            for (int i = 0; i < input.Length; i++) {
                if (input[i] == '\\') {
                    StringBuilder sb = new StringBuilder();
                    RegexParser p = new RegexParser(CultureInfo.InvariantCulture);
                    int lastpos;
                    p.SetPattern(input);

                    sb.Append(input, 0, i);
                    do {
                        i++;
                        p.Textto(i);
                        if (i < input.Length)
                            sb.Append(p.ScanCharEscape());
                        i = p.Textpos();
                        lastpos = i;
                        while (i < input.Length && input[i] != '\\')
                            i++;
                        sb.Append(input, lastpos, i - lastpos);

                    } while (i < input.Length);

                    return sb.ToString();
                }
            }

            return input;
        }

        /*
         * Private constructor.
         */
        private RegexParser(CultureInfo culture) {
            _culture = culture;
            _optionsStack = new ArrayList();
            _caps = new Hashtable();
        }

        /*
         * Drops a string into the pattern buffer.
         */
        internal void SetPattern(String Re) {
            if (Re == null)
                Re = String.Empty;
            _pattern = Re;
            _currentPos = 0;
        }

        /*
         * Resets parsing to the beginning of the pattern.
         */
        internal void Reset(RegexOptions topopts) {
            _currentPos = 0;
            _autocap = 1;
            _ignoreNextParen = false;

            if (_optionsStack.Count > 0)
                _optionsStack.RemoveRange(0, _optionsStack.Count - 1);

            _options = topopts;
            _stack = null;
        }

        /*
         * The main parsing function.
         */
        internal RegexNode ScanRegex() {
            char ch = '@'; // nonspecial ch, means at beginning
            bool isQuantifier = false;

            StartGroup(new RegexNode(RegexNode.Capture, _options, 0, -1));

            while (CharsRight() > 0) {
                bool wasPrevQuantifier = isQuantifier;
                isQuantifier = false;

                ScanBlank();

                int startpos = Textpos();

                if (UseOptionX())
                    while (CharsRight() > 0 && (!IsStopperX(ch = RightChar()) || ch == '{' && !IsTrueQuantifier()))
                        RightNext();
                else
                    while (CharsRight() > 0 && (!IsSpecial(ch = RightChar()) || ch == '{' && !IsTrueQuantifier()))
                        RightNext();

                int endpos = Textpos();

                ScanBlank();

                if (CharsRight() == 0)
                    ch = '!'; // nonspecial, means at end
                else if (IsSpecial(ch = RightChar())) {
                    isQuantifier = IsQuantifier(ch);
                    RightNext();
                } else
                    ch = ' '; // nonspecial, means at ordinary char

                if (startpos < endpos) {
                    int cchUnquantified = endpos - startpos - (isQuantifier ? 1 : 0);

                    wasPrevQuantifier = false;

                    if (cchUnquantified > 0)
                        AddConcatenate(startpos, cchUnquantified, false);

                    if (isQuantifier)
                        AddUnitOne(CharAt(endpos - 1));
                }

                switch (ch) {
                    case '!':
                        goto BreakOuterScan;

                    case ' ':
                        goto ContinueOuterScan;

                    case '[':
                        AddUnitSet(ScanCharClass(UseOptionI()));
                        if (CharsRight() == 0 || RightCharNext() != ']')
                            throw MakeException(SR.GetString(SR.UnterminatedBracket));
                        break;

                    case '(': {
                            RegexNode grouper;

                            PushOptions();

                            if (null == (grouper = ScanGroupOpen())) {
                                PopKeepOptions();
                            }
                            else {
                                PushGroup();
                                StartGroup(grouper);
                            }
                        }
                        continue;

                    case '|':
                        AddAlternate();
                        goto ContinueOuterScan;

                    case ')':
                        if (EmptyStack())
                            throw MakeException(SR.GetString(SR.TooManyParens));

                        AddGroup();
                        PopGroup();
                        PopOptions();

                        if (Unit() == null)
                            goto ContinueOuterScan;
                        break;

                    case '\\':
                        AddUnitNode(ScanBackslash());
                        break;

                    case '^':
                        AddUnitType(UseOptionM() ? RegexNode.Bol : RegexNode.Beginning);
                        break;

                    case '$':
                        AddUnitType(UseOptionM() ? RegexNode.Eol : RegexNode.EndZ);
                        break;

                    case '.':
                        if (UseOptionS())
                            AddUnitSet(RegexCharClass.AnyClass);
                        else
                            AddUnitNotone('\n');
                        break;

                    case '{':
                    case '*':
                    case '+':
                    case '?':
                        if (Unit() == null)
                            throw MakeException(wasPrevQuantifier ?
                                                SR.GetString(SR.NestedQuantify, ch.ToString()) :
                                                SR.GetString(SR.QuantifyAfterNothing));
                        LeftNext();
                        break;

                    default:
                        throw MakeException(SR.GetString(SR.InternalError));
                }

                ScanBlank();

                if (CharsRight() == 0 || !(isQuantifier = IsTrueQuantifier())) {
                    AddConcatenate();
                    goto ContinueOuterScan;
                }

                ch = RightCharNext();

                // Handle quantifiers
                while (Unit() != null) {
                    int min;
                    int max;
                    bool lazy;

                    switch (ch) {
                        case '*':
                            min = 0;
                            max = infinite;
                            break;

                        case '?':
                            min = 0;
                            max = 1;
                            break;

                        case '+':
                            min = 1;
                            max = infinite;
                            break;

                        case '{': {
                                startpos = Textpos();
                                max = min = ScanDecimal();
                                if (startpos < Textpos()) {
                                    if (CharsRight() > 0 && RightChar() == ',') {
                                        RightNext();
                                        if (CharsRight() == 0 || RightChar() == '}')
                                            max = infinite;
                                        else
                                            max = ScanDecimal();
                                    }
                                }

                                if (startpos == Textpos() || CharsRight() == 0 || RightCharNext() != '}') {
                                    AddConcatenate();
                                    Textto(startpos - 1);
                                    goto ContinueOuterScan;
                                }
                            }

                            break;

                        default:
                            throw MakeException(SR.GetString(SR.InternalError));
                    }

                    ScanBlank();

                    if (CharsRight() == 0 || RightChar() != '?')
                        lazy = false;
                    else {
                        RightNext();
                        lazy = true;
                    }

                    if (min > max)
                        throw MakeException(SR.GetString(SR.IllegalRange));

                    AddConcatenate(lazy, min, max);
                }

                ContinueOuterScan:
                ;
            }

            BreakOuterScan: 
            ;

            if (!EmptyStack())
                throw MakeException(SR.GetString(SR.NotEnoughParens));

            AddGroup();

            return Unit();
        }

        /*
         * Simple parsing for replacement patterns
         */
        internal RegexNode ScanReplacement() {
            int c;
            int startpos;

            _concatenation = new RegexNode(RegexNode.Concatenate, _options);

            for (;;) {
                c = CharsRight();
                if (c == 0)
                    break;

                startpos = Textpos();

                while (c > 0 && RightChar() != '$') {
                    RightNext();
                    c--;
                }

                AddConcatenate(startpos, Textpos() - startpos, true);

                if (c > 0) {
                    if (RightCharNext() == '$')
                        AddUnitNode(ScanDollar());
                    AddConcatenate();
                }
            }

            return _concatenation;
        }

        /*
         * Scans contents of [] (not including []'s), and converts to a
         * RegexCharClass.
         */
        internal RegexCharClass ScanCharClass(bool caseInsensitive) {
            return ScanCharClass(caseInsensitive, false);
        }

        /*
         * Scans contents of [] (not including []'s), and converts to a
         * RegexCharClass.
         */
        internal RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly) {
            char    ch = '\0';
            bool inRange;
            bool firstChar;
            char    chPrev = '\0';

            RegexCharClass cc;

            cc = scanOnly ? null : new RegexCharClass();

            if (CharsRight() > 0 && RightChar() == '^') {
                RightNext();
                firstChar = false;
                if (!scanOnly)
                    cc.Negate = true;
            }

            inRange = false;

            for (firstChar = true; CharsRight() > 0; firstChar = false) {
                switch (ch = RightCharNext()) {
                    case ']':
                        if (!firstChar) {
                            LeftNext();
                            goto BreakScan;
                        }
                        break;

                    case '\\':
                        if (CharsRight() > 0) {
                            switch (ch = RightCharNext()) {
                                case 'd':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
#if ECMA
                                        if (UseOptionE())
                                            cc.AddSet(RegexCharClass.ECMADigit);
                                        else
#endif
                                            cc.AddCategoryFromName("Nd", false, false, _pattern);
                                    }
                                    continue;

                                case 'D':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
#if ECMA
                                        if (UseOptionE())
                                            cc.AddSet(RegexCharClass.NotECMADigit);
                                        else
#endif
                                            cc.AddCategoryFromName("Nd", true, false, _pattern);
                                    }
                                    continue;

                                case 's':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
#if ECMA
                                        if (UseOptionE())
                                            cc.AddSet(RegexCharClass.ECMASpace);
                                        else
#endif
                                            cc.AddCategory(RegexCharClass.Space);
                                    }
                                    continue;

                                case 'S':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
#if ECMA
                                        if (UseOptionE())
                                            cc.AddSet(RegexCharClass.NotECMASpace);
                                        else
#endif
                                            cc.AddCategory(RegexCharClass.NotSpace);
                                    }
                                    continue;

                                case 'w':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
#if ECMA
                                        if (UseOptionE())
                                            cc.AddSet(RegexCharClass.ECMAWord);
                                        else
#endif
                                            cc.AddCategory(RegexCharClass.Word);
                                    }
                                    continue;


                                case 'W':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
#if ECMA
                                        if (UseOptionE())
                                            cc.AddSet(RegexCharClass.NotECMAWord);
                                        else
#endif
                                            cc.AddCategory(RegexCharClass.NotWord);
                                    }
                                    continue;


                                case 'p':
                                case 'P':
                                    if (!scanOnly) {
                                        if (inRange)
                                            throw MakeException(SR.GetString(SR.BadClassInCharRange, ch.ToString()));
                                        cc.AddCategoryFromName(ParseProperty(), (ch != 'p'), caseInsensitive, _pattern);
                                    }
                                    else 
                                        ParseProperty();

                                    continue;
                                    

                                default:
                                    LeftNext();
                                    ch = ScanCharEscape();
                                    break;
                            }
                        }
                        break;

                    case '[':
                        if (CharsRight() > 0 && RightChar() == ':' && !inRange) {
                            String name;
                            int savePos = Textpos();

                            RightNext();
                            name = ScanCapname();
                            if (CharsRight() < 2 || RightCharNext() != ':' || RightCharNext() != ']')
                                Textto(savePos);
                            // else lookup name (nyi)
                        }
                        break;
                }

                if (inRange) {
                    inRange = false;
                    if (!scanOnly) {
                        if (chPrev > ch)
                            throw MakeException(SR.GetString(SR.ReversedCharRange));
                        cc.AddRange(chPrev, ch);
                    }
                }
                else if (CharsRight() >= 2 && RightChar() == '-' && RightChar(1) != ']') {
                    chPrev = ch;
                    inRange = true;
                    RightNext();
                }
                else {
                    if (!scanOnly)
                        cc.AddRange(ch, ch);
                }
            }

            BreakScan: 
            ;

            return cc;
        }

        /*
         * Scans chars following a '(' (not counting the '('), and returns
         * a RegexNode for the type of group scanned, or null if the group
         * simply changed options (?cimsx-cimsx) or was a comment (#...).
         */
        internal RegexNode ScanGroupOpen() {
            char ch = '\0';
            int NodeType;
            char close = '>';


            // just return a RegexNode if we have:
            // 1. "(" followed by nothing
            // 2. "(x" where x != ?
            // 3. "(?)"
            if (CharsRight() == 0 || RightChar() != '?' || (RightChar() == '?' && RightChar(1) == ')')) {
                if (UseOptionN() || _ignoreNextParen) {
                    _ignoreNextParen = false;
                    return new RegexNode(RegexNode.Group, _options);
                }
                else
                    return new RegexNode(RegexNode.Capture, _options, _autocap++, -1);
            }

            RightNext();

            for (;;) {
                if (CharsRight() == 0)
                    break;

                switch (ch = RightCharNext()) {
                    case ':':
                        NodeType = RegexNode.Group;
                        break;

                    case '=':
                        _options &= ~(RegexOptions.RightToLeft);
                        NodeType = RegexNode.Require;
                        break;

                    case '!':
                        _options &= ~(RegexOptions.RightToLeft);
                        NodeType = RegexNode.Prevent;
                        break;

                    case '>':
                        NodeType = RegexNode.Greedy;
                        break;

                    case '\'':
                        close = '\'';
                        goto case '<';
                        // fallthrough

                    case '<':
                        if (CharsRight() == 0)
                            goto BreakRecognize;

                        switch (ch = RightCharNext()) {
                            case '=':
                                if (close == '\'')
                                    goto BreakRecognize;

                                _options |= RegexOptions.RightToLeft;
                                NodeType = RegexNode.Require;
                                break;

                            case '!':
                                if (close == '\'')
                                    goto BreakRecognize;

                                _options |= RegexOptions.RightToLeft;
                                NodeType = RegexNode.Prevent;
                                break;

                            default:
                                LeftNext();
                                int capnum = -1;
                                int uncapnum = -1;
                                bool proceed = false;

                                // grab part before -

                                if (ch >= '0' && ch <= '9') {
                                    capnum = ScanDecimal();

                                    if (!IsCaptureSlot(capnum))
                                        capnum = -1;

                                    // check if we have bogus characters after the number
                                    if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))
                                        throw MakeException(SR.GetString(SR.InvalidGroupName));
                                    if (capnum == 0)
                                        throw MakeException(SR.GetString(SR.CapnumNotZero));
                                }
                                else if (RegexCharClass.IsWordChar(ch)) {
                                    String capname = ScanCapname();

                                    if (IsCaptureName(capname))
                                        capnum = CaptureSlotFromName(capname);

                                    // check if we have bogus character after the name
                                    if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))
                                        throw MakeException(SR.GetString(SR.InvalidGroupName));
                                }
                                else if (ch == '-') {
                                    proceed = true;
                                }
                                else {
                                    // bad group name - starts with something other than a word character and isn't a number
                                    throw MakeException(SR.GetString(SR.InvalidGroupName));
                                }

                                // grab part after - if any

                                if ((capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-') {
                                    RightNext();
                                    ch = RightChar();

                                    if (ch >= '0' && ch <= '9') {
                                        uncapnum = ScanDecimal();
                                        
                                        if (!IsCaptureSlot(uncapnum))
                                            throw MakeException(SR.GetString(SR.UndefinedBackref, uncapnum));
                                        
                                        // check if we have bogus characters after the number
                                        if (CharsRight() > 0 && RightChar() != close)
                                            throw MakeException(SR.GetString(SR.InvalidGroupName));
                                    }
                                    else if (RegexCharClass.IsWordChar(ch)) {
                                        String uncapname = ScanCapname();

                                        if (IsCaptureName(uncapname))
                                            uncapnum = CaptureSlotFromName(uncapname);
                                        else
                                            throw MakeException(SR.GetString(SR.UndefinedNameRef, uncapname));

                                        // check if we have bogus character after the name
                                        if (CharsRight() > 0 && RightChar() != close)
                                            throw MakeException(SR.GetString(SR.InvalidGroupName));
                                    }
                                    else {
                                        // bad group name - starts with something other than a word character and isn't a number
                                        throw MakeException(SR.GetString(SR.InvalidGroupName));
                                    }
                                }

                                // actually make the node

                                if ((capnum != -1 || uncapnum != -1) && CharsRight() > 0 && RightCharNext() == close) {
                                    return new RegexNode(RegexNode.Capture, _options, capnum, uncapnum);
                                }
                                goto BreakRecognize;
                        }
                        break;

                    case '(': 
                        // alternation construct (?(...) | )
                        int parenPos = Textpos();

                        ch = RightChar();

                        // check if the alternation condition is a backref
                        if (ch >= '0' && ch <= '9') {
                            int capnum = ScanDecimal();
                            if (CharsRight() > 0 && RightCharNext() == ')') {
                                if (IsCaptureSlot(capnum))
                                    return new RegexNode(RegexNode.Testref, _options, capnum);
                                else
                                    throw MakeException(SR.GetString(SR.UndefinedReference, capnum.ToString()));
                            }
                            else
                                throw MakeException(SR.GetString(SR.MalformedReference, capnum.ToString()));

                        }
                        else if (RegexCharClass.IsWordChar(ch)) {
                            String capname = ScanCapname();

                            if (IsCaptureName(capname) && CharsRight() > 0 && RightCharNext() == ')')
                                return new RegexNode(RegexNode.Testref, _options, CaptureSlotFromName(capname));
                        }

                        // not a backref
                        NodeType = RegexNode.Testgroup;
                        Textto(parenPos - 1);       // jump to the start of the parentheses
                        _ignoreNextParen = true;    // but make sure we don't try to capture the insides

                        int charsRight = CharsRight();
                        if (charsRight >= 3 && RightChar(1) == '?') {
                            char rightchar2 = RightChar(2);
                            // disallow comments in the condition
                            if (rightchar2 == '#')
                                throw MakeException(SR.GetString(SR.AlternationCantHaveComment));

                            // disallow named capture group (?<..>..) in the condition
                            if (rightchar2 == '\'' ) 
                                throw MakeException(SR.GetString(SR.AlternationCantCapture));
                            else {
                                if (charsRight >=4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '='))
                                    throw MakeException(SR.GetString(SR.AlternationCantCapture));
                            }
                        }
                            
                        break;


                    default:
                        LeftNext();

                        NodeType = RegexNode.Group;
                        ScanOptions();
                        if (CharsRight() == 0)
                            goto BreakRecognize;

                        if ((ch = RightCharNext()) == ')')
                            return null;

                        if (ch != ':')
                            goto BreakRecognize;
                        break;
                }

                return new RegexNode(NodeType, _options);
            }

            BreakRecognize: 
            ;
            // break Recognize comes here

            throw MakeException(SR.GetString(SR.UnrecognizedGrouping));
        }

        /*
         * Scans whitespace or x-mode comments.
         */
        internal void ScanBlank() {
            if (UseOptionX()) {
                for (;;) {
                    while (CharsRight() > 0 && IsSpace(RightChar()))
                        RightNext();

                    if (CharsRight() == 0)
                        break;

                    if (RightChar() == '#') {
                        while (CharsRight() > 0 && RightChar() != '\n')
                            RightNext();
                    }
                    else if (CharsRight() >= 3 && RightChar(2) == '#' &&
                             RightChar(1) == '?' && RightChar() == '(') {
                        while (CharsRight() > 0 && RightChar() != ')')
                            RightNext();
                        if (CharsRight() == 0)
                            throw MakeException(SR.GetString(SR.UnterminatedComment));
                        RightNext();
                    }
                    else
                        break;
                }
            }
            else {
                for (;;) {
                    if (CharsRight() < 3 || RightChar(2) != '#' ||
                        RightChar(1) != '?' || RightChar() != '(')
                        return;

                    while (CharsRight() > 0 && RightChar() != ')')
                        RightNext();
                    if (CharsRight() == 0)
                        throw MakeException(SR.GetString(SR.UnterminatedComment));
                    RightNext();
                }
            }
        }

        /*
         * Scans chars following a '\' (not counting the '\'), and returns
         * a RegexNode for the type of atom scanned.
         */
        internal RegexNode ScanBackslash() {
            char ch;
            RegexCharClass cc;

            if (CharsRight() == 0)
                throw MakeException(SR.GetString(SR.IllegalEndEscape));

            switch (ch = RightChar()) {
                case 'b':
                case 'B':
                case 'A':
                case 'G':
                case 'Z':
                case 'z':
                    RightNext();
                    return new RegexNode(TypeFromCode(ch), _options);

                case 'w':
                    RightNext();
#if ECMA
                    if (UseOptionE())
                        return new RegexNode(RegexNode.Set, _options, RegexCharClass.ECMAWord, String.Empty);
#endif
                    return new RegexNode(RegexNode.Set, _options, String.Empty, RegexCharClass.Word);

                case 'W':
                    RightNext();
#if ECMA
                    if (UseOptionE())
                        return new RegexNode(RegexNode.Set, _options, RegexCharClass.NotECMAWord, String.Empty);
#endif
                    return new RegexNode(RegexNode.Set, _options, String.Empty, RegexCharClass.NotWord);

                case 's':
                    RightNext();
#if ECMA
                    if (UseOptionE())
                        return new RegexNode(RegexNode.Set, _options, RegexCharClass.ECMASpace, String.Empty);
#endif
                    return new RegexNode(RegexNode.Set, _options, String.Empty, RegexCharClass.Space);

                case 'S':
                    RightNext();
#if ECMA
                    if (UseOptionE())
                        return new RegexNode(RegexNode.Set, _options, RegexCharClass.NotECMASpace, String.Empty);
#endif
                    return new RegexNode(RegexNode.Set, _options, String.Empty, RegexCharClass.NotSpace);

                case 'd':
                    RightNext();
#if ECMA
                    if (UseOptionE())
                        return new RegexNode(RegexNode.Set, _options, RegexCharClass.ECMADigit, String.Empty);
#endif
                    cc = RegexCharClass.CreateFromCategory("Nd", false, false, _pattern);
                    return new RegexNode(RegexNode.Set, _options, String.Empty, cc.Category);

                case 'D':
                    RightNext();
#if ECMA
                    if (UseOptionE())
                        return new RegexNode(RegexNode.Set, _options, RegexCharClass.NotECMADigit, String.Empty);
#endif
                    cc = RegexCharClass.CreateFromCategory("Nd", true, false, _pattern);
                    return new RegexNode(RegexNode.Set, _options, String.Empty, cc.Category);

                case 'p':
                case 'P':
                    RightNext();
                    cc = RegexCharClass.CreateFromCategory(ParseProperty(), (ch != 'p'), UseOptionI(), _pattern);
                    return new RegexNode(RegexNode.Set, _options, cc.ToSetCi(UseOptionI(), _culture), cc.Category);

                default:
                    return ScanBasicBackslash();
            }
        }

        /*
         * Scans \-style backreferences and character escapes
         */
        internal RegexNode ScanBasicBackslash() {
            if (CharsRight() == 0)
                throw MakeException(SR.GetString(SR.IllegalEndEscape));

            char ch;
            bool angled = false;
            char close = '\0';
            int backpos;

            backpos = Textpos();
            ch = RightChar();

            // allow \k<foo> instead of \<foo>, which is now deprecated

            if (ch == 'k') {
                if (CharsRight() >= 2) {
                    RightNext();
                    ch = RightCharNext();

                    if (ch == '<' || ch == '\'') {
                        angled = true;
                        close = (ch == '\'') ? '\'' : '>';
                    }
                }

                if (!angled)
                    throw MakeException(SR.GetString(SR.MalformedNameRef));

                ch = RightChar();
            }

            // Note angle without \g (CONSIDER: to be removed)

            else if ((ch == '<' || ch == '\'') && CharsRight() > 1) {
                angled = true;
                close = (ch == '\'') ? '\'' : '>';

                RightNext();
                ch = RightChar();
            }

            // Try to parse backreference: \<1> or \<cap>

            if (angled && ch >= '0' && ch <= '9') {
                int capnum = ScanDecimal();

                if (CharsRight() > 0 && RightCharNext() == close) {
                    if (IsCaptureSlot(capnum))
                        return new RegexNode(RegexNode.Ref, _options, capnum);
                    else
                        throw MakeException(SR.GetString(SR.UndefinedBackref, capnum.ToString()));
                }
            }

            // Try to parse backreference or octal: \1

            else if (!angled && ch >= '1' && ch <= '9') {
#if ECMA
                if (UseOptionE()) {
                    int capnum = -1;
                    int newcapnum = (int)(ch - '0');
                    int pos = Textpos() - 1;
                    while (newcapnum <= _captop) {
                        if (IsCaptureSlot(newcapnum) && (_caps == null || (int)_caps[newcapnum] < pos))
                            capnum = newcapnum;
                        RightNext();
                        if (CharsRight() == 0 || (ch = RightChar()) < '0' || ch > '9')
                            break;
                        newcapnum = newcapnum * 10 + (int)(ch - '0');
                    }
                    if (capnum >= 0)
                        return new RegexNode(RegexNode.Ref, _options, capnum);
                } else
#endif
                {

                  int capnum = ScanDecimal();
                  if (IsCaptureSlot(capnum))
                      return new RegexNode(RegexNode.Ref, _options, capnum);
                  else if (capnum <= 9)
                      throw MakeException(SR.GetString(SR.UndefinedBackref, capnum.ToString()));
                }
            }

            else if (angled && RegexCharClass.IsWordChar(ch)) {
                String capname = ScanCapname();

                if (CharsRight() > 0 && RightCharNext() == close) {
                    if (IsCaptureName(capname))
                        return new RegexNode(RegexNode.Ref, _options, CaptureSlotFromName(capname));
                    else
                        throw MakeException(SR.GetString(SR.UndefinedNameRef, capname));
                }
            }

            // Not backreference: must be char code

            Textto(backpos);
            ch = ScanCharEscape();

            if (UseOptionI())
                ch = Char.ToLower(ch, _culture);

            return new RegexNode(RegexNode.One, _options, ch);
        }

        /*
         * Scans $ patterns recognized within replacment patterns
         */
        internal RegexNode ScanDollar() {
            if (CharsRight() == 0)
                return new RegexNode(RegexNode.One, _options, '$');

            char ch;
            bool angled;
            int backpos;

            backpos = Textpos();
            ch = RightChar();

            // Note angle

            if (ch == '{' && CharsRight() > 1) {
                angled = true;
                RightNext();
                ch = RightChar();
            }
            else {
                angled = false;
            }

            // Try to parse backreference: \1 or \{1} or \{cap}

            if (ch >= '0' && ch <= '9') {
#if ECMA
                if (!angled && UseOptionE()) {
                    int capnum = -1;
                    int newcapnum = (int)(ch - '0');
                    int pos = Textpos() - 1;
                    while (newcapnum <= _capsize) {
                        if (IsCaptureSlot(newcapnum))
                            capnum = newcapnum;
                        RightNext();
                        if (CharsRight() == 0 || (ch = RightChar()) < '0' || ch > '9')
                            break;
                        newcapnum = newcapnum * 10 + (int)(ch - '0');
                    }
                    if (capnum >= 0)
                        return new RegexNode(RegexNode.Ref, _options, capnum);
                } 
                else
#endif
                {
                    int capnum = ScanDecimal();
                    if (!angled || CharsRight() > 0 && RightCharNext() == '}') {
                        if (IsCaptureSlot(capnum))
                            return new RegexNode(RegexNode.Ref, _options, capnum);
                    }
                }
            }
            else if (angled && RegexCharClass.IsWordChar(ch)) {
                String capname = ScanCapname();

                if (CharsRight() > 0 && RightCharNext() == '}') {
                    if (IsCaptureName(capname))
                        return new RegexNode(RegexNode.Ref, _options, CaptureSlotFromName(capname));
                }
            }
            else if (!angled) {
                int capnum = 1;

                switch (ch) {
                    case '$':
                        RightNext();
                        return new RegexNode(RegexNode.One, _options, '$');

                    case '&':
                        capnum = 0;
                        break;

                    case '`':
                        capnum = RegexReplacement.LeftPortion;
                        break;

                    case '\'':
                        capnum = RegexReplacement.RightPortion;
                        break;

                    case '+':
                        capnum = RegexReplacement.LastGroup;
                        break;

                    case '_':
                        capnum = RegexReplacement.WholeString;
                        break;
                }

                if (capnum != 1) {
                    RightNext();
                    return new RegexNode(RegexNode.Ref, _options, capnum);
                }
            }

            // unrecognized $: literalize

            Textto(backpos);
            return new RegexNode(RegexNode.One, _options, '$');
        }

        /*
         * Scans a capture name: consumes word chars
         */
        internal String ScanCapname() {
            int startpos = Textpos();

            while (CharsRight() > 0) {
                if (!RegexCharClass.IsWordChar(RightCharNext())) {
                    LeftNext();
                    break;
                }
            }

            return _pattern.Substring(startpos, Textpos() - startpos);
        }


        /*
         * Scans up to three octal digits (stops before exceeding 0377).
         */
        internal char ScanOctal() {
            int d;
            int i;
            int c;

            // Consume octal chars only up to 3 digits and value 0377

            // HACKHACK: SMC incorrectly treats char as signed (dbau)
            c = 3;

            if (c > CharsRight())
                c = CharsRight();

            for (i = 0; c > 0 && (char)(d = RightChar() - '0') <= 7 && d >= 0; c -= 1) {
                RightNext();
                i *= 8;
                i += d;
#if ECMA
                if (UseOptionE() && i >= 0x20)
                    break;
#endif
            }

            // Octal codes only code from 0-127
            i &= 0x7F;

            return(char)i;
        }

        /*
         * Scans any number of decimal digits (pegs value at 2^31-1 if too large)
         */
        internal int ScanDecimal() {
            int i = 0;
            int d;

            // HACKHACK: SMC incorrectly treats char as signed so we have to
            // test d >= 0. When SMC fixes this (or when we get a language
            // with an unsigned modifier), we should remove the test (6/2/99 dbau)

            while (CharsRight() > 0 && (d = (char)(RightChar() - '0')) <= 9 && d >= 0) {
                RightNext();

                if (i > (infinite / 10) || i == (infinite / 10) && d > (infinite % 10))
                    i = infinite;

                i *= 10;
                i += d;
            }

            return i;
        }

        /*
         * Scans exactly c hex digits (c=2 for \xFF, c=4 for \uFFFF)
         */
        internal char ScanHex(int c) {
            int i;
            int d;

            i = 0;

            if (CharsRight() >= c) {
                for (; c > 0 && ((d = HexDigit(RightCharNext())) >= 0); c -= 1) {
                    i *= 0x10;
                    i += d;
                }
            }

            if (c > 0)
                throw MakeException(SR.GetString(SR.TooFewHex));

            return(char)i;
        }

        /*
         * Returns n <= 0xF for a hex digit.
         */
        internal static int HexDigit(char ch) {
            int d;

            // HACKHACK: SMC incorrectly treats char as signed (dbau)
            if ((char)(d = ch - '0') <= 9 && d >= 0)
                return d;

            if ((char)(d = ch - 'a') <= 5 && d >= 0)
                return d + 0xa;

            if ((char)(d = ch - 'A') <= 5 && d >= 0)
                return d + 0xa;

            return -1;
        }

        /*
         * Grabs and converts an ascii control character
         */
        internal char ScanControl() {
            char ch;

            if (CharsRight() <= 0)
                throw MakeException(SR.GetString(SR.MissingControl));

            ch = RightCharNext();

            // \ca interpreted as \cA

            // HACKHACK: SMC incorrectly treats char as signed (dbau)
            if (ch >= 'a' && ch <= 'z')
                ch = (char)(ch - ('a' - 'A'));

            if ((ch = (char)(ch - '@')) < ' ' && ch >= 0)
                return ch;

            throw MakeException(SR.GetString(SR.UnrecognizedControl));
        }

        /*
         * Returns true for options allowed only at the top level
         */
        internal bool IsOnlyTopOption(RegexOptions option) {
            return(option == RegexOptions.RightToLeft
                || option == RegexOptions.Compiled
                || option == RegexOptions.CultureInvariant
#if ECMA
                || option == RegexOptions.ECMAScript
#endif
            );
        }

        /*
         * Scans cimsx-cimsx option string, stops at the first unrecognized char.
         */
        internal void ScanOptions() {
            char ch;
            bool off;
            RegexOptions option;

            for (off = false; CharsRight() > 0; RightNext()) {
                ch = RightChar();

                if (ch == '-') {
                    off = true;
                }
                else if (ch == '+') {
                    off = false;
                }
                else {
                    option = OptionFromCode(ch);
                    if (option == 0 || IsOnlyTopOption(option))
                        return;

                    if (off)
                        _options &= ~option;
                    else
                        _options |= option;
                }
            }
        }

        /*
         * Scans \ code for escape codes that map to single unicode chars.
         */
        internal char ScanCharEscape() {
            char ch;

            ch = RightCharNext();

            // HACKHACK: SMC incorrectly treats char as signed (dbau)
            if (ch >= '0' && ch <= '7') {
                LeftNext();
                return ScanOctal();
            }

            switch (ch) {
                case 'x':
                    return ScanHex(2);
                case 'u':
                    return ScanHex(4);
                case 'a':
                    return '\u0007';
                case 'b':
                    return '\b';
                case 'e':
                    return '\u001B';
                case 'f':
                    return '\f';
                case 'n':
                    return '\n';
                case 'r':
                    return '\r';
                case 't':
                    return '\t';
                case 'v':
                    return '\u000B';
                case 'c':
                    return ScanControl();
                default:
                    if (
#if ECMA
                        !UseOptionE() &&
#endif
                        RegexCharClass.IsWordChar(ch))
                        throw MakeException(SR.GetString(SR.UnrecognizedEscape, ch.ToString()));
                    return ch;
            }
        }

        /*
         * Scans X for \p{X} or \P{X}
         */
        internal String ParseProperty() {
            if (CharsRight() < 3) {
                throw MakeException(SR.GetString(SR.IncompleteSlashP));
            }
            char ch = RightCharNext();
            if (ch != '{') {
                throw MakeException(SR.GetString(SR.MalformedSlashP));
            }
            String capname = ScanCapname();

            if (CharsRight() == 0 || RightCharNext() != '}')
                throw MakeException(SR.GetString(SR.IncompleteSlashP));

            return capname;
        }

        /*
         * Returns ReNode type for zero-length assertions with a \ code.
         */
        internal int TypeFromCode(char ch) {
            switch (ch) {
                case 'b':
                    return
#if ECMA
                        UseOptionE() ? RegexNode.ECMABoundary : 
#endif
                        RegexNode.Boundary;
                case 'B':
                    return
#if ECMA
                        UseOptionE() ? RegexNode.NonECMABoundary :
#endif
                        RegexNode.Nonboundary;
                case 'A':
                    return RegexNode.Beginning;
                case 'G':
                    return RegexNode.Start;
                case 'Z':
                    return RegexNode.EndZ;
                case 'z':
                    return RegexNode.End;
                default:
                    return RegexNode.Nothing;
            }
        }

        /*
         * Returns option bit from single-char (?cimsx) code.
         */
        internal static RegexOptions OptionFromCode(char ch) {
            // case-insensitive
            if (ch >= 'A' && ch <= 'Z')
                ch += (char)('a' - 'A');

            switch (ch) {
                case 'c':
                    return RegexOptions.Compiled;
                case 'i':
                    return RegexOptions.IgnoreCase;
                case 'r':
                    return RegexOptions.RightToLeft;
                case 'm':
                    return RegexOptions.Multiline;
                case 'n':
                    return RegexOptions.ExplicitCapture;
                case 's':
                    return RegexOptions.Singleline;
                case 'x':
                    return RegexOptions.IgnorePatternWhitespace;
#if DBG
                case 'd':
                    return RegexOptions.Debug;
#endif
#if ECMA
                case 'e':
                    return RegexOptions.ECMAScript;
#endif
                default:
                    return 0;
            }
        }

        /*
         * a prescanner for deducing the slots used for
         * captures by doing a partial tokenization of the pattern.
         */
        internal void CountCaptures() {
            char ch;

            NoteCaptureSlot(0, 0);

            _autocap = 1;

            while (CharsRight() > 0) {
                int pos = Textpos();
                ch = RightCharNext();
                switch (ch) {
                    case '\\':
                        if (CharsRight() > 0)
                            RightNext();
                        break;

                    case '#':
                        if (UseOptionX()) {
                            LeftNext();
                            ScanBlank();
                        }
                        break;

                    case '[':
                        ScanCharClass(false, true);
                        break;

                    case ')':
                        if (!EmptyOptionsStack())
                            PopOptions();
                        break;

                    case '(':
                        if (CharsRight() >= 2 && RightChar(1) == '#' && RightChar() == '?') {
                            LeftNext();
                            ScanBlank();
                        } 
                        else {
                            
                            PushOptions();
                            if (CharsRight() > 0 && RightChar() == '?') {
                                // we have (?...
                                RightNext();

                                if (CharsRight() > 1 && (RightChar() == '<' || RightChar() == '\'')) {
                                    // named group: (?<... or (?'...

                                    RightNext();
                                    ch = RightChar();

                                    if (ch != '0' && RegexCharClass.IsWordChar(ch)) {
                                        //if (_ignoreNextParen) 
                                        //    throw MakeException(SR.GetString(SR.AlternationCantCapture));
                                        if (ch >= '1' && ch <= '9') 
                                            NoteCaptureSlot(ScanDecimal(), pos);
                                        else 
                                            NoteCaptureName(ScanCapname(), pos);
                                    }
                                }
                                else {
                                    // (?...

                                    // get the options if it's an option construct (?cimsx-cimsx...)
                                    ScanOptions();

                                    if (CharsRight() > 0) {
                                        if (RightChar() == ')') {
                                            // (?cimsx-cimsx)
                                            RightNext();
                                            PopKeepOptions();
                                        }
                                        else if (RightChar() == '(') {
                                            // alternation construct: (?(foo)yes|no)
                                            // ignore the next paren so we don't capture the condition
                                            _ignoreNextParen = true;

                                            // break from here so we don't reset _ignoreNextParen
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                if (!UseOptionN() && !_ignoreNextParen)
                                    NoteCaptureSlot(_autocap++, pos);
                            }
                        }

                        _ignoreNextParen = false;
                        break;
                }
            }

            AssignNameSlots();
        }

        /*
         * Notes a used capture slot
         */
        internal void NoteCaptureSlot(int i, int pos) {
            if (!_caps.ContainsKey(i)) {
                // the rhs of the hashtable isn't used in the parser

                _caps.Add(i, pos);
                _capcount++;

                if (_captop <= i)
                    _captop = i + 1;
            }
        }

        /*
         * Notes a used capture slot
         */
        internal void NoteCaptureName(String name, int pos) {
            if (_capnames == null) {
                _capnames = new Hashtable();
                _capnamelist = new ArrayList();
            }

            if (!_capnames.ContainsKey(name)) {
                _capnames.Add(name, pos);
                _capnamelist.Add(name);
            }
        }

        /*
         * For when all the used captures are known: note them all at once
         */
        internal void NoteCaptures(Hashtable caps, int capsize, Hashtable capnames) {
            _caps = caps;
            _capsize = capsize;
            _capnames = capnames;
        }

        /*
         * Assigns unused slot numbers to the capture names
         */
        internal void AssignNameSlots() {
            if (_capnames != null) {
                for (int i = 0; i < _capnamelist.Count; i++) {
                    while (IsCaptureSlot(_autocap))
                        _autocap++;
                    string name = (string)_capnamelist[i];
                    int pos = (int)_capnames[name];
                    _capnames[name] = _autocap;
                    NoteCaptureSlot(_autocap, pos);

                    _autocap++;
                }
            }

            // if the caps array has at least one gap, construct the list of used slots

            if (_capcount < _captop) {
                _capnumlist = new Object[_capcount];
                int i = 0;

                for (IDictionaryEnumerator de = _caps.GetEnumerator(); de.MoveNext(); )
                    _capnumlist[i++] = de.Key;

                System.Array.Sort(_capnumlist, InvariantComparer.Default);
            }

            // merge capsnumlist into capnamelist

            if (_capnames != null || _capnumlist != null) {
                ArrayList oldcapnamelist;
                int next;
                int k = 0;

                if (_capnames == null) {
                    oldcapnamelist = null;
                    _capnames = new Hashtable();
                    _capnamelist = new ArrayList();
                    next = -1;
                }
                else {
                    oldcapnamelist = _capnamelist;
                    _capnamelist = new ArrayList();
                    next = (int)_capnames[oldcapnamelist[0]];
                }

                for (int i = 0; i < _capcount; i++) {
                    int j = (_capnumlist == null) ? i : (int)_capnumlist[i];

                    if (next == j) {
                        _capnamelist.Add((String)oldcapnamelist[k++]);
                        next = (k == oldcapnamelist.Count) ? -1 : (int)_capnames[oldcapnamelist[k]];
                    }
                    else {
                        String str = Convert.ToString(j);
                        _capnamelist.Add(str);
                        _capnames[str] = j;
                    }
                }
            }
        }

        /*
         * Looks up the slot number for a given name
         */
        internal int CaptureSlotFromName(String capname) {
            return(int)_capnames[capname];
        }

        /*
         * True if the capture slot was noted
         */
        internal bool IsCaptureSlot(int i) {
            if (_caps != null)
                return _caps.ContainsKey(i);

            return(i >= 0 && i < _capsize);
        }

        /*
         * Looks up the slot number for a given name
         */
        internal bool IsCaptureName(String capname) {
            if (_capnames == null)
                return false;

            return _capnames.ContainsKey(capname);
        }

        /*
         * True if N option disabling '(' autocapture is on.
         */
        internal bool UseOptionN() {
            return(_options & RegexOptions.ExplicitCapture) != 0;
        }

        /*
         * True if I option enabling case-insensitivity is on.
         */
        internal bool UseOptionI() {
            return(_options & RegexOptions.IgnoreCase) != 0;
        }

        /*
         * True if M option altering meaning of $ and ^ is on.
         */
        internal bool UseOptionM() {
            return(_options & RegexOptions.Multiline) != 0;
        }

        /*
         * True if S option altering meaning of . is on.
         */
        internal bool UseOptionS() {
            return(_options & RegexOptions.Singleline) != 0;
        }

        /*
         * True if X option enabling whitespace/comment mode is on.
         */
        internal bool UseOptionX() {
            return(_options & RegexOptions.IgnorePatternWhitespace) != 0;
        }

#if ECMA
        /*
         * True if E option enabling ECMAScript behavior is on.
         */
        internal bool UseOptionE() {
            return(_options & RegexOptions.ECMAScript) != 0;
        }
#endif

        internal const byte Q = 5;    // quantifier
        internal const byte S = 4;    // ordinary stoppper
        internal const byte Z = 3;    // ScanBlank stopper
        internal const byte X = 2;    // whitespace
        internal const byte E = 1;    // should be escaped

        /*
         * For categorizing ascii characters.
        */
        internal static readonly byte[] _category = new byte[] {
            // 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F 
               0,0,0,0,0,0,0,0,0,X,X,0,X,X,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            //   ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? 
               X,0,0,Z,S,0,0,0,S,S,Q,Q,0,0,S,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Q,
            // @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,S,S,0,S,0,
            // ' a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ 
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Q,S,0,0,0};

        /*
         * Returns true for those characters that terminate a string of ordinary chars.
         */
        internal static bool IsSpecial(char ch) {
            return(ch <= '|' && _category[ch] >= S);
        }

        /*
         * Returns true for those characters that terminate a string of ordinary chars.
         */
        internal static bool IsStopperX(char ch) {
            return(ch <= '|' && _category[ch] >= X);
        }

        /*
         * Returns true for those characters that begin a quantifier.
         */
        internal static bool IsQuantifier(char ch) {
            return(ch <= '{' && _category[ch] >= Q);
        }

        internal bool IsTrueQuantifier() {
            int nChars = CharsRight();
            if (nChars == 0)
                return false;
            int startpos = Textpos();
            char ch = CharAt(startpos);
            if (ch != '{')
                return ch <= '{' && _category[ch] >= Q;
            int pos = startpos;
            while (--nChars > 0 && (ch = CharAt(++pos)) >= '0' && ch <= '9') ;
            if (nChars == 0 || pos - startpos == 1)
                return false;
            if (ch == '}')
                return true;
            if (ch != ',')
                return false;
            while (--nChars > 0 && (ch = CharAt(++pos)) >= '0' && ch <= '9') ;
            return nChars > 0 && ch == '}';
        }

        /*
         * Returns true for whitespace.
         */
        internal static bool IsSpace(char ch) {
            return(ch <= ' ' && _category[ch] == X);
        }

        /*
         * Returns true for chars that should be escaped.
         */
        internal static bool IsMetachar(char ch) {
            return(ch <= '|' && _category[ch] >= E);
        }


        /*
         * Add a string to the last concatenate.
         */
        internal void AddConcatenate(int pos, int cch, bool isReplacement) {
            RegexNode node;

            if (cch == 0)
                return;

            if (cch > 1) {
                String str = _pattern.Substring(pos, cch);

                if (UseOptionI() && !isReplacement)
                    str = str.ToLower(_culture);

                node = new RegexNode(RegexNode.Multi, _options, str);
            }
            else {
                char ch = _pattern[pos];

                if (UseOptionI() && !isReplacement)
                    ch = Char.ToLower(ch, _culture);

                node = new RegexNode(RegexNode.One, _options, ch);
            }

            _concatenation.AddChild(node);
        }

        /*
         * Push the parser state (in response to an open paren)
         */
        internal void PushGroup() {
            _group._next = _stack;
            _alternation._next = _group;
            _concatenation._next = _alternation;
            _stack = _concatenation;
        }

        /*
         * Remember the pushed state (in response to a ')')
         */
        internal void PopGroup() {
            _concatenation = _stack;
            _alternation = _concatenation._next;
            _group = _alternation._next;
            _stack = _group._next;

            // The first () inside a Testgroup group goes directly to the group
            if (_group.Type() == RegexNode.Testgroup && _group.ChildCount() == 0) {
                if (_unit == null)
                    throw MakeException(SR.GetString(SR.IllegalCondition));

                _group.AddChild(_unit);
                _unit = null;
            }
        }

        /*
         * True if the group stack is empty.
         */
        internal bool EmptyStack() {
            return _stack == null;
        }

        /*
         * Start a new round for the parser state (in response to an open paren or string start)
         */
        internal void StartGroup(RegexNode openGroup) {
            _group = openGroup;
            _alternation = new RegexNode(RegexNode.Alternate, _options);
            _concatenation = new RegexNode(RegexNode.Concatenate, _options);
        }

        /*
         * Finish the current concatenation (in response to a |)
         */
        internal void AddAlternate() {
            // The | parts inside a Testgroup group go directly to the group

            if (_group.Type() == RegexNode.Testgroup || _group.Type() == RegexNode.Testref) {
                _group.AddChild(_concatenation.ReverseLeft());
            }
            else {
                _alternation.AddChild(_concatenation.ReverseLeft());
            }

            _concatenation = new RegexNode(RegexNode.Concatenate, _options);
        }

        /*
         * Finish the current quantifiable (when a quantifier is not found or is not possible)
         */
        internal void AddConcatenate() {
            // The first (| inside a Testgroup group goes directly to the group

            _concatenation.AddChild(_unit);
            _unit = null;
        }

        /*
         * Finish the current quantifiable (when a quantifier is found)
         */
        internal void AddConcatenate(bool lazy, int min, int max) {
            _concatenation.AddChild(_unit.MakeQuantifier(lazy, min, max));
            _unit = null;
        }

        /*
         * Returns the current unit
         */
        internal RegexNode Unit() {
            return _unit;
        }

        /*
         * Sets the current unit to a single char node
         */
        internal void AddUnitOne(char ch) {
            if (UseOptionI())
                ch = Char.ToLower(ch, _culture);

            _unit = new RegexNode(RegexNode.One, _options, ch);
        }

        /*
         * Sets the current unit to a single inverse-char node
         */
        internal void AddUnitNotone(char ch) {
            if (UseOptionI())
                ch = Char.ToLower(ch, _culture);

            _unit = new RegexNode(RegexNode.Notone, _options, ch);
        }

        /*
         * Sets the current unit to a single set node
         */
        internal void AddUnitSet(RegexCharClass cc) {
            _unit = new RegexNode(RegexNode.Set, _options, cc.ToSetCi(UseOptionI(), _culture), cc.Category);
        }

        /*
         * Sets the current unit to a subtree
         */
        internal void AddUnitNode(RegexNode node) {
            _unit = node;
        }

        /*
         * Sets the current unit to an assertion of the specified type
         */
        internal void AddUnitType(int type) {
            _unit = new RegexNode(type, _options);
        }

        /*
         * Finish the current group (in response to a ')' or end)
         */
        internal void AddGroup() {
            if (_group.Type() == RegexNode.Testgroup || _group.Type() == RegexNode.Testref) {
                _group.AddChild(_concatenation.ReverseLeft());

                if (_group.Type() == RegexNode.Testref && _group.ChildCount() > 2 || _group.ChildCount() > 3)
                    throw MakeException(SR.GetString(SR.TooManyAlternates));
            }
            else {
                _alternation.AddChild(_concatenation.ReverseLeft());
                _group.AddChild(_alternation);
            }

            /*  This is code for ASURT 78559
                Also need to set '_group._next = _stack' in StartGroup(RegexNode)
            if (_group.Type() == RegexNode.Capture) {
                RegexNode parent = _group._next;
                while (parent != null) {
                    if (parent.Type() == RegexNode.Capture) 
                        parent.AddToCaptureList(_group);
                    parent = parent._next;
                }
            }
            */
            
            _unit = _group;
        }

        /*
         * Saves options on a stack.
         */
        internal void PushOptions() {
            _optionsStack.Add(_options);
        }

        /*
         * Recalls options from the stack.
         */
        internal void PopOptions() {
            _options = (RegexOptions) _optionsStack[_optionsStack.Count - 1];
            _optionsStack.RemoveAt(_optionsStack.Count - 1);
        }

        /*
         * True if options stack is empty.
         */
        internal bool EmptyOptionsStack() {
            return(_optionsStack.Count == 0);
        }

        /*
         * Pops the option stack, but keeps the current options unchanged.
         */
        internal void PopKeepOptions() {
            _optionsStack.RemoveAt(_optionsStack.Count - 1);
        }

        /*
         * Fills in an ArgumentException
         */
        internal ArgumentException MakeException(String message) {
            return new ArgumentException(SR.GetString(SR.MakeException, _pattern, message), _pattern);
        }

        /*
         * Returns the current parsing position.
         */
        internal int Textpos() {
            return _currentPos;
        }

        /*
         * Zaps to a specific parsing position.
         */
        internal void Textto(int pos) {
            _currentPos = pos;
        }

        /*
         * Returns the char at the right of the current parsing position and advances to the right.
         */
        internal char RightCharNext() {
            return _pattern[_currentPos++];
        }

        /*
         * Returns the char at the right of the current parsing position and advances to the right.
         */
        internal char RightNext() {
            return _pattern[_currentPos++];
        }

        /*
         * Moves the current parsing position one to the left.
         */
        internal void LeftNext() {
            --_currentPos;
        }

        /*
         * Returns the char left of the current parsing position.
         */
        internal char CharAt(int i) {
            return _pattern[i];
        }

        /*
         * Returns the char right of the current parsing position.
         */
        internal char RightChar() {
            return _pattern[_currentPos];
        }

        /*
         * Returns the char i chars right of the current parsing position.
         */
        internal char RightChar(int i) {
            return _pattern[_currentPos + i];
        }

        /*
         * Number of characters to the right of the current parsing position.
         */
        internal int CharsRight() {
            return _pattern.Length - _currentPos;
        }

        /*
         * Number of characters to the left of the current parsing position.
         */
        //internal int CharsLeft() {
        //    return _currentPos;
        //}

        /*
         * Returns the char left of the current parsing position.
         */
        //internal char LeftChar() {
        //    return _pattern[_currentPos - 1];
        //}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexmatchcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexMatchCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The MatchCollection lists the successful matches that
 * result when searching a string for a regular expression.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *  6/01/99 (dbau)      First draft
 */

namespace System.Text.RegularExpressions {

    using System.Collections;


    /*
     * This collection returns a sequence of successful match results, either
     * from GetMatchCollection() or GetExecuteCollection(). It stops when the
     * first failure is encountered (it does not return the failed match).
     */
    /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the set of names appearing as capturing group
    ///       names in a regular expression.
    ///    </para>
    /// </devdoc>
    [ Serializable() ] 
    public class MatchCollection : ICollection {
        internal Regex _regex;
        internal ArrayList _matches;
        internal bool _done;
        internal String _input;
        internal int _beginning;
        internal int _length;
        internal int _startat;
        internal int _prevlen;

        private static int infinite = 0x7FFFFFFF;

        /*
         * Nonpublic constructor
         */
        internal MatchCollection(Regex regex, String input, int beginning, int length, int startat) {
            if (startat < 0 || startat > input.Length)
                throw new ArgumentOutOfRangeException("startat", SR.GetString(SR.BeginIndexNotNegative));

            _regex = regex;
            _input = input;
            _beginning = beginning;
            _length = length;
            _startat = startat;
            _prevlen = -1;
            _matches = new ArrayList();
            _done = false;
        }

        internal Match GetMatch(int i) {
            if (i < 0)
                return null;

            if (_matches.Count > i)
                return(Match)_matches[i];

            if (_done)
                return null;

            Match match;

            do {
                match = _regex.Run(false, _prevlen, _input, _beginning, _length, _startat);

                if (!match.Success) {
                    _done = true;
                    return null;
                }

                _matches.Add(match);

                _prevlen = match._length;
                _startat = match._textpos;

            } while (_matches.Count <= i);

            return match;
        }

        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the number of captures.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                if (_done)
                    return _matches.Count;

                GetMatch(infinite);

                return _matches.Count;
            }
        }

        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return true;
            }
        }


        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the ith Match in the collection.
        ///    </para>
        /// </devdoc>
        public virtual Match this[int i]
        {
            get {
                Match match;

                match = GetMatch(i);

                if (match == null)
                    throw new ArgumentOutOfRangeException("i");

                return match;
            }
        }

        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies all the elements of the collection to the given array
        ///       starting at the given index.
        ///    </para>
        /// </devdoc>
        public void CopyTo(Array array, int arrayIndex) {
            // property access to force computation of whole array
            int count = Count;

            _matches.CopyTo(array, arrayIndex);
        }

        /// <include file='doc\RegexMatchCollection.uex' path='docs/doc[@for="MatchCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides an enumerator in the same order as Item[i].
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new MatchEnumerator(this);
        }
    }

    /*
     * This non-public enumerator lists all the group matches.
     * Should it be public?
     */
    [ Serializable() ] 
    internal class MatchEnumerator : IEnumerator {
        internal MatchCollection _matchcoll;
        internal Match _match = null;
        internal int _curindex;
        internal bool _done;

        /*
         * Nonpublic constructor
         */
        internal MatchEnumerator(MatchCollection matchcoll) {
            _matchcoll = matchcoll;
        }

        /*
         * Advance to the next match
         */
        public bool MoveNext() {
            if (_done)
                return false;

            _match = _matchcoll.GetMatch(_curindex++);

            if (_match == null) {
                _done = true;
                return false;
            }

            return true;
        }

        /*
         * The current match
         */
        public Object Current {
            get { 
                if (_match == null)
                    throw new InvalidOperationException(SR.GetString(SR.EnumNotStarted));
                return _match;
            }
        }

        /*
         * The current match
         */
        public Match Match {
            get {
                return _match;
            }
        }

        /*
         * Position before the first item
         */
        public void Reset() {
            _curindex = 0;
        }
    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexrunner.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexRunner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexRunner class is a base class for compiled regex code.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/28/99 (dbau)      First draft
 *      5/11/99 (dbau)      Split interpreter out to RegexInterpreter
 *                          now used as base class for generated type
 */

/*
 * Implementation notes:
 * 
 * RegexRunner provides a common calling convention and a common
 * runtime environment for the interpreter and the compiled code.
 *
 * It provides the driver code that call's the subclass's Go()
 * method for either scanning or direct execution.
 *
 * It also maintains memory allocation for the backtracking stack,
 * the grouping stack and the longjump crawlstack, and provides
 * methods to push new subpattern match results into (or remove
 * backtracked results from) the Match instance.
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner"]/*' />
    /// <internalonly/>
    [ EditorBrowsable(EditorBrowsableState.Never) ]
    abstract public class RegexRunner {
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtextbeg"]/*' />
        protected internal int runtextbeg;         // beginning of text to search
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtextend"]/*' />
        protected internal int runtextend;         // end of text to search
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtextstart"]/*' />
        protected internal int runtextstart;       // starting point for search

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtext"]/*' />
        protected internal String runtext;         // text to search
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtextpos"]/*' />
        protected internal int runtextpos;         // current position in text

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtrack"]/*' />
        protected internal int [] runtrack;        // backtracking stack
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtrackpos"]/*' />
        protected internal int runtrackpos;        // current position in backtracking stack

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runstack"]/*' />
        protected internal int [] runstack;        // ordinary stack
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runstackpos"]/*' />
        protected internal int runstackpos;        // current position in ordinary stack

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runcrawl"]/*' />
        protected internal int [] runcrawl;        // longjump crawl stack
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runcrawlpos"]/*' />
        protected internal int runcrawlpos;        // current position in crawl stack

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runtrackcount"]/*' />
        protected internal int runtrackcount;      // count of states that may do backtracking

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runmatch"]/*' />
        protected internal Match runmatch;         // result object
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.runregex"]/*' />
        protected internal Regex runregex;         // regex object

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.RegexRunner"]/*' />
        protected internal RegexRunner() {}

        /*
         * Scans the string to find the first match. Uses the Match object
         * both to feed text in and as a place to store matches that come out.
         *
         * All the action is in the abstract Go() method defined by subclasses. Our
         * responsibility is to load up the class members (as done here) before
         * calling Go.
         *
         * CONSIDER: the optimizer can compute a set of candidate starting characters,
         * and we should have a separate method Skip() that will quickly scan past
         * any characters that we know can't match.
         *
         * CONSIDER: we should be aware of ^ or .* anchored searches and not iterate.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Scan"]/*' />
        protected internal Match Scan(Regex regex, String text, int textbeg, int textend, int textstart, int prevlen, bool quick) {
            int bump;
            int stoppos;
            bool initted = false;

            runregex      = regex;
            runtext       = text;
            runtextbeg    = textbeg;
            runtextend    = textend;
            runtextstart  = textstart;

            bump    = runregex.RightToLeft ? -1 : 1;
            stoppos = runregex.RightToLeft ? runtextbeg : runtextend;

            runtextpos    = textstart;

            // If previous match was empty or failed, advance by one before matching

            if (prevlen == 0) {
                if (runtextpos == stoppos)
                    return Match.Empty;

                runtextpos += bump;
            }

            for (;;) {
#if DBG
                if (runregex.Debug) {
                    Debug.WriteLine("");
                    Debug.WriteLine("Search range: from " + runtextbeg.ToString() + " to " + runtextend.ToString());
                    Debug.WriteLine("Firstchar search starting at " + runtextpos.ToString() + " stopping at " + stoppos.ToString());
                }
#endif
                if (FindFirstChar()) {
                    if (!initted) {
                        InitMatch();
                        initted = true;
                    }
#if DBG
                    if (runregex.Debug) {
                        Debug.WriteLine("Executing engine starting at " + runtextpos.ToString());
                        Debug.WriteLine("");
                    }
#endif
                    Go();

                    if (runmatch._matchcount[0] > 0) {
                        // CONSIDER: Friedl's pp.249-250 seems to disagree with Perl 5 -
                        // we'll return a match even if it touches a previous empty match
                        return TidyMatch(quick);
                    }

                    // reset state for another go
                    runtrackpos = runtrack.Length;
                    runstackpos = runstack.Length;
                    runcrawlpos = runcrawl.Length;
                }

                // failure!

                if (runtextpos == stoppos) {
                    TidyMatch(true);
                    return Match.Empty;
                }

                // CONSIDER: recognize leading []* and various anchors, and bump on failure accordingly

                // Bump by one and start again

                runtextpos += bump;
            }

        }

        /*
         * The responsibility of Go() is to run the regular expression at
         * runtextpos and call Capture() on all the captured subexpressions,
         * then to leave runtextpos at the ending position. It should leave
         * runtextpos where it started if there was no match.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Go"]/*' />
        protected abstract void Go();

        /*
         * The responsibility of FindFirstChar() is to advance runtextpos
         * until it is at the next position which is a candidate for the
         * beginning of a successful match.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.FindFirstChar"]/*' />
        protected abstract bool FindFirstChar();

        /*
         * InitTrackCount must initialize the runtrackcount field; this is
         * used to know how large the initial runtrack and runstack arrays
         * must be.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.InitTrackCount"]/*' />
        protected abstract void InitTrackCount();

        /*
         * Initializes all the data members that are used by Go()
         */
        private void InitMatch() {
            // Use a hashtable'ed Match object if the capture numbers are sparse

            if (runmatch == null) {
                if (runregex.caps != null)
                    runmatch = new MatchSparse(runregex, runregex.caps, runregex.capsize, runtext, runtextbeg, runtextend - runtextbeg, runtextstart);
                else
                    runmatch = new Match(runregex, runregex.capsize, runtext, runtextbeg, runtextend - runtextbeg, runtextstart);
            }
            else {
                runmatch.Reset(runregex, runtext, runtextbeg, runtextend, runtextstart);
            }

            // note we test runcrawl, because it is the last one to be allocated
            // If there is an alloc failure in the middle of the three allocations,
            // we may still return to reuse this instance, and we want to behave
            // as if the allocations didn't occur. (we used to test _trackcount != 0)

            if (runcrawl != null) {
                runtrackpos = runtrack.Length;
                runstackpos = runstack.Length;
                runcrawlpos = runcrawl.Length;
                return;
            }

            InitTrackCount();

            int tracksize = runtrackcount * 8;
            int stacksize = runtrackcount * 8;

            if (tracksize < 32)
                tracksize = 32;
            if (stacksize < 16)
                stacksize = 16;

            runtrack = new int[tracksize];
            runtrackpos = tracksize;

            runstack = new int[stacksize];
            runstackpos = stacksize;

            runcrawl = new int[32];
            runcrawlpos = 32;
        }

        /*
         * Put match in its canonical form before returning it.
         */
        private Match TidyMatch(bool quick) {
            if (!quick) {
                Match match = runmatch;

                runmatch = null;

                match.Tidy(runtextpos);
                return match;
            }
            else {
                // in quick mode, a successful match returns null, and
                // the allocated match object is left in the cache

                return null;
            }
        }

        /*
         * Called by the implemenation of Go() to increase the size of storage
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.EnsureStorage"]/*' />
        protected void EnsureStorage() {
            if (runstackpos < runtrackcount * 4)
                DoubleStack();
            if (runtrackpos < runtrackcount * 4)
                DoubleTrack();
        }

        /*
         * Called by the implemenation of Go() to decide whether the pos
         * at the specified index is a boundary or not. It's just not worth
         * emitting inline code for this logic.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.IsBoundary"]/*' />
        protected bool IsBoundary(int index, int startpos, int endpos) {
            return (index > startpos && RegexCharClass.IsWordChar(runtext[index - 1])) !=
                   (index < endpos && RegexCharClass.IsWordChar(runtext[index]));
        }

#if ECMA
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.IsECMABoundary"]/*' />
        protected bool IsECMABoundary(int index, int startpos, int endpos) {
            return (index > startpos && RegexCharClass.IsECMAWordChar(runtext[index - 1])) !=
                   (index < endpos && RegexCharClass.IsECMAWordChar(runtext[index]));
        }
#endif

        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.CharInSet"]/*' />
        protected static bool CharInSet(char ch, String set, String category) {
            return RegexCharClass.CharInSet(ch, set, category);
        }

        /*
         * Called by the implemenation of Go() to increase the size of the
         * backtracking stack.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.DoubleTrack"]/*' />
        protected void DoubleTrack() {
            int[] newtrack;

            newtrack = new int[runtrack.Length * 2];

            System.Array.Copy(runtrack, 0, newtrack, runtrack.Length, runtrack.Length);
            runtrackpos += runtrack.Length;
            runtrack = newtrack;
        }

        /*
         * Called by the implemenation of Go() to increase the size of the
         * grouping stack.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.DoubleStack"]/*' />
        protected void DoubleStack() {
            int[] newstack;

            newstack = new int[runstack.Length * 2];

            System.Array.Copy(runstack, 0, newstack, runstack.Length, runstack.Length);
            runstackpos += runstack.Length;
            runstack = newstack;
        }

        /*
         * Increases the size of the longjump unrolling stack.
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.DoubleCrawl"]/*' />
        protected void DoubleCrawl() {
            int[] newcrawl;

            newcrawl = new int[runcrawl.Length * 2];

            System.Array.Copy(runcrawl, 0, newcrawl, runcrawl.Length, runcrawl.Length);
            runcrawlpos += runcrawl.Length;
            runcrawl = newcrawl;
        }

        /*
         * Save a number on the longjump unrolling stack
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Crawl"]/*' />
        protected void Crawl(int i) {
            if (runcrawlpos == 0)
                DoubleCrawl();

            runcrawl[--runcrawlpos] = i;
        }

        /*
         * Remove a number from the longjump unrolling stack
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Popcrawl"]/*' />
        protected int Popcrawl() {
            return runcrawl[runcrawlpos++];
        }

        /*
         * Get the height of the stack
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Crawlpos"]/*' />
        protected int Crawlpos() {
            return runcrawl.Length - runcrawlpos;
        }

        /*
         * Called by Go() to capture a subexpression. Note that the
         * capnum used here has already been mapped to a non-sparse
         * index (by the code generator RegexWriter).
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Capture"]/*' />
        protected void Capture(int capnum, int start, int end) {
            if (end < start) {
                int T;

                T = end;
                end = start;
                start = T;
            }

            Crawl(capnum);
            runmatch.AddMatch(capnum, start, end - start);
        }

        /*
         * Called by Go() to capture a subexpression. Note that the
         * capnum used here has already been mapped to a non-sparse
         * index (by the code generator RegexWriter).
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.TransferCapture"]/*' />
        protected void TransferCapture(int capnum, int uncapnum, int start, int end) {
            int start2;
            int end2;

            // these are the two intervals that are cancelling each other

            if (end < start) {
                int T;

                T = end;
                end = start;
                start = T;
            }

            start2 = MatchIndex(uncapnum);
            end2 = start2 + MatchLength(uncapnum);

            // The new capture gets the innermost defined interval

            if (start >= end2) {
                end = start;
                start = end2;
            }
            else if (end <= start2) {
                start = start2;
            }
            else {
                if (end > end2)
                    end = end2;
                if (start2 > start)
                    start = start2;
            }

            Crawl(uncapnum);
            runmatch.BalanceMatch(uncapnum);

            if (capnum != -1) {
                Crawl(capnum);
                runmatch.AddMatch(capnum, start, end - start);
            }
        }

        /*
         * Called by Go() to revert the last capture
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.Uncapture"]/*' />
        protected void Uncapture() {
            int capnum = Popcrawl();
            runmatch.RemoveMatch(capnum);
        }

        /*
         * Call out to runmatch to get around visibility issues
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.IsMatched"]/*' />
        protected bool IsMatched(int cap) {
            return runmatch.IsMatched(cap);
        }

        /*
         * Call out to runmatch to get around visibility issues
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.MatchIndex"]/*' />
        protected int MatchIndex(int cap) {
            return runmatch.MatchIndex(cap);
        }

        /*
         * Call out to runmatch to get around visibility issues
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.MatchLength"]/*' />
        protected int MatchLength(int cap) {
            return runmatch.MatchLength(cap);
        }

#if DBG
        /*
         * Dump the current state
         */
        /// <include file='doc\RegexRunner.uex' path='docs/doc[@for="RegexRunner.DumpState"]/*' />
        public virtual void DumpState() {
            Debug.WriteLine("Text:  " + TextposDescription());
            Debug.WriteLine("Track: " + StackDescription(runtrack, runtrackpos));
            Debug.WriteLine("Stack: " + StackDescription(runstack, runstackpos));
        }

        internal static String StackDescription(int[] A, int Index) {
            StringBuilder Sb = new StringBuilder();

            Sb.Append(A.Length - Index);
            Sb.Append('/');
            Sb.Append(A.Length);

            if (Sb.Length < 8)
                Sb.Append(' ',8 - Sb.Length);

            Sb.Append("(");

            for (int i = Index; i < A.Length; i++) {
                if (i > Index)
                    Sb.Append(' ');
                Sb.Append(A[i]);
            }

            Sb.Append(')');

            return Sb.ToString();
        }

        internal virtual String TextposDescription() {
            StringBuilder Sb = new StringBuilder();
            int remaining;

            Sb.Append(runtextpos);

            if (Sb.Length < 8)
                Sb.Append(' ',8 - Sb.Length);

            if (runtextpos > runtextbeg)
                Sb.Append(RegexCharClass.CharDescription(runtext[runtextpos - 1]));
            else
                Sb.Append('^');

            Sb.Append('>');

            remaining = runtextend - runtextpos;

            for (int i = runtextpos; i < runtextend; i++) {
                Sb.Append(RegexCharClass.CharDescription(runtext[i]));
            }
            if (Sb.Length >= 64) {
                Sb.Length = 61;
                Sb.Append("...");
            }
            else {
                Sb.Append('$');
            }

            return Sb.ToString();
        }
#endif
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regextree.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexTree.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * RegexTree is just a wrapper for a node tree with some
 * global information attached.
 *
 * Revision history
 *      5/04/99 (dbau)      First draft
 *
 */

namespace System.Text.RegularExpressions {

    using System.Collections;

    internal sealed class RegexTree {
        internal RegexTree(RegexNode root, Hashtable caps, Object[] capnumlist, int captop, Hashtable capnames, String[] capslist, RegexOptions opts) {
            _root = root;
            _caps = caps;
            _capnumlist = capnumlist;
            _capnames = capnames;
            _capslist = capslist;
            _captop = captop;
            _options = opts;
        }

        internal RegexNode _root;
        internal Hashtable _caps;
        internal Object[]  _capnumlist;
        internal Hashtable _capnames;
        internal String[]  _capslist;
        internal RegexOptions _options;
        internal int       _captop;

#if DBG
        internal void Dump() {
            _root.Dump();
        }

        internal bool Debug {
            get {
                return(_options & RegexOptions.Debug) != 0;
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexrunnerfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexRunnerFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexRunnerFactory class is a base class for compiled regex code.
 * we need to compile a factory because Type.CreateInstance is much slower
 * than calling the constructor directly.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      6/02/99     (dbau)  First draft
 */

namespace System.Text.RegularExpressions {

    using System.ComponentModel;
    
    /// <include file='doc\RegexRunnerFactory.uex' path='docs/doc[@for="RegexRunnerFactory"]/*' />
    /// <internalonly/>
    [ EditorBrowsable(EditorBrowsableState.Never) ]
    abstract public class RegexRunnerFactory {
        /// <include file='doc\RegexRunnerFactory.uex' path='docs/doc[@for="RegexRunnerFactory.RegexRunnerFactory"]/*' />
        protected RegexRunnerFactory() {}
        /// <include file='doc\RegexRunnerFactory.uex' path='docs/doc[@for="RegexRunnerFactory.CreateInstance"]/*' />
        abstract protected internal RegexRunner CreateInstance();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\installutil\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\installutillib\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexreplacement.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexReplacement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * The RegexReplacement class represents a substitution string for
 * use when using regexs to search/replace, etc. It's logically
 * a sequence intermixed (1) constant strings and (2) group numbers.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *  6/24/99 (dbau)      First go at replacements
 */

namespace System.Text.RegularExpressions {

    using System.Collections;

    internal sealed class RegexReplacement {
        /*
         * Since RegexReplacement shares the same parser as Regex,
         * the constructor takes a RegexNode which is a concatenation
         * of constant strings and backreferences.
         */
        internal RegexReplacement(String rep, RegexNode concat, Hashtable _caps) {
            StringBuilder sb;
            ArrayList strings;
            ArrayList rules;
            int slot;

            _rep = rep;

            if (concat.Type() != RegexNode.Concatenate)
                throw new ArgumentException(SR.GetString(SR.ReplacementError));

            sb = new StringBuilder();
            strings = new ArrayList();
            rules = new ArrayList();

            for (int i = 0; i < concat.ChildCount(); i++) {
                RegexNode child = concat.Child(i);

                switch (child.Type()) {
                    case RegexNode.Multi:
                        sb.Append(child._str);
                        break;
                    case RegexNode.One:
                        sb.Append(child._ch);
                        break;
                    case RegexNode.Ref:
                        if (sb.Length > 0) {
                            rules.Add(strings.Count);
                            strings.Add(sb.ToString());
                            sb.Length = 0;
                        }
                        slot = child._m;

                        if (_caps != null && slot >= 0)
                            slot = (int)_caps[slot];

                        rules.Add(-Specials - 1 - slot);
                        break;
                    default:
                        throw new ArgumentException(SR.GetString(SR.ReplacementError));
                }
            }

            if (sb.Length > 0) {
                rules.Add(strings.Count);
                strings.Add(sb.ToString());
            }

            _strings = strings; 
            _rules = rules; 
        }

        internal String _rep;
        internal ArrayList  _strings;          // table of string constants
        internal ArrayList  _rules;            // negative -> group #, positive -> string #

        // constants for special insertion patterns

        internal const int Specials       = 4;
        internal const int LeftPortion    = -1;
        internal const int RightPortion   = -2;
        internal const int LastGroup      = -3;
        internal const int WholeString    = -4;

        /*
        
         * Given a Match, emits into the StringBuilder the evaluated
         * substitution pattern.
         */
        private void ReplacementImpl(StringBuilder sb, Match match) {
            for (int i = 0; i < _rules.Count; i++) {
                int r = (int) _rules[i];
                if (r >= 0)
                    sb.Append((string) _strings[r]);
                else if (r < -Specials)
                    sb.Append(match.GroupToStringImpl(-Specials - 1 - r));
                else {
                    switch (-Specials - 1 - r) {
                        case LeftPortion:
                            sb.Append(match.GetLeftSubstring());
                            break;
                        case RightPortion:
                            sb.Append(match.GetRightSubstring());
                            break;
                        case LastGroup:
                            sb.Append(match.LastGroupToStringImpl());
                            break;
                        case WholeString:
                            sb.Append(match.GetOriginalString());
                            break;
                    }
                }
            }
        }

        /*
         * The original pattern string
         */
        internal String Pattern {
            get {
                return _rep;
            }
        }

        /*
         * Returns the replacement result for a single match
         */
        internal String Replacement(Match match) {
            StringBuilder sb = new StringBuilder();

            ReplacementImpl(sb, match);

            return sb.ToString();
        }

        /*
         * Three very similar algorithms appear below: replace (pattern),
         * replace (evaluator), and split.
         */


        /*
         * Replaces all ocurrances of the regex in the string with the
         * replacement pattern.
         *
         * Note that the special case of no matches is handled on its own:
         * with no matches, the input string is returned unchanged.
         * The right-to-left case is split out because StringBuilder
         * doesn't handle right-to-left string building directly very well.
         */
        internal String Replace(Regex regex, String input, int count, int startat) {
            Match match;

            if (count < -1)
                throw new ArgumentOutOfRangeException("count", SR.GetString(SR.CountTooSmall));
            if (startat < 0 || startat > input.Length) 
                throw new ArgumentOutOfRangeException("startat", SR.GetString(SR.BeginIndexNotNegative));

            if (count == 0)
                return input;

            match = regex.Match(input, startat);
            if (!match.Success) {
                return input;
            }
            else {
                StringBuilder sb;

                if (!regex.RightToLeft) {
                    sb = new StringBuilder();
                    int prevat = 0;

                    do {
                        if (match.Index != prevat)
                            sb.Append(input, prevat, match.Index - prevat);

                        prevat = match.Index + match.Length;
                        ReplacementImpl(sb, match);
                        if (--count == 0)
                            break;

                        match = match.NextMatch();
                    } while (match.Success);

                    if (prevat < input.Length)
                        sb.Append(input, prevat, input.Length - prevat);
                }
                else {
                    ArrayList al = new ArrayList();
                    int prevat = input.Length;

                    do {
                        if (match.Index + match.Length != prevat)
                            al.Add(input.Substring(match.Index + match.Length, prevat - match.Index - match.Length));

                        prevat = match.Index;

                        for (int i = _rules.Count - 1; i >= 0; i--) {
                            int r = (int) _rules[i];
                            if (r >= 0)
                                al.Add((string) _strings[r]);
                            else
                                al.Add(match.GroupToStringImpl(-Specials - 1 - r));
                        }

                        if (--count == 0)
                            break;

                        match = match.NextMatch();
                    } while (match.Success);

                    sb = new StringBuilder();

                    if (prevat > 0)
                        sb.Append(input, 0, prevat);

                    for (int i = al.Count - 1; i >= 0; i--) {
                        sb.Append((String)al[i]);
                    }
                }

                return sb.ToString();
            }
        }

        /*
         * Replaces all ocurrances of the regex in the string with the
         * replacement evaluator.
         *
         * Note that the special case of no matches is handled on its own:
         * with no matches, the input string is returned unchanged.
         * The right-to-left case is split out because StringBuilder
         * doesn't handle right-to-left string building directly very well.
         */
        internal static String Replace(MatchEvaluator evaluator, Regex regex,
                                       String input, int count, int startat) {
            Match match;

            if (evaluator == null)
                throw new ArgumentNullException("evaluator");
            if (count < -1)
                throw new ArgumentOutOfRangeException("count", SR.GetString(SR.CountTooSmall));
            if (startat < 0 || startat > input.Length)
                throw new ArgumentOutOfRangeException("startat", SR.GetString(SR.BeginIndexNotNegative));

            if (count == 0)
                return input;

            match = regex.Match(input, startat);

            if (!match.Success) {
                return input;
            }
            else {
                StringBuilder sb;

                if (!regex.RightToLeft) {
                    sb = new StringBuilder();
                    int prevat = 0;

                    do {
                        if (match.Index != prevat)
                            sb.Append(input, prevat, match.Index - prevat);

                        prevat = match.Index + match.Length;

                        sb.Append(evaluator(match));

                        if (--count == 0)
                            break;

                        match = match.NextMatch();
                    } while (match.Success);

                    if (prevat < input.Length)
                        sb.Append(input, prevat, input.Length - prevat);
                }
                else {
                    ArrayList al = new ArrayList();
                    int prevat = input.Length;

                    do {
                        if (match.Index + match.Length != prevat)
                            al.Add(input.Substring(match.Index + match.Length, prevat - match.Index - match.Length));

                        prevat = match.Index;

                        al.Add(evaluator(match));

                        if (--count == 0)
                            break;

                        match = match.NextMatch();
                    } while (match.Success);

                    sb = new StringBuilder();

                    if (prevat > 0)
                        sb.Append(input, 0, prevat);

                    for (int i = al.Count - 1; i >= 0; i--) {
                        sb.Append((String)al[i]);
                    }
                }

                return sb.ToString();
            }
        }

        /*
         * Does a split. In the right-to-left case we reorder the
         * array to be forwards.
         */
        internal static String[] Split(Regex regex, String input, int count, int startat) {
            Match match;
            String[] result;

            if (count < 0)
                throw new ArgumentOutOfRangeException("count", SR.GetString(SR.CountTooSmall));

            if (startat < 0 || startat > input.Length) 
                throw new ArgumentOutOfRangeException("startat", SR.GetString(SR.BeginIndexNotNegative));
                
            if (count == 1) {
                result = new String[1];
                result[0] = input;
                return result;
            }

            count -= 1;

            match = regex.Match(input, startat);

            if (!match.Success) {
                result = new String[1];
                result[0] = input;
                return result;
            }
            else {
                ArrayList al = new ArrayList();

                if (!regex.RightToLeft) {
                    int prevat = 0;

                    for (;;) {
                        al.Add(input.Substring(prevat, match.Index - prevat));

                        prevat = match.Index + match.Length;
                        
                        // add all matched capture groups to the list.
                        int i = 1;
                        while (match.IsMatched(i)) {
                            al.Add(match.Groups[i].ToString());
                            i++;
                        }

                        if (--count == 0)
                            break;

                        match = match.NextMatch();

                        if (!match.Success)
                            break;
                    }

                    al.Add(input.Substring(prevat, input.Length - prevat));
                }
                else {
                    int prevat = input.Length;

                    for (;;) {
                        al.Add(input.Substring(match.Index + match.Length, prevat - match.Index - match.Length));

                        prevat = match.Index;

                        if (--count == 0)
                            break;

                        match = match.NextMatch();

                        if (!match.Success)
                            break;
                    }

                    al.Add(input.Substring(0, prevat));

                    al.Reverse(0, al.Count);
                }

                return(String[])al.ToArray(typeof(String));
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\licensecompiler\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\regex\system\text\regularexpressions\regexwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * This RegexWriter class is internal to the Regex package.
 * It builds a block of regular expression codes (RegexCode)
 * from a RegexTree parse tree.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Revision history
 *      4/26/99 (dbau)      First draft
 *      5/11/99 (dbau)      Added comments
 */

/*
 * Implementation notes:
 * 
 * This step is as simple as walking the tree and emitting
 * sequences of codes.
 *
 * CONSIDER: perhaps we should generate MSIL directly from a tree walk?
 */
#define ECMA

namespace System.Text.RegularExpressions {

    using System.Collections;
    using System.Collections.Specialized;
    using System.Globalization;
    
    internal sealed class RegexWriter {
        internal int[]       _intStack;
        internal int         _depth;
        internal int[]       _emitted;
        internal int         _curpos;
        internal IDictionary   _stringhash;
        internal ArrayList   _stringtable;
        // not used! internal int         _stringcount;
        internal bool     _counting;
        internal int         _count;
        internal int         _trackcount;
        internal Hashtable   _caps;

        internal const int BeforeChild = 64;
        internal const int AfterChild = 128;
        internal const int infinite = RegexCode.infinite;

        /*
         * This is the only function that should be called from outside.
         * It takes a RegexTree and creates a corresponding RegexCode.
         */
        internal static RegexCode Write(RegexTree t) {
            RegexWriter w = new RegexWriter();
            RegexCode retval = w.RegexCodeFromRegexTree(t);
#if DBG
            if (t.Debug) {
                retval.Dump();
            }
#endif
            return retval;
        }

        /*
         * private constructor; can't be created outside
         */
        private RegexWriter() {
            _intStack = new int[32];
            _emitted = new int[32];
            _stringhash = new HybridDictionary();
            _stringtable = new ArrayList();
        }

        /*
         * To avoid recursion, we use a simple integer stack.
         * This is the push.
         */
        internal void PushInt(int I) {
            if (_depth >= _intStack.Length) {
                int [] expanded = new int[_depth * 2];

                System.Array.Copy(_intStack, 0, expanded, 0, _depth);

                _intStack = expanded;
            }

            _intStack[_depth++] = I;
        }

        /*
         * True if the stack is empty.
         */
        internal bool EmptyStack() {
            return _depth == 0;
        }

        /*
         * This is the pop.
         */
        internal int PopInt() {
            return _intStack[--_depth];
        }

        /*
         * Returns the current position in the emitted code.
         */
        internal int CurPos() {
            return _curpos;
        }

        /*
         * Fixes up a jump instruction at the specified offset
         * so that it jumps to the specified jumpDest.
         */
        internal void PatchJump(int Offset, int jumpDest) {
            _emitted[Offset + 1] = jumpDest;
        }

        /*
         * Emits a zero-argument operation. Note that the emit
         * functions all run in two modes: they can emit code, or
         * they can just count the size of the code.
         */
        internal void Emit(int op) {
            if (_counting) {
                _count += 1;
                if (RegexCode.OpcodeBacktracks(op))
                    _trackcount += 1;
                return;
            }
            _emitted[_curpos++] = op;
        }

        /*
         * Emits a one-argument operation.
         */
        internal void Emit(int op, int opd1) {
            if (_counting) {
                _count += 2;
                if (RegexCode.OpcodeBacktracks(op))
                    _trackcount += 1;
                return;
            }
            _emitted[_curpos++] = op;
            _emitted[_curpos++] = opd1;
        }

        /*
         * Emits a two-argument operation.
         */
        internal void Emit(int op, int opd1, int opd2) {
            if (_counting) {
                _count += 3;
                if (RegexCode.OpcodeBacktracks(op))
                    _trackcount += 1;
                return;
            }
            _emitted[_curpos++] = op;
            _emitted[_curpos++] = opd1;
            _emitted[_curpos++] = opd2;
        }

        /*
         * Emits a three-argument operation.
         */
        internal void Emit(int op, int opd1, int opd2, int opd3) {
            if (_counting) {
                _count += 4;
                if (RegexCode.OpcodeBacktracks(op))
                    _trackcount += 1;
                return;
            }
            _emitted[_curpos++] = op;
            _emitted[_curpos++] = opd1;
            _emitted[_curpos++] = opd2;
            _emitted[_curpos++] = opd3;
        }

        /*
         * Returns an index in the string table for a string;
         * uses a hashtable to eliminate duplicates.
         */
        internal int StringCode(String str) {
            Int32 i;

            if (_counting)
                return 0;

            if (str == null)
                str = String.Empty;
            
            if (_stringhash.Contains(str)) {
                i = (Int32)_stringhash[str];
            }
            else {
                i = _stringtable.Count;
                _stringhash[str] = i;
                _stringtable.Add(str);
            }

            return i;
        }

        /*
         * Just returns an exception; should be dead code
         */
        internal ArgumentException MakeException(String message) {
            return new ArgumentException(message);
        }

        /*  This is code for ASURT 78559
            Use this in EmitFragment, 'case RegexNode.Capture | AfterChild' when we emit the string
        internal string MapGroupString(string groupstring) {
            if (groupstring == null)
                return null;
            
            char[] ret = new char[groupstring.Length];

            for (int i=0; i<groupstring.Length; i++) 
                ret[i] = (char) MapCapnum((int) groupstring[i]);

            return new String(ret);
        }
        */
        
        /*
         * When generating code on a regex that uses a sparse set
         * of capture slots, we hash them to a dense set of indices
         * for an array of capture slots. Instead of doing the hash
         * at match time, it's done at compile time, here.
         */
        internal int MapCapnum(int capnum) {
            if (capnum == -1)
                return -1;

            if (_caps != null)
                return(Int32)_caps[capnum];
            else
                return capnum;
        }

        /*
         * The top level RegexCode generator. It does a depth-first walk
         * through the tree and calls EmitFragment to emits code before
         * and after each child of an interior node, and at each leaf.
         *
         * It runs two passes, first to count the size of the generated
         * code, and second to generate the code.
         *
         * CONSIDER: we need to time it against the alternative, which is
         * to just generate the code and grow the array as we go.
         */
        internal RegexCode RegexCodeFromRegexTree(RegexTree tree) {
            RegexNode curNode;
            int curChild;
            int capsize;
            RegexPrefix fcPrefix;
            RegexPrefix scPrefix;
            RegexPrefix prefix;
            int anchors;
            RegexBoyerMoore bmPrefix;
            bool rtl;

            // construct sparse capnum mapping if some numbers are unused

            if (tree._capnumlist == null || tree._captop == tree._capnumlist.Length) {
                capsize = tree._captop;
                _caps = null;
            }
            else {
                capsize = tree._capnumlist.Length;
                _caps = tree._caps;
                for (int i = 0; i < tree._capnumlist.Length; i++)
                    _caps[tree._capnumlist[i]] = i;
            }

            _counting = true;

            for (;;) {
                if (!_counting)
                    _emitted = new int[_count];

                curNode = tree._root;
                curChild = 0;

                Emit(RegexCode.Lazybranch, 0);

                for (;;) {
                    if (curNode._children == null) {
                        EmitFragment(curNode._type, curNode, 0);
                    }
                    else if (curChild < curNode._children.Count) {
                        EmitFragment(curNode._type | BeforeChild, curNode, curChild);

                        curNode = (RegexNode)curNode._children[curChild];
                        PushInt(curChild);
                        curChild = 0;
                        continue;
                    }

                    if (EmptyStack())
                        break;

                    curChild = PopInt();
                    curNode = curNode._next;

                    EmitFragment(curNode._type | AfterChild, curNode, curChild);
                    curChild++;
                }

                PatchJump(0, CurPos());
                Emit(RegexCode.Stop);

                if (!_counting)
                    break;

                _counting = false;
            }

            // if the set of possible first chars is very large,
            // don't bother scanning for it (common case: . == [^\n])

            fcPrefix = RegexFCD.FirstChars(tree);

	    // REVIEW : ChrisAn/DavidGut, 11/21/2000 - Huh... this code used to 
	    //        : read "> 0XFFF", note the CAPITAL X... everything is golden,
	    //        : except that this really evaluates to 0 in the C# compiler.
	    //        :
	    //        : However! begining in CSC 9055 0XFFF will attempted to be
	    //        : evaluated as a float, causing a compiler error. So switching
	    //        : the constant to "0xFFF", note the lowercase x, causes
	    //        : everything to fail.
	    //        :
	    //        : What is this code really supposed to do???!
	    //
            if (fcPrefix != null && RegexCharClass.SetSize(fcPrefix.Prefix) > 0)
                fcPrefix = null;

            // REVIEW: is this even used anywhere? Can we use it somehow?
            scPrefix = null; //RegexFCD.ScanChars(tree);
            prefix = RegexFCD.Prefix(tree);
            rtl = ((tree._options & RegexOptions.RightToLeft) != 0);

            CultureInfo culture = (tree._options & RegexOptions.CultureInvariant) != 0 ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture;
            if (prefix != null && prefix.Prefix.Length > 0)
                bmPrefix = new RegexBoyerMoore(prefix.Prefix, prefix.CaseInsensitive, rtl, culture);
            else
                bmPrefix = null;

            anchors = RegexFCD.Anchors(tree);

            return new RegexCode(_emitted, _stringtable, _trackcount, _caps, capsize, bmPrefix, fcPrefix, scPrefix, anchors, rtl);
        }

        /*
         * The main RegexCode generator. It does a depth-first walk
         * through the tree and calls EmitFragment to emits code before
         * and after each child of an interior node, and at each leaf.
         */
        internal void EmitFragment(int nodetype, RegexNode node, int CurIndex) {
            int bits = 0;

            if (nodetype <= RegexNode.Ref) {
                if (node.UseOptionR())
                    bits |= RegexCode.Rtl;
                if ((node._options & RegexOptions.IgnoreCase) != 0)
                    bits |= RegexCode.Ci;
            }

            switch (nodetype) {
                case RegexNode.Concatenate | BeforeChild:
                case RegexNode.Concatenate | AfterChild:
                case RegexNode.Empty:
                    break;

                case RegexNode.Alternate | BeforeChild:
                    if (CurIndex < node._children.Count - 1) {
                        PushInt(CurPos());
                        Emit(RegexCode.Lazybranch, 0);
                    }
                    break;

                case RegexNode.Alternate | AfterChild: {

                        if (CurIndex < node._children.Count - 1) {
                            int LBPos = PopInt();
                            PushInt(CurPos());
                            Emit(RegexCode.Goto, 0);
                            PatchJump(LBPos, CurPos());
                        }
                        else {
                            int I;
                            for (I = 0; I < CurIndex; I++) {
                                PatchJump(PopInt(), CurPos());
                            }
                        }
                        break;
                    }

                case RegexNode.Testref | BeforeChild:
                    switch (CurIndex) {
                        case 0:
                            Emit(RegexCode.Setjump);
                            PushInt(CurPos());
                            Emit(RegexCode.Lazybranch, 0);
                            Emit(RegexCode.Testref, MapCapnum(node._m));
                            Emit(RegexCode.Forejump);
                            break;
                    }
                    break;

                case RegexNode.Testref | AfterChild:
                    switch (CurIndex) {
                        case 0: {
                                int Branchpos = PopInt();
                                PushInt(CurPos());
                                Emit(RegexCode.Goto, 0);
                                PatchJump(Branchpos, CurPos());
                                Emit(RegexCode.Forejump);
                                if (node._children.Count > 1)
                                    break;
                                // else fallthrough
                                goto case 1;
                            }
                        case 1:
                            PatchJump(PopInt(), CurPos());
                            break;
                    }
                    break;

                case RegexNode.Testgroup | BeforeChild:
                    switch (CurIndex) {
                        case 0:
                            Emit(RegexCode.Setjump);
                            Emit(RegexCode.Setmark);
                            PushInt(CurPos());
                            Emit(RegexCode.Lazybranch, 0);
                            break;
                    }
                    break;

                case RegexNode.Testgroup | AfterChild:
                    switch (CurIndex) {
                        case 0:
                            Emit(RegexCode.Getmark);
                            Emit(RegexCode.Forejump);
                            break;
                        case 1: 
                            int Branchpos = PopInt();
                            PushInt(CurPos());
                            Emit(RegexCode.Goto, 0);
                            PatchJump(Branchpos, CurPos());
                            Emit(RegexCode.Getmark);
                            Emit(RegexCode.Forejump);

                            if (node._children.Count > 2)
                                break;
                            // else fallthrough
                            goto case 2;
                        case 2:
                            PatchJump(PopInt(), CurPos());
                            break;
                    }
                    break;

                case RegexNode.Loop | BeforeChild:
                case RegexNode.Lazyloop | BeforeChild:

                    if (node._n < infinite || node._m > 1)
                        Emit(node._m == 0 ? RegexCode.Nullcount : RegexCode.Setcount, node._m == 0 ? 0 : 1 - node._m);
                    else
                        Emit(node._m == 0 ? RegexCode.Nullmark : RegexCode.Setmark);

                    if (node._m == 0) {
                        PushInt(CurPos());
                        Emit(RegexCode.Goto, 0);
                    }
                    PushInt(CurPos());
                    break;

                case RegexNode.Loop | AfterChild:
                case RegexNode.Lazyloop | AfterChild: {
                        int StartJumpPos = CurPos();
                        int Lazy = (nodetype - (RegexNode.Loop | AfterChild));

                        if (node._n < infinite || node._m > 1)
                            Emit(RegexCode.Branchcount + Lazy, PopInt(), node._n == infinite ? infinite : node._n - node._m);
                        else
                            Emit(RegexCode.Branchmark + Lazy, PopInt());

                        if (node._m == 0)
                            PatchJump(PopInt(), StartJumpPos);
                    }
                    break;

                case RegexNode.Group | BeforeChild:
                case RegexNode.Group | AfterChild:
                    break;

                case RegexNode.Capture | BeforeChild:
                    Emit(RegexCode.Setmark);
                    break;

                case RegexNode.Capture | AfterChild:
                    Emit(RegexCode.Capturemark, MapCapnum(node._m), MapCapnum(node._n));
                    break;

                case RegexNode.Require | BeforeChild:
                    // NOTE: the following line causes lookahead/lookbehind to be
                    // NON-BACKTRACKING. It can be commented out with (*)
                    Emit(RegexCode.Setjump);


                    Emit(RegexCode.Setmark);
                    break;

                case RegexNode.Require | AfterChild:
                    Emit(RegexCode.Getmark);

                    // NOTE: the following line causes lookahead/lookbehind to be
                    // NON-BACKTRACKING. It can be commented out with (*)
                    Emit(RegexCode.Forejump);

                    break;

                case RegexNode.Prevent | BeforeChild:
                    Emit(RegexCode.Setjump);
                    PushInt(CurPos());
                    Emit(RegexCode.Lazybranch, 0);
                    break;

                case RegexNode.Prevent | AfterChild:
                    Emit(RegexCode.Backjump);
                    PatchJump(PopInt(), CurPos());
                    Emit(RegexCode.Forejump);
                    break;

                case RegexNode.Greedy | BeforeChild:
                    Emit(RegexCode.Setjump);
                    break;

                case RegexNode.Greedy | AfterChild:
                    Emit(RegexCode.Forejump);
                    break;

                case RegexNode.One:
                case RegexNode.Notone:
                    Emit(node._type | bits, (int)node._ch);
                    break;

                case RegexNode.Notoneloop:
                case RegexNode.Notonelazy:
                case RegexNode.Oneloop:
                case RegexNode.Onelazy:
                    if (node._m > 0)
                        Emit(((node._type == RegexNode.Oneloop || node._type == RegexNode.Onelazy) ?
                              RegexCode.Onerep : RegexCode.Notonerep) | bits, (int)node._ch, node._m);
                    if (node._n > node._m)
                        Emit(node._type | bits, (int)node._ch, node._n == infinite ?
                             infinite : node._n - node._m);
                    break;

                case RegexNode.Setloop:
                case RegexNode.Setlazy:
                    if (node._m > 0)
                        Emit(RegexCode.Setrep | bits, StringCode(node._str), StringCode(node._str2), node._m);
                    if (node._n > node._m)
                        Emit(node._type | bits, StringCode(node._str), StringCode(node._str2), 
                             (node._n == infinite) ? infinite : node._n - node._m);
                    break;

                case RegexNode.Multi:
                    Emit(node._type | bits, StringCode(node._str));
                    break;

                case RegexNode.Set:
                    Emit(node._type | bits, StringCode(node._str), StringCode(node._str2));
                    break;

                case RegexNode.Ref:
                    Emit(node._type | bits, MapCapnum(node._m));
                    break;

                case RegexNode.Nothing:
                case RegexNode.Bol:
                case RegexNode.Eol:
                case RegexNode.Boundary:
                case RegexNode.Nonboundary:
#if ECMA
                case RegexNode.ECMABoundary:
                case RegexNode.NonECMABoundary:
#endif
                case RegexNode.Beginning:
                case RegexNode.Start:
                case RegexNode.EndZ:
                case RegexNode.End:
                    Emit(node._type);
                    break;

                default:
                    throw MakeException(SR.GetString(SR.UnexpectedOpcode, nodetype.ToString()));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\installutil\system\configuration\installutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration {
    
    using System;
    using System.Reflection;
    using System.Configuration.Install;
    using System.Configuration.InstallUtilResources;

    /// <include file='doc\InstallUtil.uex' path='docs/doc[@for="InstallUtil"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class InstallUtil {
        /// <include file='doc\InstallUtil.uex' path='docs/doc[@for="InstallUtil.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int Main(string[] args) {
            object[] attributes = Assembly.GetEntryAssembly().GetCustomAttributes(typeof(AssemblyProductAttribute) ,true);            

            Console.WriteLine(Res.GetString(Res.InstallUtilSignOnMessage, 
                                            ThisAssembly.InformationalVersion,
                                            ThisAssembly.Copyright));
                                                        
            try {
                ManagedInstallerClass.InstallHelper(args);
            }
            catch (Exception e) {
                Console.WriteLine(e.Message);
                return -1;
            }

            return 0;
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\installutillib\stdafx.h ===
//------------------------------------------------------------------------------
// <copyright file="StdAfx.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StdAfx.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_)
#define AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8AC075D3_B57F_11D2_B936_00600893B17A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\installutillib\installutillib.cpp ===
//------------------------------------------------------------------------------
// <copyright file="InstallUtilLib.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   InstallUtilLib.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#include "stdafx.h"
#include "oaidl.h"
#include <msi.h>
#include <msiquery.h>
#include "ManagedInstaller.h"
#include <mscoree.h>
#include <correg.h>
#include <fxver.h>
#include <stdio.h>
#include <windows.h>

#define FULLY_QUALIFIED_CONFIGURATION_INSTALL_NAME_STR_L L"System.Configuration.Install,version=" VER_ASSEMBLYVERSION_STR_L L", Culture=neutral, PublicKeyToken=" MICROSOFT_PUBLICKEY_STR_L

DWORD Helper(LPWSTR commandLine, DWORD hInstall, LPWSTR configFile);

/*
 *  reports an error back to msi, or to the
 *  console if msi is not present
 */
void ReportError(
    DWORD hInstall,
    LPWSTR msg
)
{
    if (hInstall == 0) {
        MessageBoxW(NULL, msg, NULL, MB_OK);             
        //wprintf( L"%s\n", msg);    
    } else {
        MSIHANDLE hRecord = MsiCreateRecord(2);
        MsiRecordSetInteger(hRecord, 1, 1001 ); // 1 = Error, 2 = Warning
        MsiRecordSetStringW(hRecord, 2, msg);
        MsiProcessMessage(hInstall, INSTALLMESSAGE_ERROR, hRecord);
    }
}      

/*
 *  reports an error, using Win32 error code
 */
void OutError(
    DWORD  hInstall,
    DWORD  errCode,             // Win32 error code
    LPWSTR funcname   
)
{
    bool messageReported = false;

    //
    // Get system error string for error code.
    //
    LPWSTR lpMsgBuf = 0;                                    // system error msg buffer
    if ( FormatMessageW(  
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            errCode,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),      // Default language
            (LPWSTR)&lpMsgBuf,
            0,
            NULL ) 
         != 0 ) {
    
        //
        // Format error message string.
        //
        DWORD maxBufWchars =  lstrlenW(lpMsgBuf) + 100; 
        LPWSTR msgbuf =  (LPWSTR) LocalAlloc( LMEM_FIXED, maxBufWchars * sizeof(WCHAR) ); 
   
        if ( msgbuf != 0 ) {
            // wsprintf(msgbuf, L"InstallUtilLib.dll %s: %s (hr: 0x%0x)", funcname, errCode, lpMsgBuf);  // link unresolved!
            LPDWORD         MsgPtr[3];                              // formating arguments array
            MsgPtr[0] = (LPDWORD) funcname;
            MsgPtr[1] = (LPDWORD) UIntToPtr(errCode);
            MsgPtr[2] = (LPDWORD) lpMsgBuf;
    
            if ( FormatMessageW(                                    // **** get string for system error ****
                    FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    L"InstallUtilLib.dll:%1!s! (hr=0x%2!08x!): %3!s!",
                    0,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),      // Default language => current set in system
                    msgbuf,
                    maxBufWchars,
                    (va_list *) MsgPtr ) 
                 != 0 ) {
    
                ReportError(hInstall, msgbuf);
                messageReported = true;
            }
            LocalFree( msgbuf );           // Free our buffer.
        }
    }

    if ( lpMsgBuf != 0 )  
        LocalFree( lpMsgBuf );            // Free system buffer.
        
    if ( !messageReported ) {
        char defaultMessage[512];
        defaultMessage[0] = '\0';
        int ret = wsprintfA(defaultMessage, "InstallUtilLib.dll: Unknown error in %S (0x%x).", funcname, errCode);
        if (ret) {
            WCHAR defaultMessageWide[512];
            ret = MultiByteToWideChar(CP_ACP, 0, defaultMessage, -1, defaultMessageWide, 512);
            if (ret) {
                ReportError(hInstall, defaultMessageWide);
                return;
            }
        }

        // if either wsprintf or MultiByteToWideChar failed, show something REALLY generic. 
        ReportError(hInstall, L"InstallUtilLib.dll: Unknown error.");
        
    }
}      

/* 
 *  entry point for testing outside of the context
 *  of msi
 */
extern "C" __declspec(dllexport) DWORD __stdcall
ManagedInstallTest(
    LPWSTR commandLine
)
{
    return Helper(commandLine, 0, NULL);
}

/*
 *  entry point for msi
 */
extern "C" __declspec(dllexport) DWORD __stdcall
ManagedInstall(
    MSIHANDLE hInstall   // this handle is always 32 bits (even on a 64-bit machine)
)  
{
    LPWSTR valueBuf = NULL;
    DWORD valueBufCount = 0;  // character count
    int returnValue = 0;
    UINT err;

    // after this call, valueBufCount will contain the required buffer size
    // (in characters), not including null terminator, in valueBufCount
    err = MsiGetPropertyW(hInstall,
                          L"CustomActionData",
                          L"",
                          &valueBufCount);

    switch (err) {
        case ERROR_MORE_DATA:
        case ERROR_SUCCESS: 
            // either of these is okay
            break;
        default:
            OutError(hInstall, err, L"MsiGetProperty");       // "MsiGetProperty failed"
            return (DWORD)-2;
    }

    valueBufCount++;   // add one for the null terminator

    valueBuf = new WCHAR[valueBufCount];

    err = MsiGetPropertyW(hInstall,
                          L"CustomActionData",
                          valueBuf,
                          &valueBufCount);

    if ( err != ERROR_SUCCESS ) {
        OutError(hInstall, err, L"MsiGetProperty");   //  "MsiGetProperty failed"
        returnValue = -2;
        goto done;
    }
    
    // if the property is undefined in MSI, it just reports success
    // and returns a zero-length value - this is an error to us
    if ( valueBufCount == 0) {
        // see WINERROR.H (was: "MsiGetProperty returned a zero-length value for property 'CustomActionData'")
        OutError(hInstall, (DWORD)TYPE_E_UNDEFINEDTYPE, L"MsiGetProperty");   
        returnValue = -2;
        goto done;
    }

    // The string msi gives to us will have an extra param on the end. 
    // This is the name of the config file, surrounded by quotes, that 
    // will load the right version of the runtime for us.  We parse it 
    // out and eliminate the quotes.
    int startindex = valueBufCount-1;
    valueBuf[startindex] = '\0';

    while (valueBuf[startindex] != '\"' && startindex > 0)
        startindex--;

    valueBuf[startindex] = '\0';
          
    returnValue = Helper(valueBuf, hInstall, valueBuf+startindex+1);

done:

    delete[] valueBuf;

    return returnValue;
}

/*
 *  this is where the work happens.  this function does all
 *  the com stuff to eventually make a call to 
 *  ManagedInstallerClass::ManagedInstall
 */
DWORD Helper(
    LPWSTR commandLine,
    DWORD hInstall,
    LPWSTR configFile
) 
{
    HRESULT hr = S_OK;    
    IManagedInstaller *pIManagedInstaller;
    int returnValue = -1;
  	void *pDispenser = NULL;

    // cook up a BSTR for ManagedInstall
    BSTR bstrCommandLine = SysAllocString(commandLine);
    
    // first try to load a runtime.  If setup has already loaded it,
    // this will just succeed.
    if (configFile != NULL) {
    	// Set error mode to prevent Framework to launch unfriendly error dialog
    	UINT uOldErrorMode = ::SetErrorMode(SEM_FAILCRITICALERRORS);
    	hr = CorBindToRuntimeHost(NULL, NULL, configFile, NULL, STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST, CLSID_CorMetaDataDispenser, IID_IMetaDataDispenser, &pDispenser);
    	::SetErrorMode(uOldErrorMode);

        if (FAILED(hr)) {
            OutError(hInstall, hr, L"CorBindToRuntimeHost");       // couldn't load the runtime
            returnValue = -4;
            goto Cleanup;
        }    
    }
    
    hr = ClrCreateManagedInstance(                
                L"System.Configuration.Install.ManagedInstallerClass," FULLY_QUALIFIED_CONFIGURATION_INSTALL_NAME_STR_L, 
                IID_IManagedInstaller, 
                (LPVOID*)& pIManagedInstaller);
    if (FAILED(hr)) {
        OutError(hInstall, hr, L"ClrCreateManagedInstance");       // "Couldn't create ManagedInstallerClass"
        returnValue = -4;
        goto Cleanup;
    }    

    hr = pIManagedInstaller->ManagedInstall(bstrCommandLine, hInstall, &returnValue);
    if (FAILED(hr)) {
        // we don't need to do a ReportError here because pIManagedInstaller::ManagedInstall
        // already did that.
        returnValue = -5;                
    }
    
    pIManagedInstaller->Release();

Cleanup:               
    SysFreeString(bstrCommandLine);
    if (pDispenser) ((IMetaDataDispenser *) pDispenser)->Release();
    return returnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static TraceSwitch installerDesign;
        
        
        public static TraceSwitch InstallerDesign {
            get {
                if (installerDesign == null) {
                    installerDesign = new TraceSwitch("InstallerDesign", "Enable tracing for design-time code for installers");
                }
                return installerDesign;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\runtimetools\licensecompiler\licensecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Tools {
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.ComponentModel.Design;
    using System.Globalization;


    /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompilationException"]/*' />
    public class LicenseCompilationException : ApplicationException {

        /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompilationException.LicenseCompilationException"]/*' />
        public LicenseCompilationException(int lineNumber, int errorNumber, string errorMessage) :
            base(string.Format("({0}) : error LC{1:0000} : {2}", lineNumber, errorNumber, errorMessage)) {

        }
    }

    /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompiler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class LicenseCompiler {
        private static string outputDir = null;
        private static string targetPE = null;
        private static bool verbose = false;
        private static ArrayList compLists;
        private static ArrayList assemblies;
        private static Hashtable assemHash;

        /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompiler.Main"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int Main(string[] args) {
            int retcode = 0;
            try {
                if (ProcessArgs(args)) {

                    // Hook up the type resolution events for the appdomain so we can delay load
                    // any assemblies/types users gave us in the /i option.
                    //
                    ResolveEventHandler assemblyResolveEventHandler = new ResolveEventHandler(OnAssemblyResolve);
                    AppDomain.CurrentDomain.AssemblyResolve += assemblyResolveEventHandler;

                    DesigntimeLicenseContext ctx = new DesigntimeLicenseContext();

                    foreach (string componentListFile in compLists) {
                        OutputLine("Processing complist '" + componentListFile + "'...");
                        Hashtable types = new Hashtable();
                        StreamReader sr = new StreamReader(componentListFile);

                        string line = null;
                        int lineNumber = 0;
                        do {
                            line = sr.ReadLine();
                            lineNumber++;

                            if (line != null && line.Length > 0) {
                                if (!line.StartsWith("#")) {
                                    if (!types.ContainsKey(line)) {
                                        if (verbose) OutputLine(componentListFile + "(" + lineNumber.ToString() + ") : info LC0001 : Processing component entry '" + line + "'");
                                        types[line] = Type.GetType(line);
                                        if (types[line] != null) {
                                            if (verbose) OutputLine(componentListFile + "(" + lineNumber.ToString() + ") : info LC0002 : Resolved entry to '" + ((Type)types[line]).AssemblyQualifiedName + "'");
                                            try {
                                                LicenseManager.CreateWithContext((Type)types[line], ctx);
                                            }
                                            catch (Exception e) {
                                                OutputLine(componentListFile + "(" + lineNumber.ToString() + ") : error LC0004 : Exception occured creating type '" + e.GetType() + "'");
                                                if (verbose) {
                                                    OutputLine("Complete Error Message:");
                                                    OutputLine(e.ToString());
                                                }
                                            }
                                        }
                                        else {
                                            OutputLine(componentListFile + "(" + lineNumber.ToString() + ") : error LC0003 : Unabled to resolve type '" + line + "'");
                                            retcode = -1;
                                        }
                                    }
                                }
                            }
                        } while (line != null);
                    }

                    AppDomain.CurrentDomain.AssemblyResolve -= assemblyResolveEventHandler;

                    string targetName = null;
                    if (outputDir != null) {
                        targetName = outputDir + "\\" + targetPE.ToLower(CultureInfo.InvariantCulture) + ".licenses";
                    }
                    else {
                        targetName = targetPE.ToLower(CultureInfo.InvariantCulture) + ".licenses";
                    }

                    OutputLine("Creating Licenses file " + targetName + "...");
                    Stream fs = null;
                    try {
                        fs = File.Create(targetName);
                        DesigntimeLicenseContextSerializer.Serialize(fs, targetPE.ToUpper(CultureInfo.InvariantCulture), ctx);
                    }
                    finally {
                        if (fs != null) {
                            fs.Flush();
                            fs.Close();
                        }
                    }
                }
            }
            catch(Exception e) {
                // UNDONE(SreeramN): Localize this.
                //
                OutputLine("Error LC0000: '" + e.Message + "'");
            }
            return retcode;
        }

        /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompiler.GenerateLicenses"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static MemoryStream GenerateLicenses(string fileContents, string targetPE) {
            return GenerateLicenses(fileContents, targetPE, null, null);
        }
        
        /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompiler.GenerateLicenses1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static MemoryStream GenerateLicenses(string fileContents, string targetPE, ITypeResolutionService resolver) {
            return GenerateLicenses(fileContents, targetPE, resolver, null);
        }

        /// <include file='doc\LicenseCompiler.uex' path='docs/doc[@for="LicenseCompiler.GenerateLicenses2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static MemoryStream GenerateLicenses(string fileContents, string targetPE, ITypeResolutionService resolver, DesigntimeLicenseContext ctx) {
            // UNDONE(sreeramn): This is a temporary check... this is needed so the licensing
            // code works with 9216 of VS which does not have a fix from Izzy. We can safely
            // remove this with 9224 or greater VS.
            //
            if (ctx == null)
                ctx = new DesigntimeLicenseContext();

            Hashtable types = new Hashtable();
            StringReader reader = new StringReader(fileContents);

            string line = null;
            int lineNumber = 0;
            do {
                line = reader.ReadLine();
                lineNumber++;

                if (line != null && line.Length > 0) {
                    if (!line.StartsWith("#")) {
                        if (!types.ContainsKey(line)) {
                            if (resolver != null) {
                                types[line] = resolver.GetType(line);

                                // If we cannot find the strong-named type, then try to see
                                // if the TypeResolver can bind to partial names. For this, 
                                // we will strip out the partial names and keep the rest of the
                                // strong-name informatio to try again.
                                //
                                if (types[line] == null) {
                                    string[] typeParts = line.Split(new char[] {','});
                                    
                                    // Break up the type name from the rest of the assembly strong name.
                                    //
                                    if (typeParts != null && typeParts.Length > 2) {
                                        string partialName = typeParts[0].Trim();
                    
                                        for (int i = 1; i < typeParts.Length; ++i) {
                                            string s = typeParts[i].Trim();
                                            if (!s.StartsWith("Version=") && !s.StartsWith("version=")) {
                                                partialName = partialName + ", " + s;
                                            }
                                        }

                                        types[line] = resolver.GetType(partialName);
                                    }
                                }
                            }

                            // If the resolver completely failed, then see if the default
                            // Fusion look up will find the type.
                            //
                            if (types[line] == null)
                                types[line] = Type.GetType(line);

                            if (types[line] != null) {
                                try {
                                    LicenseManager.CreateWithContext((Type)types[line], ctx);
                                }
                                catch (Exception e) {
                                    throw new LicenseCompilationException(lineNumber, 4, "Exception occured creating type '" + e.GetType() + "'");
                                }
                            }
                            else {
                                throw new LicenseCompilationException(lineNumber, 3, "Unabled to resolve type '" + line + "'");
                            }
                        }
                    }
                }
            } while (line != null);
            
            MemoryStream ms = new MemoryStream();
            DesigntimeLicenseContextSerializer.Serialize(ms, targetPE.ToUpper(CultureInfo.InvariantCulture), ctx);
            return ms;
        }

        private static Assembly OnAssemblyResolve(object sender, ResolveEventArgs e) {
            if (assemblies == null || assemblies.Count == 0)
                return null;

            // If there is a shell type loader in our resolveTypeLoader variable, then we
            // will use it to resolve the assembly.
            //
            Assembly assembly = null;
            string assemblyName = e.Name;

            if (assemHash == null) {
                assemHash = new Hashtable();
            }
            else {
                assembly = (Assembly)assemHash[assemblyName];
            }

            foreach (string assemName in assemblies) {
                Assembly assem = Assembly.LoadFrom(assemName);
                Debug.Assert(assem != null, "No assembly loaded from: " + assemName);
                if (assem == null)
                    return null;

                string s = assem.GetName().Name;
                assemHash.Add(s, assem);
                if (s == assemblyName) {
                    return assem;
                }
            }

            return null;
        }
            
        private static bool ProcessArgs(string[] args) {
            bool needOutputUsage = false;
            bool needLogo = true;

            for (int i=0; i<args.Length; i++) {
                string currentArg = args[i];

                if (currentArg[0] == '-'
                    || currentArg[0] == '/') {

                    string option = currentArg.Substring(1);

                    bool consumed = false;

                    if (!consumed) {
                        if (option.Equals("?")
                            || option.ToUpper(CultureInfo.InvariantCulture).Equals("H")
                            || option.ToUpper(CultureInfo.InvariantCulture).Equals("HELP")) {

                            needOutputUsage = true;
                            consumed = true;
                            break;
                        }
                    }
                    if (!consumed) {
                        if (option.ToUpper(CultureInfo.InvariantCulture).Equals("NOLOGO")) {
                            needLogo = false;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.ToUpper(CultureInfo.InvariantCulture).Equals("V")) {
                            verbose = true;
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 7 && option.Substring(0, 7).ToUpper(CultureInfo.InvariantCulture).Equals("OUTDIR:")) {
                            outputDir = option.Substring(7);
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 7 && option.Substring(0, 7).ToUpper(CultureInfo.InvariantCulture).Equals("TARGET:")) {
                            targetPE = option.Substring(7);
                            consumed = true;
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 8 && option.Substring(0, 9).ToUpper(CultureInfo.InvariantCulture).Equals("COMPLIST:")) {
                            string compList = option.Substring(9);
                            if (compList != null && compList.Length > 1) {
                                if (compLists == null)
                                    compLists = new ArrayList();
                                
                                compLists.Add(compList);
                                consumed = true;
                            }
                        }
                    }
                    if (!consumed) {
                        if (option.Length > 2 && option.Substring(0, 2).ToUpper(CultureInfo.InvariantCulture).Equals("I:")) {
                            string moduleName = option.Substring(2);
                            if (moduleName.Length > 0) {
                                if (assemblies == null)
                                    assemblies = new ArrayList();
                                assemblies.Add(moduleName);
                            }
                            consumed = true;
                        }
                    }

                    // Unknown command!
                    //
                    if (!consumed) {
                        needOutputUsage = true;
                        break;
                    }
                }
            }

            if (needLogo || needOutputUsage) {
                OutputLogo();
            }

            if (needOutputUsage) {
                OutputUsage();
                return false;
            }

            if (targetPE == null || compLists == null || compLists.Count == 0) {
                OutputUsage();
                return false;
            }

            return true;
        }


        private static void OutputLine(string s) {
            Console.Out.WriteLine(s);
        }

        private static void OutputUsage() {
            OutputLine(SR.GetString(SR.Usage));
        }

        private static void OutputLogo() {
            OutputLine(SR.GetString(SR.Logo, Environment.Version, ThisAssembly.Copyright));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\imanagedinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="IManagedInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration.Install {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;

    /// <include file='doc\IManagedInstaller.uex' path='docs/doc[@for="IManagedInstaller"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [ComImport, Guid("1E233FE7-C16D-4512-8C3B-2E9988F08D38"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface IManagedInstaller {

        /// <include file='doc\IManagedInstaller.uex' path='docs/doc[@for="IManagedInstaller.ManagedInstall"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
    	[return: MarshalAs(UnmanagedType.I4)]
        int ManagedInstall(
    		[In, MarshalAs(UnmanagedType.BStr)] 
            string commandLine,

            [In, MarshalAs(UnmanagedType.I4)] 
            int hInstall);  // this handle is alway 32 bits (even on a 64 bit machine)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\componentinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    

    /// <include file='doc\ComponentInstaller.uex' path='docs/doc[@for="ComponentInstaller"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public abstract class ComponentInstaller : Installer {

        /// <include file='doc\ComponentInstaller.uex' path='docs/doc[@for="ComponentInstaller.CopyFromComponent"]/*' />
        /// <devdoc>
        /// Copies properties from the given component to this installer. This method
        /// will be called at design-time when the user clicks 'Add Installer' on a
        /// component that has specified this class as its installer. The installer
        /// should take all information it can from the live component and store it
        /// to be used at install time.
        /// </devdoc>
        public abstract void CopyFromComponent(IComponent component);

        /// <include file='doc\ComponentInstaller.uex' path='docs/doc[@for="ComponentInstaller.IsEquivalentInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool IsEquivalentInstaller(ComponentInstaller otherInstaller) {
            return false;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\eventloginstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics {
    using System.ComponentModel;
    using System.Diagnostics;
//    using System.Windows.Forms;
    using System;
    using System.Collections;    
    using Microsoft.Win32;
    using System.Configuration.Install;
    using System.Globalization;
    
    /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller"]/*' />
    /// <devdoc>
    /// This class acts as an installer for the EventLog component. Essentially, it calls
    /// EventLog.CreateEventSource.
    /// </devdoc>
    public class EventLogInstaller : ComponentInstaller {

        private string logName;
        private string sourceName;
        private UninstallAction uninstallAction = System.Configuration.Install.UninstallAction.Remove;

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.Log"]/*' />
        /// <devdoc>
        /// The log in which the source will be created
        /// </devdoc>
        [
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string Log {
            get {
                if (logName == null && sourceName != null)
                    // they've told us a source, but they haven't told us a log name.
                    // try to deduce the log name from the source name.
                    logName = EventLog.LogNameFromSourceName(sourceName, ".");
                return logName;
            }
            set {
                logName = value;
            }
        }

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.Source"]/*' />
        /// <devdoc>
        /// The source to be created
        /// </devdoc>
        [
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string Source {
            get {
                return sourceName;
            }
            set {
                sourceName = value;
            }
        }

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.UninstallAction"]/*' />
        /// <devdoc>
        /// Determines whether the event log is removed at uninstall time.
        /// </devdoc>
        [DefaultValue(UninstallAction.Remove)]
        public UninstallAction UninstallAction {
            get {
                return uninstallAction;
            }
            set {
                if (!Enum.IsDefined(typeof(UninstallAction), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(UninstallAction));
                
                uninstallAction = value;
            }
        }

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.CopyFromComponent"]/*' />
        /// <devdoc>
        /// A method on ComponentInstaller that lets us copy properties.
        /// </devdoc>
        public override void CopyFromComponent(IComponent component) {
            EventLog log = component as EventLog;
            
            if (log == null)
                throw new ArgumentException(Res.GetString(Res.NotAnEventLog));

            if (log.Log == null || log.Log == string.Empty || log.Source == null || log.Source == string.Empty) {
                throw new ArgumentException(Res.GetString(Res.IncompleteEventLog));
            }

            Log = log.Log;
            Source = log.Source;
        }
        
        private static RegistryKey FindSourceRegistration(string source, string machineName, bool readOnly) {
            if (source != null && source.Length != 0) {                
                RegistryKey key = null;

                if (machineName.Equals(".")) {
                    key = Registry.LocalMachine;
                }
                else {
                    key = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                }
                if (key != null)
                    key = key.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog", /*writable*/!readOnly);
                if (key == null)
                    // there's not even an event log service on the machine.
                    // or, more likely, we don't have the access to read the registry.
                    return null;
                // Most machines will return only { "Application", "System", "Security" },
                // but you can create your own if you want.
                string[] logNames = key.GetSubKeyNames();
                for (int i = 0; i < logNames.Length; i++) {
                    // see if the source is registered in this log.
                    // NOTE: A source name must be unique across ALL LOGS!
                    RegistryKey logKey = key.OpenSubKey(logNames[i], /*writable*/!readOnly);
                    if (logKey != null) {
                        RegistryKey sourceKey = logKey.OpenSubKey(source, /*writable*/!readOnly);
                        if (sourceKey != null) {
                            key.Close();
                            sourceKey.Close();
                            // found it
                            return logKey;
                        }
                        logKey.Close();
                    }
                }
                key.Close();
                
                // didn't see it anywhere
            }

            return null;
        }
        
        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.Install"]/*' />
        /// <devdoc>
        /// Called when we should perform the install. Inherited from Installer.
        /// </devdoc>
        public override void Install(IDictionary stateSaver) {
            base.Install(stateSaver);

            Context.LogMessage(Res.GetString(Res.CreatingEventLog, Source, Log));
            
            if (Environment.OSVersion.Platform != PlatformID.Win32NT) {
                throw new PlatformNotSupportedException(Res.GetString(Res.WinNTRequired));
            }

            stateSaver["baseInstalledAndPlatformOK"] = true;

            // remember whether the log was already there and if the source was already registered
            bool logExists = EventLog.Exists(Log, ".");
            stateSaver["logExists"] = logExists;


            bool alreadyRegistered = EventLog.SourceExists(Source, ".");
            stateSaver["alreadyRegistered"] = alreadyRegistered;

            if (alreadyRegistered) {
                string oldLog = EventLog.LogNameFromSourceName(Source, ".");
                if (oldLog == Log) {
                    // The source exists, and it's on the right log, so we do nothing
                    // here.  If oldLog != Log, we'll try to create the source below
                    // and it will fail, because the source already exists on another
                    // log.
                    return;
                }
            }

            // do the installation.
            EventLog.CreateEventSource(Source, Log, ".");
        }

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.IsEquivalentInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsEquivalentInstaller(ComponentInstaller otherInstaller) {
            EventLogInstaller other = otherInstaller as EventLogInstaller;
            if (other == null)
                return false;

            return other.Source == Source;
        }

        // Restores the registry to the state it was in when SaveRegistryKey ran.
        private void RestoreRegistryKey(SerializableRegistryKey serializable) {
            // A RegistryKey can't contain all the information necessary to serialize it,
            // so we have to have prior knowledge about where to put the saved information.
            // Luckily, we do. =)
            RegistryKey regKey = Registry.LocalMachine;
            regKey = regKey.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog", /*writable*/true);
            regKey = regKey.CreateSubKey(Log);
            regKey = regKey.CreateSubKey(Source);

            serializable.CopyToRegistry(regKey);

            regKey.Close();
        }

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.Rollback"]/*' />
        /// <devdoc>
        /// Called when this or another component in the installation has failed.
        /// </devdoc>
        public override void Rollback(IDictionary savedState) {
            base.Rollback(savedState);

            Context.LogMessage(Res.GetString(Res.RestoringEventLog, Source));

            if (savedState["baseInstalledAndPlatformOK"] != null) {
                bool logExists = (bool) savedState["logExists"];
                if (!logExists)
                    EventLog.Delete(Log, ".");
                else {
                    bool alreadyRegistered = (bool) savedState["alreadyRegistered"];
                    if (!alreadyRegistered) {
                        // delete the source we installed, assuming it succeeded. Then put back whatever used to be there.
                        if (EventLog.SourceExists(Source, "."))
                            EventLog.DeleteEventSource(Source, ".");
                    }                  
                }
            }
        }

        // takes the information at the given registry key and below it and copies it into the
        // given dictionary under the given key in the dictionary.
        private static void SaveRegistryKey(RegistryKey regKey, IDictionary saver, string dictKey) {
            // Since the RegistryKey class isn't serializable, we use our own class to hold the information.
            SerializableRegistryKey serializable = new SerializableRegistryKey(regKey);
            saver[dictKey] = serializable;
        }

        /// <include file='doc\EventLogInstaller.uex' path='docs/doc[@for="EventLogInstaller.Uninstall"]/*' />
        /// <devdoc>
        /// Called to remove the event log source from the machine.
        /// </devdoc>
        public override void Uninstall(IDictionary savedState) {
            base.Uninstall(savedState);
            if (UninstallAction == UninstallAction.Remove) {
                Context.LogMessage(Res.GetString(Res.RemovingEventLog, Source));
                if (EventLog.SourceExists(Source, ".")) {
                    if ( string.Compare(Log, Source, true, CultureInfo.InvariantCulture) != 0 ) // If log has the same name, don't delete the source.
                        EventLog.DeleteEventSource(Source, ".");
                }
                else
                    Context.LogMessage(Res.GetString(Res.LocalSourceNotRegisteredWarning, Source));

                // now test to see if the log has any more sources in it. If not, we
                // should remove the log entirely.
                // we have to do this by inspecting the registry.
                RegistryKey key = Registry.LocalMachine;
                if (key != null)
                    key = key.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog\\" + Log, false);
                if (key != null) {
                    string[] keyNames = key.GetSubKeyNames();
                    if ( keyNames == null || keyNames.Length == 0 || 
                         (keyNames.Length == 1 && string.Compare(keyNames[0], Log, true, CultureInfo.InvariantCulture) ==0) // the only key has the same name as log
                       ) {     
                        Context.LogMessage(Res.GetString(Res.DeletingEventLog, Log));
                        // there are no sources in this log. Delete the log.
                        EventLog.Delete(Log, ".");
                    }
                }
            }
            // otherwise it's UninstallAction.NoAction, so we shouldn't do anything.
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\installcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {

    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.IO;
    using System.Text;
    using System.Windows.Forms;
    using System.Globalization;
    
    /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext"]/*' />
    /// <devdoc>
    ///    <para>Contains information about the current installation.</para>
    /// </devdoc>
    public class InstallContext {

        private string logFilePath;
        private StringDictionary parameters;

        /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext.InstallContext"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Configuration.Install.InstallContext'/> class; a log file for the
        ///       installation is not created.
        ///    </para>
        /// </devdoc>
        public InstallContext() : this(null, null) {
        }

        /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext.InstallContext1"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new instance of the
        ///    <see cref='System.Configuration.Install.InstallContext'/> class and creates a log file for 
        ///       the installation.</para>
        /// </devdoc>
        public InstallContext(string logFilePath, string[] commandLine) {
            parameters = ParseCommandLine(commandLine);
            if (Parameters["logfile"] != null)
                this.logFilePath = Parameters["logfile"];
            else if (logFilePath != null) {
                this.logFilePath = logFilePath;
                Parameters["logfile"] = logFilePath;
            }                
        }

        /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext.Parameters"]/*' />
        /// <devdoc>
        ///    <para>Gets the
        ///       command-line arguments that were entered
        ///       when the installation executable was run.</para>
        /// </devdoc>
        public StringDictionary Parameters {
            get { 
                return parameters;
            }
        }

        /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext.IsParameterTrue"]/*' />
        /// <devdoc>
        ///    <para>Determines whether the specified command line parameter
        ///       is <see langword='true'/>.</para>
        /// </devdoc>
        public bool IsParameterTrue(string paramName) {
            string paramValue = Parameters[paramName.ToLower(CultureInfo.InvariantCulture)];
            if (paramValue == null)
                return false;
            return string.Compare(paramValue, "true", true, CultureInfo.InvariantCulture) == 0 || string.Compare(paramValue, "yes", true, CultureInfo.InvariantCulture) == 0
                || string.Compare(paramValue, "1", true, CultureInfo.InvariantCulture) == 0 || "".Equals(paramValue);
        }

        /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext.LogMessage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the message
        ///       to the log file for the installation and
        ///       to the console.
        ///    </para>
        /// </devdoc>
        public void LogMessage(string message) {
            if (this.logFilePath != null && !"".Equals(this.logFilePath)) {
                StreamWriter log = null;
                try {
                    log = new StreamWriter(logFilePath, true, Encoding.UTF8);                                                      
                    log.WriteLine(message);                    
                }
                finally {
                    if (log != null)
                        log.Close();
                }                    
            }
                    
            if (IsParameterTrue("LogToConsole") || Parameters["logtoconsole"] == null)
                Console.WriteLine(message);
        }

        /// <include file='doc\InstallContext.uex' path='docs/doc[@for="InstallContext.ParseCommandLine"]/*' />
        /// <devdoc>
        /// <para>Parses the command-line arguments into a <see cref='T:System.Windows.Forms.StringDictionary'/>.</para>
        /// </devdoc>
        protected static StringDictionary ParseCommandLine(string[] args) {
            StringDictionary options = new StringDictionary();
            if (args == null)
                return options;
            for (int i = 0; i < args.Length; i++) {
                // chop off the leading / or -
                if (args[i].StartsWith("/") || args[i].StartsWith("-"))
                    args[i] = args[i].Substring(1);
                // find the '='
                int equalsPos = args[i].IndexOf('=');
                // if there is no equals, add the parameter with a value of ""
                if (equalsPos < 0)
                    options[args[i].ToLower(CultureInfo.InvariantCulture)] = "";
                else
                    options[args[i].Substring(0, equalsPos).ToLower(CultureInfo.InvariantCulture)] = args[i].Substring(equalsPos+1);
            }
            return options;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\installercollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallerCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration.Install {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    
    /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains a collection of installers to be run during an
    ///       installation.
    ///    </para>
    /// </devdoc>
    public class InstallerCollection : CollectionBase {
        private Installer owner;

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.InstallerCollection"]/*' />
        /// <devdoc>
        /// internal so no one can create one of these
        /// </devdoc>
        internal InstallerCollection(Installer owner) {
            this.owner = owner;
        }

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets an
        ///       installer at the specified index.
        ///    </para>
        /// </devdoc>
        public Installer this[int index] {
            get {
                return ((Installer)(List[index]));
            }
            set {
                List[index] = value;
            }
        }        

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified installer to this collection of
        ///       installers.
        ///    </para>
        /// </devdoc>
        public int Add(Installer value) {
            return List.Add(value);
        }

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified installers to this installer collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(InstallerCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(Installer[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
         
        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether the specified installer is included in this <see cref='System.Configuration.Install.InstallerCollection'/>.
        ///    </para>
        /// </devdoc>
        public bool Contains(Installer value) {
            return List.Contains(value);
        }

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Installer[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(Installer value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, Installer value) {
            List.Insert(index, value);
        }

        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified <see cref='System.Configuration.Install.Installer'/> from the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public void Remove(Installer value) {
            List.Remove(value);
        }
        
        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.OnInsert"]/*' />
        ///<internalonly/>                          
        protected override void OnInsert(int index, object value) {
            if (CompModSwitches.InstallerDesign.TraceVerbose) Debug.WriteLine("Adding installer " + index + " to Installers collection");
            ((Installer)value).parent = this.owner;
        }
        
        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemove(int index, object value) {
            if (CompModSwitches.InstallerDesign.TraceVerbose) Debug.WriteLine("Removing installer " + index + " from Installers collection");
            ((Installer)value).parent = null;
        }
                 
        /// <include file='doc\InstallerCollection.uex' path='docs/doc[@for="InstallerCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSet(int index, object oldValue, object newValue) {
            if (CompModSwitches.InstallerDesign.TraceVerbose) Debug.WriteLine("Setting installer " + index + " in Installers collection");
            ((Installer)oldValue).parent = null;
            ((Installer)newValue).parent = this.owner;    
        }         
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\assemblyinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="AssemblyInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;    
    using System.ComponentModel;
    using System.Runtime.Serialization.Formatters.Soap;

    /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller"]/*' />
    /// <devdoc>
    ///    Loads an assembly, finds all installers in it, and runs them.
    /// </devdoc>
    public class AssemblyInstaller : Installer {

        private Assembly assembly;
        private string[] commandLine;
        private bool useNewContext;
        private static bool helpPrinted = false;
        
        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.AssemblyInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AssemblyInstaller() : base() {
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.AssemblyInstaller1"]/*' />
        /// <devdoc>
        ///    Creates a new AssemblyInstaller for the given assembly and passes
        ///    the given command line arguments to its Context object.
        /// </devdoc>
        public AssemblyInstaller(string filename, string[] commandLine) : base() {
            this.Path = System.IO.Path.GetFullPath(filename);
            this.commandLine = commandLine;
            this.useNewContext = true;
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.AssemblyInstaller2"]/*' />
        /// <devdoc>
        ///    Creates a new AssemblyInstaller for the given assembly and passes
        ///    the given command line arguments to its Context object.
        /// </devdoc>
        public AssemblyInstaller(Assembly assembly, string[] commandLine) : base() {
            this.Assembly = assembly;
            this.commandLine = commandLine;
            this.useNewContext = true;
        }
        
        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.Assembly"]/*' />
        /// <devdoc>
        ///      The actual assembly that will be installed
        /// </devdoc>
        public Assembly Assembly {
            get {
                return this.assembly;
            }
            set {
                this.assembly = value;
            }
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.CommandLine"]/*' />
        /// <devdoc>
        ///    The command line to use when creating a new context for the assembly's install.
        /// </devdoc>
        public string[] CommandLine {
            get {
                return commandLine;
            }
            set {
                commandLine = value;
            }
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.HelpText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string HelpText {
            get {
                if (Path != null && Path.Length > 0) {
                    Context = new InstallContext(null, new string[0]);
                    InitializeFromAssembly();
                }
                if (helpPrinted)
                    return base.HelpText;
                else  {
                    helpPrinted = true;
                    return Res.GetString(Res.InstallAssemblyHelp) + "\r\n" + base.HelpText;
                }
            }
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.Path"]/*' />
        /// <devdoc>
        ///    The path to the assembly to install
        /// </devdoc>
        public string Path {
            get {
                if (this.assembly == null) {
                    return null;
                }
                else {
                    return this.assembly.Location;
                }
            }
            set {           
                if (value == null) {
                    this.assembly = null;
                }
                this.assembly = Assembly.LoadFrom(value);
            }
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.UseNewContext"]/*' />
        /// <devdoc>
        ///    If true, creates a new InstallContext object for the assembly's install.
        /// </devdoc>
        public bool UseNewContext {
            get {
                return useNewContext;
            }
            set {
                useNewContext = value;
            }
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.CheckIfInstallable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds the installers in the specified assembly, creates
        ///       a new instance of <see cref='System.Configuration.Install.AssemblyInstaller'/>
        ///       , and adds the installers to its installer collection.
        ///    </para>
        /// </devdoc>
        public static void CheckIfInstallable(string assemblyName) {
            AssemblyInstaller tester = new AssemblyInstaller();
            tester.UseNewContext = false;
            tester.Path = assemblyName;
            tester.CommandLine = new string[0];
            tester.Context = new InstallContext(null, new string[0]);

            // this does the actual check and throws if necessary.
            tester.InitializeFromAssembly();
            if (tester.Installers.Count == 0)
                throw new InvalidOperationException(Res.GetString(Res.InstallNoPublicInstallers, assemblyName));
        }

        private InstallContext CreateAssemblyContext() {
            InstallContext context = new InstallContext(System.IO.Path.ChangeExtension(Path, ".InstallLog"), CommandLine);
                
            context.Parameters["assemblypath"] = Path;
            return context;
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.InitializeFromAssembly"]/*' />
        /// <devdoc>
        /// this is common code that's called from Install, Commit, Rollback, and Uninstall. It
        /// loads the assembly, finds all Installer types in it, and adds them to the Installers
        /// collection. It also prints some useful information to the Context log.
        /// </devdoc>
        private void InitializeFromAssembly() {
            // Get the set of installers to use out of the assembly. This will load the assembly
            // so that its types are accessible later. An assembly cannot be unloaded. 

            Type[] installerTypes = null;
            try {
                installerTypes = GetInstallerTypes(assembly);
            }
            catch (Exception e) {
                Context.LogMessage(Res.GetString(Res.InstallException, Path));
                Installer.LogException(e, Context);
                Context.LogMessage(Res.GetString(Res.InstallAbort, Path));
                throw new InvalidOperationException(Res.GetString(Res.InstallNoInstallerTypes, Path), e);
            }

            if (installerTypes == null || installerTypes.Length == 0) {
                Context.LogMessage(Res.GetString(Res.InstallNoPublicInstallers, Path));
                // this is not an error, so don't throw. Just don't do anything.
                return;
            }

            // create instances of each of those, and add them to the Installers collection.
            for (int i = 0; i < installerTypes.Length; i++) {
                try {
                    Installer installer = (Installer) Activator.CreateInstance(installerTypes[i], 
                                                                                                    BindingFlags.Instance | 
                                                                                                    BindingFlags.Public | 
                                                                                                    BindingFlags.CreateInstance, 
                                                                                                    null, 
                                                                                                    new object[0],
                                                                                                    null);                    
                    Installers.Add(installer);
                }
                catch (Exception e) {
                    Context.LogMessage(Res.GetString(Res.InstallCannotCreateInstance, installerTypes[i].FullName));
                    Installer.LogException(e, Context);
                    throw new InvalidOperationException(Res.GetString(Res.InstallCannotCreateInstance, installerTypes[i].FullName), e);
                }
            }
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.Commit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Commit(IDictionary savedState) {
            PrintStartText(Res.GetString(Res.InstallActivityCommitting));
            InitializeFromAssembly();

            // never use the passed-in savedState. Always look next to the assembly.
            FileStream file = new FileStream(System.IO.Path.ChangeExtension(Path, ".InstallState"), FileMode.Open, FileAccess.Read);
            try {
                SoapFormatter formatter = new SoapFormatter();
                savedState = (IDictionary) formatter.Deserialize(file);
            }
            finally {
                file.Close();
                if (Installers.Count == 0) {
                    Context.LogMessage(Res.GetString(Res.RemovingInstallState));
                    File.Delete(System.IO.Path.ChangeExtension(Path, ".InstallState"));
                } 
            }

            base.Commit(savedState);
        }

        // returns the set of types that implement Installer in the given assembly
        private static Type[] GetInstallerTypes(Assembly assem) {
            ArrayList typeList = new ArrayList();            
            
            Module[] mods = assem.GetModules();
            for (int i = 0; i < mods.Length; i++) {
                Type[] types = mods[i].GetTypes();
                for (int j = 0; j < types.Length; j++) {
                #if DEBUG
                if (CompModSwitches.InstallerDesign.TraceVerbose) {
                    Debug.WriteLine("Looking at type '" + types[j].FullName + "'");
                    Debug.WriteLine("  Is it an installer? " + (typeof(Installer).IsAssignableFrom(types[j]) ? "Yes" : "No"));
                    Debug.WriteLine("  Is it abstract? " + (types[j].IsAbstract ? "Yes" : "No"));
                    Debug.WriteLine("  Is it public? " + (types[j].IsPublic ? "Yes" : "No"));
                    Debug.WriteLine("  Does it have the RunInstaller attribute? " + (((RunInstallerAttribute) TypeDescriptor.GetAttributes(types[j])[typeof(RunInstallerAttribute)]).RunInstaller ? "Yes" : "No"));
                }
                #endif
                    if (typeof(Installer).IsAssignableFrom(types[j]) && !types[j].IsAbstract && types[j].IsPublic
                        && ((RunInstallerAttribute) TypeDescriptor.GetAttributes(types[j])[typeof(RunInstallerAttribute)]).RunInstaller)
                        typeList.Add(types[j]);
                }
            }

            return (Type[]) typeList.ToArray(typeof(Type));
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.Install"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Install(IDictionary savedState) {
            PrintStartText(Res.GetString(Res.InstallActivityInstalling));
            InitializeFromAssembly();

            // never use the one passed in. Always create a new file right next to the
            // assembly.
            savedState = new Hashtable();

            try {
                // Do the install
                base.Install(savedState);
            }
            finally {
                // and write out the results
                FileStream file = new FileStream(System.IO.Path.ChangeExtension(Path, ".InstallState"), FileMode.Create);
                try {
                    SoapFormatter formatter = new SoapFormatter();
                    formatter.Serialize(file, savedState);
                }
                finally {
                    file.Close();
                }
            }
        }

        private void PrintStartText(string activity) {
            if (UseNewContext) {
                InstallContext newContext = CreateAssemblyContext();
                // give a warning in the main log file that we're switching over to the assembly-specific file
                if (Context != null) {
                    Context.LogMessage(Res.GetString(Res.InstallLogContent, Path));
                    Context.LogMessage(Res.GetString(Res.InstallFileLocation, newContext.Parameters["logfile"]));
                }
                Context = newContext;
            }

            // print out some info on the install
            Context.LogMessage(string.Format(activity, Path));
            Context.LogMessage(Res.GetString(Res.InstallLogParameters));
            if (Context.Parameters.Count == 0)
                Context.LogMessage("   " + Res.GetString(Res.InstallLogNone));
            IDictionaryEnumerator en = (IDictionaryEnumerator) Context.Parameters.GetEnumerator();
            while (en.MoveNext())
                Context.LogMessage("   " + (string) en.Key + " = " + (string) en.Value);
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.Rollback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Rollback(IDictionary savedState) {
            PrintStartText(Res.GetString(Res.InstallActivityRollingBack));
            InitializeFromAssembly();
            string filePath = System.IO.Path.ChangeExtension(Path, ".InstallState");

            // never use the passed-in savedState. Always look next to the assembly.
            FileStream file = new FileStream(filePath, FileMode.Open, FileAccess.Read);
            try {
                SoapFormatter formatter = new SoapFormatter();
                savedState = (IDictionary) formatter.Deserialize(file);                                
            }
            finally {
                file.Close();
            }

            try {
                base.Rollback(savedState);
            }                
            finally {
                File.Delete(filePath);
            }                
        }

        /// <include file='doc\AssemblyInstaller.uex' path='docs/doc[@for="AssemblyInstaller.Uninstall"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Uninstall(IDictionary savedState) {
            PrintStartText(Res.GetString(Res.InstallActivityUninstalling));
            InitializeFromAssembly();

            // never use the passed-in savedState. Always look next to the assembly.
            string filePath = System.IO.Path.ChangeExtension(Path, ".InstallState");
            if (filePath != null && File.Exists(filePath)) {
                FileStream file = new FileStream(filePath, FileMode.Open, FileAccess.Read);
                try {
                    SoapFormatter formatter = new SoapFormatter();
                    savedState = (IDictionary) formatter.Deserialize(file);
                }
                catch {
                    Context.LogMessage(Res.GetString(Res.InstallSavedStateFileCorruptedWarning, Path, filePath));
                    savedState = null;
                }
                finally {
                    file.Close();
                }
            }
            else
                savedState = null;

            base.Uninstall(savedState);

            if (filePath != null && filePath.Length != 0)
                try {
                    File.Delete(filePath);
                }
                catch {
                    //Throw an exception if we can't delete the file (but we were able to read from it)                    
                    throw new InvalidOperationException(Res.GetString(Res.InstallUnableDeleteFile, filePath));
                }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\installeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {

    using System.Diagnostics;

    using System;

    /// <include file='doc\InstallEventHandler.uex' path='docs/doc[@for="InstallEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Configuration.Install.Installer.OnBeforeInstall'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnAfterInstall'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnCommitting'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnCommitted'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnBeforeRollback'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnAfterRollback'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnBeforeUninstall'/> event, or
    ///    the <see cref='System.Configuration.Install.Installer.OnAfterUninstall'/>
    ///    event of
    ///    the <see cref='System.Configuration.Install.Installer'/>.</para>
    /// </devdoc>

    public delegate void InstallEventHandler(object sender, InstallEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\installexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration.Install {

    using System;
    using System.Runtime.Serialization;

    /// <include file='doc\InstallException.uex' path='docs/doc[@for="InstallException"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    public class InstallException : SystemException {
    
        /// <include file='doc\InstallException.uex' path='docs/doc[@for="InstallException.InstallException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstallException() : base() {
            HResult = HResults.Install;
        }

        /// <include file='doc\InstallException.uex' path='docs/doc[@for="InstallException.InstallException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstallException(string message) : base(message) {
        }

        /// <include file='doc\InstallException.uex' path='docs/doc[@for="InstallException.InstallException2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstallException(string message, Exception innerException) : base(message, innerException) {
        }
        
        /// <internalonly/>        
        protected InstallException(SerializationInfo info, StreamingContext context) : base (info, context) {            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\managedinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="ManagedInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Reflection;
    using System.Configuration;
    using System.Configuration.Install;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Globalization;
    
    /// <include file='doc\ManagedInstaller.uex' path='docs/doc[@for="ManagedInstallerClass"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [ComVisible(true), GuidAttribute("42EB0342-0393-448f-84AA-D4BEB0283595")]
    public class ManagedInstallerClass : IManagedInstaller {                            

        /// <include file='doc\ManagedInstaller.uex' path='docs/doc[@for="ManagedInstallerClass.IManagedInstaller.ManagedInstall"]/*' />
        /// <internalonly/>
        int IManagedInstaller.ManagedInstall(string argString, int hInstall) {
            try {
                string[] args = StringToArgs(argString);
                InstallHelper(args);
            }
            catch (Exception e) {
                Exception temp = e;
                StringBuilder msg = new StringBuilder();
                while (temp != null) {
                    msg.Append(temp.Message);
                    temp = temp.InnerException;
                    if (temp != null)
                        msg.Append(" --> ");
                }

                int hRecord = NativeMethods.MsiCreateRecord(2);
                if (hRecord != 0) {
                    int err = NativeMethods.MsiRecordSetInteger(hRecord, 1, 1001 ); // 1 = Error, 2 = Warning
                    if (err == 0) {
                        err = NativeMethods.MsiRecordSetStringW(hRecord, 2, msg.ToString());
                        if (err == 0) {
                            NativeMethods.MsiProcessMessage(hInstall, NativeMethods.INSTALLMESSAGE_ERROR, hRecord);
                        }
                    }
                }
                
                return -1;
            }
            
            return 0;
        }

        /// <include file='doc\ManagedInstaller.uex' path='docs/doc[@for="ManagedInstallerClass.InstallHelper"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void InstallHelper(string[] args) { 
            bool uninstall = false;
            bool isAssemblyName = false;
            TransactedInstaller topLevelInstaller = new TransactedInstaller();
            bool showHelp = false;

            try {

                /*
                StreamWriter stream = new StreamWriter("c:\\installutilargs.txt", true);
                stream.WriteLine("----------");
                for (int i = 0; i < args.Length; i++)
                    stream.WriteLine(args[i]);
                stream.Close();
                */
                

                // strategy: Use a TransactedInstaller to manage the top-level installation work.
                // It will perform rollback/commit as necessary. Go through the assemblies on the
                // command line and add an AssemblyInstaller for each of them to the TransactedInstaller's
                // Installers collection.
                //
                // as we walk the parameters, we'll encounter either a filename or a
                // parameter. If we get to a filename, create an assembly installer with
                // all of the parameters we've seen _so far_. This way parameters can
                // be different for the different assemblies.

                ArrayList parameters = new ArrayList();
                for (int i = 0; i < args.Length; i++) {
                    if (args[i].StartsWith("/") || args[i].StartsWith("-")) {
                        string str = args[i].Substring(1);
                        if (string.Compare(str, "u", true, CultureInfo.InvariantCulture) == 0 || string.Compare(str, "uninstall", true, CultureInfo.InvariantCulture) == 0)
                            uninstall = true;
                        else if (string.Compare(str, "?", true, CultureInfo.InvariantCulture) == 0 || string.Compare(str, "help", true, CultureInfo.InvariantCulture) == 0)
                            showHelp = true;
                        else if (string.Compare(str, "AssemblyName", true, CultureInfo.InvariantCulture) == 0)
                            isAssemblyName = true;
                        else                             
                            parameters.Add(args[i]);
                    }
                    else {
                        Assembly asm = null;
                        try {
                            if (isAssemblyName) {
                                asm = Assembly.Load(args[i]);
                            }
                            else {
                                asm = Assembly.LoadFrom(args[i]);
                            }
                        }
                        catch (Exception e) {
                            if (args[i].IndexOf('=') != -1) {
                                // probably a mistake where /key=value was written as key=value,
                                // try to explain that
                                throw new ArgumentException(Res.GetString(Res.InstallFileDoesntExistCommandLine, args[i]), e);
                            }
                            else {
                                // the assembly.Load{From} gives a good descriptive error - pass it up
                                throw;
                            }
                        }

                        AssemblyInstaller installer = new AssemblyInstaller(asm, (string[]) parameters.ToArray(typeof(string)));
                        topLevelInstaller.Installers.Add(installer);
                    }
                }

                if (showHelp || topLevelInstaller.Installers.Count == 0) {
                    // we may have seen some options, but they didn't tell us to do any
                    // work. Or they gave us /? or /help. Show the help screen.
                    showHelp = true;
                    topLevelInstaller.Installers.Add(new AssemblyInstaller());
                    throw new InvalidOperationException(GetHelp(topLevelInstaller));
                }

                topLevelInstaller.Context = new InstallContext("InstallUtil.InstallLog", (string[]) parameters.ToArray(typeof(string)));

            }
            catch (Exception e) {
                if (showHelp) {
                    // it's just the help message
                    throw e;
                }
                else {
                    throw new InvalidOperationException(Res.GetString(Res.InstallInitializeException, e.GetType().FullName, e.Message));
                }
            }

            try {
                // MSI mode.
                // If the parameter /installtype=notransaction is specified, then we don't want to run
                // a TransactedInstaller. Instead, we just use that installer as a container for all
                // the AssemblyInstallers we want to run.
                string installType = topLevelInstaller.Context.Parameters["installtype"];
                if (installType != null && string.Compare(installType, "notransaction", true, CultureInfo.InvariantCulture) == 0) {
                    // this is a non-transacted install. Check the value of the Action parameter
                    // to see what to do
                    string action = topLevelInstaller.Context.Parameters["action"];
                    if (action != null && string.Compare(action, "rollback", true, CultureInfo.InvariantCulture) == 0) {
                        topLevelInstaller.Context.LogMessage( Res.GetString(Res.InstallRollbackNtRun) );
                        for (int i = 0; i < topLevelInstaller.Installers.Count; i++)
                            topLevelInstaller.Installers[i].Rollback(null);
                        return;
                    }
                    if (action != null && string.Compare(action, "commit", true, CultureInfo.InvariantCulture) == 0) {
                        topLevelInstaller.Context.LogMessage( Res.GetString(Res.InstallCommitNtRun) );
                        for (int i = 0; i < topLevelInstaller.Installers.Count; i++)
                            topLevelInstaller.Installers[i].Commit(null);
                        return;
                    }
                    if (action != null && string.Compare(action, "uninstall", true, CultureInfo.InvariantCulture) == 0) {
                        topLevelInstaller.Context.LogMessage( Res.GetString(Res.InstallUninstallNtRun) );
                        for (int i = 0; i < topLevelInstaller.Installers.Count; i++)
                            topLevelInstaller.Installers[i].Uninstall(null);
                        return;
                    }
                    // they said notransaction, and they didn't tell us to do rollback, commit,
                    // or uninstall. They must mean install.
                    topLevelInstaller.Context.LogMessage( Res.GetString(Res.InstallInstallNtRun) );
                    for (int i = 0; i < topLevelInstaller.Installers.Count; i++)
                        topLevelInstaller.Installers[i].Install(null);
                    return;

                }

                // transacted mode - we'll only get here if /installtype=notransaction wasn't specified.
                if (!uninstall) {
                    IDictionary stateSaver = new Hashtable();
                    topLevelInstaller.Install(stateSaver);
                    // we don't bother writing out the saved state for this guy, because each assembly
                    // we're installing gets its own saved-state file.
                }
                else {
                    topLevelInstaller.Uninstall(null);
                }

            }

            catch (Exception e) {
                /*
                StreamWriter stream = new StreamWriter("c:\\installutilargs.txt", true);
                stream.WriteLine("Caught exception: " + e.GetType().FullName + ": " + e.Message);
                stream.WriteLine(e.StackTrace);
                stream.Close();
                */

                throw e;
            }

            /*
            StreamWriter stream2 = new StreamWriter("c:\\installutilargs.txt", true);
            stream2.WriteLine("Caught no exceptions. Returning 0.");
            stream2.Close();
            */

            return;
        }

        private static string GetHelp(Installer installerWithHelp) {
            return Res.GetString(Res.InstallHelpMessageStart)   + Environment.NewLine + 
                   installerWithHelp.HelpText                   + Environment.NewLine +
                   Res.GetString(Res.InstallHelpMessageEnd)     + Environment.NewLine;
        }

        static string[] StringToArgs(string cmdLine) {
            ArrayList args = new ArrayList();
            StringBuilder nextArg = null;
            bool inString = false;
            bool escaped = false;
            
            for (int pos = 0; pos < cmdLine.Length; pos++) {
                char ch = cmdLine[pos];            
    
                if (nextArg == null) {
                    if (Char.IsWhiteSpace(ch)) {
                        continue;
                    } else {
                        nextArg = new StringBuilder();
                    }
                }
     
                if (inString) {
                    if (escaped) {
                        if (ch != '\\' && ch != '\"')                 
                            nextArg.Append('\\');                     
                        escaped = false;
                        nextArg.Append(ch);  
                    } else if (ch == '\"') {
                        inString = false;
                    } else if (ch == '\\') {
                        escaped = true;
                    } else {
                        nextArg.Append(ch);
                    }
                }
                else {
                    if (Char.IsWhiteSpace(ch)) {
                        args.Add(nextArg.ToString());
                        nextArg = null;              
                        escaped = false;      
                    } else if (escaped) {
                        nextArg.Append(ch);
                        escaped = false;
                    } else if (ch == '^') {
                        escaped = true;
                    } else if (ch == '\"') {
                        inString = true;
                    } else {
                        nextArg.Append(ch);
                    }                
                }
                
            }
    
            if (nextArg != null)
                args.Add(nextArg.ToString());
    
            string[] argsArray = new string[args.Count];
            args.CopyTo(argsArray);
    
            return argsArray;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\installevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {

    using System.Diagnostics;

    using System;
    using System.Collections;


/// <include file='doc\InstallEvent.uex' path='docs/doc[@for="InstallEventArgs"]/*' />
/// <devdoc>
///    <para>
///       Provides data for the <see cref='System.Configuration.Install.Installer.OnBeforeInstall'/>, <see cref='System.Configuration.Install.Installer.OnAfterInstall'/>, <see cref='System.Configuration.Install.Installer.OnCommitting'/>, <see cref='System.Configuration.Install.Installer.OnCommitted'/>, <see cref='System.Configuration.Install.Installer.OnBeforeRollback'/>, <see cref='System.Configuration.Install.Installer.OnAfterRollback'/>, <see cref='System.Configuration.Install.Installer.OnBeforeUninstall'/>, and <see cref='System.Configuration.Install.Installer.OnAfterUninstall'/> events.
///    </para>
/// </devdoc>
    public class InstallEventArgs : EventArgs {
        private IDictionary savedState;
        /// <include file='doc\InstallEvent.uex' path='docs/doc[@for="InstallEventArgs.InstallEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Configuration.Install.InstallEventArgs'/>
        ///       class, leaving the <paramref name="savedState"/>
        ///       field empty.
        ///    </para>
        /// </devdoc>
        public InstallEventArgs() : base() {
        }

        /// <include file='doc\InstallEvent.uex' path='docs/doc[@for="InstallEventArgs.InstallEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Configuration.Install.InstallEventArgs'/> class, with the saved state
        ///       parameter.
        ///    </para>
        /// </devdoc>
        public InstallEventArgs(IDictionary savedState) : base() {
            this.savedState = savedState;
        }
        
        /// <include file='doc\InstallEvent.uex' path='docs/doc[@for="InstallEventArgs.SavedState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An <see cref='System.Collections.IDictionary'/>
        ///       that represents the current state of the installation.
        ///    </para>
        /// </devdoc>
        public IDictionary SavedState {
            get {
                return this.savedState;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\installer.cs ===
//------------------------------------------------------------------------------
// <copyright file="Installer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration.Install {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Configuration;
    using System;
    using Microsoft.Win32;
    using System.Collections;    
    using System.Windows.Forms;

    /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides
    ///       a basic framework for doing installations.
    ///    </para>
    /// </devdoc>
    [
    Designer("Microsoft.VisualStudio.Configuration.InstallerDesigner, " + AssemblyRef.MicrosoftVisualStudio, typeof(IRootDesigner)),
    DefaultEvent("AfterInstall")
    ]
    public class Installer : Component {

        private InstallerCollection installers;
        private InstallContext context;
        internal Installer parent;

        private InstallEventHandler afterCommitHandler;
        private InstallEventHandler afterInstallHandler;
        private InstallEventHandler afterRollbackHandler;
        private InstallEventHandler afterUninstallHandler;
        private InstallEventHandler beforeCommitHandler;
        private InstallEventHandler beforeInstallHandler;
        private InstallEventHandler beforeRollbackHandler;
        private InstallEventHandler beforeUninstallHandler;

        private const string wrappedExceptionSource = Res.WrappedExceptionSource;

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Context"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets information about the current installation.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public InstallContext Context {
            get {
                return context;
            }
            set {
                context = value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.HelpText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the help text for all of the <see cref='System.Configuration.Install.Installer'/> objects contained in
        ///       the <see cref='System.Configuration.Install.Installer.Installers'/> collection of this installer instance.
        ///    </para>
        /// </devdoc>
        public virtual string HelpText {
            get {
                StringBuilder containedHelp = new StringBuilder();
                for (int i = 0; i < Installers.Count; i++) {
                    string help = Installers[i].HelpText;
                    if (help.Length > 0) {
                        containedHelp.Append("\r\n");
                        containedHelp.Append(help);
                    }
                }
                return containedHelp.ToString();
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Installers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of <see cref='System.Configuration.Install.Installer'/> objects contained in this <see cref='System.Configuration.Install.Installer'/>
        ///       instance.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
        public InstallerCollection Installers {
            get {
                if (installers == null)
                    installers = new InstallerCollection(this);

                return installers;
            }
        }

        
        internal bool InstallerTreeContains(Installer target) {
            if (Installers.Contains(target))
                return true;

            foreach (Installer child in Installers)
                if (child.InstallerTreeContains(target))
                    return true;

            return false;
        }
        
        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Parent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Configuration.Install.Installer'/> whose <see cref='System.Configuration.Install.InstallerCollection'/> contains this <see cref='System.Configuration.Install.Installer'/>
        ///       instance.
        ///    </para>
        /// </devdoc>
        [Browsable(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), TypeConverter("System.Configuration.Design.InstallerParentConverter")]
        public Installer Parent {
            get {
                return parent;
            }
            set {
                if (value == this)
                    throw new InvalidOperationException(Res.GetString(Res.InstallBadParent));

                if (value == parent) {
                    // nothing to do
                    return;
                }

                if (value != null && InstallerTreeContains(value)) {
                    throw new InvalidOperationException(Res.GetString(Res.InstallRecursiveParent));
                }

                if (parent != null) {
                    int index = parent.Installers.IndexOf(this);
                    if (index != -1)
                        parent.Installers.RemoveAt(index);
                }
                parent = value;
                if (parent != null && !parent.Installers.Contains(this))
                    parent.Installers.Add(this);
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Committed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs after the
        ///       installations handled by the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance are committed.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler Committed {
            add {
                afterCommitHandler += value;
            }
            remove {
                afterCommitHandler -= value;
            }
        }
        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.AfterInstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs after the <see cref='System.Configuration.Install.Installer.Install'/> methods
        ///       of all the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance have run.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler AfterInstall {
            add {
                afterInstallHandler += value;
            }
            remove {
                afterInstallHandler -= value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.AfterRollback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs after the
        ///       installations handled by the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of
        ///       this instance are rolled back.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler AfterRollback {
            add {
                afterRollbackHandler += value;
            }
            remove {
                afterRollbackHandler -= value;
            }
        }


        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.AfterUninstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs after the
        ///       installations handled by the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance are uninstalled.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler AfterUninstall {
            add {
                afterUninstallHandler += value;
            }
            remove {
                afterUninstallHandler -= value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Committing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs before the
        ///       installations handled by the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance are committed.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler Committing {
            add {
                beforeCommitHandler += value;
            }                                                                                                                    
            remove {
                beforeCommitHandler -= value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.BeforeInstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs before the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance are run.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler BeforeInstall {
            add {
                beforeInstallHandler += value;
            }
            remove {
                beforeInstallHandler -= value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.BeforeRollback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs before the
        ///       installations handled by the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance are rolled back.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler BeforeRollback {
            add {
                beforeRollbackHandler += value;
            }
            remove {
                beforeRollbackHandler -= value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.BeforeUninstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs before the
        ///       installations handled by the installers in the <see cref='System.Configuration.Install.InstallerCollection'/> of this instance are uninstalled.
        ///    </para>
        /// </devdoc>
        public event InstallEventHandler BeforeUninstall {
            add {
                beforeUninstallHandler += value;
            }
            remove {
                beforeUninstallHandler -= value;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Commit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Completes the install transaction.
        ///    </para>
        /// </devdoc>
        public virtual void Commit(IDictionary savedState) {
            // check arguments
            if (savedState == null)
                throw new ArgumentException(Res.GetString(Res.InstallNullParameter, "savedState"));
            if (savedState["_reserved_lastInstallerAttempted"] == null || savedState["_reserved_nestedSavedStates"] == null)
                throw new ArgumentException(Res.GetString(Res.InstallDictionaryMissingValues, "savedState"));

            Exception savedException = null;
            // raise the OnCommitting event
            try {
                OnCommitting(savedState);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityWarning), "OnCommitting", e);
                Context.LogMessage(Res.GetString(Res.InstallCommitException));
                savedException = e;
            }

            // do the commit

            int lastInstallerAttempted = (int) savedState["_reserved_lastInstallerAttempted"];
            IDictionary[] nestedSavedStates = (IDictionary[]) savedState["_reserved_nestedSavedStates"];
            // do more validation
            if (lastInstallerAttempted + 1 != nestedSavedStates.Length || lastInstallerAttempted >= Installers.Count)
                throw new ArgumentException(Res.GetString(Res.InstallDictionaryCorrupted, "savedState"));
            for (int i = 0; i < Installers.Count; i++) {
                // set all the contexts first.  see note in Install
                Installers[i].Context = Context;
            }
            for (int i = 0; i <= lastInstallerAttempted; i++) {
                try {
                    Installers[i].Commit(nestedSavedStates[i]);
                }
                catch (Exception e) {
                    if (!IsWrappedException(e)) {
                        // only print the message if this is not a wrapper around an exception we already printed out.
                        Context.LogMessage(Res.GetString(Res.InstallLogCommitException, Installers[i].ToString()));
                        LogException(e, Context);
                        Context.LogMessage(Res.GetString(Res.InstallCommitException));
                    }
                    savedException = e;
                }
            }
            // make sure if the nested installers changed thier state, that gets saved out.
            savedState["_reserved_nestedSavedStates"] = nestedSavedStates;
            // no point in keeping this around, since we know they all succeeded.
            savedState.Remove("_reserved_lastInstallerAttempted");

            // raise the OnCommitted event
            try {
                OnCommitted(savedState);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityWarning), "OnCommitted", e);
                Context.LogMessage(Res.GetString(Res.InstallCommitException));
                savedException = e;
            }

            if (savedException != null) {
                Exception wrappedException = savedException;
                if (!IsWrappedException(savedException)) {
                    wrappedException = new InstallException(Res.GetString(Res.InstallCommitException), savedException);
                    wrappedException.Source = wrappedExceptionSource;
                }
                throw wrappedException;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Install"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs the installation.
        ///    </para>
        /// </devdoc>
        public virtual void Install(IDictionary stateSaver) {
            // validate argument
            if (stateSaver == null)
                throw new ArgumentException(Res.GetString(Res.InstallNullParameter, "stateSaver"));

            // raise the OnBeforeInstall event
            try {
                OnBeforeInstall(stateSaver);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityError), "OnBeforeInstall", e);
                throw new InvalidOperationException(Res.GetString(Res.InstallEventException, "OnBeforeInstall", GetType().FullName), e);
            }

            // perform the install
            int lastInstallerAttempted = -1;
            ArrayList savedStates = new ArrayList();
            try {
                for (int i = 0; i < Installers.Count; i++) {
                    // Pass down our context to each of the contained installers.
                    // We set all of the contexts before calling any installers just
                    // in case one contained installer gets another to examine its
                    // context before installation (as in the case of ServiceInstallers).
                    Installers[i].Context = Context;
                }
                for (int i = 0; i < Installers.Count; i++) {
                    Installer installer = Installers[i];
                    // each contained installer gets a new IDictionary to write to. This way
                    // there can be no name conflicts between installers.
                    IDictionary nestedStateSaver = new Hashtable();
                    try {
                        lastInstallerAttempted = i;
                        installer.Install(nestedStateSaver);
                    }
                    finally {
                        savedStates.Add(nestedStateSaver);
                    }
                }
            }
            finally {
                stateSaver.Add("_reserved_lastInstallerAttempted", lastInstallerAttempted);
                stateSaver.Add("_reserved_nestedSavedStates", savedStates.ToArray(typeof(IDictionary)));
            }

            // raise the OnAfterInstall event
            try {
                OnAfterInstall(stateSaver);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityError), "OnAfterInstall", e);
                throw new InvalidOperationException(Res.GetString(Res.InstallEventException, "OnAfterInstall", GetType().FullName), e);
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.LogException"]/*' />
        /// <devdoc>
        /// Writes exception information for the given inner exception and any
        /// inner exceptions it may have to the given context object.
        /// </devdoc>
        internal static void LogException(Exception e, InstallContext context) {
            bool toplevel = true;
            while (e != null) {
                if (toplevel) {
                    context.LogMessage(e.GetType().FullName + ": " + e.Message);
                    toplevel = false;
                }
                else
                    context.LogMessage(Res.GetString(Res.InstallLogInner, e.GetType().FullName, e.Message));
                if (context.IsParameterTrue("showcallstack"))
                    context.LogMessage(e.StackTrace);
                e = e.InnerException;
            }
        }

        private bool IsWrappedException(Exception e) {
            return e is InstallException && e.Source == wrappedExceptionSource && e.TargetSite.ReflectedType == typeof(Installer);
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnCommitted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnCommitted'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnCommitted(IDictionary savedState) {
            if (afterCommitHandler != null)
                afterCommitHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnAfterInstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnAfterInstall'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnAfterInstall(IDictionary savedState) {
            if (afterInstallHandler != null)
                afterInstallHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnAfterRollback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnAfterRollback'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnAfterRollback(IDictionary savedState) {
            if (afterRollbackHandler != null)
                afterRollbackHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnAfterUninstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnAfterUninstall'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnAfterUninstall(IDictionary savedState) {
            if (afterUninstallHandler != null)
                afterUninstallHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnCommitting"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnCommitting'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnCommitting(IDictionary savedState) {
            if (beforeCommitHandler != null)
                beforeCommitHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnBeforeInstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnBeforeInstall'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnBeforeInstall(IDictionary savedState) {
            if (beforeInstallHandler != null)
                beforeInstallHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnBeforeRollback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnBeforeRollback'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnBeforeRollback(IDictionary savedState) {
            if (beforeRollbackHandler != null)
                beforeRollbackHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.OnBeforeUninstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Configuration.Install.Installer.OnBeforeUninstall'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnBeforeUninstall(IDictionary savedState) {
            if (beforeUninstallHandler != null)
                beforeUninstallHandler(this, new InstallEventArgs(savedState));
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Rollback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Restores the machine to the state it was in before
        ///       the <see cref='System.Configuration.Install.Installer.Install'/>
        ///       method was called.
        ///    </para>
        /// </devdoc>
        public virtual void Rollback(IDictionary savedState) {
            // check arguments
            if (savedState == null)
                throw new ArgumentException(Res.GetString(Res.InstallNullParameter, "savedState"));
            if (savedState["_reserved_lastInstallerAttempted"] == null || savedState["_reserved_nestedSavedStates"] == null)
                throw new ArgumentException(Res.GetString(Res.InstallDictionaryMissingValues, "savedState"));

            // raise the OnBeforeRollback event
            Exception savedException = null;
            try {
                OnBeforeRollback(savedState);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityWarning), "OnBeforeRollback", e);
                Context.LogMessage(Res.GetString(Res.InstallRollbackException));
                savedException = e;
            }

            // do the rollback

            int lastInstallerAttempted = (int) savedState["_reserved_lastInstallerAttempted"];
            IDictionary[] nestedSavedStates = (IDictionary[]) savedState["_reserved_nestedSavedStates"];
            // do more validation
            if (lastInstallerAttempted + 1 != nestedSavedStates.Length || lastInstallerAttempted >= Installers.Count)
                throw new ArgumentException(Res.GetString(Res.InstallDictionaryCorrupted, "savedState"));
            for (int i = Installers.Count - 1; i >= 0; i--) {
                // set all the contexts first.  see note in Install
                Installers[i].Context = Context;
            }
            for (int i = lastInstallerAttempted; i >= 0; i--) {
                try {
                    Installers[i].Rollback(nestedSavedStates[i]);
                }
                catch (Exception e) {
                    if (!IsWrappedException(e)) {
                        // only print the message if this is not a wrapper around an exception we already printed out.
                        Context.LogMessage(Res.GetString(Res.InstallLogRollbackException, Installers[i].ToString()));
                        LogException(e, Context);
                        Context.LogMessage(Res.GetString(Res.InstallRollbackException));
                    }
                    savedException = e;
                }
            }
            // no point in doing anything to the saved state, because it'll all be
            // thrown away at the top anyway.

            // raise the OnAfterRollback event
            try {
                OnAfterRollback(savedState);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityWarning), "OnAfterRollback", e);
                Context.LogMessage(Res.GetString(Res.InstallRollbackException));
                savedException = e;
            }

            if (savedException != null) {
                Exception wrappedException = savedException;
                if (!IsWrappedException(savedException)) {
                    wrappedException = new InstallException(Res.GetString(Res.InstallRollbackException), savedException);
                    wrappedException.Source = wrappedExceptionSource;
                }
                throw wrappedException;
            }
        }

        /// <include file='doc\Installer.uex' path='docs/doc[@for="Installer.Uninstall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes an installation.
        ///    </para>
        /// </devdoc>
        public virtual void Uninstall(IDictionary savedState) {
            // raise the OnBeforeUninstall event
            Exception savedException = null;
            try {
                OnBeforeUninstall(savedState);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityWarning), "OnBeforeUninstall", e);
                Context.LogMessage(Res.GetString(Res.InstallUninstallException));
                savedException = e;
            }

            // do the uninstall

            // uninstall is special: savedState can be null. (The state file may have been deleted since
            // the application was installed.) If it isn't, we read state out as usual. Otherwise we create
            // some new, empty state to pass to the contained installers.
            IDictionary[] nestedSavedStates;
            if (savedState != null) {
                nestedSavedStates = (IDictionary[]) savedState["_reserved_nestedSavedStates"];
                if (nestedSavedStates.Length != Installers.Count)
                    throw new ArgumentException(Res.GetString(Res.InstallDictionaryCorrupted, "savedState"));
            }
            else
                nestedSavedStates = new IDictionary[Installers.Count];
            //go in reverse order when uninstalling
            for (int i = Installers.Count - 1; i >= 0; i--) {
                // set all the contexts first.  see note in Install
                Installers[i].Context = Context;
            }
            for (int i = Installers.Count - 1; i >= 0; i--) {
                try {
                    Installers[i].Uninstall(nestedSavedStates[i]);
                }
                catch (Exception e) {
                    if (!IsWrappedException(e)) {
                        // only print the message if this is not a wrapper around an exception we already printed out.
                        Context.LogMessage(Res.GetString(Res.InstallLogUninstallException, Installers[i].ToString()));
                        LogException(e, Context);
                        Context.LogMessage(Res.GetString(Res.InstallUninstallException));
                    }
                    savedException  = e;
                }
            }

            // raise the OnAfterUninstall event
            try {
                OnAfterUninstall(savedState);
            }
            catch (Exception e) {
                WriteEventHandlerError(Res.GetString(Res.InstallSeverityWarning), "OnAfterUninstall", e);
                Context.LogMessage(Res.GetString(Res.InstallUninstallException));
                savedException = e;
            }

            if (savedException != null) {
                Exception wrappedException = savedException;
                if (!IsWrappedException(savedException)) {
                    wrappedException = new InstallException(Res.GetString(Res.InstallUninstallException), savedException);
                    wrappedException.Source = wrappedExceptionSource;
                }
                throw wrappedException;
            }
        }

        private void WriteEventHandlerError(string severity, string eventName, Exception e) {
            Context.LogMessage(Res.GetString(Res.InstallLogError, severity, eventName, GetType().FullName));
            LogException(e, Context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration.Install {
    using System;    
    using System.Runtime.InteropServices;    
    using System.ComponentModel;

    // not public!
    internal sealed class NativeMethods {
        [DllImport(ExternDll.Msi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int MsiCreateRecord(int cParams);
    
        [DllImport(ExternDll.Msi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int MsiRecordSetInteger(int hRecord, int iField, int iValue);
    
        [DllImport(ExternDll.Msi, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern int MsiRecordSetStringW(int hRecord, int iField, string szValue);

        [DllImport(ExternDll.Msi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int MsiProcessMessage(int hInstall, int messageType, int hRecord); 
        
        public const int INSTALLMESSAGE_ERROR = 0x01000000;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\serializableregistrykey.cs ===
//------------------------------------------------------------------------------
// <copyright file="SerializableRegistryKey.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.ComponentModel;
    using System.Diagnostics;
//    using System.Windows.Forms;
    using System;
    using System.Collections;    
    using Microsoft.Win32;
//    using System.Configuration.Install;
    
    [Serializable()]
    internal class SerializableRegistryKey {
        // these fields are public so that they can be serialized.
        public string[] ValueNames;
        public object[] Values;
        public string[] KeyNames;
        public SerializableRegistryKey[] Keys;

        public SerializableRegistryKey() {
        }

        public SerializableRegistryKey(RegistryKey keyToSave) {
            CopyFromRegistry(keyToSave);
        }

        public void CopyFromRegistry(RegistryKey keyToSave) {
            if (keyToSave == null)
                throw new ArgumentNullException("keyToSave");

            ValueNames = keyToSave.GetValueNames();
            //RegistryKey might return null on this call, if no values are
            //available.
            if (ValueNames == null)
                ValueNames = new string[0];
            Values = new object[ValueNames.Length];
            for (int i = 0; i < ValueNames.Length; i++) {
                Values[i] = keyToSave.GetValue(ValueNames[i]);
            }

            KeyNames = keyToSave.GetSubKeyNames();
            //RegistryKey might return null on this call, if no values are
            //available.
            if (KeyNames == null)
                KeyNames = new string[0];
            Keys = new SerializableRegistryKey[KeyNames.Length];
            for (int i = 0; i < KeyNames.Length; i++)
                Keys[i] = new SerializableRegistryKey(keyToSave.OpenSubKey(KeyNames[i]));
        }

        public void CopyToRegistry(RegistryKey baseKey) {
            if (baseKey == null)
                throw new ArgumentNullException("baseKey");

            if (Values != null) {
                for (int i = 0; i < Values.Length; i++)
                    baseKey.SetValue(ValueNames[i], Values[i]);
            }

            if (Keys != null) {
                for (int i = 0; i < Keys.Length; i++) {
                    RegistryKey key = baseKey.CreateSubKey(KeyNames[i]);
                    Keys[i].CopyToRegistry(key);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\uninstallaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="UninstallAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {

    using System.Diagnostics;

    /// <include file='doc\UninstallAction.uex' path='docs/doc[@for="UninstallAction"]/*' />
    /// <devdoc>
    ///    <para> An enum of what an installer can do at uninstall time.
    ///       It can either remove the resource it created, or do nothing (leaving the resource as installed).</para>
    /// </devdoc>
    public enum UninstallAction {
        /// <include file='doc\UninstallAction.uex' path='docs/doc[@for="UninstallAction.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Remove,
        /// <include file='doc\UninstallAction.uex' path='docs/doc[@for="UninstallAction.NoAction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoAction
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\transactedinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="TransactedInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Configuration.Install {

    using System.Diagnostics;

    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;
    
    /// <include file='doc\TransactedInstaller.uex' path='docs/doc[@for="TransactedInstaller"]/*' />
    /// <devdoc>
    /// A transacted install will either completely succeed or fail and leave the
    /// machine in its initial state. To run installers in a transaction, add them
    /// to the Installers collection of this class.
    /// </devdoc>
    public class TransactedInstaller : Installer {

        // A transacted install will either completely succeed or fail and leave the
        // machine in its initial state. The Install method is called on each of the
        // installers. If they all succeed, then the Commit method is called on each
        // of them. If any of the Install methods fails, then that installer's Rollback
        // method is called, as are the Rollback methods on all the installers whose
        // Install methods ran before the failure.
        /// <include file='doc\TransactedInstaller.uex' path='docs/doc[@for="TransactedInstaller.Install"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Install(IDictionary savedState) {
            if (Context == null)
                Context = new InstallContext("con", new string[0]);

            Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoTransacted));
            try {
                bool success = true;
                try {
                    Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoBeginInstall));
                    base.Install(savedState);
                }
                catch (Exception e) {
                    success = false;
                    Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoException));
                    Installer.LogException(e, Context);

                    Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoBeginRollback));
                    try {
                        Rollback(savedState);
                    }
                    catch (Exception) {
                    }
                    Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoRollbackDone));

                    // make sure the failure goes all the way to the top.
                    throw new InvalidOperationException(Res.GetString(Res.InstallRollback), e);
                }
                if (success) {
                    Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoBeginCommit));
                    try {
                        Commit(savedState);
                    }
                    finally {
                        Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoCommitDone));
                    }
                }
            }
            finally {
                Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoTransactedDone));
            }
        }

        /// <include file='doc\TransactedInstaller.uex' path='docs/doc[@for="TransactedInstaller.Uninstall"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Uninstall(IDictionary savedState) {
            if (Context == null)
                Context = new InstallContext("con", new string[0]);

            Context.LogMessage("\r\n\r\n" + Res.GetString(Res.InstallInfoBeginUninstall));
            try {
                base.Uninstall(savedState);
            }
            finally {
                Context.LogMessage("\r\n" + Res.GetString(Res.InstallInfoUninstallDone));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\authenticationtypes.cs ===
//------------------------------------------------------------------------------
// <copyright file="AuthenticationTypes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {    
    using System;    
    using System.DirectoryServices.Interop;

    /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies what kind of acknowledgment to get after sending a message.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum AuthenticationTypes {
            
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.None"]/*' />
        None = 0,               
               
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.Secure"]/*' />
        /// <devdoc>
        ///     Requests secure authentication. When this flag is set, the WinNT provider uses NT LAN Manager (NTLM) 
        ///     to authenticate the client. Active Directory will use Kerberos, and possibly NTLM, to authenticate the client. 
        /// </devdoc>
        Secure = NativeMethods.AuthenticationModes.SecureAuthentication,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.Encription"]/*' />
        /// <devdoc>
        ///     Forces ADSI to use encryption for data exchange over the network. 
        /// </devdoc>
        Encryption = NativeMethods.AuthenticationModes.UseEncryption,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.SecureSocketsLayer"]/*' />
        /// <devdoc>
        ///     Encrypts the channel with SSL. Data will be encrypted using SSL. Active Directory requires that the 
        ///     Certificate Server be installed to support SSL encryption. 
        /// </devdoc>
        SecureSocketsLayer = NativeMethods.AuthenticationModes.UseSSL,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.ReadonlyServer"]/*' />
        /// <devdoc>
        ///     For a WinNT provider, ADSI tries to connect to a primary domain controller or a backup domain 
        ///     controller. For Active Directory, this flag indicates that a writeable server is not required for a 
        ///     serverless binding. 
        /// </devdoc>
        ReadonlyServer = NativeMethods.AuthenticationModes.ReadonlyServer,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.Anonymous"]/*' />
        /// <devdoc>
        ///     Request no authentication. The providers may attempt to bind client, as an anonymous user, to the targeted 
        ///     object. The WinNT provider does not support this flag. Active Directory establishes a connection between 
        ///     the client and the targeted object, but will not perform any authentication. Setting this flag amounts to 
        ///     requesting an anonymous binding, which means "Everyone" as the security context. 
        /// </devdoc>
        Anonymous = NativeMethods.AuthenticationModes.NoAuthentication,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.FastBind"]/*' />
        /// <devdoc>
        ///     When this flag is set, ADSI will not attempt to query the objectClass property and thus will only expose 
        ///     the base interfaces supported by all ADSI objects instead of the full object support. 
        /// </devdoc>
        FastBind = NativeMethods.AuthenticationModes.FastBind,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.Signing"]/*' />
        /// <devdoc>
        ///     Verifies data integrity to ensure the data received is the same as the data sent. The Secure flag 
        ///     must be set also in order to use the signing. 
        /// </devdoc>
        Signing = NativeMethods.AuthenticationModes.UseSigning,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.Sealing"]/*' />
        /// <devdoc>
        ///     Encrypts data using Kerberos. The Secure flag must be set also in order to use the sealing. 
        /// </devdoc>
        Sealing = NativeMethods.AuthenticationModes.UseSealing,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.Delegation"]/*' />
        /// <devdoc>
        ///     Enables ADSI to delegate the user's security context, which is necessary for moving objects across domains. 
        /// </devdoc>
        Delegation = NativeMethods.AuthenticationModes.UseDelegation,
        
        /// <include file='doc\AuthenticationTypes.uex' path='docs/doc[@for="AuthenticationTypes.ServerBind"]/*' />
        /// <devdoc>
        ///     Specify this flag when using the LDAP provider if your ADsPath includes a server name. Do not use 
        ///     this flag for paths that include a domain name or for serverless paths.
        /// </devdoc>
        ServerBind= NativeMethods.AuthenticationModes.UseServerBinding
        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directorydescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\DirectoryDescriptionAttribute.uex' path='docs/doc[@for="DSDescriptionAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>DescriptionAttribute marks a property, event, or extender with a
    ///       description. Visual designers can display this description when referencing
    ///       the member.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class DSDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\DirectoryDescriptionAttribute.uex' path='docs/doc[@for="DSDescriptionAttribute.DSDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public DSDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\DirectoryDescriptionAttribute.uex' path='docs/doc[@for="DSDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = Res.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\config\system\configuration\install\performancecounterinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Configuration.Install;
    using System.Globalization;
    
    /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PerformanceCounterInstaller : ComponentInstaller {

        private const string ServicePath = "SYSTEM\\CurrentControlSet\\Services";                
        private const string PerfShimName = "netfxperf.dll";
        private string categoryName = string.Empty;
        private CounterCreationDataCollection counters = new CounterCreationDataCollection();        
        private string categoryHelp = string.Empty;
        private UninstallAction uninstallAction = System.Configuration.Install.UninstallAction.Remove;

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.CategoryName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        ResDescription(Res.PCCategoryName),        
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]                                                      
        public string CategoryName {
            get {
                return categoryName;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                categoryName = value;
            }
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.CategoryHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        MonitoringDescription(Res.PCI_CategoryHelp)
        ]
        public string CategoryHelp {
            get {
                return categoryHelp;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                categoryHelp = value;
            }
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.Counters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content), 
        MonitoringDescription(Res.PCI_Counters)
        ]
        public CounterCreationDataCollection Counters {
            get {
                return counters;
            }
        }
        
        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.UninstallAction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(UninstallAction.Remove),
        MonitoringDescription(Res.PCI_UninstallAction)
        ]
        public UninstallAction UninstallAction {
            get {
                return uninstallAction;
            }
            set {
                if (!Enum.IsDefined(typeof(UninstallAction), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(UninstallAction));
            
                uninstallAction = value;
            }
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.CopyFromComponent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void CopyFromComponent(IComponent component) {
            if (!(component is PerformanceCounter))
                throw new ArgumentException(Res.GetString(Res.NotAPerformanceCounter));

            PerformanceCounter counter = (PerformanceCounter) component;

            if (counter.CategoryName == null || counter.CategoryName.Length == 0)
                throw new ArgumentException(Res.GetString(Res.IncompletePerformanceCounter));

            if (Counters.Count > 0 && !CategoryName.Equals(counter.CategoryName))
                throw new ArgumentException(Res.GetString(Res.NewCategory));

            PerformanceCounterType counterType = PerformanceCounterType.NumberOfItems32;
            string counterHelp = string.Empty;
            if (CategoryName == null || string.Empty.Equals(CategoryName)) {
                CategoryName = counter.CategoryName;
                if (Environment.OSVersion.Platform == PlatformID.Win32NT) {              
                    string machineName = counter.MachineName;
                        
                    if (PerformanceCounterCategory.Exists(CategoryName, machineName)) {                          
                        string keyPath = ServicePath + "\\" + CategoryName + "\\Performance";       
                        RegistryKey key = null;
                        try {                 
                            if (machineName == "." || String.Compare(machineName, SystemInformation.ComputerName, true, CultureInfo.InvariantCulture) == 0) {
                                key = Registry.LocalMachine.OpenSubKey(keyPath);                                                    
                            }                        
                            else {
                                RegistryKey baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "\\\\" + machineName);                    
                                key =  baseKey.OpenSubKey(keyPath);                                                    
                            }   
                                        
                            if (key == null) 
                                throw new ArgumentException(Res.GetString(Res.NotCustomPerformanceCategory));
                                
                            object systemDllName = key.GetValue("Library");                                            
                            if (systemDllName == null || !(systemDllName is string) || String.Compare((string)systemDllName, PerfShimName, true, CultureInfo.InvariantCulture) != 0) 
                                throw new ArgumentException(Res.GetString(Res.NotCustomPerformanceCategory));
    
                            PerformanceCounterCategory pcat = new PerformanceCounterCategory(CategoryName, machineName);                        
                            CategoryHelp = pcat.CategoryHelp;
                            if (pcat.CounterExists(counter.CounterName)) {                                                                                        
                                counterType = counter.CounterType;
                                counterHelp = counter.CounterHelp;
                            }                                                                                                                                                          
                        }
                        finally {
                            if (key != null)
                                key.Close();
                        }                        
                    }
                }                    
            }                                    

            CounterCreationData data = new CounterCreationData(counter.CounterName, counterHelp, counterType);
            Counters.Add(data);
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.DoRollback"]/*' />
        /// <devdoc>
        /// Restores the registry to how it was before install, as saved in the state dictionary.
        /// </devdoc>
        private void DoRollback(IDictionary state) {
            //we need to remove the category key OR put old data back into the key
            Context.LogMessage(Res.GetString(Res.RestoringPerformanceCounter, CategoryName));

            SerializableRegistryKey categoryKeyData = (SerializableRegistryKey) state["categoryKeyData"];

            RegistryKey servicesKey = Registry.LocalMachine.CreateSubKey("SYSTEM\\CurrentControlSet\\Services");            
            RegistryKey categoryKey = servicesKey.OpenSubKey(CategoryName);
            if (categoryKey != null) {
                categoryKey.Close();
                servicesKey.DeleteSubKeyTree(CategoryName);
            }
            //re-create key with old data ONLY if we had data saved into the hashtable
            if (categoryKeyData != null) {
                categoryKey = servicesKey.CreateSubKey(CategoryName);
                categoryKeyData.CopyToRegistry(categoryKey);
            }
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.Install"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Install(IDictionary stateSaver) {
            base.Install(stateSaver);

            Context.LogMessage(Res.GetString(Res.CreatingPerformanceCounter, CategoryName));

            RegistryKey categoryKey = null;
            RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Services", true);            
            if (servicesKey != null) {
                categoryKey = servicesKey.OpenSubKey(CategoryName);

                if (categoryKey != null) {
                    stateSaver["categoryKeyData"] = new SerializableRegistryKey(categoryKey);
                    categoryKey.Close();
                    servicesKey.DeleteSubKeyTree(CategoryName);

                }
            }

            PerformanceCounterCategory.Create(CategoryName, CategoryHelp, Counters);
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.Rollback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Rollback(IDictionary savedState) {
            base.Rollback(savedState);

            DoRollback(savedState);
        }

        /// <include file='doc\PerformanceCounterInstaller.uex' path='docs/doc[@for="PerformanceCounterInstaller.Uninstall"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Uninstall(IDictionary savedState) {
            base.Uninstall(savedState);

            if (UninstallAction == UninstallAction.Remove) {
                Context.LogMessage(Res.GetString(Res.RemovingPerformanceCounter, CategoryName));
                PerformanceCounterCategory.Delete(CategoryName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directorysearcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectorySearcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTPTRCAST = System.IntPtr;
using INTPTR_INTCAST    = System.Int32;
      
/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;
    using System.DirectoryServices.Design;
    using System.ComponentModel;
    using System.Security.Permissions;
    using Microsoft.Win32;

    /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher"]/*' />
    /// <devdoc>
    ///    <para> Performs queries against the Active Directory hierarchy.</para>
    /// </devdoc>
    public class DirectorySearcher : Component {

        private DirectoryEntry searchRoot;
        private string filter = defaultFilter;
        private StringCollection propertiesToLoad;
        private bool disposed = false;

        private static readonly TimeSpan minusOneSecond = new TimeSpan(0, 0, -1);

        // search preference variables
        private SearchScope scope = System.DirectoryServices.SearchScope.Subtree;
        private int sizeLimit = 0;
        private TimeSpan serverTimeLimit = minusOneSecond;
        private bool propertyNamesOnly = false;
        private TimeSpan clientTimeout = minusOneSecond;
        private int pageSize = 0;
        private TimeSpan serverPageTimeLimit = minusOneSecond;
        private ReferralChasingOption referralChasing = ReferralChasingOption.External;
        private SortOption sort = new SortOption();
        private bool cacheResults = true;
        private bool rootEntryAllocated = false;             // true: if a temporary entry inside Searcher has been created
        private string assertDefaultNamingContext = null;

        private const string defaultFilter = "(objectClass=*)";

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/>, 
        /// <see cref='System.DirectoryServices.DirectorySearcher.Filter'/>, <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/>, and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to their default values.</para>
        /// </devdoc>
        public DirectorySearcher() : this(null, defaultFilter, null, System.DirectoryServices.SearchScope.Subtree) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with 
        /// <see cref='System.DirectoryServices.DirectorySearcher.Filter'/>, <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/>, and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to their default 
        ///    values, and <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/> set to the given value.</para>
        /// </devdoc>
        public DirectorySearcher(DirectoryEntry searchRoot) : this(searchRoot, defaultFilter, null, System.DirectoryServices.SearchScope.Subtree) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with 
        /// <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/> and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to their default 
        ///    values, and <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/> and <see cref='System.DirectoryServices.DirectorySearcher.Filter'/> set to the respective given values.</para>
        /// </devdoc>
        public DirectorySearcher(DirectoryEntry searchRoot, string filter) : this(searchRoot, filter, null, System.DirectoryServices.SearchScope.Subtree) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with 
        /// <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to its default 
        ///    value, and <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/>, <see cref='System.DirectoryServices.DirectorySearcher.Filter'/>, and <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/> set to the respective given values.</para>
        /// </devdoc>
        public DirectorySearcher(DirectoryEntry searchRoot, string filter, string[] propertiesToLoad) : this(searchRoot, filter, propertiesToLoad, System.DirectoryServices.SearchScope.Subtree) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/>, 
        /// <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/>, and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to their default 
        ///    values, and <see cref='System.DirectoryServices.DirectorySearcher.Filter'/> set to the given value.</para>
        /// </devdoc>
        public DirectorySearcher(string filter) : this(null, filter, null, System.DirectoryServices.SearchScope.Subtree) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher5"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/> 
        /// and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to their default
        /// values, and <see cref='System.DirectoryServices.DirectorySearcher.Filter'/> and <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/> set to the respective given values.</para>
        /// </devdoc>
        public DirectorySearcher(string filter, string[] propertiesToLoad) : this(null, filter, propertiesToLoad, System.DirectoryServices.SearchScope.Subtree) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher6"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/> set to its default 
        ///    value, and <see cref='System.DirectoryServices.DirectorySearcher.Filter'/>, <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/>, and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> set to the respective given values.</para>
        /// </devdoc>
        public DirectorySearcher(string filter, string[] propertiesToLoad, SearchScope scope) : this(null, filter, propertiesToLoad, scope) {
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.DirectorySearcher7"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.DirectoryServices.DirectorySearcher'/> class with the <see cref='System.DirectoryServices.DirectorySearcher.SearchRoot'/>, <see cref='System.DirectoryServices.DirectorySearcher.Filter'/>, <see cref='System.DirectoryServices.DirectorySearcher.PropertiesToLoad'/>, and <see cref='System.DirectoryServices.DirectorySearcher.SearchScope'/> properties set to the given 
        ///    values.</para>
        /// </devdoc>
        public DirectorySearcher(DirectoryEntry searchRoot, string filter, string[] propertiesToLoad, SearchScope scope) {            
            this.searchRoot = searchRoot;
            this.filter = filter;
            if (propertiesToLoad != null)
                PropertiesToLoad.AddRange(propertiesToLoad);
            this.SearchScope = scope;
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.Dispose"]/*' />
        /// <devdoc>        
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            // safe to call while finalizing or disposing
            //
            if ( !this.disposed && disposing) {
                if ( rootEntryAllocated )
                    searchRoot.Dispose();
                rootEntryAllocated = false;    
                this.disposed = true;
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.CacheResults"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the result should be cached on the
        ///       client machine.
        ///    </para>
        /// </devdoc>
        [
            DefaultValue(true), 
            DSDescriptionAttribute(Res.DSCacheResults)
        ]                            
        public bool CacheResults {
            get {
                return cacheResults;
            }
            set {
                cacheResults = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.ClientTimeout"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the maximum amount of time that the client waits for
        ///       the server to return results. If the server does not respond within this time,
        ///       the search is aborted, and no results are returned.</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSClientTimeout)
        ]                    
        public TimeSpan ClientTimeout {
            get {
                return clientTimeout;
            }
            set {
                clientTimeout = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.PropertyNamesOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the search should retrieve only the names of requested
        ///       properties or the names and values of requested properties.</para>
        /// </devdoc>        
        [
            DefaultValue(false), 
            DSDescriptionAttribute(Res.DSPropertyNamesOnly)
        ]
        public bool PropertyNamesOnly {
            get {
                return propertyNamesOnly;
            }
            set {
                propertyNamesOnly = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.Filter"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the Lightweight Directory Access Protocol (LDAP) filter string
        ///       format.</para>
        ///    <![CDATA[ (objectClass=*) (!(objectClass=user)) (&(objectClass=user)(sn=Jones)) ]]>
        ///    </devdoc>
        [
            DefaultValue(defaultFilter), 
            DSDescriptionAttribute(Res.DSFilter),            
            TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
            RecommendedAsConfigurable(true)
        ]
        public string Filter {
            get {
                return filter;
            }
            set {
                if (value == null || value.Length == 0)
                    value = defaultFilter;
                filter = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.PageSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the page size in a paged search.</para>
        /// </devdoc>
        [
            DefaultValue(0), 
            DSDescriptionAttribute(Res.DSPageSize)                        
        ]
        public int PageSize {
            get {
                return pageSize;
            }
            set {
                if (value < 0)
                    throw new ArgumentException(Res.GetString(Res.DSBadPageSize));
                pageSize = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.PropertiesToLoad"]/*' />
        /// <devdoc>
        /// <para>Gets the set of properties retrieved during the search. By default, the <see cref='System.DirectoryServices.DirectoryEntry.Path'/>
        /// and <see cref='System.DirectoryServices.DirectoryEntry.Name'/> properties are retrieved.</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSPropertiesToLoad),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            Editor("System.Windows.Forms.Design.StringCollectionEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing)
        ]
        public StringCollection PropertiesToLoad {
            get {
                if (propertiesToLoad == null) {
                    propertiesToLoad = new StringCollection();
                }
                return propertiesToLoad;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.ReferralChasing"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets how referrals are chased.</para>
        /// </devdoc>
        [
            DefaultValue(ReferralChasingOption.External), 
            DSDescriptionAttribute(Res.DSReferralChasing)                                    
        ]
        public ReferralChasingOption ReferralChasing {
            get {
                return referralChasing;
            }
            set {
                if (!Enum.IsDefined(typeof(ReferralChasingOption), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ReferralChasingOption));
                    
                referralChasing = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.SearchScope"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the scope of the search that should be observed by the server.</para>
        /// </devdoc>
        [
            DefaultValue(SearchScope.Subtree), 
            DSDescriptionAttribute(Res.DSSearchScope),                                                
            RecommendedAsConfigurable(true)
        ]
        public SearchScope SearchScope {
            get {
                return scope;
            }
            set {
                if (!Enum.IsDefined(typeof(SearchScope), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(SearchScope));
                    
                scope = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.ServerPageTimeLimit"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the time limit that the server should 
        ///       observe to search a page of results (as opposed to
        ///       the time limit for the entire search).</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSServerPageTimeLimit)
        ]
        public TimeSpan ServerPageTimeLimit {
            get {
                return serverPageTimeLimit;
            }
            set {
                serverPageTimeLimit = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.ServerTimeLimit"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the maximum amount of time the server spends searching. If the
        ///       time limit is reached, only entries found up to that point will be returned.</para>
        /// </devdoc>
        [
             DSDescriptionAttribute(Res.DSServerTimeLimit)
        ]
        public TimeSpan ServerTimeLimit {
            get {
                return serverTimeLimit;
            }
            set {
                serverTimeLimit = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.SizeLimit"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the maximum number of objects that the 
        ///       server should return in a search.</para>
        /// </devdoc>
        [
            DefaultValue(0), 
            DSDescriptionAttribute(Res.DSSizeLimit)            
        ]
        public int SizeLimit {
            get {
                return sizeLimit;
            }
            set {
                if (value < 0)
                    throw new ArgumentException(Res.GetString(Res.DSBadPageSize));
                sizeLimit = value;
            }                                                                                 
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.SearchRoot"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the node in the Active Directory hierarchy 
        ///       at which the search will start.</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSSearchRoot),
            DefaultValueAttribute(null)            
        ]
        public DirectoryEntry SearchRoot {
            get {
                if (searchRoot == null && !DesignMode) {
                    if (GetAdsVersion().Major < 5)
                        return null;
                                                                                        
                    // get the default naming context. This should be the default root for the search.
                    DirectoryEntry rootDSE = new DirectoryEntry("LDAP://RootDSE");
                    
                    //SECREVIEW: Searching the root of the DS will demand browse permissions
                    //                     on "*" or "LDAP://RootDSE".
                    string defaultNamingContext = (string) rootDSE.Properties["defaultNamingContext"][0];
                    rootDSE.Dispose();
                                                            
                    searchRoot = new DirectoryEntry("LDAP://" + defaultNamingContext);
                    rootEntryAllocated = true;    
                    assertDefaultNamingContext = "LDAP://" + defaultNamingContext;
                    
                }
                return searchRoot;
            }
            set {
                if ( rootEntryAllocated )
                    searchRoot.Dispose();
                rootEntryAllocated = false;    

                assertDefaultNamingContext = null;
                searchRoot = value;
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.Sort"]/*' />
        /// <devdoc>
        ///    <para>Gets the property on which the results should be 
        ///       sorted.</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSSort),
            TypeConverterAttribute(typeof(ExpandableObjectConverter)),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content)
        ]
        public SortOption Sort {
            get {
                return sort;
            }
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                
                sort = value;                    
            }
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.FindOne"]/*' />
        /// <devdoc>
        ///    <para>Executes the search and returns only the first entry that is found.</para>
        /// </devdoc>
        public SearchResult FindOne() {
            SearchResultCollection results = FindAll(false);
            foreach (SearchResult entry in results) {
                results.Dispose();                  // collection is no more needed
                return entry;
            }
            return null;
        }

        /// <include file='doc\DirectorySearcher.uex' path='docs/doc[@for="DirectorySearcher.FindAll"]/*' />
        /// <devdoc>
        ///    <para> Executes the search and returns a collection of the entries that are found.</para>
        /// </devdoc>
        public SearchResultCollection FindAll() {
            return FindAll(true);
        }
        
        private SearchResultCollection FindAll(bool findMoreThanOne) {
            //if it is not of valid searching type, then throw an exception
            if (SearchRoot == null) {
                Version adsVersion = GetAdsVersion();                                    
                throw new InvalidOperationException(Res.GetString(Res.DSVersion, adsVersion.ToString()));
            }
                        
            DirectoryEntry clonedRoot = null;
            if (assertDefaultNamingContext == null) {                 
                clonedRoot = SearchRoot.CloneBrowsable();
            }                
            else { 
                //SECREVIEW: If the SearchRoot was created by this object
                //                        it is safe to assert its browse permission to get
                //                        the inner IAds.
                DirectoryServicesPermission dsPermission = new DirectoryServicesPermission(
                                                                                              DirectoryServicesPermissionAccess.Browse, assertDefaultNamingContext);
                dsPermission.Assert();                                                                                              
                try {
                    clonedRoot = SearchRoot.CloneBrowsable();
                }
                finally {
                    DirectoryServicesPermission.RevertAssert();                        
                }
            }    
            
            UnsafeNativeMethods.IAds adsObject = clonedRoot.AdsObject;                        
            if (!(adsObject is UnsafeNativeMethods.IDirectorySearch))
                throw new NotSupportedException(Res.GetString(Res.DSSearchUnsupported, SearchRoot.Path));
                                                                    
            UnsafeNativeMethods.IDirectorySearch adsSearch = (UnsafeNativeMethods.IDirectorySearch) adsObject;
            SetSearchPreferences(adsSearch, findMoreThanOne);

            string[] properties = null;
            if (PropertiesToLoad.Count > 0) {
                if ( !PropertiesToLoad.Contains("ADsPath") ) {
                    // if we don't get this property, we won't be able to return a list of DirectoryEntry objects!                
                    PropertiesToLoad.Add("ADsPath");
                }
                properties = new string[PropertiesToLoad.Count];
                PropertiesToLoad.CopyTo(properties, 0);
            }
            
            IntPtr resultsHandle;
            if ( properties != null )
                adsSearch.ExecuteSearch(Filter, properties, properties.Length, out resultsHandle);
            else {
                adsSearch.ExecuteSearch(Filter, null, -1, out resultsHandle);
                properties = new string[0];                    
            }                
            
            SearchResultCollection result = new SearchResultCollection(clonedRoot, resultsHandle, properties, Filter);
            return  result;         
        }

        private static Version GetAdsVersion() {
            //SECREVIEW: Read only registry access inside a private function.
            //                         Not a security issue.
            RegistryKey key =null;
            string version = null;
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {            
                key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Active Setup\Installed Components\{E92B03AB-B707-11d2-9CBD-0000F87A369E}");
                if (key != null)
                    version = (string) key.GetValue("Version");
            }
            finally {
                RegistryPermission.RevertAssert();
            }
                                        
            if (key == null)
                return new Version(0, 0);            
            if (version == null)
                return new Version(0, 0);
            // it comes back in a format like 5,0,00,0. System.Version understands dots, not commas.
            return new Version(version.Replace(',', '.'));
        }

        private unsafe void SetSearchPreferences(UnsafeNativeMethods.IDirectorySearch adsSearch, bool findMoreThanOne) {
            ArrayList prefList = new ArrayList();
            AdsSearchPreferenceInfo info;

            // search scope
            info = new AdsSearchPreferenceInfo();
            info.dwSearchPref = (int) AdsSearchPreferences.SEARCH_SCOPE;
            info.vValue = new AdsValueHelper((int) SearchScope).GetStruct();
            prefList.Add(info);

            // size limit
            if (sizeLimit != 0 || !findMoreThanOne) {
                info = new AdsSearchPreferenceInfo();
                info.dwSearchPref = (int) AdsSearchPreferences.SIZE_LIMIT;
                info.vValue = new AdsValueHelper(findMoreThanOne ? SizeLimit : 1).GetStruct();
                prefList.Add(info);
            }

            // time limit
            if (ServerTimeLimit >= new TimeSpan(0)) {
                info = new AdsSearchPreferenceInfo();
                info.dwSearchPref = (int) AdsSearchPreferences.TIME_LIMIT;
                info.vValue = new AdsValueHelper((int) ServerTimeLimit.TotalSeconds).GetStruct();
                prefList.Add(info);
            }

            // propertyNamesOnly
            info = new AdsSearchPreferenceInfo();
            info.dwSearchPref = (int) AdsSearchPreferences.ATTRIBTYPES_ONLY;
            info.vValue = new AdsValueHelper(PropertyNamesOnly).GetStruct();
            prefList.Add(info);

            // Timeout
            if (ClientTimeout >= new TimeSpan(0)) {
                info = new AdsSearchPreferenceInfo();
                info.dwSearchPref = (int) AdsSearchPreferences.TIMEOUT;
                info.vValue = new AdsValueHelper((int) ClientTimeout.TotalSeconds).GetStruct();
                prefList.Add(info);
            }

            // page size
            if (PageSize != 0) {
                info = new AdsSearchPreferenceInfo();
                info.dwSearchPref = (int) AdsSearchPreferences.PAGESIZE;
                info.vValue = new AdsValueHelper(PageSize).GetStruct();
                prefList.Add(info);
            }

            // page time limit
            if (ServerPageTimeLimit >= new TimeSpan(0)) {
                info = new AdsSearchPreferenceInfo();
                info.dwSearchPref = (int) AdsSearchPreferences.PAGED_TIME_LIMIT;
                info.vValue = new AdsValueHelper((int) ServerPageTimeLimit.TotalSeconds).GetStruct();
                prefList.Add(info);
            }

            // chase referrals
            info = new AdsSearchPreferenceInfo();
            info.dwSearchPref = (int) AdsSearchPreferences.CHASE_REFERRALS;
            info.vValue = new AdsValueHelper((int) ReferralChasing).GetStruct();
            prefList.Add(info);

            IntPtr ptrToFree = (IntPtr)0;
            try {
                // sort
                if (Sort.PropertyName != null && Sort.PropertyName.Length > 0) {
                    info = new AdsSearchPreferenceInfo();
                    info.dwSearchPref = (int) AdsSearchPreferences.SORT_ON;
                    AdsSortKey sortKey = new AdsSortKey();
                    sortKey.pszAttrType = Marshal.StringToCoTaskMemUni(Sort.PropertyName);
                    ptrToFree = sortKey.pszAttrType; // so we can free it later.
                    sortKey.pszReserved = (IntPtr)0;
                    sortKey.fReverseOrder = (Sort.Direction == SortDirection.Descending) ? -1 : 0;
                    byte[] sortKeyBytes = new byte[Marshal.SizeOf(sortKey)];
                    Marshal.Copy((INTPTR_INTPTRCAST)(long) &sortKey, sortKeyBytes, 0, sortKeyBytes.Length);
                    info.vValue = new AdsValueHelper(sortKeyBytes, AdsType.ADSTYPE_PROV_SPECIFIC).GetStruct();
                    prefList.Add(info);
                }

                // cacheResults
                info = new AdsSearchPreferenceInfo();
                info.dwSearchPref = (int) AdsSearchPreferences.CACHE_RESULTS;
                info.vValue = new AdsValueHelper(CacheResults).GetStruct();
                prefList.Add(info);

                //
                // now make the call
                //                
                AdsSearchPreferenceInfo[] prefs = new AdsSearchPreferenceInfo[prefList.Count];
                for (int i = 0; i < prefList.Count; i++) {
                    prefs[i] = (AdsSearchPreferenceInfo) prefList[i];
                }

	        DoSetSearchPrefs(adsSearch, prefs);
            }
            finally {
                if (ptrToFree != (IntPtr)0)
                    Marshal.FreeCoTaskMem(ptrToFree);
            }
        }

        private static void DoSetSearchPrefs(UnsafeNativeMethods.IDirectorySearch adsSearch, AdsSearchPreferenceInfo[] prefs) {
            int structSize = Marshal.SizeOf(typeof(AdsSearchPreferenceInfo));
            IntPtr ptr = Marshal.AllocHGlobal((IntPtr)(structSize * prefs.Length));
            try {
                IntPtr tempPtr = ptr;
                for (int i = 0; i < prefs.Length; i++) {
                        Marshal.StructureToPtr(prefs[i], tempPtr, false);
                        tempPtr = (IntPtr)((long)tempPtr + structSize);
                }
 
                adsSearch.SetSearchPreference(ptr, prefs.Length);   
                
                // Check for the result status for all preferences
                tempPtr = ptr;
                for (int i = 0; i < prefs.Length; i++) {
                    int status = Marshal.ReadInt32(tempPtr, 32);
                    if ( status != 0 ) {
                        int prefIndex = prefs[i].dwSearchPref;
                        string property = "";
                        switch (prefIndex) {
                            case (int) AdsSearchPreferences.SEARCH_SCOPE:
                                property = "SearchScope";
                                break; 
                            case (int) AdsSearchPreferences.SIZE_LIMIT:
                                property = "SizeLimit";
                                break; 
                            case (int) AdsSearchPreferences.TIME_LIMIT:
                                property = "ServerTimeLimit";
                                break; 
                            case (int) AdsSearchPreferences.ATTRIBTYPES_ONLY:
                                property = "PropertyNamesOnly";
                                break;                                 
                            case (int) AdsSearchPreferences.TIMEOUT:
                                property = "ClientTimeout";
                                break;                                                                 
                            case (int) AdsSearchPreferences.PAGESIZE:
                                property = "PageSize";
                                break;                                                                 
                            case (int) AdsSearchPreferences.PAGED_TIME_LIMIT:
                                property = "ServerPageTimeLimit";
                                break;                                                                                                 
                            case (int) AdsSearchPreferences.CHASE_REFERRALS:
                                property = "ReferralChasing";
                                break;                                                                                                                                                                                                                                        
                            case (int) AdsSearchPreferences.SORT_ON:
                                property = "Sort";
                                break;           
                            case (int) AdsSearchPreferences.CACHE_RESULTS:
                                property = "CacheResults";
                                break;                                                                                                                                                                                                                                                                                                                                         
                        }
                        throw new InvalidOperationException(Res.GetString(Res.DSSearchPreferencesNotAccepted, property), 
                                                                              DirectoryEntry.CreateFormattedComException(status));
                    }                        
                        
                    tempPtr = (IntPtr)((long)tempPtr + structSize);
                }             
            }
            finally {
                    Marshal.FreeHGlobal(ptr);
            }
        }

        private bool ShouldSerializeClientTimeout() {
            return ClientTimeout != minusOneSecond;
        }

        private bool ShouldSerializeServerTimeLimit() {
            return ServerTimeLimit != minusOneSecond;
        }

        private bool ShouldSerializeServerPageTimeLimit() {
            return ServerPageTimeLimit != minusOneSecond;
        }

        private const string ADS_DIRSYNC_COOKIE = "fc8cb04d-311d-406c-8cb9-1ae8b843b418";

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryservicespermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryServicesPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {
    using System;        
    using System.Security.Permissions;    
                                                                        
    /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Serializable()
    ]
    public sealed class DirectoryServicesPermission : ResourcePermissionBase {    
        private DirectoryServicesPermissionEntryCollection innerCollection;
        
        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.DirectoryServicesPermission"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DirectoryServicesPermission() {
            SetNames();
        }                                                                
        
        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.DirectoryServicesPermission1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DirectoryServicesPermission(PermissionState state) 
        : base(state) {
            SetNames();
        }
        
        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.DirectoryServicesPermission2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DirectoryServicesPermission(DirectoryServicesPermissionAccess permissionAccess, string path) {            
            SetNames();
            this.AddPermissionAccess(new DirectoryServicesPermissionEntry(permissionAccess, path));              
        }         
         
        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.DirectoryServicesPermission3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DirectoryServicesPermission(DirectoryServicesPermissionEntry[] permissionAccessEntries) {            
            if (permissionAccessEntries == null)
                throw new ArgumentNullException("permissionAccessEntries");
                
            SetNames();            
            for (int index = 0; index < permissionAccessEntries.Length; ++index)
                this.AddPermissionAccess(permissionAccessEntries[index]);                          
        }

        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.PermissionEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>                
        public DirectoryServicesPermissionEntryCollection PermissionEntries {
            get {
                if (this.innerCollection == null)                     
                    this.innerCollection = new DirectoryServicesPermissionEntryCollection(this, base.GetPermissionEntries()); 
                                                                           
                return this.innerCollection;                                                               
            }
        }

        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.AddPermissionAccess"]/*' />                
        ///<internalonly/> 
        internal void AddPermissionAccess(DirectoryServicesPermissionEntry entry) {
            base.AddPermissionAccess(entry.GetBaseEntry());
        }
        
        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.Clear"]/*' />                        
        ///<internalonly/> 
        internal new void Clear() {
            base.Clear();
        }

        /// <include file='doc\DirectoryServicesPermission.uex' path='docs/doc[@for="DirectoryServicesPermission.RemovePermissionAccess"]/*' />                                                  
        ///<internalonly/> 
        internal void RemovePermissionAccess(DirectoryServicesPermissionEntry entry) {
            base.RemovePermissionAccess(entry.GetBaseEntry());
        }
        
        private void SetNames() {
            this.PermissionAccessType = typeof(DirectoryServicesPermissionAccess);
            this.TagNames = new string[]{"Path"};
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryservicespermissionaccess.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryServicesPermissionAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {

    /// <include file='doc\DirectoryServicesPermissionAccess.uex' path='docs/doc[@for="DirectoryServicesPermissionAccess"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]         
    public enum DirectoryServicesPermissionAccess {
        /// <include file='doc\DirectoryServicesPermissionAccess.uex' path='docs/doc[@for="DirectoryServicesPermissionAccess.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\DirectoryServicesPermissionAccess.uex' path='docs/doc[@for="DirectoryServicesPermissionAccess.Browse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Browse = 1 << 1,
        /// <include file='doc\DirectoryServicesPermissionAccess.uex' path='docs/doc[@for="DirectoryServicesPermissionAccess.Write"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Write = 1 << 2 | Browse,          
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryservicespermissionentry.cs ===
//----------------------------------------------------
// <copyright file="DirectoryServicesPermissionEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {
    using System.Security.Permissions;
    
    /// <include file='doc\DirectoryServicesPermissionEntry.uex' path='docs/doc[@for="DirectoryServicesPermissionEntry"]/*' />
    [
        Serializable()
    ] 
    public class DirectoryServicesPermissionEntry {
        private string path;
        private DirectoryServicesPermissionAccess permissionAccess;
            
        /// <include file='doc\DirectoryServicesPermissionEntry.uex' path='docs/doc[@for="DirectoryServicesPermissionEntry.DirectoryServicesPermissionEntry"]/*' />
        public DirectoryServicesPermissionEntry(DirectoryServicesPermissionAccess permissionAccess, string path) {
            if (path == null)
                throw new ArgumentNullException("path");
                    
            this.permissionAccess = permissionAccess;
            this.path = path;
        }  
        
        /// <include file='doc\DirectoryServicesPermissionEntry.uex' path='docs/doc[@for="DirectoryServicesPermissionEntry.DirectoryServicesPermissionEntry1"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal DirectoryServicesPermissionEntry(ResourcePermissionBaseEntry baseEntry) {
            this.permissionAccess = (DirectoryServicesPermissionAccess)baseEntry.PermissionAccess;
            this.path = baseEntry.PermissionAccessPath[0]; 
        }

        
        /// <include file='doc\DirectoryServicesPermissionEntry.uex' path='docs/doc[@for="DirectoryServicesPermissionEntry.Path"]/*' />
        public string Path {
            get {
                return this.path;
            }                        
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntry.uex' path='docs/doc[@for="DirectoryServicesPermissionEntry.PermissionAccess"]/*' />
        public DirectoryServicesPermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }                        
        }     
        
        /// <include file='doc\DirectoryServicesPermissionEntry.uex' path='docs/doc[@for="DirectoryServicesPermissionEntry.GetBaseEntry"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal ResourcePermissionBaseEntry GetBaseEntry() {
            ResourcePermissionBaseEntry baseEntry = new ResourcePermissionBaseEntry((int)this.PermissionAccess, new string[] {this.Path});            
            return baseEntry;
        }                        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryservicespermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryServicesPermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {  
    using System.Security;  
    using System.Security.Permissions;    
    
    /// <include file='doc\DirectoryServicesPermissionAttribute.uex' path='docs/doc[@for="DirectoryServicesPermissionAttribute"]/*' />
    [
    AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly | AttributeTargets.Event, AllowMultiple = true, Inherited = false ),
    Serializable()
    ]     
    public class DirectoryServicesPermissionAttribute : CodeAccessSecurityAttribute {
        private string path;
        private DirectoryServicesPermissionAccess permissionAccess;
                                        
        /// <include file='doc\DirectoryServicesPermissionAttribute.uex' path='docs/doc[@for="DirectoryServicesPermissionAttribute.DirectoryServicesPermissionAttribute"]/*' />
        public DirectoryServicesPermissionAttribute(SecurityAction action)
        : base(action) {
            this.path = "*";
            this.permissionAccess = DirectoryServicesPermissionAccess.Browse;            
        }

        /// <include file='doc\DirectoryServicesPermissionAttribute.uex' path='docs/doc[@for="DirectoryServicesPermissionAttribute.Path"]/*' />
        public string Path {
            get {
                return this.path;
            }
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                
                this.path = value;                    
            }
        }
        
        /// <include file='doc\DirectoryServicesPermissionAttribute.uex' path='docs/doc[@for="DirectoryServicesPermissionAttribute.PermissionAccess"]/*' />
        public DirectoryServicesPermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }
            
            set {
                this.permissionAccess = value;
            }
        }                          
              
        /// <include file='doc\DirectoryServicesPermissionAttribute.uex' path='docs/doc[@for="DirectoryServicesPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {            
            if (Unrestricted) 
                return new DirectoryServicesPermission(PermissionState.Unrestricted);
            
            return new DirectoryServicesPermission(this.PermissionAccess, this.Path);
            
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryentries.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryEntries.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;

    /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries"]/*' />
    /// <devdoc>
    ///    <para>Contains the children (child entries) of an entry in the Active Directory.</para>
    /// </devdoc>
    public class DirectoryEntries : IEnumerable {

        // the parent of the children in this collection
        private DirectoryEntry container;

        internal DirectoryEntries(DirectoryEntry parent) {
            container = parent;
        }
        
        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.SchemaFilter"]/*' />
        /// <devdoc>
        ///    <para>Gets the schemas that specify which children are shown.</para>
        /// </devdoc>
        public SchemaNameCollection SchemaFilter {
            get {
                CheckIsContainer();
                SchemaNameCollection.FilterDelegateWrapper filter = new SchemaNameCollection.FilterDelegateWrapper(container.ContainerObject);
                return new SchemaNameCollection(filter.Getter, filter.Setter);
            }
        }

        private void CheckIsContainer() {
            if (!container.IsContainer)
                throw new InvalidOperationException(Res.GetString(Res.DSNotAContainer, container.Path));
        }
        
        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.Add"]/*' />
        /// <devdoc>
        ///    <para>Creates a request to create a new entry in the container.</para>
        /// </devdoc>
        public DirectoryEntry Add(string name, string schemaClassName) {
            CheckIsContainer();
            object newChild = container.ContainerObject.Create(schemaClassName, name);
            DirectoryEntry entry = new DirectoryEntry(newChild, container.UsePropertyCache, container.Username, container.Password, container.AuthenticationType);
            entry.JustCreated = true;       // suspend writing changes until CommitChanges() is called
            return entry;
        }
        
        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.Find"]/*' />
        /// <devdoc>
        ///    <para>Returns the child with the given name.</para>
        /// </devdoc>
        public DirectoryEntry Find(string name) {
            // For IIS: and WinNT: providers  schemaClassName == "" does general search.
            return Find(name, null);
        }

        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.Find1"]/*' />
        /// <devdoc>
        ///    <para>Returns the child with the given name and of the given type.</para>
        /// </devdoc>
        public DirectoryEntry Find(string name, string schemaClassName) {
            CheckIsContainer();
            // Note: schemaClassName == null does not work for IIS: provider.
            return new DirectoryEntry(container.ContainerObject.GetObject(schemaClassName, name), container.UsePropertyCache, container.Username, container.Password, container.AuthenticationType);
        }

        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.Remove"]/*' />
        /// <devdoc>
        /// <para>Deletes a child <see cref='System.DirectoryServices.DirectoryEntry'/> from this collection.</para>
        /// </devdoc>
        public void Remove(DirectoryEntry entry) {
            CheckIsContainer();            
            container.ContainerObject.Delete(entry.SchemaClassName, entry.Name);
        }

        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new ChildEnumerator(container);
        }

        /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.ChildEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Supports a simple ForEach-style iteration over a collection and defines
        ///       enumerators, size, and synchronization methods.
        ///    </para>
        /// </devdoc>
        private class ChildEnumerator : IEnumerator {

            private DirectoryEntry container;
            private SafeNativeMethods.EnumVariant enumVariant;
            private DirectoryEntry currentEntry;
            
            internal ChildEnumerator(DirectoryEntry container) {
                this.container = container;
                if (container.IsContainer) {
                    enumVariant = new SafeNativeMethods.EnumVariant((SafeNativeMethods.IEnumVariant) container.ContainerObject._NewEnum);
                }
            }
            
            /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.ChildEnumerator.Current"]/*' />
            /// <devdoc>
            ///    <para>Gets the current element in the collection.</para>
            /// </devdoc>
            public DirectoryEntry Current {
                get {
                    if (enumVariant == null)
                        throw new InvalidOperationException(Res.GetString(Res.DSNoCurrentChild));
                    
                    if (currentEntry == null)                        
                        currentEntry = new DirectoryEntry(enumVariant.GetValue(), container.UsePropertyCache, container.Username, container.Password, container.AuthenticationType);
                        
                    return currentEntry;                        
                }
            }

            /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.ChildEnumerator.MoveNext"]/*' />
            /// <devdoc>
            ///    <para>Advances
            ///       the enumerator to the next element of the collection
            ///       and returns a Boolean value indicating whether a valid element is available.</para>
            /// </devdoc>
            public bool MoveNext() {
                if (enumVariant == null)
                    return false;
                    
                currentEntry = null;                                    
                return enumVariant.GetNext();
            }

            /// <include file='doc\DirectoryEntries.uex' path='docs/doc[@for="DirectoryEntries.ChildEnumerator.Reset"]/*' />
            /// <devdoc>
            ///    <para>Resets the enumerator back to its initial position before the first element in the collection.</para>
            /// </devdoc>
            public void Reset() {
                if (enumVariant != null) {
                    try {
                        enumVariant.Reset();
                    }
                    catch (NotImplementedException) {
                        //Some providers might not implement Reset, workaround the problem.
                        enumVariant = new SafeNativeMethods.EnumVariant((SafeNativeMethods.IEnumVariant) container.ContainerObject._NewEnum);
                    }                        
                    currentEntry = null;                                    
                }                    
            }

            object IEnumerator.Current {
                get {
                    return Current;
                }
            }

        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryservicespermissionentrycollection.cs ===
//----------------------------------------------------
// <copyright file="DirectoryServicesPermissionEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {
    using System.Security.Permissions;
    using System.Collections;

    /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection"]/*' />        
    [
    Serializable()
    ]
    public class DirectoryServicesPermissionEntryCollection : CollectionBase {
        DirectoryServicesPermission owner;
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.DirectoryServicesPermissionEntryCollection"]/*' />        
        ///<internalonly/>   
        internal DirectoryServicesPermissionEntryCollection(DirectoryServicesPermission owner, ResourcePermissionBaseEntry[] entries) {
            this.owner = owner;
            for (int index = 0; index < entries.Length; ++index)
                this.InnerList.Add(new DirectoryServicesPermissionEntry(entries[index]));
        } 
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.DirectoryServicesPermissionEntryCollection"]/*' />                   
        internal DirectoryServicesPermissionEntryCollection() {
        }                                                                                                            
                                                                                                            
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.this"]/*' />        
        public DirectoryServicesPermissionEntry this[int index] {
            get {
                return (DirectoryServicesPermissionEntry)List[index];
            }
            set {
                List[index] = value;
            }
            
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.Add"]/*' />
        public int Add(DirectoryServicesPermissionEntry value) {   
            return List.Add(value);
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.AddRange"]/*' />
        public void AddRange(DirectoryServicesPermissionEntry[] value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
    
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.AddRange1"]/*' />
        public void AddRange(DirectoryServicesPermissionEntryCollection value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }         
    
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.Contains"]/*' />
        public bool Contains(DirectoryServicesPermissionEntry value) {            
            return List.Contains(value);
        }
    
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.CopyTo"]/*' />
        public void CopyTo(DirectoryServicesPermissionEntry[] array, int index) {            
            List.CopyTo(array, index);
        }
    
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.IndexOf"]/*' />
        public int IndexOf(DirectoryServicesPermissionEntry value) {            
            return List.IndexOf(value);
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.Insert"]/*' />
        public void Insert(int index, DirectoryServicesPermissionEntry value) {            
            List.Insert(index, value);
        }
                
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.Remove"]/*' />
        public void Remove(DirectoryServicesPermissionEntry value) {
            List.Remove(value);                     
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.OnClear"]/*' />        
        ///<internalonly/>                          
        protected override void OnClear() {   
            this.owner.Clear();         
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.OnInsert"]/*' />        
        ///<internalonly/>                          
        protected override void OnInsert(int index, object value) {        
            this.owner.AddPermissionAccess((DirectoryServicesPermissionEntry)value);
        }
        
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemove(int index, object value) {
            this.owner.RemovePermissionAccess((DirectoryServicesPermissionEntry)value);
        }
                 
        /// <include file='doc\DirectoryServicesPermissionEntryCollection.uex' path='docs/doc[@for="DirectoryServicesPermissionEntryCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSet(int index, object oldValue, object newValue) {     
            this.owner.RemovePermissionAccess((DirectoryServicesPermissionEntry)oldValue);
            this.owner.AddPermissionAccess((DirectoryServicesPermissionEntry)newValue);       
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\propertycollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;
    using System.Security.Permissions;

    /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection"]/*' />
    /// <devdoc>
    /// <para>Contains the properties on a <see cref='System.DirectoryServices.DirectoryEntry'/>.</para>
    /// </devdoc>
    public class PropertyCollection : IDictionary {

        private DirectoryEntry entry;

        internal PropertyCollection(DirectoryEntry entry) {
            this.entry = entry;
        }        

        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the property with the given name.</para>
        /// </devdoc>
        public PropertyValueCollection this[string propertyName] {
            get {                
                return new PropertyValueCollection(entry, propertyName);                    
            }
        }

        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of properties available on this entry.</para>
        /// </devdoc>
        public int Count {
            get {
                if (!(entry.AdsObject is UnsafeNativeMethods.IAdsPropertyList))
                    throw new NotSupportedException(Res.GetString(Res.DSCannotCount));

                entry.FillCache("");

                UnsafeNativeMethods.IAdsPropertyList propList = (UnsafeNativeMethods.IAdsPropertyList) entry.AdsObject;

                return propList.PropertyCount;
            }
        }

        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyNames"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection PropertyNames {
            get {
                return new KeysCollection(this);
            }
        }
                        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return new ValuesCollection(this);
            }
        }

        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string propertyName) {       
            try {
                //entry.FillCache(propertyName);
                object var = entry.AdsObject.GetEx(propertyName);                
            }    
            catch ( System.Runtime.InteropServices.COMException e ) {
                if ( e.ErrorCode == unchecked((int)0x8000500D) )  {   //  property not found exception
                    return false;
                }
                else    
                    throw;
            }
                         
            return true;
        }
        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of this instance into an <see cref='System.Array'/>, starting at a particular index into the array.</para>
        /// </devdoc>
        public void CopyTo(PropertyValueCollection[] array, int index) {
            ((ICollection)this).CopyTo((Array)array, index);
        }
       
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Returns an enumerator, which can be used to iterate through the collection.</para>
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator() {
            if (!(entry.AdsObject is UnsafeNativeMethods.IAdsPropertyList))
                throw new NotSupportedException(Res.GetString(Res.DSCannotEmunerate));

            // Once an object has been used for an enumerator once, it can't be used again, because it only
            // maintains a single cursor. Re-bind to the ADSI object to get a new instance.
            // That's why we must clone entry here. It will be automatically disposed inside Enumerator.
            DirectoryEntry entryToUse = entry.CloneBrowsable(); 
            entryToUse.FillCache("");

            UnsafeNativeMethods.IAdsPropertyList propList = (UnsafeNativeMethods.IAdsPropertyList) entryToUse.AdsObject;

            entryToUse.propertiesAlreadyEnumerated = true;
            return new PropertyEnumerator(entry, entryToUse);
        }
             
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.this"]/*' />
        ///<internalonly/>
        object IDictionary.this[object key] {
            get {
                return this[(string)key];
            }     
            
            set {
                throw new NotSupportedException(Res.GetString(Res.DSPropertySetSupported));
            }                               
        }
        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.IsFixedSize"]/*' />
        ///<internalonly/>
        bool IDictionary.IsFixedSize {
            get {
                return true;
            }
        } 
                                        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.IsReadOnly"]/*' />
        ///<internalonly/>
        bool IDictionary.IsReadOnly {
            get {
                return true;
            }
        }
                        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.Keys"]/*' />
        ///<internalonly/>
        ICollection IDictionary.Keys {
            get {
                return new KeysCollection(this);
            }
        }                                   
            
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.Add"]/*' />
        ///<internalonly/>
        void IDictionary.Add(object key, object value) {
            throw new NotSupportedException(Res.GetString(Res.DSAddNotSupported));
        }                            
        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.Clear"]/*' />
        ///<internalonly/>
        void IDictionary.Clear() {
            throw new NotSupportedException(Res.GetString(Res.DSClearNotSupported));
        }
                                              
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.Contains"]/*' />
        ///<internalonly/>
        bool IDictionary.Contains(object value) {
            return this.Contains((string)value);
        }        
                
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IDictionary.Remove"]/*' />
        ///<internalonly/>
        void IDictionary.Remove(object key) {
            throw new NotSupportedException(Res.GetString(Res.DSRemoveNotSupported));
        }                            
                                                                             
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.IEnumerable.GetEnumerator"]/*' />
        ///<internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }        
                            
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ICollection.IsSynchronized"]/*' />
        ///<internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }
                
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ICollection.SyncRoot"]/*' />
        ///<internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }
        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ICollection.CopyTo"]/*' />
        ///<internalonly/>
        void ICollection.CopyTo(Array array, Int32 index) {
            foreach(PropertyValueCollection value in this) {
                array.SetValue(value, index);
                index++;
            }
        }
               
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator"]/*' />
        ///<internalonly/>
        private class PropertyEnumerator : IDictionaryEnumerator, IDisposable {
            private DirectoryEntry entry;               // clone (to be disposed)
            private DirectoryEntry parentEntry;         // original entry to pass to PropertyValueCollection
            private string currentPropName = null;

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.PropertyEnumerator"]/*' />
            ///<internalonly/>
            public PropertyEnumerator(DirectoryEntry parent, DirectoryEntry clone) {
                this.entry = clone;
                this.parentEntry = parent;
            }
            
            ~PropertyEnumerator() {
                Dispose(true);      // finalizer is called => Dispose has not been called yet.
            }
            
            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyEnumerator.Dispose"]/*' />
            /// <devdoc>        
            /// </devdoc>
            public void Dispose() {
                Dispose(true);
                GC.SuppressFinalize(this);            
            }                
        
            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyEnumerator.Dispose1"]/*' />
            /// <devdoc>        
            /// </devdoc>
            protected virtual void Dispose(bool disposing) {            
                if (disposing) {
                    entry.Dispose();
                }                    
            }
        
            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.Current"]/*' />
            ///<internalonly/>
            public object Current {
                get {
                    return Entry.Value;
                }
            }
             
            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.Entry"]/*' />
            ///<internalonly/>
            public DictionaryEntry Entry {
                get {
                    if (currentPropName == null)
                        throw new InvalidOperationException(Res.GetString(Res.DSNoCurrentProperty));
                
                    return new DictionaryEntry(currentPropName, new PropertyValueCollection(parentEntry, currentPropName));
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.Key"]/*' />
            ///<internalonly/>
            public object Key {
                get {
                    return Entry.Key;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.Value"]/*' />
            ///<internalonly/>
            public object Value {
                get {
                    return Entry.Value;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.MoveNext"]/*' />
            ///<internalonly/>
            public bool MoveNext() {
                object prop;
                int hr = 0;
                try {
                    hr = ((UnsafeNativeMethods.IAdsPropertyList) entry.AdsObject).Next(out prop);
                }
                catch (COMException e) {                    
                    hr = e.ErrorCode;
                    prop = null;
                }
                if (hr == 0) {
                    if (prop != null)
                        currentPropName = ((UnsafeNativeMethods.IAdsPropertyEntry) prop).Name;
                    else
                        currentPropName = null;
                                                                    
                    return true;
                }
                else {
					currentPropName = null;
                    return false;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.PropertyEnumerator.Reset"]/*' />
            ///<internalonly/>
            public void Reset() {
                ((UnsafeNativeMethods.IAdsPropertyList) entry.AdsObject).Reset();
                currentPropName = null;
            }
        }        
        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection"]/*' />
        ///<internalonly/>
        private class ValuesCollection : ICollection {
            protected PropertyCollection props;

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.ValuesCollection"]/*' />
            ///<internalonly/>
            public ValuesCollection(PropertyCollection props) {
                this.props = props;
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.Count"]/*' />
            ///<internalonly/>
            public int Count {
                get {
                    return props.Count;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.IsReadOnly"]/*' />
            ///<internalonly/>
            public bool IsReadOnly {
                get {
                    return true;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.IsSynchronized"]/*' />
            ///<internalonly/>
            public bool IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.SyncRoot"]/*' />
            ///<internalonly/>
            public object SyncRoot {
                get {
                    return ((ICollection)props).SyncRoot;
                }
            }
            
            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.CopyTo"]/*' />
            ///<internalonly/>
            public void CopyTo(Array array, int index) {
                foreach (object value in this)
                    array.SetValue(value, index++);
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesCollection.GetEnumerator"]/*' />
            ///<internalonly/>
            public virtual IEnumerator GetEnumerator() {
                return new ValuesEnumerator(props);
            }

        }

        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.KeysCollection"]/*' />
        ///<internalonly/>   
        private class KeysCollection : ValuesCollection {           

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.KeysCollection.KeysCollection"]/*' />
            ///<internalonly/>
            public KeysCollection(PropertyCollection props) 
            : base(props){              
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.KeysCollection.GetEnumerator"]/*' />
            ///<internalonly/>
            public override IEnumerator GetEnumerator() {
                props.entry.FillCache("");
                return new KeysEnumerator(props);
            }

        }
        
        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesEnumerator"]/*' />
        ///<internalonly/>
        private class ValuesEnumerator : IEnumerator {
            private int currentIndex = -1;
            protected PropertyCollection propCollection;

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesEnumerator.ValuesEnumerator"]/*' />
            ///<internalonly/>
            public ValuesEnumerator(PropertyCollection propCollection) {
                this.propCollection = propCollection;
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesEnumerator.CurrentIndex"]/*' />
            ///<internalonly/>
            protected int CurrentIndex {
                get {
                    if (currentIndex == -1)
                        throw new InvalidOperationException(Res.GetString(Res.DSNoCurrentValue));
                    return currentIndex;
                }
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesEnumerator.Current"]/*' />
            ///<internalonly/>
            public virtual object Current {
                get {

                    UnsafeNativeMethods.IAdsPropertyList propList = (UnsafeNativeMethods.IAdsPropertyList) propCollection.entry.AdsObject;                    
                    return propCollection[((UnsafeNativeMethods.IAdsPropertyEntry) propList.Item(CurrentIndex)).Name];                
                }
            }            

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesEnumerator.MoveNext"]/*' />
            ///<internalonly/>
            public bool MoveNext() {
                currentIndex++;
                if (currentIndex >= propCollection.Count) {
                    currentIndex = -1;
                    return false;
                }
                else
                    return true;
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.ValuesEnumerator.Reset"]/*' />
            ///<internalonly/>
            public void Reset() {
                currentIndex = -1;
            }
        }

        /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.KeysEnumerator"]/*' />
        ///<internalonly/>
        private class KeysEnumerator : ValuesEnumerator {

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.KeysEnumerator.KeysEnumerator"]/*' />
            ///<internalonly/>
            public KeysEnumerator(PropertyCollection collection) 
            : base(collection) {
            }

            /// <include file='doc\PropertyCollection.uex' path='docs/doc[@for="PropertyCollection.KeysEnumerator.Current"]/*' />
            ///<internalonly/>
            public override object Current {
                get {                
                    UnsafeNativeMethods.IAdsPropertyList propList = (UnsafeNativeMethods.IAdsPropertyList) propCollection.entry.AdsObject;

                    return ((UnsafeNativeMethods.IAdsPropertyEntry) propList.Item(CurrentIndex)).Name;                
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\propertyvaluecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;
    using System.Security.Permissions;

    /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection"]/*' />
    /// <devdoc>
    ///    <para>Holds a collection of values for a multi-valued property.</para>
    /// </devdoc>
    public class PropertyValueCollection : CollectionBase {
            
        private DirectoryEntry entry;
        private string propertyName;

        internal PropertyValueCollection(DirectoryEntry entry, string propertyName) {
            this.entry = entry;
            this.propertyName = propertyName;
            PopulateList();            
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[int index] {
            get {
                return List[index];
            }
            set {
                List[index] = value;
            }
            
        }
                
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Value {
            get {
                if (this.Count == 0)
                    return null;
                else if (this.Count == 1) 
                    return List[0];
                else {
                    object[] objectArray = new object[this.Count];
                    List.CopyTo(objectArray, 0);                    
                    return objectArray;
                }                                        
            }
            
            set {   
                this.Clear();                             
                if (value == null)
                    return;                    
                else if (value is Array) {
                    if (value is object[])
                        this.AddRange((object[])value);
                    else {
                        //Need to box value type array elements.
                        object[] objArray = new object[((Array)value).Length];
                        ((Array)value).CopyTo(objArray, 0);
                        this.AddRange((object[])objArray);
                    }			
                }	 
                else
                    this.Add(value);                                                                            
            }
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Appends the value to the set of values for this property.</para>
        /// </devdoc>
        public int Add(object value) {   
            return List.Add(value);
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>Appends the values to the set of values for this property.</para>
        /// </devdoc>
        public void AddRange(object[] value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
    
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>Appends the values to the set of values for this property.</para>
        /// </devdoc>
        public void AddRange(PropertyValueCollection value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }         
    
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(object value) {            
            return List.Contains(value);
        }
    
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of this instance into an <see cref='System.Array'/>,
        ///    starting at a particular index
        ///    into the given <paramref name="array"/>.</para>
        /// </devdoc>
        public void CopyTo(object[] array, int index) {            
            List.CopyTo(array, index);
        }
    
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(object value) {            
            return List.IndexOf(value);
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, object value) {            
            List.Insert(index, value);
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.PopulateList"]/*' />
        ///<internalonly/>                           
        private void PopulateList() {      
            try {
                //No need to fill the cache here, when GetEx is calles, an implicit 
                //call to GetInfo will be called against an uninitialized property 
                //cache. Which is exactly what FillCache does.            
                //entry.FillCache(propertyName);
                object var = entry.AdsObject.GetEx(propertyName);                
                if (var is ICollection)
                    InnerList.AddRange((ICollection)var);                        
                else                    
                    InnerList.Add(var);                        
            }    
            catch ( System.Runtime.InteropServices.COMException e ) {
                if ( e.ErrorCode != unchecked((int)0x8000500D) )    //  property not found exception
                    throw;
                // "Property not found" situation will cause an empty value list as result.
            }

        }

        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the value from the collection.</para>
        /// </devdoc>
        public void Remove(object value) {
            List.Remove(value);                     
        }        
                                                  
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.OnClear"]/*' />
        ///<internalonly/>                           
        protected override void OnClearComplete() {
            entry.AdsObject.PutEx((int) AdsPropertyOperation.Clear, propertyName, null);
            try {
                entry.CommitIfNotCaching();
            }
            catch ( System.Runtime.InteropServices.COMException e ) {
                // On ADSI 2.5 if property has not been assigned any value before, 
                // then IAds::SetInfo() in CommitIfNotCaching returns bad HREsult 0x8007200A, which we ignore. 
                if ( e.ErrorCode != unchecked((int)0x8007200A) )    //  ERROR_DS_NO_ATTRIBUTE_OR_VALUE
                    throw;
            }
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.OnInsert"]/*' />
        ///<internalonly/>
        protected override void OnInsertComplete(int index, object value) {        
            object[] allValues = new object[InnerList.Count];
            InnerList.CopyTo(allValues, 0);
            entry.AdsObject.PutEx((int) AdsPropertyOperation.Update, propertyName, allValues);
            entry.CommitIfNotCaching();
        }
        
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemoveComplete(int index, object value) {
            object[] allValues = new object[InnerList.Count];
            InnerList.CopyTo(allValues, 0);
            entry.AdsObject.PutEx((int) AdsPropertyOperation.Update, propertyName, allValues);
            
            entry.CommitIfNotCaching();
        }
                 
        /// <include file='doc\PropertyValueCollection.uex' path='docs/doc[@for="PropertyValueCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSetComplete(int index, object oldValue, object newValue) {
             if (Count <= 1) {
                entry.AdsObject.Put(propertyName, newValue);
                entry.CommitIfNotCaching();
            }
            else {
                object[] allValues = new object[InnerList.Count];
                InnerList.CopyTo(allValues, 0);
                entry.AdsObject.PutEx((int) AdsPropertyOperation.Update, propertyName, allValues);
            }                
            
            entry.CommitIfNotCaching();                        
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\referalchasingoption.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReferalChasingOption.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {

    /// <include file='doc\ReferalChasingOption.uex' path='docs/doc[@for="ReferralChasingOption"]/*' />
    /// <devdoc>
    ///    <para>Specifies if and how referral chasing is pursued.</para>
    /// </devdoc>
    public enum ReferralChasingOption {
        /// <include file='doc\ReferalChasingOption.uex' path='docs/doc[@for="ReferralChasingOption.None"]/*' />
        /// <devdoc>
        ///    <para> Never chase the referred-to server. Setthing this option 
        ///       prevents a client from contacting other servers in a referral process.</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\ReferalChasingOption.uex' path='docs/doc[@for="ReferralChasingOption.Subordinate"]/*' />
        /// <devdoc>
        ///    <para>Chase only subordinate referrals which are a subordinate naming context in a 
        ///       directory tree. The ADSI LDAP provider always turns off this flag for paged
        ///       searches.</para>
        /// </devdoc>
        Subordinate = 0x20,
        /// <include file='doc\ReferalChasingOption.uex' path='docs/doc[@for="ReferralChasingOption.External"]/*' />
        /// <devdoc>
        ///    <para>Chase external referrals.</para>
        /// </devdoc>
        External = 0x40,
        /// <include file='doc\ReferalChasingOption.uex' path='docs/doc[@for="ReferralChasingOption.All"]/*' />
        /// <devdoc>
        ///    <para>Chase referrals of either the subordinate or external type.</para>
        /// </devdoc>
        All = Subordinate | External
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\schemanamecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaNameCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;
        
    
    /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection"]/*' />
    /// <devdoc>
    /// <para>Contains a list of schema names used for the <see cref='System.DirectoryServices.DirectoryEntries.SchemaFilter'/> property of a <see cref='System.DirectoryServices.DirectoryEntries'/>.</para>
    /// </devdoc>
    public class SchemaNameCollection : IList {

        private VariantPropGetter propGetter;
        private VariantPropSetter propSetter;

        internal SchemaNameCollection(VariantPropGetter propGetter, VariantPropSetter propSetter) {
            this.propGetter = propGetter;
            this.propSetter = propSetter;
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the object
        ///       at the given index.</para>
        /// </devdoc>
        public string this[int index] {
            get {
                object[] values = GetValue();
                return (string) values[index];
            }
            set {
                object[] values = GetValue();
                values[index] = value;
                propSetter(values);
            }
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of objects available on this entry.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                object[] values = GetValue();
                return values.Length;
            }
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends the value to the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public int Add(string value) {
            object[] oldValues = GetValue();
            object[] newValues = new object[oldValues.Length + 1];
            for (int i = 0; i < oldValues.Length; i++)
                newValues[i] = oldValues[i];
            newValues[newValues.Length - 1] = value;
            propSetter(newValues);
            return newValues.Length - 1;
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends the values to the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(string[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            object[] oldValues = GetValue();
            object[] newValues = new object[oldValues.Length + value.Length];
            for (int i = 0; i < oldValues.Length; i++)
                newValues[i] = oldValues[i];
            for (int i = oldValues.Length; i < newValues.Length; i++)
                newValues[i] = value[i - oldValues.Length];
            propSetter(newValues);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(SchemaNameCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            object[] oldValues = GetValue();
            object[] newValues = new object[oldValues.Length + value.Count];
            for (int i = 0; i < oldValues.Length; i++)
                newValues[i] = oldValues[i];
            for (int i = oldValues.Length; i < newValues.Length; i++)
                newValues[i] = value[i - oldValues.Length];
            propSetter(newValues);                        
        }
        
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes all items from the collection.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            object[] newValues = new object[0];
            propSetter(newValues);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the collection contains a specific value.
        ///    </para>
        /// </devdoc>
        public bool Contains(string value) {
            return IndexOf(value) != -1;
        }
                
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(String[] stringArray, int index) {
            object[] values = GetValue();
            values.CopyTo(stringArray, index);
       }                                          
        
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            object[] values = GetValue();
            return values.GetEnumerator();
        }
                                          
        private object[] GetValue() {
            object value = propGetter();
            if (value == null)
                return new object[0];
            else
                return (object[]) value;
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines the index of a specific item in the collection.
        ///    </para>
        /// </devdoc>
        public int IndexOf(string value) {
            object[] values = GetValue();
            for (int i = 0; i < values.Length; i++) {
                if (value == (string)values[i])
                    return i;
            }
            return -1;
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>Inserts an item at the specified position in the collection.</para>
        /// </devdoc>
        public void Insert(int index, string value) {
            object[] oldValues = GetValue();
            object[] newValues = new object[oldValues.Length + 1];
            for (int i = 0; i < index; i++)
                newValues[i] = oldValues[i];
            newValues[index] = value;
            for (int i = index + 1; i < newValues.Length; i++)
                newValues[i] = oldValues[i-1];
            propSetter(newValues);
        }                

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes an item from the collection.</para>
        /// </devdoc>
        public void Remove(string value) {
            // this does take two scans of the array, but value isn't guaranteed to be there.
            int index = IndexOf(value);
            RemoveAt(index);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>Removes the
        ///       item at the specified index from the collection.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            object[] oldValues = GetValue();
            if (index >= oldValues.Length || index < 0)
                throw new ArgumentOutOfRangeException("index");

            object[] newValues = new object[oldValues.Length - 1];
            for (int i = 0; i < index; i++)
                newValues[i] = oldValues[i];
            for (int i = index + 1; i < oldValues.Length; i++)
                newValues[i - 1] = oldValues[i];
            propSetter(newValues);
        }
                        
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }         
        
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            object[] values = GetValue();
            values.CopyTo(array, index);
       }          
         
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }         
         
        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return this[index];
            }
            set {
                this[index] = (string)value;
            }
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.Add"]/*' />
        /// <internalonly/>            
        int IList.Add(object value) {
            return Add((string)value);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return Contains((string) value);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.IndexOf"]/*' />
        /// <internalonly/>                           
        int IList.IndexOf(object value) {
            return IndexOf((string)value);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            Insert(index, (string)value);
        }

        /// <include file='doc\SchemaNameCollection.uex' path='docs/doc[@for="SchemaNameCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            Remove((string)value);
        }
        
        internal delegate object VariantPropGetter();
        internal delegate void VariantPropSetter(object value);

        // this class and HintsDelegateWrapper exist only because you can't create
        // a delegate to a property's accessors. You have to supply methods. So these
        // classes wrap an object and supply properties as methods.
        internal class FilterDelegateWrapper {
            private UnsafeNativeMethods.IAdsContainer obj;
            internal FilterDelegateWrapper(UnsafeNativeMethods.IAdsContainer wrapped) {
                obj = wrapped;
            }
            public VariantPropGetter Getter {
                get {
                    return new VariantPropGetter(GetFilter);
                }
            }

            public VariantPropSetter Setter {
                get {
                    return new VariantPropSetter(SetFilter);
                }
            }

            private object GetFilter() {
                return obj.Filter;
            }

            private void SetFilter(object value) {
                obj.Filter = value;
            }
        }                     
        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\directoryentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;
    using System.ComponentModel;
    using System.Threading;
    using System.Reflection;
    using System.Security.Permissions;
    using System.DirectoryServices.Design;
    using System.Globalization;
    using System.Net;
    
    /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry"]/*' />
    /// <devdoc>
    ///    <para> Encapsulates a node or an object in the Active Directory hierarchy.</para>
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(DirectoryEntryConverter)) 
    ]
    public class DirectoryEntry : Component {

        private string path = "";
        private UnsafeNativeMethods.IAds adsObject;
        private bool useCache = true;
        private bool cacheFilled;        
        internal bool propertiesAlreadyEnumerated = false;
        private bool browseGranted = false;
        private bool writeGranted = false;
        private bool justCreated = false;   // 'true' if newly created entry was not yet stored by CommitChanges().
        private bool disposed = false;
        private AuthenticationTypes authenticationType = AuthenticationTypes.None;
        private NetworkCredential credentials;

        
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.DirectoryEntry"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.DirectoryServices.DirectoryEntry'/>class.
        ///    </para>
        /// </devdoc>
        public DirectoryEntry() {            
        }
        
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.DirectoryEntry1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.DirectoryServices.DirectoryEntry'/> class that will bind
        ///       to the directory entry at <paramref name="path"/>.
        ///    </para>
        /// </devdoc>
        public DirectoryEntry(string path) {
            Path = path;                                
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.DirectoryEntry2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.DirectoryServices.DirectoryEntry'/> class.
        ///    </para>
        /// </devdoc>        
        public DirectoryEntry(string path, string username, string password) : this(path, username, password, AuthenticationTypes.Secure) {
        }
        
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.DirectoryEntry3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.DirectoryServices.DirectoryEntry'/> class.
        ///    </para>
        /// </devdoc>
        public DirectoryEntry(string path, string username, string password, AuthenticationTypes authenticationType) : this(path) {
            if (username != null && password != null)
                this.credentials = new NetworkCredential(username, password);            
                
            this.authenticationType = authenticationType;
        }

        internal DirectoryEntry(string path, bool useCache, string username, string password, AuthenticationTypes authenticationType) {
            this.path = path;            
            this.useCache = useCache;
            if (username != null && password != null)
                this.credentials = new NetworkCredential(username, password);            
                
            this.authenticationType = authenticationType;
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.DirectoryEntry4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.DirectoryServices.DirectoryEntry'/> class that will bind
        ///       to the native Active Directory object which is passed in.
        ///    </para>
        /// </devdoc>
        public DirectoryEntry(object adsObject) 
            : this(adsObject, true, null, null, AuthenticationTypes.None) {
        }

        internal DirectoryEntry(object adsObject, bool useCache, string username, string password, AuthenticationTypes authenticationType) {
            this.adsObject = adsObject as UnsafeNativeMethods.IAds;
            if (this.adsObject == null)
                throw new ArgumentException(Res.GetString(Res.DSDoesNotImplementIADs));
            // GetInfo is not needed here. ADSI executes an implicit GetInfo when GetEx 
            // is called on the PropertyValueCollection. 0x800704BC error might be returned 
            // on some WinNT entries, when iterating through 'Users' group members.
            // if (forceBind)
            //     this.adsObject.GetInfo();                
            path = this.adsObject.ADsPath;
            this.useCache = useCache;
            
            this.authenticationType = authenticationType;
            if (username != null && password != null)
                this.credentials = new NetworkCredential(username, password);            
                
            if (!useCache)
                CommitChanges();
        }
                                 
        internal UnsafeNativeMethods.IAds AdsObject {
            get {
                Bind();
                 return adsObject;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.AuthenticationType"]/*' />
        [
            DefaultValue(AuthenticationTypes.None),
            DSDescriptionAttribute(Res.DSAuthenticationType)
        ]
        public AuthenticationTypes AuthenticationType {
            get {
                return authenticationType;
            }
            set {
                if (authenticationType == value)
                    return;

                authenticationType = value;
                Unbind();
            }
        }
        
        private bool Bound {
            get {
                return adsObject != null;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Children"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.DirectoryServices.DirectoryEntries'/>
        /// containing the child entries of this node in the Active
        /// Directory hierarchy.</para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSChildren)
        ]
        public DirectoryEntries Children {
            get {
                if (!browseGranted) {
                    DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Browse, this.path);
                    permission.Demand();     
                    browseGranted = true;                                                                                         
                }

                return new DirectoryEntries(this);
            }
        }

        internal UnsafeNativeMethods.IAdsContainer ContainerObject {
            get {
                Bind();
                return (UnsafeNativeMethods.IAdsContainer) adsObject;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Guid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the globally unique identifier of the <see cref='System.DirectoryServices.DirectoryEntry'/>.
        ///    </para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSGuid)
        ]
        public Guid Guid {
            get {
                string guid = NativeGuid;
                if (guid.Length == 32) {
                    // oddly, the value comes back as a string with no dashes from LDAP
                    byte[] intGuid = new byte[16];
                    for ( int j = 0; j < 16 ; j++) {
                        intGuid[j] = Convert.ToByte( new String(new char[] { guid[j*2], guid[j*2+1] }) , 16);
                    }
                    return new Guid(intGuid);
                    // return new Guid(guid.Substring(0, 8) + "-" + guid.Substring(8, 4) + "-" + guid.Substring(12, 4) + "-" + guid.Substring(16, 4) + "-" + guid.Substring(20));
                }
                else
                    return new Guid(guid);
            }
        }

        internal bool IsContainer {
            get {
                Bind();
                return adsObject is UnsafeNativeMethods.IAdsContainer;
            }
        }

        internal bool JustCreated {
            get {
                return justCreated;
            }
            set {
                justCreated = value;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the relative name of the object as named with the
        ///       underlying directory service.
        ///    </para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSName)
        ]
        public string Name {
            get {
                Bind();
                return adsObject.Name;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.NativeGuid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            Browsable(false), 
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSNativeGuid)            
        ]
        public string NativeGuid {
            get {
                FillCache("GUID");
                return adsObject.GUID;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.NativeObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the native Active Directory Services Interface (ADSI) object.
        ///    </para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSNativeObject)
        ]
        public object NativeObject {
            get {
                Bind();
                return adsObject;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Parent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets this
        ///       entry's parent entry in the Active Directory hierarchy.
        ///    </para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSParent)
        ]
        public DirectoryEntry Parent {
            get {
                Bind();
                return new DirectoryEntry(adsObject.Parent, UsePropertyCache, Username, Password, AuthenticationType);
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Password"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the password to use when authenticating the client.</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSPassword),            
            DefaultValue(null),
            Browsable(false)
        ]
        public string Password {
            get {
                if (this.credentials == null) 
                    return null;
                  
                return this.credentials.Password;
            }
            set {                                    
                if (value == Password)
                    return;
                
                if (value == null) 
                    this.credentials = null;
                else {                   
                    if (this.credentials == null) 
                        this.credentials = new NetworkCredential();

                    this.credentials.Password = value;                
                }
                                    
                Unbind();
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Path"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the path for this <see cref='System.DirectoryServices.DirectoryEntry'/>.</para>
        /// </devdoc>
        [
            DefaultValue(""),
            DSDescriptionAttribute(Res.DSPath),
            TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
            RecommendedAsConfigurable(true)
        ]
        public string Path {
            get {                                                 
                return path;                
            }
            set {
                if (value == null)
                    value = "";

                if (string.Compare(path, value, true, CultureInfo.InvariantCulture) == 0)
                    return;

                path = value;
                Unbind();
            }
        }
        
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Properties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a <see cref='System.DirectoryServices.PropertyCollection'/>
        ///       of properties set on this object.
        ///    </para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSProperties)
        ]
        public PropertyCollection Properties {
           get {
              if (!browseGranted) {
                    DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Browse, this.path);
                    permission.Demand();     
                    browseGranted = true;                                                                                         
                }

                return new PropertyCollection(this);
            }
        }
        
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.SchemaClassName"]/*' />
        /// <devdoc>
        /// <para>Gets the name of the schema used for this <see cref='System.DirectoryServices.DirectoryEntry'/>.</para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSSchemaClassName)
        ]
        public string SchemaClassName {
            get {
                Bind();
                return adsObject.Class;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.SchemaEntry"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.DirectoryServices.DirectoryEntry'/> that holds schema information for this 
        ///    entry. An entry's <see cref='System.DirectoryServices.DirectoryEntry.SchemaClassName'/>
        ///    determines what properties are valid for it.</para>
        /// </devdoc>
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            DSDescriptionAttribute(Res.DSSchemaEntry)
        ]
        public DirectoryEntry SchemaEntry {
            get {
                Bind();
                return new DirectoryEntry(adsObject.Schema, UsePropertyCache, Username, Password, AuthenticationType);
            }
        }

        // By default changes to properties are done locally to
        // a cache and reading property values is cached after
        // the first read.  Setting this to false will cause the
        // cache to be committed after each operation.
        //
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.UsePropertyCache"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the cache should be committed after each
        ///       operation.
        ///    </para>
        /// </devdoc>
        [
            DefaultValue(true),
            DSDescriptionAttribute(Res.DSUsePropertyCache)
        ]
        public bool UsePropertyCache {
            get {
                return useCache;
            }
            set {
                if (value == useCache)
                    return;

                // auto-commit when they set this to false.
                if (!value)
                    CommitChanges();

                cacheFilled = false;    // cache mode has been changed
                useCache = value;
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Username"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the username to use when authenticating the client.</para>
        /// </devdoc>
        [
            DSDescriptionAttribute(Res.DSUsername),            
            TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
            DefaultValue(null),
            Browsable(false)
        ]
        public string Username {
            get {
                if (this.credentials == null) 
                    return null;
                  
                return this.credentials.UserName;
            }
            set {                                    
                if (value == Username)
                    return;

                if (value == null) 
                    this.credentials = null;
                else {                    
                    if (this.credentials == null) 
                        this.credentials = new NetworkCredential();

                    this.credentials.UserName = value;                
                }
                                    
                Unbind();
            }            
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Bind"]/*' />
        /// <devdoc>
        /// Binds to the ADs object (if not already bound).
        /// </devdoc>
        private void Bind() {
            Bind(true);
        }

        private void Bind(bool throwIfFail) {
            //Cannot rebind after the object has been disposed, since finalization has been suppressed.

            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
                        
            if ( Path != null && Path.Length != 0 ) {
                //SECREVIEW: Need to demand permission event if adsObject is not null
                //                         this entry might be the result of a search, need to verify
                //                         if the user has permission to browse the object first.            
                if (!browseGranted) {
                    DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Browse, Path);
                    permission.Demand();     
                    browseGranted = true;                                                                                         
                }                                        
            }                    
            
            if (adsObject == null) {                                                                                                                                        
                string pathToUse = Path; 
                if (pathToUse == null || pathToUse.Length == 0) {
                    // get the default naming context. This should be the default root for the search.
                    DirectoryEntry rootDSE = new DirectoryEntry("LDAP://RootDSE");
                
                    //SECREVIEW: Looking at the root of the DS will demand browse permissions
                    //                     on "*" or "LDAP://RootDSE".
                    string defaultNamingContext = (string) rootDSE.Properties["defaultNamingContext"][0];
                    rootDSE.Dispose();
                                    
                    pathToUse = "LDAP://" + defaultNamingContext;                                                                                
                    
                    if (!browseGranted) {
                        DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Browse, pathToUse);
                        permission.Demand();     
                        browseGranted = true;                                                                                         
                    }                                        
                }                                                
            
                // Ensure we've got a thread model set, else CoInitialize() won't have been called.
                if (Thread.CurrentThread.ApartmentState == ApartmentState.Unknown)
                    Thread.CurrentThread.ApartmentState = ApartmentState.MTA;

                Guid g = new Guid("00000000-0000-0000-c000-000000000046"); // IID_IUnknown
                object value = null;                
                int hr = UnsafeNativeMethods.ADsOpenObject(pathToUse, Username, Password, (int)authenticationType, ref g, out value);

                if (hr != 0) {
                    if (throwIfFail) 
                        throw CreateFormattedComException(hr);    
                                            
                }
                else
                    adsObject = (UnsafeNativeMethods.IAds) value;
           }
        }


        // Create new entry with the same data, but different IADs object, and grant it Browse Permission.
        internal DirectoryEntry CloneBrowsable() {
            if (!browseGranted) {
                DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Browse, this.path);
                permission.Demand();     
                browseGranted = true;                                                                                         
            }
            DirectoryEntry newEntry = new DirectoryEntry(this.Path, this.UsePropertyCache, this.Username, this.Password, this.AuthenticationType);
            newEntry.browseGranted = true;
            return newEntry;
        }


        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the <see cref='System.DirectoryServices.DirectoryEntry'/>
        ///       and releases any system resources associated with this component.
        ///    </para>
        /// </devdoc>
        public void Close() {
            Unbind();
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.CommitChanges"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves any
        ///       changes to the entry in the directory store.
        ///    </para>
        /// </devdoc>
        public void CommitChanges() {
            if ( justCreated ) {     
                // Note: Permissions Demand is not necessary here, because entry has already been created with appr. permissions. 
                // Write changes regardless of Caching mode to finish construction of a new entry.
                adsObject.SetInfo();        
                justCreated = false;
                return;
            }
            if (!useCache) {
                // nothing to do
                return;
            }

            if (!Bound)
                return;

            if (!writeGranted) {
                DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Write, this.path);
                permission.Demand();     
                writeGranted = true;                                                                                         
            }
                          
            adsObject.SetInfo();
        }

        internal void CommitIfNotCaching() {

            if ( justCreated )  
                return;   // Do not write changes, beacuse the entry is just under construction until CommitChanges() is called.
                            
            if (useCache)
                return;

            if (!Bound)
                return;

            if (!writeGranted) {
                DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Write, this.path);
                permission.Demand();     
                writeGranted = true;                                                                                         
            }
                               
            adsObject.SetInfo();
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>Creates a copy of this entry as a child of the given parent.</para>
        /// </devdoc>
        public DirectoryEntry CopyTo(DirectoryEntry newParent) {
            return CopyTo(newParent, null);
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.CopyTo1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a copy of this entry as a child of the given parent and
        ///       gives it a new name.
        ///    </para>
        /// </devdoc>
        public DirectoryEntry CopyTo(DirectoryEntry newParent, string newName) {                    
            if (!newParent.IsContainer)
                throw new InvalidOperationException(Res.GetString(Res.DSNotAContainer, newParent.Path));
                
            if (!newParent.writeGranted) {
                DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Write, newParent.path);
                permission.Demand();     
                newParent.writeGranted = true;                                                                                         
            }                
                
            object copy = newParent.ContainerObject.CopyHere(Path, newName);
            return new DirectoryEntry(copy, newParent.UsePropertyCache, Username, Password, AuthenticationType);
        }

        internal static Exception CreateFormattedComException(int hr) {
            string errorMsg = "";
            StringBuilder sb = new StringBuilder(256);
            int result = SafeNativeMethods.FormatMessage(SafeNativeMethods.FORMAT_MESSAGE_IGNORE_INSERTS |
                                       SafeNativeMethods.FORMAT_MESSAGE_FROM_SYSTEM |
                                       SafeNativeMethods.FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       0, hr, 0, sb, sb.Capacity + 1, 0);
            if (result != 0) {
                int i = sb.Length;
                while (i > 0) {
                    char ch = sb[i - 1];
                    if (ch > 32 && ch != '.') break;
                    i--;
                }
                errorMsg = sb.ToString(0, i);
            }                        
            else {
                errorMsg = Res.GetString(Res.DSUnknown, Convert.ToString(hr, 16));                            
            }
                     
            return new COMException(errorMsg, hr);
        }
                                                             
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.DeleteTree"]/*' />
        /// <devdoc>
        ///    <para>Deletes this entry and its entire subtree from the
        ///       Active Directory hierarchy.</para>
        /// </devdoc>
        public void DeleteTree() {
            if (!(AdsObject is UnsafeNativeMethods.IAdsDeleteOps))
                throw new InvalidOperationException(Res.GetString(Res.DSCannotDelete));
                
            if (!writeGranted) {
                DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Write, this.path);
                permission.Demand();     
                writeGranted = true;                                                                                         
            }                
                
            UnsafeNativeMethods.IAdsDeleteOps entry = (UnsafeNativeMethods.IAdsDeleteOps) AdsObject;
            entry.DeleteObject(0);
        }
       
        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Dispose"]/*' />
        /// <devdoc>        
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            // safe to call while finalizing or disposing
            //
            if (!this.disposed && disposing) {
                Close();
                this.disposed = true;
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Exists"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches the directory store at the given
        ///       path to see whether an entry exists.
        ///    </para>
        /// </devdoc>
        public static bool Exists(string path) {
            DirectoryEntry entry = new DirectoryEntry(path);
            try {
                entry.Bind(true);       // throws exceptions (possibly can break applications) 
                return entry.Bound; 
            }    
            catch ( System.Runtime.InteropServices.COMException e ) {
                if ( e.ErrorCode == unchecked((int)0x80072030) )   // ERROR_DS_NO_SUCH_OBJECT (not found in strict sense)
                    return false;    
                throw;
            }
            finally {
                entry.Dispose();    
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.FillCache"]/*' />
        /// <devdoc>
        /// If UsePropertyCache is true, calls GetInfo the first time it's necessary.
        /// If it's false, calls GetInfoEx on the given property name.
        /// </devdoc>
        internal void FillCache(string propertyName) {
            if (UsePropertyCache) {
                if (cacheFilled)
                    return;

                RefreshCache();
                cacheFilled = true;
            }
            else {
                Bind();
                if ( propertyName.Length > 0 )
                    adsObject.GetInfoEx(new object[] { propertyName }, 0);
                else
                    adsObject.GetInfo();  // [alexvec]
            }
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Invoke"]/*' />
        /// <devdoc>
        ///    <para>Calls
        ///       a method on the native Active Directory.</para>
        /// </devdoc>
        public object Invoke(string methodName, params object[] args) {
            if (!writeGranted) {
                DirectoryServicesPermission permission = new DirectoryServicesPermission(DirectoryServicesPermissionAccess.Write, this.path);
                permission.Demand();     
                writeGranted = true;                                                                                         
            }
            
            object target = this.NativeObject;
            Type type = target.GetType();
            object result = type.InvokeMember(methodName, BindingFlags.InvokeMethod, null, target, args);
            if (result is UnsafeNativeMethods.IAds)
                return new DirectoryEntry(result, UsePropertyCache, Username, Password, AuthenticationType);
            else
                return result;
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.MoveTo"]/*' />
        /// <devdoc>
        ///    <para>Moves this entry to the given parent.</para>
        /// </devdoc>
        public void MoveTo(DirectoryEntry newParent) {
            MoveTo(newParent, null);
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.MoveTo1"]/*' />
        /// <devdoc>
        ///    <para>Moves this entry to the given parent, and gives it a new name.</para>
        /// </devdoc>
        public void MoveTo(DirectoryEntry newParent, string newName) {
            if (!(newParent.AdsObject is UnsafeNativeMethods.IAdsContainer))
                throw new InvalidOperationException(Res.GetString(Res.DSNotAContainer, newParent.Path));
            object newEntry = newParent.ContainerObject.MoveHere(Path, newName);

            if (Bound)
                System.Runtime.InteropServices.Marshal.ReleaseComObject(adsObject);     // release old handle
                
            this.adsObject = (UnsafeNativeMethods.IAds) newEntry;
            path = this.adsObject.ADsPath;

            if (!useCache)
                CommitChanges();
            else
                RefreshCache();     // in ADSI cache is lost after moving
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.RefreshCache"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Loads the property values for this directory entry into
        ///       the property cache.
        ///    </para>
        /// </devdoc>
        public void RefreshCache() {
            Bind();
            adsObject.GetInfo();
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.RefreshCache1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Loads the values of the specified properties into the
        ///       property cache.
        ///    </para>
        /// </devdoc>
        public void RefreshCache(string[] propertyNames) {
            Bind();
            
            //Consider, V2, jruiz: there shouldn't be any marshaling issues
            //by just doing: AdsObject.GetInfoEx(object[]propertyNames, 0);
            Object[] names = new Object[propertyNames.Length];
            for (int i = 0; i < propertyNames.Length; i++)
                names[i] = propertyNames[i];
            AdsObject.GetInfoEx(names, 0);

            // this is a half-lie, but oh well. Without it, this method is pointless.
            cacheFilled = true;
        }

        /// <include file='doc\DirectoryEntry.uex' path='docs/doc[@for="DirectoryEntry.Rename"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Changes the name of this entry.
        ///    </para>
        /// </devdoc>
        public void Rename(string newName) {
            MoveTo(Parent, newName);
        }

        private void Unbind() {
            if ( adsObject != null )
                System.Runtime.InteropServices.Marshal.ReleaseComObject(adsObject);
            adsObject = null;
            browseGranted = false;
            writeGranted = false;
        }

    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\resultpropertycollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResultPropertyCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.Security.Permissions;
    using System.Globalization;
    
    /// <include file='doc\ResultPropertyCollection.uex' path='docs/doc[@for="ResultPropertyCollection"]/*' />
    /// <devdoc>
    /// <para>Contains the properties on a <see cref='System.DirectoryServices.SearchResult'/>.</para>
    /// </devdoc>
    public class ResultPropertyCollection : DictionaryBase {
        
        internal ResultPropertyCollection() {
        }

        /// <include file='doc\ResultPropertyCollection.uex' path='docs/doc[@for="ResultPropertyCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the property with the given name.</para>
        /// </devdoc>
        public ResultPropertyValueCollection this[string name] {
            get {
                object objectName = name.ToLower(CultureInfo.InvariantCulture);
                return (ResultPropertyValueCollection) InnerHashtable[objectName];
            }
        }

        /// <include file='doc\ResultPropertyCollection.uex' path='docs/doc[@for="ResultPropertyCollection.PropertyNames"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection PropertyNames {
            get { return Dictionary.Keys; }
        }

        /// <include file='doc\ResultPropertyCollection.uex' path='docs/doc[@for="ResultPropertyCollection.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return Dictionary.Values;
            }
        }                                               
                                               
        internal void Add(string name, ResultPropertyValueCollection value) {
            Dictionary.Add(name.ToLower(CultureInfo.InvariantCulture), value);            
        }        
        
        /// <include file='doc\ResultPropertyCollection.uex' path='docs/doc[@for="ResultPropertyCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string propertyName) {
            object objectName = propertyName.ToLower(CultureInfo.InvariantCulture);
            return Dictionary.Contains(objectName);
        }
        
        /// <include file='doc\ResultPropertyCollection.uex' path='docs/doc[@for="ResultPropertyCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(ResultPropertyValueCollection[] array, int index) {
            Dictionary.Values.CopyTo((Array)array, index);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\searchscope.cs ===
//------------------------------------------------------------------------------
// <copyright file="SearchScope.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    /// <include file='doc\SearchScope.uex' path='docs/doc[@for="SearchScope"]/*' />
    /// <devdoc>
    ///    <para>Specifies the scope of a directory search.</para>
    /// </devdoc>
    public enum SearchScope {
        /// <include file='doc\SearchScope.uex' path='docs/doc[@for="SearchScope.Base"]/*' />
        /// <devdoc>
        ///    <para>Limits the search to the base object. The result contains at most one object. </para>
        /// </devdoc>
        Base = 0,
        /// <include file='doc\SearchScope.uex' path='docs/doc[@for="SearchScope.OneLevel"]/*' />
        /// <devdoc>
        ///    <para>Searched one level of the immediate children, excluding the base object.</para>
        /// </devdoc>
        OneLevel = 1,
        /// <include file='doc\SearchScope.uex' path='docs/doc[@for="SearchScope.Subtree"]/*' />
        /// <devdoc>
        ///    <para>Searches the whole subtree, including all the children and the base object 
        ///       itself.</para>
        /// </devdoc>
        Subtree = 2
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\resultpropertyvaluecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResultPropertyValueCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\ResultPropertyValueCollection.uex' path='docs/doc[@for="ResultPropertyValueCollection"]/*' />
    /// <devdoc>
    ///    <para>Specifies a collection of values for a multi-valued property.</para>
    /// </devdoc>
    public class ResultPropertyValueCollection : ReadOnlyCollectionBase {

        internal ResultPropertyValueCollection(object[] values) {
            if (values == null)
                values = new object[0];
                
            InnerList.AddRange(values);                
        }

        /// <include file='doc\ResultPropertyValueCollection.uex' path='docs/doc[@for="ResultPropertyValueCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[int index] {
            get {
                object returnValue = InnerList[index];
                if (returnValue is Exception)
                    throw (Exception)returnValue;
                else
                    return returnValue;                                    
            }
        }

        /// <include file='doc\ResultPropertyValueCollection.uex' path='docs/doc[@for="ResultPropertyValueCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(object value) {
            return InnerList.Contains(value);
        }                               
        
        /// <include file='doc\ResultPropertyValueCollection.uex' path='docs/doc[@for="ResultPropertyValueCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(object value) {
            return InnerList.IndexOf(value);
        }     
        
        /// <include file='doc\ResultPropertyValueCollection.uex' path='docs/doc[@for="ResultPropertyValueCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(object[] values, int index) {
            InnerList.CopyTo(values, index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\searchresultcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SearchResultCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;

namespace System.DirectoryServices {

    using System;
    using System.Net;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;
    using System.DirectoryServices.Interop;
         
    /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection"]/*' />
    /// <devdoc>
    /// <para>Contains the instances of <see cref='System.DirectoryServices.SearchResult'/> returned during a 
    ///    query to the Active Directory hierarchy through <see cref='System.DirectoryServices.DirectorySearcher'/>.</para>
    /// </devdoc>
    public class SearchResultCollection : MarshalByRefObject, ICollection, IEnumerable, IDisposable {

        private IntPtr handle;        
        private string[] properties;
        private UnsafeNativeMethods.IDirectorySearch searchObject;
        private string filter;
        private ArrayList innerList;
        private bool disposed;
        private DirectoryEntry rootEntry;       // clone of parent entry object
        
        ///<internalonly/>                                                                   
        internal SearchResultCollection(DirectoryEntry root, IntPtr searchHandle, string[] propertiesLoaded, string filter) {
            this.handle = searchHandle;
            this.properties = propertiesLoaded;
            this.filter = filter;            
            this.rootEntry = root;                        
        }                
                                            
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SearchResult this[int index] {
            get {
                return (SearchResult)InnerList[index];
            }
        }
         
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {
                return InnerList.Count;
            }
        }         
                                      
        ///<internalonly/>                                                                       
        internal string Filter {
            get {
                return filter;
            }
        }

        ///<internalonly/>
        private ArrayList InnerList {
            get {
                if (this.innerList == null) {
                    this.innerList = new ArrayList();
                    IEnumerator enumerator = new ResultsEnumerator(this, 
                                                                                           this.rootEntry.Username, 
                                                                                           this.rootEntry.Password,
                                                                                           this.rootEntry.AuthenticationType);
                    while(enumerator.MoveNext())
                        this.innerList.Add(enumerator.Current);                    
                }
                
                return this.innerList;
            }
        }

        ///<internalonly/>                                                                              
        internal UnsafeNativeMethods.IDirectorySearch SearchObject {
            get {
                if (searchObject == null) {
                    searchObject = (UnsafeNativeMethods.IDirectorySearch) rootEntry.AdsObject;   // get it only once                                        
                }
                return searchObject;
            }
        }

        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.Handle"]/*' />
        /// <devdoc>
        ///    <para>Gets the handle returned by IDirectorySearch::ExecuteSearch, which was called
        ///    by the DirectorySearcher that created this object.</para>
        /// </devdoc>
        public IntPtr Handle {
            get {
                //The handle is no longer valid since the object has been disposed.
                if (this.disposed)
                    throw new ObjectDisposedException(GetType().Name);
                    
                return handle;
            }
        }

        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.PropertiesLoaded"]/*' />
        /// <devdoc>
        ///    <para>Gets a read-only collection of the properties 
        ///       specified on <see cref='System.DirectoryServices.DirectorySearcher'/> before the
        ///       search was executed.</para>
        /// </devdoc>
        public string[] PropertiesLoaded {
            get {
                return properties;
            }
        }

        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.Dispose"]/*' />
        /// <devdoc>        
        /// </devdoc>
        public void Dispose() {            
            Dispose(true);
            GC.SuppressFinalize(this);            
        }                
        
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.Dispose1"]/*' />
        /// <devdoc>        
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {            
            if (!this.disposed) {
                if (handle != (IntPtr)0 && this.searchObject != null) {                    
                    try {
                        // NOTE: We can't call methods on SearchObject in the finalizer because it
                        // runs on a different thread. The IDirectorySearch object is STA, so COM must create
                        // a proxy stub to marshal the call back to the original thread. Unfortunately, the
                        // IDirectorySearch interface cannot be registered, because it is not automation
                        // compatible. Therefore the QI for IDirectorySearch on this thread fails, and we get
                        // an InvalidCastException. The conclusion is that the user simply must call Dispose
                        // on this object.         
                    
                        this.searchObject.CloseSearchHandle(handle);                                                                                        
                    }
                    catch(InvalidCastException) {
                    }
                                            
                    handle = (IntPtr)0;
                }
                
                if (disposing)                                                             
                    rootEntry.Dispose();                
                                   
                this.disposed = true;                             
            }
        }
        
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for=".Finalize"]/*' />
        ~SearchResultCollection() {
            Dispose(false);      // finalizer is called => Dispose has not been called yet.
        }        
        
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            // Two ResultsEnumerators can't exist at the same time over the
            // same object. Need to get a new handle, which means re-querying.            
            return new ResultsEnumerator(this, 
                                                       this.rootEntry.Username, 
                                                       this.rootEntry.Password,
                                                       this.rootEntry.AuthenticationType);
        }

        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(SearchResult result) {
            return InnerList.Contains(result);
        }                                             
                                             
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(SearchResult[] results, int index) {
            InnerList.CopyTo(results, index);
        }                                        
                                        
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(SearchResult result) {
            return InnerList.IndexOf(result);
        }                                              
                                              
        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.ICollection.IsSynchronized"]/*' />
        ///<internalonly/>
        bool ICollection.IsSynchronized {  
            get {
                return false;
            }            
        }                          

        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.ICollection.SyncRoot"]/*' />
        ///<internalonly/>             
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }                                  

        /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            InnerList.CopyTo(array, index);
        }             
                          
        /// <devdoc>
        ///    <para> Supports a simple
        ///       ForEach-style iteration over a collection.</para>
        /// </devdoc>
        private class ResultsEnumerator : IEnumerator {
            private NetworkCredential parentCredentials;            
            private AuthenticationTypes parentAuthenticationType;
            private SearchResultCollection results;
            private bool initialized;
            private SearchResult currentResult;
            private bool eof;
            
            internal ResultsEnumerator(SearchResultCollection results, string parentUserName, string parentPassword, AuthenticationTypes parentAuthenticationType) {
                if (parentUserName != null && parentPassword != null) 
                    this.parentCredentials = new NetworkCredential(parentUserName, parentPassword);
                
                this.parentAuthenticationType = parentAuthenticationType;
                this.results = results;
                initialized = false;
            }
            
            /// <devdoc>
            ///    <para>Gets the current element in the collection.</para>
            /// </devdoc>
            public SearchResult Current {
                get {                    
                    if (!initialized || eof)
                        throw new InvalidOperationException(Res.GetString(Res.DSNoCurrentEntry));

                     if (currentResult == null)
                        this.currentResult = GetCurrentResult();
                                            
                    return this.currentResult;
                }                                     
            }

            private unsafe SearchResult GetCurrentResult() {
                SearchResult entry = new SearchResult(this.parentCredentials, this.parentAuthenticationType);
                int hr = 0;
                IntPtr pszColumnName = (IntPtr)0;
                hr = results.SearchObject.GetNextColumnName(results.Handle, (INTPTR_INTPTRCAST)(long) &pszColumnName);                
                while (hr == 0) {                    
                    try {
                        AdsSearchColumn column = new AdsSearchColumn();
                        AdsSearchColumn *pColumn = &column;
                        results.SearchObject.GetColumn(results.Handle, pszColumnName, (INTPTR_INTPTRCAST)(long) pColumn);
                        try {
                            int numValues = column.dwNumValues;
                            AdsValue *pValue = column.pADsValues;
                            object[] values = new object[numValues];
                            for (int i = 0; i < numValues; i++) {                                   
                                values[i] = new AdsValueHelper(*pValue).GetValue();                                
                                pValue++;                                
                            }
                            
                            entry.Properties.Add(Marshal.PtrToStringUni(pszColumnName), new ResultPropertyValueCollection(values));                                                                                                                                                                                
                        }
                        finally {
                            try {
                                results.SearchObject.FreeColumn((INTPTR_INTPTRCAST)(long) pColumn);
                            } 
                            catch ( COMException ) {
                            }
                        }
                    }
                    finally {
                        SafeNativeMethods.FreeADsMem(pszColumnName);
                    }
                    hr = results.SearchObject.GetNextColumnName(results.Handle, (INTPTR_INTPTRCAST)(long) &pszColumnName);
                }

                return entry;                
            }                    
                    
            /// <include file='doc\SearchResultCollection.uex' path='docs/doc[@for="SearchResultCollection.ResultsEnumerator.MoveNext"]/*' />
            /// <devdoc>
            ///    <para>Advances
            ///       the enumerator to the next element of the collection
            ///       and returns a Boolean value indicating whether a valid element is available.</para>
            /// </devdoc>
	        public bool MoveNext() {                
                if (eof)
                    return false;
                    
                this.currentResult = null;                                                
                if (!initialized) {
                    int hr = results.SearchObject.GetFirstRow(results.Handle);

                    if (hr == UnsafeNativeMethods.S_ADS_NOMORE_ROWS) {
                        eof = true;
                        return false;
                    }
                                            
                    //throw a clearer exception if the filter was invalid
                    if (hr == UnsafeNativeMethods.INVALID_FILTER)
                        throw new ArgumentException(Res.GetString(Res.DSInvalidSearchFilter, results.Filter));
                    if (hr != 0)
                        throw DirectoryEntry.CreateFormattedComException(hr);
                
                    eof = false;                                          
                    initialized = true;
                    return true;
                }
                else {
                    int hr = results.SearchObject.GetNextRow(results.Handle);
                    //  SIZE_LIMIT_EXCEEDED occurs when we supply too generic filter or small SizeLimit value.
                    if (hr == UnsafeNativeMethods.S_ADS_NOMORE_ROWS || hr == UnsafeNativeMethods.SIZE_LIMIT_EXCEEDED ) {
                        eof = true;
                        initialized = false;
                        return false;
                    }
                    //throw a clearer exception if the filter was invalid
                    if (hr == UnsafeNativeMethods.INVALID_FILTER)
                        throw new ArgumentException(Res.GetString(Res.DSInvalidSearchFilter, results.Filter));
                    if (hr != 0)
                        throw DirectoryEntry.CreateFormattedComException(hr);
                                
                    eof = false;                                            
                    return true;
                }
            }

            /// <devdoc>
            ///    <para>Resets the enumerator back to its initial position before the first element in the collection.</para>
            /// </devdoc>
            public void Reset() {
                eof = false;
                initialized = false;
            }

            object IEnumerator.Current {
                get {
                    return Current;
                }
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\sortdirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="SortDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    /// <include file='doc\SortDirection.uex' path='docs/doc[@for="SortDirection"]/*' />
    /// <devdoc>
    /// </devdoc>
    public enum SortDirection {
        /// <include file='doc\SortDirection.uex' path='docs/doc[@for="SortDirection.Ascending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ascending = 0,
        /// <include file='doc\SortDirection.uex' path='docs/doc[@for="SortDirection.Descending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Descending = 1
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\searchresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="SearchResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {

    using System;
    using System.Net;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\SearchResult.uex' path='docs/doc[@for="SearchResult"]/*' />
    /// <devdoc>
    ///    <para>Encapsulates a node in the Active Directory hierarchy 
    ///       that is returned during a search through <see cref='System.DirectoryServices.DirectorySearcher'/>.</para>
    /// </devdoc>
    public class SearchResult {
        private NetworkCredential parentCredentials;        
        private AuthenticationTypes parentAuthenticationType;
        private ResultPropertyCollection properties = new ResultPropertyCollection();

        internal SearchResult(NetworkCredential parentCredentials, AuthenticationTypes parentAuthenticationType) {
            this.parentCredentials = parentCredentials;             
            this.parentAuthenticationType = parentAuthenticationType;
        }

        /// <include file='doc\SearchResult.uex' path='docs/doc[@for="SearchResult.GetDirectoryEntry"]/*' />
        /// <devdoc>
        /// <para>Retrieves the <see cref='System.DirectoryServices.DirectoryEntry'/> that corresponds to the <see cref='System.DirectoryServices.SearchResult'/>, from the Active Directory 
        ///    hierarchy.</para>
        /// </devdoc>
        public DirectoryEntry GetDirectoryEntry() {
            if (this.parentCredentials != null)
                return new DirectoryEntry(Path, this.parentCredentials.UserName, this.parentCredentials.Password, this.parentAuthenticationType);            
            else {                
                DirectoryEntry newEntry = new DirectoryEntry(Path);
                newEntry.AuthenticationType = this.parentAuthenticationType;
                return newEntry;
            }                
        }

        /// <include file='doc\SearchResult.uex' path='docs/doc[@for="SearchResult.Path"]/*' />
        /// <devdoc>
        /// <para> Gets the path for this <see cref='System.DirectoryServices.SearchResult'/>.</para>
        /// </devdoc>
        public string Path {
            get {
                return (string) Properties["ADsPath"][0];
            }
        }

        /// <include file='doc\SearchResult.uex' path='docs/doc[@for="SearchResult.Properties"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.DirectoryServices.ResultPropertyCollection'/>
        /// of properties set on this object.</para>
        /// </devdoc>
        public ResultPropertyCollection Properties {
            get {
                return properties;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\sortoption.cs ===
//------------------------------------------------------------------------------
// <copyright file="SortOption.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices {            

    using System.ComponentModel;
    
    /// <include file='doc\SortOption.uex' path='docs/doc[@for="SortOption"]/*' />
    /// <devdoc>
    ///    <para>Specifies how to sort a query.</para>
    /// </devdoc>
    [TypeConverter(typeof(ExpandableObjectConverter))]
    public class SortOption {      
        private string propertyName;
        private SortDirection sortDirection;
    
        /// <include file='doc\SortOption.uex' path='docs/doc[@for="SortOption.SortOption"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SortOption() {
        }
        
        /// <include file='doc\SortOption.uex' path='docs/doc[@for="SortOption.SortOption1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SortOption(string propertyName, SortDirection direction) {
            this.PropertyName = propertyName;
            this.Direction = sortDirection;
        }
        
        /// <include file='doc\SortOption.uex' path='docs/doc[@for="SortOption.PropertyName"]/*' />
        /// <devdoc>
        ///    <para>Specifies a pointer to a stream that contains the type for the attribute.</para>
        /// </devdoc>
        [
            DefaultValue(null),
            DSDescriptionAttribute(Res.DSSortName)
        ]            
        public string PropertyName {       
            get {
                return this.propertyName;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                this.propertyName = value;
            }     
        }
        
        /// <include file='doc\SortOption.uex' path='docs/doc[@for="SortOption.Direction"]/*' />
        /// <devdoc>
        /// <para>Specifies one of the <see cref='System.DirectoryServices.SortDirection'/> values.</para>
        /// </devdoc>
        [
            DefaultValue(SortDirection.Ascending),
            DSDescriptionAttribute(Res.DSSortDirection)
        ]            
        public SortDirection Direction {
            get {
                return  this.sortDirection;
            }
            
            set {
                if (!Enum.IsDefined(typeof(SortDirection), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(SortDirection));
            
                this.sortDirection = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adsauthentication.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsAuthentication.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {

    internal enum AdsAuthentication {
        ADS_SECURE_AUTHENTICATION  = 0x1,
        ADS_USE_ENCRYPTION         = 0x2,
        ADS_USE_SSL                = 0x2,
        ADS_READONLY_SERVER        = 0x4,
        ADS_PROMPT_CREDENTIALS     = 0x8,
        ADS_NO_AUTHENTICATION      = 0x10,
        ADS_FAST_BIND              = 0x20,
        ADS_USE_SIGNING            = 0x40,
        ADS_USE_SEALING            = 0x80
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adssearchpreferenceinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsSearchPreferenceInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {
    using System;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal struct AdsSearchPreferenceInfo {
        public int /*AdsSearchPreferences*/ dwSearchPref;
        internal int pad;
        public AdsValue vValue;
        public int /*AdsStatus*/ dwStatus;
        internal int pad2;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\design\directoryentryconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DirectoryEntryConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

 namespace System.DirectoryServices.Design {    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System;            
    using System.Reflection;
    using System.Collections; 
    using System.Collections.Specialized; 
    using System.Globalization;
        
    /// <include file='doc\DirectoryEntryConverter.uex' path='docs/doc[@for="DirectoryEntryConverter"]/*' />
    /// <internalonly/>
    internal class DirectoryEntryConverter : TypeConverter {
        private static StandardValuesCollection values;        
        private static Hashtable componentsCreated = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                        
        /// <include file='doc\DirectoryEntryConverter.uex' path='docs/doc[@for="DirectoryEntryConverter.CanConvertFrom"]/*' />
        /// <internalonly/>                               
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }                        
                                 
        /// <include file='doc\DirectoryEntryConverter.uex' path='docs/doc[@for="DirectoryEntryConverter.ConvertFrom"]/*' />
        /// <internalonly/>                 
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value != null && value is string) {
               string text = ((string)value).Trim();
            
                if (text == String.Empty)
                    return null;

                if (text.CompareTo(Res.GetString(Res.DSNotSet)) != 0) {
                    DirectoryEntry newEntry = GetFromCache(text);
                    if (newEntry == null) {                                          
                        newEntry = new DirectoryEntry(text);  
                        componentsCreated[text] = newEntry;
                        if (context != null)
                            context.Container.Add(newEntry);                            
                             
                        return newEntry;                                            
                    }                        
                }                    
            }
            
            return null;
        }
                                                                                   
        /// <include file='doc\DirectoryEntryConverter.uex' path='docs/doc[@for="DirectoryEntryConverter.ConvertTo"]/*' />
        /// <internalonly/>                 
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType != null && destinationType == typeof(string)) {                
                if (value != null)
                    return((DirectoryEntry)value).Path;
                else
                    return Res.GetString(Res.DSNotSet);
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }         
        
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="DirectoryEntryConverter.GetStandardValues"]/*' />
        /// <internalonly/>            
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                values = new StandardValuesCollection(new object[] {null});
            }
            return values;
        }
        
        internal static DirectoryEntry GetFromCache(string path) {
            if (componentsCreated.ContainsKey(path)) {
                DirectoryEntry existingComponent = (DirectoryEntry)componentsCreated[path];
                if (existingComponent.Site == null)
                    componentsCreated.Remove(path);
                else {                                                                                        
                    if (existingComponent.Path == path)                                
                        return existingComponent;
                    else                            
                        componentsCreated.Remove(path);    
                }                                                                    
            }
            
            return null;
        }
                                 
                                 
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="DirectoryEntryConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>                                   
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }
        
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="DirectoryEntryConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>                        
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }                   
    }                                    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adssortkey.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsSortKey.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {

    using System;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal struct AdsSortKey {
        public IntPtr pszAttrType;
        public IntPtr pszReserved;     
        public int fReverseOrder;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adsstatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsStatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {

    internal enum AdsStatusEnum {
        ADS_STATUS_S_OK = 0,
        ADS_STATUS_INVALID_SEARCHPREF = 1,
        ADS_STATUS_INVALID_SEARCHPREFVALUE = 2
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adssearchpreferences.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsSearchPreferences.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {

    internal enum AdsSearchPreferences {
        ASYNCHRONOUS = 0,
        DEREF_ALIASES = 1,
        SIZE_LIMIT = 2,
        TIME_LIMIT = 3,
        ATTRIBTYPES_ONLY = 4,
        SEARCH_SCOPE = 5,
        TIMEOUT = 6,
        PAGESIZE = 7,
        PAGED_TIME_LIMIT = 8,
        CHASE_REFERRALS = 9,
        SORT_ON = 10,
        CACHE_RESULTS = 11,
        DIRSYNC = 12,
        TOMBSTONE = 13
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adssearchcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsSearchColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {

    using System;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe struct AdsSearchColumn {
        [MarshalAs(UnmanagedType.LPWStr)]
        public char *pszAttrName;
        public int/*AdsType*/ dwADsType;
        public AdsValue *pADsValues;
        public int dwNumValues;
        public int hReserved;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adspropertyoperation.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsPropertyOperation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.DirectoryServices.Interop {

    using System;
    using System.Runtime.InteropServices;
    using System.Diagnostics;

    internal enum AdsPropertyOperation {
        
        Clear = 1,

        Update = 2,

        Append = 3,

        Delete = 4

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adstype.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {

    internal enum AdsType {
        ADSTYPE_INVALID = 0,
        ADSTYPE_DN_STRING = 1,
        ADSTYPE_CASE_EXACT_STRING = 2,
        ADSTYPE_CASE_IGNORE_STRING = 3,
        ADSTYPE_PRINTABLE_STRING = 4,
        ADSTYPE_NUMERIC_STRING = 5,
        ADSTYPE_BOOLEAN = 6,
        ADSTYPE_INTEGER = 7,
        ADSTYPE_OCTET_STRING = 8,
        ADSTYPE_UTC_TIME = 9,
        ADSTYPE_LARGE_INTEGER = 10,
        ADSTYPE_PROV_SPECIFIC = 11,
        ADSTYPE_OBJECT_CLASS = 12,
        ADSTYPE_CASEIGNORE_LIST = 13,
        ADSTYPE_OCTET_LIST = 14,
        ADSTYPE_PATH = 15,
        ADSTYPE_POSTALADDRESS = 16,
        ADSTYPE_TIMESTAMP = 17,
        ADSTYPE_BACKLINK = 18,
        ADSTYPE_TYPEDNAME = 19,
        ADSTYPE_HOLD = 20,
        ADSTYPE_NETADDRESS = 21,
        ADSTYPE_REPLICAPOINTER = 22,
        ADSTYPE_FAXNUMBER = 23,
        ADSTYPE_EMAIL = 24,
        ADSTYPE_NT_SECURITY_DESCRIPTOR = 25,
        ADSTYPE_UNKNOWN = 26,
        ADSTYPE_DN_WITH_BINARY = 27,
        ADSTYPE_DN_WITH_STRING = 28
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adsvaluehelper2.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsValueHelper2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;
                      

//Consider, V2, jruiz, This class is not completely 64-bit compliant since it 
//marshals a union that represents a bunch of different datatypes, the code 
//will have to be fixed for the specific 64-bit AdsValue definition.
namespace System.DirectoryServices.Interop {

    using System;
    using System.Text;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    struct SystemTime {
       public ushort wYear; 
       public ushort wMonth;
       public ushort wDayOfWeek; 
       public ushort wDay; 
       public ushort wHour; 
       public ushort wMinute; 
       public ushort wSecond;                                                
       public ushort wMilliseconds; 
    }

    [StructLayout(LayoutKind.Sequential)]
    struct DnWithBinary {
       public int       dwLength;
       public IntPtr    lpBinaryValue;       // GUID of directory object
       public IntPtr    pszDNString;         // Distinguished Name
    }

    [StructLayout(LayoutKind.Sequential)]
    struct DnWithString {
       public IntPtr   pszStringValue;      // associated value
       public IntPtr   pszDNString;         // Distinguished Name
    }

    // helper class for dealing with struct AdsValue.
    internal class AdsValueHelper {

        public AdsValue adsvalue;
        private GCHandle pinnedHandle;
        
        public AdsValueHelper(AdsValue adsvalue) {
            this.adsvalue = adsvalue;
        }

        public AdsValueHelper(object managedValue) {
            AdsType adsType = GetAdsTypeForManagedType(managedValue.GetType());
            SetValue(managedValue, adsType);
        }

        public AdsValueHelper(object managedValue, AdsType adsType) {
            SetValue(managedValue, adsType);
        }

        public long LowInt64 {
            get {
                 return (long)((ulong)adsvalue.a + (((ulong)adsvalue.b) << 32 ));                
            }
            set {
                adsvalue.a = (int) (value & 0xFFFFFFFF);
                adsvalue.b = (int) (value >> 32);
            }
        }

        ~AdsValueHelper() {
            if (pinnedHandle.IsAllocated)
                pinnedHandle.Free();
        }

        private AdsType GetAdsTypeForManagedType(Type type) {
            //Consider, V2, jruiz, this code is only excercised by DirectorySearcher
            //it just translates the types needed by such a component, if more managed
            //types are to be used in the future, this function needs to be expanded.
            if (type == typeof(int))
                return AdsType.ADSTYPE_INTEGER;
            if (type == typeof(long))
                return AdsType.ADSTYPE_LARGE_INTEGER;
            if (type == typeof(bool))
                return AdsType.ADSTYPE_BOOLEAN;            
                
            return AdsType.ADSTYPE_UNKNOWN;
        }

        public AdsValue GetStruct() {
            return adsvalue;
        }

        static ushort LowOfInt(int i) {
            return unchecked((ushort)(i & 0xFFFF));
        }
        
        static ushort HighOfInt(int i) {
            return unchecked ( (ushort)( (i >> 16) & 0xFFFF) );
        }
        
        public object GetValue() {            
            switch ((AdsType) adsvalue.dwType) {

                // Common for DNS and LDAP 
                case AdsType.ADSTYPE_UTC_TIME:
                    {
                    SystemTime st = new SystemTime();

                    st.wYear    = LowOfInt(adsvalue.a); 
                    st.wMonth   = HighOfInt(adsvalue.a);
                    st.wDayOfWeek   = LowOfInt(adsvalue.b); 
                    st.wDay         = HighOfInt(adsvalue.b); 
                    st.wHour    = LowOfInt(adsvalue.c); 
                    st.wMinute  = HighOfInt(adsvalue.c); 
                    st.wSecond          = LowOfInt(adsvalue.d);
                    st.wMilliseconds    = HighOfInt(adsvalue.d);

                    return new DateTime(st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
                    }
                    
                case AdsType.ADSTYPE_DN_WITH_BINARY: 
                    {
                    DnWithBinary dnb = (DnWithBinary)Marshal.PtrToStructure((INTPTR_INTPTRCAST)adsvalue.a, typeof(DnWithBinary));
                    byte[] bytes = new byte[dnb.dwLength];
                    Marshal.Copy(dnb.lpBinaryValue, bytes, 0, dnb.dwLength);
                    StringBuilder strb = new StringBuilder();
                    if (bytes.Length == 16)
                        strb.Append(new Guid(bytes).ToString());
                    else 
                        strb.Append(Convert.ToBase64String(bytes));
                    
                                                                                                    
                    strb.Append(":");
                    strb.Append(Marshal.PtrToStringUni(dnb.pszDNString));    
                    return strb.ToString();
                    }
                                        
                case AdsType.ADSTYPE_DN_WITH_STRING:
                    {
                    DnWithString dns = (DnWithString) Marshal.PtrToStructure((INTPTR_INTPTRCAST)adsvalue.a, typeof(DnWithString));
                    StringBuilder strb = new StringBuilder( Marshal.PtrToStringUni(dns.pszStringValue) ); 
                    strb.Append(":");
                    strb.Append( Marshal.PtrToStringUni(dns.pszDNString) );    
                    return strb.ToString();
                    }

                case AdsType.ADSTYPE_DN_STRING:
                case AdsType.ADSTYPE_CASE_EXACT_STRING:
                case AdsType.ADSTYPE_CASE_IGNORE_STRING:
                case AdsType.ADSTYPE_PRINTABLE_STRING:
                case AdsType.ADSTYPE_NUMERIC_STRING:
                case AdsType.ADSTYPE_OBJECT_CLASS:
                    // string
                    return Marshal.PtrToStringUni((INTPTR_INTPTRCAST)adsvalue.a);

                case AdsType.ADSTYPE_BOOLEAN:
                    // bool
                    return adsvalue.a != 0;

                case AdsType.ADSTYPE_INTEGER:
                    // int
                    return adsvalue.a;

                case AdsType.ADSTYPE_NT_SECURITY_DESCRIPTOR:
                case AdsType.ADSTYPE_OCTET_STRING:
                    // byte[]
                    int len = adsvalue.a;
                    byte[] value = new byte[len];
                    Marshal.Copy((INTPTR_INTPTRCAST)adsvalue.b, value, 0, len);
                    return value;

                case AdsType.ADSTYPE_INVALID:
                    throw new InvalidOperationException( Res.GetString(Res.DSConvertTypeInvalid) );
                
                case AdsType.ADSTYPE_LARGE_INTEGER:
                    return LowInt64;

                
                // not used in LDAP
                case AdsType.ADSTYPE_CASEIGNORE_LIST:
                case AdsType.ADSTYPE_OCTET_LIST:
                case AdsType.ADSTYPE_PATH:
                case AdsType.ADSTYPE_POSTALADDRESS:
                case AdsType.ADSTYPE_TIMESTAMP:
                case AdsType.ADSTYPE_NETADDRESS:
                case AdsType.ADSTYPE_FAXNUMBER:
                case AdsType.ADSTYPE_EMAIL:

                case AdsType.ADSTYPE_BACKLINK:
                case AdsType.ADSTYPE_HOLD:
                case AdsType.ADSTYPE_TYPEDNAME:
                case AdsType.ADSTYPE_REPLICAPOINTER:
                case AdsType.ADSTYPE_UNKNOWN:
                case AdsType.ADSTYPE_PROV_SPECIFIC:
                    return new NotImplementedException( Res.GetString(Res.DSAdsvalueTypeNYI, "0x" + Convert.ToString(adsvalue.dwType, 16) ) );

                default:
                    return new ArgumentException(Res.GetString(Res.DSConvertFailed, "0x" + Convert.ToString(LowInt64, 16), "0x" + Convert.ToString(adsvalue.dwType, 16)));
            }
        }

        private unsafe void SetValue(object managedValue, AdsType adsType) {
            adsvalue = new AdsValue();
            adsvalue.dwType = (int) adsType;
            switch (adsType) {
                case AdsType.ADSTYPE_INTEGER:
                    adsvalue.a = (int) managedValue;
                    adsvalue.b = 0;
                    break;
                case AdsType.ADSTYPE_LARGE_INTEGER:
                    LowInt64 = (long) managedValue;
                    break;
                case AdsType.ADSTYPE_BOOLEAN:
                    if ((bool) managedValue)
                        LowInt64 = -1;
                    else
                        LowInt64 = 0;
                    break;
                case AdsType.ADSTYPE_PROV_SPECIFIC:                 
                    byte[] bytes = (byte[]) managedValue;
                    // filling in an ADS_PROV_SPECIFIC struct.
                    // 1st dword (our member a) is DWORD dwLength.
                    // 2nd dword (our member b) is byte *lpValue.
                    adsvalue.a = bytes.Length;
                    pinnedHandle = GCHandle.Alloc(bytes, GCHandleType.Pinned);                    
                    adsvalue.b = (int)pinnedHandle.AddrOfPinnedObject();
                    break;
                default:
                    throw new NotImplementedException( Res.GetString(Res.DSAdsvalueTypeNYI, "0x" + Convert.ToString((int)adsType, 16) ) );
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {    
    using System;
    using System.Text;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;
    
    [
    ComVisible(false), 
    SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern void VariantClear(IntPtr pObject);
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern void VariantInit(IntPtr pObject);
        [DllImport(ExternDll.Activeds)]
        public static extern bool FreeADsMem(IntPtr pVoid);
        
        public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100,
            FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200,
            FORMAT_MESSAGE_FROM_STRING = 0x00000400,
            FORMAT_MESSAGE_FROM_HMODULE = 0x00000800,
            FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000,
            FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000,
            FORMAT_MESSAGE_MAX_WIDTH_MASK = 0x000000FF;

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int FormatMessage(int dwFlags, int lpSource, int dwMessageId,
                                                int dwLanguageId, StringBuilder lpBuffer, int nSize, int arguments);

        
        [System.Runtime.InteropServices.ComVisible(false)]
        public class EnumVariant {

            private static readonly object NoMoreValues = new object();
            private Object currentValue = NoMoreValues;
            private IEnumVariant enumerator;

            public EnumVariant(IEnumVariant en) {
                if (en == null)
                    throw new ArgumentNullException("en");
                enumerator = en;
            }

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.EnumVariant.GetNext"]/*' />
            /// <devdoc>
            /// Moves the enumerator to the next value In the list.
            /// </devdoc>
            public bool GetNext() {
                Advance();
                return currentValue != NoMoreValues;
            }

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.EnumVariant.GetValue"]/*' />
            /// <devdoc>
            /// Returns the current value of the enumerator. If GetNext() has never been called,
            /// or if it has been called but it returned false, will throw an exception.
            /// </devdoc>
            public Object GetValue() {
                if (currentValue == NoMoreValues)
                    throw new InvalidOperationException(Res.GetString(Res.DSEnumerator));
                return currentValue;
            }

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.EnumVariant.Reset"]/*' />
            /// <devdoc>
            /// Returns the enumerator to the start of the sequence.
            /// </devdoc>
            public void Reset() {
                enumerator.Reset();
                currentValue = NoMoreValues;
            }

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.EnumVariant.Advance"]/*' />
            /// <devdoc>
            /// Moves the pointer to the next value In the contained IEnumVariant, and
            /// stores the current value In currentValue.
            /// </devdoc>
            private void Advance() {
                currentValue = NoMoreValues;
                IntPtr addr = Marshal.AllocCoTaskMem(16 /*Marshal.SizeOf(typeof(VARIANT))*/);
                try {
                    int[] numRead = new int[] { 0 };
                    SafeNativeMethods.VariantInit(addr);
                    enumerator.Next(1, addr, numRead);
                    try {
                        if (numRead[0] > 0) {
                            currentValue = Marshal.GetObjectForNativeVariant(addr);
                        }
                    }
                    finally {
                        SafeNativeMethods.VariantClear(addr);
                    }
                }
                finally {
                    Marshal.FreeCoTaskMem(addr);
                }
            }
        }

        [ComImport(), Guid("00020404-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumVariant {
            
            [SuppressUnmanagedCodeSecurityAttribute()]
             void Next(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int celt,
                    [In, Out] 
                       IntPtr rgvar,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      int[] pceltFetched);

            [SuppressUnmanagedCodeSecurityAttribute()]
             void Skip(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int celt);

            [SuppressUnmanagedCodeSecurityAttribute()]
             void Reset();

            [SuppressUnmanagedCodeSecurityAttribute()]
             void Clone(
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                       IEnumVariant[] ppenum);
        }                   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false)   
    ]
    internal class NativeMethods {                                        
               
        public  enum AuthenticationModes {
            SecureAuthentication  = 0x1,
            UseEncryption         = 0x2,
            UseSSL                = 0x2,
            ReadonlyServer        = 0x4,
            // PromptCredentials     = 0x8,   // Deprecated by ADSI
            NoAuthentication      = 0x10,
            FastBind              = 0x20,
            UseSigning            = 0x40,
            UseSealing            = 0x80,
            UseDelegation = 0x100,
            UseServerBinding = 0x200    
        }                                                         
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\changedfilters.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChangedFilters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {

    using System.Diagnostics;
    

    using System;

    /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters"]/*' />
    /// <devdoc>
    ///    <para>Specifies the changes to watch
    ///       for in a file or folder.</para>
    /// </devdoc>
    [Flags]
    public enum NotifyFilters {
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.FileName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FileName     = 0x00000001,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.DirectoryName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DirectoryName= 0x00000002,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.Attributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The attributes of the file or folder.
        ///       
        ///    </para>
        /// </devdoc>
        Attributes   = 0x00000004,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The size of the file or folder.
        ///       
        ///    </para>
        /// </devdoc>
        Size         = 0x00000008,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.LastWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       date that the file or folder last had anything written to it.
        ///       
        ///    </para>
        /// </devdoc>
        LastWrite    = 0x00000010,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.LastAccess"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The date that the file or folder was last opened.
        ///       
        ///    </para>
        /// </devdoc>
        LastAccess   = 0x00000020,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.CreationTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CreationTime = 0x00000040,
        /// <include file='doc\ChangedFilters.uex' path='docs/doc[@for="NotifyFilters.Security"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The security settings of the file or folder.
        ///       
        ///    </para>
        /// </devdoc>
        Security     = 0x00000100,
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\adsvalue2.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdsValue2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {
    using System;    
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal struct AdsValue {
        public int /*AdsType*/ dwType;
        internal int pad;
	public int a;
        public int b;
        public int c;
        public int d;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\ds\system\directoryservices\interop\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.DirectoryServices.Interop {
    using System.Runtime.InteropServices;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    ComVisible(false), 
    SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        [DllImport(ExternDll.Activeds, ExactSpelling=true, EntryPoint="ADsGetObject", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int ADsGetObject(String path, [In, Out] ref Guid iid, [Out, MarshalAs(UnmanagedType.Interface)] out object ppObject);

        [DllImport(ExternDll.Activeds, ExactSpelling=true, EntryPoint="ADsOpenObject", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntADsOpenObject(string path, string userName, string password, int flags, [In, Out] ref Guid iid, [Out, MarshalAs(UnmanagedType.Interface)] out object ppObject);
        public static int ADsOpenObject(string path, string userName, string password, int flags, [In, Out] ref Guid iid, [Out, MarshalAs(UnmanagedType.Interface)] out object ppObject) {
            try {
                return IntADsOpenObject(path, userName, password, flags, ref iid, out ppObject);
            }
            catch(EntryPointNotFoundException) {
                throw new InvalidOperationException(Res.GetString(Res.DSAdsiNotInstalled));
            }
        }
        
        [ComImport, Guid("FD8256D0-FD15-11CE-ABC4-02608C9E7553"), System.Runtime.InteropServices.InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        public interface IAds {
            string Name {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            string Class {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            string GUID {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            string ADsPath {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            string Parent {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            string Schema {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void GetInfo();
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void SetInfo();
    
            [return: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
            Object Get(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string bstrName);
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void Put(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string bstrName, 
                [In, MarshalAs(UnmanagedType.Struct)]
                Object vProp);
    
            [return: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
            Object GetEx(
                [In, MarshalAs(UnmanagedType.BStr)] 
                String bstrName);
    
            
            [SuppressUnmanagedCodeSecurityAttribute()]
            void PutEx(
                [In, MarshalAs(UnmanagedType.U4)] 
                int lnControlCode, 
                [In, MarshalAs(UnmanagedType.BStr)] 
                string bstrName, 
                [In, MarshalAs(UnmanagedType.Struct)]
                Object vProp);
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void GetInfoEx(
                [In, MarshalAs(UnmanagedType.Struct)]
                Object vProperties, 
                [In, MarshalAs(UnmanagedType.U4)] 
                int lnReserved);
        }
                             
        [ComImport, Guid("001677D0-FD16-11CE-ABC4-02608C9E7553"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        public interface IAdsContainer {
            int Count {
                [return: MarshalAs(UnmanagedType.U4)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            object _NewEnum {
                [return: MarshalAs(UnmanagedType.Interface)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            object Filter {
                [return: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
                [param: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
                set;
            }
    
            object Hints {
                [return: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
                [param: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
                set;
            }
    
            [return: MarshalAs(UnmanagedType.Interface)][SuppressUnmanagedCodeSecurityAttribute()]
            object GetObject(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string className, 
                [In, MarshalAs(UnmanagedType.BStr)] 
                string relativeName);
    
            [return: MarshalAs(UnmanagedType.Interface)][SuppressUnmanagedCodeSecurityAttribute()]
            object Create(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string className, 
                [In, MarshalAs(UnmanagedType.BStr)] 
                string relativeName);
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void Delete(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string className, 
                [In, MarshalAs(UnmanagedType.BStr)] 
                string relativeName);
    
            [return: MarshalAs(UnmanagedType.Interface)][SuppressUnmanagedCodeSecurityAttribute()]
            object CopyHere(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string sourceName, 
                [In, MarshalAs(UnmanagedType.BStr)] 
                string newName);
    
            [return: MarshalAs(UnmanagedType.Interface)][SuppressUnmanagedCodeSecurityAttribute()]
            object MoveHere(
                [In, MarshalAs(UnmanagedType.BStr)] 
                string sourceName, 
                [In, MarshalAs(UnmanagedType.BStr)] 
                string newName);
        }
        
        [ComImport, Guid("B2BD0902-8878-11D1-8C21-00C04FD8D503"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        public interface IAdsDeleteOps {
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void DeleteObject(int flags);
        }    
              

        [ComImport, Guid("05792C8E-941F-11D0-8529-00C04FD8D503"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        public interface IAdsPropertyEntry {
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void Clear();
    
            string Name {
                [return: MarshalAs(UnmanagedType.BStr)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
                [param: MarshalAs(UnmanagedType.BStr)]
                set;
            }
    
            int ADsType {                
                get;                
                set;
            }
    
            int ControlCode {                
                get;                
                set;
            }
    
            object Values {
                [return: MarshalAs(UnmanagedType.Struct)]
                get;
                [param: MarshalAs(UnmanagedType.Struct)]
                set;
            }    
        }              
        
        [ComImport, Guid("C6F602B6-8F69-11D0-8528-00C04FD8D503"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
        public interface IAdsPropertyList {
    
            int PropertyCount {
                [return: MarshalAs(UnmanagedType.U4)][SuppressUnmanagedCodeSecurityAttribute()]
                get;
            }
    
            [return: MarshalAs(UnmanagedType.I4)][SuppressUnmanagedCodeSecurityAttribute()][PreserveSig]
            int Next([Out, MarshalAs(UnmanagedType.Struct)] out object nextProp);
                
            void Skip([In] int cElements);
                
            void Reset();
    
            [return: MarshalAs(UnmanagedType.Struct)][SuppressUnmanagedCodeSecurityAttribute()]
            object Item([In, MarshalAs(UnmanagedType.Struct)] object varIndex);
    
            [return: MarshalAs(UnmanagedType.Struct)]
            object GetPropertyItem([In, MarshalAs(UnmanagedType.BStr)] string bstrName, int ADsType);
                
            void PutPropertyItem([In, MarshalAs(UnmanagedType.Struct)] object varData);
                
            void ResetPropertyItem([In, MarshalAs(UnmanagedType.Struct)] object varEntry);
                
            void PurgePropertyList();
    
        }
                                             
        [ComImport, Guid("109BA8EC-92F0-11D0-A790-00C04FD8D5A8"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IDirectorySearch {
            
            [SuppressUnmanagedCodeSecurityAttribute()]
            void SetSearchPreference(
                [In]
                IntPtr /*ads_searchpref_info * */pSearchPrefs,
                //ads_searchpref_info[] pSearchPrefs,
                int dwNumPrefs);
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void ExecuteSearch(
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string pszSearchFilter,
                [In, MarshalAs(UnmanagedType.LPArray)]
                string[] pAttributeNames,
                [In]
                int dwNumberAttributes,
                [Out]
                out IntPtr hSearchResult);
    
            [SuppressUnmanagedCodeSecurityAttribute()]
            void AbandonSearch([In] IntPtr hSearchResult);
    
            [return: MarshalAs(UnmanagedType.U4)][SuppressUnmanagedCodeSecurityAttribute()][PreserveSig]
            int GetFirstRow([In] IntPtr hSearchResult);
    
            [return: MarshalAs(UnmanagedType.U4)][SuppressUnmanagedCodeSecurityAttribute()][PreserveSig]
            int GetNextRow([In] IntPtr hSearchResult);
    
            [return: MarshalAs(UnmanagedType.U4)][SuppressUnmanagedCodeSecurityAttribute()][PreserveSig]
            int GetPreviousRow([In] IntPtr hSearchResult);
    
            [return: MarshalAs(UnmanagedType.U4)][SuppressUnmanagedCodeSecurityAttribute()][PreserveSig]
            int GetNextColumnName(
                [In] IntPtr hSearchResult,
                [Out]
                IntPtr ppszColumnName);      
            
            [SuppressUnmanagedCodeSecurityAttribute()]
            void GetColumn(
                [In] IntPtr hSearchResult,
                [In] //, MarshalAs(UnmanagedType.LPWStr)]
                IntPtr /* char * */ szColumnName,
                [In]
                IntPtr pSearchColumn);    
         
            [SuppressUnmanagedCodeSecurityAttribute()]               
            void FreeColumn(
                [In]
                IntPtr pSearchColumn);
    
            [SuppressUnmanagedCodeSecurityAttribute()]               
            void CloseSearchHandle([In] IntPtr hSearchResult);
        }
          
        // IDirecorySearch return codes  
        internal const int S_ADS_NOMORE_ROWS = 0x00005012;
        internal const int INVALID_FILTER = unchecked((int)0x8007203E);
        internal const int SIZE_LIMIT_EXCEEDED = unchecked((int)0x80072023);
          
                       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\erroreventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;

    /// <include file='doc\ErrorEventArgs.uex' path='docs/doc[@for="ErrorEventArgs"]/*' />
    /// <devdoc>
    ///    <para>Provides
    ///       data for the <see cref='E:System.IO.FileSystemWatcher.Error'/> event.</para>
    /// </devdoc>
    public class ErrorEventArgs : EventArgs {
        private Exception exception;

        /// <include file='doc\ErrorEventArgs.uex' path='docs/doc[@for="ErrorEventArgs.ErrorEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the class.
        ///    </para>
        /// </devdoc>
        public ErrorEventArgs(Exception exception) {
            this.exception = exception;
        }

        /// <include file='doc\ErrorEventArgs.uex' path='docs/doc[@for="ErrorEventArgs.GetException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Exception'/> that represents the error that occurred.
        ///    </para>
        /// </devdoc>
        public virtual Exception GetException() {
            return this.exception;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\erroreventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;

    /// <include file='doc\ErrorEventHandler.uex' path='docs/doc[@for="ErrorEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will
    ///       handle the <see cref='E:System.IO.FileSystemWatcher.Error'/>
    ///       event of
    ///       a <see cref='T:System.IO.FileSystemWatcher'/>.</para>
    /// </devdoc>
    public delegate void ErrorEventHandler(object sender, ErrorEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\filesystemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileSystemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.IO {

    using System.Diagnostics;

    using System;

    /// <include file='doc\FileSystemEventHandler.uex' path='docs/doc[@for="FileSystemEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.IO.FileSystemWatcher.Changed'/>, <see cref='System.IO.FileSystemWatcher.Created'/>, or <see cref='System.IO.FileSystemWatcher.Deleted'/> event of a <see cref='System.IO.FileSystemWatcher'/>
    /// class.</para>
    /// </devdoc>
    public delegate void FileSystemEventHandler(object sender, FileSystemEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\internalbufferoverflowexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="InternalBufferOverflowException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.IO {

    using System.Diagnostics;
    using System.Runtime.Serialization;
    using System;

    /// <include file='doc\InternalBufferOverflowException.uex' path='docs/doc[@for="InternalBufferOverflowException"]/*' />
    /// <devdoc>
    ///    <para>The exception that is thrown when the internal buffer overflows.</para>
    /// </devdoc>
    [Serializable]
    public class InternalBufferOverflowException : SystemException {
        /// <include file='doc\InternalBufferOverflowException.uex' path='docs/doc[@for="InternalBufferOverflowException.InternalBufferOverflowException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new default instance of the <see cref='System.IO.InternalBufferOverflowException'/> class.</para>
        /// </devdoc>
        public InternalBufferOverflowException() : base() {
            HResult = HResults.InternalBufferOverflow;
        }

        /// <include file='doc\InternalBufferOverflowException.uex' path='docs/doc[@for="InternalBufferOverflowException.InternalBufferOverflowException1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.IO.InternalBufferOverflowException'/> class with the error
        ///    message to be displayed
        ///    specified.</para>
        /// </devdoc>
        public InternalBufferOverflowException(string message) : base(message) {
            HResult =HResults.InternalBufferOverflow;
        }

        /// <include file='doc\InternalBufferOverflowException.uex' path='docs/doc[@for="InternalBufferOverflowException.InternalBufferOverflowException2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.IO.InternalBufferOverflowException'/>
        /// class with the message to be displayed and the generated inner exception specified.</para>
        /// </devdoc>
        public InternalBufferOverflowException(string message, Exception inner) : base(message, inner) {
            HResult = HResults.InternalBufferOverflow;
        }
        
        /// <internalonly/>             
        protected InternalBufferOverflowException(SerializationInfo info, StreamingContext context) : base (info, context) {            
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\filesystemeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileSystemEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {

    using System.Diagnostics;
    using System.Security.Permissions;

    using System;

    /// <include file='doc\FileSystemEventArgs.uex' path='docs/doc[@for="FileSystemEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the directory events: <see cref='System.IO.FileSystemWatcher.Changed'/>, <see cref='System.IO.FileSystemWatcher.Created'/>, <see cref='System.IO.FileSystemWatcher.Deleted'/>.</para>
    /// </devdoc>
    public class FileSystemEventArgs : EventArgs {
        private WatcherChangeTypes changeType;
        private string name;
        private string fullPath;

        /// <include file='doc\FileSystemEventArgs.uex' path='docs/doc[@for="FileSystemEventArgs.FileSystemEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.IO.FileSystemEventArgs'/> class.</para>
        /// </devdoc>
        public FileSystemEventArgs(WatcherChangeTypes changeType, string directory, string name)
        {
            this.changeType = changeType;
            this.name = name;

            // Ensure that the directory name ends with a "\"
            if (!directory.EndsWith("\\")) {
                directory = directory + "\\";
            }

            this.fullPath = directory + name;
        }

        /// <include file='doc\FileSystemEventArgs.uex' path='docs/doc[@for="FileSystemEventArgs.ChangeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       one of the <see cref='System.IO.WatcherChangeTypes'/>
        ///       values.
        ///    </para>
        /// </devdoc>
        public WatcherChangeTypes ChangeType {
            get {
                return changeType;
            }
        }

        /// <include file='doc\FileSystemEventArgs.uex' path='docs/doc[@for="FileSystemEventArgs.FullPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the
        ///       fully qualifed path of the affected file or directory.
        ///    </para>
        /// </devdoc>
        public string FullPath {
            get {
                return fullPath;
            }
        }


        /// <include file='doc\FileSystemEventArgs.uex' path='docs/doc[@for="FileSystemEventArgs.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the name of the affected file or directory.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\iodescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="IODescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\IODescriptionAttribute.uex' path='docs/doc[@for="IODescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class IODescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\IODescriptionAttribute.uex' path='docs/doc[@for="IODescriptionAttribute.IODescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public IODescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\IODescriptionAttribute.uex' path='docs/doc[@for="IODescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\patternmatcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="PatternMatcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.IO {
    using System.Text;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Globalization;

    internal class PatternMatcher {
        /// <include file='doc\PatternMatcher.uex' path='docs/doc[@for="PatternMatcher.MATCHES_ARRAY_SIZE"]/*' />
        /// <devdoc>
        ///     Private constants (directly from C header files)
        /// </devdoc>
        private const int MATCHES_ARRAY_SIZE = 16;
        private const char ANSI_DOS_STAR = '>';
        private const char ANSI_DOS_QM = '<';
        private const char DOS_DOT = '"';

        /// <include file='doc\PatternMatcher.uex' path='docs/doc[@for="PatternMatcher.MatchPattern"]/*' />
        /// <devdoc>
        ///     Tells whether a given name matches the expression given with the same
        ///     (looser) semantics that the DOS or NT Command prompt has.
        /// </devdoc>
        public static bool MatchPattern(string expression, string name) {
            // Short-circuit in case it's "*.*" or "*"
            if (String.Compare(expression, "*.*", false, CultureInfo.InvariantCulture) == 0) {
                return true;
            }
            if (String.Compare(expression, "*", false, CultureInfo.InvariantCulture) == 0) {
                return true;
            }

            int length = expression.Length;
            StringBuilder buffer = new StringBuilder(expression);

            // If it's a "abc*", append a ".*" at the end of it.
            int index = expression.LastIndexOf('*');
            if (index == (length - 1)) {
                buffer.Append(".*");
            }

            for (int i = 0; i < length; i++) {
                char c = buffer[i];

                if (c == '*') {
                    buffer[i] = ANSI_DOS_STAR;
                }
                else if (c == '?') {
                    buffer[i] = ANSI_DOS_QM;
                }
                else if (c == '.') {
                    buffer[i] = DOS_DOT;
                }
                else if (c == '\\') {
                    throw new ArgumentException(SR.GetString(SR.PatternInvalidChar, c));
                }
                else {
                    buffer[i] = Char.ToUpper(c, CultureInfo.InvariantCulture);
                }
            }

            return StrictMatchPattern(buffer.ToString(), name.ToUpper(CultureInfo.InvariantCulture));
        }


        /// <include file='doc\PatternMatcher.uex' path='docs/doc[@for="PatternMatcher.StrictMatchPattern"]/*' />
        /// <devdoc>
        ///     Tells whether a given name matches the expression given with a strict (i.e. UNIX like)
        ///     semantics.  This code is a port of unmanaged code.  Original code comment follows:
        ///
        ///    Routine Description:
        ///
        ///        This routine compares a Dbcs name and an expression and tells the caller
        ///        if the name is in the language defined by the expression.  The input name
        ///        cannot contain wildcards, while the expression may contain wildcards.
        ///
        ///        Expression wild cards are evaluated as shown in the nondeterministic
        ///        finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.
        ///
        ///
        ///                 ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT
        ///
        ///
        ///                                           S
        ///                                        &lt;-----&lt;
        ///                                     X  |     |  e       Y
        ///                 X * Y ==       (0)-----&gt;-(1)-&gt;-----(2)-----(3)
        ///
        ///
        ///                                          S-.
        ///                                        &lt;-----&lt;
        ///                                     X  |     |  e       Y
        ///                 X ~* Y ==      (0)-----&gt;-(1)-&gt;-----(2)-----(3)
        ///
        ///
        ///
        ///                                    X     S     S     Y
        ///                 X ?? Y ==      (0)---(1)---(2)---(3)---(4)
        ///
        ///
        ///
        ///                                    X     .        .      Y
        ///                 X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
        ///                                       |      |________|
        ///                                       |           ^   |
        ///                                       |_______________|
        ///                                          ^EOF or .^
        ///
        ///
        ///                                    X     S-.     S-.     Y
        ///                 X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
        ///                                       |      |________|
        ///                                       |           ^   |
        ///                                       |_______________|
        ///                                          ^EOF or .^
        ///
        ///
        ///
        ///             where S is any single character
        ///
        ///                   S-. is any single character except the final .
        ///
        ///                   e is a null character transition
        ///
        ///                   EOF is the end of the name string
        ///
        ///        In words:
        ///
        ///            * matches 0 or more characters.
        ///
        ///            ? matches exactly 1 character.
        ///
        ///            DOS_STAR matches 0 or more characters until encountering and matching
        ///                the final . in the name.
        ///
        ///            DOS_QM matches any single character, or upon encountering a period or
        ///                end of name string, advances the expression to the end of the
        ///                set of contiguous DOS_QMs.
        ///
        ///            DOS_DOT matches either a . or zero characters beyond name string.
        ///
        ///    Arguments:
        ///
        ///        Expression - Supplies the input expression to check against
        ///
        ///        Name - Supplies the input name to check for.
        ///
        ///    Return Value:
        ///
        ///        BOOLEAN - TRUE if Name is an element in the set of strings denoted
        ///            by the input Expression and FALSE otherwise.
        ///
        /// </devdoc>
        public static bool StrictMatchPattern(string expression, string name) {
            int nameOffset;
            int exprOffset;
            int length;

            int srcCount;
            int destCount;
            int previousDestCount;
            int matchesCount;

            char nameChar = '\0';
            char exprChar = '\0';

            int[] previousMatches = new int[MATCHES_ARRAY_SIZE];
            int[] currentMatches = new int[MATCHES_ARRAY_SIZE];

            int maxState;
            int currentState;

            bool nameFinished = false;

            //
            //  The idea behind the algorithm is pretty simple.  We keep track of
            //  all possible locations in the regular expression that are matching
            //  the name.  If when the name has been exhausted one of the locations
            //  in the expression is also just exhausted, the name is in the language
            //  defined by the regular expression.
            //

            if (name == null || name.Length == 0 || expression == null || expression.Length == 0) {
                return false;
            }

            //
            //  Special case by far the most common wild card search of * or *.*
            //

            if (expression.Equals("*") || expression.Equals("*.*")) {
                return true;
            }

            // Consider, V2, jruiz: If this class is ever exposed for generic use,
            // we need to make sure that name doesn't contain wildcards. Currently 
            // the only component that calls this method is FileSystemWatcher and
            // it will never pass a name that contains a wildcard.
            

            //
            //  Also special case expressions of the form *X.  With this and the prior
            //  case we have covered virtually all normal queries.
            //
            if (expression[0] == '*' && expression.IndexOf('*', 1) == -1) {
                int rightLength = expression.Length - 1;
                // if name is shorter that the stuff to the right of * in expression, we don't
                // need to do the string compare, otherwise we compare rightlength characters
                // and the end of both strings.
                if (name.Length >= rightLength && String.Compare(expression, 1, name, name.Length - rightLength, rightLength, true, CultureInfo.InvariantCulture) == 0) {
                    return true;
                }
            }

            //
            //  Walk through the name string, picking off characters.  We go one
            //  character beyond the end because some wild cards are able to match
            //  zero characters beyond the end of the string.
            //
            //  With each new name character we determine a new set of states that
            //  match the name so far.  We use two arrays that we swap back and forth
            //  for this purpose.  One array lists the possible expression states for
            //  all name characters up to but not including the current one, and other
            //  array is used to build up the list of states considering the current
            //  name character as well.  The arrays are then switched and the process
            //  repeated.
            //
            //  There is not a one-to-one correspondence between state number and
            //  offset into the expression.  This is evident from the NFAs in the
            //  initial comment to this function.  State numbering is not continuous.
            //  This allows a simple conversion between state number and expression
            //  offset.  Each character in the expression can represent one or two
            //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
            //  ExprOffset*2 + 1.  All other expreesion characters can produce only
            //  a single state.  Thus ExprOffset = State/2.
            //
            //
            //  Here is a short description of the variables involved:
            //
            //  NameOffset  - The offset of the current name char being processed.
            //
            //  ExprOffset  - The offset of the current expression char being processed.
            //
            //  SrcCount    - Prior match being investigated with current name char
            //
            //  DestCount   - Next location to put a matching assuming current name char
            //
            //  NameFinished - Allows one more itteration through the Matches array
            //                 after the name is exhusted (to come *s for example)
            //
            //  PreviousDestCount - This is used to prevent entry duplication, see coment
            //
            //  PreviousMatches   - Holds the previous set of matches (the Src array)
            //
            //  CurrentMatches    - Holds the current set of matches (the Dest array)
            //
            //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
            //

            //
            //  Set up the initial variables
            //

            previousMatches[0] = 0;
            matchesCount = 1;

            nameOffset = 0;
            maxState = expression.Length * 2;

            while (! nameFinished) {
                if (nameOffset < name.Length) {
                    nameChar = name[nameOffset];
                    length = 1;
                    nameOffset++;
                }
                else {
                    nameFinished = true;

                    //
                    //  if we have already exhasted the expression, C#.  Don't
                    //  continue.
                    //
                    if (previousMatches[matchesCount - 1] == maxState) {
                        break;
                    }
                }

                //
                //  Now, for each of the previous stored expression matches, see what
                //  we can do with this name character.
                //
                srcCount = 0;
                destCount = 0;
                previousDestCount = 0;

                while (srcCount < matchesCount) {

                    //
                    //  We have to carry on our expression analysis as far as possible
                    //  for each character of name, so we loop here until the
                    //  expression stops matching.  A clue here is that expression
                    //  cases that can match zero or more characters end with a
                    //  continue, while those that can accept only a single character
                    //  end with a break.
                    //
                    exprOffset = ((previousMatches[srcCount++] + 1) / 2);
                    length = 0;

                    while (true) {
                        if ( exprOffset == expression.Length ) {
                            break;
                        }

                        //
                        //  The first time through the loop we don't want
                        //  to increment ExprOffset.
                        //

                        exprOffset += length;

                        currentState = exprOffset * 2;

                        if (exprOffset == expression.Length) {
                            currentMatches[destCount++] = maxState;
                            break;
                        }

                        exprChar = expression[exprOffset];
                        length = 1;

                        //
                        //  Before we get started, we have to check for something
                        //  really gross.  We may be about to exhaust the local
                        //  space for ExpressionMatches[][], so we have to allocate
                        //  some pool if this is the case.  Yuk!
                        //

                        if (destCount >= MATCHES_ARRAY_SIZE - 2) {
                            int newSize = currentMatches.Length * 2;
                            int [] tmp = new int[newSize];
                            Array.Copy(currentMatches, tmp, currentMatches.Length);
                            currentMatches = tmp;

                            tmp = new int[newSize];
                            Array.Copy(previousMatches, tmp, previousMatches.Length);
                            previousMatches = tmp;
                        }

                        //
                        //  * matches any character zero or more times.
                        //

                        if (exprChar == '*') {
                            currentMatches[destCount++] = currentState;
                            currentMatches[destCount++] = (currentState + 1);
                            continue;
                        }

                        //
                        //  DOS_STAR matches any character except . zero or more times.
                        //

                        if (exprChar == ANSI_DOS_STAR) {
                            bool iCanEatADot = false;

                            //
                            //  If we are at a period, determine if we are allowed to
                            //  consume it, ie. make sure it is not the last one.
                            //
                            if (!nameFinished && (nameChar == '.') ) {
                                char tmpChar;
                                int offset;

                                int nameLength = name.Length;
                                for (offset = nameOffset; offset < nameLength; offset ++ ) {
                                    tmpChar = name[offset];
                                    length = 1;

                                    if (tmpChar == '.') {
                                        iCanEatADot = true;
                                        break;
                                    }
                                }
                            }

                            if (nameFinished || (nameChar != '.') || iCanEatADot) {
                                currentMatches[destCount++] = currentState;
                                currentMatches[destCount++] = (currentState + 1);
                                continue;
                            } else {

                                //
                                //  We are at a period.  We can only match zero
                                //  characters (ie. the epsilon transition).
                                //
                                currentMatches[destCount++] = (currentState + 1);
                                continue;
                            }
                        }

                        //
                        //  The following expreesion characters all match by consuming
                        //  a character, thus force the expression, and thus state
                        //  forward.
                        //
                        currentState += length * 2;

                        //
                        //  DOS_QM is the most complicated.  If the name is finished,
                        //  we can match zero characters.  If this name is a '.', we
                        //  don't match, but look at the next expression.  Otherwise
                        //  we match a single character.
                        //
                        if (exprChar == ANSI_DOS_QM) {

                            if (nameFinished || (nameChar == '.') ) {
                                continue;
                            }

                            currentMatches[destCount++] = currentState;
                            break;
                        }

                        //
                        //  A DOS_DOT can match either a period, or zero characters
                        //  beyond the end of name.
                        //
                        if (exprChar == DOS_DOT) {

                            if (nameFinished) {
                                continue;
                            }

                            if (nameChar == '.') {
                                currentMatches[destCount++] = currentState;
                                break;
                            }
                        }

                        //
                        //  From this point on a name character is required to even
                        //  continue, let alone make a match.
                        //
                        if (nameFinished) {
                            break;
                        }

                        //
                        //  If this expression was a '?' we can match it once.
                        //
                        if (exprChar == '?') {
                            currentMatches[destCount++] = currentState;
                            break;
                        }

                        //
                        //  Finally, check if the expression char matches the name char
                        //
                        if (exprChar == nameChar) {
                            currentMatches[destCount++] = currentState;
                            break;
                        }

                        //
                        //  The expression didn't match so go look at the next
                        //  previous match.
                        //

                        break;
                    }


                    //
                    //  Prevent duplication in the destination array.
                    //
                    //  Each of the arrays is montonically increasing and non-
                    //  duplicating, thus we skip over any source element in the src
                    //  array if we just added the same element to the destination
                    //  array.  This guarentees non-duplication in the dest. array.
                    //

                    if ((srcCount < matchesCount) && (previousDestCount < destCount) ) {
                        while (previousDestCount < destCount) {
                            int previousLength = previousMatches.Length;
                            while ((srcCount < previousLength) && (previousMatches[srcCount] < currentMatches[previousDestCount])) {
                                srcCount += 1;
                            }
                            previousDestCount += 1;
                        }
                    }
                }

                //
                //  If we found no matches in the just finished itteration, it's time
                //  to bail.
                //

                if ( destCount == 0 ) {
                    return false;
                }

                //
                //  Swap the meaning the two arrays
                //

                {
                    int[] tmp;

                    tmp = previousMatches;

                    previousMatches = currentMatches;

                    currentMatches = tmp;
                }

                matchesCount = destCount;
            }

            currentState = previousMatches[matchesCount - 1];

            return currentState == maxState;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\renamedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RenamedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.IO {

    using System.Diagnostics;

    using System;


    /// <include file='doc\RenamedEventHandler.uex' path='docs/doc[@for="RenamedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.IO.FileSystemWatcher.Renamed'/> event of a <see cref='System.IO.FileSystemWatcher'/>
    /// class.</para>
    /// </devdoc>
    public delegate void RenamedEventHandler(object sender, RenamedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\renamedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="RenamedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.IO {

    using System.Diagnostics;
    using System.Security.Permissions;
    using System;


    /// <include file='doc\RenamedEventArgs.uex' path='docs/doc[@for="RenamedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.IO.FileSystemWatcher.Renamed'/> event.</para>
    /// </devdoc>
    public class RenamedEventArgs : FileSystemEventArgs {
        private string oldName;
        private string oldFullPath;

        /// <include file='doc\RenamedEventArgs.uex' path='docs/doc[@for="RenamedEventArgs.RenamedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.IO.RenamedEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public RenamedEventArgs(WatcherChangeTypes changeType, string directory, string name, string oldName)
            : base(changeType, directory, name) {

            // Ensure that the directory name ends with a "\"
            if (!directory.EndsWith("\\")) {
                directory = directory + "\\";
            }
            
            this.oldName = oldName;
            this.oldFullPath = directory + oldName;
        }

        /// <include file='doc\RenamedEventArgs.uex' path='docs/doc[@for="RenamedEventArgs.OldFullPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the previous fully qualified path of the affected file or directory.
        ///    </para>
        /// </devdoc>
        public string OldFullPath {
            get {
                new FileIOPermission(FileIOPermissionAccess.Read, Path.GetPathRoot(oldFullPath)).Demand();
                return oldFullPath;
            }
        }

        /// <include file='doc\RenamedEventArgs.uex' path='docs/doc[@for="RenamedEventArgs.OldName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the old name of the affected file or directory.
        ///    </para>
        /// </devdoc>
        public string OldName {
            get {
                return oldName;
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\watcherchangetypes.cs ===
//------------------------------------------------------------------------------
// <copyright file="WatcherChangeTypes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {

    using System.Diagnostics;
    using System;

    
    /// <include file='doc\WatcherChangeTypes.uex' path='docs/doc[@for="WatcherChangeTypes"]/*' />
    /// <devdoc>
    ///    <para>Changes that may occur to a file or directory.
    ///       </para>
    /// </devdoc>
    [Flags()]
    public enum WatcherChangeTypes {
        /// <include file='doc\WatcherChangeTypes.uex' path='docs/doc[@for="WatcherChangeTypes.Created"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The creation of a file or folder.
        ///    </para>
        /// </devdoc>
        Created = 1,
        /// <include file='doc\WatcherChangeTypes.uex' path='docs/doc[@for="WatcherChangeTypes.Deleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The deletion of a file or folder.
        ///    </para>
        /// </devdoc>
        Deleted = 2,
        /// <include file='doc\WatcherChangeTypes.uex' path='docs/doc[@for="WatcherChangeTypes.Changed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The change of a file or folder.
        ///    </para>
        /// </devdoc>
        Changed = 4,
        /// <include file='doc\WatcherChangeTypes.uex' path='docs/doc[@for="WatcherChangeTypes.Renamed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The renaming of a file or folder.
        ///    </para>
        /// </devdoc>
        Renamed = 8,
        // all of the above 
        /// <include file='doc\WatcherChangeTypes.uex' path='docs/doc[@for="WatcherChangeTypes.All"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        All = Created | Deleted | Changed | Renamed
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
!if "$(LINKONLY)" != "1"
compileWithResGen: 
    $(ECHO_PROCESSING_CMD) Compile_With_ResGen
    if exist %URTSDKTARGET%\bin\resgen.exe %URTSDKTARGET%\bin\resgen.exe /compile Resources\System\Messaging\Design\QueuePathDialog.resx,$(O)\QueuePathDialog.resources
    if not exist %URTSDKTARGET%\bin\resgen.exe copy Resources\System\Messaging\Design\QueuePathDialog.resources $(O)
!else
compileWithResGen: 
    echo Nothing to do this phase.
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\accesscontrolentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessControlEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AccessControlEntry.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Text;
using System.Messaging.Interop;

namespace System.Messaging {    
    /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class AccessControlEntry {
        //const int customRightsMask   = 0x0000ffff;
        const StandardAccessRights standardRightsMask = (StandardAccessRights)0x001f0000;
        const GenericAccessRights genericRightsMask  = unchecked((GenericAccessRights)0xf0000000);
    
        internal int accessFlags = 0;
        Trustee trustee = null;
        AccessControlEntryType entryType = AccessControlEntryType.Allow;
    
        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.AccessControlEntry"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AccessControlEntry() {            
        }

        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.AccessControlEntry1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AccessControlEntry(Trustee trustee) {            
            this.Trustee = trustee;
        }
   
        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.AccessControlEntry2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AccessControlEntry(Trustee trustee, GenericAccessRights genericAccessRights, StandardAccessRights standardAccessRights, AccessControlEntryType entryType) {                        
            this.GenericAccessRights = genericAccessRights;
            this.StandardAccessRights = standardAccessRights;
            this.Trustee = trustee;
            this.EntryType = entryType;
        }

        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.EntryType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AccessControlEntryType EntryType {
            get { return entryType; }
            set { 
                if (!Enum.IsDefined(typeof(AccessControlEntryType), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(AccessControlEntryType));
                    
                entryType = value; 
            }
        }
    
        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.CustomAccessRights"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected int CustomAccessRights {
            get {
                return accessFlags;
            }
            set {
                accessFlags = value;
            }
        }
    
        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.GenericAccessRights"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public GenericAccessRights GenericAccessRights {
            get {
                return (GenericAccessRights)accessFlags & genericRightsMask;
            }
            set {
                // make sure these flags really are genericAccessRights
                if ((value & genericRightsMask) != value) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(GenericAccessRights));
                    
                accessFlags = (accessFlags & (int)~genericRightsMask) | (int)value;
            }
        }
    
        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.StandardAccessRights"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StandardAccessRights StandardAccessRights {
            get {
                return (StandardAccessRights)accessFlags & standardRightsMask;
            }
            set {
                // make sure these flags really are standardAccessRights
                if ((value & standardRightsMask) != value) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StandardAccessRights));
                                    
                accessFlags = (accessFlags & (int)~standardRightsMask) | (int)value;
            }
        }
    
        /// <include file='doc\AccessControlEntry.uex' path='docs/doc[@for="AccessControlEntry.Trustee"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Trustee Trustee {
            get {
                return trustee;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                trustee = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\filesystemwatcher.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileSystemWatcher.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;
                                         
namespace System.IO {
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.IO;  
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Security.Permissions;
    using System.Security;
    using System.Globalization;
    
    /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher"]/*' />
    /// <devdoc>
    ///    <para>Listens to the system directory change notifications and
    ///       raises events when a directory or file within a directory changes.</para>
    /// </devdoc>
    [
    DefaultEvent("Changed"),
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust"),
    PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")
    ]
    public class FileSystemWatcher : Component, ISupportInitialize {
        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.directory"]/*' />
        /// <devdoc>
        ///     Private instance variables
        /// </devdoc>
        // Directory being monitored
        private string directory;

        // Filter for name matching
        private string filter;

        // Unmanaged handle to monitored directory
        private IntPtr directoryHandle = (IntPtr)(-1);

        // The watch filter for the API call.
        private const NotifyFilters defaultNotifyFilters = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;
        private NotifyFilters notifyFilters = defaultNotifyFilters;

        // Flag to watch subtree of this directory
        private bool includeSubdirectories = false;

        // Flag to note whether we are attached to the thread pool and responding to changes
        private bool enabled = false;

        // Are we in init?
        private bool initializing = false;

        // Buffer size
        private int internalBufferSize = 8192;
                
        // Used for synchronization
        private WaitForChangedResult changedResult;
        private bool isChanged = false;
        private ISynchronizeInvoke synchronizingObject;
        private bool readGranted;
        private bool disposed;

        // Event handlers
        private FileSystemEventHandler onChangedHandler = null;
        private FileSystemEventHandler onCreatedHandler = null;
        private FileSystemEventHandler onDeletedHandler = null;
        private RenamedEventHandler onRenamedHandler = null;
        private ErrorEventHandler onErrorHandler = null;

        // Thread gate holder and constats
        private bool stopListening = false;        

        // Used for async method
        private bool runOnce = false;

        // To validate the input for "path"
        private static char[] wildcards = new char[] { '?', '*' };

        private static int notifyFiltersValidMask;

        static FileSystemWatcher() {
            notifyFiltersValidMask = 0;
            foreach (int enumValue in Enum.GetValues(typeof(NotifyFilters)))
                notifyFiltersValidMask |= enumValue;
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.FileSystemWatcher"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.IO.FileSystemWatcher'/> class.</para>
        /// </devdoc>
        public FileSystemWatcher() {
            this.directory = String.Empty;
            this.filter = "*.*";
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.FileSystemWatcher1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.IO.FileSystemWatcher'/> class,
        ///       given the specified directory to monitor.
        ///    </para>
        /// </devdoc>
        public FileSystemWatcher(string path) : this(path, "*.*") {
        }


        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.FileSystemWatcher2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.IO.FileSystemWatcher'/> class,
        ///       given the specified directory and type of files to monitor.
        ///    </para>
        /// </devdoc>
        public FileSystemWatcher(string path, string filter) {
            if (path == null)
                throw new ArgumentNullException("path");

            if (filter == null)
                throw new ArgumentNullException("filter");
            
            // Early check for directory parameter so that an exception can be thrown as early as possible.
            if (path.Length == 0 || !Directory.Exists(path))
                throw new ArgumentException(SR.GetString(SR.InvalidDirName, path));            

            this.directory = path;
            this.filter = filter;
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.NotifyFilter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of changes to watch for.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(defaultNotifyFilters),
        IODescription(SR.FSW_ChangedFilter)
        ]
        public NotifyFilters NotifyFilter {
            get {
                return notifyFilters;
            }
            set {
                if (((int) value & ~notifyFiltersValidMask) != 0)
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(NotifyFilters));                                                                                

                if (notifyFilters != value) {
                    notifyFilters = value;

                    Restart();
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.EnableRaisingEvents"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the component is enabled.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        IODescription(SR.FSW_Enabled)
        ]
        public bool EnableRaisingEvents {
            get {
                return enabled;
            }
            set {
                if (enabled == value) {
                    return;
                }

                enabled = value;

                if (!IsSuspended()) {
                    if (enabled) {
                        StartRaisingEvents();
                    }
                    else {
                        StopRaisingEvents();
                    }
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Filter"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the filter string, used to determine what files are monitored in a directory.</para>
        /// </devdoc>
        [
        DefaultValue("*.*"),
        IODescription(SR.FSW_Filter),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
        RecommendedAsConfigurable(true),        
        ]
        public string Filter {
            get {
                return filter;
            }
            set {                
                if (value == null || value == String.Empty) {
                    value = "*.*";
                }
                if (String.Compare(filter, value, true, CultureInfo.InvariantCulture) != 0) {
                    filter = value;
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.IncludeSubdirectories"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a
        ///       value indicating whether subdirectories within the specified path should be monitored.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        IODescription(SR.FSW_IncludeSubdirectories)
        ]
        public bool IncludeSubdirectories {
            get {
                return includeSubdirectories;
            }
            set {
                if (includeSubdirectories != value) {
                    includeSubdirectories = value;

                    Restart();
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.InternalBufferSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the size of the internal buffer.</para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(8192)
        ]
        public int InternalBufferSize {
            get {
                return internalBufferSize;
            }
            set {
                if (internalBufferSize != value) {
                    if (value < 4096) {
                        value = 4096;
                    }

                    internalBufferSize = value;

                    Restart();
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Path"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the path of the directory to watch.</para>
        /// </devdoc>
        [
        DefaultValue(""),
        IODescription(SR.FSW_Path),
        Editor("System.Diagnostics.Design.FSWPathEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),        
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
        RecommendedAsConfigurable(true)
        ]
        public string Path {
            get {
                return directory;
            }
            set {
                value = (value == null) ? string.Empty : value;
                if (String.Compare(directory, value, true, CultureInfo.InvariantCulture) != 0) {
                    if (DesignMode) {
                        // Don't check the path if in design mode, try to do simple syntax check                 
                        if (value.IndexOfAny(FileSystemWatcher.wildcards) != -1 || value.IndexOfAny(System.IO.Path.InvalidPathChars) != -1) {
                            throw new ArgumentException(SR.GetString(SR.InvalidDirName, value));
                        }
                    }
                    else {
                        if (!Directory.Exists(value))                             
                            throw new ArgumentException(SR.GetString(SR.InvalidDirName, value));                        
                    }
                    directory = value;
                    readGranted = false;
                    Restart();
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Site"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false)]
        public override ISite Site {
            get {
                return base.Site;
            }
            set {
                base.Site = value;

                // set EnableRaisingEvents to true at design time so the user
                // doesn't have to manually. We can't do this in
                // the constructor because in code it should
                // default to false.
                if (Site != null && Site.DesignMode)
                    EnableRaisingEvents = true;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.SynchronizingObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the object used to marshal the event handler calls issued as a
        ///       result of a directory change.
        ///    </para>
        /// </devdoc>
        [DefaultValue(null), IODescription(SR.FSW_SynchronizingObject)]
        public ISynchronizeInvoke SynchronizingObject {
            get {
                if (this.synchronizingObject == null && DesignMode) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        object baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is ISynchronizeInvoke)
                            this.synchronizingObject = (ISynchronizeInvoke)baseComponent;
                    }                        
                }
            
                return this.synchronizingObject;
            }
            
            set {
                this.synchronizingObject = value;
            }
        }        

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Changed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a file or directory in the specified <see cref='System.IO.FileSystemWatcher.Path'/>
        ///       is changed.
        ///    </para>
        /// </devdoc>
        [IODescription(SR.FSW_Changed)]
        public event FileSystemEventHandler Changed {
            add {
                onChangedHandler += value;
            }
            remove {                            
                onChangedHandler -= value;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Created"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a file or directory in the specified <see cref='System.IO.FileSystemWatcher.Path'/>
        ///       is created.
        ///    </para>
        /// </devdoc>
        [IODescription(SR.FSW_Created)]
        public event FileSystemEventHandler Created {
            add {
                onCreatedHandler += value;
            }
            remove {
                onCreatedHandler -= value;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Deleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a file or directory in the specified <see cref='System.IO.FileSystemWatcher.Path'/>
        ///       is deleted.
        ///    </para>
        /// </devdoc>
        [IODescription(SR.FSW_Deleted)]
        public event FileSystemEventHandler Deleted {
            add{
                onDeletedHandler += value;
            }
            remove {
                onDeletedHandler -= value;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the internal buffer overflows.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public event ErrorEventHandler Error {
            add {
                onErrorHandler += value;
            }
            remove {
                onErrorHandler -= value;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Renamed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a file or directory in the specified <see cref='System.IO.FileSystemWatcher.Path'/>
        ///       is renamed.
        ///    </para>
        /// </devdoc>
        [IODescription(SR.FSW_Renamed)]
        public event RenamedEventHandler Renamed {
            add {
                onRenamedHandler += value;
            }
            remove {
                onRenamedHandler -= value;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>Notifies the object that initialization is beginning and tells it to standby.</para>
        /// </devdoc>
        public void BeginInit() {
            bool oldEnabled = enabled;
            StopRaisingEvents();
            enabled = oldEnabled;
            initializing = true;
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.CompletionStatusChanged"]/*' />
        /// <devdoc>
        ///     Callback from thread pool.
        /// </devdoc>
        /// <internalonly/>
        private unsafe void CompletionStatusChanged(uint errorCode, uint numBytes, NativeOverlapped  * overlappedPointer) {
            Overlapped overlapped = Overlapped.Unpack(overlappedPointer);
            ulong bufferPtrTemp = ((ulong)overlapped.OffsetHigh) << 32;
            bufferPtrTemp = bufferPtrTemp | (0x00000000ffffffff & (ulong)overlapped.OffsetLow);
            IntPtr bufferPtr = (IntPtr)bufferPtrTemp;
                                        
            try {                
                if (stopListening) {
                    return;
                }                                                
                                                                                                                                                                              
                lock(this) {                                
                    if (errorCode != 0) {
                        if (errorCode == 995 /* ERROR_OPERATION_ABORTED */) {
                            //Win2000 inside a service the first completion status is false
                            //cannot return without monitoring again.
                            //NOTE, stefanph: Because this return statement is inside a try/finally block,
                            //the finally block will execute. It does restart the monitoring.
                            return;
                        }
                        else {
                            OnError(new ErrorEventArgs(new Win32Exception((int)errorCode)));
                            EnableRaisingEvents = false;
                            return;
                        }
                    }
    
                    if (numBytes == 0) {
                        NotifyInternalBufferOverflowEvent();
                    }
                    else {  // Else, parse each of them and notify appropriate delegates
    
                        /******
                            Format for the buffer is the following C struct:
    
                            typedef struct _FILE_NOTIFY_INFORMATION {
                               DWORD NextEntryOffset;
                               DWORD Action;
                               DWORD FileNameLength;
                               WCHAR FileName[1];
                            } FILE_NOTIFY_INFORMATION;
    
                            NOTE1: FileNameLength is length in bytes.
                            NOTE2: The Filename is a Unicode string that's NOT NULL terminated.
                            NOTE3: A NextEntryOffset of zero means that it's the last entry
                        *******/
    
                        // Parse the file notify buffer
                        int offset = 0;
                        int nextOffset, action, nameLength;
                        string oldName = null;
    
                        do {
                            // Get next offset
                            nextOffset = Marshal.ReadInt32((IntPtr)((long)bufferPtr + offset));
    
                            // Get change flag
                            action = Marshal.ReadInt32((IntPtr)((long)bufferPtr + offset + 4));
    
                            // Get filename length (in bytes)
                            nameLength = Marshal.ReadInt32((IntPtr)((long)bufferPtr + offset + 8));
    
                            string name = Marshal.PtrToStringUni((IntPtr)((long)bufferPtr + offset + 12), nameLength / 2).ToLower(CultureInfo.InvariantCulture);
    
                            /* A slightly convoluted piece of code follows.  Here's what's happening:
    
                               We wish to collapse the poorly done rename notifications from the
                               ReadDirectoryChangesW API into a nice rename event. So to do that,
                               it's assumed that a FILE_ACTION_RENAMED_OLD_NAME will be followed
                               immediately by a FILE_ACTION_RENAMED_NEW_NAME in the buffer, which is
                               all that the following code is doing.
    
                               On a FILE_ACTION_RENAMED_OLD_NAME, it asserts that no previous one existed
                               and saves its name.  If there are no more events in the buffer, it'll
                               assert and fire a RenameEventArgs with the Name field null.
    
                               If a NEW_NAME action comes in with no previous OLD_NAME, we assert and fire
                               a rename event with the OldName field null.
    
                               If the OLD_NAME and NEW_NAME actions are indeed there one after the other,
                               we'll fire the RenamedEventArgs normally and clear oldName.
    
                               If the OLD_NAME is followed by another action, we assert and then fire the
                               rename event with the Name field null and then fire the next action.
    
                               In case it's not a OLD_NAME or NEW_NAME action, we just fire the event normally.
    
                               (Phew!)
                             */
    
                            // If the action is RENAMED_FROM, save the name of the file
                            if (action == Direct.FILE_ACTION_RENAMED_OLD_NAME) {
                                Debug.Assert(oldName == null, "FileSystemWatcher: Two FILE_ACTION_RENAMED_OLD_NAME " +
                                                              "in a row!  [" + oldName + "], [ " + name + "]");
    
                                oldName = name;
                            }
                            else if (action == Direct.FILE_ACTION_RENAMED_NEW_NAME) {
                                if (oldName != null) {
                                    NotifyRenameEventArgs(WatcherChangeTypes.Renamed, name, oldName);
                                    oldName = null;
                                }
                                else {
                                    Debug.Assert(false, "FileSystemWatcher: FILE_ACTION_RENAMED_NEW_NAME with no" +
                                                                  "old name! [ " + name + "]");
    
                                    NotifyRenameEventArgs(WatcherChangeTypes.Renamed, name, oldName);
                                    oldName = null;
                                }
                            }
                            else {
                                if (oldName != null) {
                                    Debug.Assert(false, "FileSystemWatcher: FILE_ACTION_RENAMED_OLD_NAME with no" +
                                                                  "new name!  [" + oldName + "]");
    
                                    NotifyRenameEventArgs(WatcherChangeTypes.Renamed, null, oldName);
                                    oldName = null;
                                }
    
                                // Notify each file of change
                                NotifyFileSystemEventArgs(action, name);
    
                            }
    
                            offset += nextOffset;
                        } while (nextOffset != 0);
    
                        if (oldName != null) {
                            Debug.Assert(false, "FileSystemWatcher: FILE_ACTION_RENAMED_OLD_NAME with no" +
                                                          "new name!  [" + oldName + "]");
    
                            NotifyRenameEventArgs(WatcherChangeTypes.Renamed, null, oldName);
                            oldName = null;
                        }
                    }                                                                        
                }
            }
            finally {                                                            
                Overlapped.Free(overlappedPointer);                
                if (stopListening || runOnce) {
                    if (bufferPtr != (IntPtr)0) 
                        Marshal.FreeHGlobal(bufferPtr);
                } 
                else {                   
                    Monitor(bufferPtr);
                }                                    		        
            }                            
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Dispose1"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {                
                //Stop raising events cleans up managed and
                //unmanaged resources.                    
                StopRaisingEvents();

                // Clean up managed resources
                onChangedHandler = null;
                onCreatedHandler = null;
                onDeletedHandler = null;
                onRenamedHandler = null;
                onErrorHandler = null;
                readGranted = false;
            }
            else {               
                stopListening = true;
                             
                // Clean up unmanaged resources
                if (directoryHandle != (IntPtr)(-1)) {
                    UnsafeNativeMethods.CloseHandle(new HandleRef(this, directoryHandle));
                }                                                          
            }                
            
            this.disposed = true;
            base.Dispose(disposing);
        }
                             
        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.EndInit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies the object that initialization is complete.
        ///    </para>
        /// </devdoc>
        public void EndInit() {
            initializing = false;
            // Unless user told us NOT to start after initialization, we'll start listening
            // to events
            if (directory.Length != 0 && enabled == true)
                StartRaisingEvents();            
        }        

        
        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.IsSuspended"]/*' />
        /// <devdoc>
        ///     Returns true if the component is either in a Begin/End Init block or in design mode.
        /// </devdoc>
        // <internalonly/>
        //
        private bool IsSuspended() {
            return initializing || DesignMode;
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.MatchPattern"]/*' />
        /// <devdoc>
        ///     Sees if the name given matches the name filter we have.
        /// </devdoc>
        /// <internalonly/>
        private bool MatchPattern(string relativePath) {            
            string name = System.IO.Path.GetFileName(relativePath);            
            if (name != null)
                return PatternMatcher.StrictMatchPattern(filter.ToUpper(CultureInfo.InvariantCulture), name.ToUpper(CultureInfo.InvariantCulture));
            else
                return false;                
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Monitor"]/*' />
        /// <devdoc>
        ///     Calls native API and sets up handle with the directory change API.
        /// </devdoc>
        /// <internalonly/>
        private unsafe void Monitor(IntPtr bufferPtr) {
            if (!enabled || (directoryHandle == (IntPtr)(-1))) {
                return;
            }

            Overlapped overlapped = new Overlapped();            
            if (bufferPtr == (IntPtr) 0) {
                try {
                    bufferPtr = Marshal.AllocHGlobal((INTPTR_INTPTRCAST)internalBufferSize);
                } catch (OutOfMemoryException) {
                        throw new OutOfMemoryException(SR.GetString(SR.BufferSizeTooLarge, internalBufferSize.ToString()));
                }
            }                                                    
                        
            ulong bufferPtrTemp = (ulong)bufferPtr;
            overlapped.OffsetHigh = (int)(0xffffffff00000000 & bufferPtrTemp);    
            overlapped.OffsetLow = (int)(0x00000000ffffffff & bufferPtrTemp);
            NativeOverlapped* overlappedPointer = overlapped.Pack(new IOCompletionCallback(this.CompletionStatusChanged));
            
            IntPtr h = directoryHandle;
            int size;
            bool ok = UnsafeNativeMethods.ReadDirectoryChangesW(new HandleRef(this, h),
                                               new HandleRef(this, bufferPtr),
                                               internalBufferSize,
                                               includeSubdirectories ? 1 : 0,
                                               (int)notifyFilters,
                                               out size,
                                               overlappedPointer,
                                               NativeMethods.NullHandleRef);

            if (! ok) {
                Overlapped.Free(overlappedPointer);                
                Marshal.FreeHGlobal(bufferPtr);
                
                // If the handle was for some reason changed or closed during this call, then don't throw an
                // exception.  Else, it's a valid error.
                if ((h == directoryHandle) && (directoryHandle != (IntPtr)(-1))) {
                    OnError(new ErrorEventArgs(new Win32Exception()));
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.NotifyFileSystemEventArgs"]/*' />
        /// <devdoc>
        ///     Raises the event to each handler in the list.
        /// </devdoc>
        /// <internalonly/>
        private void NotifyFileSystemEventArgs(int action, string name) {
            if (!MatchPattern(name)) {
                return;
            }

            switch (action) {
                case Direct.FILE_ACTION_ADDED:
                    OnCreated(new FileSystemEventArgs(WatcherChangeTypes.Created, directory, name));
                    break;
                case Direct.FILE_ACTION_REMOVED:
                    OnDeleted(new FileSystemEventArgs(WatcherChangeTypes.Deleted, directory, name));
                    break;
                case Direct.FILE_ACTION_MODIFIED:
                    OnChanged(new FileSystemEventArgs(WatcherChangeTypes.Changed, directory, name));
                    break;
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.NotifyInternalBufferOverflowEvent"]/*' />
        /// <devdoc>
        ///     Raises the event to each handler in the list.
        /// </devdoc>
        /// <internalonly/>
        private void NotifyInternalBufferOverflowEvent() {
            InternalBufferOverflowException ex = new InternalBufferOverflowException(SR.GetString(SR.FSW_BufferOverflow, directory));

            ErrorEventArgs errevent = new ErrorEventArgs(ex);

            OnError(errevent);
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.NotifyRenameEventArgs"]/*' />
        /// <devdoc>
        ///     Raises the event to each handler in the list.
        /// </devdoc>
        /// <internalonly/>
        private void NotifyRenameEventArgs(WatcherChangeTypes action, string name, string oldName) {
            //filter if neither new name or old name are a match a specified pattern
            if (!MatchPattern(name) && !MatchPattern(oldName)) {
                return;
            }

            RenamedEventArgs renevent = new RenamedEventArgs(action, directory, name, oldName);
            OnRenamed(renevent);
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.IO.FileSystemWatcher.Changed'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnChanged(FileSystemEventArgs e) {
            if (onChangedHandler != null) {
                if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                    this.SynchronizingObject.BeginInvoke(this.onChangedHandler, new object[]{this, e});
                else                        
                   onChangedHandler(this, e);                
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnCreated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.IO.FileSystemWatcher.Created'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnCreated(FileSystemEventArgs e) {
            if (onCreatedHandler != null) {
                if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                    this.SynchronizingObject.BeginInvoke(this.onCreatedHandler, new object[]{this, e});
                else                        
                   onCreatedHandler(this, e);                
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnDeleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.IO.FileSystemWatcher.Deleted'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnDeleted(FileSystemEventArgs e) {
            if (onDeletedHandler != null) {
                if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                    this.SynchronizingObject.BeginInvoke(this.onDeletedHandler, new object[]{this, e});
                else                        
                   onDeletedHandler(this, e);                
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnError"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.IO.FileSystemWatcher.Error'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnError(ErrorEventArgs e) {
            if (onErrorHandler != null) {
                if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                    this.SynchronizingObject.BeginInvoke(this.onErrorHandler, new object[]{this, e});
                else                        
                   onErrorHandler(this, e);                
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnInternalFileSystemEventArgs"]/*' />
        /// <devdoc>
        ///     Internal method used for synchronous notification.
        /// </devdoc>
        /// <internalonly/>
        private void OnInternalFileSystemEventArgs(object sender, FileSystemEventArgs e) {
            lock (this) {
                // Only change the state of the changed result if it doesn't contain a previous one.
                if (isChanged != true) {
                    changedResult = new WaitForChangedResult(e.ChangeType, e.Name, false);
                    isChanged = true;
                    System.Threading.Monitor.Pulse(this);
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnInternalRenameEventArgs"]/*' />
        /// <devdoc>
        ///     Internal method used for synchronous notification.
        /// </devdoc>
        /// <internalonly/>
        private void OnInternalRenameEventArgs(object sender, RenamedEventArgs e) {
            lock (this) {
                // Only change the state of the changed result if it doesn't contain a previous one.
                if (isChanged != true) {
                    changedResult = new WaitForChangedResult(e.ChangeType, e.Name, e.OldName, false);
                    isChanged = true;
                    System.Threading.Monitor.Pulse(this);
                }
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.OnRenamed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.IO.FileSystemWatcher.Renamed'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnRenamed(RenamedEventArgs e) {
            if (onRenamedHandler != null) {
                if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                    this.SynchronizingObject.BeginInvoke(this.onRenamedHandler, new object[]{this, e});
                else                        
                   onRenamedHandler(this, e);                
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.Restart"]/*' />
        /// <devdoc>
        ///     Stops and starts this object.
        /// </devdoc>
        /// <internalonly/>
        private void Restart() {
            if ((!IsSuspended()) && enabled) {
                StopRaisingEvents();
                StartRaisingEvents();
            }
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.StartRaisingEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts monitoring the specified directory.
        ///    </para>
        /// </devdoc>
        private unsafe void StartRaisingEvents() {
            //Cannot allocate the directoryHandle and the readBuffer if the object has been disposed; finalization has been suppressed.
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
                
            try {
                new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                if (Environment.OSVersion.Platform != PlatformID.Win32NT) {
                    throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequired));
                }
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            // If we're called when "Initializing" is true, set enabled to true
            if (IsSuspended()) {
                enabled = true;
                return;
            }
        
            if (!readGranted) {
                string fullPath;
                new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                try {
                    fullPath = System.IO.Path.GetFullPath(directory);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                FileIOPermission permission = new FileIOPermission(FileIOPermissionAccess.Read, fullPath);
                permission.Demand();                
                readGranted = true;                    
            }
            
            
            // If we're attached, don't do anything.
            if (directoryHandle != (IntPtr)(-1)) {
                return;
            }

            // Create handle to directory being monitored
            directoryHandle = UnsafeNativeMethods.CreateFile(directory,            // Directory name
                                UnsafeNativeMethods.FILE_LIST_DIRECTORY,           // access (read-write) mode
                                UnsafeNativeMethods.FILE_SHARE_READ |
                                    UnsafeNativeMethods.FILE_SHARE_DELETE |
                                    UnsafeNativeMethods.FILE_SHARE_WRITE,          // share mode
                                null,                                              // security descriptor
                                UnsafeNativeMethods.OPEN_EXISTING,                 // how to create
                                UnsafeNativeMethods.FILE_FLAG_BACKUP_SEMANTICS |
                                    UnsafeNativeMethods.FILE_FLAG_OVERLAPPED,      // file attributes
                                NativeMethods.NullHandleRef                        // file with attributes to copy
                            );

            if (directoryHandle == (IntPtr)(-1)) {
                throw new FileNotFoundException(SR.GetString(SR.FSW_IOError, directory));
            }
            
            stopListening = false;

            // Attach handle to thread pool
            
            //SECREVIEW: At this point at least FileIOPermission has already been demanded.
            SecurityPermission secPermission = new SecurityPermission(PermissionState.Unrestricted);
            secPermission.Assert();
            try {
                ThreadPool.BindHandle(directoryHandle);
            }
            finally {
                SecurityPermission.RevertAssert();
            }                                                   
            enabled = true;

            // Setup IO completion port
            Monitor((IntPtr)0);
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.StopRaisingEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Stops monitoring the specified directory.
        ///    </para>
        /// </devdoc>
        private void StopRaisingEvents() {
            if (IsSuspended()) {
                enabled = false;
                return;
            }

            // If we're not attached, do nothing.
            if (directoryHandle == (IntPtr)(-1)) {
                return;
            }

            // Close directory handle 
            // This operation doesn't need to be atomic because the API will deal with a closed
            // handle appropriatelly.
            // Ensure that the directoryHandle is set to INVALID_HANDLE before closing it, so that
            // the Monitor() can shutdown appropriatelly.
            stopListening = true;
            IntPtr h = directoryHandle;
            directoryHandle = (IntPtr)(-1);
            UnsafeNativeMethods.CloseHandle(new HandleRef(this, h));
            
            // Set enabled to false
            enabled = false;
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.WaitForChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A synchronous method that returns a structure that
        ///       contains specific information on the change that occurred, given the type
        ///       of change that you wish to monitor.
        ///    </para>
        /// </devdoc>
        public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType) {
            return WaitForChanged(changeType, -1);
        }

        /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="FileSystemWatcher.WaitForChanged1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A synchronous
        ///       method that returns a structure that contains specific information on the change that occurred, given the
        ///       type of change that you wish to monitor and the time (in milliseconds) to wait before timing out.
        ///    </para>
        /// </devdoc>
        public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout) {
            FileSystemEventHandler dirHandler = new FileSystemEventHandler(this.OnInternalFileSystemEventArgs);
            RenamedEventHandler renameHandler = new RenamedEventHandler(this.OnInternalRenameEventArgs);

            this.isChanged = false;
            this.changedResult = WaitForChangedResult.TimedOutResult;

            // Register the internal event handler from the given change types.
            if ((changeType & WatcherChangeTypes.Created) != 0) {
                this.Created += dirHandler;
            }
            if ((changeType & WatcherChangeTypes.Deleted) != 0) {
                this.Deleted += dirHandler;
            }
            if ((changeType & WatcherChangeTypes.Changed) != 0) {
                this.Changed += dirHandler;
            }
            if ((changeType & WatcherChangeTypes.Renamed) != 0) {
                this.Renamed += renameHandler;
            }

            // Save the Enabled state of this component to revert back to it later (if needed).
            bool savedEnabled = EnableRaisingEvents;
            if (savedEnabled == false) {
                runOnce = true;
                EnableRaisingEvents = true;
            }

            // For each thread entering this wait loop, addref it and wait.  When the last one
            // exits, reset the waiterObject.
            WaitForChangedResult retVal = WaitForChangedResult.TimedOutResult;
            lock (this) {
                if (timeout == -1) {
                    while (!isChanged) {
                        System.Threading.Monitor.Wait(this);
                    }
                }
                else {
                    System.Threading.Monitor.Wait(this, timeout, true);
                }

                retVal = changedResult;
            }

            // Revert the Enabled flag to its previous state.
            EnableRaisingEvents = savedEnabled;
            runOnce = false;

            // Decouple the event handlers added above.
            if ((changeType & WatcherChangeTypes.Created) != 0) {
                this.Created -= dirHandler;
            }
            if ((changeType & WatcherChangeTypes.Deleted) != 0) {
                this.Deleted -= dirHandler;
            }
            if ((changeType & WatcherChangeTypes.Changed) != 0) {
                this.Changed -= dirHandler;
            }
            if ((changeType & WatcherChangeTypes.Renamed) != 0) {
                this.Renamed -= renameHandler;
            }

            // Return the struct.
            return retVal;
        }
    }

    /// <include file='doc\FileSystemWatcher.uex' path='docs/doc[@for="Direct"]/*' />
    /// <devdoc>
    ///    Helper class to hold to N/Direct call declaration and flags.
    /// </devdoc>
    [
        System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]    
    internal class Direct {
        // All possible action flags
        public const int FILE_ACTION_ADDED            = 1;
        public const int FILE_ACTION_REMOVED          = 2;
        public const int FILE_ACTION_MODIFIED         = 3;
        public const int FILE_ACTION_RENAMED_OLD_NAME = 4;
        public const int FILE_ACTION_RENAMED_NEW_NAME = 5;


        // All possible notifications flags
        public const int FILE_NOTIFY_CHANGE_FILE_NAME    = 0x00000001;
        public const int FILE_NOTIFY_CHANGE_DIR_NAME     = 0x00000002;
        public const int FILE_NOTIFY_CHANGE_NAME         = 0x00000003;
        public const int FILE_NOTIFY_CHANGE_ATTRIBUTES   = 0x00000004;
        public const int FILE_NOTIFY_CHANGE_SIZE         = 0x00000008;
        public const int FILE_NOTIFY_CHANGE_LAST_WRITE   = 0x00000010;
        public const int FILE_NOTIFY_CHANGE_LAST_ACCESS  = 0x00000020;
        public const int FILE_NOTIFY_CHANGE_CREATION     = 0x00000040;
        public const int FILE_NOTIFY_CHANGE_SECURITY     = 0x00000100;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\io\system\io\waitforchangedresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="WaitForChangedResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.IO {

    using System.Diagnostics;

    using System;

    /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult"]/*' />
    /// <devdoc>
    ///    <para>Waits for a change in the specified path.</para>
    /// </devdoc>
    public struct WaitForChangedResult {
        private WatcherChangeTypes changeType;
        private string name;
        private string oldName;
        private bool timedOut;

        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.TimedOutResult"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the call has timed out.
        ///    </para>
        /// </devdoc>
        internal static readonly WaitForChangedResult TimedOutResult = new WaitForChangedResult(0, null, true);
        
        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.WaitForChangedResult"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.IO.WaitForChangedResult'/> class, given the
        ///       type of change to watch for, the folder to watch, and whether the call has
        ///       timed out.
        ///    </para>
        /// </devdoc>
        internal WaitForChangedResult(WatcherChangeTypes changeType, string name, bool timedOut)
            : this(changeType, name, null, timedOut){
        }

        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.WaitForChangedResult1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.IO.WaitForChangedResult'/> class. This constructor is called when you are waiting
        ///       for a change in a file or directory name.
        ///    </para>
        /// </devdoc>
        internal WaitForChangedResult(WatcherChangeTypes changeType, string name, string oldName, bool timedOut) {
            this.changeType = changeType;
            this.name = name;
            this.oldName = oldName;
            this.timedOut = timedOut;
        }

        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.ChangeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of change to watch for.
        ///    </para>
        /// </devdoc>
        public WatcherChangeTypes ChangeType {
            get {
                return changeType;
            }
            set {
                changeType = value;
            }
        }

        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the file or subdirectory that has changed.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
            set {
                name = value;
            }
        }

        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.OldName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the original name of the file or subdirectory that has been
        ///       renamed.
        ///    </para>
        /// </devdoc>
        public string OldName {
            get {
                return oldName;
            }
            set {
                oldName = value;
            }
        }

        /// <include file='doc\WaitForChangedResult.uex' path='docs/doc[@for="WaitForChangedResult.TimedOut"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the process has timed out.
        ///    </para>
        /// </devdoc>
        public bool TimedOut {
            get {
                return timedOut;
            }
            set {
                timedOut = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\accesscontrolentrytype.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessControlEntryType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AccessControlEntryType.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Messaging.Interop;

namespace System.Messaging {
    /// <include file='doc\AccessControlEntryType.uex' path='docs/doc[@for="AccessControlEntryType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum AccessControlEntryType {
        /// <include file='doc\AccessControlEntryType.uex' path='docs/doc[@for="AccessControlEntryType.Allow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Allow  = NativeMethods.GRANT_ACCESS,
        /// <include file='doc\AccessControlEntryType.uex' path='docs/doc[@for="AccessControlEntryType.Set"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Set    = NativeMethods.SET_ACCESS,
        /// <include file='doc\AccessControlEntryType.uex' path='docs/doc[@for="AccessControlEntryType.Deny"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Deny   = NativeMethods.DENY_ACCESS,
        /// <include file='doc\AccessControlEntryType.uex' path='docs/doc[@for="AccessControlEntryType.Revoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Revoke = NativeMethods.REVOKE_ACCESS
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\accesscontrollist.cs ===
//------------------------------------------------------------------------------
// <copyright file="AccessControlList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AccessControlList.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Security.Permissions;
using System.Security;    
using System.Collections;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Text;
using System.Messaging.Interop;

namespace System.Messaging {
   
    /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class AccessControlList : CollectionBase {
    
        internal static readonly int UnknownEnvironment = 0;
        internal static readonly int W2kEnvironment = 1;
        internal static readonly int NtEnvironment = 2;
        internal static readonly int NonNtEnvironment = 3;        
        private static int environment = UnknownEnvironment;        
            
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.AccessControlList"]/*' />
        public AccessControlList() {            
        }
        
        internal static int CurrentEnvironment {
            get {
                if (environment == UnknownEnvironment) { 
                    lock (typeof(AccessControlList)) {
                        if (environment == UnknownEnvironment) {
                            //SECREVIEW: jruiz- need to assert Environment permissions here
                            //                        the environment check is not exposed as a public 
                            //                        method                        
                            EnvironmentPermission environmentPermission = new EnvironmentPermission(PermissionState.Unrestricted);                        
                            environmentPermission.Assert();                        
                            try {
                                if (Environment.OSVersion.Platform == PlatformID.Win32NT)  {
                                    if (Environment.OSVersion.Version.Major >= 5)
                                        environment = W2kEnvironment; 
                                    else
                                        environment = NtEnvironment; 
                                }                                
                                else                    
                                    environment = NonNtEnvironment;
                            }
                            finally {  
                                 EnvironmentPermission.RevertAssert();                             
                            }                                                    
                        }                
                    }
                }
            
                return environment;                        
            }                
        }               
    
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(AccessControlEntry entry) {
            return List.Add(entry);
        }
   
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, AccessControlEntry entry) {
            List.Insert(index, entry);
        }
    
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(AccessControlEntry entry) {
            return List.IndexOf(entry);
        }
    
        internal static void CheckEnvironment() {            
            if (CurrentEnvironment == NonNtEnvironment)
                throw new PlatformNotSupportedException(Res.GetString(Res.WinNTRequired));
        }
                                    
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(AccessControlEntry entry) {
            return List.Contains(entry);
        }
                                        
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(AccessControlEntry entry) {
            List.Remove(entry);
        }
    
        /// <include file='doc\AccessControlList.uex' path='docs/doc[@for="AccessControlList.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(AccessControlEntry[] array, int index) {
            List.CopyTo(array, index);
        }

        internal IntPtr MakeAcl(IntPtr oldAcl) {
            CheckEnvironment();
            
            int ACECount = List.Count;
            IntPtr newAcl;
    
            NativeMethods.ExplicitAccess[] entries = new NativeMethods.ExplicitAccess[ACECount];
            
            GCHandle mem = GCHandle.Alloc(entries, GCHandleType.Pinned);
            try {
                for (int i = 0; i < ACECount; i++) {
                    int sidSize = 0;
                    int sidtype;
                    int domainSize = 0;
                    
                    AccessControlEntry ace = (AccessControlEntry)List[i];
            
                    if (ace.Trustee == null)
                        throw new InvalidOperationException(Res.GetString(Res.InvalidTrustee));
                    
                    string name = ace.Trustee.Name;
                    if (name == null) 
                        throw new InvalidOperationException(Res.GetString(Res.InvalidTrusteeName));
                    
                    if ((ace.Trustee.TrusteeType == TrusteeType.Computer) && !name.EndsWith("$"))
                        name += "$";

                    if (!UnsafeNativeMethods.LookupAccountName(ace.Trustee.SystemName, name, (IntPtr)0, ref sidSize, null, ref domainSize, out sidtype)) {
                        int errval = Marshal.GetLastWin32Error();
                        if (errval != 122)
                            throw new InvalidOperationException(Res.GetString(Res.CouldntResolve ,ace.Trustee.Name, errval));
                    }
        
                    entries[i].data = (IntPtr)Marshal.AllocHGlobal(sidSize);
        
                    StringBuilder domainName = new StringBuilder(domainSize);                
                    if (!UnsafeNativeMethods.LookupAccountName(ace.Trustee.SystemName, name, entries[i].data, ref sidSize, domainName, ref domainSize, out sidtype))
                        throw new InvalidOperationException(Res.GetString(Res.CouldntResolveName, ace.Trustee.Name));
    
                    entries[i].grfAccessPermissions     = ace.accessFlags;
                    entries[i].grfAccessMode            = (int)ace.EntryType;
                    entries[i].grfInheritance           = 0;
                    entries[i].pMultipleTrustees        = (IntPtr)0;
                    entries[i].MultipleTrusteeOperation = NativeMethods.NO_MULTIPLE_TRUSTEE;
                    entries[i].TrusteeForm              = NativeMethods.TRUSTEE_IS_SID;
                    entries[i].TrusteeType              = (int)ace.Trustee.TrusteeType;
                }
    
                int err = SafeNativeMethods.SetEntriesInAclW(ACECount, (IntPtr)mem.AddrOfPinnedObject(), oldAcl, out newAcl);
    
                if (err != NativeMethods.ERROR_SUCCESS)
                    throw new Win32Exception(err);
            } 
            finally {
                mem.Free();
            
                for (int i = 0; i < ACECount; i++)
                    if (entries[i].data != (IntPtr)0)
                        Marshal.FreeHGlobal(entries[i].data);
                    
            }
    
    
            return newAcl;
        }
    
        internal static void FreeAcl(IntPtr acl) {
            SafeNativeMethods.LocalFree(acl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\acknowledgement.cs ===
//------------------------------------------------------------------------------
// <copyright file="Acknowledgement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Threading;

    using System.Diagnostics;

    using System;    
    using System.Messaging.Interop;

    /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies what went wrong (or right) during a Message
    ///       Queuing operation. This is the type of a property of an acknowledgement
    ///       message.
    ///    </para>
    /// </devdoc>
    public enum Acknowledgment {
         /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.None"]/*' />
         /// <devdoc>
         ///    <para>
         ///       The default value of the <see cref='System.Messaging.Acknowledgment'/>
         ///       property. This means the message is
         ///       not an acknowledgment message.
         ///    </para>
         /// </devdoc>
         None = 0,
         
         /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.AccessDenied"]/*' />
         /// <devdoc>
         ///     The sending application does not have access rights
         ///     to the destination queue.
         /// </devdoc>
        AccessDenied = NativeMethods.MESSAGE_CLASS_ACCESS_DENIED,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.BadDestinationQueue"]/*' />
        /// <devdoc>
        ///     The destination queue is not available to the sending
        ///     application.
        /// </devdoc>
        BadDestinationQueue = NativeMethods.MESSAGE_CLASS_BAD_DESTINATION_QUEUE,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.BadEncryption"]/*' />
        /// <devdoc>
        ///     The destination Queue Manager could not decrypt a private
        ///     (encrypted) message.
        /// </devdoc>
        BadEncryption = NativeMethods.MESSAGE_CLASS_BAD_ENCRYPTION,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.BadSignature"]/*' />
        /// <devdoc>
        ///     MSMQ could not authenticate the original message. The original
        ///     message's digital signature is not valid.
        /// </devdoc>
        BadSignature = NativeMethods.MESSAGE_CLASS_BAD_SIGNATURE,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.CouldNotEncrypt"]/*' />
        /// <devdoc>
        ///     The source Queue Manager could not encrypt a private message.
        /// </devdoc>
        CouldNotEncrypt = NativeMethods.MESSAGE_CLASS_COULD_NOT_ENCRYPT,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.HopCountExceeded"]/*' />
        /// <devdoc>
        ///     The original message's hop count is exceeded.
        /// </devdoc>
        HopCountExceeded = NativeMethods.MESSAGE_CLASS_HOP_COUNT_EXCEEDED,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.NotTransactionalQueue"]/*' />
        /// <devdoc>
        ///     A transaction message was sent to a non-transaction
        ///     queue.
        /// </devdoc>
        NotTransactionalQueue = NativeMethods.MESSAGE_CLASS_NOT_TRANSACTIONAL_QUEUE,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.NotTransactionalMessage"]/*' />
        /// <devdoc>
        ///     A non-transaction message was sent to a transaction
        ///     queue.
        /// </devdoc>
        NotTransactionalMessage = NativeMethods.MESSAGE_CLASS_NOT_TRANSACTIONAL_MESSAGE,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.Purged"]/*' />
        /// <devdoc>
        ///     The message was purged before reaching the destination
        ///     queue.
        /// </devdoc>
        Purged = NativeMethods.MESSAGE_CLASS_PURGED,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.QueueDeleted"]/*' />
        /// <devdoc>
        ///     The queue was deleted before the message could be read
        ///     from the queue.
        /// </devdoc>
        QueueDeleted = NativeMethods.MESSAGE_CLASS_QUEUE_DELETED,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.QueueExceedMaximumSize"]/*' />
        /// <devdoc>
        ///     The original message's destination queue is full.
        /// </devdoc>
        QueueExceedMaximumSize = NativeMethods.MESSAGE_CLASS_QUEUE_EXCEED_QUOTA,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.QueuePurged"]/*' />
        /// <devdoc>
        ///     The queue was purged and the message no longer exists.
        /// </devdoc>
        QueuePurged = NativeMethods.MESSAGE_CLASS_QUEUE_PURGED,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.ReachQueue"]/*' />
        /// <devdoc>
        ///     The original message reached its destination queue.
        /// </devdoc>
        ReachQueue = NativeMethods.MESSAGE_CLASS_REACH_QUEUE,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.ReachQueueTimeout"]/*' />
        /// <devdoc>
        ///     Either the time-to-reach-queue or time-to-be-received timer
        ///     expired before the original message could reach the destination queue.
        /// </devdoc>
        ReachQueueTimeout = NativeMethods.MESSAGE_CLASS_REACH_QUEUE_TIMEOUT,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.ReceiveTimeout"]/*' />
        /// <devdoc>
        ///     The original message was not removed from the queue before
        ///     its time-to-be-received timer expired.
        /// </devdoc>
        ReceiveTimeout = NativeMethods.MESSAGE_CLASS_RECEIVE_TIMEOUT,

        /// <include file='doc\Acknowledgement.uex' path='docs/doc[@for="Acknowledgment.Receive"]/*' />
        /// <devdoc>
        ///     The original message was retrieved by the receiving
        ///     application.
        /// </devdoc>
        Receive = NativeMethods.MESSAGE_CLASS_RECEIVE,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\activexmessageformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ActiveXMessageFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.IO;    
    using System.Globalization;
    using System.ComponentModel;
    using System.Messaging.Interop;
        
    /// <include file='doc\ActiveXMessageFormatter.uex' path='docs/doc[@for="ActiveXMessageFormatter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Formatter class that serializes and deserializes
    ///       primitives, classes, enumeration, and other objects into and from <see cref='System.Messaging.MessageQueue'/>
    ///       messages using binary format.
    ///    </para>
    /// </devdoc>
    public class ActiveXMessageFormatter : IMessageFormatter {
        internal const short VT_ARRAY = 0x2000;
        internal const short VT_BOOL = 11;
        internal const short VT_BSTR = 8;
        internal const short VT_CLSID = 72;
        internal const short VT_CY = 6;
        internal const short VT_DATE = 7;
        internal const short VT_I1 = 16;
        internal const short VT_I2 = 2;
        internal const short VT_I4 = 3;
        internal const short VT_I8 = 20;
        internal const short VT_LPSTR = 30;
        internal const short VT_LPWSTR = 31;
        internal const short VT_NULL = 1;
        internal const short VT_R4 = 4;
        internal const short VT_R8 = 5;
        internal const short VT_STREAMED_OBJECT = 68;
        internal const short VT_STORED_OBJECT = 69;
        internal const short VT_UI1 = 17;
        internal const short VT_UI2 = 18;
        internal const short VT_UI4 = 19;
        internal const short VT_UI8 = 21;
        internal const short VT_VECTOR = 0x1000;
        private byte[] internalBuffer;
        private UnicodeEncoding unicodeEncoding;      
        private ASCIIEncoding asciiEncoding;
        private char[] internalCharBuffer;          
            
        /// <include file='doc\ActiveXMessageFormatter.uex' path='docs/doc[@for="ActiveXMessageFormatter.CanRead"]/*' />
        /// <devdoc>
        ///    When this method is called, the formatter will attempt to determine 
        ///    if the contents of the message are something the formatter can deal with.
        /// </devdoc>
        public bool CanRead(Message message) {
            if (message == null)
                throw new ArgumentNullException("message");
                
            int variantType = message.BodyType;                
            if (variantType != VT_BOOL && variantType != VT_CLSID &&
                variantType != VT_CY && variantType != VT_DATE &&
                variantType != VT_I1 && variantType != VT_UI1 &&
                variantType != VT_I2 && variantType != VT_UI2 &&
                variantType != VT_I4 && variantType != VT_UI4 &&
                variantType != VT_I8 && variantType != VT_UI8 &&
                variantType != VT_NULL && variantType != VT_R4 &&
                variantType != VT_I8 && variantType != VT_STREAMED_OBJECT &&
                variantType != VT_STORED_OBJECT && 
                variantType != (VT_VECTOR | VT_UI1) &&
                variantType != VT_LPSTR && variantType != VT_LPWSTR &&
                variantType != VT_BSTR && variantType != VT_R8)    
                return false;                
            
            return true;            
        }
        
        /// <include file='doc\ActiveXMessageFormatter.uex' path='docs/doc[@for="ActiveXMessageFormatter.Clone"]/*' />
        /// <devdoc>
        ///    This method is needed to improve scalability on Receive and ReceiveAsync scenarios.  Not requiring 
        ///     thread safety on read and write.
        /// </devdoc>
        public object Clone() {
            return new ActiveXMessageFormatter();
        }
        
        /// <include file='doc\ActiveXMessageFormatter.uex' path='docs/doc[@for="ActiveXMessageFormatter.InitStreamedObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void InitStreamedObject(object streamedObject) {
            IPersistStreamInit persistStreamInit = streamedObject as IPersistStreamInit;
            if (persistStreamInit != null)
                persistStreamInit.InitNew();
        }
        
        /// <include file='doc\ActiveXMessageFormatter.uex' path='docs/doc[@for="ActiveXMessageFormatter.Read"]/*' />
        /// <devdoc>
        ///    This method is used to read the contents from the given message 
        ///     and create an object.
        /// </devdoc>
        public object Read(Message message) {             
            if (message == null)
                throw new ArgumentNullException("message");
                
            Stream stream;
            byte[] bytes;
            byte[] newBytes;
            int size;
            int variantType = message.BodyType;      
            switch (variantType) {
                case VT_LPSTR:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);
                    size = message.properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE);
            
                    if (this.internalCharBuffer == null || this.internalCharBuffer.Length < size)
                        this.internalCharBuffer = new char[size];
                        
                    if (asciiEncoding == null)
                        this.asciiEncoding = new ASCIIEncoding();                
                                                                
                    this.asciiEncoding.GetChars(bytes, 0, size, this.internalCharBuffer, 0);                             
                    return new String(this.internalCharBuffer, 0, size);                                                                    
                case VT_BSTR:                    
                case VT_LPWSTR:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);
                    size = message.properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE) / 2;
            
                    if (this.internalCharBuffer == null || this.internalCharBuffer.Length < size)
                        this.internalCharBuffer = new char[size];
                    
                    if (unicodeEncoding == null)
                        this.unicodeEncoding = new UnicodeEncoding();                
                    
                    this.unicodeEncoding.GetChars(bytes, 0, size * 2, this.internalCharBuffer, 0);                             
                    return new String(this.internalCharBuffer, 0, size);                                    
                case VT_VECTOR | VT_UI1:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);
                    size = message.properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE);
                    newBytes = new byte[size];
                    Array.Copy(bytes, newBytes, size);
                                                                
                    return newBytes;                  
                case VT_BOOL:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);       
                    newBytes = new byte[1];                    
                    Array.Copy(bytes, newBytes, 1);                                                                                             
                    if (bytes[0] != 0)
                        return true;
                        
                    return false;
                case VT_CLSID:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);       
                    newBytes = new byte[16];
                    Array.Copy(bytes, newBytes, 16);                                                     
                    return new Guid(newBytes);
                case VT_CY:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);       
                    newBytes = new byte[8];
                    Array.Copy(bytes, newBytes, 8);                                                     
                    return Decimal.FromOACurrency(BitConverter.ToInt64(newBytes, 0));
                case VT_DATE:
                    bytes = message.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY);       
                    newBytes = new byte[8];
                    Array.Copy(bytes, newBytes, 8);                                                     
                    return new DateTime(BitConverter.ToInt64(newBytes, 0));
                case VT_I1:                    
                case VT_UI1:
                    stream = message.BodyStream;                
                    bytes = new byte[1];
                    stream.Read(bytes, 0, 1);
                    return bytes[0];
                case VT_I2:               
                    stream = message.BodyStream;                
                    bytes = new byte[2];
                    stream.Read(bytes, 0, 2);                    
                    return BitConverter.ToInt16(bytes, 0);
                case VT_UI2:
                    stream = message.BodyStream;                
                    bytes = new byte[2];
                    stream.Read(bytes, 0, 2);                    
                    return BitConverter.ToUInt16(bytes, 0);
                case VT_I4:
                    stream = message.BodyStream;                
                    bytes = new byte[4];
                    stream.Read(bytes, 0, 4);                    
                    return BitConverter.ToInt32(bytes, 0);
                case VT_UI4:
                    stream = message.BodyStream;                
                    bytes = new byte[4];
                    stream.Read(bytes, 0, 4);                    
                    return BitConverter.ToUInt32(bytes, 0);
                case VT_I8:
                    stream = message.BodyStream;                
                    bytes = new byte[8];
                    stream.Read(bytes, 0, 8);                    
                    return BitConverter.ToInt64(bytes, 0);
                case VT_UI8:
                    stream = message.BodyStream;                
                    bytes = new byte[8];
                    stream.Read(bytes, 0, 8);                    
                    return BitConverter.ToUInt64(bytes, 0);
                case VT_R4:
                    stream = message.BodyStream;                
                    bytes = new byte[4];
                    stream.Read(bytes, 0, 4);                    
                    return BitConverter.ToSingle(bytes, 0);
                case VT_R8:
                    stream = message.BodyStream;                
                    bytes = new byte[8];
                    stream.Read(bytes, 0, 8);                    
                    return BitConverter.ToDouble(bytes, 0);           
                case VT_NULL:
                    return null;                    
                case VT_STREAMED_OBJECT:
                    stream = message.BodyStream;                
                    ComStreamFromDataStream comStream = new ComStreamFromDataStream(stream);        
                    return NativeMethods.OleLoadFromStream(comStream, ref NativeMethods.IID_IUnknown);                                                            
                case VT_STORED_OBJECT:                    
                    throw new NotSupportedException(Res.GetString(Res.StoredObjectsNotSupported));                                                    
                default:
                    throw new InvalidOperationException(Res.GetString(Res.InvalidTypeDeserialization));
            }                            
        }
        
        /// <include file='doc\ActiveXMessageFormatter.uex' path='docs/doc[@for="ActiveXMessageFormatter.Write"]/*' />
        /// <devdoc>
        ///    This method is used to write the given object into the given message.  
        ///     If the formatter cannot understand the given object, an exception is thrown.
        /// </devdoc>
        public void Write(Message message, object obj) {
            if (message == null)
                throw new ArgumentNullException("message");
                
            Stream stream;
            int variantType;                        
            if (obj is string) {        
                int size = ((string)obj).Length * 2;
                if (this.internalBuffer == null || this.internalBuffer.Length < size)
                    this.internalBuffer = new byte[size];
                    
                if (unicodeEncoding == null)
                    this.unicodeEncoding = new UnicodeEncoding();
                                                                        
                this.unicodeEncoding.GetBytes(((string)obj).ToCharArray(), 0, size /2, this.internalBuffer, 0);
                message.properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY, this.internalBuffer);
                message.properties.AdjustSize(NativeMethods.MESSAGE_PROPID_BODY, size);
                message.properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE, size);
                message.properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_TYPE, VT_LPWSTR);                
                return;
            }
            else if (obj is byte[]) {
                byte[] bytes = (byte[])obj;
                if (this.internalBuffer == null || this.internalBuffer.Length < bytes.Length)
                    this.internalBuffer = new byte[bytes.Length];
            
                Array.Copy(bytes, this.internalBuffer, bytes.Length);
                message.properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY, this.internalBuffer);
                message.properties.AdjustSize(NativeMethods.MESSAGE_PROPID_BODY, bytes.Length);
                message.properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE, bytes.Length);
                message.properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_TYPE, VT_UI1 | VT_VECTOR);                
                return;         
            }
            else if (obj is char[]) {
                char[] chars = (char[])obj;
                int size = chars.Length * 2;
                if (this.internalBuffer == null || this.internalBuffer.Length < size)
                    this.internalBuffer = new byte[size];
                    
                if (unicodeEncoding == null)
                    this.unicodeEncoding = new UnicodeEncoding();
                                                                        
                this.unicodeEncoding.GetBytes(chars, 0, size /2, this.internalBuffer, 0);
                message.properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY, this.internalBuffer);
                message.properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE, size);
                message.properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_TYPE, VT_LPWSTR);                
                return;                            
            }
            else if (obj is byte) {
                stream = new MemoryStream(1);    
                stream.Write(new byte[]{(byte)obj}, 0, 1);                
                variantType = VT_UI1;
            }            
            else if (obj is bool) {
                stream = new MemoryStream(1);    
                if ((bool)obj)                
                    stream.Write(new byte[]{0xff}, 0, 1);
                else                    
                    stream.Write(new byte[]{0x00}, 0, 1);
                variantType = VT_BOOL;
            }
            else if (obj is char) {
                stream = new MemoryStream(2);                    
                byte[] bytes = BitConverter.GetBytes((Char)obj);
                stream.Write(bytes, 0, 2);                      
                variantType = VT_UI2;
            }            
            else if (obj is Decimal) {                
                stream = new MemoryStream(8);    
                byte[] bytes = BitConverter.GetBytes(Decimal.ToOACurrency((Decimal)obj));
                stream.Write(bytes, 0, 8);                
                variantType = VT_CY;
            }
            else if (obj is DateTime) {
                stream = new MemoryStream(8);    
                byte[] bytes = BitConverter.GetBytes(((DateTime)obj).Ticks);
                stream.Write(bytes, 0, 8);                
                variantType = VT_DATE;
            }
            else if (obj is Double) {
                stream = new MemoryStream(8);                    
                byte[] bytes = BitConverter.GetBytes((Double)obj);
                stream.Write(bytes, 0, 8);                
                variantType = VT_R8;
            }
            else if (obj is Int16) {
                stream = new MemoryStream(2);                    
                byte[] bytes = BitConverter.GetBytes((short)obj);
                stream.Write(bytes, 0, 2);                      
                variantType = VT_I2;
            }
            else if (obj is UInt16) {
                stream = new MemoryStream(2);                    
                byte[] bytes = BitConverter.GetBytes((UInt16)obj);
                stream.Write(bytes, 0, 2);                      
                variantType = VT_UI2;
            }
            else if (obj is Int32) {
                stream = new MemoryStream(4);                    
                byte[] bytes = BitConverter.GetBytes((int)obj);
                stream.Write(bytes, 0, 4);                      
                variantType = VT_I4;
            }
            else if (obj is UInt32) {
                stream = new MemoryStream(4);                    
                byte[] bytes = BitConverter.GetBytes((UInt32)obj);
                stream.Write(bytes, 0, 4);               
                variantType = VT_UI4;
            }
            else if (obj is Int64) {
                stream = new MemoryStream(8);                    
                byte[] bytes = BitConverter.GetBytes((Int64)obj);
                stream.Write(bytes, 0, 8);               
                variantType = VT_I8;
            }
            else if (obj is UInt64) {
                stream = new MemoryStream(8);                    
                byte[] bytes = BitConverter.GetBytes((UInt64)obj);
                stream.Write(bytes, 0, 8);               
                variantType = VT_UI8;
            }
            else if (obj is Single) {
                stream = new MemoryStream(4);                    
                byte[] bytes = BitConverter.GetBytes((float)obj);
                stream.Write(bytes, 0, 4);               
                variantType = VT_R4;
            }                        
            else if (obj is IPersistStream) {                
                IPersistStream pstream = (IPersistStream) obj;                 
                ComStreamFromDataStream comStream = new ComStreamFromDataStream(new MemoryStream());                
                NativeMethods.OleSaveToStream(pstream, comStream);
                stream = comStream.GetDataStream();
                variantType = VT_STREAMED_OBJECT;
            }
            else if (obj == null) {                
                stream = new MemoryStream();    
                variantType = VT_NULL;			
            }                                    
            else {                     
                throw new InvalidOperationException(Res.GetString(Res.InvalidTypeSerialization));
            }
            
            message.BodyStream = stream;
            message.BodyType = variantType;        
        }      
        
        [ComVisible(false)]
        private class ComStreamFromDataStream : IStream {
            protected Stream dataStream;

            // to support seeking ahead of the stream length...
            private long virtualPosition = -1;

            public ComStreamFromDataStream(Stream dataStream) {
                if (dataStream == null) throw new ArgumentNullException("dataStream");
                this.dataStream = dataStream;
            }

            // Don't forget to set dataStream before using this object
            protected ComStreamFromDataStream() {
            }

            private void ActualizeVirtualPosition() {
                if (virtualPosition == -1) return;
            
                if (virtualPosition > dataStream.Length)
                    dataStream.SetLength(virtualPosition);
            
                dataStream.Position = virtualPosition;
            
                virtualPosition = -1;
            }

            public IStream Clone() {
                NotImplemented();
                return null;
            }

            public void Commit(int grfCommitFlags) {
                dataStream.Flush();
                // Extend the length of the file if needed.
                ActualizeVirtualPosition();
            }

            public long CopyTo(IStream pstm, long cb, long[] pcbRead) {                
                int bufSize = 4096;
                IntPtr buffer = Marshal.AllocHGlobal((IntPtr)bufSize);
                if (buffer == IntPtr.Zero) throw new OutOfMemoryException();
                long written = 0;
                try {
                    while (written < cb) {
                        int toRead = bufSize;
                        if (written + toRead > cb) toRead  = (int) (cb - written);
                        int read = Read(buffer, toRead);
                        if (read == 0) break;
                        if (pstm.Write(buffer, read) != read) {
                            throw EFail(Res.GetString(Res.IncorrectNumberOfBytes));
                        }
                        written += read;
                    }
                }
                finally {
                    Marshal.FreeHGlobal(buffer);
                }
                if (pcbRead != null && pcbRead.Length > 0) {
                    pcbRead[0] = written;
                }

                return written;
            }

            public Stream GetDataStream() {
                return dataStream;
            }

            public void LockRegion(long libOffset, long cb, int dwLockType) {
            }

            protected static ExternalException EFail(string msg) {
                ExternalException e = new ExternalException(msg, NativeMethods.E_FAIL);
                throw e;
            }
        
            protected static void NotImplemented() {
                ExternalException e = new ExternalException(Res.GetString(Res.NotImplemented), NativeMethods.E_NOTIMPL);
                throw e;
            }

            public int Read(IntPtr buf, int length) {                
                byte[] buffer = new byte[length];
                int count = Read(buffer, length);
                Marshal.Copy(buffer, 0, buf, length);
                return count;
            }

            public int Read(byte[] buffer, int length) {
                ActualizeVirtualPosition();
                return dataStream.Read(buffer, 0, length);
            }

            public void Revert() {
                NotImplemented();
            }

            public long Seek(long offset, int origin) {                
                long pos = virtualPosition;
                if (virtualPosition == -1) {
                    pos = dataStream.Position;
                }
                long len = dataStream.Length;
                switch (origin) {
                    case NativeMethods.STREAM_SEEK_SET:
                        if (offset <= len) {
                            dataStream.Position = offset;
                            virtualPosition = -1;
                        }
                        else {
                            virtualPosition = offset;
                        }
                        break;
                    case NativeMethods.STREAM_SEEK_END:
                        if (offset <= 0) {
                            dataStream.Position = len + offset;
                            virtualPosition = -1;
                        }
                        else {
                            virtualPosition = len + offset;
                        }
                        break;
                    case NativeMethods.STREAM_SEEK_CUR:
                        if (offset+pos <= len) {
                            dataStream.Position = pos + offset;
                            virtualPosition = -1;
                        }
                        else {
                            virtualPosition = offset + pos;
                        }
                        break;
                }
                if (virtualPosition != -1) {
                    return virtualPosition;
                }
                else {
                    return dataStream.Position;
                }
            }

            public void SetSize(long value) {
                dataStream.SetLength(value);
            }

            public void Stat(IntPtr pstatstg, int grfStatFlag) {
                // GpStream has a partial implementation, but it's so partial rather 
                // restrict it to use with GDI+
                NotImplemented();
            }

            public void UnlockRegion(long libOffset, long cb, int dwLockType) {
            }

            public int Write(IntPtr buf, int length) {
                byte[] buffer = new byte[length];
                Marshal.Copy(buf, buffer, 0, length);
                return Write(buffer, length);
            }

            public int Write(byte[] buffer, int length) {
                ActualizeVirtualPosition();
                dataStream.Write(buffer, 0, length);
                return length;
            }
        }                       
    }            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\acknowledgetypes.cs ===
//------------------------------------------------------------------------------
// <copyright file="AcknowledgeTypes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;    
    using System.Messaging.Interop;

    /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies what kind of acknowledgment to get after sending a message.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum AcknowledgeTypes {
    
         /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.PositiveArrival"]/*' />
         /// <devdoc>
        ///    <para>
        ///       Use this value to request a positive acknowledgment when the message
        ///       reaches the queue. 
        ///    </para>
        /// </devdoc>
        PositiveArrival = NativeMethods.ACKNOWLEDGE_POSITIVE_ARRIVAL,
        
        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.PositiveReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value to request a positive acknowledgment when the message 
        ///       is successfully retrieved from the queue.
        ///    </para>
        /// </devdoc>
        PositiveReceive = NativeMethods.ACKNOWLEDGE_POSITIVE_RECEIVE,
                
        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.NegativeReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value to request a negative acknowledgment when the message fails
        ///       to be retrieved from the queue. 
        ///    </para>
        /// </devdoc>                    
        NegativeReceive = NativeMethods.ACKNOWLEDGE_NEGATIVE_RECEIVE,        
        
        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value to request no acknowledgment messages (positive or negative) to be posted.
        ///    </para>
        /// </devdoc>
        None = NativeMethods.ACKNOWLEDGE_NONE,

        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.NotAcknowledgeReachQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value to request a negative acknowledgment when the message cannot
        ///       reach the queue. This can happen when the time-to-reach-queue
        ///       timer expires, or a message cannot be authenticated.
        ///    </para>
        /// </devdoc>
        NotAcknowledgeReachQueue = NativeMethods.ACKNOWLEDGE_NEGATIVE_ARRIVAL,

        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.NotAcknowledgeReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value to request a negative acknowledgment when an error occurs and
        ///       the message cannot be retrieved from the queue before its
        ///       time-to-be-received timer expires.
        ///    </para>
        /// </devdoc>
        NotAcknowledgeReceive =  NegativeReceive | 
                                                       NativeMethods.ACKNOWLEDGE_NEGATIVE_ARRIVAL,               
                                                      
        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.FullReachQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value
        ///       to request full acknowledgment (positive or negative) depending
        ///       on whether or not the message reaches the queue.
        ///       This can happen when the time-to-reach-queue timer expires,
        ///       or a message cannot be authenticated.
        ///    </para>
        /// </devdoc>
        FullReachQueue = NotAcknowledgeReachQueue |
                                        PositiveArrival,

        /// <include file='doc\AcknowledgeTypes.uex' path='docs/doc[@for="AcknowledgeTypes.FullReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Use this value to request full acknowledgment (positive or negative) depending
        ///       on whether or not the message is retrieved from the queue
        ///       before its time-to-be-received timer expires.
        ///    </para>
        /// </devdoc>
        FullReceive = NotAcknowledgeReceive | 
                                PositiveReceive,
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\cryptographicprovidertype.cs ===
//------------------------------------------------------------------------------
// <copyright file="CryptographicProviderType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;
    using System.Messaging.Interop;

    /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType"]/*' />
    /// <devdoc>
    ///    Typically used when working with foreign queues. The type and name of the cryptographic 
    ///    provider is required to validate the digital signature of a message sent to a foreign queue 
    ///    or messages passed to MSMQ from a foreign queue.
    /// </devdoc>
    public enum CryptographicProviderType {
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.RsaFull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RsaFull = NativeMethods.PROV_RSA_FULL,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.RsqSig"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RsqSig = NativeMethods.PROV_RSA_SIG,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.Dss"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Dss = NativeMethods.PROV_DSS,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.Fortezza"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Fortezza = NativeMethods.PROV_FORTEZZA,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.MicrosoftExchange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MicrosoftExchange = NativeMethods.PROV_MS_EXCHANGE,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.Ssl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ssl = NativeMethods.PROV_SSL,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.SttMer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SttMer = NativeMethods.PROV_STT_MER,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.SttAcq"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SttAcq = NativeMethods.PROV_STT_ACQ,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.SttBrnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SttBrnd = NativeMethods.PROV_STT_BRND,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.SttRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SttRoot = NativeMethods.PROV_STT_ROOT,
        /// <include file='doc\CryptographicProviderType.uex' path='docs/doc[@for="CryptographicProviderType.SttIss"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SttIss = NativeMethods.PROV_STT_ISS,      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\encryptionalgorithm.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncryptionAlgorithm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;    
    using System.Messaging.Interop;

    /// <include file='doc\EncryptionAlgorithm.uex' path='docs/doc[@for="EncryptionAlgorithm"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the encryption algorithm used to encrypt the message body of a
    ///       private message.
    ///       
    ///    </para>
    /// </devdoc>
    public enum EncryptionAlgorithm {

        /// <include file='doc\EncryptionAlgorithm.uex' path='docs/doc[@for="EncryptionAlgorithm.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No encryption.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\EncryptionAlgorithm.uex' path='docs/doc[@for="EncryptionAlgorithm.Rc2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The value MQMSG_CALG_RC2. This is the default value for
        ///       the <see langword='EncryptAlgorithm'/> property of the Message Queuing
        ///       application's <see langword='MSMQMessage '/>
        ///       
        ///       
        ///       object.
        ///       
        ///    </para>
        /// </devdoc>
        Rc2 = NativeMethods.CALG_RC2,

        /// <include file='doc\EncryptionAlgorithm.uex' path='docs/doc[@for="EncryptionAlgorithm.Rc4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The value MQMSG_CALG_RC4. This corresponds to the less
        ///       secure option for the <see langword='EncryptAlgorithm '/>property of the
        ///       Message Queuing application's <see langword='MSMQMessage '/>
        ///       
        ///       object.
        ///       
        ///    </para>
        /// </devdoc>
        Rc4 = NativeMethods.CALG_RC4,
    }                
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\encryptionrequired.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncryptionRequired.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System.Messaging.Interop;
    
    /// <include file='doc\EncryptionRequired.uex' path='docs/doc[@for="EncryptionRequired"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the privacy level of messages received by the queue.
    ///       
    ///    </para>
    /// </devdoc>
    public enum EncryptionRequired {
        /// <include file='doc\EncryptionRequired.uex' path='docs/doc[@for="EncryptionRequired.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Accepts
        ///       only
        ///       non-private (non-encrypted) messages.
        ///       
        ///    </para>
        /// </devdoc>
        None = NativeMethods.QUEUE_PRIVACY_LEVEL_NONE,

        /// <include file='doc\EncryptionRequired.uex' path='docs/doc[@for="EncryptionRequired.Optional"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Does not force privacy. Accepts private (encrypted) messages and non-private (non-encrypted) messages.
        ///       
        ///    </para>
        /// </devdoc>
        Optional = NativeMethods.QUEUE_PRIVACY_LEVEL_OPTIONAL,

        /// <include file='doc\EncryptionRequired.uex' path='docs/doc[@for="EncryptionRequired.Body"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Accepts only private (encrypted) messages.
        ///    </para>
        /// </devdoc>
        Body = NativeMethods.QUEUE_PRIVACY_LEVEL_BODY 
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\binarymessageformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="BinaryMessageFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Diagnostics;
    using System.IO;
    using System.ComponentModel;
    
    /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter"]/*' />
    /// <devdoc>
    ///    Formatter class that serializes and deserializes objects into
    ///    and from  MessageQueue messages using binary format.
    /// </devdoc>             
    public class BinaryMessageFormatter : IMessageFormatter {
        private BinaryFormatter formatter;
        internal const short VT_BINARY_OBJECT = 0x300;
        
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.BinaryMessageFormatter"]/*' />
        /// <devdoc>
        ///    Creates a new Binary message formatter object.
        /// </devdoc>
        public BinaryMessageFormatter() {
            this.formatter = new BinaryFormatter();
        }
    
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.BinaryMessageFormatter1"]/*' />
        /// <devdoc>
        ///    Creates a new Binary message formatter object 
        ///    with the given properties.
        /// </devdoc>
        public BinaryMessageFormatter(FormatterAssemblyStyle topObjectFormat, FormatterTypeStyle typeFormat) {
            this.formatter = new BinaryFormatter();
            this.formatter.AssemblyFormat = topObjectFormat;
            this.formatter.TypeFormat = typeFormat;            
        }
    
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.TopObjectFormat"]/*' />
        /// <devdoc>
        ///    Determines how the top (root) object of a graph
        ///    is laid out in the serialized stream.
        /// </devdoc>
        [MessagingDescription(Res.MsgTopObjectFormat), DefaultValueAttribute(FormatterAssemblyStyle.Simple)]
        public FormatterAssemblyStyle TopObjectFormat {
            get {
                return this.formatter.AssemblyFormat;
            }
            
            set {
                this.formatter.AssemblyFormat = value;
            }
        }
        
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.TypeFormat"]/*' />
        /// <devdoc>
        ///    Determines how type descriptions are laid out in the
        ///    serialized stream.
        /// </devdoc>
        [MessagingDescription(Res.MsgTypeFormat), DefaultValueAttribute(FormatterTypeStyle.TypesWhenNeeded)]
        public FormatterTypeStyle TypeFormat {
            get {
                return this.formatter.TypeFormat;
            }
            
            set {
                this.formatter.TypeFormat = value;
            }
        }
        
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.CanRead"]/*' />
        /// <devdoc>
        ///    <para>When this method is called, the formatter will attempt to determine
        ///       if the contents of the message are something the formatter can deal with.</para>
        /// </devdoc>
        public bool CanRead(Message message) {
            if (message == null)
                throw new ArgumentNullException("message");
                
            int variantType = message.BodyType;
            if (variantType != VT_BINARY_OBJECT)
                return false;

            return true;
        }
        
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.Clone"]/*' />
        /// <devdoc>
        ///    This method is needed to improve scalability on Receive and ReceiveAsync scenarios.  Not requiring 
        ///     thread safety on read and write.
        /// </devdoc>
        public object Clone() {
            return new BinaryMessageFormatter(TopObjectFormat, TypeFormat);
        }
                                 
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.Read"]/*' />
        /// <devdoc>
        ///    This method is used to read the contents from the given message 
        ///     and create an object.
        /// </devdoc>
        public object Read(Message message) {
            if (message == null)
                throw new ArgumentNullException("message");
                
            int variantType = message.BodyType;
            if (variantType == VT_BINARY_OBJECT) {                                                   
                Stream stream = message.BodyStream;                
                return formatter.Deserialize(stream);
            }
            
            throw new InvalidOperationException(Res.GetString(Res.InvalidTypeDeserialization));
        }
        
        /// <include file='doc\BinaryMessageFormatter.uex' path='docs/doc[@for="BinaryMessageFormatter.Write"]/*' />
        /// <devdoc>
        ///    This method is used to write the given object into the given message.  
        ///     If the formatter cannot understand the given object, an exception is thrown.
        /// </devdoc>
        public void Write(Message message, object obj) {
            if (message == null)
                throw new ArgumentNullException("message");
                
            Stream stream = new MemoryStream();
            formatter.Serialize(stream, obj);                
            message.BodyType = VT_BINARY_OBJECT;
            message.BodyStream = stream;
        }                                             
    }            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\imessageformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMessageFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Runtime.Serialization;    
    using System.ComponentModel;
    using System.Diagnostics;    
    using System;
 
    /// <include file='doc\IMessageFormatter.uex' path='docs/doc[@for="IMessageFormatter"]/*' />
    /// <devdoc>
    ///    The functions defined in this interface are used to 
    ///    serailize and deserialize objects into and from 
    ///    MessageQueue messages.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(System.Messaging.Design.MessageFormatterConverter))
    ]
    public interface IMessageFormatter : ICloneable {
    
        /// <include file='doc\IMessageFormatter.uex' path='docs/doc[@for="IMessageFormatter.CanRead"]/*' />
        /// <devdoc>
        ///    When this method is called, the formatter will attempt to determine 
        ///    if the contents of the message are something the formatter can deal with.
        /// </devdoc>
        bool CanRead(Message message);        
        
        /// <include file='doc\IMessageFormatter.uex' path='docs/doc[@for="IMessageFormatter.Read"]/*' />
        /// <devdoc>
        ///    This method is used to read the contents from the given message 
        ///     and create an object.
        /// </devdoc>
        object Read(Message message);
        
        /// <include file='doc\IMessageFormatter.uex' path='docs/doc[@for="IMessageFormatter.Write"]/*' />
        /// <devdoc>
        ///    This method is used to write the given object into the given message.  
        ///     If the formatter cannot understand the given object, an exception is thrown.
        /// </devdoc>
        void Write(Message message, object obj);        
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\defaultpropertiestosend.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultPropertiesToSend.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;    
    using System;
    using System.ComponentModel;

    /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the default property values that will be used when
    ///       sending objects using the message queue.
    ///    </para>
    /// </devdoc>
    [TypeConverter(typeof(ExpandableObjectConverter))]
    public class DefaultPropertiesToSend {
        private Message cachedMessage = new Message();
        private bool designMode;
        private MessageQueue cachedAdminQueue;
        private MessageQueue cachedResponseQueue;
        private MessageQueue cachedTransactionStatusQueue;
                                                                                                                                       
                                                                                                                               
        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.DefaultPropertiesToSend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.DefaultPropertiesToSend'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public DefaultPropertiesToSend() {
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.DefaultPropertiesToSend1"]/*' />
        /// <internalonly/>
        internal DefaultPropertiesToSend(bool designMode) {
            this.designMode = designMode;
        }
                     
        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.AcknowledgeTypes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the type of acknowledgement message to be returned to the sending
        ///       application.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(AcknowledgeTypes.None), MessagingDescription(Res.MsgAcknowledgeType)]
        public AcknowledgeTypes AcknowledgeType {
            get {
                return this.cachedMessage.AcknowledgeType;
            }

            set {                
                this.cachedMessage.AcknowledgeType = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.AdministrationQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the queue used for acknowledgement messages
        ///       generated by the application. This is the queue that
        ///       will receive the acknowledgment message for the message you are about to
        ///       send.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(null), MessagingDescription(Res.MsgAdministrationQueue)]
        public MessageQueue AdministrationQueue {
            get {
                if (this.designMode) {
                    if (this.cachedAdminQueue != null && this.cachedAdminQueue.Site == null) 
                        this.cachedAdminQueue = null;
                        
                    return this.cachedAdminQueue;
                }                    
                    
                return this.cachedMessage.AdministrationQueue;
            }

            set {
                //The format name of this queue shouldn't be
                //resolved at desgin time, but it should at runtime.
                if (this.designMode)
                    this.cachedAdminQueue = value;
                else                        
                    this.cachedMessage.AdministrationQueue = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.AppSpecific"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets application-generated information.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(0), MessagingDescription(Res.MsgAppSpecific)]
        public int AppSpecific {
            get {
                return this.cachedMessage.AppSpecific;
            }

            set {
                this.cachedMessage.AppSpecific = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.AttachSenderId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating if the sender ID is to be attached to the
        ///       message.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgAttachSenderId)]
        public bool AttachSenderId {
            get {
                return this.cachedMessage.AttachSenderId;
            }

            set {
                this.cachedMessage.AttachSenderId = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.CachedMessage"]/*' />
        /// <internalonly/>
        internal Message CachedMessage {
            get {
                return this.cachedMessage;
            }                
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.EncryptionAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the encryption algorithm used to encrypt the body of a
        ///       private message.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(EncryptionAlgorithm.Rc2), MessagingDescription(Res.MsgEncryptionAlgorithm)]
        public EncryptionAlgorithm EncryptionAlgorithm {
            get {
                return this.cachedMessage.EncryptionAlgorithm;
            }

            set {
                this.cachedMessage.EncryptionAlgorithm = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.Extension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets additional information associated with the message.
        ///       
        ///    </para>
        /// </devdoc>
        [
        Editor("System.ComponentModel.Design.ArrayEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),        
        MessagingDescription(Res.MsgExtension)
        ]
        public byte[] Extension {
            get {
                return this.cachedMessage.Extension;
            }

            set {
                this.cachedMessage.Extension = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.HashAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the hashing algorithm used when
        ///       authenticating
        ///       messages.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(HashAlgorithm.Md5), MessagingDescription(Res.MsgHashAlgorithm)]
        public HashAlgorithm HashAlgorithm {
            get {
                return this.cachedMessage.HashAlgorithm;
            }

            set {
                this.cachedMessage.HashAlgorithm = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.Label"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the message label.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(""), MessagingDescription(Res.MsgLabel)]
        public string Label {
            get {
                return this.cachedMessage.Label;
            }

            set {                
                this.cachedMessage.Label = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.Priority"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the message priority.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(MessagePriority.Normal), MessagingDescription(Res.MsgPriority)]
        public MessagePriority Priority {
            get {
                return this.cachedMessage.Priority;
            }

            set {
                this.cachedMessage.Priority = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.Recoverable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the message is
        ///       guaranteed to be delivered in the event
        ///       of a computer failure or network problem.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgRecoverable)]
        public bool Recoverable {
            get {
                return this.cachedMessage.Recoverable;
            }

            set {
                this.cachedMessage.Recoverable = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.ResponseQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the queue which receives application-generated response
        ///       messages.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(null), MessagingDescription(Res.MsgResponseQueue)]
        public MessageQueue ResponseQueue {
            get {
                if (this.designMode)
                 return this.cachedResponseQueue;
                    
                return this.cachedMessage.ResponseQueue;
            }

            set {
                //The format name of this queue shouldn't be
                //resolved at desgin time, but it should at runtime.
                if (this.designMode)
                    this.cachedResponseQueue = value;
                else
                    this.cachedMessage.ResponseQueue = value;
            }
        }        
        
        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.TimeToBeReceived"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the time limit for the message to be
        ///       retrieved from
        ///       the target queue.
        ///    </para>
        /// </devdoc>
        [
        TypeConverter(typeof(System.Messaging.Design.TimeoutConverter)), 
        MessagingDescription(Res.MsgTimeToBeReceived)
        ]
        public TimeSpan TimeToBeReceived {
            get {
                return this.cachedMessage.TimeToBeReceived;
            }

            set {                
                this.cachedMessage.TimeToBeReceived = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.TimeToReachQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the time limit for the message to
        ///       reach the queue.
        ///       
        ///    </para>
        /// </devdoc>
        [
        TypeConverter(typeof(System.Messaging.Design.TimeoutConverter)), 
        MessagingDescription(Res.MsgTimeToReachQueue)
        ]
        public TimeSpan TimeToReachQueue {
            get {
                return this.cachedMessage.TimeToReachQueue;
            }

            set {                
                this.cachedMessage.TimeToReachQueue = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.TransactionStatusQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the transaction status queue on the source computer.
        ///       
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(null), MessagingDescription(Res.MsgTransactionStatusQueue)]
        public MessageQueue TransactionStatusQueue {
            get {
                if (this.designMode)
                    return this.cachedTransactionStatusQueue;
                    
                return this.cachedMessage.TransactionStatusQueue;
            }

            set {
                //The format name of this queue shouldn't be
                //resolved at desgin time, but it should at runtime.
                if (this.designMode)
                    this.cachedTransactionStatusQueue = value;
                else
                    this.cachedMessage.TransactionStatusQueue = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.UseAuthentication"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the message must be authenticated.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseAuthentication)]
        public bool UseAuthentication {
            get {
                return this.cachedMessage.UseAuthentication;
            }

            set {
                this.cachedMessage.UseAuthentication = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.UseDeadLetterQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a copy of the message that could not
        ///       be delivered should be sent to a dead-letter queue.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseDeadLetterQueue)]
        public bool UseDeadLetterQueue {
            get {
                return this.cachedMessage.UseDeadLetterQueue;
            }

            set {
                this.cachedMessage.UseDeadLetterQueue = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.UseEncryption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to encrypt private messages.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseEncryption)]
        public bool UseEncryption {
            get {
                return this.cachedMessage.UseEncryption;
            }

            set {
                this.cachedMessage.UseEncryption = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.UseJournalQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a copy of the message should be kept
        ///       in a machine journal on the originating computer.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseJournalQueue)]
        public bool UseJournalQueue {
            get {
                return this.cachedMessage.UseJournalQueue;
            }

            set {
                this.cachedMessage.UseJournalQueue = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.UseTracing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to trace a message as it moves toward
        ///       its destination queue.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseTracing)]
        public bool UseTracing {
            get {
                return this.cachedMessage.UseTracing;
            }

            set {
                this.cachedMessage.UseTracing = value;
            }
        }

        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.ShouldSerializeTimeToBeReceived"]/*' />
        /// <internalonly/>
        private bool ShouldSerializeTimeToBeReceived() {   
            if (TimeToBeReceived == Message.InfiniteTimeout)
                return false;
                
            return true;                
        }
                                    
        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.ShouldSerializeTimeToReachQueue"]/*' />
        /// <internalonly/>
        private bool ShouldSerializeTimeToReachQueue() {
            if (TimeToReachQueue == Message.InfiniteTimeout)
                return false;
                
            return true;                
        }            
                                                 
        /// <include file='doc\DefaultPropertiesToSend.uex' path='docs/doc[@for="DefaultPropertiesToSend.ShouldSerializeExtension"]/*' />
        /// <internalonly/>
        private bool ShouldSerializeExtension() {
            if (Extension != null && Extension.Length > 0) {
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\hashalgorithm.cs ===
//------------------------------------------------------------------------------
// <copyright file="HashAlgorithm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;
    using System.Messaging.Interop;

    /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the hash algorithm used by Message
    ///       Queuing when authenticating messages.
    ///       
    ///    </para>
    /// </devdoc>
    public enum HashAlgorithm {

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No hashing
        ///       algorithm.
        ///       
        ///    </para>
        /// </devdoc>
       None = 0,

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Md2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       MD2 hashing algorithm.
        ///    </para>
        /// </devdoc>
       Md2 = NativeMethods.CALG_MD2,

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Md4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       MD4 hashing algorithm.
        ///       
        ///    </para>
        /// </devdoc>
       Md4 = NativeMethods.CALG_MD4,

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Md5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       MD5 hashing algorithm.
        ///    </para>
        /// </devdoc>
       Md5 = NativeMethods.CALG_MD5,

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Sha"]/*' />
        /// <devdoc>
        ///    <para>
        ///       SHA hashing algorithm.
        ///    </para>
        /// </devdoc>
       Sha = NativeMethods.CALG_SHA,

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Mac"]/*' />
        /// <devdoc>
        ///    <para>
        ///       MAC keyed hashing algorithm.
        ///    </para>
        /// </devdoc>
       Mac = NativeMethods.CALG_MAC,
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\genericaccessrights.cs ===
//------------------------------------------------------------------------------
// <copyright file="GenericAccessRights.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GenericAccessRights.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Messaging {
    /// <include file='doc\GenericAccessRights.uex' path='docs/doc[@for="GenericAccessRights"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum GenericAccessRights {
        /// <include file='doc\GenericAccessRights.uex' path='docs/doc[@for="GenericAccessRights.All"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        All     = 1 << 28,
        /// <include file='doc\GenericAccessRights.uex' path='docs/doc[@for="GenericAccessRights.Execute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Execute = 1 << 29,
        /// <include file='doc\GenericAccessRights.uex' path='docs/doc[@for="GenericAccessRights.Write"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Write   = 1 << 30,
        /// <include file='doc\GenericAccessRights.uex' path='docs/doc[@for="GenericAccessRights.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Read    = 1 << 31,
        /// <include file='doc\GenericAccessRights.uex' path='docs/doc[@for="GenericAccessRights.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None    = 0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messageenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageEnumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
                          
namespace System.Messaging {    

    using System.Diagnostics;
    using System;  
    using System.ComponentModel;  
    using System.Collections;
    using System.Messaging.Interop;
    
    /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator"]/*' />
    /// <devdoc>
    ///    <para>Provides (forward-only)
    ///       cursor semantics to enumerate the messages contained in
    ///       a queue.</para>
    ///    <note type="rnotes">
    ///       Translate into English?
    ///    </note>
    /// </devdoc>
    public class MessageEnumerator : MarshalByRefObject, IEnumerator, IDisposable {
        private MessageQueue owner;
        private IntPtr handle;
        private int index;                  
        private bool disposed;

        internal MessageEnumerator(MessageQueue owner) {
            this.owner = owner;
            this.index = 0;            
        }              

        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.Current"]/*' />
        /// <devdoc>
        /// <para>Gets the current <see cref='System.Messaging.Message'/> pointed to
        ///    by this enumerator.</para>
        /// </devdoc>
        public Message Current {
            get {
                if (this.index == 0)
                        throw new InvalidOperationException(Res.GetString(Res.NoCurrentMessage));

                return this.owner.ReceiveCurrent(TimeSpan.Zero, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, CursorHandle,
                                                              this.owner.MessageReadPropertyFilter, null,
                                                              MessageQueueTransactionType.None);
            }
        } 
        
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.IEnumerator.Current"]/*' />
        /// <internalonly/>
        object IEnumerator.Current {
            get {
                return this.Current;
            }                   			
        }

        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.CursorHandle"]/*' />
        /// <devdoc>
        ///    <para>Gets the native Message Queuing cursor handle used to browse messages
        ///       in the queue.</para>
        /// </devdoc>
        public IntPtr CursorHandle{
            get{
                //Cursor handle doesn't demmand permissions since GetEnumerator will demmand somehow.
                if (this.handle == (IntPtr)0) {
                    //Cannot allocate the a new cursor if the object has been disposed, since finalization has been suppressed.
                    if (this.disposed)
                        throw new ObjectDisposedException(GetType().Name);
                        
                    IntPtr result;
                    int status = SafeNativeMethods.MQCreateCursor(this.owner.MQInfo.ReadHandle, out result);
                    if (MessageQueue.IsFatalError(status))
                        throw new MessageQueueException(status);

                    this.handle =  result;
                }
                return this.handle;
            }
        }

        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Frees the resources associated with the enumerator.
        ///    </para>
        /// </devdoc>
        public void Close() {
            this.index = 0;            
            if (this.handle != (IntPtr)0) {
                SafeNativeMethods.MQCloseCursor(this.handle);
                this.handle = (IntPtr)0;
            }
        }
         
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Dispose() {            
            Dispose(true);            
            GC.SuppressFinalize(this);                           
        }                         
        
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.Dispose1"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            this.Close();      
            this.disposed = true;                      
        }
                         
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.Finalize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        ~MessageEnumerator() {
            Dispose(false);
        }

        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>Advances the enumerator to the next message in the queue, if one
        ///       is currently available.</para>
        /// </devdoc>
        public bool MoveNext() {
            return MoveNext(TimeSpan.Zero);
        }

        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.MoveNext1"]/*' />
        /// <devdoc>
        ///    <para>Advances the enumerator to the next message in the
        ///       queue. If the enumerator is positioned at the end of the queue, <see cref='System.Messaging.MessageEnumerator.MoveNext'/> waits until a message is available or the
        ///       given <paramref name="timeout"/>
        ///       expires.</para>
        /// </devdoc>
        public unsafe bool MoveNext(TimeSpan timeout) {
            long timeoutInMilliseconds = (long)timeout.TotalMilliseconds;
            if (timeoutInMilliseconds < 0 || timeoutInMilliseconds > UInt32.MaxValue)
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "timeout", timeout.ToString()));
                
            int status = 0;                
            int action = NativeMethods.QUEUE_ACTION_PEEK_NEXT;
            //Peek current or next?
            if (this.index == 0)
                action = NativeMethods.QUEUE_ACTION_PEEK_CURRENT;
                
            status =  owner.StaleSafeReceiveMessage((uint)timeoutInMilliseconds,  action, null, null, null, CursorHandle, (IntPtr)NativeMethods.QUEUE_TRANSACTION_NONE);                          
            //If the cursor reached the end of the queue.
            if (status == (int)MessageQueueErrorCode.IOTimeout) {
                this.Close();
                return false;
            }
            //If all messages were removed.
            else if (status == (int)MessageQueueErrorCode.IllegalCursorAction) {
                this.index = 0;
                this.Close();
                return false;
            }

            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);

            ++ this.index;                
            return true;
        }           
          
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.RemoveCurrent"]/*' />
        /// <devdoc>
        ///    <para> Removes the current message from
        ///       the queue and returns the message to the calling application.</para>
        /// </devdoc>
        public Message RemoveCurrent() {
            return RemoveCurrent(TimeSpan.Zero, null, MessageQueueTransactionType.None);
        }              
        
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.RemoveCurrent1"]/*' />
        /// <devdoc>
        ///    <para> Removes the current message from
        ///       the queue and returns the message to the calling application.</para>
        /// </devdoc>
        public Message RemoveCurrent(MessageQueueTransaction transaction) {                    
            if (transaction == null) 
                throw new ArgumentNullException("transaction");
                
            return RemoveCurrent(TimeSpan.Zero, transaction, MessageQueueTransactionType.None);
        }
         
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.RemoveCurrent5"]/*' />
        /// <devdoc>
        ///    <para> Removes the current message from
        ///       the queue and returns the message to the calling application.</para>
        /// </devdoc>
        public Message RemoveCurrent(MessageQueueTransactionType transactionType) {                    
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
                
            return RemoveCurrent(TimeSpan.Zero, null, transactionType);
        }         
            
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.RemoveCurrent2"]/*' />
        /// <devdoc>
        ///    <para> Removes the current message from
        ///       the queue and returns the message to the calling application within the timeout specified.</para>
        /// </devdoc>
        public Message RemoveCurrent(TimeSpan timeout) {
            return RemoveCurrent(timeout, null, MessageQueueTransactionType.None);
        }      
        
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.RemoveCurrent3"]/*' />
        /// <devdoc>
        ///    <para> Removes the current message from
        ///       the queue and returns the message to the calling application within the timeout specified.</para>
        /// </devdoc>
        public Message RemoveCurrent(TimeSpan timeout, MessageQueueTransaction transaction) {     
            if (transaction == null) 
                throw new ArgumentNullException("transaction");
                
            return RemoveCurrent(timeout, transaction, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.RemoveCurrent4"]/*' />
        /// <devdoc>
        ///    <para> Removes the current message from
        ///       the queue and returns the message to the calling application within the timeout specified.</para>
        /// </devdoc>
        public Message RemoveCurrent(TimeSpan timeout, MessageQueueTransactionType transactionType) {     
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                          
                
            return RemoveCurrent(timeout, null, transactionType);
        }
                
        private Message RemoveCurrent(TimeSpan timeout, MessageQueueTransaction transaction, MessageQueueTransactionType transactionType) {                                 
            long timeoutInMilliseconds = (long)timeout.TotalMilliseconds;
            if (timeoutInMilliseconds < 0 || timeoutInMilliseconds > UInt32.MaxValue)
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "timeout", timeout.ToString()));            
                
            if (this.index == 0)
                return null;
            
            Message message = this.owner.ReceiveCurrent(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, 
                                                                               CursorHandle, this.owner.MessageReadPropertyFilter, transaction, transactionType);                            
                                                                            
            --this.index;
            return message;
        }         
         
        /// <include file='doc\MessageEnumerator.uex' path='docs/doc[@for="MessageEnumerator.Reset"]/*' />
        /// <devdoc>
        ///    <para> Resets the current enumerator, so it points to
        ///       the head of the queue.</para>
        /// </devdoc>
        public void Reset() {
            this.Close();            
        }      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeueaccesscontrolentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueAccessControlEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MessageQueueAccessControlEntry.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Messaging.Interop;

namespace System.Messaging {
    /// <include file='doc\MessageQueueAccessControlEntry.uex' path='docs/doc[@for="MessageQueueAccessControlEntry"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class MessageQueueAccessControlEntry : AccessControlEntry {
        /// <include file='doc\MessageQueueAccessControlEntry.uex' path='docs/doc[@for="MessageQueueAccessControlEntry.MessageQueueAccessControlEntry"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueueAccessControlEntry(Trustee trustee, MessageQueueAccessRights rights) : base(trustee) {
            CustomAccessRights |= (int)rights;
        }
    
        /// <include file='doc\MessageQueueAccessControlEntry.uex' path='docs/doc[@for="MessageQueueAccessControlEntry.MessageQueueAccessControlEntry1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueueAccessControlEntry(Trustee trustee, MessageQueueAccessRights rights, AccessControlEntryType entryType) : base(trustee) {
            CustomAccessRights |= (int)rights;
            EntryType = entryType;
        }

        /// <include file='doc\MessageQueueAccessControlEntry.uex' path='docs/doc[@for="MessageQueueAccessControlEntry.MessageQueueAccessRights"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueueAccessRights MessageQueueAccessRights {
            get {
                return (MessageQueueAccessRights)CustomAccessRights;
            }
            set {
                CustomAccessRights = (int)value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagepropertyfilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessagePropertyFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System;
    using System.Messaging.Interop;
    using System.ComponentModel;    
    using Microsoft.Win32;

    /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Limits the
    ///       properties retrieved when receiving messages from a queue.
    ///    </para>
    /// </devdoc>
    [TypeConverter(typeof(ExpandableObjectConverter))]
    public class MessagePropertyFilter {        
        internal const int ACKNOWLEDGEMENT = 1;
        internal const int ACKNOWLEDGE_TYPE = 1 << 2;
        internal const int ADMIN_QUEUE = 1 << 3;                        
        internal const int BODY = 1 << 4;
        internal const int LABEL = 1 << 5;
        internal const int ID = 1 << 6;
        internal const int USE_DEADLETTER_QUEUE = 1 << 7;        
        internal const int RESPONSE_QUEUE = 1 << 8;
        internal const int MESSAGE_TYPE = 1 << 9;
        internal const int USE_JOURNALING = 1 << 10;
                
        internal const int APP_SPECIFIC = 1;
        internal const int ARRIVED_TIME = 1 << 2;
        internal const int ATTACH_SENDER_ID = 1 << 3;
        internal const int AUTHENTICATED = 1 << 4;        
        internal const int CONNECTOR_TYPE = 1 << 5;
        internal const int CORRELATION_ID = 1 << 6;
        internal const int CRYPTOGRAPHIC_PROVIDER_NAME = 1 << 7;
        internal const int CRYPTOGRAPHIC_PROVIDER_TYPE = 1 << 8;
        internal const int IS_RECOVERABLE = 1 << 9;        
        internal const int DIGITAL_SIGNATURE = 1 << 10;
        internal const int ENCRYPTION_ALGORITHM = 1 << 11;
        internal const int EXTENSION = 1 << 12;
        internal const int FOREIGN_ADMIN_QUEUE = 1 << 13;
        internal const int HASH_ALGORITHM = 1 << 14;
        internal const int DESTINATION_QUEUE = 1 << 15;                
        internal const int PRIORITY = 1 << 16;        
        internal const int SECURITY_CONTEXT = 1 << 17;
        internal const int SENDER_CERTIFICATE = 1 << 18;
        internal const int SENDER_ID = 1 << 19;
        internal const int SENT_TIME = 1 << 20;
        internal const int SOURCE_MACHINE = 1 << 21;
        internal const int SYMMETRIC_KEY = 1 << 22;
        internal const int TIME_TO_BE_RECEIVED = 1 << 23;
        internal const int TIME_TO_REACH_QUEUE = 1 << 24;
        internal const int USE_AUTHENTICATION = 1 << 25;        
        internal const int USE_ENCRYPTION = 1 << 26;        
        internal const int USE_TRACING = 1 << 27;
        internal const int VERSION = 1 << 28;
        internal const int IS_FIRST_IN_TRANSACTION = 1 << 29;
        internal const int IS_LAST_IN_TRANSACTION = 1 << 30;
        internal const int TRANSACTION_ID = 1 << 31;
        
        internal int data1;
        internal int data2;
        private const int defaultBodySize = 1024; 
        private const int defaultExtensionSize = 255; 
        private const int defaultLabelSize = 255; 
        internal int bodySize = defaultBodySize;
        internal int extensionSize = defaultExtensionSize;
        internal int labelSize = defaultLabelSize;
        

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.MessagePropertyFilter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.MessagePropertyFilter'/>
        ///       class
        ///       and
        ///       sets
        ///       the
        ///       most
        ///       common
        ///       filter
        ///       properties
        ///       to
        ///       true.
        ///    </para>
        /// </devdoc>
        public MessagePropertyFilter() {
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Acknowledgment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve
        ///    <see cref='System.Messaging.Message.Acknowledgment' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgAcknowledgement)]
        public bool Acknowledgment{
            get{
                return((data1 & ACKNOWLEDGEMENT) != 0);
            }

            set{
                data1 = value ? data1 | ACKNOWLEDGEMENT : data1 & ~ ACKNOWLEDGEMENT;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.AcknowledgeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.AcknowledgeType' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgAcknowledgeType)]
        public bool AcknowledgeType{
            get{
                return((data1 & ACKNOWLEDGE_TYPE) != 0);
            }

            set{
                data1 = value ? data1 | ACKNOWLEDGE_TYPE : data1 & ~ ACKNOWLEDGE_TYPE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.AdministrationQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.AdministrationQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgAdministrationQueue)]
        public bool AdministrationQueue{
            get{
                return((data1 & ADMIN_QUEUE) != 0);
            }

            set{
                data1 = value ? data1 | ADMIN_QUEUE : data1 & ~ ADMIN_QUEUE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.AppSpecific"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.AppSpecific' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgAppSpecific)]
        public bool AppSpecific{
            get{
                return((data2 & APP_SPECIFIC) != 0);
            }

            set{
                data2 = value ? data2 | APP_SPECIFIC : data2 & ~ APP_SPECIFIC;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.ArrivedTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.ArrivedTime' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgArrivedTime)]
        public bool ArrivedTime{
            get{
                return((data2 & ARRIVED_TIME) != 0);
            }

            set{
                data2 = value ? data2 | ARRIVED_TIME : data2 & ~ ARRIVED_TIME;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.AttachSenderId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.AttachSenderId' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgAttachSenderId)]
        public bool AttachSenderId{
            get{
                return((data2 & ATTACH_SENDER_ID) != 0);
            }

            set{
                data2 = value ? data2 | ATTACH_SENDER_ID : data2 & ~ ATTACH_SENDER_ID;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Authenticated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Authenticated' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgAuthenticated)]
        public bool Authenticated{
            get{
                return((data2 & AUTHENTICATED) != 0);
            }

            set{
                data2 = value ? data2 | AUTHENTICATED : data2 & ~ AUTHENTICATED;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.AuthenticationProviderName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.AuthenticationProviderName' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgAuthenticationProviderName)]
        public bool AuthenticationProviderName{
            get{
                return((data2 & CRYPTOGRAPHIC_PROVIDER_NAME) != 0);
            }

            set{
                data2 = value ? data2 | CRYPTOGRAPHIC_PROVIDER_NAME : data2 & ~ CRYPTOGRAPHIC_PROVIDER_NAME;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.AuthenticationProviderType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.AuthenticationProviderType' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgAuthenticationProviderType)]
        public bool AuthenticationProviderType{
            get{
                return((data2 & CRYPTOGRAPHIC_PROVIDER_TYPE) != 0);
            }

            set{
                data2 = value ? data2 | CRYPTOGRAPHIC_PROVIDER_TYPE : data2 & ~ CRYPTOGRAPHIC_PROVIDER_TYPE;
            }
        }        

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Body"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Body' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgBody)]
        public bool Body{
            get{
                return((data1 & BODY) != 0);
            }

            set{
                data1 = value ? data1 | BODY : data1 & ~ BODY;
            }
        }

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.ConnectorType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.ConnectorType' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgConnectorType)]
        public bool ConnectorType{
            get{
                return((data2 & CONNECTOR_TYPE) != 0);
            }

            set{
                data2 = value ? data2 | CONNECTOR_TYPE : data2 & ~ CONNECTOR_TYPE;
            }
        }

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.CorrelationId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.CorrelationId' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgCorrelationId)]
        public bool CorrelationId{
            get{
                return((data2 & CORRELATION_ID) != 0);
            }

            set{
                data2 = value ? data2 | CORRELATION_ID : data2 & ~ CORRELATION_ID;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.DefaultBodySize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the size,
        ///       in bytes, of the default body buffer.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(MessagePropertyFilter.defaultBodySize), MessagingDescription(Res.MsgDefaultBodySize)]
        public int DefaultBodySize {
            get {
                return this.bodySize;
            }            
            
            set {
                if (value < 0)
                    throw new ArgumentException(Res.GetString(Res.DefaultSizeError));
                    
                this.bodySize = value;                       
            }
        }

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.DefaultExtensionSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the
        ///       size, in bytes, of the default extension buffer.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(MessagePropertyFilter.defaultExtensionSize), MessagingDescription(Res.MsgDefaultExtensionSize)]
        public int DefaultExtensionSize {
            get {
                return this.extensionSize;
            }
            
            set {
                if (value < 0)
                    throw new ArgumentException(Res.GetString(Res.DefaultSizeError));
                    
                this.extensionSize = value;                    
            }            
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.DefaultLabelSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the size,
        ///       in bytes, of the default label buffer.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(MessagePropertyFilter.defaultLabelSize), MessagingDescription(Res.MsgDefaultLabelSize)]
        public int DefaultLabelSize {
            get {
                return this.labelSize;
            }
            
            set {
                if (value < 0)
                    throw new ArgumentException(Res.GetString(Res.DefaultSizeError));
                    
                this.labelSize = value;
            }            
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.DestinationQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.DestinationQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgDestinationQueue)]
        public bool DestinationQueue{
            get{
                return((data2 & DESTINATION_QUEUE) != 0);
            }

            set{
                data2 = value ? data2 | DESTINATION_QUEUE : data2 & ~ DESTINATION_QUEUE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.DestinationSymmetricKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve
        ///    <see cref='System.Messaging.Message.DestinationSymmetricKey' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgDestinationSymmetricKey)]
        public bool DestinationSymmetricKey {
            get{
                return((data2 & SYMMETRIC_KEY) != 0);
            }

            set{
                data2 = value ? data2 | SYMMETRIC_KEY : data2 & ~ SYMMETRIC_KEY;
            }
        }        
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.DigitalSignature"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.DigitalSignature' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgDigitalSignature)]
        public bool DigitalSignature{
            get{
                return((data2 & DIGITAL_SIGNATURE) != 0);
            }

            set{
                data2 = value ? data2 | DIGITAL_SIGNATURE : data2 & ~ DIGITAL_SIGNATURE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.EncryptionAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.EncryptionAlgorithm' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgEncryptionAlgorithm)]
        public bool EncryptionAlgorithm{
            get{
                return((data2 & ENCRYPTION_ALGORITHM) != 0);
            }

            set{
                data2 = value ? data2 | ENCRYPTION_ALGORITHM : data2 & ~ ENCRYPTION_ALGORITHM;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Extension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Extension' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgExtension)]
        public bool Extension{
            get{
                return((data2 & EXTENSION) != 0);
            }

            set{
                data2 = value ? data2 | EXTENSION : data2 & ~ EXTENSION;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.HashAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.HashAlgorithm' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgHashAlgorithm)]
        public bool HashAlgorithm{
            get{
                return((data2 & HASH_ALGORITHM) != 0);
            }

            set{
                data2 = value ? data2 | HASH_ALGORITHM : data2 & ~ HASH_ALGORITHM;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Id"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Id' qualify='true'/>
        ///       property information when receiving or peeking a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgId)]
        public bool Id{
            get{
                return((data1 & ID) != 0);
            }

            set{
                data1 = value ? data1 | ID : data1 & ~ ID;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.IsFirstInTransaction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.IsFirstInTransaction' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgIsFirstInTransaction)]
        public bool IsFirstInTransaction {
            get {
                return ((data2 & IS_FIRST_IN_TRANSACTION) != 0);
            }
            
            set {
                data2 = value ? data2 | IS_FIRST_IN_TRANSACTION : data2 & ~ IS_FIRST_IN_TRANSACTION;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.IsLastInTransaction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.IsLastInTransaction' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgIsLastInTransaction)]
        public bool IsLastInTransaction {
            get {
                return ((data2 & IS_LAST_IN_TRANSACTION) != 0);                
            }
            
            set {
                data2 = value ? data2 | IS_LAST_IN_TRANSACTION : data2 & ~ IS_LAST_IN_TRANSACTION;
            }
        }        
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Label"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Label' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgLabel)]
        public bool Label{
            get{
                return((data1 & LABEL) != 0);
            }

            set{
                data1 = value ? data1 | LABEL : data1 & ~ LABEL;
            }
        }

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.MessageType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.MessageType' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgMessageType)]
        public bool MessageType{
            get{
                return((data1 & MESSAGE_TYPE) != 0);
            }

            set{
                data1 = value ? data1 | MESSAGE_TYPE : data1 & ~ MESSAGE_TYPE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Priority"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Priority' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgPriority)]
        public bool Priority{
            get{
                return((data2 & PRIORITY) != 0);
            }

            set{
                data2 = value ? data2 | PRIORITY : data2 & ~ PRIORITY;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.Recoverable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.Recoverable' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgRecoverable)]
        public bool Recoverable{
            get{
                return((data2 & IS_RECOVERABLE) != 0);
            }

            set{
                data2 = value ? data2 | IS_RECOVERABLE : data2 & ~ IS_RECOVERABLE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.ResponseQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.ResponseQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgResponseQueue)]
        public bool ResponseQueue{
            get{
                return((data1 & RESPONSE_QUEUE) != 0);
            }

            set{
                data1 = value ? data1 | RESPONSE_QUEUE : data1 & ~ RESPONSE_QUEUE;
            }
        }       

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SenderCertificate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.SenderCertificate' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgSenderCertificate)]
        public bool SenderCertificate{
            get{
                return((data2 & SENDER_CERTIFICATE) != 0);
            }

            set{
                data2 = value ? data2 | SENDER_CERTIFICATE : data2 & ~ SENDER_CERTIFICATE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SenderId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.SenderId' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgSenderId)]
        public bool SenderId{
            get{
                return((data2 & SENDER_ID) != 0);
            }

            set{
                data2 = value ? data2 | SENDER_ID : data2 & ~ SENDER_ID;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SenderVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.SenderVersion' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgSenderVersion)]
        public bool SenderVersion{
            get{
                return((data2 & VERSION) != 0);
            }

            set{
                data2 = value ? data2 | VERSION : data2 & ~ VERSION;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SentTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.SentTime' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgSentTime)]
        public bool SentTime{
            get{
                return((data2 & SENT_TIME) != 0);
            }

            set{
                data2 = value ? data2 | SENT_TIME : data2 & ~ SENT_TIME;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SourceMachine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.SourceMachine' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgSourceMachine)]
        public bool SourceMachine{
            get{
                return((data2 & SOURCE_MACHINE) != 0);
            }

            set{
                data2 = value ? data2 | SOURCE_MACHINE : data2 & ~ SOURCE_MACHINE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.TimeToBeReceived"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.TimeToBeReceived' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgTimeToBeReceived)]
        public bool TimeToBeReceived{
            get{
                return((data2 & TIME_TO_BE_RECEIVED) != 0);
            }

            set{
                data2 = value ? data2 | TIME_TO_BE_RECEIVED : data2 & ~ TIME_TO_BE_RECEIVED;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.TimeToReachQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.TimeToReachQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgTimeToReachQueue)]
        public bool TimeToReachQueue{
            get{
                return((data2 & TIME_TO_REACH_QUEUE) != 0);
            }

            set{
                data2 = value ? data2 | TIME_TO_REACH_QUEUE : data2 & ~ TIME_TO_REACH_QUEUE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.TransactionId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.TransactionId' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgTransactionId)]
        public bool TransactionId {
            get {
                return ((data2 & TRANSACTION_ID) != 0);
            }
            
            set {
                data2 = value ? data2 | TRANSACTION_ID : data2 & ~ TRANSACTION_ID;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.TransactionStatusQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.TransactionStatusQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgTransactionStatusQueue)]
        public bool TransactionStatusQueue{
            get{
                return((data2 & FOREIGN_ADMIN_QUEUE) != 0);
            }

            set{
                data2 = value ? data2 | FOREIGN_ADMIN_QUEUE : data2 & ~ FOREIGN_ADMIN_QUEUE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.UseAuthentication"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.UseAuthentication' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseAuthentication)]
        public bool UseAuthentication{
            get{
                return((data2 & USE_AUTHENTICATION) != 0);
            }

            set{
                data2 = value ? data2 | USE_AUTHENTICATION : data2 & ~ USE_AUTHENTICATION;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.UseDeadLetterQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.UseDeadLetterQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgUseDeadLetterQueue)]
        public bool UseDeadLetterQueue{
            get{
                return((data1 & USE_DEADLETTER_QUEUE) != 0);
            }

            set{
                data1 = value ? data1 | USE_DEADLETTER_QUEUE : data1 & ~ USE_DEADLETTER_QUEUE;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.UseEncryption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.UseEncryption' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseEncryption)]
        public bool UseEncryption{
            get{
                return((data2 & USE_ENCRYPTION) != 0);
            }

            set{
                data2 = value ? data2 | USE_ENCRYPTION : data2 & ~ USE_ENCRYPTION;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.UseJournalQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.UseJournalQueue' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(true), MessagingDescription(Res.MsgUseJournalQueue)]
        public bool UseJournalQueue{
            get{
                return((data1 & USE_JOURNALING) != 0);
            }

            set{
                data1 = value ? data1 | USE_JOURNALING : data2 & ~ USE_JOURNALING;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.UseTracing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to retrieve <see cref='System.Messaging.Message.UseTracing' qualify='true'/> property information when receiving or peeking
        ///       a message.
        ///    </para>
        /// </devdoc>
        [DefaultValueAttribute(false), MessagingDescription(Res.MsgUseTracing)]
        public bool UseTracing{
            get{
                return((data2 & USE_TRACING) != 0);
            }

            set{
                data2 = value ? data2 | USE_TRACING : data2 & ~ USE_TRACING;
            }
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.ClearAll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies not to retrieve
        ///       any message properties when receiving a message.
        ///    </para>
        /// </devdoc>
        public void ClearAll() {
            data1 = 0;
            data2 = 0;
        }
        
        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SetDefaults"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Filters on the message properties that the
        ///       constructor sets to <see langword='true'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public void SetDefaults() {                        
            data1 = ACKNOWLEDGEMENT |
                   ACKNOWLEDGE_TYPE |
                   ADMIN_QUEUE |
                   BODY |
                   ID |
                   LABEL |
                   USE_DEADLETTER_QUEUE |
                   RESPONSE_QUEUE |
                   MESSAGE_TYPE |
                   USE_JOURNALING;
            
            data2 = 0;
            DefaultBodySize = defaultBodySize;
            DefaultExtensionSize = defaultExtensionSize;
            DefaultLabelSize = defaultLabelSize;
        }

        /// <include file='doc\MessagePropertyFilter.uex' path='docs/doc[@for="MessagePropertyFilter.SetAll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies to retrieve all
        ///       message properties when receiving a message.
        ///    </para>
        /// </devdoc>
        public void SetAll() {
            data1 = ACKNOWLEDGEMENT |
                   ACKNOWLEDGE_TYPE |
                   ADMIN_QUEUE |
                   BODY |
                   ID |
                   LABEL |
                   USE_DEADLETTER_QUEUE |
                   RESPONSE_QUEUE |
                   MESSAGE_TYPE |
                   USE_JOURNALING;
                                      
            data2 = APP_SPECIFIC |
                   ARRIVED_TIME |
                   ATTACH_SENDER_ID |
                   AUTHENTICATED |                   
                   CONNECTOR_TYPE |
                   CORRELATION_ID |
                   CRYPTOGRAPHIC_PROVIDER_NAME |
                   CRYPTOGRAPHIC_PROVIDER_TYPE |
                   IS_RECOVERABLE |
                   DESTINATION_QUEUE  |
                   DIGITAL_SIGNATURE |
                   ENCRYPTION_ALGORITHM |
                   EXTENSION |
                   FOREIGN_ADMIN_QUEUE  |
                   HASH_ALGORITHM |                   
                   PRIORITY |                   
                   SECURITY_CONTEXT |
                   SENDER_CERTIFICATE |
                   SENDER_ID |
                   SENT_TIME |
                   SOURCE_MACHINE |
                   SYMMETRIC_KEY |
                   TIME_TO_BE_RECEIVED |
                   TIME_TO_REACH_QUEUE |
                   USE_AUTHENTICATION |                  
                   USE_ENCRYPTION |                   
                   USE_TRACING |
                   VERSION |
                   IS_FIRST_IN_TRANSACTION |
                   IS_LAST_IN_TRANSACTION |
                   TRANSACTION_ID;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuecriteria.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueCriteria.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;
    using System;    
    using System.Messaging.Interop;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Security.Permissions;    

    /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This class
    ///       is used to filter MessageQueues when performing a
    ///       query in the network, through MessageQueue.GetPublicQueues method.
    ///    </para>
    /// </devdoc>
    public class MessageQueueCriteria {
        private DateTime createdAfter;
        private DateTime createdBefore;
        private string label;
        private string machine;
        private DateTime modifiedAfter;
        private DateTime modifiedBefore;
        private Guid category;
        private CriteriaPropertyFilter filter = new CriteriaPropertyFilter();
        private Restrictions restrictions;
        private Guid machineId;        
        private static DateTime minDate = new DateTime(1970 , 1, 1);
        private static DateTime maxDate = new DateTime(2038 , 1, 19);

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.CreatedAfter"]/*' />
        /// <devdoc>
        ///    Specifies the lower bound of the interval 
        ///    that will be used as  the queue creation time
        ///    search criteria.
        /// </devdoc>
        public DateTime CreatedAfter{
             get {
                if (!this.filter.CreatedAfter)
                    throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

                return this.createdAfter;
             }

             set {
                if (value < MessageQueueCriteria.minDate || value > MessageQueueCriteria.maxDate)
                    throw new ArgumentException(Res.GetString(Res.InvalidDateValue, MessageQueueCriteria.minDate.ToString(), MessageQueueCriteria.maxDate.ToString()));
                    
                this.createdAfter = value;
                if (this.filter.CreatedBefore && this.createdAfter > this.createdBefore)
                    this.createdBefore = this.createdAfter;

                this.filter.CreatedAfter = true;
             }
         }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.CreatedBefore"]/*' />
        /// <devdoc>
        ///    Specifies the upper bound of the interval 
        ///    that will be used as  the queue creation time
        ///    search criteria.
        /// </devdoc>
         public DateTime CreatedBefore{
             get {
                if (!this.filter.CreatedBefore)
                    throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

                return this.createdBefore;
             }

             set {
                if (value < MessageQueueCriteria.minDate || value > MessageQueueCriteria.maxDate)
                    throw new ArgumentException(Res.GetString(Res.InvalidDateValue, MessageQueueCriteria.minDate.ToString(), MessageQueueCriteria.maxDate.ToString()));
                    
                this.createdBefore = value;
                if (this.filter.CreatedAfter && this.createdAfter > this.createdBefore)
                    this.createdAfter = this.createdBefore;

                this.filter.CreatedBefore = true;
             }
         }

         internal bool FilterMachine{
            get{
                return this.filter.MachineName;
            }
         }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.Label"]/*' />
        /// <devdoc>
        ///    Specifies the label that that will be used as 
        ///    the criteria to search queues in the network.        
        /// </devdoc>
         public string Label{
             get {
                if (!this.filter.Label)
                    throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

                return this.label;
             }

             set {
                if (value == null)
                    throw new ArgumentNullException("value");

                this.label = value;
                this.filter.Label = true;
             }
         }

         /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.MachineName"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Specifies the machine name that will be used
         ///       as the criteria to search queues in the network.
         ///    </para>
         /// </devdoc>
         public string MachineName{
             get {
                if (!this.filter.MachineName)
                    throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

                return this.machine;
             }

             set {
                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "MachineName", value));            
                               
                //SECREVIEW: Setting this property shouldn't demmand any permissions,
                //                    the machine id will only be used internally.
                MessageQueuePermission permission = new MessageQueuePermission(PermissionState.Unrestricted);
                permission.Assert();
                try {
                    this.machineId = MessageQueue.GetMachineId(value);
                }
                finally {
                    MessageQueuePermission.RevertAssert();
                }
                                                               
                this.machine = value;
                this.filter.MachineName = true;
             }
         }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.ModifiedAfter"]/*' />
        /// <devdoc>
        ///    Specifies the lower bound of the interval 
        ///    that will be used as  the queue modified time
        ///    search criteria.
        /// </devdoc>
         public DateTime ModifiedAfter{
             get {
                if (!this.filter.ModifiedAfter)
                    throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

                return this.modifiedAfter;
             }
                                                                             
             set {
                if (value < MessageQueueCriteria.minDate || value > MessageQueueCriteria.maxDate)
                    throw new ArgumentException(Res.GetString(Res.InvalidDateValue, MessageQueueCriteria.minDate.ToString(), MessageQueueCriteria.maxDate.ToString()));
                
                this.modifiedAfter = value;

                if (this.filter.ModifiedBefore && this.modifiedAfter > this.modifiedBefore)
                    this.modifiedBefore = this.modifiedAfter;

                this.filter.ModifiedAfter = true;
             }
         }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.ModifiedBefore"]/*' />
        /// <devdoc>
        ///    Specifies the upper bound of the interval 
        ///    that will be used as  the queue modified time
        ///    search criteria.
        /// </devdoc>
         public DateTime ModifiedBefore{
             get {
                if (!this.filter.ModifiedBefore)
                    throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

                return this.modifiedBefore;
             }

             set {
                if (value < MessageQueueCriteria.minDate || value > MessageQueueCriteria.maxDate)
                    throw new ArgumentException(Res.GetString(Res.InvalidDateValue, MessageQueueCriteria.minDate.ToString(), MessageQueueCriteria.maxDate.ToString()));
                
                this.modifiedBefore = value;

                if (this.filter.ModifiedAfter && this.modifiedAfter > this.modifiedBefore)
                    this.modifiedAfter = this.modifiedBefore;

                this.filter.ModifiedBefore = true;
             }
         }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.Reference"]/*' />
        ///    <internalonly/>
        internal Restrictions.MQRESTRICTION Reference{
           get{
               int size = 0;
               if (this.filter.CreatedAfter)
                   ++ size;
               if (this.filter.CreatedBefore)
                   ++ size;
               if (this.filter.Label)
                   ++ size;
               if (this.filter.ModifiedAfter)
                   ++ size;
               if (this.filter.ModifiedBefore)
                   ++ size;
               if (this.filter.Category)
                   ++ size;

               restrictions = new Restrictions(size);
               if (this.filter.CreatedAfter)
                   restrictions.AddI4(NativeMethods.QUEUE_PROPID_CREATE_TIME, Restrictions.PRGT, ConvertTime(this.createdAfter));
               if (this.filter.CreatedBefore)
                   restrictions.AddI4(NativeMethods.QUEUE_PROPID_CREATE_TIME, Restrictions.PRLE, ConvertTime(this.createdBefore));
               if (this.filter.Label)
                   restrictions.AddString(NativeMethods.QUEUE_PROPID_LABEL, Restrictions.PREQ, this.label);
               if (this.filter.ModifiedAfter)
                   restrictions.AddI4(NativeMethods.QUEUE_PROPID_MODIFY_TIME, Restrictions.PRGT, ConvertTime(this.modifiedAfter));
               if (this.filter.ModifiedBefore)
                   restrictions.AddI4(NativeMethods.QUEUE_PROPID_MODIFY_TIME, Restrictions.PRLE, ConvertTime(this.modifiedBefore));
               if (this.filter.Category)
                   restrictions.AddGuid(NativeMethods.QUEUE_PROPID_TYPE, Restrictions.PREQ, this.category);

               return this.restrictions.GetRestrictionsRef();
           }
        }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.Category"]/*' />
        /// <devdoc>
        ///    Specifies the Category that will be used 
        ///    as the criteria to search queues in the network.        
        /// </devdoc>
        public Guid Category{
            get {
               if (!this.filter.Category)
                   throw new InvalidOperationException(Res.GetString(Res.CriteriaNotDefined));

               return this.category;
            }

            set {
               this.category = value;
               this.filter.Category = true;
            }
        }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.ClearAll"]/*' />
        /// <devdoc>
        ///    Resets all the current instance settings.
        /// </devdoc>
        public void ClearAll() {
            this.filter.ClearAll();
        }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.ConvertTime"]/*' />
        ///    <internalonly/>
        private int ConvertTime(DateTime time) {
            time = time.ToUniversalTime();            
            return (int)(time - MessageQueueCriteria.minDate).TotalSeconds;
        }

        /// <include file='doc\MessageQueueCriteria.uex' path='docs/doc[@for="MessageQueueCriteria.CriteriaPropertyFilter"]/*' />
        ///    <internalonly/>
        private class CriteriaPropertyFilter{
            public bool CreatedAfter;
            public bool CreatedBefore;
            public bool Label;
            public bool MachineName;
            public bool ModifiedAfter;
            public bool ModifiedBefore;
            public bool Category;

            public void ClearAll() {
                this.CreatedAfter = false;
                this.CreatedBefore = false;
                this.Label = false;
                this.MachineName = false;
                this.ModifiedAfter = false;
                this.ModifiedBefore = false;
                this.Category = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagepriority.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessagePriority.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;

    /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority"]/*' />
    /// <devdoc>
    ///    Message priority effects how MSMQ handles the message while it is in route, 
    ///    as well as where the message is placed in the queue. Higher priority messages 
    ///    are given preference during routing, and inserted toward the front of the queue. 
    ///    Messages with the same priority are placed in the queue according to their arrival 
    ///    time.
    /// </devdoc>
    public enum MessagePriority {
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.Lowest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Lowest = 0,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.VeryLow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VeryLow = 1,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.Low"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Low = 2,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.Normal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Normal = 3,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.AboveNormal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AboveNormal = 4,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.High"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        High = 5,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.VeryHigh"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VeryHigh = 6,
        /// <include file='doc\MessagePriority.uex' path='docs/doc[@for="MessagePriority.Highest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Highest = 7,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeueaccessrights.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueAccessRights.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MessageQueueAccessRights.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Text;
using System.Messaging.Interop;

namespace System.Messaging {
    
    /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum MessageQueueAccessRights {
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.DeleteMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeleteMessage          = 0x00000001,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.PeekMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PeekMessage            = 0x00000002,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.WriteMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WriteMessage           = 0x00000004,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.DeleteJournalMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeleteJournalMessage   = 0x00000008,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.SetQueueProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetQueueProperties     = 0x00000010,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.GetQueueProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GetQueueProperties     = 0x00000020,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.DeleteQueue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeleteQueue            = 0x00010000,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.GetQueuePermissions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GetQueuePermissions    = 0x00020000,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.ChangeQueuePermissions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ChangeQueuePermissions = 0x00040000,
        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.TakeQueueOwnership"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TakeQueueOwnership     = 0x00080000,

        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.ReceiveMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ReceiveMessage         = DeleteMessage | PeekMessage,

        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.ReceiveJournalMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ReceiveJournalMessage  = DeleteJournalMessage | PeekMessage,

        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.GenericRead"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GenericRead            = GetQueueProperties | GetQueuePermissions | ReceiveMessage | ReceiveJournalMessage,

        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.GenericWrite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GenericWrite           = GetQueueProperties | GetQueuePermissions | WriteMessage,

        /// <include file='doc\MessageQueueAccessRights.uex' path='docs/doc[@for="MessageQueueAccessRights.FullControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FullControl            = DeleteMessage | PeekMessage | WriteMessage | DeleteJournalMessage |
                                 SetQueueProperties | GetQueueProperties | DeleteQueue | GetQueuePermissions |
                                 ChangeQueuePermissions | TakeQueueOwnership, 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeueenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueEnumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTPTRCAST = System.IntPtr;                    
                    
namespace System.Messaging {    
    using System.Runtime.InteropServices;    
    using System.Diagnostics;
    using System;    
    using System.Collections;    
    using System.Messaging.Interop;
    using System.Globalization;
    
    /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator"]/*' />
    /// <devdoc>
    ///    <para>Provides (forward-only) cursor semantics to enumerate the queues on a 
    ///       computer.</para>
    ///    <note type="rnotes">
    ///       I'm assuming all the queues have to
    ///       be
    ///       on the same computer. Is this the case? Do we want to translate this reference
    ///       to "cursor semantics" into English, or is it okay as it stands? Will the users
    ///       understand the concept of a cursor?
    ///    </note>
    /// </devdoc>
    public class MessageQueueEnumerator : MarshalByRefObject, IEnumerator, IDisposable {
        private MessageQueueCriteria criteria;
        private IntPtr locatorHandle;
        private MessageQueue currentMessageQueue;        
        private bool checkSecurity;
        private bool disposed;

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.MessageQueueEnumerator"]/*' />
        ///    <internalonly/>
        internal MessageQueueEnumerator(MessageQueueCriteria criteria) {
            this.criteria = criteria;            
            this.checkSecurity = true;
        }
        
        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.MessageQueueEnumerator1"]/*' />
        ///    <internalonly/>
        internal MessageQueueEnumerator(MessageQueueCriteria criteria, bool checkSecurity) {
            this.criteria = criteria;            
            this.checkSecurity = checkSecurity;
        }        

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.Current"]/*' />
        /// <devdoc>
        ///     Returns the current MessageQueue of the  enumeration. 
        ///     Before the first call to MoveNext and following a call to MoveNext that 
        ///     returned false an InvalidOperationException will be thrown. Multiple 
        ///     calls to Current with no intervening calls to MoveNext will return the 
        ///     same MessageQueue object.
        /// </devdoc>        
        public MessageQueue Current {
            get {
                if (this.currentMessageQueue == null)
                    throw new InvalidOperationException(Res.GetString(Res.NoCurrentMessageQueue));
                    
                return this.currentMessageQueue;
            }
        }
        
        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.IEnumerator.Current"]/*' />
        /// <internalonly/>
        object IEnumerator.Current {
            get {
                return this.Current;
            }   
        }

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.Close"]/*' />
        /// <devdoc>
        ///    <para>Frees the resources associated with the enumerator.</para>
        /// </devdoc>
        public void Close() {
            if (this.locatorHandle != (IntPtr)0) {
                SafeNativeMethods.MQLocateEnd(this.locatorHandle);
                this.locatorHandle = (IntPtr)0;
                this.currentMessageQueue = null;                
            }
        }         
         
        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Dispose() {                        
            Dispose(true);
            GC.SuppressFinalize(this);                           
        }

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.Dispose1"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            this.Close();                        
            this.disposed = true;
        }

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.Finalize"]/*' />
        /// <devdoc>
        /// </devdoc>
        ~MessageQueueEnumerator() {
            Dispose(false);
        }

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.LocatorHandle"]/*' />
        /// <devdoc>
        ///    <para>Indicates the native Message Queuing handle used to locate queues in a network. This
        ///       property is read-only.</para>
        /// </devdoc>
        public IntPtr LocatorHandle {
            get {
                if (this.locatorHandle == (IntPtr)0) {
                    //Cannot allocate the locatorHandle if the object has been disposed, since finalization has been suppressed.
                    if (this.disposed)
                        throw new ObjectDisposedException(GetType().Name);
                    
                    if (this.checkSecurity) {
                        MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, MessageQueuePermission.Any);
                        permission.Demand();
                    }                        
                    
                    Columns columns = new Columns(2);
                    IntPtr enumHandle;
                    columns.AddColumnId(NativeMethods.QUEUE_PROPID_PATHNAME);
                    //Adding the instance property avoids accessing the DS a second
                    //time, the formatName can be resolved by calling MQInstanceToFormatName
                    columns.AddColumnId(NativeMethods.QUEUE_PROPID_INSTANCE);
                    int status;
                    if (this.criteria != null)
                        status = UnsafeNativeMethods.MQLocateBegin(null, this.criteria.Reference, columns.GetColumnsRef(), null, out enumHandle);
                    else
                        status = UnsafeNativeMethods.MQLocateBegin(null, null, columns.GetColumnsRef(), null, out enumHandle);

                    if (MessageQueue.IsFatalError(status))
                        throw new MessageQueueException(status);

                    this.locatorHandle = enumHandle;
                }

                return this.locatorHandle;
            }
        }

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Advances the enumerator to the next queue of the enumeration, if one
        ///       is currently available.</para>
        /// </devdoc>
        public bool MoveNext() {
            int[] array = new int[8];
            int propertyCount;
            string currentItem;
            byte[] currentGuid = new byte[16];
            string machineName = null;

            if (this.criteria != null  && this.criteria.FilterMachine) {
                if (this.criteria.MachineName.CompareTo(".") == 0)
                    machineName = MessageQueue.ComputerName + "\\";
                else                    
                    machineName = this.criteria.MachineName + "\\";
            }                

            do {
                propertyCount = 2;
                int status;
                status = SafeNativeMethods.MQLocateNext(this.LocatorHandle, ref propertyCount, array);
                if (MessageQueue.IsFatalError(status))
                    throw new MessageQueueException(status);

                if (propertyCount != 2) {
                    this.currentMessageQueue = null;
                    return false;
                }

                //Using Unicode API even on Win9x
                currentItem = Marshal.PtrToStringUni((INTPTR_INTPTRCAST)array[2]);
                Marshal.Copy((INTPTR_INTPTRCAST)array[6], currentGuid, 0, 16);
                //MSMQ allocated this memory, lets free it.
                SafeNativeMethods.MQFreeMemory((INTPTR_INTPTRCAST)array[2]);
                SafeNativeMethods.MQFreeMemory((INTPTR_INTPTRCAST)array[6]);
            }
            while (machineName != null && (machineName.Length >= currentItem.Length ||
                                           String.Compare(machineName, 0, currentItem, 0, machineName.Length, true, CultureInfo.InvariantCulture) != 0));

            this.currentMessageQueue = new MessageQueue(currentItem, new Guid(currentGuid));
            return true;
        }        

        /// <include file='doc\MessageQueueEnumerator.uex' path='docs/doc[@for="MessageQueueEnumerator.Reset"]/*' />
        /// <devdoc>
        ///    <para>Resets the cursor, so it points to the head of the list..</para>
        /// </devdoc>
        public void Reset() {
            this.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeueexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Text;
    using System.Messaging.Interop;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Globalization;

    /// <include file='doc\MessageQueueException.uex' path='docs/doc[@for="MessageQueueException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Is thrown if a Microsoft Message
    ///       Queue Server (MSMQ) internal error occurs.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public class MessageQueueException : ExternalException, ISerializable {
        
        private readonly int nativeErrorCode;
        
        /// <include file='doc\MessageQueueException.uex' path='docs/doc[@for="MessageQueueException.MessageQueueException"]/*' />
        ///<internalonly/>        
        internal MessageQueueException(int error) {
            nativeErrorCode = error;
        }
        
        /// <include file='doc\MessageQueueException.uex' path='docs/doc[@for="MessageQueueException.MessageQueueException"]/*' />
        /// <internalonly/>
        protected MessageQueueException(SerializationInfo info, StreamingContext context) : base (info, context) {
            nativeErrorCode = info.GetInt32("NativeErrorCode");
        }
                
        /// <include file='doc\MessageQueueException.uex' path='docs/doc[@for="MessageQueueException.MessageQueueErrorCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueueErrorCode MessageQueueErrorCode {
            get {
                return (MessageQueueErrorCode)nativeErrorCode;
            }
        }
       
        /// <include file='doc\MessageQueueException.uex' path='docs/doc[@for="MessageQueueException.Message"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string Message {
            get {
                try {
                    return Res.GetString(Convert.ToString(nativeErrorCode, 16).ToUpper(CultureInfo.InvariantCulture)); 
                }
                catch (Exception) {
                    return GetUnknownErrorMessage(nativeErrorCode);
                }                    
            }
        }
        
        private static string GetUnknownErrorMessage(int error) {
            //get the system error message...
            string errorMsg = "";

            StringBuilder sb = new StringBuilder(256);
            int result = SafeNativeMethods.FormatMessage(SafeNativeMethods.FORMAT_MESSAGE_IGNORE_INSERTS |
                                       SafeNativeMethods.FORMAT_MESSAGE_FROM_SYSTEM |
                                       SafeNativeMethods.FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       0, error, 0, sb, sb.Capacity + 1, 0);
            if (result != 0) {
                int i = sb.Length;
                while (i > 0) {
                    char ch = sb[i - 1];
                    if (ch > 32 && ch != '.') break;
                    i--;
                }
                errorMsg = sb.ToString(0, i);
            }
            else {
                errorMsg =Res.GetString("UnknownError", Convert.ToString(error, 16));
            }

            return errorMsg;
        }

        /// <include file='doc\MessageQueueException.uex' path='docs/doc[@for="MessageQueueException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue("NativeErrorCode", nativeErrorCode);
            base.GetObjectData(info, context);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeueerrorcode.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueErrorCode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum MessageQueueErrorCode {                             
        
        /// <internalonly/>
        Base = unchecked((int)0xC00E0000),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.Generic"]/*' />
        /// <devdoc>
        ///     GenericError.
        /// </devdoc>
        Generic = unchecked((int)0xC00E0001),
        /// <internalonly/>
        Property = unchecked((int)0xC00E0002),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.QueueNotFound"]/*' />
        /// <devdoc>
        ///     The queue is not registered in the DS.
        /// </devdoc>
        QueueNotFound = unchecked((int)0xC00E0003),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.QueueExists"]/*' />
        /// <devdoc>
        ///     A queue with the same pathname is already registered.
        /// </devdoc>
        QueueExists = unchecked((int)0xC00E0005),
        /// <internalonly/>
        InvalidParameter = unchecked((int)0xC00E0006),
        /// <internalonly/>
        InvalidHandle = unchecked((int)0xC00E0007),        
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.OperationCanceled"]/*' />
        /// <devdoc>
        ///     The operation was cancelled before it could be completed.
        /// </devdoc>
        OperationCanceled = unchecked((int)0xC00E0008),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.SharingViolation"]/*' />
        /// <devdoc>
        ///     Sharing violation. The queue is already opened for
        ///     exclusive receive.
        /// </devdoc>
        SharingViolation = unchecked((int)0xC00E0009),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.ServiceNotAvailable"]/*' />
        /// <devdoc>
        ///     The Message Queues service is not available.
        /// </devdoc>
        ServiceNotAvailable = unchecked((int)0xC00E000B),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MachineNotFound"]/*' />
        /// <devdoc>
        ///     The specified machine could not be found.
        /// </devdoc>
        MachineNotFound = unchecked((int)0xC00E000D),
        /// <internalonly/>
        IllegalSort = unchecked((int)0xC00E0010),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalUser"]/*' />
        /// <devdoc>
        ///     The user is an illegal user.
        /// </devdoc>
        IllegalUser = unchecked((int)0xC00E0011),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoDs"]/*' />
        /// <devdoc>
        ///     No connection with this site's controller(s).
        /// </devdoc>
        NoDs = unchecked((int)0xC00E0013),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalQueuePathName"]/*' />
        /// <devdoc>
        ///     Illegal queue path name.
        /// </devdoc>
        IllegalQueuePathName = unchecked((int)0xC00E0014),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalPropertyValue"]/*' />
        /// <devdoc>
        ///     Illegal property value.
        /// </devdoc>
        IllegalPropertyValue = unchecked((int)0xC00E0018),        
        /// <internalonly/>
        IllegalPropertyVt = unchecked((int)0xC00E0019),
        /// <internalonly/>
        BufferOverflow = unchecked((int)0xC00E001A),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IOTimeout"]/*' />
        /// <devdoc>
        ///     The Receive or Peek Message timeout has expired.
        /// </devdoc>
        IOTimeout = unchecked((int)0xC00E001B),
        /// <internalonly/>
        IllegalCursorAction = unchecked((int)0xC00E001C),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MessageAlreadyReceived"]/*' />
        /// <devdoc>
        ///     A message that is currently pointed at by the cursor has been removed from
        ///     the queue by another process or by another call to MQReceiveMessage
        ///     without the use of this cursor.
        /// </devdoc>
        MessageAlreadyReceived = unchecked((int)0xC00E001D),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalFormatName"]/*' />
        /// <devdoc>
        ///     The given format name is invalid.
        /// </devdoc>
        IllegalFormatName = unchecked((int)0xC00E001E),
        /// <internalonly/>
        FormatNameBufferTooSmall = unchecked((int)0xC00E001F),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.UnsupportedFormatNameOperation"]/*' />
        /// <devdoc>
        ///     The requested operation for the specified format name is not
        ///     supported (e.g., delete a direct queue format name).
        /// </devdoc>
        UnsupportedFormatNameOperation = unchecked((int)0xC00E0020),
        /// <internalonly/>
        IllegalSecurityDescriptor = unchecked((int)0xC00E0021),
        /// <internalonly/>
        SenderIdBufferTooSmall = unchecked((int)0xC00E0022),
        /// <internalonly/>
        SecurityDescriptorBufferTooSmall = unchecked((int)0xC00E0023),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotImpersonateClient"]/*' />
        /// <devdoc>
        ///     The RPC server can not impersonate the client application, hence security
        ///     credentials could not be verified.
        /// </devdoc>
        CannotImpersonateClient = unchecked((int)0xC00E0024),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.AccessDenied"]/*' />
        /// <devdoc>
        ///     Access is denied.
        /// </devdoc>
        AccessDenied = unchecked((int)0xC00E0025),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.PrivilegeNotHeld"]/*' />
        /// <devdoc>
        ///     Client does not have the required privileges to perform the operation.
        /// </devdoc>
        PrivilegeNotHeld = unchecked((int)0xC00E0026),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.InsufficientResources"]/*' />
        /// <devdoc>
        ///     Insufficient resources to perform operation.
        /// </devdoc>
        InsufficientResources = unchecked((int)0xC00E0027),
        /// <internalonly/>
        UserBufferTooSmall = unchecked((int)0xC00E0028),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MessageStorageFailed"]/*' />
        /// <devdoc>
        ///     Could not store a recoverable or journal message. Message was not sent.
        /// </devdoc>
        MessageStorageFailed = unchecked((int)0xC00E002A),
        /// <internalonly/>
        SenderCertificateBufferTooSmall = unchecked((int)0xC00E002B),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.InvalidCertificate"]/*' />
        /// <devdoc>
        ///     The user certificate is not valid.
        /// </devdoc>
        InvalidCertificate = unchecked((int)0xC00E002C),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CorruptedInternalCertificate"]/*' />
        /// <devdoc>
        ///     The internal MSMQ certificate is corrupted.
        /// </devdoc>
        CorruptedInternalCertificate = unchecked((int)0xC00E002D),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoInternalUserCertificate"]/*' />
        /// <devdoc>
        ///     The internal MSMQ certificate for the user does not exist.
        /// </devdoc>
        NoInternalUserCertificate = unchecked((int)0xC00E002F),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CorruptedSecurityData"]/*' />
        /// <devdoc>
        ///     A cryptogrphic function has failed.
        /// </devdoc>
        CorruptedSecurityData = unchecked((int)0xC00E0030),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CorruptedPersonalCertStore"]/*' />
        /// <devdoc>
        ///     The personal certificate store is corrupted.
        /// </devdoc>
        CorruptedPersonalCertStore = unchecked((int)0xC00E0031),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.ComputerDoesNotSupportEncryption"]/*' />
        /// <devdoc>
        ///     The computer does not support encryption operations.
        /// </devdoc>
        ComputerDoesNotSupportEncryption = unchecked((int)0xC00E0033),
        /// <internalonly/>
        BadSecurityContext = unchecked((int)0xC00E0035),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CouldNotGetUserSid"]/*' />
        /// <devdoc>
        ///     Could not get the SID information out of the thread token.
        /// </devdoc>
        CouldNotGetUserSid = unchecked((int)0xC00E0036),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CouldNotGetAccountInfo"]/*' />
        /// <devdoc>
        ///     Could not get the account information for the user.
        /// </devdoc>        
        CouldNotGetAccountInfo = unchecked((int)0xC00E0037),
        /// <internalonly/>
        IllegalCriteriaColumns = unchecked((int)0xC00E0038),
        /// <internalonly/>
        IllegalPropertyId = unchecked((int)0xC00E0039),
        /// <internalonly/>
        IllegalRelation = unchecked((int)0xC00E003A),
        /// <internalonly/>
        IllegalPropertySize = unchecked((int)0xC00E003B),
        /// <internalonly/>
        IllegalRestrictionPropertyId = unchecked((int)0xC00E003C),        
        /// <internalonly/>
        IllegalQueueProperties = unchecked((int)0xC00E003D),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.PropertyNotAllowed"]/*' />
        /// <devdoc>
        ///     Invalid property for the requested operation.
        /// </devdoc>
        PropertyNotAllowed = unchecked((int)0xC00E003E),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.InsufficientProperties"]/*' />
        /// <devdoc>
        ///     Not all the required properties for the operation were specified
        ///     in the input parameters.
        /// </devdoc>
        InsufficientProperties = unchecked((int)0xC00E003F),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MachineExists"]/*' />
        /// <devdoc>
        ///     Computer with the same name already exists in the site.
        /// </devdoc>
        MachineExists = unchecked((int)0xC00E0040),
        /// <internalonly/>
        IllegalMessageProperties = unchecked((int)0xC00E0041),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.DsIsFull"]/*' />
        /// <devdoc>
        ///     DS is full.
        /// </devdoc>
        DsIsFull = unchecked((int)0xC00E0042),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.DsError"]/*' />
        /// <devdoc>
        ///     internal DS error.
        /// </devdoc>
        DsError = unchecked((int)0xC00E0043),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.InvalidOwner"]/*' />
        /// <devdoc>
        ///     Invalid object owner. For example CreateQueue failed because the Queue Manager
        ///     object is invalid.
        /// </devdoc>
        InvalidOwner = unchecked((int)0xC00E0044),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.UnsupportedAccessMode"]/*' />
        /// <devdoc>
        ///     The specified access mode is not supported.
        /// </devdoc>
        UnsupportedAccessMode = unchecked((int)0xC00E0045),
        /// <internalonly/>
        ResultBufferTooSmall = unchecked((int)0xC00E0046),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.DeleteConnectedNetworkInUse"]/*' />
        /// <devdoc>
        ///     The Connected Network can not be deleted, it is in use.
        /// </devdoc>
        DeleteConnectedNetworkInUse = unchecked((int)0xC00E0048),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoResponseFromObjectServer"]/*' />
        /// <devdoc>
        ///     No response from object owner.
        /// </devdoc>
        NoResponseFromObjectServer = unchecked((int)0xC00E0049),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.ObjectServerNotAvailable"]/*' />
        /// <devdoc>
        ///     Object owner is not reachable.
        /// </devdoc>
        ObjectServerNotAvailable = unchecked((int)0xC00E004A),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.QueueNotAvailable"]/*' />
        /// <devdoc>
        ///     Error while reading from a queue residing on a remote computer.
        /// </devdoc>
        QueueNotAvailable = unchecked((int)0xC00E004B),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.DtcConnect"]/*' />
        /// <devdoc>
        ///     Cannot connect to MS DTC.
        /// </devdoc>
        DtcConnect = unchecked((int)0xC00E004C),        
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.TransactionImport"]/*' />
        /// <devdoc>
        ///     Cannot import the transaction.
        /// </devdoc>
        TransactionImport = unchecked((int)0xC00E004E),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.TransactionUsage"]/*' />
        /// <devdoc>
        ///     Wrong transaction usage.
        /// </devdoc>
        TransactionUsage = unchecked((int)0xC00E0050),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.TransactionSequence"]/*' />
        /// <devdoc>
        ///     Wrong transaction operations sequence.
        /// </devdoc>
        TransactionSequence = unchecked((int)0xC00E0051),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MissingConnectorType"]/*' />
        /// <devdoc>
        ///     Connector Type is mandatory when sending Acknowledgment or secure message.
        /// </devdoc>
        MissingConnectorType = unchecked((int)0xC00E0055),
        /// <internalonly/>
        StaleHandle = unchecked((int)0xC00E0056),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.TransactionEnlist"]/*' />
        /// <devdoc>
        ///     Cannot enlist the transaction.
        /// </devdoc>
        TransactionEnlist = unchecked((int)0xC00E0058),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.QueueDeleted"]/*' />
        /// <devdoc>
        ///     The queue was deleted. Messages can not be received anymore using this
        ///     queue instance. The queue should be closed.
        /// </devdoc>
        QueueDeleted = unchecked((int)0xC00E005A),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalContext"]/*' />
        /// <devdoc>
        ///     Invalid context parameter.
        /// </devdoc>
        IllegalContext = unchecked((int)0xC00E005B),
        /// <internalonly/>
        IllegalSortPropertyId = unchecked((int)0xC00E005C),
        /// <internalonly/>
        LabelBufferTooSmall = unchecked((int)0xC00E005E),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MqisServerEmpty"]/*' />
        /// <devdoc>
        ///     The list of MQIS servers (in registry) is empty.
        /// </devdoc>
        MqisServerEmpty = unchecked((int)0xC00E005F),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.MqisReadOnlyMode"]/*' />
        /// <devdoc>
        ///     MQIS database is in read-only mode.
        /// </devdoc>
        MqisReadOnlyMode = unchecked((int)0xC00E0060),
        /// <internalonly/>
        SymmetricKeyBufferTooSmall = unchecked((int)0xC00E0061),
        /// <internalonly/>
        SignatureBufferTooSmall = unchecked((int)0xC00E0062),
        /// <internalonly/>
        ProviderNameBufferTooSmall = unchecked((int)0xC00E0063),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalOperation"]/*' />
        /// <devdoc>
        ///     The operation is illegal on foreign message queuing system.
        /// </devdoc>
        IllegalOperation  = unchecked((int)0xC00E0064),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.WriteNotAllowed"]/*' />
        /// <devdoc>
        ///     Another MQIS server is being installed, write operations to the
        ///     database are not allowed at this stage.
        /// </devdoc>
        WriteNotAllowed  = unchecked((int)0xC00E0065),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.WksCantServeClient"]/*' />
        /// <devdoc>
        ///     MSMQ independent clients cannot serve MSMQ dependent clients.
        /// </devdoc>
        WksCantServeClient  = unchecked((int)0xC00E0066),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.DependentClientLicenseOverflow"]/*' />
        /// <devdoc>
        ///     The number of dependent clients served by this MSMQ server reached
        ///     its upper limit.
        /// </devdoc>
        DependentClientLicenseOverflow = unchecked((int)0xC00E0067),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CorruptedQueueWasDeleted"]/*' />
        /// <devdoc>
        ///     Ini file for queue in LQS was deleted because it was corrupted.
        /// </devdoc>
        CorruptedQueueWasDeleted  = unchecked((int)0xC00E0068),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.RemoteMachineNotAvailable"]/*' />
        /// <devdoc>
        ///     The remote machine is not available.
        /// </devdoc>
        RemoteMachineNotAvailable  = unchecked((int)0xC00E0069),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.UnsupportedOperation"]/*' />
        /// <devdoc>
        ///  The operation is not supported for a WORKGROUP installation computer.
        /// </devdoc>
        UnsupportedOperation  = unchecked((int)0xC00E006A),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.EncryptionProviderNotSupported"]/*' />
        /// <devdoc>
        ///  The Cryptographic Service Provider  is not supported by Message Queuing.
        /// </devdoc>
        EncryptionProviderNotSupported  = unchecked((int)0xC00E006B),        
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotSetCryptographicSecurityDescriptor"]/*' />
        /// <devdoc>
        ///  Unable to set the security descriptor for the cryptographic keys.
        /// </devdoc>
        CannotSetCryptographicSecurityDescriptor  = unchecked((int)0xC00E006C),                                                                                                 
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CertificateNotProvided"]/*' />
        /// <devdoc>
        ///  A user attempted  to send an authenticated message without a certificate.
        /// </devdoc>
        CertificateNotProvided  = unchecked((int)0xC00E006D),
        /// <internalonly/>
        QDnsPropertyNotSupported  = unchecked((int)0xC00E006E),                                                                                                                                                                                                                                                                
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotCreateCertificateStore"]/*' />
        /// <devdoc>
        ///  Unable to create a certificate store for the internal certificate.
        /// </devdoc>
        CannotCreateCertificateStore  = unchecked((int)0xC00E006F),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotOpenCertificateStore"]/*' />
        /// <devdoc>
        ///  Unable to  open the certificates store for the internal certificate.
        /// </devdoc>
        CannotOpenCertificateStore  = unchecked((int)0xC00E0070),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.IllegalEnterpriseOperation"]/*' />
        /// <devdoc>
        ///  The operation is invalid for a msmqServices object.
        /// </devdoc>
        IllegalEnterpriseOperation  = unchecked((int)0xC00E0071),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotGrantAddGuid"]/*' />
        /// <devdoc>
        ///  Failed to grant the "Add Guid" permission to current user.
        /// </devdoc>
        CannotGrantAddGuid  = unchecked((int)0xC00E0072),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotLoadMsmqOcm"]/*' />
        /// <devdoc>
        ///  Can't load the MSMQOCM.DLL library.
        /// </devdoc>
        CannotLoadMsmqOcm  = unchecked((int)0xC00E0073),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoEntryPointMsmqOcm"]/*' />
        /// <devdoc>
        ///  Cannot locate an entry point in the MSMQOCM.DLL library.
        /// </devdoc>
        NoEntryPointMsmqOcm  = unchecked((int)0xC00E0074),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoMsmqServersOnDc"]/*' />
        /// <devdoc>
        ///  Failed to find Message Queuing servers on domain controllers.
        /// </devdoc>
        NoMsmqServersOnDc  = unchecked((int)0xC00E0075),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotJoinDomain"]/*' />
        /// <devdoc>
        ///  Failed to join MSMQ enterprise on Windows 2000 domain.
        /// </devdoc>
        CannotJoinDomain  = unchecked((int)0xC00E0076),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotCreateOnGlobalCatalog"]/*' />
        /// <devdoc>
        ///  Failed to create an object on a specified Global Catalog server.
        /// </devdoc>
        CannotCreateOnGlobalCatalog  = unchecked((int)0xC00E0077),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.GuidNotMatching"]/*' />
        /// <devdoc>
        ///  Failed to create msmqConfiguration object with GUID that match machine installation. You must uninstall MSMQ and then reinstall it.
        /// </devdoc>
        GuidNotMatching  = unchecked((int)0xC00E0078),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.PublicKeyNotFound"]/*' />
        /// <devdoc>
        ///  Unable to find the public key for computer.
        /// </devdoc>
        PublicKeyNotFound  = unchecked((int)0xC00E0079),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.PublicKeyDoesNotExist"]/*' />
        /// <devdoc>
        ///  The public key for the computer does not exist.
        /// </devdoc>
        PublicKeyDoesNotExist  = unchecked((int)0xC00E007A),
        /// <internalonly/>
        IllegalPrivateProperties  = unchecked((int)0xC00E007B),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoGlobalCatalogInDomain"]/*' />
        /// <devdoc>
        ///  Unable to find Global Catalog servers in the specified domain.
        /// </devdoc>
        NoGlobalCatalogInDomain  = unchecked((int)0xC00E007C),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.NoMsmqServersOnGlobalCatalog"]/*' />
        /// <devdoc>
        ///  Failed to find Message Queuing servers on Global Catalog domain controllers.
        /// </devdoc>
        NoMsmqServersOnGlobalCatalog  = unchecked((int)0xC00E007D),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotGetDistinguishedName"]/*' />
        /// <devdoc>
        ///  Failed to retrieve the distinguished name of local computer.
        /// </devdoc>
        CannotGetDistinguishedName  = unchecked((int)0xC00E007E),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotHashDataEx"]/*' />
        /// <devdoc>
        ///  Unable to hash data for an authenticated message.
        /// </devdoc>
        CannotHashDataEx  = unchecked((int)0xC00E007F),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotSignDataEx"]/*' />
        /// <devdoc>
        ///  Unable to sign data before sending an authenticated message.
        /// </devdoc>
        CannotSignDataEx  = unchecked((int)0xC00E0080),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.CannotCreateHashEx"]/*' />
        /// <devdoc>
        ///  Unable to create hash object for an authenticated message.
        /// </devdoc>
        CannotCreateHashEx  = unchecked((int)0xC00E0081),
        /// <include file='doc\MessageQueueErrorCode.uex' path='docs/doc[@for="MessageQueueErrorCode.FailVerifySignatureEx"]/*' />
        /// <devdoc>
        ///  Signature of recieved message is not valid.
        /// </devdoc>
        FailVerifySignatureEx  = unchecked((int)0xC00E0082),        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\message.cs ===
//------------------------------------------------------------------------------
// <copyright file="Message.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using INTPTR_INTPTRCAST = System.IntPtr;
using INTPTR_INTCAST = System.Int32;

namespace System.Messaging {
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Globalization;
    using System.Messaging.Interop;    
    using System.IO;
    using System.Security.Permissions;
    using Microsoft.Win32;

    /// <include file='doc\Message.uex' path='docs/doc[@for="Message"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides access to the properties needed to define a
    ///       Message Queuing message.
    ///    </para>
    /// </devdoc>
    [
    Designer("System.Messaging.Design.MessageDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class Message : Component {
        private const int GenericIdSize = 16;
        private const int MessageIdSize = 20;
        private const int DefaultQueueNameSize = 255;
        private const int DefaultCryptographicProviderNameSize = 255;
        private const int DefaultDigitalSignatureSize = 255;
        private const int DefaultSenderCertificateSize = 255;
        private const int DefaultSenderIdSize = 255;
        private const int DefaultSymmetricKeySize = 255;                        
        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.InfiniteTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that there is no timeout.
        ///    </para>
        /// </devdoc>
        public static readonly TimeSpan InfiniteTimeout = TimeSpan.FromSeconds(UInt32.MaxValue);

        private MessagePropertyFilter filter;        
        private string machineName;
        private bool receiveCreated;
        private object cachedBodyObject;
        private Stream cachedBodyStream;
        private IMessageFormatter cachedFormatter;        
        private MessageQueue cachedResponseQueue;
        private MessageQueue cachedTransactionStatusQueue;
        private MessageQueue cachedAdminQueue;        
        private MessageQueue cachedDestinationQueue;
        internal MessagePropertyVariants properties;        

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Message"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.Message'/> class with an empty body.
        ///    </para>
        /// </devdoc>
        public Message() {
            properties = new MessagePropertyVariants();
            receiveCreated = false;
            this.filter = new MessagePropertyFilter();

            //Always add Id
            properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_MSGID, new byte[MessageIdSize]);
            this.filter.Id = true;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Message1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.Message'/>
        ///       class, serializing the object passed as
        ///       an argument.
        ///    </para>
        /// </devdoc>
        public Message(object body)
        : this() {
            this.Body = body;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Message2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message(object body, IMessageFormatter formatter)
        : this() {
            this.Formatter = formatter;
            this.Body = body;
        }         

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Message3"]/*' />
        /// <internalonly/>                
        internal Message(MessagePropertyFilter filter) {
            properties = new MessagePropertyVariants();
            receiveCreated = true;
            this.filter = filter;                        
            if (filter.data1 != 0) {
                int data = filter.data1;
                
                if (0 != (data & MessagePropertyFilter.ACKNOWLEDGEMENT))
                    properties.SetUI2(NativeMethods.MESSAGE_PROPID_CLASS, (short)0);
                if (0 != (data & MessagePropertyFilter.ACKNOWLEDGE_TYPE))                
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_ACKNOWLEDGE, (byte)0);
                if (0 != (data & MessagePropertyFilter.ADMIN_QUEUE)) {
                    properties.SetString(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE, new byte[DefaultQueueNameSize * 2]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN,  DefaultQueueNameSize);
                }
                if (0 != (data & MessagePropertyFilter.BODY)) {
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY, new byte[filter.bodySize]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE, filter.bodySize);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_TYPE, 0);
                }
                if (0 != (data & MessagePropertyFilter.LABEL)) {
                    properties.SetString(NativeMethods.MESSAGE_PROPID_LABEL, new byte[filter.labelSize * 2]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_LABEL_LEN, filter.labelSize);
                }
                if (0 != (data & MessagePropertyFilter.ID))
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_MSGID, new byte[MessageIdSize]);
                if (0 != (data & MessagePropertyFilter.USE_DEADLETTER_QUEUE))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)0);
                if (0 != (data & MessagePropertyFilter.RESPONSE_QUEUE)) {
                    properties.SetString(NativeMethods.MESSAGE_PROPID_RESP_QUEUE, new byte[DefaultQueueNameSize * 2]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN, DefaultQueueNameSize);
                }
                //Acknowledgment and MessageType are overloaded in MQ.
                if ((0 == (data & MessagePropertyFilter.ACKNOWLEDGEMENT)) && (0 != (data & MessagePropertyFilter.MESSAGE_TYPE)))
                    properties.SetUI2(NativeMethods.MESSAGE_PROPID_CLASS, (short)0);                
                //Journaling and Deadletter are overloaded in MSMQ
                if ((0 == (data & MessagePropertyFilter.USE_DEADLETTER_QUEUE)) && (0 != (data & MessagePropertyFilter.USE_JOURNALING)))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)0);                                        
            }                    
                        
            if (filter.data2 != 0) {
                int data = filter.data2;
                if (0 != (data & MessagePropertyFilter.APP_SPECIFIC))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_APPSPECIFIC, 0);
                if (0 != (data & MessagePropertyFilter.ARRIVED_TIME))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_ARRIVEDTIME, 0);
                if (0 != (data & MessagePropertyFilter.ATTACH_SENDER_ID))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_TYPE, 0);
                if (0 != (data & MessagePropertyFilter.AUTHENTICATED))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_AUTHENTICATED, (byte)0);
                
                if (0 != (data & MessagePropertyFilter.CONNECTOR_TYPE))
                    properties.SetGuid(NativeMethods.MESSAGE_PROPID_CONNECTOR_TYPE, new byte[GenericIdSize]);
                if (0 != (data & MessagePropertyFilter.CORRELATION_ID))
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_CORRELATIONID,  new byte[MessageIdSize]);
                if (0 != (data & MessagePropertyFilter.CRYPTOGRAPHIC_PROVIDER_NAME)) {
                    properties.SetString(NativeMethods.MESSAGE_PROPID_PROV_NAME, new byte[DefaultCryptographicProviderNameSize * 2]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_PROV_NAME_LEN, DefaultCryptographicProviderNameSize);
                }
                if (0 != (data & MessagePropertyFilter.CRYPTOGRAPHIC_PROVIDER_TYPE))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_PROV_TYPE, 0);
                if (0 != (data & MessagePropertyFilter.IS_RECOVERABLE))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_DELIVERY, (byte)0);
                if (0 != (data & MessagePropertyFilter.DESTINATION_QUEUE)) {
                    properties.SetString(NativeMethods.MESSAGE_PROPID_DEST_QUEUE, new byte[DefaultQueueNameSize * 2]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_DEST_QUEUE_LEN, DefaultQueueNameSize);
                }
                if (0 != (data & MessagePropertyFilter.DIGITAL_SIGNATURE)) {
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SIGNATURE, new byte[DefaultDigitalSignatureSize]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SIGNATURE_LEN, DefaultDigitalSignatureSize);
                }
                if (0 != (data & MessagePropertyFilter.ENCRYPTION_ALGORITHM))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_ENCRYPTION_ALG, 0);
                if (0 != (data & MessagePropertyFilter.EXTENSION)) {
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_EXTENSION, new byte[filter.extensionSize]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_EXTENSION_LEN, filter.extensionSize);
                }
                if (0 != (data & MessagePropertyFilter.FOREIGN_ADMIN_QUEUE)) {
                    properties.SetString(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE, new byte[DefaultQueueNameSize * 2]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN, DefaultQueueNameSize);
                }
                if (0 != (data & MessagePropertyFilter.HASH_ALGORITHM))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_HASH_ALG, 0);                
                if (0 != (data & MessagePropertyFilter.IS_FIRST_IN_TRANSACTION))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_FIRST_IN_XACT, (byte)0);
                if (0 != (data & MessagePropertyFilter.IS_LAST_IN_TRANSACTION))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_LAST_IN_XACT, (byte)0);                                                
                if (0 != (data & MessagePropertyFilter.PRIORITY))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_PRIORITY, (byte)0);                            
                if (0 != (data & MessagePropertyFilter.SENDER_CERTIFICATE)) {
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDER_CERT, new byte[DefaultSenderCertificateSize]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENDER_CERT_LEN, DefaultSenderCertificateSize);
                }
                if (0 != (data & MessagePropertyFilter.SENDER_ID)) {
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDERID, new byte[DefaultSenderIdSize]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_LEN, DefaultSenderIdSize);
                }
                if (0 != (data & MessagePropertyFilter.SENT_TIME))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENTTIME, 0);
                if (0 != (data & MessagePropertyFilter.SOURCE_MACHINE))
                    properties.SetGuid(NativeMethods.MESSAGE_PROPID_SRC_MACHINE_ID, new byte[GenericIdSize]);
                if (0 != (data & MessagePropertyFilter.SYMMETRIC_KEY)) {
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY, new byte[DefaultSymmetricKeySize]);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN,  DefaultSymmetricKeySize);
                }
                if (0 != (data & MessagePropertyFilter.TIME_TO_BE_RECEIVED))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_TIME_TO_BE_RECEIVED, 0);
                if (0 != (data & MessagePropertyFilter.TIME_TO_REACH_QUEUE))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_TIME_TO_REACH_QUEUE, 0);
                if (0 != (data & MessagePropertyFilter.TRANSACTION_ID))
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_XACTID,  new byte[MessageIdSize]);
                if (0 != (data & MessagePropertyFilter.USE_AUTHENTICATION))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_AUTH_LEVEL, 0);            
                if (0 != (data & MessagePropertyFilter.USE_ENCRYPTION))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_PRIV_LEVEL, 0);                
                if (0 != (data & MessagePropertyFilter.USE_TRACING))
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_TRACE, (byte)0);
                if (0 != (data & MessagePropertyFilter.VERSION))
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_VERSION, 0);
            }                    
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Acknowledgment"]/*' />
        /// <devdoc>
        ///    <para>Gets the classification
        ///       of acknowledgment messages that Message Queuing posts.</para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAcknowledgement)]
        public Acknowledgment Acknowledgment{
            get{
                if (!this.filter.Acknowledgment) {
                    //This message cannot be an acknowledgment, because it has not been sent.
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.NotAcknowledgement));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Acknowledgment"));
                }

                //Casting unsigned short to int, mask off sign extension.
                int res = ((int)properties.GetUI2(NativeMethods.MESSAGE_PROPID_CLASS)) & 0x0000FFFF;                
                return(Acknowledgment)res;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AcknowledgeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of acknowledgment
        ///       message requested
        ///       from
        ///       Message Queuing when a message arrives in the queue.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAcknowledgeType)]
        public AcknowledgeTypes AcknowledgeType{
            get{
                if (!this.filter.AcknowledgeType) {
                    //Return the default.
                    if (!receiveCreated)
                        return AcknowledgeTypes.None;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "AcknowledgeType"));
                }

                return(AcknowledgeTypes)this.properties.GetUI1(NativeMethods.MESSAGE_PROPID_ACKNOWLEDGE);
            }

            set{                
                //If default
                if (value == AcknowledgeTypes.None) {
                    this.filter.AcknowledgeType = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_ACKNOWLEDGE);                    
                }
                else {                    
                    this.filter.AcknowledgeType = true;
                    this.properties.SetUI1(NativeMethods.MESSAGE_PROPID_ACKNOWLEDGE, (byte)value);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AdministrationQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the queue used for acknowledgment
        ///       messages.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAdministrationQueue)]
        public MessageQueue AdministrationQueue{
            get{
                if (!this.filter.AdministrationQueue) {
                    //This property has not been set, lets return an undefined value.
                    if (!receiveCreated)
                        return null;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "AdministrationQueue"));
                }

                if (this.cachedAdminQueue == null) {
                    if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN) != 0) {
                        string queueFormatName = StringFromBytes(properties.GetString(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE),
                                                                 properties.GetUI4(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN));

                        this.cachedAdminQueue = new MessageQueue("FORMATNAME:" + queueFormatName);                                                                                 
                    }
                }
                                    
                return this.cachedAdminQueue;
            }

            set{                
                if (value != null) 
                    this.filter.AdministrationQueue = true;
                else {
                    //If default
                    if (this.filter.AdministrationQueue) {
                        this.filter.AdministrationQueue = false;
                        properties.Remove(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE);
                        properties.Remove(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN);
                    }
                }
                
                this.cachedAdminQueue = value;                
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AppSpecific"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       application-generated information regarding the message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAppSpecific)]
        public int AppSpecific{
            get{
                if (!this.filter.AppSpecific) {
                    //Return the default.
                    if (!receiveCreated)
                        return 0;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "AppSpecific"));
                }

                return properties.GetUI4(NativeMethods.MESSAGE_PROPID_APPSPECIFIC);
            }

            set{
                //If default
                if (value == 0) {                    
                    this.filter.AppSpecific = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_APPSPECIFIC);                    
                }
                else {                    
                    this.filter.AppSpecific = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_APPSPECIFIC, value);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.ArrivedTime"]/*' />
        /// <devdoc>
        ///    Indicates when the message arrived at the queue.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgArrivedTime)]
        public DateTime ArrivedTime{
            get {
                if (!this.filter.ArrivedTime) {
                    //Undefined at this point, throw an exception.
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.ArrivedTimeNotSet));
            
                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "ArrivedTime"));
                }

                //Number of seconds ellapsed since 1/1/1970
                DateTime time = new DateTime(1970 , 1, 1);
                time = time.AddSeconds(properties.GetUI4(NativeMethods.MESSAGE_PROPID_ARRIVEDTIME)).ToLocalTime();
                return time;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AttachSenderId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the sender ID is to be attached
        ///       to the message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAttachSenderId)]
        public bool AttachSenderId{
            get{
                if (!this.filter.AttachSenderId) {
                    //SenderId is attached by default.
                    if (!receiveCreated)
                        return true;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "AttachSenderId"));
                }

                int type = properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_TYPE);
                if (type == NativeMethods.MESSAGE_SENDERID_TYPE_NONE)
                    return false;

                return true;
            }

            set{
                //If default.
                if (value) {                    
                    this.filter.AttachSenderId = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_SENDERID_TYPE);                    
                }
                else {                    
                    this.filter.AttachSenderId = true;
                    if (value)
                        properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_TYPE, NativeMethods.MESSAGE_SENDERID_TYPE_SID);
                    else
                        properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_TYPE, NativeMethods.MESSAGE_SENDERID_TYPE_NONE);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Authenticated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the message was
        ///       authenticated.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAuthenticated)]
        public bool Authenticated{
            get{
                if (!this.filter.Authenticated) {
                    //Authentication is undefined, there is nothing to return here.
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.AuthenticationNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Authenticated"));
                }

                return(properties.GetUI1(NativeMethods.MESSAGE_PROPID_AUTHENTICATED) != 0);
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AuthenticationProviderName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the cryptographic
        ///       provider used to generate the digital signature of the message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAuthenticationProviderName)]
        public string AuthenticationProviderName{
            get {
                if (!this.filter.AuthenticationProviderName) {
                    //Return default
                    if (!receiveCreated)
                        return "Microsoft Base Cryptographic Provider, Ver. 1.0";

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "AuthenticationProviderName"));
                }

                if (this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_PROV_NAME_LEN) != 0)
                    return StringFromBytes(this.properties.GetString(NativeMethods.MESSAGE_PROPID_PROV_NAME),
                                           properties.GetUI4(NativeMethods.MESSAGE_PROPID_PROV_NAME_LEN));
                else
                    return "";
            }

            set{
                if (value == null)
                    throw new ArgumentNullException("value");

                //Should not remove if default, the default value might change in future MQ clients
                //if (value.CompareTo("Microsoft Base Cryptographic Provider, Ver. 1.0") == 0) {                    
                //    this.filter.AuthenticationProviderName = false;
                //    properties.Remove(NativeMethods.MESSAGE_PROPID_PROV_NAME);
                //    properties.Remove(NativeMethods.MESSAGE_PROPID_PROV_NAME_LEN);                    
                //}
                //else {
                    this.filter.AuthenticationProviderName = true;
                    properties.SetString(NativeMethods.MESSAGE_PROPID_PROV_NAME, StringToBytes(value));
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_PROV_NAME_LEN, value.Length);
                //}
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AuthenticationProviderType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of cryptographic provider used to
        ///       generate the digital signature of the
        ///       message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgAuthenticationProviderType)]
        public CryptographicProviderType AuthenticationProviderType{
            get {
                //Return default
                if (!this.filter.AuthenticationProviderType) {
                    if (!receiveCreated)
                        return CryptographicProviderType.RsaFull;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "AuthenticationProviderType"));
                }

                return(CryptographicProviderType)properties.GetUI4(NativeMethods.MESSAGE_PROPID_PROV_TYPE);
            }

            set{                
                if (!Enum.IsDefined(typeof(CryptographicProviderType), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(CryptographicProviderType));
            
                //Should not remove if default, the default value might change in future MQ clients
                //if (value == CryptographicProviderType.RsaFull) {                    
                //    this.filter.AuthenticationProviderType = false;
                //    properties.Remove(NativeMethods.MESSAGE_PROPID_PROV_TYPE);                    
                //}
                //else {                    
                    this.filter.AuthenticationProviderType = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_PROV_TYPE, (int)value);
                //}
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Body"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the serialized
        ///       contents of the message.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public object Body {
            get{
                if (!this.filter.Body) {
                    if (!receiveCreated)             
                        return null;                                            

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Body"));
                }

                if (this.cachedBodyObject == null) {
                    if (this.Formatter == null)
                        throw new InvalidOperationException(Res.GetString(Res.FormatterMissing));
        
                    this.cachedBodyObject = this.Formatter.Read(this);                                                               
                }
                
                return this.cachedBodyObject;                
            }

            set{
                this.filter.Body = true;                          
                this.cachedBodyObject = value;    
            }                        
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.BodyStream"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the information in the body of
        ///       the message.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        Editor("System.ComponentModel.Design.BinaryEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),
        MessagingDescription(Res.MsgBodyStream)
        ] 
        public Stream BodyStream {
            get{
                if (!this.filter.Body) {
                    if (!receiveCreated) {
                        this.filter.Body = true;
                        if (this.cachedBodyStream == null)
                            this.cachedBodyStream = new MemoryStream();
                            
                        return this.cachedBodyStream;
                    }                        

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Body"));
                }

                if (this.cachedBodyStream == null)
                    this.cachedBodyStream = new MemoryStream(properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY),
                                                                                                0, properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE));
                                                       
                return this.cachedBodyStream;
            }

            set{
                if (value != null)  
                    this.filter.Body = true;                                    
                else {
                    this.filter.Body = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_BODY);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_BODY_TYPE);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_BODY_SIZE);
                }
                
                this.cachedBodyStream = value;    
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.BodyType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the type of data the message body contains.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgBodyType)]
        public int BodyType{
            get{
                if (!this.filter.Body) {
                    //Return default.
                    if (!receiveCreated)
                        return 0;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Body"));
                }

                return this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_TYPE);
            }

            set{
                properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_TYPE, value);
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.ConnectorType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Is required whenever an application sets a message property that is
        ///       typically set by MSMQ. It is typically used in the following two cases.
        ///       Whenever a message is passed by a connector application, the connector
        ///       type is required so that the sending and receiving applications know how
        ///       to interpret the security and acknowledgment properties of the messages.
        ///       When sending application-encrypted messages, this property tells the
        ///       MSMQ run time to use the symmetric key.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgConnectorType)]
        public Guid ConnectorType{
            get{
                if (!this.filter.ConnectorType) {
                    //Return default.
                    if (!receiveCreated)
                        return Guid.Empty;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "ConnectorType"));
                }

                return new Guid(this.properties.GetGuid(NativeMethods.MESSAGE_PROPID_CONNECTOR_TYPE));
            }

            set{
                //If default
                if (value.Equals(Guid.Empty)) {                    
                    this.filter.ConnectorType = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_CONNECTOR_TYPE);                    
                }
                else {                    
                    this.filter.ConnectorType = true;
                    properties.SetGuid(NativeMethods.MESSAGE_PROPID_CONNECTOR_TYPE, ((Guid)value).ToByteArray());
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.CorrelationId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the message identifier used by
        ///       acknowledgment and report messages to reference the original
        ///       message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgCorrelationId)]
        public string CorrelationId{
            get {
                if (!this.filter.CorrelationId) {
                    //Return default
                    if (!receiveCreated)
                        return String.Empty;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "CorrelationId"));
                }

                return IdFromByteArray(this.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_CORRELATIONID));
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                //If default
                if (value.Length == 0) {
                    this.filter.CorrelationId = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_CORRELATIONID);                    
                }
                else {                    
                    this.filter.CorrelationId = true;
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_CORRELATIONID, IdToByteArray(value));
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.DefaultBodySize"]/*' />
        /// <devdoc>
        ///    The default body  buffer size to create,  
        ///    when the message is received.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        private int DefaultBodySize {
            get {
                return this.filter.DefaultBodySize;
            }            
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.DefaultExtensionSize"]/*' />
        /// <devdoc>
        ///    The default extension  buffer size to create,  
        ///    when the message is received.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        private int DefaultExtensionSize {
            get {
                return this.filter.DefaultExtensionSize;
            }            
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.DefaultLabelSize"]/*' />
        /// <devdoc>
        ///    The default label  buffer size to create,  
        ///    when the message is received.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        private int DefaultLabelSize {
            get {
                return this.filter.DefaultLabelSize;
            }            
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.DestinationQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Identifies the original destination queue for a message. It is typically
        ///       used to determine the original destination of a message that is in a journal
        ///       or dead-letter queue, however it can also be used when sending a
        ///       response message back to a response queue.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgDestinationQueue)]
        public MessageQueue DestinationQueue{
            get {
                if (!this.filter.DestinationQueue) {
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.DestinationQueueNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "DestinationQueue"));
                }

                if (this.cachedDestinationQueue == null) {                            
                    if (this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_QUEUE_LEN) !=0) {
                        string queueFormatName = StringFromBytes(properties.GetString(NativeMethods.MESSAGE_PROPID_DEST_QUEUE),
                                                                 properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_QUEUE_LEN));
                        this.cachedDestinationQueue = new MessageQueue("FORMATNAME:" + queueFormatName);
                    }
                }

                return this.cachedDestinationQueue;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.DestinationSymmetricKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the symmetric key used to encrypt messages.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        MessagingDescription(Res.MsgDestinationSymmetricKey)
        ]
        public byte[] DestinationSymmetricKey{
            get{
                if (!this.filter.DestinationSymmetricKey) {
                    if (!receiveCreated)
                        return new byte[0];

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "DestinationSymmetricKey"));
                }

                byte[] bytes = new byte[properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN)];
                Array.Copy(properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY), bytes, bytes.Length);
                return bytes;
            }

            set{
                if (value == null)
                    throw new ArgumentNullException("value");

                //If default
                if (value.Length == 0) {                    
                    this.filter.DestinationSymmetricKey = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN);                    
                }
                else {                    
                    this.filter.DestinationSymmetricKey = true;
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY, value);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN, value.Length);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.DigitalSignature"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the digital signature used to authenticate
        ///       the message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgDigitalSignature)]
        public byte[] DigitalSignature{
            get{
                if (!this.filter.DigitalSignature) {
                    if (!receiveCreated)
                        return new byte[0];

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "DigitalSignature"));
                }

                byte[] bytes = new byte[properties.GetUI4(NativeMethods.MESSAGE_PROPID_SIGNATURE_LEN)];
                Array.Copy(properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_SIGNATURE), bytes, bytes.Length);
                return bytes;
            }

            set{
                if (value == null)
                    throw new ArgumentNullException("value");
                
                if (value.Length == 0) {                    
                    this.filter.DigitalSignature = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_SIGNATURE);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_SIGNATURE_LEN);                    
                }
                else {                    
                    this.filter.DigitalSignature = true;
                    this.filter.UseAuthentication = true;
                                        
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SIGNATURE, value);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SIGNATURE_LEN, value.Length);
                }                    
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.EncryptionAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the encryption algorithm used to encrypt the
        ///       body of a private message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgEncryptionAlgorithm)]
        public EncryptionAlgorithm EncryptionAlgorithm{
            get {
                if (!this.filter.EncryptionAlgorithm) {
                    //Return default.
                    if (!receiveCreated)
                        return EncryptionAlgorithm.Rc2;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "EncryptionAlgorithm"));
                }

                return(EncryptionAlgorithm)properties.GetUI4(NativeMethods.MESSAGE_PROPID_ENCRYPTION_ALG);
            }
            set{
                if (!Enum.IsDefined(typeof(EncryptionAlgorithm), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(EncryptionAlgorithm));
            
                //Should not remove if default, the default value might change in future MQ clients
                //if (value == EncryptionAlgorithm.Rc2) {                
                //    this.filter.EncryptionAlgorithm = false;
                //    properties.Remove(NativeMethods.MESSAGE_PROPID_ENCRYPTION_ALG);                    
                //}
                //else {                    
                    this.filter.EncryptionAlgorithm = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_ENCRYPTION_ALG, (int)value);
                //}
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Extension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       additional information associated with the message.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        MessagingDescription(Res.MsgExtension)
        ]
        public byte[] Extension{
            get{
                if (!this.filter.Extension) {
                    //Return default.
                    if (!receiveCreated)
                        return new byte[0];

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Extension"));
                }

                byte[] bytes = new byte[properties.GetUI4(NativeMethods.MESSAGE_PROPID_EXTENSION_LEN)];
                Array.Copy(properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_EXTENSION), bytes, bytes.Length);
                return bytes;
            }

            set{
                if (value == null)
                    throw new ArgumentNullException("value");

                //If default
                if (value.Length == 0) {                    
                    this.filter.Extension = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_EXTENSION);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_EXTENSION_LEN);                    
                }
                else {                    
                    this.filter.Extension = true;
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_EXTENSION,  value);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_EXTENSION_LEN, value.Length);
                }
            }
        }        
        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Formatter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the formatter used to read or write an object into the message
        ///       body.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]        
        public IMessageFormatter Formatter {
            get {                
                return this.cachedFormatter;
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                this.cachedFormatter = value;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.HashAlgorithm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the hashing
        ///       algorithm used when authenticating messages.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgHashAlgorithm)]
        public HashAlgorithm HashAlgorithm{
            get {
                if (!this.filter.HashAlgorithm) {
                    //This property has not been set, lets return an empty queue.
                    if (!receiveCreated)
                        return HashAlgorithm.Md5;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "HashAlgorithm"));
                }

                return(HashAlgorithm)properties.GetUI4(NativeMethods.MESSAGE_PROPID_HASH_ALG);
            }

            set {       
                if (!Enum.IsDefined(typeof(HashAlgorithm), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(HashAlgorithm));
                                  
                //Should not remove if default since MQ3.0 changed the default algorithm
                //if (value == HashAlgorithm.Md5) {                    
                //    this.filter.HashAlgorithm = false;
                //    properties.Remove(NativeMethods.MESSAGE_PROPID_HASH_ALG);                    
                //}
                //else {                    
                    this.filter.HashAlgorithm = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_HASH_ALG, (int)value);
                //}
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Id"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the Message Queuing-generated identifier of the message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgId)]
        public string Id {
            get {
                if (!this.filter.Id) {
                    //The Id is undefined at this point
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.IdNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Id"));
                }

                return IdFromByteArray(this.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_MSGID));
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.IsFirstInTransaction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating
        ///       whether the message was the first message sent in a transaction.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgIsFirstInTransaction)]
        public bool IsFirstInTransaction {
            get {
                if (!this.filter.IsFirstInTransaction) {
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "IsFirstInTransaction"));
                }

                return(properties.GetUI1(NativeMethods.MESSAGE_PROPID_FIRST_IN_XACT) != 0);
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.IsLastInTransaction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the message was
        ///       the last message sent in a transaction.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgIsLastInTransaction)]
        public bool IsLastInTransaction {
            get {
                if (!this.filter.IsLastInTransaction) {
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "IsLastInTransaction"));
                }

                return(properties.GetUI1(NativeMethods.MESSAGE_PROPID_LAST_IN_XACT) != 0);
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Label"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the message label.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgLabel)]
        public string Label{
            get {
                if (!this.filter.Label) {
                    //Return default
                    if (!receiveCreated)
                        return String.Empty;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Label"));
                }

                if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_LABEL_LEN) != 0)
                    return StringFromBytes(this.properties.GetString(NativeMethods.MESSAGE_PROPID_LABEL),
                                           properties.GetUI4(NativeMethods.MESSAGE_PROPID_LABEL_LEN));
                else
                    return "";
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                //If default
                if (value.Length == 0) {                    
                    this.filter.Label = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_LABEL);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_LABEL_LEN);                    
                }
                else {                    
                    this.filter.Label = true;
                    properties.SetString(NativeMethods.MESSAGE_PROPID_LABEL, StringToBytes(value));
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_LABEL_LEN, value.Length);
                }
            }
        }        

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.MessageType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of the message (normal, acknowledgment, or report).
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgMessageType)]
        public MessageType MessageType {
            get {
                if (!this.filter.MessageType) {
                    //Return default
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.MessageTypeNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "MessageType"));
                }

                int cls = properties.GetUI2(NativeMethods.MESSAGE_PROPID_CLASS);
                if (cls == NativeMethods.MESSAGE_CLASS_NORMAL)
                    return MessageType.Normal;

                if (cls == NativeMethods.MESSAGE_CLASS_REPORT)
                    return MessageType.Report;

                return MessageType.Acknowledgment;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Priority"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the message priority, used to determine
        ///       where the
        ///       message is placed in the
        ///       queue.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgPriority)]
        public MessagePriority Priority {
            get {
                if (!this.filter.Priority) {
                    //Return default
                    if (!receiveCreated)
                        return MessagePriority.Normal;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Priority"));
                }

                return(MessagePriority)properties.GetUI1(NativeMethods.MESSAGE_PROPID_PRIORITY);
            }

            set {
                if (!Enum.IsDefined(typeof(MessagePriority), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(MessagePriority));
            
                //If default
                if (value == MessagePriority.Normal) {                    
                    this.filter.Priority = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_PRIORITY);                    
                }
                else {                    
                    this.filter.Priority = true;
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_PRIORITY, (byte)value);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Recoverable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the message is guaranteed to be delivered in the event of
        ///       a computer failure or network problem.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgRecoverable)]
        public bool Recoverable {
            get {
                if (!this.filter.Recoverable) {
                    //Return default
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "Recoverable"));
                }

                return properties.GetUI1(NativeMethods.MESSAGE_PROPID_DELIVERY) ==  NativeMethods.MESSAGE_DELIVERY_RECOVERABLE;
            }

            set{
                //If default
                if (!value) {
                    this.filter.Recoverable = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_DELIVERY);                    
                }
                else {                    
                    this.filter.Recoverable = true;
                    properties.SetUI1(NativeMethods.MESSAGE_PROPID_DELIVERY, (byte)NativeMethods.MESSAGE_DELIVERY_RECOVERABLE);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.ResponseQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the queue which receives application-generated
        ///       response messages.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgResponseQueue)]
        public MessageQueue ResponseQueue {
            get {
                if (!this.filter.ResponseQueue) {
                    //This property has not been set, lets return an undefined value.
                    if (!receiveCreated)
                        return null;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "ResponseQueue"));
                }

                if (this.cachedResponseQueue == null) {                    
                    if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN) != 0) {
                        string queueFormatName = StringFromBytes(properties.GetString(NativeMethods.MESSAGE_PROPID_RESP_QUEUE),
                                                                 properties.GetUI4(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN));
                                                                    
                        this.cachedResponseQueue = new MessageQueue("FORMATNAME:" + queueFormatName);
                    }
                }
                                    
                return this.cachedResponseQueue;
            }

            set{
                //If default
                if (value != null)  
                    this.filter.ResponseQueue = true;                                   
                else {
                    if (this.filter.ResponseQueue) {
                        this.filter.ResponseQueue = false;
                        properties.Remove(NativeMethods.MESSAGE_PROPID_RESP_QUEUE);
                        properties.Remove(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN);
                    }
                }
                
                this.cachedResponseQueue = value;                
            }
        }

        //Consider, V2, jruiz- This property was removed, apparently no meaningful
        //scenarios could be addressed.
        //public int SecurityContext{
        //    get{
        //        if (!this.filter.SecurityContext) {
        //            //Return default
        //             if (!receiveCreated)
        //                    return 0;
        //
        //              throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "SecurityContext"));
        //        }
        //
        //      return properties.GetUI4(NativeMethods.MESSAGE_PROPID_SECURITY_CONTEXT);
        //  }
        //
        //  set{
        //      //If default
        //      if (value == 0) {
        //          if (this.filter.SecurityContext) {
        //              this.filter.SecurityContext = false;
        //              properties.Remove(NativeMethods.MESSAGE_PROPID_SECURITY_CONTEXT);
        //          }
        //      }
        //      else {
        //          if (!this.filter.SecurityContext)
        //              this.filter.SecurityContext = true;
        //
        //          properties.SetUI4(NativeMethods.MESSAGE_PROPID_SECURITY_CONTEXT, value);
        //      }
        //  }
        //

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.SenderCertificate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the security certificate used to authenticate messages.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgSenderCertificate)]
        public byte[] SenderCertificate {
            get {
                if (!this.filter.SenderCertificate) {
                    //Return default
                    if (!receiveCreated)
                        return new byte[0];

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "SenderCertificate"));
                }

                byte[] bytes = new byte[properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENDER_CERT_LEN)];
                Array.Copy(properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDER_CERT), bytes, bytes.Length);
                return bytes;
            }

            set{
                if (value == null)
                    throw new ArgumentNullException("value");

                //If default
                if (value.Length == 0) {                    
                    this.filter.SenderCertificate = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_SENDER_CERT);
                    properties.Remove(NativeMethods.MESSAGE_PROPID_SENDER_CERT_LEN);                    
                }
                else {                    
                    this.filter.SenderCertificate = true;
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDER_CERT, value);
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_SENDER_CERT_LEN, value.Length);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.SenderId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       This property is set by MSMQ, and is used primarily by the
        ///       receiving Queue Manager when authenticating a message. The receiving
        ///       Queue Manager uses the sender identifier in this property to verify where
        ///       the message originated and to verify the sender has access rights to a queue.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgSenderId)]
        public byte[] SenderId {
            get {
                if (!this.filter.SenderId) {
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.SenderIdNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "SenderId"));
                }

                byte[] bytes = new byte[properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_LEN)];
                Array.Copy(properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDERID), bytes, bytes.Length);
                return bytes;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.SenderVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the version of Message Queuing used to send the message.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgSenderVersion)]
        public long SenderVersion {
            get {
                if (!this.filter.SenderVersion) {
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.VersionNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "SenderVersion"));
                }

                return(long)((uint)properties.GetUI4(NativeMethods.MESSAGE_PROPID_VERSION));
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.SentTime"]/*' />
        /// <devdoc>
        ///    Indicates the date and time that the message was sent by
        ///    the source Queue Manager.
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgSentTime)]
        public DateTime SentTime {
            get {
                if (!this.filter.SentTime) {
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.SentTimeNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "SentTime"));
                }

                //Number of seconds ellapsed since 1/1/1970
                DateTime time = new DateTime(1970 , 1, 1);
                time = time.AddSeconds(properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENTTIME)).ToLocalTime();
                return time;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.SourceMachine"]/*' />
        /// <devdoc>
        ///    Specifies the computer where the message originated.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgSourceMachine)]
        public string SourceMachine {
            get {
                if (!this.filter.SourceMachine) {
                    if (!receiveCreated)
                        throw new InvalidOperationException(Res.GetString(Res.SourceMachineNotSet));

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "SourceMachine"));
                }

                if (this.machineName == null) {
                    byte[] bytes = this.properties.GetGuid(NativeMethods.MESSAGE_PROPID_SRC_MACHINE_ID);
                    GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);

                    MachinePropertyVariants machineProperties = new MachinePropertyVariants();
                    machineProperties.SetNull(NativeMethods.MACHINE_PATHNAME);
                    int status = UnsafeNativeMethods.MQGetMachineProperties(null, (INTPTR_INTPTRCAST)handle.AddrOfPinnedObject(), machineProperties.Lock());
                    machineProperties.Unlock();
                    handle.Free();

                    IntPtr memoryHandle = (INTPTR_INTPTRCAST)machineProperties.GetUI4(NativeMethods.MACHINE_PATHNAME);
                    if (memoryHandle != (IntPtr)0) {
                        //Using Unicode API even on Win9x
                        this.machineName = Marshal.PtrToStringUni(memoryHandle);
                        SafeNativeMethods.MQFreeMemory(memoryHandle);
                    }

                    if (MessageQueue.IsFatalError(status))
                        throw new MessageQueueException(status);
                }

                return this.machineName;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.TimeToBeReceived"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the time limit for the message to be retrieved from the target
        ///       queue.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        TypeConverter(typeof(System.Messaging.Design.TimeoutConverter)), 
        MessagingDescription(Res.MsgTimeToBeReceived)
        ]
        public TimeSpan TimeToBeReceived {
            get {
                if (!this.filter.TimeToBeReceived) {
                    //Return default
                    if (!receiveCreated)
                        return InfiniteTimeout;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "TimeToBeReceived"));
                }

                return TimeSpan.FromSeconds((uint)properties.GetUI4(NativeMethods.MESSAGE_PROPID_TIME_TO_BE_RECEIVED));
            }

            set {                
                long timeoutInSeconds = (long)value.TotalSeconds;
                if (timeoutInSeconds < 0)
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "TimeToBeReceived", value.ToString()));

                if (timeoutInSeconds > UInt32.MaxValue)
                    timeoutInSeconds = UInt32.MaxValue;

                //If default
                if (timeoutInSeconds == UInt32.MaxValue) {                    
                    this.filter.TimeToBeReceived = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_TIME_TO_BE_RECEIVED);                    
                }
                else {
                    this.filter.TimeToBeReceived = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_TIME_TO_BE_RECEIVED, (int)((uint)timeoutInSeconds));
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.TimeToReachQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the time limit for the message to reach
        ///       the queue.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        TypeConverter(typeof(System.Messaging.Design.TimeoutConverter)), 
        MessagingDescription(Res.MsgTimeToReachQueue)
        ]
        public TimeSpan TimeToReachQueue {
            get {
                if (!this.filter.TimeToReachQueue) {
                    //Return default
                    if (!receiveCreated)
                        return InfiniteTimeout;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "TimeToReachQueue"));
                }

                return TimeSpan.FromSeconds((uint)properties.GetUI4(NativeMethods.MESSAGE_PROPID_TIME_TO_REACH_QUEUE));
            }

            set {                
                long timeoutInSeconds = (long)value.TotalSeconds;
                if (timeoutInSeconds < 0)
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "TimeToReachQueue", value.ToString()));

                if (timeoutInSeconds > UInt32.MaxValue)
                    timeoutInSeconds = UInt32.MaxValue;

                if (timeoutInSeconds == UInt32.MaxValue) {
                    this.filter.TimeToReachQueue = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_TIME_TO_REACH_QUEUE);                    
                }
                else {                    
                    this.filter.TimeToReachQueue = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_TIME_TO_REACH_QUEUE, (int)((uint)timeoutInSeconds));
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.TransactionId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       identifier for the transaction of which the message was a part.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgTransactionId)]
        public string TransactionId {
            get {
                if (!this.filter.TransactionId) {
                    //Return default
                    if (!receiveCreated)
                        return String.Empty;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "TransactionId"));
                }

                return IdFromByteArray(this.properties.GetUI1Vector(NativeMethods.MESSAGE_PROPID_XACTID));
            }
        }            

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.TransactionStatusQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       transaction status queue on the source computer.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgTransactionStatusQueue)]
        public MessageQueue TransactionStatusQueue {
            get {
                if (!this.filter.TransactionStatusQueue) {
                    //This property has not been set, lets return an undefined value.
                    if (!receiveCreated)
                        return null;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "TransactionStatusQueue"));
                }

                if (this.cachedTransactionStatusQueue == null) {                
                    if (this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN) != 0) {
                        string queueFormatName = StringFromBytes(properties.GetString(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE),
                                                                 properties.GetUI4(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN));
                                                                      
                        this.cachedTransactionStatusQueue = new MessageQueue("FORMATNAME:" + queueFormatName);
                    }
                }
                                    
                return this.cachedTransactionStatusQueue;
            }

            set{
                //If default
                if (value != null) 
                    this.filter.TransactionStatusQueue = true;
                else {                    
                    if (this.filter.TransactionStatusQueue) {
                        this.filter.TransactionStatusQueue = false;
                        properties.Remove(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE);
                        properties.Remove(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN);
                    }
                }
                
                this.cachedTransactionStatusQueue = value;                
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.UseAuthentication"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating whether a message must be authenticated.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgUseAuthentication)]
        public bool UseAuthentication {
            get {
                if (!this.filter.UseAuthentication) {
                    //Return default
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "UseAuthentication"));
                }

                return(properties.GetUI4(NativeMethods.MESSAGE_PROPID_AUTH_LEVEL) != NativeMethods.MESSAGE_AUTHENTICATION_LEVEL_NONE);
            }

            set{
                //If default
                if (!value) {                    
                    this.filter.UseAuthentication = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_AUTH_LEVEL);                    
                }
                else {                    
                    this.filter.UseAuthentication = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_AUTH_LEVEL, NativeMethods.MESSAGE_AUTHENTICATION_LEVEL_ALWAYS);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.UseDeadLetterQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether
        ///       a copy of an undeliverable message should be sent to a dead-letter queue.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgUseDeadLetterQueue)]
        public bool UseDeadLetterQueue {
            get {
                if (!this.filter.UseDeadLetterQueue) {
                    //Return default
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "UseDeadLetterQueue"));
                }

                return((properties.GetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL) & NativeMethods.MESSAGE_JOURNAL_DEADLETTER) != 0);
            }

            set {
                //If Default
                if (!value) {
                    if (this.filter.UseDeadLetterQueue) {
                        this.filter.UseDeadLetterQueue = false;
                        if (!this.filter.UseJournalQueue)
                            properties.Remove(NativeMethods.MESSAGE_PROPID_JOURNAL);
                        else
                            properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)(properties.GetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL)  & ~NativeMethods.MESSAGE_JOURNAL_DEADLETTER));
                    }
                }
                else {
                    if (!this.filter.UseDeadLetterQueue && !this.filter.UseJournalQueue)
                        properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)NativeMethods.MESSAGE_JOURNAL_DEADLETTER);
                    else
                        properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)(properties.GetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL)  | NativeMethods.MESSAGE_JOURNAL_DEADLETTER));

                    this.filter.UseDeadLetterQueue = true;
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.UseEncryption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether to encrypt messages.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgUseEncryption)]
        public bool UseEncryption {
            get {
                if (!this.filter.UseEncryption) {
                    //Return default
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "UseEncryption"));
                }

                return(properties.GetUI4(NativeMethods.MESSAGE_PROPID_PRIV_LEVEL) != NativeMethods.MESSAGE_PRIVACY_LEVEL_NONE);
            }

            set{
                //If default
                if (!value) {                    
                    this.filter.UseEncryption = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_PRIV_LEVEL);                    
                }
                else {                    
                    this.filter.UseEncryption = true;
                    properties.SetUI4(NativeMethods.MESSAGE_PROPID_PRIV_LEVEL, NativeMethods.MESSAGE_PRIVACY_LEVEL_BODY);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.UseJournalQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a copy of the message should be kept in a machine
        ///       journal on the originating computer.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgUseJournalQueue)]
        public bool UseJournalQueue {
            get {
                if (!this.filter.UseJournalQueue) {
                    //Return default
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "UseJournalQueue"));
                }

                return((properties.GetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL) & NativeMethods.MESSAGE_JOURNAL_JOURNAL) != 0);
            }

            set {
                //If Default
                if (!value) {
                    if (this.filter.UseJournalQueue) {
                        this.filter.UseJournalQueue = false;
                        if (!this.filter.UseDeadLetterQueue)
                            properties.Remove(NativeMethods.MESSAGE_PROPID_JOURNAL);
                        else
                            properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)(properties.GetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL)  & ~NativeMethods.MESSAGE_JOURNAL_JOURNAL));
                    }
                }
                else {
                    if (!this.filter.UseDeadLetterQueue && !this.filter.UseJournalQueue)
                        properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)NativeMethods.MESSAGE_JOURNAL_JOURNAL);
                    else
                        properties.SetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL, (byte)(properties.GetUI1(NativeMethods.MESSAGE_PROPID_JOURNAL)  | NativeMethods.MESSAGE_JOURNAL_JOURNAL));

                    this.filter.UseJournalQueue = true;
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.UseTracing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a value indicating whether to trace a message as
        ///       it moves toward its destination queue.
        ///    </para>
        /// </devdoc>
        [ReadOnly(true), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MsgUseTracing)]
        public bool UseTracing {
            get {
                if (!this.filter.UseTracing) {
                    //Return default
                    if (!receiveCreated)
                        return false;

                    throw new InvalidOperationException(Res.GetString(Res.MissingProperty, "UseTracing"));
                }

                return(properties.GetUI1(NativeMethods.MESSAGE_PROPID_TRACE) != NativeMethods.MESSAGE_TRACE_NONE);
            }

            set{
                //If Default
                if (!value) {
                    this.filter.UseTracing = false;
                    properties.Remove(NativeMethods.MESSAGE_PROPID_TRACE);                    
                }
                else {                    
                    this.filter.UseTracing = true;

                    if (!value)
                        properties.SetUI1(NativeMethods.MESSAGE_PROPID_TRACE, (byte)NativeMethods.MESSAGE_TRACE_NONE);
                    else
                        properties.SetUI1(NativeMethods.MESSAGE_PROPID_TRACE, (byte)NativeMethods.MESSAGE_TRACE_SEND_ROUTE_TO_REPORT_QUEUE);
                }
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AdjustMemory"]/*' />
        /// <internalonly/>        
        internal void AdjustMemory() {
            if (filter.AdministrationQueue) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN);
                if (size > Message.DefaultQueueNameSize)
                    properties.SetString(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE, new byte[size * 2]);
            }

            if (filter.Body) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE);
                if (size > DefaultBodySize)
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY, new byte[size]);
            }

            if (filter.AuthenticationProviderName) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_PROV_NAME_LEN);
                if (size > Message.DefaultCryptographicProviderNameSize)
                    properties.SetString(NativeMethods.MESSAGE_PROPID_PROV_NAME,  new byte[size * 2]);
            }

            if (filter.DestinationQueue) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_QUEUE_LEN);
                if (size > Message.DefaultQueueNameSize)
                    properties.SetString(NativeMethods.MESSAGE_PROPID_DEST_QUEUE, new byte[size * 2]);
            }

            if (filter.Extension) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_EXTENSION_LEN);
                if (size > DefaultExtensionSize)
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_EXTENSION, new byte[size]);
            }

            if (filter.TransactionStatusQueue) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN);
                if (size > Message.DefaultQueueNameSize)
                    properties.SetString(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE, new byte[size * 2]);
            }

            if (filter.Label) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_LABEL_LEN);
                if (size > DefaultLabelSize)
                    properties.SetString(NativeMethods.MESSAGE_PROPID_LABEL,  new byte[size * 2]);
            }

            if (filter.ResponseQueue) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN);
                if (size > Message.DefaultQueueNameSize)
                    properties.SetString(NativeMethods.MESSAGE_PROPID_RESP_QUEUE, new byte[size * 2]);
            }

            if (filter.SenderCertificate) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENDER_CERT_LEN);
                if (size > Message.DefaultSenderCertificateSize)
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDER_CERT, new byte[size]);
            }

            if (filter.SenderId) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENDERID_LEN);
                if (size > Message.DefaultSenderIdSize)
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_SENDERID, new byte[size]);
            }

            if (filter.DestinationSymmetricKey) {
                int size = properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN);
                if (size > Message.DefaultSymmetricKeySize)
                    properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY, new byte[size]);
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.AdjustToSend"]/*' />
        /// <internalonly/>        
        internal void AdjustToSend() {
            //Write cached properties
            string queueFormatName;
            if (this.filter.AdministrationQueue && this.cachedAdminQueue != null) {
                queueFormatName = this.cachedAdminQueue.FormatName;
                properties.SetString(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE,  StringToBytes(queueFormatName));
                properties.SetUI4(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN, queueFormatName.Length);                                
            }
            
            if (this.filter.ResponseQueue && this.cachedResponseQueue != null) {
                queueFormatName = this.cachedResponseQueue.FormatName;
                properties.SetString(NativeMethods.MESSAGE_PROPID_RESP_QUEUE,  StringToBytes(queueFormatName));
                properties.SetUI4(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN, queueFormatName.Length);
            }
            
            if (this.filter.TransactionStatusQueue && this.cachedTransactionStatusQueue != null) {
                queueFormatName = this.cachedTransactionStatusQueue.FormatName;
                properties.SetString(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE,  StringToBytes(queueFormatName));
                properties.SetUI4(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN, queueFormatName.Length);
            }
                         
            if (this.filter.Body &&  this.cachedBodyObject != null) {
                if (this.Formatter == null)
                    this.Formatter = new XmlMessageFormatter();

                this.Formatter.Write(this, this.cachedBodyObject);                                                    
            }
            
            if (this.filter.Body && this.cachedBodyStream != null) {
                this.cachedBodyStream.Position = 0;                    
                byte[] bytes = new byte[(int)this.cachedBodyStream.Length];
                this.cachedBodyStream.Read(bytes, 0, bytes.Length);
                properties.SetUI1Vector(NativeMethods.MESSAGE_PROPID_BODY, bytes);
                properties.SetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE, bytes.Length);                
            }            
        
            if (this.receiveCreated) {
                lock (this) {
                    if (this.receiveCreated) {
                        //We don't want to send the buffers as they were allocated
                        //when receiving, they might be to big.
                        //Adjust sizes
                        if (this.filter.Body) {
                            this.properties.AdjustSize(NativeMethods.MESSAGE_PROPID_BODY,
                                                       this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_BODY_SIZE));
                        }
                        if (this.filter.Extension) {
                            this.properties.AdjustSize(NativeMethods.MESSAGE_PROPID_EXTENSION,
                                                       this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_EXTENSION_LEN));
                        }
                        if (this.filter.SenderCertificate) {
                            this.properties.AdjustSize(NativeMethods.MESSAGE_PROPID_SENDER_CERT,
                                                       this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_SENDER_CERT_LEN));
                        }
                        if (this.filter.DestinationSymmetricKey) {
                            this.properties.AdjustSize(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY,
                                                       this.properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN));
                        }

                        //Ghost properties.
                        if (this.filter.Acknowledgment || this.filter.MessageType)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_CLASS);
                        if (this.filter.ArrivedTime)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_ARRIVEDTIME);
                        if (this.filter.Authenticated)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_AUTHENTICATED);
                        if (this.filter.DestinationQueue) {
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_DEST_QUEUE);
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_DEST_QUEUE_LEN);
                            this.cachedDestinationQueue = null;
                        }
                        if (this.filter.IsFirstInTransaction)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_FIRST_IN_XACT);
                        if (this.filter.IsLastInTransaction)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_LAST_IN_XACT);
                        if (this.filter.SenderId) {
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_SENDERID);
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_SENDERID_LEN);
                        }
                        if (this.filter.SentTime)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_SENTTIME);
                        if (this.filter.SourceMachine)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_SRC_MACHINE_ID);
                        if (this.filter.TransactionId)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_XACTID);
                        if (this.filter.SenderVersion)
                            this.properties.Ghost(NativeMethods.MESSAGE_PROPID_VERSION);

                        //Ghost invalid returned properties

                        if (this.filter.AdministrationQueue) {
                            if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN) == 0) {
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE);
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_ADMIN_QUEUE_LEN);
                            }
                        }
                        //Encryption algorithm cannot be set if not using Encryption
                        if (this.filter.EncryptionAlgorithm) {
                            if ((this.filter.UseEncryption && !this.UseEncryption) || !this.filter.UseEncryption)
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_ENCRYPTION_ALG);
                        }
                        if (this.filter.DigitalSignature) {
                            if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_SIGNATURE_LEN) == 0) {
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_SIGNATURE);
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_SIGNATURE_LEN);
                            }
                        }
                        if (this.filter.DestinationSymmetricKey) {
                            if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN) == 0) {
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY);
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_DEST_SYMM_KEY_LEN);
                            }
                        }
                        if (this.filter.ResponseQueue) {
                            if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN) == 0) {
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_RESP_QUEUE);
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_RESP_QUEUE_LEN);
                            }
                        }
                        if (this.filter.TransactionStatusQueue) {
                            if (properties.GetUI4(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN) == 0) {
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE);
                                this.properties.Ghost(NativeMethods.MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN);
                            }
                        }

                        this.receiveCreated = false;
                    }
                }                
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.IdFromByteArray"]/*' />
        /// <internalonly/>        
        private string IdFromByteArray(byte[] bytes) {
            StringBuilder result = new StringBuilder();
            byte[] guidBytes = new byte[GenericIdSize];
            Array.Copy(bytes, guidBytes, GenericIdSize);
            int id = BitConverter.ToInt32(bytes, GenericIdSize);
            result.Append((new Guid(guidBytes)).ToString());
            result.Append("\\");
            result.Append(id);
            return result.ToString();
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.IdToByteArray"]/*' />
        /// <internalonly/>        
        private byte[] IdToByteArray(string id) {
            string[] pieces = id.Split(new char[]{'\\'});
            if (pieces.Length != 2)
                throw new InvalidOperationException(Res.GetString(Res.InvalidId));

            Guid guid;
            try {
                guid = new Guid(pieces[0]);
            }
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.InvalidId));
            }

            int integerId;
            try {
                integerId = Convert.ToInt32(pieces[1]);
            }
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.InvalidId));
            }

            byte[] bytes = new byte[MessageIdSize];
            Array.Copy(guid.ToByteArray(), bytes, GenericIdSize);
            Array.Copy(BitConverter.GetBytes(integerId), 0, bytes, GenericIdSize, 4);
            return bytes;
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Lock"]/*' />
        /// <internalonly/>        
        internal MessagePropertyVariants.MQPROPS Lock() {
            return this.properties.Lock();            
        }        

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.StringFromBytes"]/*' />
        /// <internalonly/>        
        internal static string StringFromBytes(byte[] bytes,int len) {
            //If the string ends with 0, lets trim it.
            if (len != 0 && bytes[len * 2 -1] == 0 && bytes[len * 2 - 2] == 0)
                --len;

            char[] charBuffer = new char[len];                
            Encoding.Unicode.GetChars(bytes, 0, len * 2, charBuffer, 0);                             
            return new String(charBuffer, 0, len);                               
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.StringToBytes"]/*' />
        /// <internalonly/>        
        internal static byte[] StringToBytes(string value) {
            int size = value.Length * 2 + 1;
            byte[] byteBuffer = new byte[size];
            byteBuffer[size - 1] = 0;
            Encoding.Unicode.GetBytes(value.ToCharArray(), 0, value.Length, byteBuffer, 0);            
            return byteBuffer;
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="Message.Unlock"]/*' />
        /// <internalonly/>        
        internal void Unlock() {
            this.properties.Unlock();            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeueinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Messaging {
    using System.ComponentModel;
    using System.Diagnostics;    
    using System;
    using System.Configuration.Install;    
    using System.Collections;    
    using Microsoft.Win32;

    /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller"]/*' />
    /// <devdoc>
    ///    <para>Allows you to install and configure a queue that your 
    ///       application needs in order to run. This class is called by the installation
    ///       utility, installutil.exe, when installing a <see cref='System.Messaging.MessageQueue'/>
    ///       .</para>
    ///    <note type="rnotes">
    ///       Do we install the
    ///       backend queue resource or some MessageQueue object. I.e. is this creating a
    ///       new backend queue resource? Do we need to say anthing about checking for Path
    ///       existence?
    ///    </note>
    /// </devdoc>
    public class MessageQueueInstaller : ComponentInstaller {
        
        private bool authenticate = false; 
        private short basePriority = (short)0;
        private Guid category = Guid.Empty;
        private System.Messaging.EncryptionRequired encryptionRequired = System.Messaging.EncryptionRequired.Optional;
        private string label = String.Empty;
        private long maximumJournalSize = UInt32.MaxValue;
        private long maximumQueueSize = UInt32.MaxValue;
        private string path = String.Empty;
        private bool transactional = false;
        private bool useJournalQueue = false;
        private AccessControlList permissions = null;

        private UninstallAction uninstallAction = System.Configuration.Install.UninstallAction.Remove;

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.MessageQueueInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueueInstaller() : base() {
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.MessageQueueInstaller1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public MessageQueueInstaller(MessageQueue componentToCopy) : base() {
            CopyFromComponent(componentToCopy);
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Authenticate"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the queue to be installed only accepts authenticated messages.</para>
        /// </devdoc>
        [DefaultValue(false)]
        public bool Authenticate {
            get {
                return authenticate;
            }
            set {
                authenticate = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.BasePriority"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the base priority used
        ///       to route a public queue's messages over the network.</para>
        /// </devdoc>
        [DefaultValue(0)]
        public short BasePriority {
            get {
                return basePriority;
            }
            set {
                basePriority = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Category"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates an implementation-specific queue type.</para>
        ///    <note type="rnotes">
        ///       Wording. Shorter
        ///       ("Indicates the queue's type") better here?
        ///    </note>
        /// </devdoc>
        [TypeConverterAttribute("System.ComponentModel.GuidConverter, " + AssemblyRef.System)]
        public Guid Category {
            get {
                return category;
            }
            set {
                category = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.EncryptionRequired"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the queue only accepts private
        ///       (encrypted) messages.</para>
        /// </devdoc>
        [DefaultValue(EncryptionRequired.Optional)]
        public EncryptionRequired EncryptionRequired {
            get {
                return encryptionRequired;
            }
            set {
                if (!Enum.IsDefined(typeof(EncryptionRequired), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(EncryptionRequired));
            
                encryptionRequired = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Label"]/*' />
        /// <devdoc>
        ///    <para>Indicates a description of the queue.</para>
        /// </devdoc>
        [DefaultValue("")]
        public string Label {
            get {
                return label;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                label = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.MaximumJournalSize"]/*' />
        /// <devdoc>
        ///    <para>Indicates the maximum size of the journal associated with the queue.</para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(System.Messaging.Design.SizeConverter))
        ]
        public long MaximumJournalSize {
            get {
                return maximumJournalSize;
            }
            set {
                maximumJournalSize = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.MaximumQueueSize"]/*' />
        /// <devdoc>
        ///    <para> Indicates the the maximum size of the queue.</para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(System.Messaging.Design.SizeConverter)),
        ]
        public long MaximumQueueSize {
            get {
                return maximumQueueSize;
            }
            set {
                maximumQueueSize = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Path"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the
        ///       location of
        ///       the queue that
        ///       will
        ///       be referenced by this object. .</para>
        /// </devdoc>
        [        
        Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),
        DefaultValue(""),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string Path {
            get {
                return path;
            }
            set {
                if (!MessageQueue.ValidatePath(value, true))
                    throw new ArgumentException(Res.GetString(Res.PathSyntax));
                if (value == null)
                    throw new ArgumentNullException("value");

                this.path = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Permissions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public AccessControlList Permissions {
            get {
                return permissions;
            }
            set {
                permissions = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Transactional"]/*' />
        /// <devdoc>
        ///     If a queue is transactional, it can only accept messages that are sent as part
        ///     of a transaction. However, messages can be retrieved from a local transaction
        ///     queue with or without using a transaction.
        /// </devdoc>
        [DefaultValue(false)]
        public bool Transactional {
            get {
                return transactional;
            }
            set {
                transactional = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.UninstallAction"]/*' />
        /// <devdoc>
        ///    <para>Indicates what the installer does with the queue at uninstall time: remove it, restore it
        ///       to its pre-installation state, or leave it in its current installed state.</para>
        /// </devdoc>
        [DefaultValue(UninstallAction.Remove)]
        public UninstallAction UninstallAction {
            get {
                return uninstallAction;
            }
            set {
                if (!Enum.IsDefined(typeof(UninstallAction), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(UninstallAction));
            
                uninstallAction = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.UseJournalQueue"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether messages retrieved from the queue are also copied to the
        ///       associated journal queue.</para>
        /// </devdoc>
        [DefaultValue(false)]
        public bool UseJournalQueue {
            get {
                return useJournalQueue;
            }
            set {
                useJournalQueue = value;
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Commit"]/*' />
        /// <devdoc>
        /// <para>Completes the installation process by committing <see cref='System.Messaging.MessageQueue'/> 
        /// installation information that was written to the registry by the <see cref='System.Messaging.MessageQueueInstaller.Install'/>
        /// method. This method is meant to be used by installation tools, which
        /// process the appropriate methods automatically.</para>
        /// </devdoc>
        public override void Commit(IDictionary savedState) {
            base.Commit(savedState);

            Context.LogMessage(Res.GetString(Res.ClearingQueue, Path));

            // make sure the queue is empty
            // we don't do this in Install because it can't be undone.
            MessageQueue queue = new MessageQueue(path);            
            queue.Purge();
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.CopyFromComponent"]/*' />
        /// <devdoc>
        /// <para>Copies the property values of a <see cref='System.Messaging.MessageQueue'/> 
        /// component to this <see cref='System.Messaging.MessageQueueInstaller'/>
        /// . </para>
        /// </devdoc>
        public override void CopyFromComponent(IComponent component) {
            MessageQueue queue = component as MessageQueue;

            if (queue == null)
                throw new ArgumentException(Res.GetString(Res.NotAMessageQueue));

            if (queue.Path != null && queue.Path != string.Empty)
                Path = queue.Path;
            else
                throw new ArgumentException(Res.GetString(Res.IncompleteMQ));            
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Install"]/*' />
        /// <devdoc>
        ///    <para>Writes message queue information to the registry. This method is meant to be 
        ///       used by installation tools, which process the appropriate methods
        ///       automatically</para>
        /// </devdoc>
        public override void Install(IDictionary stateSaver) {
            base.Install(stateSaver);

            Context.LogMessage(Res.GetString(Res.CreatingQueue, Path));

            bool exists = MessageQueue.Exists(path);
            stateSaver["Exists"] = exists;
            MessageQueue queue = null;
            if (!exists)
                queue = MessageQueue.Create(Path, Transactional);
            else {
                // it exists. If it's got the right transactional property, we're OK.
                // Otherwise we have to recreate.
                queue = new MessageQueue(Path);

                // save off the properties for rollback
                stateSaver["Authenticate"] = queue.Authenticate;
                stateSaver["BasePriority"] = queue.BasePriority;
                stateSaver["Category"] = queue.Category;
                stateSaver["EncryptionRequired"] = queue.EncryptionRequired;
                stateSaver["Label"] = queue.Label;
                stateSaver["MaximumJournalSize"] = queue.MaximumJournalSize;
                stateSaver["MaximumQueueSize"] = queue.MaximumQueueSize;
                stateSaver["Path"] = queue.Path;
                stateSaver["Transactional"] = queue.Transactional;
                stateSaver["UseJournalQueue"] = queue.UseJournalQueue;

                if (queue.Transactional != Transactional) {
                    // Messages won't be kept.
                    MessageQueue.Delete(Path);
                    queue = MessageQueue.Create(Path, Transactional);
                }
            }

            // now change all the properties to how we want them.
            queue.Authenticate = Authenticate;
            queue.BasePriority = BasePriority;
            queue.Category = Category;
            queue.EncryptionRequired = EncryptionRequired;
            queue.Label = Label;
            queue.MaximumJournalSize = MaximumJournalSize;
            queue.MaximumQueueSize = MaximumQueueSize;
            queue.UseJournalQueue = UseJournalQueue;
            if (permissions != null)
                queue.SetPermissions(permissions);
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.IsEquivalentInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsEquivalentInstaller(ComponentInstaller otherInstaller) {
            MessageQueueInstaller other = otherInstaller as MessageQueueInstaller;
            if (other == null)
                return false;

            return other.Path == Path;
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.RestoreQueue"]/*' />
        /// <devdoc>
        /// Called by Rollback and Uninstall to restore a queue to its state prior to Install
        /// </devdoc>
        private void RestoreQueue(IDictionary state) {
            bool exists = false;
            if (state != null && state["Exists"] != null)
                exists = (bool) state["Exists"];
            else
                // this can only happen at uninstall - the user might have deleted the .InstallState
                // file since Install ran. It's probably best to leave things the way they are.
                return;

            if (exists) {
                Context.LogMessage(Res.GetString(Res.RestoringQueue, Path));
                // the queue existed before install. Restore the properties

                MessageQueue queue = null;

                // first, restore the queue with the right Transactional property
                if (!MessageQueue.Exists(Path)) {
                    // weird, but possible: the queue used to exist, but it doesn't now.
                    // put it back
                    queue = MessageQueue.Create(Path, (bool) state["Transactional"]);
                }
                else {
                    queue = new MessageQueue(Path);
                    if (queue.Transactional != (bool) state["Transactional"]) {
                        // the transactional property doesn't match. Recreate so it does
                        MessageQueue.Delete(Path);
                        queue = MessageQueue.Create(Path, (bool) state["Transactional"]);
                    }
                }

                // now change all the other properties to how they were.
                queue.Authenticate = (bool) state["Authenticate"];
                queue.BasePriority = (short) state["BasePriority"];
                queue.Category = (Guid) state["Category"];
                queue.EncryptionRequired = (EncryptionRequired) state["EncryptionRequired"];
                queue.Label = (string) state["Label"];
                queue.MaximumJournalSize = (long) state["MaximumJournalSize"];
                queue.MaximumQueueSize = (long) state["MaximumQueueSize"];
                queue.UseJournalQueue = (bool) state["UseJournalQueue"];
                queue.ResetPermissions();
            }
            else {
                Context.LogMessage(Res.GetString(Res.RemovingQueue, Path));
                // it wasn't there before install, so let's make sure it still isn't
                if (MessageQueue.Exists(path))
                    MessageQueue.Delete(path);
            }
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Rollback"]/*' />
        /// <devdoc>
        ///    <para> Rolls back queue information that was written to the registry 
        ///       by the installation procedure. This method is meant to be used by installation
        ///       tools, which process the appropriate methods automatically.</para>
        /// </devdoc>
        public override void Rollback(IDictionary savedState) {
            base.Rollback(savedState);

            RestoreQueue(savedState);
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.ShouldSerializeCategory"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the value of the Category property should be persisted in 
        ///       generated code.</para>
        ///    <note type="rnotes">
        ///       The similar
        ///       "ShouldSerializeServicesDependedOn" in ServiceInstaller had dev comments that
        ///       indicated "persisted in code-gen". Is generated code the operative issue
        ///       here also?
        ///    </note>
        /// </devdoc>
        private bool ShouldSerializeCategory() {
            return !Category.Equals(Guid.Empty);
        }

        /// <include file='doc\MessageQueueInstaller.uex' path='docs/doc[@for="MessageQueueInstaller.Uninstall"]/*' />
        /// <devdoc>
        ///    <para>Uninstalls the queue by removing information concerning it from the registry. 
        ///       If the <see cref='System.Messaging.MessageQueueInstaller.UninstallAction'/> is <see langword='Remove'/>,
        ///       Uninstall also deletes the queue associated with the <see cref='System.Messaging.MessageQueue'/>. </para>
        /// </devdoc>
        public override void Uninstall(IDictionary savedState) {
            base.Uninstall(savedState);

            if (UninstallAction == UninstallAction.Remove) {
                Context.LogMessage(Res.GetString(Res.DeletingQueue, Path));
                if (MessageQueue.Exists(Path))
                    MessageQueue.Delete(Path);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuepermission.cs ===
//----------------------------------------------------
// <copyright file="MessageQueuePermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System;
    using System.Text;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;    
    using System.Collections.Specialized;    
    using System.Globalization;
    
                                                                    
    /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Serializable()
    ]
    public sealed class MessageQueuePermission :  CodeAccessPermission, IUnrestrictedPermission {    
        internal Hashtable resolvedFormatNames;                
        internal MessageQueuePermissionEntryCollection innerCollection;
        internal bool isUnrestricted;                
        internal const string Any = "*";                               
        
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermissionEntry.MessageQueuePermission"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueuePermission() {
        }
                                                     
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.MessageQueuePermission1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueuePermission(PermissionState state) {
            if (state == PermissionState.Unrestricted)
                this.isUnrestricted = true;
            else 
                this.isUnrestricted = false;            
        }
        
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.MessageQueuePermission2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueuePermission(MessageQueuePermissionAccess permissionAccess, string path) {
            MessageQueuePermissionEntry entry = new MessageQueuePermissionEntry(permissionAccess, path);
            this.PermissionEntries.Add(entry);
        }
        
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.MessageQueuePermission3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueuePermission(MessageQueuePermissionAccess permissionAccess, string machineName, string label, string category) {
            MessageQueuePermissionEntry entry = new MessageQueuePermissionEntry(permissionAccess, machineName, label, category);
            this.PermissionEntries.Add(entry);
        }
                                         
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.MessageQueuePermission4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueuePermission(MessageQueuePermissionEntry[] permissionAccessEntries) {
            if (permissionAccessEntries == null)
                throw new ArgumentNullException("permissionAccessEntries");
                
            this.PermissionEntries.AddRange(permissionAccessEntries);                
        }

        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.PermissionEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MessageQueuePermissionEntryCollection PermissionEntries {
            get {                                 
                if (this.innerCollection == null) {                 
                    if (this.resolvedFormatNames == null) 
                        this.innerCollection = new MessageQueuePermissionEntryCollection(this); 
                    else {
                        Hashtable resolvedReference = this.resolvedFormatNames;
                        this.innerCollection = new MessageQueuePermissionEntryCollection(this);                         
                        foreach (string formatName in resolvedReference.Keys) {
                            string path;                            
                            if (formatName == Any)
                                path = Any;
                            else
                                path = "FORMATNAME:" + formatName;
                            
                            MessageQueuePermissionEntry entry = new MessageQueuePermissionEntry(                                                                                       
                                                                                        (MessageQueuePermissionAccess)resolvedReference[formatName],
                                                                                         path);                            
                            this.innerCollection.Add(entry);                                                                                        
                        }   
                    }                                         
                }                    
                                                                                                               
                return this.innerCollection;                                                               
            }
        }

        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.Clear"]/*' />
        ///<internalonly/> 
        internal void Clear() {         
            this.resolvedFormatNames = null;
        }                                                                                     
                                                                       
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.Copy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IPermission Copy() {
            MessageQueuePermission permission = new MessageQueuePermission();                        
            permission.isUnrestricted = this.isUnrestricted;            
            foreach (MessageQueuePermissionEntry entry in this.PermissionEntries) 
                permission.PermissionEntries.Add(entry);
            
            permission.resolvedFormatNames = this.resolvedFormatNames;                            
            return permission;            
        }
                                                                                           
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.FromXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void FromXml(SecurityElement securityElement) {                                                           
            this.PermissionEntries.Clear();
            string unrestrictedValue = securityElement.Attribute("Unrestricted");            
            if (unrestrictedValue != null && (string.Compare(unrestrictedValue, "true", true, CultureInfo.InvariantCulture) == 0)) {
                this.isUnrestricted = true;
                return;
            }                                                                                              

            if (securityElement.Children != null) {                
                for (int index = 0; index < securityElement.Children.Count; ++ index) {            
                    SecurityElement currentElement =  (SecurityElement)securityElement.Children[index];                                        
                    MessageQueuePermissionEntry entry = null;                                 
    
                    string accessString = currentElement.Attribute("access");                                             
                    int permissionAccess = 0;                                                  
                    if (accessString != null) { 
                        string[] accessArray = accessString.Split(new char[]{'|'});
                        for (int index2 = 0; index2 < accessArray.Length; ++ index2) {
                            string currentAccess =  accessArray[index2].Trim();
                            if (Enum.IsDefined(typeof(MessageQueuePermissionAccess), currentAccess)) 
                                permissionAccess = permissionAccess | (int)Enum.Parse(typeof(MessageQueuePermissionAccess), currentAccess);                                         
                        }                                
                    }                                      
                                                                                              
                    if (currentElement.Tag == "Path") {
                        string path = currentElement.Attribute("value");
                        if (path == null)
                            throw new InvalidOperationException(Res.GetString(Res.InvalidXmlFormat));                                
                        
                        entry = new MessageQueuePermissionEntry((MessageQueuePermissionAccess)permissionAccess, path);
                    }                
                    else if (currentElement.Tag == "Criteria") {
                        string label = currentElement.Attribute("label");                            
                        string category = currentElement.Attribute("category");                            
                        string machineName = currentElement.Attribute("machine");                            
                        if (machineName == null && label == null && category == null)
                            throw new InvalidOperationException(Res.GetString(Res.InvalidXmlFormat));                                
                            
                        entry = new MessageQueuePermissionEntry((MessageQueuePermissionAccess)permissionAccess, machineName, label, category);                    
                    }
                    else                              
                        throw new InvalidOperationException(Res.GetString(Res.InvalidXmlFormat));                                
                                                                                   
                    this.PermissionEntries.Add(entry);
                }                                                        
            }
        }        
                 
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.Intersect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {            
            if (target == null)
                return null;
                
            if (!(target is MessageQueuePermission))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "target", target.ToString()));            
                
            MessageQueuePermission targetQueuePermission = (MessageQueuePermission)target;            
            if (this.IsUnrestricted())
                return targetQueuePermission.Copy();
                
            if (targetQueuePermission.IsUnrestricted())
                return this.Copy();
                
            this.ResolveFormatNames();
            targetQueuePermission.ResolveFormatNames();                
            MessageQueuePermission newPermission = new MessageQueuePermission();
            Hashtable newFormatNames = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            newPermission.resolvedFormatNames = newFormatNames;
            IDictionaryEnumerator formatNamesEnumerator;
            Hashtable formatNamesTable;
            if (this.resolvedFormatNames.Count <  targetQueuePermission.resolvedFormatNames.Count) {
                formatNamesEnumerator = this.resolvedFormatNames.GetEnumerator();
                formatNamesTable = targetQueuePermission.resolvedFormatNames;
            }
            else{
                formatNamesEnumerator = targetQueuePermission.resolvedFormatNames.GetEnumerator();
                formatNamesTable = this.resolvedFormatNames;
            }
            
            while(formatNamesEnumerator.MoveNext()) {
                if (formatNamesTable.ContainsKey(formatNamesEnumerator.Key))  {
                    string currentFormatName = (string)formatNamesEnumerator.Key;
                    MessageQueuePermissionAccess currentAccess = (MessageQueuePermissionAccess)formatNamesEnumerator.Value;
                    MessageQueuePermissionAccess targetAccess = (MessageQueuePermissionAccess)formatNamesTable[currentFormatName];
                    newFormatNames.Add(currentFormatName, currentAccess & targetAccess);
                }                    
            }                                                                                        
                                                                                              
            return newPermission;                                                               
        }         
                            
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.IsSubsetOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            if (target == null)                     
                return false;
                            
            if (!(target is MessageQueuePermission))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "target", target.ToString()));            
                                                                                                                 
            MessageQueuePermission targetQueuePermission = (MessageQueuePermission)target;            
            if (targetQueuePermission.IsUnrestricted())
                return true;
            else if (this.IsUnrestricted())
                return false;                                              
                                                  
            this.ResolveFormatNames();
            targetQueuePermission.ResolveFormatNames();
            
            //If one of the tables is empty the subset cannot be resolved reliably, should assume
            //then that they are not subset of each other.
            if ((this.resolvedFormatNames.Count == 0 && targetQueuePermission.resolvedFormatNames.Count != 0) ||
                (this.resolvedFormatNames.Count != 0 && targetQueuePermission.resolvedFormatNames.Count == 0))
                return false;                    
            
            //If the target table contains a wild card, all the current formatName access need to be
            //a subset of the target.                      
            IDictionaryEnumerator formatNamesEnumerator;                                                                   
            if (targetQueuePermission.resolvedFormatNames.ContainsKey(Any)) {
                MessageQueuePermissionAccess targetAccess = (MessageQueuePermissionAccess)targetQueuePermission.resolvedFormatNames[Any];
                formatNamesEnumerator = this.resolvedFormatNames.GetEnumerator();                            
                while(formatNamesEnumerator.MoveNext()) {
                    MessageQueuePermissionAccess currentAccess = (MessageQueuePermissionAccess)formatNamesEnumerator.Value;
                    if ((currentAccess & targetAccess) != currentAccess)
                        return false;
                }
                
                return true;
            }
                                                                                
            //If the current table contains a wild card it can be treated as any other format name.
            formatNamesEnumerator = this.resolvedFormatNames.GetEnumerator();            
            while(formatNamesEnumerator.MoveNext()) {
                string currentFormatName = (string)formatNamesEnumerator.Key;                
                if (!targetQueuePermission.resolvedFormatNames.ContainsKey(currentFormatName)) 
                    return false;
                else {
                    MessageQueuePermissionAccess currentAccess = (MessageQueuePermissionAccess)formatNamesEnumerator.Value;
                    MessageQueuePermissionAccess targetAccess = (MessageQueuePermissionAccess)targetQueuePermission.resolvedFormatNames[currentFormatName];
                    if ((currentAccess & targetAccess) != currentAccess)
                        return false;
                }                    
            }

            return true;                                        
        }
        
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return this.isUnrestricted;
        }
       
        internal void ResolveFormatNames() {
            if (this.resolvedFormatNames == null) {
                this.resolvedFormatNames = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                IEnumerator enumerator = this.PermissionEntries.GetEnumerator();
                while (enumerator.MoveNext()) {
                    MessageQueuePermissionEntry entry = (MessageQueuePermissionEntry)enumerator.Current;
                    if (entry.Path != null) {
                        if (entry.Path == Any) 
                            this.resolvedFormatNames.Add(Any, entry.PermissionAccess);                         
                        else {
                            try {
                                MessageQueue queue = new MessageQueue(entry.Path);
                                this.resolvedFormatNames.Add(queue.FormatName, entry.PermissionAccess);                         
                            }
                            catch(Exception) {
                                //if the format name cannot be resolved, it won't be added to the list
                                //permissions won't be granted.
                            }                                
                        }   
                    }
                    else {
                       try {                            
                            MessageQueueCriteria criteria = new MessageQueueCriteria();
                            if (entry.MachineName != null)
                                criteria.MachineName = entry.MachineName;
                            
                            if (entry.Category != null)
                                criteria.Category = new Guid(entry.Category);
                            
                            if (entry.Label != null)
                                criteria.Label = entry.Label;        
                                                    
                            IEnumerator messageQueues = MessageQueue.GetMessageQueueEnumerator(criteria, false);
                            while (messageQueues.MoveNext()) {
                                MessageQueue queue = (MessageQueue)messageQueues.Current;                                        
                                this.resolvedFormatNames.Add(queue.FormatName, entry.PermissionAccess);
                            }    
                        }
                        catch(Exception) {
                            //if the criteria cannot be resolved, nothing will be added to the list
                            //permissions won't be granted.
                        }                                                                                                          
                    }                        
                }               
            }
        }
        
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.ToXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SecurityElement ToXml() {
            SecurityElement root = new SecurityElement("IPermission");            
            Type type = this.GetType();
            root.AddAttribute("class", type.FullName + ", " + type.Module.Assembly.FullName.Replace('\"', '\''));            
            root.AddAttribute("version", "1");            
            
            if (this.isUnrestricted) {
                root.AddAttribute("Unrestricted", "true");
                return root;                    
            }                        

            IEnumerator enumerator = this.PermissionEntries.GetEnumerator();
            while (enumerator.MoveNext()) {
                SecurityElement currentElement = null;
                MessageQueuePermissionEntry entry = (MessageQueuePermissionEntry)enumerator.Current;
                if (entry.Path != null) {
                    currentElement = new SecurityElement("Path");
                    currentElement.AddAttribute("value", entry.Path);
                }
                else {                
                    currentElement = new SecurityElement("Criteria");
                    if (entry.MachineName != null)
                        currentElement.AddAttribute("machine", entry.MachineName);
                                                
                    if (entry.Category != null)
                        currentElement.AddAttribute("category", entry.Category);
                        
                    if (entry.Label != null)
                        currentElement.AddAttribute("label", entry.Label);                    
                }                        
                                                
                int currentAccess = (int)entry.PermissionAccess;
                if (currentAccess != 0) {                                                               
                    StringBuilder accessStringBuilder = null;                     
                    int[] enumValues =  (int[])Enum.GetValues(typeof(MessageQueuePermissionAccess));                    
                    Array.Sort(enumValues, InvariantComparer.Default);
                    for (int index = (enumValues.Length -1); index >= 0; -- index) {
                        if (enumValues[index] != 0 && ((currentAccess & enumValues[index]) == enumValues[index])) {
                            if (accessStringBuilder == null)
                                accessStringBuilder = new StringBuilder();
                            else
                                accessStringBuilder.Append("|");
                                                                        
                            accessStringBuilder.Append(Enum.GetName(typeof(MessageQueuePermissionAccess), enumValues[index]));
                            currentAccess = currentAccess & (enumValues[index] ^ enumValues[index]);                                
                        }
                    }
                    
                    currentElement.AddAttribute("access", accessStringBuilder.ToString());       
                }
                                                                              
                root.AddChild(currentElement);
            }                                                                                    
                                                                                                  
            return root;
        }
        
        /// <include file='doc\MessageQueuePermission.uex' path='docs/doc[@for="MessageQueuePermission.Union"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {
            if (target == null)
                return this.Copy();
        
            if (!(target is MessageQueuePermission))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "target", target.ToString()));            
                                                                                   
            MessageQueuePermission targetQueuePermission = (MessageQueuePermission)target;                                        
            MessageQueuePermission newPermission = new MessageQueuePermission();
            if (this.IsUnrestricted() || targetQueuePermission.IsUnrestricted()) {
                newPermission.isUnrestricted = true;
                return newPermission;
            }
            
            Hashtable newFormatNames = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            this.ResolveFormatNames();
            targetQueuePermission.ResolveFormatNames();
            
            IDictionaryEnumerator formatNamesEnumerator = this.resolvedFormatNames.GetEnumerator();
            IDictionaryEnumerator targetFormatNamesEnumerator = targetQueuePermission.resolvedFormatNames.GetEnumerator();            
            while(formatNamesEnumerator.MoveNext())
                newFormatNames[(string)formatNamesEnumerator.Key] = formatNamesEnumerator.Value;                            
            
            while(targetFormatNamesEnumerator.MoveNext()) {
                if (!newFormatNames.ContainsKey(targetFormatNamesEnumerator.Key)) 
                    newFormatNames[targetFormatNamesEnumerator.Key] = targetFormatNamesEnumerator.Value;
                else {
                    MessageQueuePermissionAccess currentAccess = (MessageQueuePermissionAccess)newFormatNames[targetFormatNamesEnumerator.Key];
                    newFormatNames[targetFormatNamesEnumerator.Key] = currentAccess | (MessageQueuePermissionAccess)targetFormatNamesEnumerator.Value;                     
                }                    
            }                
                                                                      
            newPermission.resolvedFormatNames = newFormatNames;
            return newPermission;                                                               
        }                 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuepermissionaccess.cs ===
//----------------------------------------------------
// <copyright file="MessageQueuePermissionAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    
    /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]         
    public enum MessageQueuePermissionAccess {                        
        /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess.Browse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Browse = 1 << 1,        
        /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess.Send"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Send = 1 << 2 | Browse,
        /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess.Peek"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Peek = 1 << 3 | Browse,        
        /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess.Receive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Receive = 1 << 4 | Peek,
        /// <include file='doc\MessageQueuePermissionAccess.uex' path='docs/doc[@for="MessageQueuePermissionAccess.Administer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Administer = 1 << 5 | Send | Receive | Peek,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuepermissionentry.cs ===
//----------------------------------------------------
// <copyright file="MessageQueuePermissionEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.ComponentModel;

    /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry"]/*' />
    [
    Serializable()
    ]  
    public class MessageQueuePermissionEntry {        
        private string label;
        private string machineName;
        private string path;
        private string category;
        private MessageQueuePermissionAccess permissionAccess;
                  
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.MessageQueuePermissionEntry"]/*' />
        public MessageQueuePermissionEntry(MessageQueuePermissionAccess permissionAccess, string path) {
            if (path == null)
                throw new ArgumentNullException("name");  
                                        
            if (path != MessageQueuePermission.Any && !MessageQueue.ValidatePath(path, false))
                throw new ArgumentException(Res.GetString(Res.PathSyntax));
                    
            this.path = path;                                           
                                                  
            this.permissionAccess = permissionAccess;                
        }
        
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.MessageQueuePermissionEntry1"]/*' />
        public MessageQueuePermissionEntry(MessageQueuePermissionAccess permissionAccess, string machineName, string label, string category) {
            if (machineName == null && label == null && category == null)
                throw new ArgumentNullException("machineName");  
        
            if (machineName != null && !SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "MachineName", machineName));            
                    
            this.permissionAccess = permissionAccess;
            this.machineName = machineName;
            this.label = label;
            this.category = category;
        }
                 
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.Category"]/*' />
        public string Category {
            get {
                return this.category;
            }            
        }
                                       
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.Label"]/*' />
        public string Label {
            get {
                return this.label;
            }                       
        }
        
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.MachineName"]/*' />
        public string MachineName {
            get {
                return this.machineName;
            }                        
        }
        
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.Path"]/*' />
        public string Path {
            get {
                return this.path;
            }                        
        }    
        
        /// <include file='doc\MessageQueuePermissionEntry.uex' path='docs/doc[@for="MessageQueuePermissionEntry.PermissionAccess"]/*' />
        public MessageQueuePermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }                       
        }                                   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuepermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueuePermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.ComponentModel;
    using System.Security;
    using System.Security.Permissions;   
        
    /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute"]/*' />
    [
    AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly | AttributeTargets.Event, AllowMultiple = true, Inherited = false ),
    Serializable()
    ]     
    public class MessageQueuePermissionAttribute : CodeAccessSecurityAttribute {        
        private string label;
        private string machineName;
        private string path;
        private string category;
        private MessageQueuePermissionAccess permissionAccess;
            
        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.MessageQueuePermissionAttribute"]/*' />
        public MessageQueuePermissionAttribute(SecurityAction action)
        : base(action) {            
        }        

        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.Category"]/*' />
        public string Category {
            get {
                return this.category;
            }
            
            set {
                string oldValue = this.category;
                this.category = value;
                Exception e = CheckProperties();
                if (e != null) {
                    this.category = oldValue;
                    throw e;
                }                
            }
        }
                             
        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.Label"]/*' />
        public string Label {
            get {
                return this.label;
            }
            
            set {
                string oldValue = this.label;
                this.label = value;
                Exception e = CheckProperties();
                if (e != null) {
                    this.label = oldValue;
                    throw e;
                }                
            }
        }
        
        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.MachineName"]/*' />
        public string MachineName {
            get {
                return this.machineName;
            }
            
            set{
                if (value != null && !SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "MachineName", value));            
            
                string oldValue = this.machineName;
                this.machineName = value;
                Exception e = CheckProperties();
                if (e != null) {
                    this.machineName = oldValue;
                    throw e;
                }                
            }
        }
        
        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.Path"]/*' />
        public string Path {
            get {
                return this.path;
            }
            
            set {
                if (value != null && value != MessageQueuePermission.Any && !MessageQueue.ValidatePath(value, false))
                    throw new ArgumentException(Res.GetString(Res.PathSyntax));
                    
                string oldValue = this.path;
                this.path = value;
                Exception e = CheckProperties();
                if (e != null) {
                    this.path = oldValue;
                    throw e;
                }                                    
            }
        }   
        
        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.PermissionAccess"]/*' />
        public MessageQueuePermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }                       
            
            set {
                this.permissionAccess = value;
            }
        }  
                                      
        /// <include file='doc\MessageQueuePermissionAttribute.uex' path='docs/doc[@for="MessageQueuePermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {            
            if (Unrestricted) 
                return new MessageQueuePermission(PermissionState.Unrestricted);
            
            CheckProperties();
            if (this.path != null)                
                return new MessageQueuePermission(this.PermissionAccess, this.path);                                                             
            
            return new MessageQueuePermission(this.PermissionAccess, this.machineName, this.label, this.category);                                                             
        }
        
        private Exception CheckProperties() {               
            if (this.path != null &&
                (this.machineName != null || this.label != null || this.category != null))
                return new InvalidOperationException(Res.GetString(Res.PermissionPathOrCriteria));                
                
            if (this.path == null && 
                this.machineName == null && this.label == null && this.category == null)
                return new InvalidOperationException(Res.GetString(Res.PermissionAllNull));
                
            return null;                                                             
        }

    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuetransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Threading;
    using System.Diagnostics;
    using System.Messaging.Interop;
    
    /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class MessageQueueTransaction : IDisposable {
        private ITransaction internalTransaction;
        private MessageQueueTransactionStatus transactionStatus;
        private bool disposed;
                                           
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.MessageQueueTransaction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new Message Queuing internal transaction context.
        ///    </para>
        /// </devdoc>                
        public MessageQueueTransaction() {
            this.transactionStatus = MessageQueueTransactionStatus.Initialized;
        }
        
        internal ITransaction InnerTransaction {
            get {
                return this.internalTransaction;
            }                
        }
        
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Status"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The status of the transaction that this object represents.
        ///    </para>
        /// </devdoc>   
        public MessageQueueTransactionStatus Status {
            get {
                return this.transactionStatus;                    
            }                
        }
        
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Abort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rolls back the pending internal transaction.
        ///    </para>
        /// </devdoc>
        public void Abort() {
            lock (this) {
                if (this.internalTransaction == null)
                    throw new InvalidOperationException(Res.GetString(Res.TransactionNotStarted));
                else {
                    this.AbortInternalTransaction();   
                }            
            }                                
        }
                    
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.AbortInternalTransaction"]/*' />
        /// <internalonly/>                                 
        private void AbortInternalTransaction() {
            int status = this.internalTransaction.Abort(0, 0, 0);                    
            if (MessageQueue.IsFatalError(status)) 
                throw new MessageQueueException(status);
            
            this.internalTransaction = null;    
            this.transactionStatus = MessageQueueTransactionStatus.Aborted;                                    
        }                        
                     
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Begin"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Begins a new Message Queuing internal transaction context.
        ///    </para>
        /// </devdoc>
        public void Begin() {
            //Won't allow begining a new transaction after the object has been disposed.
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
                
            lock (this) {
                if (internalTransaction != null)
                    throw new InvalidOperationException(Res.GetString(Res.TransactionStarted));
                else {
                    int status = SafeNativeMethods.MQBeginTransaction(out this.internalTransaction);
                    if (MessageQueue.IsFatalError(status)) {
                        this.internalTransaction = null;
                        throw new MessageQueueException(status);
                    }                        
                        
                    this.transactionStatus = MessageQueueTransactionStatus.Pending;
                }
            }
        }
       
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.BeginQueueOperation"]/*' />
        /// <internalonly/>                                           
        internal ITransaction BeginQueueOperation() {            
            Monitor.Enter(this);
            return this.internalTransaction;
        }
        
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Commit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Commits a pending internal transaction.
        ///    </para>
        /// </devdoc>
        public void Commit() {
            lock (this) {
                if (this.internalTransaction == null)
                    throw new InvalidOperationException(Res.GetString(Res.TransactionNotStarted));
                else {
                    int status = this.internalTransaction.Commit(0, 0, 0);                    
                    if (MessageQueue.IsFatalError(status))                        
                        throw new MessageQueueException(status);
                                        
                    this.internalTransaction = null;
                    this.transactionStatus = MessageQueueTransactionStatus.Committed;                         
                }
            }
        }
        
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes this transaction instance, if it is in a 
        ///       pending status, the transaction will be aborted.  
        ///    </para>
        /// </devdoc>   
        public void Dispose() {
            Dispose(true); 
            GC.SuppressFinalize(this);                           
        }
        
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Dispose1"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                lock (this) {
                    if (internalTransaction != null) 
                        this.AbortInternalTransaction();                                        
                }                                
            }    
            
            this.disposed = true;                                  
        }        
        
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.Finalize"]/*' />
        /// <internalonly/>   
        ~MessageQueueTransaction() {
            Dispose(false);
        }
         
        /// <include file='doc\MessageQueueTransaction.uex' path='docs/doc[@for="MessageQueueTransaction.EndQueueOperation"]/*' />
        /// <internalonly/>        
        internal void EndQueueOperation() { 
            Monitor.Exit(this);
        }                                 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuepermissionentrycollection.cs ===
//----------------------------------------------------
// <copyright file="MessageQueuePermissionEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {   
    using System.Collections;
    
    /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection"]/*' />        
    [
    Serializable()
    ]
    public class MessageQueuePermissionEntryCollection : CollectionBase {
        MessageQueuePermission owner;
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.MessageQueuePermissionEntryCollection"]/*' />        
        ///<internalonly/>   
        internal MessageQueuePermissionEntryCollection(MessageQueuePermission owner) {
            this.owner = owner;        
        }                                                                                                                 
                                                                                                            
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.this"]/*' />        
        public MessageQueuePermissionEntry this[int index] {
            get {
                return (MessageQueuePermissionEntry)List[index];
            }
            set {
                List[index] = value;
            }
            
        }
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.Add"]/*' />        
        public int Add(MessageQueuePermissionEntry value) {   
            return List.Add(value);
        }
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.AddRange"]/*' />        
        public void AddRange(MessageQueuePermissionEntry[] value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
    
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.AddRange1"]/*' />        
        public void AddRange(MessageQueuePermissionEntryCollection value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }         
    
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.Contains"]/*' />        
        public bool Contains(MessageQueuePermissionEntry value) {            
            return List.Contains(value);
        }
    
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.CopyTo"]/*' />        
        public void CopyTo(MessageQueuePermissionEntry[] array, int index) {            
            List.CopyTo(array, index);
        }
    
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.IndexOf"]/*' />        
        public int IndexOf(MessageQueuePermissionEntry value) {            
            return List.IndexOf(value);
        }
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.Insert"]/*' />        
        public void Insert(int index, MessageQueuePermissionEntry value) {            
            List.Insert(index, value);
        }
                
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.Remove"]/*' />        
        public void Remove(MessageQueuePermissionEntry value) {
            List.Remove(value);                     
        }
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.OnClear"]/*' />        
        ///<internalonly/>                          
        protected override void OnClear() {   
            this.owner.Clear();         
        }
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.OnInsert"]/*' />        
        ///<internalonly/>                          
        protected override void OnInsert(int index, object value) {        
            this.owner.Clear();         
        }
        
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemove(int index, object value) {
            this.owner.Clear();         
        }
                 
        /// <include file='doc\MessageQueuePermissionEntryCollection.uex' path='docs/doc[@for="MessageQueuePermissionEntryCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSet(int index, object oldValue, object newValue) {     
            this.owner.Clear();         
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuetransactionstatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueTransactionStatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Diagnostics;
    using System.Messaging.Interop;
    
    /// <include file='doc\MessageQueueTransactionStatus.uex' path='docs/doc[@for="MessageQueueTransactionStatus"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum MessageQueueTransactionStatus {
        /// <include file='doc\MessageQueueTransactionStatus.uex' path='docs/doc[@for="MessageQueueTransactionStatus.Aborted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Aborted = 0,
        /// <include file='doc\MessageQueueTransactionStatus.uex' path='docs/doc[@for="MessageQueueTransactionStatus.Commited"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Committed = 1,
        /// <include file='doc\MessageQueueTransactionStatus.uex' path='docs/doc[@for="MessageQueueTransactionStatus.Initialized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Initialized = 2,            
        /// <include file='doc\MessageQueueTransactionStatus.uex' path='docs/doc[@for="MessageQueueTransactionStatus.Pending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pending = 3,        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;
    using System;   

    /// <include file='doc\MessageType.uex' path='docs/doc[@for="MessageType"]/*' />
    /// <devdoc>
    ///    A message can be a normal MSMQ message, a positive or negative 
    ///    (arrival and read) acknowledgment message, or a report message.
    /// </devdoc>
    public enum MessageType {
        /// <include file='doc\MessageType.uex' path='docs/doc[@for="MessageType.Acknowledgment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Acknowledgment = 1,
        /// <include file='doc\MessageType.uex' path='docs/doc[@for="MessageType.Normal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Normal = 2,
        /// <include file='doc\MessageType.uex' path='docs/doc[@for="MessageType.Report"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Report = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeue.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueue.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;

namespace System.Messaging {
    using System.Text;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;                
    using System.Configuration.Install;
    using System.Messaging.Interop;    
    using Microsoft.Win32;                                                                                                                        
    using System.ComponentModel.Design;
    using System.Collections;    
    using System.Globalization;    
    using System.Security.Permissions;    
    using System.DirectoryServices;    
    using ITransaction = System.Messaging.Interop.ITransaction;

    /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides
    ///       access to a Message Queuing backend queue resource.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("ReceiveCompleted"),    
    TypeConverterAttribute(typeof(System.Messaging.Design.MessageQueueConverter)), 
    Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),
    DesignerAttribute("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, " + AssemblyRef.MicrosoftVisualStudio),
    InstallerTypeAttribute(typeof(MessageQueueInstaller))
    ]
    public class MessageQueue : Component, IEnumerable {
        //Public constants
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.InfiniteTimeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that
        ///       there is no
        ///       timeout period for calls to peek or receive messages.
        ///    </para>
        /// </devdoc>
        public static readonly TimeSpan InfiniteTimeout = TimeSpan.FromMilliseconds(UInt32.MaxValue);                                                                                             
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.InfiniteQueueSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly long InfiniteQueueSize = UInt32.MaxValue;                                                                            
                               
        //Internal members        
        private DefaultPropertiesToSend defaultProperties;
        private MessagePropertyFilter receiveFilter;
        private int sharedMode;
        private string formatName;
        private string queuePath;
        private string path;
        private QueuePropertyVariants properties;
        private IMessageFormatter formatter;
        private static string computerName;                           
        
        //Cached properties
        private QueuePropertyFilter filter;
        private bool authenticate;
        private short basePriority;
        private DateTime createTime;
        private int encryptionLevel;
        private Guid id;
        private string label;        
        private DateTime lastModifyTime;
        private long journalSize;
        private long queueSize;
        private Guid queueType;
        private bool useJournaling;           
        private MQCacheableInfo mqInfo;

        //Async IO support        
        private bool attached;        
        private bool useThreadPool;
        private AsyncCallback onRequestCompleted;                                
        private PeekCompletedEventHandler onPeekCompleted;
        private ReceiveCompletedEventHandler onReceiveCompleted;
        private ISynchronizeInvoke synchronizingObject;

        //Path sufixes
        private static readonly string SUFIX_PRIVATE = "\\PRIVATE$";
        private static readonly string SUFIX_JOURNAL = "\\JOURNAL$";
        private static readonly string SUFIX_DEADLETTER = "\\DEADLETTER$";
        private static readonly string SUFIX_DEADXACT = "\\XACTDEADLETTER$";

        //Path prefixes
        private static readonly string PREFIX_LABEL = "LABEL:";
        private static readonly string PREFIX_FORMAT_NAME = "FORMATNAME:";

        //Connection pooling support
        private static CacheTable formatNameCache = new CacheTable("formatNameCache", 4, new TimeSpan(0, 0, 100));   // path -> formatname
        private static CacheTable queueInfoCache  = new CacheTable("queue info", 4, new TimeSpan(0, 0, 100));        // formatname -> readHandle. writeHandle, isTrans
        private static bool enableConnectionCache = true;
        
        //Code Acess Security support            
        private bool administerGranted;
        private bool browseGranted;
        private bool sendGranted;
        private bool receiveGranted;
        private bool peekGranted;                                     
                                     
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MessageQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.MessageQueue'/> class. To use the object instantiated by the default
        ///       constructor, the <see cref='System.Messaging.MessageQueue.Path'/>
        ///       property must be set.
        ///    </para>
        /// </devdoc>
        //
        public MessageQueue() {
            this.path = String.Empty;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MessageQueue1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.MessageQueue'/>
        ///       class that references the Message Queuing application resource specified by the
        ///    <paramref name="path"/> 
        ///    parameter.
        /// </para>
        /// </devdoc>
        public MessageQueue(string path) {
            Path = path;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MessageQueue2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Messaging.MessageQueue'/> class that references the
        ///       Message Queuing application resource specified by the <paramref name="path"/> parameter,
        ///       and has the specified queue read access restriction.
        ///    </para>
        /// </devdoc>
        public MessageQueue(string path, bool sharedModeDenyReceive) : this(path) {
            if (sharedModeDenyReceive) {
                this.sharedMode = NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE;                
            }                
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MessageQueue3"]/*' />
        /// <internalonly/>                             
        internal MessageQueue(string path, Guid id) {
            PropertyFilter.Id = true;
            this.id = id;
            this.path = path;
        }        
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Authenticate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value specifying whether the queue only accepts authenticated
        ///       messages.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_Authenticate)]
        public bool Authenticate {
            get {
                if (!PropertyFilter.Authenticate) {                    
                    Properties.SetUI1(NativeMethods.QUEUE_PROPID_AUTHENTICATE, (byte)0);
                    GenerateQueueProperties();
                    this.authenticate = (Properties.GetUI1(NativeMethods.QUEUE_PROPID_AUTHENTICATE) != NativeMethods.QUEUE_AUTHENTICATE_NONE);
                    PropertyFilter.Authenticate = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_AUTHENTICATE);
                }

                return this.authenticate;
            }

            set {                
                if (value)
                    Properties.SetUI1(NativeMethods.QUEUE_PROPID_AUTHENTICATE, (byte)NativeMethods.QUEUE_AUTHENTICATE_AUTHENTICATE);
                else
                    Properties.SetUI1(NativeMethods.QUEUE_PROPID_AUTHENTICATE, (byte)NativeMethods.QUEUE_AUTHENTICATE_NONE);

                SaveQueueProperties();
                this.authenticate = value;
                PropertyFilter.Authenticate = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_AUTHENTICATE);
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BasePriority"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating the base
        ///       priority used to route a public queue's messages over the network.</para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_BasePriority)]
        public short BasePriority {
            get {
                if (!PropertyFilter.BasePriority) {                    
                    Properties.SetI2(NativeMethods.QUEUE_PROPID_BASEPRIORITY, (short)0);
                    GenerateQueueProperties();
                    this.basePriority = properties.GetI2(NativeMethods.QUEUE_PROPID_BASEPRIORITY);
                    PropertyFilter.BasePriority = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_BASEPRIORITY);
                }

                return this.basePriority;

            }

            set {                
                Properties.SetI2(NativeMethods.QUEUE_PROPID_BASEPRIORITY, value);
                SaveQueueProperties();
                this.basePriority = value;
                PropertyFilter.BasePriority = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_BASEPRIORITY);
            }
        }
 
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.CanRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Messaging.MessageQueue'/>
        ///       has read permission.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_CanRead)]
        public bool CanRead {
            get {
                if (!browseGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                
                    browseGranted = true;                   
                }
                                    
                return MQInfo.CanRead;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.CanWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Messaging.MessageQueue'/>
        ///       has write permission.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_CanWrite)]
        public bool CanWrite {
            get {
                if (!browseGranted) {
                     MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                    
                    browseGranted = true;
                }                   
                
                return MQInfo.CanWrite;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Category"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the queue type.</para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_Category)]
        public Guid Category {
            get {
                if (!PropertyFilter.Category) {                    
                    Properties.SetNull(NativeMethods.QUEUE_PROPID_TYPE);
                    GenerateQueueProperties();
                    byte[] bytes = new byte[16];
                    IntPtr handle = (INTPTR_INTPTRCAST)Properties.GetUI4(NativeMethods.QUEUE_PROPID_TYPE);
                    if (handle != (IntPtr)0) {
                        Marshal.Copy(handle, bytes, 0, 16);
                        //MSMQ allocated memory for this operation, needs to be freed
                        SafeNativeMethods.MQFreeMemory(handle);
                    }

                    this.queueType = new Guid(bytes);
                    PropertyFilter.Category = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_TYPE);
                }
                return this.queueType;
            }

            set {                
                Properties.SetGuid(NativeMethods.QUEUE_PROPID_TYPE, value.ToByteArray());
                SaveQueueProperties();
                this.queueType = value;
                PropertyFilter.Category = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_TYPE);
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ComputerName"]/*' />
        /// <internalonly/>
        internal static string ComputerName {
            get {                
                if (computerName == null) {
                    lock (typeof(MessageQueue)) {
                        if (computerName == null) {
                            StringBuilder sb = new StringBuilder(256);
                            SafeNativeMethods.GetComputerName(sb, new int[] {sb.Capacity});
                            computerName = sb.ToString();
                        }                            
                    }                        
                }                    
                
                return computerName;
            }
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.CreateTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the time and date of the queue's creation.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_CreateTime)]
        public DateTime CreateTime {
            get {
                if (!PropertyFilter.CreateTime) {
                    DateTime time = new DateTime(1970 , 1, 1);
                    Properties.SetI4(NativeMethods.QUEUE_PROPID_CREATE_TIME, 0);
                    GenerateQueueProperties();
                    this.createTime = time.AddSeconds(properties.GetI4(NativeMethods.QUEUE_PROPID_CREATE_TIME)).ToLocalTime();
                    PropertyFilter.CreateTime = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_CREATE_TIME);
                }

                return this.createTime;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.DefaultPropertiesToSend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the properties to be used by
        ///       default when sending messages to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Content), MessagingDescription(Res.MQ_DefaultPropertiesToSend)]
        public DefaultPropertiesToSend DefaultPropertiesToSend {
            get {
                if (this.defaultProperties == null) {
                    if (this.DesignMode)
                        this.defaultProperties = new DefaultPropertiesToSend(true);
                    else
                        this.defaultProperties = new DefaultPropertiesToSend();                                                        
                }

                return this.defaultProperties;
            }

            set {
                this.defaultProperties = value;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.DenySharedReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the shared mode for the queue that this object
        ///       references. If <see langword='true'/> ,
        ///       no other queue object will be able to receive messages from the queue resource.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DefaultValueAttribute(false), MessagingDescription(Res.MQ_DenySharedReceive)]
        public bool DenySharedReceive {
            get {
                return(this.sharedMode == NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE);
            }
            set {                
                if (value && (this.sharedMode != NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE)) {                    
                    this.Close();
                    this.sharedMode = NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE;
                }
                else if (!value && (this.sharedMode == NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE)) {                    
                    this.Close();
                    this.sharedMode = NativeMethods.QUEUE_SHARED_MODE_DENY_NONE;
                }
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.EnableConnectionCache"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public static bool EnableConnectionCache {
            get {
                return enableConnectionCache;
            }

            set {
                enableConnectionCache = value;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.EncryptionRequired"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the queue only accepts non-private
        ///       (non-encrypted) messages.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_EncryptionRequired)]
        public EncryptionRequired EncryptionRequired {
            get {
                if (!PropertyFilter.EncryptionLevel) {                    
                    Properties.SetUI4(NativeMethods.QUEUE_PROPID_PRIV_LEVEL, 0);
                    GenerateQueueProperties();
                    this.encryptionLevel = Properties.GetUI4(NativeMethods.QUEUE_PROPID_PRIV_LEVEL);
                    PropertyFilter.EncryptionLevel = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_PRIV_LEVEL);
                }
                return(EncryptionRequired)this.encryptionLevel;
            }

            set {  
                if (!Enum.IsDefined(typeof(EncryptionRequired), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(EncryptionRequired));
                              
                Properties.SetUI4(NativeMethods.QUEUE_PROPID_PRIV_LEVEL, (int)value);
                SaveQueueProperties();
                this.encryptionLevel = properties.GetUI4(NativeMethods.QUEUE_PROPID_PRIV_LEVEL);
                PropertyFilter.EncryptionLevel = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_PRIV_LEVEL);                
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.FormatName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the unique name that was generated for the queue when the queue was created.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_FormatName)]
        public string FormatName {
            get {
                if (this.formatName == null) {
                    if (this.path == null || path == "") {
                        return string.Empty;
                    }

                    // see if we already have this cached 
                    if (enableConnectionCache)                        
                        this.formatName = (string)MessageQueue.formatNameCache.Get(this.path);
                    
                    // not in the cache?  keep working.
                    if (formatName == null) {
                        if (PropertyFilter.Id) {
                            //Improves performance when enumerating queues.
                            //This codepath will only be executed when accessing
                            //a queue returned by MessageQueueEnumerator.                        
                            int result;
                            int status = 0;
                            StringBuilder newFormatName = new StringBuilder(NativeMethods.MAX_LABEL_LEN);
                            result = NativeMethods.MAX_LABEL_LEN;
                            status = SafeNativeMethods.MQInstanceToFormatName(this.id.ToByteArray(), newFormatName, ref result);
                            if (status != 0)
                                throw new MessageQueueException(status);                            
    
                            this.formatName = newFormatName.ToString();
                            return this.formatName;
                        }
                                                   
                        string pathUpper = this.path.ToUpper(CultureInfo.InvariantCulture);
                    
                        if (pathUpper.StartsWith(PREFIX_FORMAT_NAME))
                            this.formatName = this.path.Substring(PREFIX_FORMAT_NAME.Length);
                        else if (pathUpper.StartsWith(PREFIX_LABEL)) {
                            MessageQueue labeledQueue = ResolveQueueFromLabel(this.path, true);                                                            
                            this.formatName = labeledQueue.FormatName;
                            this.queuePath = labeledQueue.QueuePath;
                        }                            
                        else {
                            this.queuePath = this.path;
                            this.formatName = ResolveFormatNameFromQueuePath(this.queuePath, true);                            
                        }

                        MessageQueue.formatNameCache.Put(pathUpper, formatName);
                    }
                }
                
                return this.formatName;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Formatter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a
        ///       formatter class used to serialize messages read or written to
        ///       the message body.
        ///    </para>
        /// </devdoc>
        [
        DefaultValueAttribute(null), 
        TypeConverterAttribute(typeof(System.Messaging.Design.MessageFormatterConverter)),
        Browsable(false),
        MessagingDescription(Res.MQ_Formatter)
        ]
        public IMessageFormatter Formatter {
            get {
                if (this.formatter == null && !DesignMode)
                    this.formatter = new XmlMessageFormatter();

                return this.formatter;
            }

            set {
                this.formatter = value;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Id"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Message Queuing unique identifier for the queue.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_GuidId)]
        public Guid Id {
            get {
                if (!PropertyFilter.Id) {
                    Properties.SetNull(NativeMethods.QUEUE_PROPID_INSTANCE);
                    GenerateQueueProperties();
                    byte[] bytes = new byte[16];
                    IntPtr handle = (INTPTR_INTPTRCAST)Properties.GetUI4(NativeMethods.QUEUE_PROPID_INSTANCE);
                    if (handle != (IntPtr)0) {
                        Marshal.Copy(handle, bytes, 0, 16);
                        //MSMQ allocated memory for this operation, needs to be freed
                        SafeNativeMethods.MQFreeMemory(handle);
                    }
                    this.id = new Guid(bytes);
                    PropertyFilter.Id = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_INSTANCE);
                }
                return this.id;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Label"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the queue description.</para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_Label)]
        public string Label {
            get {
                if (!PropertyFilter.Label) {                                        
                    Properties.SetNull(NativeMethods.QUEUE_PROPID_LABEL);
                    GenerateQueueProperties();
                    string description = null;
                    IntPtr handle = (INTPTR_INTPTRCAST)Properties.GetUI4(NativeMethods.QUEUE_PROPID_LABEL);
                    if (handle!= (IntPtr)0) {
                        //Using Unicode API even on Win9x
                        description = Marshal.PtrToStringUni(handle);
                        //MSMQ allocated memory for this operation, needs to be freed
                        SafeNativeMethods.MQFreeMemory(handle);
                    }

                    this.label = description;
                    PropertyFilter.Label = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_LABEL);
                }

                return this.label;
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                                                       
                //Borrow this function from message
                Properties.SetString(NativeMethods.QUEUE_PROPID_LABEL, Message.StringToBytes(value));
                SaveQueueProperties();
                this.label = value;
                PropertyFilter.Label = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_LABEL);
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.LastModifyTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the last time the properties of a queue were modified.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_LastModifyTime)]
        public DateTime LastModifyTime {
            get {
                if (!PropertyFilter.LastModifyTime) {
                    DateTime time = new DateTime(1970 , 1, 1);
                    Properties.SetI4(NativeMethods.QUEUE_PROPID_MODIFY_TIME, 0);
                    GenerateQueueProperties();
                    this.lastModifyTime = time.AddSeconds(properties.GetI4(NativeMethods.QUEUE_PROPID_MODIFY_TIME)).ToLocalTime();
                    PropertyFilter.LastModifyTime = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_MODIFY_TIME);
                }

                return this.lastModifyTime;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MachineName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the computer where
        ///       the queue referenced by this <see cref='System.Messaging.MessageQueue'/>
        ///       is located.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_MachineName)]
        public string MachineName {
            get {
                string queuePath = QueuePath;
                if (queuePath.Length == 0) {
                    return queuePath;
                }
                return queuePath.Substring(0, queuePath.IndexOf('\\'));
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "MachineName", value));            

                StringBuilder newPath = new StringBuilder();
                if ((this.path == null || this.path == "") && this.formatName == null) {
                    //Need to default to an existing queue, for instance Journal.
                    newPath.Append(value);
                    newPath.Append(SUFIX_JOURNAL);
                }
                else {
                    newPath.Append(value);
                    newPath.Append("\\");
                    newPath.Append(QueueName);
                }
                Path =  newPath.ToString();
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MaximumJournalSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum size of the journal queue.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        MessagingDescription(Res.MQ_MaximumJournalSize), 
        TypeConverterAttribute(typeof(System.Messaging.Design.SizeConverter))
        ]
        public long MaximumJournalSize {
            get {
                if (!PropertyFilter.MaximumJournalSize) {
                    Properties.SetUI4(NativeMethods.QUEUE_PROPID_JOURNAL_QUOTA, 0);
                    GenerateQueueProperties();
                    this.journalSize = (long)((uint)properties.GetUI4(NativeMethods.QUEUE_PROPID_JOURNAL_QUOTA));
                    PropertyFilter.MaximumJournalSize = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_JOURNAL_QUOTA);
                }

                return this.journalSize;
            }

            set {
                if (value > InfiniteQueueSize || value < 0)
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "MaximumJournalSize", value));            

                Properties.SetUI4(NativeMethods.QUEUE_PROPID_JOURNAL_QUOTA, (int)((uint)value));
                SaveQueueProperties();
                this.journalSize = value;
                PropertyFilter.MaximumJournalSize = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_JOURNAL_QUOTA);
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MaximumQueueSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum size of the queue.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        MessagingDescription(Res.MQ_MaximumQueueSize), 
        TypeConverterAttribute(typeof(System.Messaging.Design.SizeConverter))
        ]
        public long MaximumQueueSize {
            get {
                if (!PropertyFilter.MaximumQueueSize) {
                    Properties.SetUI4(NativeMethods.QUEUE_PROPID_QUOTA, 0);
                    GenerateQueueProperties();
                    this.queueSize = (long)((uint)properties.GetUI4(NativeMethods.QUEUE_PROPID_QUOTA));
                    PropertyFilter.MaximumQueueSize = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_QUOTA);
                }

                return this.queueSize;
            }

            set {
                if (value > InfiniteQueueSize || value < 0)
                    throw new ArgumentException(Res.GetString(Res.InvalidProperty, "MaximumQueueSize", value));            

                Properties.SetUI4(NativeMethods.QUEUE_PROPID_QUOTA, (int)((uint)value));
                SaveQueueProperties();
                this.queueSize = value;
                PropertyFilter.MaximumQueueSize = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_QUOTA);
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.MessageReadPropertyFilter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the property filter for
        ///       receiving messages.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Content), MessagingDescription(Res.MQ_MessageReadPropertyFilter)]
        public MessagePropertyFilter MessageReadPropertyFilter {
            get {
                if (this.receiveFilter == null) {
                    this.receiveFilter = new MessagePropertyFilter();
                    this.receiveFilter.SetDefaults();
                }

                return this.receiveFilter;
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                this.receiveFilter = value;
            }
        }

        internal MQCacheableInfo MQInfo {
            get {
                if (mqInfo == null) {
                    MQCacheableInfo cachedInfo = (MQCacheableInfo)queueInfoCache.Get(FormatName);                    
                    if (sharedMode == NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE || !enableConnectionCache) {
                        if (cachedInfo != null)
                            cachedInfo.CloseIfNotReferenced();
                            
                        // don't use the cache
                        mqInfo = new MQCacheableInfo(this.FormatName, sharedMode);
                        mqInfo.AddRef();
                    } else {
                        // use the cache                        
                        if (cachedInfo != null) {
                            cachedInfo.AddRef();
                            mqInfo = cachedInfo;                            
                        }                            
                        else {                            
                            mqInfo = new MQCacheableInfo(this.FormatName, sharedMode);
                            mqInfo.AddRef();
                            queueInfoCache.Put(FormatName, mqInfo);
                        }
                    }
                }
                
                return mqInfo;  
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Path"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the queue's path. When setting the <see cref='System.Messaging.MessageQueue.Path'/>, this points the <see cref='System.Messaging.MessageQueue'/>
        ///       to a new queue.
        ///    </para>
        /// </devdoc>         
        [Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),
         RecommendedAsConfigurable(true), 
         Browsable(false), 
         DefaultValueAttribute(""), 
         TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
         MessagingDescription(Res.MQ_Path)]
        public string Path {
            get {
                return this.path;
            }

            set {                
                if (value == null)
                    value = String.Empty;

                if (!ValidatePath(value, false))
                    throw new ArgumentException(Res.GetString(Res.PathSyntax));

                if (this.path != "")
                    this.Close();

                this.path = value;
            }
        }
                
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Properties"]/*' />
        /// <internalonly/>
        private QueuePropertyVariants Properties {
            get {
                if (this.properties == null)
                    this.properties = new QueuePropertyVariants();

                return this.properties;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.PropertyFilter"]/*' />
        /// <internalonly/>
        private QueuePropertyFilter PropertyFilter{
            get {
                if (this.filter == null)
                    this.filter = new QueuePropertyFilter();

                return this.filter;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.QueueName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the friendly
        ///       name that identifies the queue.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_QueueName)]
        public string QueueName {
            get {
                string queuePath = QueuePath;
                if (queuePath.Length == 0) {
                    return queuePath;
                }
                return  queuePath.Substring(queuePath.IndexOf('\\') + 1);
            }

            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                StringBuilder newPath = new StringBuilder();
                if ((this.path == null || this.path == "") && this.formatName == null) {
                    newPath.Append(".\\");
                    newPath.Append(value);
                }
                else {
                    newPath.Append(MachineName);
                    newPath.Append("\\");
                    newPath.Append(value);
                }
                Path =  newPath.ToString();
            }
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.QueuePath"]/*' />
        /// <internalonly/>
        internal string QueuePath{
            get {
                if (this.queuePath == null) {
                    if (this.path == null || this.path == "") {
                        return string.Empty;
                    }

                    string pathUpper = this.path.ToUpper(CultureInfo.InvariantCulture);
                    if (pathUpper.StartsWith(PREFIX_LABEL)) {
                        MessageQueue labeledQueue = ResolveQueueFromLabel(this.path, true);                                
                        this.formatName = labeledQueue.FormatName;
                        this.queuePath = labeledQueue.QueuePath;
                    }                        
                    else if (pathUpper.StartsWith(PREFIX_FORMAT_NAME)) {
                        Properties.SetNull(NativeMethods.QUEUE_PROPID_PATHNAME);
                        GenerateQueueProperties();
                        string description = null;
                        IntPtr handle = (INTPTR_INTPTRCAST)Properties.GetUI4(NativeMethods.QUEUE_PROPID_PATHNAME);
                        if (handle != (IntPtr)0) {
                            //Using Unicode API even on Win9x
                            description = Marshal.PtrToStringUni(handle);
                            //MSMQ allocated memory for this operation, needs to be freed
                            SafeNativeMethods.MQFreeMemory(handle);
                        }
                        Properties.Remove(NativeMethods.QUEUE_PROPID_PATHNAME);
                        this.queuePath =  description;
                    }
                    else
                        this.queuePath = path;
                }
                return this.queuePath;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReadHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The native handle used to receive messages from the message queue
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_ReadHandle)]
        public IntPtr ReadHandle {
            get {
                if (!receiveGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Receive, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                    
                    receiveGranted = true;                    
                }
                
                return MQInfo.ReadHandle;
            }
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SynchronizingObject"]/*' />
        /// <devdoc>
        ///   Represents the object used to marshal the event handler
        ///   calls issued as a result of a BeginReceive or BeginPeek
        ///  request into a specific thread. Normally this property will 
        ///  be set when the component is placed inside a control or
        ///  a from, since those components are bound to a specific
        ///  thread.
        /// </devdoc>
        [Browsable(false), DefaultValue(null), MessagingDescription(Res.MQ_SynchronizingObject)]
        public ISynchronizeInvoke SynchronizingObject {
            get {
                if (this.synchronizingObject == null && DesignMode) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        object baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is ISynchronizeInvoke)
                            this.synchronizingObject = (ISynchronizeInvoke)baseComponent;
                    }
                }

                return this.synchronizingObject;
            }

            set {
                this.synchronizingObject = value;
            }
        }  

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Transactional"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether the queue supports transactions.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_Transactional)]
        public bool Transactional {
            get {
                if (!browseGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                
                    browseGranted = true;                   
                }
                                    
                return MQInfo.Transactional;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.UseJournalQueue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether retrieved messages are copied to the
        ///       journal queue.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_UseJournalQueue)]
        public bool UseJournalQueue {
            get {
                if (!PropertyFilter.UseJournalQueue) {
                    Properties.SetUI1(NativeMethods.QUEUE_PROPID_JOURNAL, (byte)0);
                    GenerateQueueProperties();
                    this.useJournaling = (Properties.GetUI1(NativeMethods.QUEUE_PROPID_JOURNAL) != NativeMethods.QUEUE_JOURNAL_NONE);
                    PropertyFilter.UseJournalQueue = true;
                    Properties.Remove(NativeMethods.QUEUE_PROPID_JOURNAL);
                }
                return this.useJournaling;
            }

            set {
                if (value)
                    Properties.SetUI1(NativeMethods.QUEUE_PROPID_JOURNAL, (byte)NativeMethods.QUEUE_JOURNAL_JOURNAL);
                else
                    Properties.SetUI1(NativeMethods.QUEUE_PROPID_JOURNAL, (byte)NativeMethods.QUEUE_JOURNAL_NONE);

                SaveQueueProperties();
                this.useJournaling = value;
                PropertyFilter.UseJournalQueue = true;
                Properties.Remove(NativeMethods.QUEUE_PROPID_JOURNAL);
            }
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.WriteHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The native handle used to send messages to the message queue
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.MQ_WriteHandle)]
        public IntPtr WriteHandle {
            get {
                if (!sendGranted) {                    
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Send, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                        
                    sendGranted = true;                                    
                }
                                    
                return MQInfo.WriteHandle;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.PeekCompleted"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a message is read without being removed
        ///       from the queue. This is a result of the asynchronous operation, <see cref='System.Messaging.MessageQueue.BeginPeek'/>
        ///       .</para>
        /// </devdoc>
        [MessagingDescription(Res.MQ_PeekCompleted)]
        public event PeekCompletedEventHandler PeekCompleted {
            add {
                if (!peekGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Peek, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                                                        
                    peekGranted = true; 
                }   
                             
                onPeekCompleted += value;
            }
            remove {
                onPeekCompleted -= value;
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveCompleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a message has been taken out of the queue.
        ///       This is a result of the asynchronous operation <see cref='System.Messaging.MessageQueue.BeginReceive'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [MessagingDescription(Res.MQ_ReceiveCompleted)]
        public event ReceiveCompletedEventHandler ReceiveCompleted {
            add {
                if (!receiveGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Receive, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                    
                    receiveGranted = true;                    
                }

                onReceiveCompleted += value;
            }
            remove {
                onReceiveCompleted -= value;
            }
        }                

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginPeek"]/*' />
        /// <devdoc>
        ///    <para>Initiates an asynchronous peek operation with no timeout. The method 
        ///       returns immediately, but the asynchronous operation is not completed until
        ///       the event handler is called. This occurs when a message is
        ///       available in the
        ///       queue.</para>
        /// </devdoc>
        public IAsyncResult BeginPeek() {
            return ReceiveAsync(InfiniteTimeout, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, null, null);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginPeek1"]/*' />
        /// <devdoc>
        ///    <para> Initiates an asynchronous peek operation with the timeout specified. 
        ///       The method returns immediately, but the asynchronous operation is not completed until
        ///       the event handler is called. This occurs when either a message is available in
        ///       the queue or the timeout
        ///       expires.</para>
        /// </devdoc>
        public IAsyncResult BeginPeek(TimeSpan timeout) {
            return ReceiveAsync(timeout, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, null, null);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginPeek2"]/*' />
        /// <devdoc>
        ///    <para> Initiates an asynchronous peek operation with a state object that associates 
        ///       information with the operation throughout the operation's
        ///       lifetime. The method returns immediately, but the asynchronous operation is not completed
        ///       until the event handler
        ///       is called. This occurs when either a message is available in the
        ///       queue or the timeout
        ///       expires.</para>
        /// </devdoc>
        public IAsyncResult BeginPeek(TimeSpan timeout, object stateObject) {
            return ReceiveAsync(timeout, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, null, stateObject);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginPeek3"]/*' />
        /// <devdoc>
        ///    <para> Initiates an asynchronous peek operation that receives 
        ///       notification through a callback which identifies the event handling method for the
        ///       operation. The method returns immediately, but the asynchronous operation is not completed
        ///       until the event handler is called. This occurs when either a message is available
        ///       in the queue or the timeout
        ///       expires.</para>
        /// </devdoc>
        public IAsyncResult BeginPeek(TimeSpan timeout, object stateObject, AsyncCallback callback) {
            return ReceiveAsync(timeout, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, callback, stateObject);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue
        ///       referenced by the <see cref='System.Messaging.MessageQueue'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public IAsyncResult BeginReceive() {
            return ReceiveAsync(InfiniteTimeout, NativeMethods.QUEUE_ACTION_RECEIVE, null, null);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginReceive1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue
        ///       referenced by the <see cref='System.Messaging.MessageQueue'/> . Waits the specified interval for
        ///       the message to be
        ///       removed.
        ///    </para>
        /// </devdoc>
        public IAsyncResult BeginReceive(TimeSpan timeout) {
            return ReceiveAsync(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, null, null);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginReceive2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue
        ///       referenced by the <see cref='System.Messaging.MessageQueue'/> . Waits the specified interval
        ///       for a new message to be removed and uses the specified object to retrieve
        ///       the result.
        ///    </para>
        /// </devdoc>
        public IAsyncResult BeginReceive(TimeSpan timeout, object stateObject) {
            return ReceiveAsync(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, null, stateObject);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.BeginReceive3"]/*' />
        /// <devdoc>
        ///    <para>Receives the first message available in the queue
        ///       referenced by the <see cref='System.Messaging.MessageQueue'/> . Waits
        ///       the specified interval for a new message to be removed, uses the specified
        ///       object to retrieve the result, and receives notification through a
        ///       callback.</para>
        /// </devdoc>
        public IAsyncResult BeginReceive(TimeSpan timeout, object stateObject, AsyncCallback callback) {
            return ReceiveAsync(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, callback, stateObject);
        } 

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ClearConnectionCache"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void ClearConnectionCache() {
            formatNameCache.ClearStale(new TimeSpan(0));
            queueInfoCache.ClearStale(new TimeSpan(0));
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Frees all resources allocated by the <see cref='System.Messaging.MessageQueue'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public void Close() {
            //This is generated from the path.
            //It needs to be cleared.            
            this.formatName = null;
            this.queuePath = null;   
            this.attached = false;            
            this.administerGranted = false;
            this.browseGranted = false;
            this.sendGranted = false;
            this.receiveGranted = false;
            this.peekGranted = false;                                     
            
            if (this.mqInfo != null) {
                this.mqInfo.Release();
                
                //No need to check references in this case, the only object
                //mqInfo is not cached if both conditions are satisified.
                if (sharedMode == NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE || !enableConnectionCache) 
                    this.mqInfo.Dispose();
                    
                this.mqInfo = null;                
            }                            
        }        

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Create"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates
        ///       a nontransactional Message Queuing backend queue resource with the
        ///       specified path.
        ///    </para>
        /// </devdoc>
        public static MessageQueue Create(string path) {
            return MessageQueue.Create(path, false);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Create1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates
        ///       a transactional or nontransactional Message Queuing backend queue resource with the
        ///       specified path.
        ///    </para>
        /// </devdoc>
        public static MessageQueue Create(string path, bool transactional) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            if (path == "")
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "path", path));
                                 
            if (!IsCanonicalPath(path, true))
                throw new ArgumentException(Res.GetString(Res.InvalidQueuePathToCreate, path));
                
            MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Administer, MessageQueuePermission.Any);
            permission.Demand(); 

            //Create properties.
            QueuePropertyVariants properties = new QueuePropertyVariants();
            properties.SetString(NativeMethods.QUEUE_PROPID_PATHNAME, Message.StringToBytes(path));
            if (transactional)
                properties.SetUI1(NativeMethods.QUEUE_PROPID_TRANSACTION, (byte)NativeMethods.QUEUE_TRANSACTIONAL_TRANSACTIONAL);
            else
                properties.SetUI1(NativeMethods.QUEUE_PROPID_TRANSACTION,  (byte)NativeMethods.QUEUE_TRANSACTIONAL_NONE);

            StringBuilder formatName = new StringBuilder(NativeMethods.MAX_LABEL_LEN);
            int formatNameLen = NativeMethods.MAX_LABEL_LEN;
            int status =0;

            //Try to create queue.
            status = UnsafeNativeMethods.MQCreateQueue((IntPtr)0, properties.Lock(), formatName, ref formatNameLen);
            properties.Unlock();
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);

            return new MessageQueue(path);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.CreateMessageQueuesSnapshot"]/*' />
        ///    <internalonly/>
        private static MessageQueue[] CreateMessageQueuesSnapshot(MessageQueueCriteria criteria) {
            return  CreateMessageQueuesSnapshot(criteria, true);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.CreateMessageQueuesSnapshot1"]/*' />
        ///    <internalonly/>
        private static MessageQueue[] CreateMessageQueuesSnapshot(MessageQueueCriteria criteria, bool checkSecurity) {
            ArrayList messageQueuesList = new ArrayList();
            IEnumerator messageQueues = GetMessageQueueEnumerator(criteria, checkSecurity);
            while (messageQueues.MoveNext()) {
                MessageQueue messageQueue = (MessageQueue)messageQueues.Current;                                        
                messageQueuesList.Add(messageQueue);                    
            }                                    

            MessageQueue[] queues = new MessageQueue[messageQueuesList.Count];
            messageQueuesList.CopyTo(queues, 0);
            return queues;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Delete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes a queue backend resource identified by
        ///       the given path.
        ///    </para>
        /// </devdoc>
        public static void Delete(string path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            if (path == "")
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "path", path));

            if (!ValidatePath(path, false))
                throw new ArgumentException(Res.GetString(Res.PathSyntax));

            int status = 0;
            MessageQueue queue = new MessageQueue(path);
            MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Administer, PREFIX_FORMAT_NAME + queue.FormatName);
            permission.Demand();
                
            status = UnsafeNativeMethods.MQDeleteQueue(queue.FormatName);
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);

            queueInfoCache.Remove(queue.FormatName);
            formatNameCache.Remove(path);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            //This is generated from the path.
            //It needs to be cleared.            
            this.formatName = null;
            this.queuePath = null;   
            this.attached = false;            
            this.administerGranted = false;
            this.browseGranted = false;
            this.sendGranted = false;
            this.receiveGranted = false;
            this.peekGranted = false;                                     

            if (disposing) {
                if (this.mqInfo != null) {
                    this.mqInfo.Release();
                    
                    //No need to check references in this case, the only object
                    //mqInfo is not cached if both conditions are satisified.
                    if (sharedMode == NativeMethods.QUEUE_SHARED_MODE_DENY_RECEIVE || !enableConnectionCache) 
                        this.mqInfo.Dispose();
                        
                    this.mqInfo = null;                
                }                
            }

            base.Dispose(disposing);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.EndPeek"]/*' />
        /// <devdoc>
        ///    <para>Completes an asynchronous peek operation associated with 
        ///       the <paramref name="asyncResult"/>
        ///       parameter.</para>
        /// </devdoc>
        public Message EndPeek(IAsyncResult asyncResult) {
            if (asyncResult == null)
                throw new ArgumentNullException("asyncResult");

            if (!(asyncResult is AsynchronousRequest))
                throw new ArgumentException(Res.GetString(Res.AsyncResultInvalid));

            AsynchronousRequest request = (AsynchronousRequest)asyncResult;                                     
            return request.End();
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.EndReceive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Terminates a receive asynchronous operation identified
        ///       by the specified interface.
        ///    </para>
        /// </devdoc>
        public Message EndReceive(IAsyncResult asyncResult) {
            if (asyncResult == null)
                throw new ArgumentNullException("asyncResult");

            if (!(asyncResult is AsynchronousRequest))
                throw new ArgumentException(Res.GetString(Res.AsyncResultInvalid));

            AsynchronousRequest request = (AsynchronousRequest)asyncResult;                         
            return request.End();
        } 

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Exists"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether a queue with the specified path
        ///       exists.
        ///    </para>
        /// </devdoc>
        public static bool Exists(string path) {
            if (path == null)
                throw new ArgumentNullException("path");
                                                    
            if (!ValidatePath(path, false))
                throw new ArgumentException(Res.GetString(Res.PathSyntax));                                                    
                                                    
            MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, MessageQueuePermission.Any);
            permission.Demand();
                                   
            string pathUpper = path.ToUpper(CultureInfo.InvariantCulture);                
            if (pathUpper.StartsWith(PREFIX_FORMAT_NAME))
                throw new InvalidOperationException(Res.GetString(Res.QueueExistsError));
            else if (pathUpper.StartsWith(PREFIX_LABEL)) {
                MessageQueue labeledQueue = ResolveQueueFromLabel(path, false);
                if (labeledQueue == null)
                    return false;
                else
                    return true;                                    
            }                            
            else {
                string formatName = ResolveFormatNameFromQueuePath(path, false);
                if (formatName == null)
                    return false;
                else
                    return true;                                    
            }                                    
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GenerateQueueProperties"]/*' />
        /// <internalonly/>
        private void GenerateQueueProperties() {
            if (!browseGranted) {
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
            
                browseGranted = true;                   
            }
            
            int status = UnsafeNativeMethods.MQGetQueueProperties(FormatName, Properties.Lock());
            Properties.Unlock();
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);
        }       

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetAllMessages"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns all the messages available in the queue.
        ///    </para>
        /// </devdoc>
        public Message[] GetAllMessages() {
            ArrayList messageList = new ArrayList();            
            MessageEnumerator messages = GetMessageEnumerator();
            while (messages.MoveNext()) {
                Message message = (Message)messages.Current;                
                messageList.Add(message);                
            }

            Message[] resultMessages = new Message[messageList.Count];
            messageList.CopyTo(resultMessages, 0);
            return resultMessages;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return GetMessageEnumerator();
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetMachineId"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Guid GetMachineId(string machineName) {           
             if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "MachineName", machineName));          

            if (machineName == ".")
                machineName = MessageQueue.ComputerName;

            MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, MessageQueuePermission.Any);            
            permission.Demand(); 

            MachinePropertyVariants machineProperties = new MachinePropertyVariants();
            byte[] bytes = new byte[16];
            machineProperties.SetNull(NativeMethods.MACHINE_ID);            
            int status = UnsafeNativeMethods.MQGetMachineProperties(machineName, (IntPtr)0, machineProperties.Lock());
            machineProperties.Unlock();            
            IntPtr handle = (INTPTR_INTPTRCAST)machineProperties.GetUI4(NativeMethods.MACHINE_ID);
            if (MessageQueue.IsFatalError(status)) {
                if (handle != (IntPtr)0)
                    SafeNativeMethods.MQFreeMemory(handle);

                throw new MessageQueueException(status);
            }
            
            if (handle != (IntPtr)0) {
                Marshal.Copy(handle, bytes, 0 ,16);
                SafeNativeMethods.MQFreeMemory(handle);
            }

            return new Guid(bytes);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetMessageQueueEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an enumerator object for the message queues
        ///       available on the network.
        ///    </para>
        /// </devdoc>
        public static MessageQueueEnumerator GetMessageQueueEnumerator() {
            return new MessageQueueEnumerator(null);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetMessageQueueEnumerator1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an enumerator object for the message queues
        ///       available on the network.
        ///    </para>
        /// </devdoc>
        public static MessageQueueEnumerator GetMessageQueueEnumerator(MessageQueueCriteria criteria) {
            return new MessageQueueEnumerator(criteria);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetMessageQueueEnumerator2"]/*' />
        /// <internalonly/>
         internal static MessageQueueEnumerator GetMessageQueueEnumerator(MessageQueueCriteria criteria, bool checkSecurity) {
            return new MessageQueueEnumerator(criteria, checkSecurity);
        }
                                                      
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetMessageEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an enumerator object for the messages contained
        ///       in the
        ///       queue.
        ///    </para>
        /// </devdoc>
        public MessageEnumerator GetMessageEnumerator() {
            if (!peekGranted) {
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Peek, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
                                                    
                peekGranted = true; 
            }
            
            return new MessageEnumerator(this);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPrivateQueuesByMachine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves all the private queues on
        ///       the specified computer.
        ///    </para>
        /// </devdoc>
        public static MessageQueue[] GetPrivateQueuesByMachine(string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "MachineName", machineName));          

            MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, MessageQueuePermission.Any);            
            permission.Demand(); 

            if (machineName == "." || (String.Compare(machineName, MessageQueue.ComputerName, true, CultureInfo.InvariantCulture) == 0))
                machineName = null;

            MessagePropertyVariants properties = new MessagePropertyVariants(5, 0);
            properties.SetNull(NativeMethods.MANAGEMENT_PRIVATEQ);
            int status = UnsafeNativeMethods.MQMgmtGetInfo(machineName, "MACHINE", properties.Lock());
            properties.Unlock();
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);

            int len = properties.GetStringVectorLength(NativeMethods.MANAGEMENT_PRIVATEQ);
            IntPtr basePointer = properties.GetStringVectorBasePointer(NativeMethods.MANAGEMENT_PRIVATEQ);
            MessageQueue[] queues = new MessageQueue[len];
            for (int index = 0; index < len; ++index) {
                IntPtr stringPointer = (INTPTR_INTPTRCAST)Marshal.ReadInt32((IntPtr)((long)basePointer + index * 4));
                //Using Unicode API even on Win9x
                string path = Marshal.PtrToStringUni(stringPointer);
                queues[index] = new MessageQueue("FormatName:DIRECT=OS:" + path);
                queues[index].queuePath = path; 
                SafeNativeMethods.MQFreeMemory(stringPointer);
            }

            SafeNativeMethods.MQFreeMemory(basePointer);
            return queues;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPublicQueues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves all public queues on the network.
        ///    </para>
        /// </devdoc>
        public static MessageQueue[] GetPublicQueues() {
            return CreateMessageQueuesSnapshot(null);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPublicQueues1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a
        ///       set of public queues filtered by the specified criteria.
        ///    </para>
        /// </devdoc>
        public static MessageQueue[] GetPublicQueues(MessageQueueCriteria criteria) {
            return CreateMessageQueuesSnapshot(criteria);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPublicQueuesByCategory"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a
        ///       set of public queues filtered by the specified category.
        ///    </para>
        /// </devdoc>
        public static MessageQueue[] GetPublicQueuesByCategory(Guid category) {
            MessageQueueCriteria criteria = new MessageQueueCriteria();
            criteria.Category = category;
            return CreateMessageQueuesSnapshot(criteria);
        }
                                                                 
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPublicQueuesByLabel"]/*' />
        /// <devdoc>
        ///    <para>                                                                                                                   
        ///       Retrieves a
        ///       set of public queues filtered by the specified label.
        ///    </para>
        /// </devdoc>
        public static MessageQueue[] GetPublicQueuesByLabel(string label) {
            return GetPublicQueuesByLabel(label, true);
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPublicQueuesByLabel1"]/*' />
        /// <internalonly/>
        private static MessageQueue[] GetPublicQueuesByLabel(string label, bool checkSecurity) {
            MessageQueueCriteria criteria = new MessageQueueCriteria();
            criteria.Label = label;
            return CreateMessageQueuesSnapshot(criteria, checkSecurity);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.GetPublicQueuesByMachine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves all public queues on the specified computer.
        ///    </para>
        /// </devdoc>
        public static MessageQueue[] GetPublicQueuesByMachine(string machineName) {                        
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "MachineName", machineName));          
            
            MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Browse, MessageQueuePermission.Any);            
            permission.Demand(); 
                        
            try {
                DirectoryServicesPermission dsPermission = new DirectoryServicesPermission(PermissionState.Unrestricted);
                dsPermission.Assert();
                                                
                DirectorySearcher localComputerSearcher = new DirectorySearcher(String.Format("(&(CN={0})(objectCategory=Computer))", ComputerName));                                                    
                SearchResult localComputer = localComputerSearcher.FindOne();  
                if (localComputer != null) {
                    DirectorySearcher localComputerMsmqSearcher = new DirectorySearcher(localComputer.GetDirectoryEntry());            
                    localComputerMsmqSearcher.Filter = "(CN=msmq)";
                    SearchResult localMsmqNode = localComputerMsmqSearcher.FindOne(); 
                    SearchResult remoteMsmqNode = null;
                    if (localMsmqNode != null) {    
                        if (machineName != "." && String.Compare(machineName, ComputerName, true, CultureInfo.InvariantCulture) != 0) {                                                                           
                            DirectorySearcher remoteComputerSearcher = new DirectorySearcher(String.Format("(&(CN={0})(objectCategory=Computer))", machineName));                                                    
                            SearchResult remoteComputer = remoteComputerSearcher.FindOne();  
                            if (remoteComputer == null) 
                                return new MessageQueue[0];    
                        
                            DirectorySearcher remoteComputerMsmqSearcher = new DirectorySearcher(remoteComputer.GetDirectoryEntry());            
                            remoteComputerMsmqSearcher.Filter = "(CN=msmq)";
                            remoteMsmqNode = remoteComputerMsmqSearcher.FindOne(); 
                            if (remoteMsmqNode == null)                     
                                return new MessageQueue[0];    
                        }
                        else
                            remoteMsmqNode = localMsmqNode;
                                                                                                    
                        DirectorySearcher objectsSearcher = new DirectorySearcher(remoteMsmqNode.GetDirectoryEntry());            
                        objectsSearcher.Filter = "(objectClass=mSMQQueue)";
                        objectsSearcher.PropertiesToLoad.Add("Name");
                        SearchResultCollection objects = objectsSearcher.FindAll(); 
                        MessageQueue[] queues = new MessageQueue[objects.Count];
                        for (int index = 0; index < queues.Length; ++ index) {
                           string queueName = (string)objects[index].Properties["Name"][0];
                           queues[index] = new MessageQueue(String.Format("{0}\\{1}", machineName, queueName));        
                        }                       
                           
                        return queues;                                                                                                                                                                                                                                                                                                                     
                    }                                                                                                                                                    
                }                                                                                                                                                                                                                                                   
            }   
            catch (Exception) {
                    //Ignore Exceptions, so we can gracefully downgrade to use MQ locator.
            }         
            finally {
                DirectoryServicesPermission.RevertAssert();                    
            }                
                        
            MessageQueueCriteria criteria = new MessageQueueCriteria();
            criteria.MachineName = machineName;
            return CreateMessageQueuesSnapshot(criteria, false);                    
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.IsCanonicalPath"]/*' />
        /// <internalonly/>
        private static bool IsCanonicalPath(string path, bool checkQueueNameSize) {
            if (!ValidatePath(path, checkQueueNameSize))
                return false;

            string upperPath = path.ToUpper(CultureInfo.InvariantCulture);
            if (upperPath.StartsWith(PREFIX_LABEL) ||
                upperPath.StartsWith(PREFIX_FORMAT_NAME) ||
                upperPath.EndsWith(SUFIX_DEADLETTER) ||
                upperPath.EndsWith(SUFIX_DEADXACT) ||
                upperPath.EndsWith(SUFIX_JOURNAL))
                return false;

            return true;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.IsFatalError"]/*' />
        /// <internalonly/>                           
        internal static bool IsFatalError(int value) {
            bool isSuccessful = (value == 0x00000000);
            bool isInformation =  ((value & unchecked((int)0xC0000000)) == 0x40000000);
            return (!isInformation && !isSuccessful);
        }        

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.IsMemoryError"]/*' />
        /// <internalonly/>                           
        internal static bool IsMemoryError(int value) {
            if (value == (int)MessageQueueErrorCode.BufferOverflow ||
                 value == (int)MessageQueueErrorCode.LabelBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.ProviderNameBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.SenderCertificateBufferTooSmall||
                 value == (int)MessageQueueErrorCode.SenderIdBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.SecurityDescriptorBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.SignatureBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.SymmetricKeyBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.UserBufferTooSmall ||
                 value == (int)MessageQueueErrorCode.FormatNameBufferTooSmall)
                return true;

            return false;
        }
                                   
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.OnRequestCompleted"]/*' />
        /// <devdoc>
        ///    Used for component model event support. 
        /// </devdoc>        
        /// <internalonly/>
        private void OnRequestCompleted(IAsyncResult asyncResult) {
            if (((AsynchronousRequest)asyncResult).Action == NativeMethods.QUEUE_ACTION_PEEK_CURRENT) {
                if (this.onPeekCompleted != null) {
                    PeekCompletedEventArgs eventArgs = new PeekCompletedEventArgs(this, asyncResult);                
                    this.onPeekCompleted(this, eventArgs);
                }
            }
            else {
                if (this.onReceiveCompleted != null) {
                    ReceiveCompletedEventArgs eventArgs = new ReceiveCompletedEventArgs(this, asyncResult);                
                    this.onReceiveCompleted(this, eventArgs);
                }
            }
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Peek"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns without removing (peeks) the first message
        ///       available in the queue referenced by the <see cref='System.Messaging.MessageQueue'/> . This call
        ///       is synchronous. It
        ///       blocks the current
        ///       thread of execution until a message is
        ///       available.
        ///    </para>
        /// </devdoc>
        public Message Peek() {
            return ReceiveCurrent(InfiniteTimeout, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, (IntPtr)0, MessageReadPropertyFilter, null, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Peek1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns without removing (peeks) the first message
        ///       available in the queue referenced by the <see cref='System.Messaging.MessageQueue'/>
        ///       . Waits
        ///       the specified interval for a message to become
        ///       available.
        ///    </para>
        /// </devdoc>
        public Message Peek(TimeSpan timeout) {
            return ReceiveCurrent(timeout, NativeMethods.QUEUE_ACTION_PEEK_CURRENT, (IntPtr)0, MessageReadPropertyFilter, null, MessageQueueTransactionType.None);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.PeekById"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Peeks the message that matches the given ID.
        ///       If there is no message with a matching ID,
        ///       an exception will be raised.
        ///    </para>
        /// </devdoc>
        public Message PeekById(string id) {
            return ReceiveBy(id, TimeSpan.Zero, false, true, false, null, MessageQueueTransactionType.None);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.PeekById1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Peeks the message that matches the
        ///       given ID. This method waits until a message with
        ///       a matching ID is available, or the given timeout
        ///       expires when no more messages can be
        ///       inspected.
        ///    </para>
        /// </devdoc>
        public Message PeekById(string id, TimeSpan timeout) {
            return ReceiveBy(id, timeout, false, true, true, null, MessageQueueTransactionType.None);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.PeekByCorrelationId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Peeks the message that matches the
        ///       given correlation ID. If there is no message with
        ///       a matching correlation ID, an exception is
        ///       thrown.
        ///    </para>
        /// </devdoc>
        public Message PeekByCorrelationId(string correlationId) {
            return ReceiveBy(correlationId, TimeSpan.Zero, false, false, false, null, MessageQueueTransactionType.None);
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.PeekByCorrelationId1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Peeks the message that matches the
        ///       given correlation ID. This function will wait
        ///       until a message with a matching correlation ID is
        ///       available, or the given timeout expires when
        ///       no more messages can be inspected.
        ///    </para>
        /// </devdoc>
        public Message PeekByCorrelationId(string correlationId, TimeSpan timeout) {
            return ReceiveBy(correlationId, timeout, false, false, true, null, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Purge"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes all the messages contained in the queue.
        ///    </para>
        /// </devdoc>
        public void Purge() {
           if (!receiveGranted) {
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Receive, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
                
                receiveGranted = true;                    
            }
                
        
            int status = StaleSafePurgeQueue();
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Receive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue referenced by the <see cref='System.Messaging.MessageQueue'/> . This
        ///       call is synchronous. It blocks the current thread of execution until a message is
        ///       available.
        ///    </para>
        /// </devdoc>
        public Message Receive() {
            return ReceiveCurrent(InfiniteTimeout, NativeMethods.QUEUE_ACTION_RECEIVE, (IntPtr)0, MessageReadPropertyFilter, null, MessageQueueTransactionType.None);
        }
 
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Receive1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue referenced by the <see cref='System.Messaging.MessageQueue'/> . This
        ///       call is synchronous. It blocks the current thread of execution until a message is
        ///       available.
        ///    </para>
        /// </devdoc>
        public Message Receive(MessageQueueTransaction transaction) {
            if (transaction == null)
                throw new ArgumentNullException("transaction");
                
            return ReceiveCurrent(InfiniteTimeout, NativeMethods.QUEUE_ACTION_RECEIVE, (IntPtr)0, MessageReadPropertyFilter, transaction, MessageQueueTransactionType.None);                                 
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Receive5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message Receive(MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
                
            return ReceiveCurrent(InfiniteTimeout, NativeMethods.QUEUE_ACTION_RECEIVE, (IntPtr)0, MessageReadPropertyFilter, null, transactionType);                                 
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Receive2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue
        ///       referenced by the <see cref='System.Messaging.MessageQueue'/>
        ///       . Waits the specified interval for a message to become
        ///       available.
        ///    </para>
        /// </devdoc>
        public Message Receive(TimeSpan timeout) {
            return ReceiveCurrent(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, (IntPtr)0, MessageReadPropertyFilter, null, MessageQueueTransactionType.None);
        }
         
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Receive3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the first message available in the queue
        ///       referenced by the <see cref='System.Messaging.MessageQueue'/>
        ///       . Waits the specified interval for a message to become
        ///       available.
        ///    </para>
        /// </devdoc>
        public Message Receive(TimeSpan timeout, MessageQueueTransaction transaction) {
            if (transaction == null)
                throw new ArgumentNullException("transaction");
                    
            return ReceiveCurrent(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, (IntPtr)0, MessageReadPropertyFilter, transaction, MessageQueueTransactionType.None);                                                       
        }         


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Receive4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message Receive(TimeSpan timeout, MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
                
            return ReceiveCurrent(timeout, NativeMethods.QUEUE_ACTION_RECEIVE, (IntPtr)0, MessageReadPropertyFilter, null, transactionType);                                                                       
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveAsync"]/*' />
        /// <internalonly/>
        private unsafe IAsyncResult ReceiveAsync(TimeSpan timeout, int action, AsyncCallback callback, object stateObject) {
            long timeoutInMilliseconds = (long)timeout.TotalMilliseconds;
            if (timeoutInMilliseconds < 0 || timeoutInMilliseconds > UInt32.MaxValue)
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "timeout", timeout.ToString()));          

            if (action == NativeMethods.QUEUE_ACTION_RECEIVE) {
                if (!receiveGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Receive, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                    
                    receiveGranted = true;                    
                }
             } 
             else {
                if (!peekGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Peek, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                                                        
                    peekGranted = true; 
                } 
            }                  
                                            
            if (!attached) {
                lock (this) {
                    if (!attached) {
                        IntPtr handle = MQInfo.ReadHandle;
                        int handleInformation;
                        // If GetHandleInformation returns false, it means that the 
                        // handle created for reading is not a File handle.
                        if (!SafeNativeMethods.GetHandleInformation(handle, out handleInformation)) 
                             // If not a File handle, need to use MSMQ
                            // APC based async IO.
                            this.useThreadPool = false;
                        else {
                            // File handle can use IOCompletion ports
                            // since it only happens for NT
                            MQInfo.BindToThreadPool();
                            this.useThreadPool = true;
                        }                                    
                        attached = true;                                                            
                    }
                }
            }

            if (callback == null) {
                if (this.onRequestCompleted == null)
                    this.onRequestCompleted = new AsyncCallback(this.OnRequestCompleted);

                callback = this.onRequestCompleted;                    
            }

            AsynchronousRequest request = new AsynchronousRequest(this, (uint)timeoutInMilliseconds, action, this.useThreadPool, stateObject, callback);            

            request.BeginRead();
            return(IAsyncResult)request;
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveBy"]/*' />
        /// <internalonly/>
        private Message ReceiveBy(string id, TimeSpan timeout, bool remove, bool compareId, bool throwTimeout, MessageQueueTransaction transaction, MessageQueueTransactionType transactionType) {
            if (id == null)
                throw new ArgumentNullException("id");

            if (timeout < TimeSpan.Zero || timeout > InfiniteTimeout)
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "timeout", timeout.ToString()));          

            MessagePropertyFilter oldFilter = this.receiveFilter;
            try {
                this.receiveFilter = new MessagePropertyFilter();
                this.receiveFilter.ClearAll();
                if (!compareId)
                    this.receiveFilter.CorrelationId = true;
                else
                    this.receiveFilter.Id = true; 
    
                MessageEnumerator messagesEnumerator = GetMessageEnumerator();
                while (messagesEnumerator.MoveNext(timeout)) {
                    Message message = (Message)messagesEnumerator.Current;               
                    if ((compareId && String.Compare(message.Id, id, true, CultureInfo.InvariantCulture) == 0) ||
                        (!compareId && String.Compare(message.CorrelationId, id, true, CultureInfo.InvariantCulture) == 0)) {
                        this.receiveFilter = oldFilter;        
    
                        if (remove) {                    
                            if (transaction == null)
                                return(Message)messagesEnumerator.RemoveCurrent(transactionType);
                            else
                                return(Message)messagesEnumerator.RemoveCurrent(transaction);                                                        
                        }                        
                        else
                            return(Message)messagesEnumerator.Current;                                        
                    }
                }        
            }
            finally {
                this.receiveFilter = oldFilter;        
            }
                            
            if (!throwTimeout)
                throw new InvalidOperationException(Res.GetString("MessageNotFound"));
            else
                throw new MessageQueueException((int)MessageQueueErrorCode.IOTimeout);                                
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveById"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches the given
        ///       ID. If there is no message with a matching
        ///       ID, an exception is thrown.
        ///    </para>
        /// </devdoc>
        public Message ReceiveById(string id) {
            return ReceiveBy(id, TimeSpan.Zero, true, true, false, null, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveById1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches the given
        ///       ID. If there is no message with a matching
        ///       ID, an exception is thrown.
        ///    </para>
        /// </devdoc>
        public Message ReceiveById(string id, MessageQueueTransaction transaction) {
            if (transaction == null) 
                throw new ArgumentNullException("transaction");
                
            return ReceiveBy(id, TimeSpan.Zero, true, true, false, transaction, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveById5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches the given
        ///       ID. If there is no message with a matching
        ///       ID, an exception is thrown.
        ///    </para>
        /// </devdoc>
        public Message ReceiveById(string id, MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
                
            return ReceiveBy(id, TimeSpan.Zero, true, true, false, null, transactionType);
        }
            
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveById2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches the given
        ///       ID. This method waits until a message with
        ///       a matching id is available or the given timeout
        ///       expires when no more messages can be
        ///       inspected.
        ///    </para>
        /// </devdoc>
        public Message ReceiveById(string id, TimeSpan timeout) {
            return ReceiveBy(id, timeout, true, true, true, null, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveById3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches the given
        ///       ID. This method waits until a message with
        ///       a matching id is available or the given timeout
        ///       expires when no more messages can be
        ///       inspected.
        ///    </para>
        /// </devdoc>
        public Message ReceiveById(string id, TimeSpan timeout, MessageQueueTransaction transaction) {
            if (transaction == null) 
                throw new ArgumentNullException("transaction");
            
            return ReceiveBy(id, timeout, true, true, true, transaction, MessageQueueTransactionType.None);
        }                

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveById4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches the given
        ///       ID. This method waits until a message with
        ///       a matching id is available or the given timeout
        ///       expires when no more messages can be
        ///       inspected.
        ///    </para>
        /// </devdoc>
        public Message ReceiveById(string id, TimeSpan timeout, MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
            
            return ReceiveBy(id, timeout, true, true, true, null, transactionType);
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveByCorrelationId"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receivess the message that matches the
        ///       given correlation ID. If there is no message with
        ///       a matching correlation ID, an exception is
        ///       thrown.
        ///    </para>
        /// </devdoc>
        public Message ReceiveByCorrelationId(string correlationId) {
            return ReceiveBy(correlationId, TimeSpan.Zero, true, false, false, null, MessageQueueTransactionType.None);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveByCorrelationId1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receivess the message that matches the
        ///       given correlation ID. If there is no message with
        ///       a matching correlation ID, an exception is
        ///       thrown.
        ///    </para>
        /// </devdoc>
        public Message ReceiveByCorrelationId(string correlationId, MessageQueueTransaction transaction) {
            if (transaction == null) 
                throw new ArgumentNullException("transaction");

            return ReceiveBy(correlationId, TimeSpan.Zero, true, false, false, transaction, MessageQueueTransactionType.None);
        }         

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveByCorrelationId5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receivess the message that matches the
        ///       given correlation ID. If there is no message with
        ///       a matching correlation ID, an exception is
        ///       thrown.
        ///    </para>
        /// </devdoc>
        public Message ReceiveByCorrelationId(string correlationId, MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        

            return ReceiveBy(correlationId, TimeSpan.Zero, true, false, false, null, transactionType);
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveByCorrelationId2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches
        ///       the given correlation ID. This method waits
        ///       until a message with a matching correlation ID is
        ///       available or the given timeout expires when
        ///       no more messages can be inspected.
        ///    </para>
        /// </devdoc>
        public Message ReceiveByCorrelationId(string correlationId, TimeSpan timeout) {
            return ReceiveBy(correlationId, timeout, true, false, true, null, MessageQueueTransactionType.None);
        } 
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveByCorrelationId3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches
        ///       the given correlation ID. This method waits
        ///       until a message with a matching correlation ID is
        ///       available or the given timeout expires when
        ///       no more messages can be inspected.
        ///    </para>
        /// </devdoc>
        public Message ReceiveByCorrelationId(string correlationId, TimeSpan timeout, MessageQueueTransaction transaction) {
            if (transaction == null) 
                throw new ArgumentNullException("transaction");

            return ReceiveBy(correlationId, timeout, true, false, true, transaction, MessageQueueTransactionType.None);
        } 

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveByCorrelationId4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Receives the message that matches
        ///       the given correlation ID. This method waits
        ///       until a message with a matching correlation ID is
        ///       available or the given timeout expires when
        ///       no more messages can be inspected.
        ///    </para>
        /// </devdoc>
        public Message ReceiveByCorrelationId(string correlationId, TimeSpan timeout, MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        

            return ReceiveBy(correlationId, timeout, true, false, true, null, transactionType);
        } 
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ReceiveCurrent"]/*' />
        /// <internalonly/>        
        internal unsafe Message ReceiveCurrent(TimeSpan timeout, int action, IntPtr cursor, MessagePropertyFilter filter, MessageQueueTransaction internalTransaction, MessageQueueTransactionType transactionType) {
            long timeoutInMilliseconds = (long)timeout.TotalMilliseconds;
            if (timeoutInMilliseconds < 0 || timeoutInMilliseconds > UInt32.MaxValue)
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "timeout", timeout.ToString()));          

            if (action == NativeMethods.QUEUE_ACTION_RECEIVE) {
                if (!receiveGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Receive, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                    
                    receiveGranted = true;                    
                }
            } 
            else {
                if (!peekGranted) {
                    MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Peek, PREFIX_FORMAT_NAME + this.FormatName);
                    permission.Demand();
                                                        
                    peekGranted = true; 
                }   
            }                
                                    
            int status = 0;                                    
            Message receiveMessage = null;
            MessagePropertyVariants.MQPROPS lockedReceiveMessage = null;
            if (filter != null) {
                receiveMessage = new Message(filter);                        
                if (this.formatter != null)
                    receiveMessage.Formatter = (IMessageFormatter)this.formatter.Clone();                    
                    
                lockedReceiveMessage = receiveMessage.Lock();
            }
            
            try {
                if (internalTransaction != null)
                    status =  StaleSafeReceiveMessage((uint)timeoutInMilliseconds, action, lockedReceiveMessage, null, null, cursor, internalTransaction.BeginQueueOperation());                           
                else
                    status =  StaleSafeReceiveMessage((uint)timeoutInMilliseconds, action, lockedReceiveMessage, null, null, cursor, (IntPtr)transactionType);
                                                                                           
                if (receiveMessage != null) {
                    //Need to keep trying until enough space has been allocated.
                    //Concurrent scenarions might not succeed on the second retry.
                    while (MessageQueue.IsMemoryError(status)) {
                        receiveMessage.Unlock();
                        receiveMessage.AdjustMemory();
                        lockedReceiveMessage  = receiveMessage.Lock();
                        if (internalTransaction != null)
                            status =  StaleSafeReceiveMessage((uint)timeoutInMilliseconds, action, lockedReceiveMessage, null, null, cursor, internalTransaction.InnerTransaction);
                        else
                            status =  StaleSafeReceiveMessage((uint)timeoutInMilliseconds, action, lockedReceiveMessage, null, null, cursor, (IntPtr)transactionType);
                    }                        
                    
                    receiveMessage.Unlock();         
                }                                                                                                                           
            }
            finally {
                if (internalTransaction != null) 
                    internalTransaction.EndQueueOperation();
            }                
                                                  
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);

            return receiveMessage;
        }        
                                    
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Refresh"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Refreshes the properties presented by the <see cref='System.Messaging.MessageQueue'/>
        ///       to reflect the current state of the
        ///       resource.
        ///    </para>
        /// </devdoc>
        //
        public void Refresh() {
            this.PropertyFilter.ClearAll();
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SaveQueueProperties"]/*' />
        /// <internalonly/>
        private void SaveQueueProperties() {
            if (!administerGranted) {                    
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Administer, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
                
                administerGranted = true;
            }                
            
            int status = UnsafeNativeMethods.MQSetQueueProperties(FormatName, Properties.Lock());
            Properties.Unlock();
            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Send"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends an object to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>
        ///       . The object is serialized
        ///       using the formatter provided.
        ///    </para>
        /// </devdoc>
        public void Send(object obj) {
            SendInternal(obj, null, MessageQueueTransactionType.None);
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Send1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends an object to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>
        ///       . The object is serialized
        ///       using the formatter provided.
        ///    </para>
        /// </devdoc>
        public void Send(object obj, MessageQueueTransaction transaction) {
            if (transaction == null) 
                throw new ArgumentNullException("transaction");

            SendInternal(obj, transaction, MessageQueueTransactionType.None);                            
        }        

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Send5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends an object to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>
        ///       . The object is serialized
        ///       using the formatter provided.
        ///    </para>
        /// </devdoc>
        public void Send(object obj, MessageQueueTransactionType transactionType) {
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
                            
            SendInternal(obj, null, transactionType);            
        }                         
                 
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Send2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends an object to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>.
        ///       The object will be serialized
        ///       using the formatter provided.
        ///    </para>
        /// </devdoc>
        public void Send(object obj, string label) {        
            Send(obj, label, null, MessageQueueTransactionType.None);                
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Send3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends an object to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>.
        ///       The object will be serialized
        ///       using the formatter provided.
        ///    </para>
        /// </devdoc>
        public void Send(object obj, string label, MessageQueueTransaction transaction) {        
            if (transaction == null)             
                throw new ArgumentNullException("transaction");
            
            Send(obj, label, transaction, MessageQueueTransactionType.None);                
        }
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.Send4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sends an object to the queue referenced by this <see cref='System.Messaging.MessageQueue'/>.
        ///       The object will be serialized
        ///       using the formatter provided.
        ///    </para>
        /// </devdoc>
        public void Send(object obj, string label, MessageQueueTransactionType transactionType) {        
            if (!Enum.IsDefined(typeof(MessageQueueTransactionType), transactionType)) 
                throw new InvalidEnumArgumentException("transactionType", (int)transactionType, typeof(MessageQueueTransactionType));                                        
                
            Send(obj, label, null, transactionType);                            
        }
        
        private void Send(object obj, string label, MessageQueueTransaction transaction, MessageQueueTransactionType transactionType) {        
            if (label == null) 
                throw new ArgumentNullException("label");
                                            
            if (obj is Message) {
                ((Message)obj).Label = label;
                SendInternal(obj, transaction, transactionType);            
            }
            else {
                string oldLabel = this.DefaultPropertiesToSend.Label;                                
                try {
                    this.DefaultPropertiesToSend.Label = label;
                    SendInternal(obj, transaction, transactionType);            
                }
                finally {
                    this.DefaultPropertiesToSend.Label = oldLabel;
                }                    
            }                
        }
                
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SendInternal"]/*' />
        /// <internalonly/>        
        private void SendInternal(object obj, MessageQueueTransaction internalTransaction, MessageQueueTransactionType transactionType) {                      
            if (!sendGranted) {                    
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Send, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
                    
                sendGranted = true;                                    
            }
                        
            Message message = null;
            if (obj is Message) 
                message = (Message)obj;                
            
            if (message == null) {
                message = this.DefaultPropertiesToSend.CachedMessage;                     
                message.Formatter = this.Formatter;
                message.Body = obj;
            }

            //Write cached properties and if message is being forwarded Clear queue specific properties            
            int status = 0;            
            message.AdjustToSend();                                                                                               
            MessagePropertyVariants.MQPROPS properties = message.Lock();
            try {
                if (internalTransaction != null) 
                    status = StaleSafeSendMessage(properties, internalTransaction.BeginQueueOperation());                
                else 
                    status = StaleSafeSendMessage(properties, (IntPtr)transactionType);                                    
            }
            finally {                                    
                message.Unlock();
                
                if (internalTransaction != null) 
                    internalTransaction.EndQueueOperation();
            }                

            if (MessageQueue.IsFatalError(status))
                throw new MessageQueueException(status);

        }
                 
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ResolveQueueFromLabel"]/*' />
        /// <internalonly/>
        private static MessageQueue ResolveQueueFromLabel(string path, bool throwException) {            
            MessageQueue[] queues = GetPublicQueuesByLabel(path.Substring(PREFIX_LABEL.Length), false);
            if (queues.Length == 0) {
                if (throwException)
                    throw new InvalidOperationException(Res.GetString(Res.InvalidLabel, path.Substring(PREFIX_LABEL.Length)));
                    
                return null;         
            }                       
            else if (queues.Length > 1)
                throw new InvalidOperationException(Res.GetString(Res.AmbiguousLabel, path.Substring(PREFIX_LABEL.Length)));

            return queues[0];            
        }
        
        /// <internalonly/>
        private static string ResolveFormatNameFromQueuePath(string queuePath, bool throwException) {                    
            string machine = queuePath.Substring(0, queuePath.IndexOf('\\'));
            //The name includes the \\
            string name = queuePath.Substring(queuePath.IndexOf('\\'));
             //Check for machine DeadLetter or Journal
            if (String.Compare(name, SUFIX_DEADLETTER, true, CultureInfo.InvariantCulture) == 0 ||
                String.Compare(name, SUFIX_DEADXACT, true, CultureInfo.InvariantCulture) == 0 ||
                String.Compare(name, SUFIX_JOURNAL, true, CultureInfo.InvariantCulture) == 0) {
                //Need to get the machine Id to construct the format name.
    
                if (machine.CompareTo(".") == 0)
                    machine = MessageQueue.ComputerName;

                //Create a guid to get the right format.
                Guid machineId = MessageQueue.GetMachineId(machine);
                StringBuilder newFormatName = new StringBuilder();
                //System format names:
                //MACHINE=guid;DEADXACT
                //MACHINE=guid;DEADLETTER
                //MACHINE=guid;JOURNAL
                newFormatName.Append("MACHINE=");
                newFormatName.Append(machineId.ToString());
                if (String.Compare(name, SUFIX_DEADXACT, true, CultureInfo.InvariantCulture) == 0)
                    newFormatName.Append(";DEADXACT");
                else if (String.Compare(name, SUFIX_DEADLETTER, true, CultureInfo.InvariantCulture) == 0)
                    newFormatName.Append(";DEADLETTER");
                else
                    newFormatName.Append(";JOURNAL");

                return newFormatName.ToString();
            }
            else {
                string realPath = queuePath;
                bool journal = false;
                if (queuePath.ToUpper(CultureInfo.InvariantCulture).EndsWith(SUFIX_JOURNAL)) {
                    journal = true;
                    int lastIndex = realPath.LastIndexOf('\\');
                    realPath = realPath.Substring(0, lastIndex);
                }

                int result;
                int status = 0;
                StringBuilder newFormatName = new StringBuilder(NativeMethods.MAX_LABEL_LEN);
                result = NativeMethods.MAX_LABEL_LEN;
                status = SafeNativeMethods.MQPathNameToFormatName(realPath, newFormatName, ref result);
                if (status != 0) {
                    if (throwException)
                        throw new MessageQueueException(status);    
                    else if (status == (int)MessageQueueErrorCode.IllegalQueuePathName)
                        throw new MessageQueueException(status);    
                                                                    
                    return null;                        
                }                    

                if (journal)
                    newFormatName.Append(";JOURNAL");

                return newFormatName.ToString();
            }
        } 

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ResetPermissions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetPermissions() {
            if (!administerGranted) {                    
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Administer, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
                
                administerGranted = true;
            }                    
            
            int result = UnsafeNativeMethods.MQSetQueueSecurity(FormatName, NativeMethods.DACL_SECURITY_INFORMATION, null);
            if (result != NativeMethods.MQ_OK) 
                throw new MessageQueueException(result);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SetPermissions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetPermissions(string user, MessageQueueAccessRights rights) {
            if (user == null)
                throw new ArgumentNullException("user");

            SetPermissions(user, rights, AccessControlEntryType.Allow);            
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SetPermissions1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetPermissions(string user, MessageQueueAccessRights rights, AccessControlEntryType entryType) {
            if (user == null)
                throw new ArgumentNullException("user");
                        
            Trustee t = new Trustee(user);
            MessageQueueAccessControlEntry ace = new MessageQueueAccessControlEntry(t, rights, entryType);
            AccessControlList dacl = new AccessControlList();
            dacl.Add(ace);
            SetPermissions(dacl);
        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SetPermissions2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetPermissions(MessageQueueAccessControlEntry ace) {       
            if (ace == null)
                throw new ArgumentNullException("ace");
                                                                                                
            AccessControlList dacl = new AccessControlList();
            dacl.Add(ace);
            SetPermissions(dacl);
        }
                
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.SetPermissions3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetPermissions(AccessControlList dacl) {                            
            if (dacl == null)
                throw new ArgumentNullException("dacl");
                
            if (!administerGranted) {                    
                MessageQueuePermission permission = new MessageQueuePermission(MessageQueuePermissionAccess.Administer, PREFIX_FORMAT_NAME + this.FormatName);
                permission.Demand();
                
                administerGranted = true;
            }                                    

            //Access control is not supported in Win9x, need to check
            //the environment and take appropriate action.
            AccessControlList.CheckEnvironment();
                                              
            byte[] SecurityDescriptor = new byte[100];
            int lengthNeeded = 0;
            int mqResult;

            GCHandle sdHandle = GCHandle.Alloc(SecurityDescriptor, GCHandleType.Pinned);
            try {
                mqResult = UnsafeNativeMethods.MQGetQueueSecurity(FormatName,
                                                             NativeMethods.DACL_SECURITY_INFORMATION,
                                                             (INTPTR_INTPTRCAST)sdHandle.AddrOfPinnedObject(),
                                                             SecurityDescriptor.Length,
                                                             out lengthNeeded);

                if (mqResult == NativeMethods.MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL) {
                    sdHandle.Free();
                    SecurityDescriptor = new byte[lengthNeeded];
                    sdHandle = GCHandle.Alloc(SecurityDescriptor, GCHandleType.Pinned);
                    mqResult = UnsafeNativeMethods.MQGetQueueSecurity(FormatName,
                                                                 NativeMethods.DACL_SECURITY_INFORMATION,
                                                                 (INTPTR_INTPTRCAST)sdHandle.AddrOfPinnedObject(),
                                                                 SecurityDescriptor.Length,
                                                                 out lengthNeeded);
                }
                
                if (mqResult != NativeMethods.MQ_OK) {
                    throw new MessageQueueException(mqResult);
                }

                bool daclPresent, daclDefaulted;
                IntPtr pDacl;
                bool success = UnsafeNativeMethods.GetSecurityDescriptorDacl((INTPTR_INTPTRCAST)sdHandle.AddrOfPinnedObject(),
                                                                                out daclPresent,
                                                                                out pDacl,
                                                                                out daclDefaulted);

                if (!success) 
                    throw new Win32Exception();

                // At this point we have the DACL for the queue.  Now we need to create
                // a new security descriptor with an updated DACL.
                
                NativeMethods.SECURITY_DESCRIPTOR newSecurityDescriptor = new NativeMethods.SECURITY_DESCRIPTOR();
                UnsafeNativeMethods.InitializeSecurityDescriptor(newSecurityDescriptor,
                                                                    NativeMethods.SECURITY_DESCRIPTOR_REVISION);
                IntPtr newDacl = dacl.MakeAcl(pDacl);
                try {
                    success = UnsafeNativeMethods.SetSecurityDescriptorDacl(newSecurityDescriptor,
                                                                               true,
                                                                               newDacl,
                                                                               false);

                    if (!success)
                        throw new Win32Exception();

                    int result = UnsafeNativeMethods.MQSetQueueSecurity(FormatName,
                                                                   NativeMethods.DACL_SECURITY_INFORMATION,
                                                                   newSecurityDescriptor);
                    
                    if (result != NativeMethods.MQ_OK)
                        throw new MessageQueueException(result);
                }
                finally {
                    AccessControlList.FreeAcl(newDacl);
                }

                //If the format name has been cached, let's
                //remove it, since the process might no longer
                //have access to the corresponding queue.                                
                queueInfoCache.Remove(FormatName);                                    
                formatNameCache.Remove(path);
            }
            finally {
                if (sdHandle.IsAllocated)
                    sdHandle.Free();
            }

        }

        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.ValidatePath"]/*' />
        /// <internalonly/>
        internal static bool ValidatePath(string path, bool checkQueueNameSize) {
            if (path == null || path == "")
                return true;

            String upperPath = path.ToUpper(CultureInfo.InvariantCulture);
            if (upperPath.StartsWith(PREFIX_LABEL))
                return true;

            if (upperPath.StartsWith(PREFIX_FORMAT_NAME))
                return true;

            int number = 0;
            int index = -1;
            while (true) {
                int newIndex = upperPath.IndexOf('\\', index + 1);
                if (newIndex == -1)
                    break;
                else
                    index = newIndex;

                ++number;
            }

            if (number == 1) {
                if (checkQueueNameSize) {
                    long length = path.Length - (index + 1);
                    if (length > 255)
                        throw new ArgumentException(Res.GetString(Res.LongQueueName));
                }
                return true;
            }

            if (number == 2) {
                if (upperPath.EndsWith(SUFIX_JOURNAL))
                    return true;

                index = upperPath.LastIndexOf(SUFIX_PRIVATE + "\\");
                if (index != -1)
                    return true;
            }

            if (number == 3 && upperPath.EndsWith(SUFIX_JOURNAL)) {
                index = upperPath.LastIndexOf(SUFIX_PRIVATE + "\\");
                if (index != -1)
                    return true;
            }

            return false;
        }                
        
        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.QueuePropertyFilter"]/*' />
        /// <internalonly/>
        private class QueuePropertyFilter {
            public bool Authenticate;
            public bool BasePriority;
            public bool CreateTime;
            public bool EncryptionLevel;
            public bool Id;
            public bool Transactional;
            public bool Label;
            public bool LastModifyTime;
            public bool MaximumJournalSize;
            public bool MaximumQueueSize;            
            public bool Path;            
            public bool Category;
            public bool UseJournalQueue;

            public void ClearAll() {
                Authenticate = false;
                BasePriority = false;
                CreateTime = false;
                EncryptionLevel = false;
                Id = false;
                Transactional = false;
                Label = false;
                LastModifyTime = false;
                MaximumJournalSize = false;
                MaximumQueueSize = false;
                Path = false;                
                Category = false;
                UseJournalQueue = false;
            }
        }


        /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest"]/*' />
        /// <devdoc>
        ///    This class is used in asynchronous operations,
        ///    it keeps the context under which the asynchronous
        ///    request was posted.
        /// </devdoc>
        /// <internalonly/>
        private class AsynchronousRequest : IAsyncResult {            
            private IOCompletionCallback onCompletionStatusChanged;        
            private SafeNativeMethods.ReceiveCallback onMessageReceived;
            private AsyncCallback callback;
            private ManualResetEvent resetEvent;
            private object asyncState;            
            private MessageQueue owner;
            private bool isCompleted = false;
            private int status = 0;
            private Message message;
            private int action;
            private uint timeout;


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.AsynchronousRequest"]/*' />
            /// <devdoc>
            ///    Creates a new asynchronous request that 
            ///    represents a pending asynchronous operation.
            /// </devdoc>
            /// <internalonly/>
            internal unsafe AsynchronousRequest(MessageQueue owner, uint timeout, int action, bool useThreadPool, object asyncState, AsyncCallback callback) {
                this.owner = owner;
                this.asyncState = asyncState;
                this.callback = callback;
                this.action = action;   
                this.timeout = timeout;                                                 
                this.resetEvent = new ManualResetEvent(false);

                if (!useThreadPool)
                    this.onMessageReceived = new SafeNativeMethods.ReceiveCallback(this.OnMessageReceived);
                else
                    this.onCompletionStatusChanged = new IOCompletionCallback(this.OnCompletionStatusChanged);  
            }


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.Action"]/*' />
            /// <internalonly/>
            internal int Action {
                get {
                    return this.action;
                }
            }              


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.AsyncObject"]/*' />
            /// <devdoc>
            ///    IAsyncResult implementation        
            /// </devdoc>            
            public object AsyncObject {
                get {                    
                    return this.owner;
                }
            }


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.AsyncState"]/*' />
            /// <devdoc>
            ///    IAsyncResult implementation        
            /// </devdoc>            
            public object AsyncState {
                get {
                    return this.asyncState;
                }
            }


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.AsyncWaitHandle"]/*' />
            /// <devdoc>
            ///    IAsyncResult implementation        
            /// </devdoc>           
            public WaitHandle AsyncWaitHandle {
                get {
                    return this.resetEvent;
                }
            }


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.CompletedSynchronously"]/*' />
            /// <devdoc>
            ///    IAsyncResult implementation        
            /// </devdoc>            
            public bool CompletedSynchronously {
                get {
                    return false;
                }
            }            

            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.IsCompleted"]/*' />
            /// <devdoc>
            ///    IAsyncResult implementation        
            /// </devdoc>
            /// <internalonly/>
            public bool IsCompleted {
                get {
                    return this.isCompleted;
                }
            }                


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.BeginRead"]/*' />
            /// <devdoc>
            ///   Does the actual asynchronous receive posting.
            /// </devdoc>
            /// <internalonly/>            
            internal unsafe void BeginRead() {
                NativeOverlapped* overlappedPointer = null;
                if (this.onCompletionStatusChanged != null) {
                    Overlapped overlapped = new Overlapped();
                    overlapped.AsyncResult = this;                        
                    overlappedPointer = overlapped.Pack(this.onCompletionStatusChanged);
                }

                int localStatus = 0;                
                this.message = new Message(owner.MessageReadPropertyFilter);                                                                             
                localStatus =  this.owner.StaleSafeReceiveMessage(this.timeout, this.action, this.message.Lock(), overlappedPointer, this.onMessageReceived, (IntPtr)0, (IntPtr)0);                                 
                while (MessageQueue.IsMemoryError(localStatus)) {
                    this.message.Unlock();
                    this.message.AdjustMemory();
                    localStatus =  this.owner.StaleSafeReceiveMessage(this.timeout, this.action, this.message.Lock(), overlappedPointer, this.onMessageReceived, (IntPtr)0, (IntPtr)0);                                                     
                }

                if (MessageQueue.IsFatalError(localStatus)) 
                    RaiseCompletionEvent(localStatus, overlappedPointer);                                
            }

           
            
            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.End"]/*' />
            /// <devdoc>
            ///   Waits until the request has been completed.
            /// </devdoc>
            /// <internalonly/>            
            internal Message End() {
                this.resetEvent.WaitOne();
                if (MessageQueue.IsFatalError(status))
                    throw new MessageQueueException(status);

                if (this.owner.formatter != null)
                    this.message.Formatter = (IMessageFormatter)this.owner.formatter.Clone();

                return this.message;
            }           

            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.OnCompletionStatusChanged"]/*' />
            /// <devdoc>
            ///   Thread pool IOCompletionPort bound callback.
            /// </devdoc>
            /// <internalonly/>            
            private unsafe void OnCompletionStatusChanged(uint  errorCode, uint numBytes, NativeOverlapped  * overlappedPointer) {
                int result = 0;            
                if (errorCode != 0) {
                    // MSMQ does a hacky trick to return the operation 
                    // result through the completion port.
                    result = overlappedPointer->InternalLow;              
                }

                RaiseCompletionEvent(result, overlappedPointer);                                                                             
            }


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.OnMessageReceived"]/*' />
            /// <devdoc>
            ///   MSMQ APC based callback.
            /// </devdoc>
            /// <internalonly/>
            private unsafe void OnMessageReceived(int result, IntPtr handle, int timeout, int action, IntPtr propertiesPointer, NativeOverlapped  * overlappedPointer, IntPtr cursorHandle) {
                RaiseCompletionEvent(result, overlappedPointer);                                                
            }                        


            /// <include file='doc\MessageQueue.uex' path='docs/doc[@for="MessageQueue.AsynchronousRequest.RaiseCompletionEvent"]/*' />
            /// <internalonly/>            
            private unsafe void RaiseCompletionEvent(int result, NativeOverlapped  * overlappedPointer) {
                
                if (MessageQueue.IsMemoryError(result)) {
                    while (MessageQueue.IsMemoryError(result)) {
                        this.message.Unlock();
                        this.message.AdjustMemory();
                        result =  this.owner.StaleSafeReceiveMessage(this.timeout, this.action, this.message.Lock(), overlappedPointer, this.onMessageReceived, (IntPtr)0, (IntPtr)0);                                                     
                    }

                    if (!MessageQueue.IsFatalError(result))                         
                        return;
                    
                }

                this.message.Unlock();                            
                
                if (result == (int)MessageQueueErrorCode.StaleHandle || status == (int)MessageQueueErrorCode.QueueDeleted) {
                    this.owner.MQInfo.Close();
                    result =  this.owner.StaleSafeReceiveMessage(this.timeout, this.action, this.message.Lock(), overlappedPointer, this.onMessageReceived, (IntPtr)0, (IntPtr)0);                                                     
                    if (!MessageQueue.IsFatalError(result))
                        return;    
                }
                
                this.status = result;
                if (overlappedPointer != null)
                    Overlapped.Free(overlappedPointer);

                this.isCompleted = true;                                                                            
                this.resetEvent.Set();

                try {
                    if (this.owner.SynchronizingObject != null &&
                        this.owner.SynchronizingObject.InvokeRequired)
                        this.owner.SynchronizingObject.BeginInvoke(this.callback, new object[]{this});
                    else
                        this.callback(this);
                }
                catch (Exception) {
                    //No top level exception handler, exception is ignored.
                    //Consider, V2, top level exception handler infrastructure.
                }
            }            
        }        
                
        private int StaleSafePurgeQueue() {
            int status = UnsafeNativeMethods.MQPurgeQueue(MQInfo.ReadHandle);
            if (status == (int)MessageQueueErrorCode.StaleHandle || status == (int)MessageQueueErrorCode.QueueDeleted) {
                MQInfo.Close();
                status = UnsafeNativeMethods.MQPurgeQueue(MQInfo.ReadHandle);
            }
            return status;
        }

        private int StaleSafeSendMessage(MessagePropertyVariants.MQPROPS properties, IntPtr transaction) {
            int status = UnsafeNativeMethods.MQSendMessage(MQInfo.WriteHandle, properties, transaction);
            if (status == (int)MessageQueueErrorCode.StaleHandle || status == (int)MessageQueueErrorCode.QueueDeleted) {
                MQInfo.Close();
                status = UnsafeNativeMethods.MQSendMessage(MQInfo.WriteHandle, properties, transaction);
            }
            return status;
        }

        private int StaleSafeSendMessage(MessagePropertyVariants.MQPROPS properties, ITransaction transaction) {
            int status = UnsafeNativeMethods.MQSendMessage(MQInfo.WriteHandle, properties, transaction);
            if (status == (int)MessageQueueErrorCode.StaleHandle || status == (int)MessageQueueErrorCode.QueueDeleted) {
                MQInfo.Close();
                status = UnsafeNativeMethods.MQSendMessage(MQInfo.WriteHandle, properties, transaction);
            }
            return status;
        }

        internal unsafe int StaleSafeReceiveMessage(uint timeout, int action, MessagePropertyVariants.MQPROPS properties, NativeOverlapped * overlapped,
                                                                                           SafeNativeMethods.ReceiveCallback receiveCallback, IntPtr cursorHandle, IntPtr transaction) {
            int status = UnsafeNativeMethods.MQReceiveMessage(MQInfo.ReadHandle, timeout, action, properties, overlapped, receiveCallback, cursorHandle, transaction);
            if (status == (int)MessageQueueErrorCode.StaleHandle || status == (int)MessageQueueErrorCode.QueueDeleted) {
                MQInfo.Close();
                status = UnsafeNativeMethods.MQReceiveMessage(MQInfo.ReadHandle, timeout, action, properties, overlapped, receiveCallback, cursorHandle, transaction);
            }
            return status;
        }

        private unsafe int StaleSafeReceiveMessage(uint timeout, int action, MessagePropertyVariants.MQPROPS properties, NativeOverlapped * overlapped, 
                                                                                           SafeNativeMethods.ReceiveCallback receiveCallback, IntPtr cursorHandle, ITransaction transaction) {
            int status = UnsafeNativeMethods.MQReceiveMessage(MQInfo.ReadHandle, timeout, action, properties, overlapped, receiveCallback, cursorHandle, transaction);
            if (status == (int)MessageQueueErrorCode.StaleHandle || status == (int)MessageQueueErrorCode.QueueDeleted) {
                MQInfo.Close();
                status = UnsafeNativeMethods.MQReceiveMessage(MQInfo.ReadHandle, timeout, action, properties, overlapped, receiveCallback, cursorHandle, transaction);
            }
            return status;
        }

        internal class CacheTable {
            private Hashtable table;
            private ReaderWriterLock rwLock;
    
            // used for debugging
            private string name;
    
            // when the number of entries in the hashtable gets larger than capacity,
            // the "stale" entries are removed and capacity is reset to twice the number
            // of remaining entries
            private int capacity;  
            private int originalCapacity;
    
            // time, in seconds, after which an entry is considerred stale (if the reference
            // count is zero)
            private TimeSpan staleTime;
        
            public CacheTable(string name, int capacity, TimeSpan staleTime) {
                this.originalCapacity = capacity;
                this.capacity = capacity;
                this.staleTime = staleTime;
                this.name = name;
                this.rwLock = new System.Threading.ReaderWriterLock();
                this.table = new System.Collections.Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            }
        
            public object Get(string key) {
                object val = null;
                rwLock.AcquireReaderLock(-1);
                CacheEntry entry = (CacheEntry)table[key];
                if (entry != null) {
                    entry.timeStamp = System.DateTime.UtcNow;
                    val = entry.contents;                    
                }   
                rwLock.ReleaseReaderLock();
                return val;
            }
        
            public void Put(string key, object val) {
                rwLock.AcquireWriterLock(-1);
                if (val == null) {
                    table[key] = null;
                } else {
                    CacheEntry entry = (CacheEntry)table[key];
                    if (entry == null) {
                        entry = new CacheEntry();
                        table[key] = entry;
                        if (table.Count >= capacity) {
                            ClearStale(staleTime);
                        }
        
                    }
                    entry.timeStamp = System.DateTime.UtcNow;
                    entry.contents = val;
                }
                rwLock.ReleaseWriterLock();
            }
    
            public void Remove(string key) {
                rwLock.AcquireWriterLock(-1);
                if (table.Contains(key))
                    table.Remove(key);
                rwLock.ReleaseWriterLock();
            }
    
            public void ClearStale(TimeSpan staleAge) {
                DateTime now = System.DateTime.UtcNow;
                Hashtable newTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
    
                rwLock.AcquireReaderLock(-1);
                foreach (DictionaryEntry DE in table) {
                    CacheEntry iterEntry = (CacheEntry)DE.Value;
    
                    // see if this entry is stale (ticks are 100 nano-sec.)
                    if (now - iterEntry.timeStamp < staleAge) {
                        newTable[DE.Key] = DE.Value;
                    }
                }
                rwLock.ReleaseReaderLock();
    
                rwLock.AcquireWriterLock(-1);
                table = newTable;
                capacity = 2*table.Count;
                if (capacity < originalCapacity) capacity = originalCapacity;
                rwLock.ReleaseWriterLock();
            }
    
            private class CacheEntry {
                public object contents;
                public DateTime timeStamp;
            }
        
        }    

        internal class MQCacheableInfo {
            private IntPtr readHandle      = (IntPtr)(-1);
            private IntPtr writeHandle     = (IntPtr)(-1);
            private bool isTransactional;
            private bool isTransactional_valid = false;
            private bool boundToThreadPool;
            private string formatName;
            private int shareMode;
            private int refCount;
            private bool disposed;

            public MQCacheableInfo(string formatName, int shareMode) {
                this.formatName = formatName;
                this.shareMode = shareMode;
            }            

            ~MQCacheableInfo() {
                Dispose(false);
            }
            
            public bool CanRead {
                get {
                    if (readHandle == (IntPtr)(-1)) {
                        if (this.disposed)
                            throw new ObjectDisposedException(GetType().Name);
                        
                        lock(this) {
                            if (readHandle == (IntPtr)(-1)) {
                                IntPtr result;
                                int status = UnsafeNativeMethods.MQOpenQueue(this.formatName, NativeMethods.QUEUE_ACCESS_RECEIVE, shareMode, out result);
                                if (MessageQueue.IsFatalError(status))
                                    return false;

                                readHandle = result;
                            }
                        }
                    }
                    
                    return true;
                }
            }


            public bool CanWrite {
                get {
                    if (writeHandle == (IntPtr)(-1)) {
                        if (this.disposed)
                            throw new ObjectDisposedException(GetType().Name);
                        
                        lock(this) {
                            if (writeHandle == (IntPtr)(-1)) {
                                IntPtr result;
                                int status = UnsafeNativeMethods.MQOpenQueue(this.formatName, NativeMethods.QUEUE_ACCESS_SEND, 0, out result);
                                if (MessageQueue.IsFatalError(status))
                                    return false;

                                writeHandle = result;
                            }
                        }
                    }
            
                    return true;
                }
            }

            public int RefCount {
                get {
                    return this.refCount;
                }
                
                set {
                    this.refCount = value;
                }
            }

            public IntPtr ReadHandle {
                get {
                    if (readHandle == (IntPtr)(-1)) {
                        if (this.disposed)
                            throw new ObjectDisposedException(GetType().Name);
                        
                        lock(this) {
                            if (readHandle == (IntPtr)(-1)) {
                                IntPtr result;
                                int status = UnsafeNativeMethods.MQOpenQueue(this.formatName, NativeMethods.QUEUE_ACCESS_RECEIVE, shareMode, out result);                                
                                if (MessageQueue.IsFatalError(status))
                                    throw new MessageQueueException(status);

                                readHandle = result;
                            }
                        }
                    }

                    return readHandle;
                }